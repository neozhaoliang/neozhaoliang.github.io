<!DOCTYPE HTML>
<html>

<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SHQJ7GP8MM"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'G-SHQJ7GP8MM');
    </script>

    <meta charset="utf-8">
        
    

    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    

        <title>
            Schur 多项式与钩长公式 | Why so serious?</title>
    <meta name="author" content="Zhao Liang">
    
    <meta name="description" content="在数学中有那么一些问题，它们的表述简单而初等，但是解决起来却非常困难，往往需要相当的奇思妙想和深刻的工具。围绕这些问题。不同领域的数学相互交织，演绎出许多奇妙的故事。
Young
表就是一个典型的例子，组合数学，表示论，概率论在这里发生了奇妙的交汇。
我们从一个有趣的问题开始：

问题： \(n\)
位选民要在一次选举中给 \(m\)
个候选人投票，每个选民只能投一票。已知第 \(i\) 位候选人最终的得票数为 \(\lambda_i\)，这里 \(\sum_{i=1}^m\lambda_i=n\) 且 \(\lambda_1\geq\cdots\geq\lambda_m\)。问题是：有多少种不同的得票序列，使得在投票过程中的任一时刻，对任何的
\(i&amp;lt;j\)，第 \(i\) 位候选人所得的票数总不少于第 \(j\) 位候选人所得的票数？
举个例子，假设有 \(n=10\) 位选民和
\(m=4\) 个候选人，则得票序列 \[1, 2, 1, 3, 2, 1, 2, 4, 3, 1\]
表示第一个选民投票给 1 号，第二个选民投票给 2 号，第三个选民投票给 1
号，第四个选民投票给 3 号，依次类推。符合问题要求的序列必须满足对任何
\(1\leq k\leq n\) 和 \(1\leq i&amp;lt;j\leq m\)，序列的前 \(k\) 项中数字 \(i\) 出现的次数都大于等于数字 \(j\) 出现的次数。

虽然问题的表述很简单，但其实答案相当复杂，叫做钩长公式 (hook length
formula)。钩长公式有好几个证明，但我最喜欢的证明是基于 Schur
多项式的理论，接下来就来介绍它。">
    
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta property="og:title" content="Schur 多项式与钩长公式"/>
    <meta property="og:site_name" content="Why so serious?"/>

    
    <meta property="og:image" content=""/>
    


    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="alternate" href="/atom.xml" title="Why so serious?" type="application/atom+xml">
    <link rel="stylesheet" href="/css/lib/materialize.min.css">
    <link rel="stylesheet" href="/css/lib/font-awesome.min.css">
    <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

    
        <link rel="stylesheet" href="/css/lib/desert.css" type="text/css">
    
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
        </script>

<meta name="generator" content="Hexo 5.4.2">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

    <body>
        <amp-auto-ads type="adsense" data-ad-client="ca-pub-2761554655832112">
        </amp-auto-ads>
        <img src="/favicon.png" style="position: absolute; left: -9999px; opacity: 0; filter: alpha(opacity=0);">

        <nav class="indigo">
    <div class="nav-wrapper">
        <a href="#" data-activates="main-menu" class="button-collapse">
            <i class="fa fa-navicon"></i>
        </a>
        <div class="">
            <a href="/" class="brand-logo hide-on-med-and-down">Why so serious?</a>
            <ul class="right hide-on-med-and-down">
                
                    <li>
                        <a class="menu-home " href="/" >
                            <i class="fa fa-home "></i>
                            
                            首页
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-archive " href="/archives" >
                            <i class="fa fa-archive "></i>
                            
                            归档
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-category category-menu" href="javascript:;" data-activates="category-menu" >
                            <i class="fa fa-bookmark "></i>
                            
                            分类
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-about " href="/about" >
                            <i class="fa fa-user "></i>
                            
                            关于
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-search modal-trigger " href="#search" >
                            <i class="fa fa-search "></i>
                            
                            搜索
                        </a>
                    </li>
                
            </ul>
            <div>
    <ul class="side-nav indigo darken-1" id="main-menu">
        
        <li class="side-user">
            <div class="row">
                <div class="col s4 no-padding">
                    <img class="avatar-image circle responsive-img" src="/favicon.png" alt="User Avatar">
                </div>
                <div class="info col s8 valign-wrapper no-padding">
                    <div class="valign">
                        <p class="name">Zhao Liang</p>
                        <p class="desc">math &amp;&amp; programming</p>
                    </div>
                </div>
            </div>
        </li>
        

        
            <li class="no-padding">
                <a class="waves-effect menu-home " href="/" >
                    <i class="fa fa-home "></i>
                    
                    首页
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-archive " href="/archives" >
                    <i class="fa fa-archive "></i>
                    
                    归档
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-category category-menu" href="javascript:;" data-activates="category-menu" >
                    <i class="fa fa-bookmark "></i>
                    
                    分类
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-about " href="/about" >
                    <i class="fa fa-user "></i>
                    
                    关于
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-search modal-trigger " href="#search" >
                    <i class="fa fa-search "></i>
                    
                    搜索
                </a>
            </li>
        
    </ul>

    <ul class="side-nav indigo darken-1" id="category-menu">
    

            

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/计数组合学/">
                    计数组合学 <span class="right">5 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Durrett-概率论批判/">
                    Durrett-概率论批判 <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/完美采样/">
                    完美采样 <span class="right">2 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/几何群论/">
                    几何群论 <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/有限群表示与结合代数/">
                    有限群表示与结合代数 <span class="right">5 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/pywonderland-项目/">
                    pywonderland-项目 <span class="right">5 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Shadertoy/">
                    Shadertoy <span class="right">2 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/线性代数/">
                    线性代数 <span class="right">3 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/可视化复分析/">
                    可视化复分析 <span class="right">4 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/随机游动/">
                    随机游动 <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/代数/">
                    代数 <span class="right">1 篇</span></a>
                </a>
            </li>

        

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Williams-概率和鞅/">
                    Williams-概率和鞅 <span class="right">4 篇</span></a>
                </a>
            </li>

        

    </ul>
</div>

        </div>
    </div>
</nav>

<div id="search" class="modal search-modal">
    <div class="row">
        <div class="input-field col s12">
              <input id="search-input" type="text">
              <label for="search-input">搜索</label>
        </div>

    </div>
    <div id="search-result" class="search-result col s12">

    </div>
</div>


            <main>
                <div class="container main-container">
    <nav class="page-nav hide-on-small-only">
    <div class="nav-wrapper indigo">
        <span class="breadcrumb">当前位置（分类目录）</span>
        
            
    
    
    <a class="breadcrumb" href="/categories/计数组合学/">计数组合学</a>


        

        
    </div>
</nav>

    <article>
        <div class="card">
            <div class="card-content">
                

                            <div class="article-title">
                                
    
        <h1>Schur 多项式与钩长公式</h1>
    


                            </div>
                            <time class="pink-link-context" datetime="2011-04-03T16:00:00.000Z"><a href="/schur-polynomials-and-hook-length-formula/">2011-04-04</a></time>

                                

                                    <div class="toc pink-link-context hide-on-med-and-down">
    <ol class="section table-of-contents"><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#schur-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E7%9A%84%E7%BB%84%E5%90%88%E5%AE%9A%E4%B9%89"><span class="section table-of-contents-text">Schur 多项式的组合定义</span></a></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#bender-knuth-%E5%AF%B9%E5%90%88"><span class="section table-of-contents-text">Bender-Knuth 对合</span></a></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#jacobi-trudi-%E6%81%92%E7%AD%89%E5%BC%8F"><span class="section table-of-contents-text">Jacobi-Trudi 恒等式</span></a></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#bi-alternant-%E5%85%AC%E5%BC%8F"><span class="section table-of-contents-text">Bi-alternant 公式</span></a></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#%E9%92%A9%E9%95%BF%E5%85%AC%E5%BC%8F"><span class="section table-of-contents-text">钩长公式</span></a></li><li class="section table-of-contents-item section table-of-contents-level-1"><a class="section table-of-contents-link" href="#bibliography"><span class="section table-of-contents-text">References</span></a></li></ol>
</div>
                                        
                                            <div class="entry pink-link-context">
                                                
<p>在数学中有那么一些问题，它们的表述简单而初等，但是解决起来却非常困难，往往需要相当的奇思妙想和深刻的工具。围绕这些问题。不同领域的数学相互交织，演绎出许多奇妙的故事。</p>
<p>Young
表就是一个典型的例子，组合数学，表示论，概率论在这里发生了奇妙的交汇。</p>
<p>我们从一个有趣的问题开始：</p>
<div class="unnumbered statement question-unnumbered definition">
<p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span><span class="math inline">\(n\)</span>
位选民要在一次选举中给 <span class="math inline">\(m\)</span>
个候选人投票，每个选民只能投一票。已知第 <span class="math inline">\(i\)</span> 位候选人最终的得票数为 <span class="math inline">\(\lambda_i\)</span>，这里 <span class="math inline">\(\sum_{i=1}^m\lambda_i=n\)</span> 且 <span class="math inline">\(\lambda_1\geq\cdots\geq\lambda_m\)</span>。问题是：有多少种不同的得票序列，使得在投票过程中的任一时刻，对任何的
<span class="math inline">\(i&lt;j\)</span>，第 <span class="math inline">\(i\)</span> 位候选人所得的票数总不少于第 <span class="math inline">\(j\)</span> 位候选人所得的票数？</p>
<p>举个例子，假设有 <span class="math inline">\(n=10\)</span> 位选民和
<span class="math inline">\(m=4\)</span> 个候选人，则得票序列 <span class="math display">\[1, 2, 1, 3, 2, 1, 2, 4, 3, 1\]</span>
表示第一个选民投票给 1 号，第二个选民投票给 2 号，第三个选民投票给 1
号，第四个选民投票给 3 号，依次类推。符合问题要求的序列必须满足对任何
<span class="math inline">\(1\leq k\leq n\)</span> 和 <span class="math inline">\(1\leq i&lt;j\leq m\)</span>，序列的前 <span class="math inline">\(k\)</span> 项中数字 <span class="math inline">\(i\)</span> 出现的次数都大于等于数字 <span class="math inline">\(j\)</span> 出现的次数。</p>
</div>
<p>虽然问题的表述很简单，但其实答案相当复杂，叫做钩长公式 (hook length
formula)。钩长公式有好几个证明，但我最喜欢的证明是基于 Schur
多项式的理论，接下来就来介绍它。</p>
<span id="more"></span>
<h1 id="schur-多项式的组合定义">Schur 多项式的组合定义</h1>
<p>设 <span class="math inline">\(\lambda=(\lambda_1,\lambda_2,\ldots)\)</span>
是一个非负整数构成的序列，且只有有限多个非零项。如果它满足 <span class="math inline">\(\lambda_1\geq \lambda_2\geq\cdots\)</span>，则称
<span class="math inline">\(\lambda\)</span>
是一个整数分拆，简称分拆，并记 <span class="math inline">\(|\lambda|=\sum\limits_{i=1}^\infty
\lambda_i\)</span>。由于 <span class="math inline">\(\lambda\)</span>
只有有限多项非 0，<span class="math inline">\(|\lambda|\)</span>
总是有限的。如果 <span class="math inline">\(|\lambda|=k\)</span> 就称
<span class="math inline">\(\lambda\)</span> 是整数 <span class="math inline">\(k\)</span> 的分拆，记作 <span class="math inline">\(\lambda\vdash k\)</span>。此外，记 <span class="math inline">\(l(\lambda)\)</span> 为 <span class="math inline">\(\lambda\)</span> 中非零项的个数。</p>
<p>对每个分拆 <span class="math inline">\(\lambda\vdash
k\)</span>，可以用一个图 <span class="math inline">\(F_\lambda\)</span>
来表示它，称为 <span class="math inline">\(\lambda\)</span> 的 Ferrers
图。<span class="math inline">\(F_\lambda\)</span> 由 <span class="math inline">\(k\)</span> 个方格组成，排列规则如下：第一行有
<span class="math inline">\(\lambda_1\)</span> 个方格，第二行有 <span class="math inline">\(\lambda_2\)</span> 个方格，. . .
以此类推，每一行都是左对齐的，总共有 <span class="math inline">\(l(\lambda)\)</span> 行。</p>
<p>例如，分拆 <span class="math inline">\(\lambda=(4, 2, 2, 1)\)</span>
的 Ferrers 图如下：</p>
<table>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>注意 <span class="math inline">\(\lambda\)</span> 中的 0 不出现在
Ferrers 图中。</p>
<p>将 <span class="math inline">\(F_\lambda\)</span>
沿主对角线翻转（即行列互换），得到的也是一个 Ferrers
图，其对应的分拆称为 <span class="math inline">\(\lambda\)</span>
的共轭分拆，记作 <span class="math inline">\(\lambda'=(\lambda_1',\lambda_2',\ldots,\lambda_r')\)</span>，其中
<span class="math inline">\(\lambda_i'\)</span> 是原 Ferrers 图第
<span class="math inline">\(i\)</span> 列的长度，且 <span class="math inline">\(r=\lambda_1\)</span>。</p>
<p>例如，上图转置后得到的共轭分拆为 <span class="math inline">\(\lambda'=(4, 3, 1, 1)\)</span>：</p>
<table>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>在 <span class="math inline">\(F_\lambda\)</span>
的每个方格中填入正整数，并满足以下条件：</p>
<ol type="1">
<li><strong>每一行从左到右非递减</strong>；</li>
<li><strong>每一列从上到下严格递增</strong>。</li>
</ol>
<p>满足上述条件的表格称为半标准 Young 表 (semistandard Young
tableaux)，简称为 SSYT；如果一个 SSYT 的所有填入的数字恰好为 <span class="math inline">\(\{1,2,\ldots,n\}\)</span>，且每个数字只出现一次，则称其为一个标准
Young 表 (standard Young tableaux)，简称为 SYT。</p>
<div class="statement example definition unnumbered">
<p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah">
</span>下图分别显示的是形状为 <span class="math inline">\(\lambda=(4, 3,
2,1)\)</span> 的一个半标准和一个标准 Young 表。</p>
<table>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">10</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">8</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</div>
<p>用记号 <span class="math inline">\(\mathrm{SSYT}(n,\lambda)\)</span>
表示所有形状为 <span class="math inline">\(\lambda\)</span>，并且填入的数字不超过 <span class="math inline">\(n\)</span> 的半标准 Young
表组成的集合。显然若要使得此集合非空必须有 <span class="math inline">\(n\geq l(\lambda)\)</span>（SSYT
从上到下是递增的，第一列的最后一行填入的整数至少是 <span class="math inline">\(l(\lambda)\)</span>）。当 <span class="math inline">\(|\lambda|=n\)</span> 时我们也将其简写为 <span class="math inline">\(\mathrm{SSYT}(\lambda)\)</span>。类似地，<span class="math inline">\({\rm SYT}(\lambda)\)</span> 表示所有形状为 <span class="math inline">\(\lambda\)</span> 的标准 Young 表的集合。</p>
<p>文章开头的投票序列问题本质上等价于计算集合 <span class="math inline">\({\rm SYT}(\lambda)\)</span>
的大小。具体来说，每个符合要求的投票序列都可以唯一地转化为一个标准 Young
表，方法如下：</p>
<ul>
<li>依次处理数字 <span class="math inline">\(j=1,2,\ldots,n\)</span>，如果选民 <span class="math inline">\(j\)</span> 将票投给了候选人 <span class="math inline">\(i\)</span>，则将数字 <span class="math inline">\(j\)</span> 填入 <span class="math inline">\(\lambda\)</span> 的 Ferrers 图的第 <span class="math inline">\(i\)</span> 行从左边数起第一个空着的方格中。</li>
<li>所有 <span class="math inline">\(n\)</span>
个数字填写完后得到的就是一个标准 Young 表 <span class="math inline">\(T\)</span>。若不然，假设第 <span class="math inline">\(k\)</span> 个选民投票给第 <span class="math inline">\(j\)</span> 个候选人，导致候选人 <span class="math inline">\(j\)</span> 的得票数大于某个候选人 <span class="math inline">\(i\,(i&lt;j)\)</span> 时，第 <span class="math inline">\(j\)</span> 行填入的 <span class="math inline">\(k\)</span> 上方对应的第 <span class="math inline">\(i\)</span>
行的方格此时是空的，这个方格未来只能填大于 <span class="math inline">\(k\)</span> 的数字，这样的 Young
表当然不是标准的。</li>
</ul>
<p>反之对一个标准 Young 表，其所有 <span class="math inline">\(\leq
k\)</span> 的方格构成一个子 Young 表 <span class="math inline">\(T_k\)</span>，其每行长度是投票截止到第 <span class="math inline">\(k\)</span> 个选民时，第 <span class="math inline">\(i\)</span>
个候选人的得票数，所以它给出一个满足要求的投票序列。</p>
<div class="statement example definition unnumbered">
<p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah">
</span>标准 Young 表</p>
<table>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">10</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">8</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>对应的得票序列为 <span class="math display">\[1, 2, 1, 3, 2, 1, 2, 4,
3, 1\]</span> 只要依次将 <span class="math inline">\(1,2,\ldots,10\)</span> 所在的行写出来即可。</p>
</div>
<p>为了解决 <span class="math inline">\({\rm SYT}(\lambda)\)</span>
的计数问题，我们需要引入 Schur 多项式的概念，Schur
多项式可以看作是半标准 Young 表的“生成函数”。</p>
<p>给定一个满足 <span class="math inline">\(n\geq l(\lambda)\)</span>
的分拆 <span class="math inline">\(\lambda=(\lambda_1,\ldots,\lambda_n)\)</span>
（允许某些 <span class="math inline">\(\lambda_i\)</span> 为零），<span class="math inline">\(T\in {\rm SSYT}(n,\lambda)\)</span>
是<strong>半标准 Young 表</strong>。我们称 <span class="math inline">\(c(T)=(c_1,c_2,\ldots,c_n)\)</span> 为 <span class="math inline">\(T\)</span> 的<strong>容度</strong> (content)，其中
<span class="math inline">\(c_i\)</span> 是 <span class="math inline">\(T\)</span> 中数字 <span class="math inline">\(i\)</span> 出现的次数。记 <span class="math display">\[X^{c(T)} = x_1^{c_1}x_2^{c_2}\cdots
x_n^{c_n}.\]</span> <span class="math inline">\(X^{c(T)}\)</span>
是一个单项式。</p>
<div class="statement example definition unnumbered">
<p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah">
</span>对 <span class="math inline">\(n=10\)</span> 和 <span class="math inline">\(\lambda=(4,3,2,1)\)</span>，上面的半标准 Young
表</p>
<table>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">5</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>的容度为 <span class="math inline">\((2, 2, 2, 1, 1, 1, 0, 1, 0,
0)\)</span>，其对应的单项式为 <span class="math display">\[X^{c(T)} =
x_1^2x_2^2x_3^2x_4x_5x_6x_8.\]</span></p>
</div>
<div id="schur-------------------------" class="statement sta_schur_________ plain unnumbered">
<p><span class="statement-heading"><span class="statement-label">Schur
多项式的组合定义</span>.</span><span class="statement-spah"> </span>设
<span class="math inline">\(n\)</span> 是一个正整数，<span class="math inline">\(\lambda=(\lambda_1,\ldots,\lambda_n)\)</span>
是一个满足 <span class="math inline">\(n\geq l(\lambda)\)</span> 的分拆
（允许某些 <span class="math inline">\(\lambda_i\)</span> 为零），定义
<span class="math inline">\(n\)</span> 变元多项式 <span class="math display">\[s_\lambda(x_1,\ldots,x_n)=\sum_{T\in {\rm
SSYT}(n,\lambda)}X^{c(T)}.\]</span> <span class="math inline">\(s_\lambda\)</span> 叫做 <strong><span class="math inline">\(n\)</span> 变元的 Schur 多项式</strong>。</p>
</div>
<p>注意 <span class="math inline">\(s_\lambda(x_1,\ldots,x_n)\)</span>
只有在 <span class="math inline">\(l(\lambda)\leq n\)</span>
时才有定义。</p>
<div class="statement example definition unnumbered">
<p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah">
</span>对 <span class="math inline">\(\lambda=(3,2)\)</span>， <span class="math display">\[\begin{align*}s_{(3,2)}(x_1,x_2,x_3) \,= \,
&amp; x_1^3x_2^2  + x_1^3x_3^2 +  x_1^3x_2x_3 + x_1^2x_2^3 + x_1^2x_3^3
+ 2x_1^2x_2x_3^2 + \\
&amp;2x_1^2x_2^2x_3 +x_1x_2x_3^3 + 2x_1x_2^2x_3^2 + x_1x_2^3x_3
+  x_2^2x_3^3 + x_2^3x_3^2.
\end{align*}\]</span> 前几项对应的半标准 Young 表如下：</p>
<table>
<tbody><tr>
<th>
<span class="math inline">\(x_1^3x_2^2\)</span>
</th>
<th>
<span class="math inline">\(x_1^3x_3^2\)</span>
</th>
<th>
<span class="math inline">\(x_1^3x_2x_3\)</span>
</th>
<th>
<span class="math inline">\(x_1^2x_2^3\)</span>
</th>
<th>
<span class="math inline">\(x_1^2x_3^3\)</span>
</th>
</tr>
<tr>
<td>
<table>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</td>
<td>
<table>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</td>
<td>
<table>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</td>
<td>
<table>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</td>
<td>
<table>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">3</td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
</td>
</tr>
</tbody></table>
</div>
<p>可以看到虽然 Schur
多项式的定义很直观，但写出它的具体表达式来却并不容易。我们需要找到 Schur
多项式的其它表现形式。首先我们将证明 Schur 多项式总是对称多项式。</p>
<h1 id="bender-knuth-对合">Bender-Knuth 对合</h1>
<p>这一节我们来证明 Schur 多项式 <span class="math inline">\(s_\lambda(x_1,\ldots,x_n)\)</span>
是对称多项式。即它在交换任何两个变元 <span class="math inline">\(x_i\)</span> 和 <span class="math inline">\(x_j\)</span> 后保持不变。为此只要证明它在交换
<span class="math inline">\(x_i\)</span> 和 <span class="math inline">\(x_{i+1}\)</span>
后保持不变即可。而这又只要说明容度为 <span class="math inline">\((\ldots,c_i,c_{i+1},\ldots)\)</span> 的半标准
Young 表与容度为 <span class="math inline">\((\ldots,c_{i+1},c_i,\ldots)\)</span> 的半标准
Young 表之间存在一一对应。看起来只要对每个形状为 <span class="math inline">\(\lambda\)</span> 的半标准 Young 表，把其中的数字
<span class="math inline">\(i\)</span> 全换成 <span class="math inline">\(i+1\)</span>，同时把 <span class="math inline">\(i+1\)</span> 全换成 <span class="math inline">\(i\)</span> 就可以了，是吗？</p>
<p>问题出在这样简单粗暴地修改得到的未必还是半标准的 Young
表。我们需要仔细点选择那些翻转的方格。我们作如下规定：</p>
<ul>
<li>如果某个 <span class="math inline">\(i\)</span> 的下方恰好是 <span class="math inline">\(i+1\)</span>，就称这样的 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(i+1\)</span> 构成匹配。</li>
<li>那些下方没有 <span class="math inline">\(i+1\)</span> 的 <span class="math inline">\(i\)</span>，或者上方没有 <span class="math inline">\(i\)</span> 的 <span class="math inline">\(i+1\)</span> 统称为未匹配的。</li>
</ul>
<p>下图中演示了 <span class="math inline">\(i=2\)</span>
的例子，绿色显示了匹配的元素，红色显示了未匹配的元素。</p>
<style>
table {max-width: 36%}
</style>
<table style="width:100%;">
<colgroup>
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
</colgroup>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span style="color:green">2</span></td>
</tr>
<tr>
<td style="text-align: center;"><span style="color:green">2</span></td>
<td style="text-align: center;"><span style="color:red">2</span></td>
<td style="text-align: center;"><span style="color:red">2</span></td>
<td style="text-align: center;"><span style="color:red">2</span></td>
<td style="text-align: center;"><span style="color:red">3</span></td>
<td style="text-align: center;"><span style="color:red">3</span></td>
<td style="text-align: center;"><span style="color:green">3</span></td>
</tr>
<tr>
<td style="text-align: center;"><span style="color:green">3</span></td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p><strong>关键观察</strong>：</p>
<blockquote>
<p>在任意一行中，未匹配的元素总是构成一段连续的序列。即设 <span class="math inline">\(i=x\leq y\leq i+1\)</span>
是两个未匹配的元素，则它们中间不可能有匹配的元素。</p>
</blockquote>
<p>设某一行中的未匹配元素形如：<span class="math inline">\(r\)</span> 个
<span class="math inline">\(i\)</span> 紧接着 <span class="math inline">\(s\)</span> 个 <span class="math inline">\(i+1\)</span>，我们将其替换为 <span class="math inline">\(s\)</span> 个 <span class="math inline">\(i\)</span> 紧接着 <span class="math inline">\(r\)</span> 个 <span class="math inline">\(i+1\)</span>，保持其他部分不变。对 Young
表的每一行都执行这一操作，得到新表 <span class="math inline">\(T^\ast\)</span>，此时 <span class="math inline">\(T^\ast\)</span> 仍然是一个合法的半标准 Young
表。</p>
<p>例如在上面的 <span class="math inline">\(T\)</span>
中，红色标注的未匹配的元素是 3 个 2 后面跟了 2 个 3，变换后在 <span class="math inline">\(T^\ast\)</span> 中变成了 2 个 2 后面跟了 3 个
3：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
<col style="width: 14%">
</colgroup>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"><font color="green">2</font></td>
</tr>
<tr>
<td style="text-align: center;"><font color="green">2</font></td>
<td style="text-align: center;"><font color="red">2</font></td>
<td style="text-align: center;"><font color="red">2</font></td>
<td style="text-align: center;"><font color="red">3</font></td>
<td style="text-align: center;"><font color="red">3</font></td>
<td style="text-align: center;"><font color="red">3</font></td>
<td style="text-align: center;"><font color="green">3</font></td>
</tr>
<tr>
<td style="text-align: center;"><font color="green">3</font></td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>容易验证 <span class="math inline">\(T^\ast\)</span> 的容度为 <span class="math inline">\((\ldots,c_{i+1},c_i,\ldots)\)</span>。这个变换显然是个对合：<span class="math inline">\((T^\ast)^\ast=T\)</span>，这就证明了 Schur
多项式是对称的。</p>
<h1 id="jacobi-trudi-恒等式">Jacobi-Trudi 恒等式</h1>
<p>除了通过半标准 Young 表的生成函数定义之外，Schur
多项式还有许多等价的表达方式。本节中，我们将 Schur
多项式表示为齐次对称多项式行列式的形式。</p>
<div class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
3.1</span>.</span><span class="statement-spah"> </span>记 <span class="math inline">\(h_k(x_1,\ldots,x_n)\)</span> 为所有次数为 <span class="math inline">\(k\)</span> 的单项式之和： <span class="math display">\[h_k(x_1,\ldots,x_n)=\sum_{\begin{subarray}{c}\alpha_1+\alpha_2+\cdots+\alpha_n=k\\\alpha_i\in\mathbb{Z}_{\geq0}\end{subarray}}
x_1^{\alpha_1}x_2^{\alpha_2}\cdots x_n^{\alpha_n}.\]</span> 约定 <span class="math inline">\(h_0=1\)</span>，<span class="math inline">\(k&lt;0\)</span> 时 <span class="math inline">\(h_{k}=0\)</span>。<span class="math inline">\(h_k\)</span>
也是对称多项式，称为<strong>齐次对称多项式</strong>。</p>
</div>
<div class="statement example definition unnumbered">
<p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah">
</span><span class="math inline">\(h_2(x_1,\ldots,x_n)=\sum_{i=1}^n
x_n^2 + \sum_{1&lt;i&lt;j&lt;n}x_ix_j\)</span>。</p>
</div>
<div id="jacobi-trudi----------" class="statement sta_jacobi_trudi____ plain unnumbered">
<p><span class="statement-heading"><span class="statement-label">Jacobi-Trudi 恒等式</span>.</span><span class="statement-spah"> </span><br>
</p>
<p>设 <span class="math inline">\(\lambda=(\lambda_1,\ldots,\lambda_n)\in\mathbb{Z}^n_{\geq0}\)</span>
为一个分拆，则 <span class="math display">\[s_\lambda(x_1,x_2,\ldots,x_n)=\det\left(
h_{\lambda_i-i+j}\right)_{1\leq i,j\leq n}.\]</span></p>
</div>
<div class="statement note definition unnumbered">
<p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah">
</span>另一种常见写法是 <span class="math display">\[s_\lambda(x_1,x_2,\ldots,x_n)=\det\left(
h_{\lambda_i-i+j}\right)_{1\leq i,j\leq l(\lambda)}.\]</span>
这没有区别。实际上令 <span class="math inline">\(r=l(\lambda)\)</span>，则 <span class="math display">\[\det\left(h_{\lambda_i-i+j}\right)_{1\leq i,j\leq
n}=
\det\left(\begin{array}{cc}
\begin{array}{l}
h_{\lambda_1}&amp;h_{\lambda_1+1} &amp;\cdots &amp; h_{\lambda_1+r-1}\\
h_{\lambda_2-1}&amp;h_{\lambda_2} &amp;\cdots &amp; h_{\lambda_2+r-2}\\
&amp;  &amp; \cdots &amp; \\
h_{\lambda_r-(r-1)}&amp;h_{\lambda_r-(r-2)}&amp;\cdots &amp;
h_{\lambda_r}
\end{array} &amp; \Large\ast \\ \Large 0 &amp;
\begin{matrix}1&amp;&amp;\\&amp;\ddots&amp;\\&amp;&amp;1\end{matrix}\end{array}\right).
\]</span> 显然它等于左上角的主子式。</p>
</div>
<p>证明要用到 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lindstr%C3%B6m%E2%80%93Gessel%E2%80%93Viennot_lemma">Gessel-Viennot
的不相交格点路径组方法</a>。关于这个方法你可以参考我之前的 <a href="/macmahon-formula-plane-partitions">一篇博文</a>。当然 <span class="citation" data-cites="thebook">(<a href="#ref-thebook" role="doc-biblioref">Martin Aigner and Ziegler 2018</a>)</span>
中格点路径组一章也是极好的介绍。</p>
<p>关键是要<strong>把每个半标准 Young
表对应到一个不相交的路径组</strong>。</p>
<p>下面的动图显示了 <span class="math inline">\(n=6, \lambda=(5,4,3,2,0,
0)\)</span> 时的一个形状为 <span class="math inline">\(\lambda\)</span>
的 Young 表 <span class="math inline">\(T\)</span>
与其不相交的路径组：</p>
<table>
<tbody>
<tr>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td style="text-align: center;">2</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>其中，<span class="math inline">\(T\)</span> 的每一行是一个长度为
<span class="math inline">\(\lambda_i\)</span>
的递增数列，该数列对应一条从 <span class="math inline">\((0,1)\)</span>
到 <span class="math inline">\((\lambda_i,n)\)</span> 的 Gauss
路径，即这一行的“台阶图”。</p>
<p><img src="/images/schur/jacobi-trudi.gif" class="fig" width="600"></p>
<p>我省略了 <span class="math inline">\(\lambda_i=0\)</span>
的部分，它们对应的是权重为 1 的垂直路径，对路径组的权重没有贡献：</p>
<p><img src="/images/schur/jacobi-trudi2.gif" class="fig" width="600"></p>
<p>但是半标准 Young 表的列是严格递增的，这个递减关系反映在 Gauss
路径上，就是 <span class="math inline">\(T\)</span>
的第二行对应的路径应该整体位于第一行对应路径的上方，第三行对应的路径整体位于第二行对应的路径的上方，…，两条路径之间可以有垂直的公共边，但是不能有水平的公共边。</p>
<p>对每个 <span class="math inline">\(i\)</span>，将第 <span class="math inline">\(i\)</span> 行对应的路径水平地向左平移 <span class="math inline">\(i\)</span> 个单位，使其成为一条从 <span class="math inline">\(A_i=(-i,1)\)</span> 到 <span class="math inline">\(B_i=(-i+\lambda_i,n)\)</span> 的 Gauss
路径，则这样得到的 <span class="math inline">\(n\)</span>
条路径构成一个不相交的路径组。</p>
<p>反过来每一个这样的不相交的路径组也对应于一个半标准 Young 表。</p>
<p>令水平线 <span class="math inline">\(y=k\)</span> 的权值为 <span class="math inline">\(x_k\)</span>，垂直边的权值一律为
1，每条路径的权重是其所含各边的权重乘积。不难验证从 <span class="math inline">\(A_j=(-j,1)\)</span> 到 <span class="math inline">\(B_i=(-i+\lambda_i,n)\)</span> 的所有 Gauss
路径权重之和是齐次对称多项式 <span class="math inline">\(h_{\lambda_i-i+j}\)</span>。于是由 Gessel-Viennot
引理，行列式 <span class="math inline">\(\det\left(h_{\lambda_i-i+j}\right)_{1\leq i,j\leq
n}\)</span>
给出了所有不相交路径组的权重之和。另一方面每个不相交路径组的权重正是它对应
Young 表的权重 <span class="math inline">\(X^{c(T)}\)</span>，所以 <span class="math display">\[s_\lambda=\det\left(h_{\lambda_i-i+j}\right)_{1\leq
i,j\leq n}.\]</span> 这就证明了 Jacobi-Trudi 恒等式。</p>
<h1 id="bi-alternant-公式">Bi-alternant 公式</h1>
<p>设 <span class="math inline">\(\lambda=(\lambda_1,\ldots,\lambda_n),\,\mu=(\mu_1,\ldots,\mu_n)\in\mathbb{Z}^n_{\geq0}\)</span>
是两个分拆。定义 Weyl 向量 <span class="math display">\[\rho=(n-1,n-2,\ldots,1,0).\]</span></p>
<p>设 <span class="math inline">\(T\in\mathrm{SSYT}(n,\mu)\)</span>，用记号 <span class="math inline">\(T_{\geq j}\)</span> 表示由 <span class="math inline">\(T\)</span> 的第 <span class="math inline">\(j,j+1,\ldots\)</span> 列组成的半标准 Young
表，同理记号 <span class="math inline">\(T_{&gt;j}\)</span> 和 <span class="math inline">\(T_{&lt;j}\)</span>
的含义都是不言自明的。如果对任何 <span class="math inline">\(j\)</span>，向量 <span class="math inline">\(\lambda+c(T_{\geq j})\)</span> 都是一个分拆，就称
<span class="math inline">\(T\)</span> 是一个“好” Young 表，否则就称
<span class="math inline">\(T\)</span> 是一个“坏” Young 表。</p>
<p>定义如下的 <span class="math inline">\(n\)</span> 阶行列式：</p>
<p><span class="math display">\[a_\lambda=\det(x_i^{\lambda_j})_{1\leq
i,j\leq n}=\sum_{\sigma\in
S_n}\text{sgn}(\sigma)X^{\sigma(\lambda)}.\]</span></p>
<div id="stembridge" class="statement theorem plain">
<p><span class="statement-heading"><span class="statement-label">定理
4.1</span>.</span><span class="statement-spah"> </span><span class="math display">\[a_{\lambda+\rho}s_{\mu}=\sum_{T\in\mathrm{SSYT}(n,\mu)\text{
and $T$ good}}a_{\lambda+c(T)+\rho}.\]</span></p>
</div>
<p>这个定理乍看起来从叙述到证明都很不直观，不过它的结论却非常重要，这就是
Littlewood-Richardson 定律。下面这个证明有很深刻的来源
（李代数的晶体图）。见</p>
<blockquote>
<p>A Concise Proof of the Littlewood-Richardson Rule, by John R.
Stembridge.</p>
</blockquote>
<p><strong>证明</strong>：由于 <span class="math inline">\(s_\mu\)</span> 是对称多项式，因此对任何置换 <span class="math inline">\(\sigma\in S_n\)</span>，当 <span class="math inline">\(T\)</span> 跑遍 <span class="math inline">\(\mathrm{SSYT}(n,\mu)\)</span> 时，集合 <span class="math inline">\(\{c(T)\}\)</span> 与集合 <span class="math inline">\(\{\sigma(c(T))\}\)</span> 是相同的，所以 <span class="math display">\[
s_{\mu}=\sum_{T\in\mathrm{SSYT}(n,\mu)} X^{c(T)} =
\sum_{T\in\mathrm{SSYT}(n,\mu)} X^{\sigma(c(T))}.
\]</span></p>
<p>于是利用定义有</p>
<p><span class="math display">\[\begin{aligned}
a_{\lambda+\rho}s_\mu&amp;=\sum_{\sigma\in
S_n}\text{sgn}(\sigma)X^{\sigma(\lambda+\rho)}s_\mu\\
&amp;=\sum_{\sigma\in
S_n}\text{sgn}(\sigma)\left(\sum_{T\in\mathrm{SSYT}(n,\,\mu)}X^{\sigma(\lambda+\rho+c(T))}\right)\\
&amp;=\sum_{T\in\mathrm{SSYT}(n,\mu)}\sum_{\sigma\in
S_n}\text{sgn}(\sigma)X^{\sigma(\lambda+\rho+c(T))}\\
&amp;=\sum_{T\in\mathrm{SSYT}(n,\mu)}a_{\lambda+c(T)+\rho}.\end{aligned}\]</span></p>
<p>接下来，我们将借助 Bender-Knuth 对合，把求和项中坏的那些 <span class="math inline">\(T\)</span> 两两配对抵消掉，从而剩下的和项都是好的
<span class="math inline">\(T\)</span>。</p>
<p>设 <span class="math inline">\(T\)</span> 是一个坏 Young 表，则存在
<span class="math inline">\(j\)</span> 使得 <span class="math inline">\(\lambda+c(T_{\geq j})\)</span>
不是一个分拆，在所有这样的 <span class="math inline">\(j\)</span>
中，选取最大的那个。选好 <span class="math inline">\(j\)</span>
以后，由于 <span class="math inline">\(\lambda+c(T_{\geq j})\)</span>
不是分拆，因此存在 <span class="math inline">\(k\)</span> 使得 <span class="math display">\[\lambda_k+c_k(T_{\geq j}) &lt;
\lambda_{k+1}+c_{k+1}(T_{\geq j}).\]</span> 在所有这样的 <span class="math inline">\(k\)</span> 中，选取最小的那个。</p>
<p>由于在 <span class="math inline">\(T\)</span> 的每一列中至多只有一个
<span class="math inline">\(k\)</span> 以及至多只有一个 <span class="math inline">\(k+1\)</span>，所以差 <span class="math display">\[c_k(T_{\geq j}) - c_{k+1}(T_{\geq j})\]</span> 在
<span class="math inline">\(j\)</span> 变动到 <span class="math inline">\(j+1\)</span> 时最多只会改变 1。从而差 <span class="math display">\[\lambda_k+c_k(T_{\geq j})
-\lambda_{k+1}-c_{k+1}(T_{\geq j})\]</span> 也是如此。根据 <span class="math display">\[\begin{aligned}
\lambda_k+c_k(T_{\geq j}) &amp;&lt; \lambda_{k+1}+c_{k+1}(T_{\geq j})\\
\lambda_k+c_k(T_{\geq j+1}) &amp;\geq \lambda_{k+1}+c_{k+1}(T_{\geq
j+1})
\end{aligned}\]</span> 第一行（两端之差）是一个负整数，在至多改变 1
的情况下，变成第二行的非负整数，只能是从 -1 变成 0。从而我们有 <span class="math display">\[\lambda_k+c_k(T_{\geq
j})+1=\lambda_{k+1}+c_{k+1}(T_{\geq
j}).\tag{1}\label{eq:assert}\]</span> 并且 <span class="math inline">\(T\)</span> 的第 <span class="math inline">\(j\)</span> 列有一个 <span class="math inline">\(k+1\)</span> 但是没有 <span class="math inline">\(k\)</span>。</p>
<p>现在对 <span class="math inline">\(T\)</span> 进行如下的变换：保持
<span class="math inline">\(T_{\geq j}\)</span> 的部分不动，把 <span class="math inline">\(T_{&lt;j}\)</span> 的部分对数字 <span class="math inline">\(k\)</span> 和 <span class="math inline">\(k+1\)</span> 进行 Bender-Knuth 变换，得到一个
Young 表 <span class="math inline">\(T^\ast\)</span> （不排除 <span class="math inline">\(T=T^\ast\)</span> 的可能）。不难验证 <span class="math inline">\(T^\ast\)</span> 也是半标准的：因为 Bender-Knuth
对换不影响列严格递增性质，利用 <span class="math inline">\(T\)</span>
的第 <span class="math inline">\(j\)</span> 列不含 <span class="math inline">\(k\)</span> 这一点，将 <span class="math inline">\(T_{&lt;j}\)</span> 的部分中某些 <span class="math inline">\(k\)</span> 换成 <span class="math inline">\(k+1\)</span> 也不会影响行的弱递增性质。<span class="math inline">\(T^\ast\)</span> 也是一个坏 Young 表且 <span class="math inline">\((T^\ast)^\ast =T\)</span> （因为 <span class="math inline">\(T^\ast_{\geq j}\)</span> 和 <span class="math inline">\(T_{\geq j}\)</span> 完全一样）。容易验证对换 <span class="math inline">\(s_k=(k,k+1)\)</span> 交换 <span class="math inline">\(c(T_{&lt; j})\)</span> 和 <span class="math inline">\(c(T^\ast_{&lt; j})\)</span> 的 <span class="math inline">\(k\)</span> 和 <span class="math inline">\(k+1\)</span> 位置： <span class="math display">\[s_kc(T_{&lt; j}) = c(T^\ast_{&lt; j}).\]</span>
而 <span class="math inline">\((\ref{eq:assert})\)</span> 说明 <span class="math inline">\(s_k\)</span> 保持 <span class="math inline">\(\lambda+c(T_{\geq j}) + \rho\)</span> 不变，因此
<span class="math display">\[s_k(\lambda+c(T)+\rho)=s_k(\lambda+c(T_{\geq
j})+\rho)+s_kc(T_{&lt;j})=\lambda+c(T^\ast)+\rho.\]</span></p>
<p>于是若 <span class="math inline">\(T\ne T^\ast\)</span>，则两个行列式
<span class="math inline">\(a_{\lambda+c(T)+\rho}\)</span> 和 <span class="math inline">\(a_{\lambda+c(T^\ast)+\rho}\)</span> 相差一个 <span class="math inline">\(k,k+1\)</span> 列的交换，从而它们的值抵消。在
<span class="math inline">\(T=T^\ast\)</span> 的情形，矩阵的 <span class="math inline">\(k,k+1\)</span> 列是相同的，行列式自然是 0。<span class="math inline">\(\blacksquare\)</span></p>
<div id="bi-alternant-formula" class="statement sta_bi_alternant_formula plain unnumbered">
<p><span class="statement-heading"><span class="statement-label">bi-alternant formula</span>.</span><span class="statement-spah"> </span> <span class="math display">\[s_{\mu}=\frac{a_{\mu+\rho}}{a_\rho}.\]</span></p>
</div>
<p><strong>证明</strong>：在定理中令 <span class="math inline">\(\lambda=\emptyset\)</span>，则只有唯一的一个形状为
<span class="math inline">\(\mu\)</span> 的好 Young 表 <span class="math inline">\(T\)</span>，使得 <span class="math inline">\(c(T_{\geq j})\)</span> 对任何 <span class="math inline">\(j\)</span> 都是一个分拆，这个表必须是第一行都填
1，第二行都填 2，…， 以此类推，从而 <span class="math inline">\(c(T)=\mu\)</span>，因此得证。<span class="math inline">\(\blacksquare\)</span></p>
<h1 id="钩长公式">钩长公式</h1>
<p>在完成前面的准备工作后，我们现在可以正式介绍钩长公式及其证明。</p>
<div class="statement definition plain">
<p><span class="statement-heading"><span class="statement-label">定义
5.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\lambda\vdash n\)</span>，<span class="math inline">\(F_\lambda\)</span> 是其 Ferrers 图，记 <span class="math inline">\(v=(i,j)\)</span> 为 <span class="math inline">\(F_\lambda\)</span> 中第 <span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 列位置的方格
（只考虑那些有方格的位置）。我们计算那些与 <span class="math inline">\(v\)</span> 同行但是位置在 <span class="math inline">\(v\)</span> 的右边，以及与 <span class="math inline">\(v\)</span> 同列但是位置在 <span class="math inline">\(v\)</span> 的下方的方格的总数，<span class="math inline">\(v\)</span> 自己也算一个但是只算一次。这个数字称作
<span class="math inline">\(v\)</span> 的钩子长度，记作 <span class="math inline">\(h_v\)</span>。</p>
</div>
<p>例如 <span class="math inline">\(\lambda=(5, 4, 3, 2, 1)\)</span> 的
Ferrers 图中，<span class="math inline">\(v=(1, 1)\)</span> 的钩子长度
<span class="math inline">\(h_v=5\)</span>。</p>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
<col style="width: 20%">
</colgroup>
<tbody>
<tr>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\phantom{\bullet}\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\phantom{\bullet}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\bullet\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\bullet\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\bullet\)</span></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\phantom{\bullet}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\bullet\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\phantom{\bullet}\)</span></td>
<td style="text-align: center;"><span class="math inline">\(\bullet\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr>
<td style="text-align: center;"><span class="math inline">\(\phantom{\bullet}\)</span></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>一般地，<span class="math inline">\((i,j)\)</span> 位置的方格的 hook
长度为 <span class="math inline">\(\lambda_i + \lambda'_j - i - j +
1\)</span>。</p>
<div id="hook-length-formula" class="statement sta_hook_length_formula plain unnumbered">
<p><span class="statement-heading"><span class="statement-label">Hook
length formula</span>.</span><span class="statement-spah"> </span><br>
</p>
<p>形状为 <span class="math inline">\(\lambda\)</span> 的标准 Young
表的个数由以下公式给出： <span class="math display">\[|{\rm
SYT}(\lambda)|=f_\lambda=\frac{n!}{\prod\limits_{v\in
F_\lambda}h_v}.\]</span></p>
</div>
<div id="lemmaA" class="statement lemma plain">
<p><span class="statement-heading"><span class="statement-label">引理
5.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mu_i=\lambda_i+r-i\)</span>，这里 <span class="math inline">\(r=l(\lambda)=\lambda_1',\,1\leq i\leq
r\)</span>，则 <span class="math display">\[\prod_{v\in F_\lambda} h_v
=\frac{\prod\limits_{i=1}^r
\mu_i!}{\prod\limits_{i&lt;j}(\mu_i-\mu_j)}.\]</span></p>
<p>注意 <span class="math inline">\(\mu_i=h_{i1}\)</span> 正是第 1 列第
<span class="math inline">\(i\)</span> 行方格的钩子长度。</p>
</div>
<p><a href="#lemmaA" title="引理 5.2">引理 5.2</a>
的结论可以很容易由下面的 <a href="#lemmaB" title="引理 5.3">引理 5.3</a>
得出：</p>
<div id="lemmaB" class="statement lemma plain">
<p><span class="statement-heading"><span class="statement-label">引理
5.3</span>.</span><span class="statement-spah"> </span>对固定的 <span class="math inline">\(1\leq k\leq r\)</span>，<span class="math inline">\(F_\lambda\)</span> 的第 <span class="math inline">\(k\)</span> 行所有方格的钩子长度集合 <span class="math inline">\(\{h_{kj},1\leq j\leq\lambda_k\}\)</span> 与 <span class="math inline">\(\{\mu_k-\mu_i, k\leq i\leq r\}\)</span>
不相交，且它们的并集恰好构成 <span class="math inline">\(\{0,1,\ldots,\mu_k\}\)</span>。因此，第 <span class="math inline">\(k\)</span> 行所有方格的钩子长度的乘积为 <span class="math display">\[\prod_{j=1}^{\lambda_k}h_{kj}=\frac{\mu_k!}{\prod\limits_{k&lt;i}(\mu_k-\mu_i)}.\]</span></p>
</div>
<p><a href="#lemmaB" title="引理 5.3">引理 5.3</a>
的证明：这里的证明改编自 <span class="citation" data-cites="Macdonald2008">Macdonald (<a href="#ref-Macdonald2008" role="doc-biblioref">2008</a>)</span>。</p>
<p>我们从 <span class="math inline">\(F_\lambda\)</span>
的左下角开始，沿着边界，每一步向右或者向上行走，直到第 <span class="math inline">\(k\)</span> 行最右边的方格右上角为止，总共要走
<span class="math inline">\(h_{k1}+1\)</span> 步。将经过的边依次标号为
<span class="math inline">\(0,1,\ldots,h_{k1}\)</span>。</p>
<figure>
<img src="/images/schur/hook_length_lemma.svg" class="fig" width="400" alt="图中只显示了 F_\lambda 第 k 行及以下的部分。向右走的步数等于第 k 行的方格个数，向上走的步数等于第 1 列中 \geq k 行的方格个数，所以总共走了 h_{k1}+1 步。">
<figcaption aria-hidden="true">图中只显示了 <span class="math inline">\(F_\lambda\)</span> 第 <span class="math inline">\(k\)</span> 行及以下的部分。向右走的步数等于第
<span class="math inline">\(k\)</span> 行的方格个数，向上走的步数等于第
1 列中 <span class="math inline">\(\geq k\)</span>
行的方格个数，所以总共走了 <span class="math inline">\(h_{k1}+1\)</span>
步。</figcaption>
</figure>
<p>不难看出：</p>
<ul>
<li>所有竖直边的标号构成集合 <span class="math inline">\(\{h_{i1} \mid
k\leq i\leq r\}\)</span>，即图中第一列方格的钩子长度。</li>
<li>所有水平边的标号构成集合 <span class="math inline">\(\{h_{k1} -
h_{kj}\mid 1\leq j\leq\lambda_k\}\)</span>。即 <span class="math inline">\(h_{k1}\)</span> 减去图中第一行（也是原 <span class="math inline">\(F_\lambda\)</span> 的第 <span class="math inline">\(k\)</span> 行）方格的钩子长度。</li>
</ul>
<p>于是我们有不交并 <span class="math display">\[\{0,1,\ldots,h_{k1}\}=\{h_{i1} \mid k\leq i\leq
r\}\sqcup \{h_{k1} - h_{kj}\mid 1\leq j\leq\lambda_k\}.\]</span> 同时用
<span class="math inline">\(h_{k1}\)</span> 减去两边的集合，得到不交并
<span class="math display">\[\{0,1,\ldots,h_{k1}\}=\{h_{k1}-h_{i1} \mid
k\leq i\leq r\}\sqcup \{h_{kj}\mid 1\leq j\leq\lambda_k\}.\]</span></p>
<p>前者正是集合 <span class="math inline">\(\{\mu_k-\mu_i\mid k\leq
i\leq r\}\)</span>，这就证明了 <a href="#lemmaB" title="引理 5.3">引理
5.3</a>。<span class="math inline">\(\blacksquare\)</span></p>
<p>最后我们来完成钩长公式的证明：这里使用了一个小技巧：考虑关于无穷多个变元的对称多项式环
<span class="math inline">\(\Lambda[x_1,\ldots,x_n,\ldots]\)</span>，任何
<span class="math inline">\(k\)</span> 变元的 Schur 多项式都是 <span class="math inline">\(\Lambda\)</span> 中的元素。<span class="math inline">\(\Lambda\)</span> 到有理数域上的单变元形式幂级数环
<span class="math inline">\(\mathbb{Q}[t]\)</span> 有一个同态 <span class="math inline">\(\theta\)</span>： <span class="math display">\[\theta(f) = \sum_{k=0}^\infty f_k
\frac{t^k}{k!}.\]</span> 其中 <span class="math inline">\(f_k\)</span>
是 <span class="math inline">\(f\)</span> 中单项式 <span class="math inline">\(x_1x_2\cdots x_k\)</span> 的系数。不难验证 <span class="math inline">\(\theta\)</span> 是 <span class="math inline">\(\Lambda\to \mathbb{Q}[t]\)</span> 的代数同态 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。</p>
<p>在齐次对称多项式 <span class="math inline">\(h_k\)</span> 中，其形如
<span class="math inline">\(x_1x_2\cdots x_n\)</span> 的项只有一个，就是
<span class="math inline">\(x_1x_2\cdots
x_k\)</span>，并且这一项的系数是 1，所以 <span class="math inline">\(\theta(h_k)=\frac{t^k}{k!}\)</span>。</p>
<p>我们再来分析 <span class="math inline">\(\theta\)</span> 作用在 <span class="math inline">\(n\)</span> 变元 Schur 多项式上的结果 <span class="math inline">\(\theta(s_\lambda(x_1,\ldots,x_n))\)</span>。这里我们要求
<span class="math inline">\(\lambda\)</span> 满足 <span class="math inline">\(|\lambda|=n\)</span>，即 <span class="math inline">\(\lambda\)</span> 的 Ferrers 图恰好包含 <span class="math inline">\(n\)</span> 个方格。单项式 <span class="math inline">\(x_1x_2\cdots x_k\)</span> 在 <span class="math inline">\(s_\lambda(x_1,\ldots,x_n)\)</span>
中的系数等于每个数字 <span class="math inline">\(\{1,2,\ldots,k\}\)</span>
都恰好使用一次的不同填法的个数，这只能是 <span class="math inline">\(k=n\)</span> 且得到的是标准 Young 表，这样的填法有
<span class="math inline">\(f_\lambda\)</span> 种，所以 <span class="math display">\[\theta(s_\lambda(x_1,\ldots,x_n))=f_\lambda
\frac{t^n}{n!}.\]</span></p>
<p>在 Jacobi-Trudi 恒等式两边同时用 <span class="math inline">\(\theta\)</span> 作用，得到 <span class="math display">\[f_\lambda \frac{t^n}{n!}=\det\left(
\frac{t^{\lambda_i-i+j}}{(\lambda_i-i+j)!} \right).\]</span> 取 <span class="math inline">\(t=1\)</span> 代入得 <span class="math display">\[f_\lambda = n!\cdot
\det\left(\frac{1}{(\lambda_i-i+j)!}\right).\]</span>
我们把这个行列式写出来： <span class="math display">\[f_\lambda =
n!\cdot \det\begin{pmatrix}
\frac{1}{\lambda_1!} &amp; \frac{1}{(\lambda_1+1)!} &amp; \cdots &amp;
\frac{1}{(\lambda_1+r-1)!}\\
\frac{1}{(\lambda_2-1)!} &amp; \frac{1}{\lambda_2!} &amp; \cdots &amp;
\frac{1}{(\lambda_2+r-2)!}\\
\cdots &amp; \cdots &amp;\cdots&amp;\cdots\\
\frac{1}{(\lambda_r-r+1)!} &amp; \frac{1}{(\lambda_r-r+2)!} &amp; \cdots
&amp; \frac{1}{\lambda_r!}
\end{pmatrix}.\]</span> 它的最后一列恰好是 <span class="math inline">\(\{\mu_i!\mid 1\leq i\leq
r\}\)</span>，提出来以后得到 <span class="math display">\[f_\lambda =
\frac{n!}{\prod\limits_{i=1}^r\mu_i!}\cdot \det\begin{pmatrix}
\mu_1^{\underline{r-1}}&amp; \mu_1^{\underline{r-2}} &amp; \cdots &amp;
\mu_1^{\underline{0}}\\
\mu_2^{\underline{r-1}} &amp; \mu_2^{\underline{r-2}} &amp; \cdots &amp;
\mu_2^{\underline{0}}\\
\cdots &amp; \cdots &amp;\cdots&amp;\cdots\\
\mu_r^{\underline{r-1}}&amp; \mu_r^{\underline{r-2}} &amp; \cdots &amp;
\mu_r^{\underline{0}}
\end{pmatrix}=
\frac{n!}{\prod\limits_{i=1}^r\mu_i!}\cdot\det(\mu_i^{\underline{r-j}}).\]</span>
其中采用了类似 <span class="citation" data-cites="aigner07">M. Aigner
(<a href="#ref-aigner07" role="doc-biblioref">2007</a>)</span> 中的记号
<span class="math display">\[x^{\underline{k}}=x(x-1)\cdots(x-k+1).\]</span></p>
<p>不难证明 <span class="math inline">\(\det(\mu_i^{\underline{r-j}})\)</span>
这个行列式与 Vandermonde 行列式 <span class="math inline">\(\det(\mu_i^{r-j})\)</span> 的值是一样的，都等于
<span class="math inline">\(\prod\limits_{i&lt;j}(\mu_i-\mu_j)\)</span>
<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。于是 <span class="math display">\[f_\lambda =
\frac{n!}{\prod\limits_{i=1}^r\mu_i!}\cdot\prod\limits_{i&lt;j}(\mu_i-\mu_j)
= \frac{n!}{\prod\limits_{v\in F_\lambda}h_v}.\]</span>
这就完成了钩长公式的证明。</p>
<h1 class="unnumbered" id="bibliography">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-aigner07" class="csl-entry" role="listitem">
Aigner, M. 2007. <em>A Course in Enumeration</em>. Graduate Texts in
Mathematics. Springer Berlin Heidelberg.
</div>
<div id="ref-thebook" class="csl-entry" role="listitem">
Aigner, Martin, and Gnter M. Ziegler. 2018. <em>Proofs from THE
BOOK</em>. 6th ed. Springer Publishing Company, Incorporated.
</div>
<div id="ref-Macdonald2008" class="csl-entry" role="listitem">
Macdonald, I. G. 2008. <em>Symmetric Functions and Hall
Polynomials</em>. 2<sup>nd</sup> ed. Oxford science pub.
</div>
<div id="ref-Stanley_Fomin_1999" class="csl-entry" role="listitem">
Stanley, Richard P., and Sergey Fomin. 1999. <em>Enumerative
Combinatorics</em>. Vol. 2. Cambridge Studies in Advanced Mathematics.
Cambridge University Press.
</div>
</div>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>你可以直接手算验证 <span class="math inline">\(\theta\)</span>
是代数同态。但这个同态背后还有更深的来历：记 <span class="math display">\[p_k=x_1^k+\cdots+x_n^k+\cdots\in\Lambda.\]</span>
<span class="math inline">\(p_k\)</span>
叫做<strong>幂和对称多项式</strong>。对称多项式的基本定理有一个版本是说，任何
<span class="math inline">\(f\in\Lambda\)</span> 可以唯一地写成关于
<span class="math inline">\(\{p_k\mid k\geq1\}\)</span>
的有理系数多项式： <span class="math display">\[f=g(p_1,p_2,\ldots).\]</span> 其中 <span class="math inline">\(g\)</span> 是关于无穷多个变元 <span class="math inline">\(x_1,\ldots,x_n\)</span>
的有理系数多项式。考虑赋值映射 <span class="math display">\[\begin{aligned}
{\rm ex}:\ \Lambda&amp;\mapsto\mathbb{Q}[t]\\
g(p_1,p_2,\ldots) &amp;\to g(t, 0, 0,\ldots)
\end{aligned}\]</span> 则 <span class="math inline">\({\rm ex}\)</span>
是代数同态。<span class="math inline">\({\rm ex}\)</span> 实际上就是
<span class="math inline">\(\theta\)</span>： <span class="math display">\[{\rm ex}(f) = \sum_{n\geq
0}f_n\frac{t^n}{n!}.\]</span> 详情可以参考 <span class="citation" data-cites="Stanley_Fomin_1999">(<a href="#ref-Stanley_Fomin_1999" role="doc-biblioref">Stanley and Fomin 1999</a>)</span>。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>考虑 <span class="math inline">\(n\)</span> 个变元 <span class="math inline">\(X_1,\ldots,X_n\)</span> 的行列式 <span class="math inline">\(\det(X_i^{\underline{r-j}})\)</span>，这个多项式在
<span class="math inline">\(X_i=X_j\)</span> 时是 0，所以它有因子 <span class="math inline">\(\prod_{1\leq i&lt;j\leq
r}(X_i-X_j)\)</span>。另一方面它的行列式展开以后每一项次数都不超过 <span class="math inline">\(\sum_{i=1}^r(r-i)=\frac{r(r-1)}{2}\)</span>，所以比较次数即得它等于
<span class="math inline">\(\prod_{1\leq i&lt;j\leq r}(X_i-X_j)\)</span>
乘以一个常数。再比较 <span class="math inline">\(X_1^{r-1}X_2^{r-2}\cdots X_r^0\)</span>
的系数（来自主对角线）即得这个常数是 1。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>



                                                    
  <p class="pink-link-context">
    <a href="/star-trek/" rel="next" title="星际迷航问题">
      上一篇：星际迷航问题
    </a>
  </p>
  

    
      <p class="pink-link-context">
        <a href="/wedderburn-artin-theorem/" rel="next" title="左 Artinian 环与 Wedderburn-Artin 定理">
          下一篇：左 Artinian 环与 Wedderburn-Artin 定理
        </a>
      </p>
      
                                            </div>

            </div>
        </div>
    </article>

    


    <section id="comment">
       <script src="https://giscus.app/client.js"
        data-repo="neozhaoliang/neozhaoliang.github.io"
        data-repo-id="MDEwOlJlcG9zaXRvcnkxNDQ4MTYxMDc="
        data-category="Announcements"
        data-category-id="DIC_kwDOCKG3684CPDuy"
        data-mapping="pathname"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="light"
        data-lang="en"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
       </script>
    </section>


</div>

                    <div class="fixed-action-btn float-sitemap">
    <a class="btn-floating btn-large pink">
      <i class="fa fa-caret-square-o-up"></i>
    </a>
    <ul>
      <li><a class="btn-return-top btn-floating waves-effect green" title="回到顶部"><i class="fa fa-arrow-circle-o-up"></i></a></li>
      <li><a class="btn-floating waves-effect button-collapse yellow darken-1"  data-activates="main-menu" title="菜单"><i class="fa fa-navicon"></i></a></li>
    </ul>
  </div>

            </main>
            


                <noscript>
    <div class="noscript">
        <p class="center-align">当前网速较慢或者你使用的浏览器不支持博客特定功能，请尝试刷新或换用Chrome、Firefox等现代浏览器</p>
    </div>
</noscript>
<div class="noscript">
    <p class="center-align">当前网速较慢或者你使用的浏览器不支持博客特定功能，请尝试刷新或换用Chrome、Firefox等现代浏览器</p>
</div>


<script src="/js/jquery.min.js"></script>
<script src="/js/materialize.min.js"></script>

<script>
    (function($) {
        $(document).ready(function() {
            // 隐藏禁用javascript（针对微信内置浏览器）的提示
            $('.noscript').hide();

            // 图片缩放效果
            var $imgs = $('img').not('.slider-image').not('.avatar-image').not('.carousel-image').not('.card-cover-image').not('.qrcode');

            // 给图片加上点击放大效果（materialbox插件）
            $imgs.addClass('materialboxed').each(function(i, el) {
                $(this).attr('data-caption', $(this).attr('alt') || ' ');
            }).materialbox();

            // 优化表格的显示
            $('table').each(function() {
                var $table = $(this);
                // 除去多行代码的情况
                if ($table.find('pre').length == 0) {
                    $table.addClass('responsive-table striped bordered');
                }
            });

            // 首页幻灯片
            $('.slider').slider({indicators: true, full_width: true, interval: 8000});

            $(".button-collapse").sideNav();
            $(".category-menu").sideNav();

            // 针对gallery post
            $('.carousel').carousel({full_width: true});
            $('.carousel-control.prev').click(function() {
                $('.carousel').carousel('prev');
            });
            $('.carousel-control.next').click(function() {
                $('.carousel').carousel('next');
            });

            // 文章目录
            $('article').not('.simple-article').find('h1').add('h2').add('h3').add('h4').add('h5').add('h6').scrollSpy();

            // 目录随屏幕滚动（防止目录过长越过footer）
            var $toc = $('.toc');
            var scrollTargetTop = 0;
            $(window).scroll(function() {
                var $activeLink = $toc.find('a.active.section');
                if ($(window).scrollTop() < 100) {
                    scrollTargetTop = 0;
                } else {
                    if ($activeLink[0]) {
                        scrollTargetTop = $activeLink.offset().top - $toc.offset().top;
                    }
                }
                $toc.css('top', '-' + scrollTargetTop + 'px');
            });

            // 修正文章目录的left-border颜色
            var color = $('.table-of-contents-text').css('color');
            $('.table-of-contents-link').css('border-left-color', color);

            // 针对移动端做的优化：FAB按钮点击一下收回
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                $('.fixed-action-btn').addClass('click-to-toggle');
            }
            // 回到顶部
            $('.btn-return-top').click(function() {
                $('body, html').animate({
                    scrollTop: 0
                }, 500);
            });

            // 重置读书页面的Tab标签页的颜色
            $('li.tab a').hover(function() {
                $(this).toggleClass('text-lighten-4');
            });
            $('.indicator').addClass('pink lighten-2');

            

            // 搜索功能
            $('.modal-trigger').leanModal({
                // 打开搜索框时自动聚焦
                ready: function() {
                    if ($('#search').is(":visible")) {
                        $('#search-input').focus();
                    }
                }
            });
            var searchXml = "search.xml";
            if (searchXml.length == 0) {
             	searchXml = "search.xml";
            }
            var searchPath = "/" + searchXml;
            initSearch(searchPath, 'search-input', 'search-result');
        });

        // 初始化搜索与匹配函数
        var initSearch = function(path, search_id, content_id) {
            'use strict';
            $.ajax({
                url: path,
                dataType: "xml",
                success: function(xmlResponse) {
                    // get the contents from search data
                    var datas = $("entry", xmlResponse).map(function() {
                        return {
                            title: $("title", this).text(),
                            content: $("content", this).text(),
                            url: $("url", this).text()
                        };
                    }).get();
                    var $input = document.getElementById(search_id);
                    var $resultContent = document.getElementById(content_id);
                    $input.addEventListener('input', function() {
                        var str = '<ul class=\"search-result-list\">';
                        var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                        $resultContent.innerHTML = "";
                        if (this.value.trim().length <= 0) {
                            return;
                        }
                        // perform local searching
                        datas.forEach(function(data) {
                            var isMatch = true;
                            var content_index = [];
                            var data_title = data.title.trim().toLowerCase();
                            var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                            var data_url = data.url;
                            var index_title = -1;
                            var index_content = -1;
                            var first_occur = -1;
                            // only match artiles with not empty titles and contents
                            if (data_title != '' && data_content != '') {
                                keywords.forEach(function(keyword, i) {
                                    index_title = data_title.indexOf(keyword);
                                    index_content = data_content.indexOf(keyword);
                                    if (index_title < 0 && index_content < 0) {
                                        isMatch = false;
                                    } else {
                                        if (index_content < 0) {
                                            index_content = 0;
                                        }
                                        if (i == 0) {
                                            first_occur = index_content;
                                        }
                                    }
                                });
                            }
                            // show search results
                            if (isMatch) {
                                keywords.forEach(function(keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    data_title = data_title.replace(regS, "<span class=\"search-keyword pink lighten-2\">" + keyword + "</span>");
                                });

                                str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                                var content = data.content.trim().replace(/<[^>]+>/g, "");
                                if (first_occur >= 0) {
                                    // cut out 100 characters
                                    var start = first_occur - 20;
                                    var end = first_occur + 80;
                                    if (start < 0) {
                                        start = 0;
                                    }
                                    if (start == 0) {
                                        end = 100;
                                    }
                                    if (end > content.length) {
                                        end = content.length;
                                    }
                                    var match_content = content.substring(start, end);
                                    // highlight all keywords
                                    keywords.forEach(function(keyword) {
                                        var regS = new RegExp(keyword, "gi");
                                        match_content = match_content.replace(regS, "<span class=\"search-keyword pink lighten-2\">" + keyword + "</span>");
                                    });

                                    str += "<p class=\"search-result\">..." + match_content + "...</p>"
                                }
                                str += "</li>";
                            }
                        });
                        str += "</ul>";
                        $resultContent.innerHTML = str;
                    });
                }
            });
        }
    })(jQuery);
</script>


<script src="/js/prettify.js"></script>
<script type="text/javascript">
    $(document).ready(function() {
        $("pre").addClass("prettyprint");
        prettyPrint();
    });
</script>






	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
  		tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
  		tex: 'ams'
		});
	</script>


	

			<script type="text/javascript"
				src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-svg.min.js?config=TeX-AMS_HTML"></script>

			
				

    </body>

    </html>