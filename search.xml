<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IFS 分形揭秘</title>
      <link href="/ifs-demystified/"/>
      <url>/ifs-demystified/</url>
      
        <content type="html"><![CDATA[<p>本文整理自我 2024/06/14 在上海科技大学数学所的一个小报告，标题是「GPU涂鸦与数学可视化」。这个报告是我和上科大数学所的陈浩老师、Abdelaziz NaitMerzouk合作的双曲反射群画展期间的一个助兴小节目。感谢陈浩老师一己之力将画展办起来，并带领我去外滩逛了一圈。我在画展现场拍摄了一些照片，但是由于光线和拍摄技术的原因，照片质量不是很好，就不放在这里献丑了。你可以在<a href="https://github.com/neozhaoliang/Hyperbolic-Honeycombs">项目主页</a>看到原汁原味的渲染图。</p><p>有机会的话，我很希望在后面的文章中讨论双曲反射群。但是关于双曲反射群我还有一些技术细节需要消化，所以这里我只能忍痛跳过这个话题，只介绍我报告的主要内容，即怎样在GPU 上画分形。我略去了报告中关于 demoscene 和分形文化的部分。</p><span id="more"></span><hr><p>在 Shadertoy上有很多效果酷炫，但是代码非常短的分形作品。我挑选了其中三个优秀的例子展示如下：</p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr class="odd"><td style="text-align: center;"><a href="https://www.shadertoy.com/view/ltB3DG">Ethereal</a> by Kali</td><td style="text-align: center;"><a href="https://www.shadertoy.com/view/NsVyRz">Apollonian fractal</a> byXor</td><td style="text-align: center;"><a href="https://www.shadertoy.com/view/mdG3Wy">Radiosity</a> by Xor</td></tr><tr class="even"><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/ltB3DG.jpg"></td><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/NsVyRz.jpg"></td><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/mdG3Wy.jpg"></td></tr></tbody></table><p>然而代码短可不代表它们容易看懂。尤其是很多作者还喜欢故弄玄虚，把代码作了混淆处理以增加神秘感。对我来说，这种被人秀了一脸却没搞明白对面是怎么装的逼的感觉让人很不爽。当然我不是在抱怨，这种炫技行为本身就是黑客文化的一部分，可以理解。</p><p>后来分形玩的多了，我也慢慢明白了其中的奥妙，他们是在玩一种很特别的“折纸游戏”——只是这个纸是空间本身。我们将要揭秘的，就是这种空间折纸术背后的数学原理。这些分形作品别看场景千变万化，其实都是用同一个套路制作出来的。这个套路可以简述为三步：</p><ol type="1"><li>首先将像素的 2D 坐标映射为空间中的某个 3D 点 <code>p</code>；</li><li>然后用一个 <code>fold</code> 函数，反复作用在 <code>p</code>上，将<code>p</code> 变换到空间中另一个位置。这个 <code>fold</code>的作用就是折纸。每次迭代结束后，生成一个颜色并将其添加到当前的颜色<code>color</code> 上。</li><li>经过若干次迭代后，终止迭代，返回 <code>color</code>的值作为像素最终的颜色。</li></ol><p><code>fold</code> 函数背后的原理是所谓的 IFS（Iterated FunctionSystem，迭代函数系统），更准确的说，它是 IFS 的逆函数。使用 IFS的逆函数而不是 IFS 本身的原因是，正向的 IFS 是没有办法在 GPU上并行实现的。</p><p>那些耳熟能详的分形，例如 Menger Sponge、Koch 曲线、Sierpinski carpet等等，都属于IFS。所以说白了，上面那些酷炫的分形，从原理上和这些经典分形没有什么不同，区别只在于<code>fold</code> 函数的构造方式。</p><p>总之，要理解这一切，我们既要了解怎样通过 IFS 构建分形，还要了解怎样在GPU 上编程实现它。我们先从 IFS 开始说起。</p><h1 id="ifs-方法">IFS 方法</h1><div id="------------" class="unnumbered statement sta_____ plain"><p><span class="statement-heading"><span class="statement-label">压缩映射</span>.</span><span class="statement-spah"> </span><br></p><p>设 <span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}^n\)</span>是一个映射，如果存在 <span class="math inline">\(0&lt;r&lt;1\)</span>使得对任何 <span class="math inline">\(x,y\in\mathbb{R}^n\)</span> 有<span class="math display">\[d(f(x),f(y))\leq r\cdot d(x,y)\]</span>成立，我们就称 <span class="math inline">\(f\)</span>是一个压缩映射，<span class="math inline">\(r\)</span> 是压缩比例。这里<span class="math inline">\(d\)</span> 是通常的 Euclidean 距离。</p></div><p>记 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span>中所有紧集组成的集合，可以证明 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 在 <a href="https://en.wikipedia.org/wiki/Hausdorff_distance">Hausdorff度量</a> 下构成一个完备度量空间。你现在不必关心 Hausdoff度量的具体细节！你只要知道它是一个度量，可以衡量两个紧集的接近程度即可。</p><p>设 <span class="math inline">\(\{f_i\}_{i=1}^N\)</span> 是 <span class="math inline">\(N\)</span> 个不同的压缩映射，<span class="math inline">\(f_i\)</span> 的压缩比例是 <span class="math inline">\(0&lt;r_i&lt;1\)</span>。定义映射 <span class="math inline">\(F:K(\mathbb{R}^n)\to K(\mathbb{R}^n)\)</span>如下： <span class="math display">\[F(X) = f_1(X)\cupf_2(X)\cup\cdots\cup f_N(X),\quad X\in K(\mathbb{R}^n).\]</span>也就是说，给你一个图形 <span class="math inline">\(X\)</span>，我们将它变形成 <span class="math inline">\(N\)</span>个版本，每个版本分别应用一个压缩变换、再把所有部分合起来，得到新的集合<span class="math inline">\(F(X)\)</span>。</p><p>可以证明 <span class="math inline">\(F\)</span> 是空间 <span class="math inline">\(K(\mathbb{R}^n)\)</span>上的压缩映射，其压缩比例不超过 <span class="math inline">\(r=\max\{r_1,\ldots,r_N\}\)</span>。于是根据 <a href="https://en.wikipedia.org/wiki/Banach_fixed-point_theorem">Banach不动点定理</a>，存在唯一的紧集 <span class="math inline">\(A\subset\mathbb{R}^n\)</span> 使得 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(F\)</span> 的不动点： <span class="math display">\[F(A) = A.\]</span> 紧集 <span class="math inline">\(A\)</span> 叫做 <span class="math inline">\(F\)</span> 的极限集。<span class="math inline">\(A\)</span> 是一个分形，它具有自相似的特征。</p><p>不仅如此，Banach 不动点定理还告诉我们，对 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 中的任何一点 <span class="math inline">\(K\)</span>（记住 <span class="math inline">\(K\)</span> 是紧集），都有 <span class="math display">\[\lim_{n\to\infty} F^n(K) =A.\]</span>换言之，从任何紧集 <span class="math inline">\(K\)</span> 出发，反复应用<span class="math inline">\(F\)</span>，最终都会收敛到分形 <span class="math inline">\(A\)</span>！</p><p>这个过程有点像孙悟空拔出毫毛，变出许多小猴子，每个小猴子再变出更多的小猴子，如此反复，假设这个过程可以无限进行下去，那么最终所有的小猴子会形成分形结构。</p><p>我们以著名的 <a href="https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle">Sierpiński三角形</a> 为例来说明这个过程。我们选择的三个压缩映射分别是</p><p><span class="math display">\[\begin{aligned}f_1(x,y) &amp;= (x/2, y/2),\\f_2(x,y) &amp;= (x/2, y/2) + (0, 1/2),\\f_3(x,y) &amp;= (x/2, y/2) + (1/2, 0).\\\end{aligned}\]</span></p><p>这三个压缩映射的压缩比都是 1/2。初始的紧集 <span class="math inline">\(K_0\)</span> 可以随便选，比如就取为一个圆：</p><p><span class="math display">\[K_0 =\img{/images/ifs/dot0.svg}{-1.75em}{}{4em}.\]</span></p><p>在第 1次迭代后，它被压缩成三个更小的版本，分别放到三角形的三个角落上：</p><p><span class="math display">\[K_1 = f_1(K_0)\cup f_2(K_0)\cup f_3(K_0)= \img{/images/ifs/dot1.svg}{-1.75em}{}{4em}.\]</span></p><p>在第 2 次迭代后，结果是</p><p><span class="math display">\[K_2 = f_1(K_1)\cup f_2(K_1)\cup f_3(K_1)= \img{/images/ifs/dot2.svg}{-1.75em}{}{4em}.\]</span></p><p>第 3 次迭代：</p><p><span class="math display">\[K_3 = f_1(K_2)\cup f_2(K_2)\cup f_3(K_2)= \img{/images/ifs/dot3.svg}{-1.75em}{}{4em}.\]</span></p><p>不断重复这个分裂并压缩的过程，当迭代次数趋于无穷，就得到了 Sierpiński分形：</p><p><span class="math display">\[\lim_{n\to\infty} K_n = A = f_1(A)\cupf_2(A)\cup f_3(A) =\img{/images/ifs/dot6.svg}{-1.75em}{}{4em}.\]</span></p><p>你可以很容易看出来为什么初始紧集的选择是不重要的：因为在压缩的过程中，任何紧集都会逐渐缩小到一个单点，所以<span class="math inline">\(K_0\)</span> 甚至取成一个点也是可以的。</p><p>压缩映射是无穷无尽的，所以 IFS分形也是无穷无尽的。为了避免选择困难，我们一般只使用仿射和球反演这两种变换，通过组合它们来实现空间压缩。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这里的球反演变换是指将单位球的外部反演到内部，单位球内部保持不动的变换。虽然在单位球内部它并不压缩距离，但是只要和其它变换适当组合，使得最终的复合变换是压缩的，就仍然可以得到分形。</p></div><p>然而，同时选择 <span class="math inline">\(N\)</span> 个不同的变换<span class="math inline">\(f_1,\ldots,f_N\)</span>，还要让它们互相协调合作，共同生成漂亮的分形图案，还是太难了。而且还有一个困难是，每次迭代时我们都需要维护当前已经生成的集合<span class="math inline">\(f_1(K_n),\ldots,f_N(K_n)\)</span>，随着<span class="math inline">\(n\)</span> 的增加这个集合是指数增长的，在CPU 上对不太大的 <span class="math inline">\(n\)</span>或许勉强可以处理，但是在 GPU上就不太现实了。我们后面会介绍，在着色器中绘制 IFS 是通过 <span class="math inline">\(F\)</span> 的逆映射 <span class="math inline">\(F^{-1}\)</span> 来实现的，<span class="math inline">\(F^{-1}\)</span>就是本文开头提到的「折纸」操作，它是一种「空间折叠」操作，可以通过”串联”若干折叠函数来实现。就像古代的炼丹师会通过反复调整原料配方来寻找效果最佳的丹药一样，设计分形也可以通过调整<span class="math inline">\(F^{-1}\)</span>中的折叠函数，并观察屏幕上显示的效果来实现。所以你根本无需关心 <span class="math inline">\(f_i\)</span> 是什么！</p><h1 id="轨道着色">轨道着色</h1><p>虽然分形背后的原理不过是IFS，但是要想把分形画得惊艳，还少不了一个秘密配方，这就是轨道着色。绝大多数惊艳的分形作品都是通过轨道着色技巧来上色的。</p><p>我们希望给分形染上漂亮的颜色，这个染色应该满足如下的条件：</p><ol type="1"><li>在分形上颜色是连续变化的；</li><li>在分形和非分形的交界处（即 <span class="math inline">\(A\)</span> 和<span class="math inline">\(A^c\)</span>的边界上）颜色应该是不连续的，从而产生泾渭分明的效果。</li></ol><p>做到这一点并不难，但是需要在每一次迭代时考虑当前点的位置信息，这就是所谓的轨道着色。</p><p>我们首先取一个底色，比如说<code>color=vec3(0)</code>，在每一次迭代中，根据当前位置 <code>p</code>生成一个颜色，并以一定的权重与 <code>color</code> 混合。理论上颜色的 rgb的取值范围应该是 <span class="math inline">\([0,1]\)</span>，但是多数情况下我们要放宽到 <span class="math inline">\([-1,1]\)</span>之间，即颜色可以增加也可以减少。否则如果颜色只增不减的话，那么多次迭代以后rgb 值很可能会溢出，变成白色。此外，随着迭代次数 <span class="math inline">\(n\)</span> 的增加，<span class="math inline">\(F^n(K)\)</span> 越来越接近真实的分形 <span class="math inline">\(A\)</span>，后面加入的颜色的权重应该单调下降，以保证突出分形的细节。这也符合我们的生活直觉：想象一下，当一位画家作画时，在开始的时候他可以浓墨重彩地画一个轮廓，但是越到后面描绘更加精细的部分时，他就会换用更细的画笔，小心地蘸一点颜料。</p><p>根据 <code>p</code>生成颜色的着色方案无穷无尽，请随便发挥你的创造力。一般来说你需要反复试验各种不同的方案才能找到最合适的。下面的例子使用了一种非常流行的染色方案，它以<code>cos(vec3(0,1,2))</code> 作为底色，并根据当前时间<code>iTime</code> 以及坐标 <code>uv</code> 进行调整：</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 uv = fragCoord / iResolution.xy;    vec3 col = 0.5 + 0.45 * cos(vec3(0, 1, 2) + iTime + uv.yxy);    fragColor = vec4(col, 1.0);}"></div><h1 id="着色器编程基础">着色器编程基础</h1><p>我简单介绍一下着色器编程的基本概念。打开 shadertoy网站，点击右上角的<code>新建</code>按钮，你会看到一个 <a href="https://www.shadertoy.com/new">最简单的动画</a>：</p><p><img src="/images/ifs/shadertoy.png" class="fig" width="600"></p><p>左边的窗口是画布，显示渲染的结果；右边窗口是代码编辑器，你在这里书写着色器代码。写完以后，点击编辑器界面左下角的三角形（或者按下<code>Alt + Enter</code>）查看编译后的效果。</p><p>画布是由若干像素组成的，你需要根据每个像素的位置，即它的<code>fragCoord</code> 值指定一个颜色。这个过程是在<code>mainImage</code> 函数中实现的：</p><figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> mainImage(<span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> fragColor, <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> fragCoord);<br></code></pre></td></tr></tbody></table></figure><p>其中 <code>fragCoord</code> 是像素的位置，<code>fragColor</code>是需要设置的像素颜色。</p><p>现实生活中有一个很形象的例子可以帮你理解着色器编程：假设你是一场方阵表演的导演，所有演员排成一个<span class="math inline">\(W\times H\)</span>的方阵，每个演员可以改变自己衣服的颜色。你的任务是发出合适的指令让每个演员根据自己的位置计算出正确的颜色，使得整个方阵呈现出漂亮的图案。</p><p><img src="/images/ifs/array.png" class="fig" width="600"></p><p>如果你一个一个地对每个演员下指令，张三你应该显示红色，李四你应该显示蓝色，等等…对成千上万个演员，这么挨个下指令还不得把人累死？正确的做法是，你应该同时对所有演员发出相同的指令，比如：“每个人，计算自己和方阵中心的距离，小于10 米的显示红色，大于等于 10 米的显示黑色”。由于每个演员都是一个单独的GPU计算单元，他们可以根据你发出的同一条指令，在极短的时间内（毫秒级）分别计算出各自的颜色。计算完毕后，观众应该会看到一个红色的圆。这种基于相同指令并行计算的工作方式就是GPU 流水线的机制。</p><p>我们来试试在着色器中实际编程绘制这个圆的例子。为了方便起见，我们假设方阵的中心是原点，并尝试绘制一个以原点为中心，半径是0.5 的圆。这只需要三行代码：</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;    float d = length(p) - 0.5;    fragColor = d > 0.0 ? vec4(0, 0, 0, 1) : vec4(1, 0, 0, 1);}"></div><ul><li>首先，每个演员会根据自己在方阵中的位置<code>fragCoord</code>，计算自己的归一化坐标 <code>p</code>，使得<code>p</code> 的纵坐标 <code>p.y</code> 位于 <span class="math inline">\([-1,1]\)</span> 中；</li><li>然后，每个演员计算自己到以原点为中心、半径为 0.5 的圆的距离<code>d</code>。位于圆内部的演员得出的 <code>d</code>是负数，圆外部的演员得出的 <code>d</code> 是正数；</li><li>最终每个人根据 <code>d</code> 的符号来确定自己的颜色。</li></ul><p>你可以修改上面代码中的半径，颜色等参数，观察左边画布的变化来体会效果。</p><p>这个例子其实蕴含了 shader编程的一个非常核心的概念，即<strong>距离场</strong> (distancefield)。当我们想绘制某个图案时，我们通过计算像素到这个图案的距离来对像素进行着色。在绘制IFS分形时，我们同样需要计算像素到分形的距离，并根据距离值来确定像素的颜色。这一点在下节会详细介绍。</p><h1 id="空间折叠">空间折叠</h1><p>现在，我们已经介绍了所有必要的预备知识，可以正式介绍怎样在 GPU上实现折纸操作了。</p><p>上面讲到，在着色器里面画 IFS就是给每个像素指定一个颜色，这个颜色应该由像素对应的点到分形的距离来决定。假设像素对应空间中的点<span class="math inline">\(p\)</span>，初始紧集是 <span class="math inline">\(K\)</span>，我们用迭代 <span class="math inline">\(n\)</span> 次的结果 <span class="math inline">\(F^n(K)\)</span> 作为分形的近似，这里 <span class="math inline">\(n\)</span> 是某个常数，在绝大多数场景下 <span class="math inline">\(n=30\)</span> 就足够了。于是我们需要计算距离 <span class="math inline">\(d(p,F^n(K))\)</span>并根据这个距离值对像素染色。然而我们已经讲过，直接计算 <span class="math inline">\(d(p,F^n(K))\)</span> 是不可行的，因为如果有 <span class="math inline">\(N\)</span> 个不同的压缩映射 <span class="math inline">\(f_1,\ldots,f_N\)</span>，那么每次迭代后集合的数目会乘以<span class="math inline">\(N\)</span>，这是指数增长的，10次迭代后就会产生多达 <span class="math inline">\(N^{10}\)</span>个不同的集合。维护如此数量的集合会轻易耗尽内存，更不用说还要计算 <span class="math inline">\(p\)</span> 到每个集合的距离了。这该怎么办呢？</p><p>有个巧妙的做法可以绕过这个困难：我们把 <span class="math inline">\(d(p,F^n(K))\)</span> 中的 <span class="math inline">\(F^n\)</span> 挪到 <code>p</code>所在的一侧并取逆，转而计算 <span class="math inline">\(d(F^{-n}(p),K)\)</span>！实际上，如果 <span class="math inline">\(F\)</span>只包含旋转、平移、反射、缩放、球反演这些变换的话，<span class="math inline">\(d(p,F^n(K))\)</span> 和 <span class="math inline">\(d(F^{-n}(p), K)\)</span>之间存在非常简单的关系，我们可以通过计算后者来得到前者！这个关系的推导我放在<a href="#note-F" title="注释">注释</a>中介绍。现在，你暂时可以认为它俩是差不多的。</p><p>于是，在着色器编程时，我们需要将压缩迭代映射的步骤倒过来，采取相反的操作：即将逆映射<span class="math inline">\(F^{-1}\)</span> 迭代作用在 <span class="math inline">\(p\)</span> 上，执行足够的迭代次数后，通过计算距离<span class="math inline">\(d(F^{-n}(p), K)\)</span> 来给 <span class="math inline">\(p\)</span> 对应的像素上色。由于 <span class="math inline">\(F\)</span> 是“一对多” 的映射，所以 <span class="math inline">\(F^{-1}\)</span> 是 “多对一”的，反复迭代应用 <span class="math inline">\(F^{-1}\)</span>会把空间“折叠”。我们实际上是在这个折叠后的空间上作画。</p><p>总而言之，在着色器编程中我们真正需要的函数不是 <span class="math inline">\(F\)</span>，而是 <span class="math inline">\(F^{-1}\)</span>！</p><p>这个先折叠后画图的操作，和剪纸艺术是一模一样的：</p><figure><img src="/images/ifs/papercut.jpg" width="480" alt="在剪纸过程中，首先把纸张反复折叠，然后在折叠后的纸张上画出某个特定的图形，沿着这个图形裁剪，再将纸张展开得到的就是美丽的图案。展开纸张的操作对应迭代映射 F，它把一个初始的紧集铺开到空间中变成分形；折叠纸张的操作对应 F^{-1}，它把分形折叠回最初的紧集。"><figcaption aria-hidden="true">在剪纸过程中，首先把纸张反复折叠，然后在折叠后的纸张上画出某个特定的图形，沿着这个图形裁剪，再将纸张展开得到的就是美丽的图案。<strong>展开</strong>纸张的操作对应迭代映射<span class="math inline">\(F\)</span>，它把一个初始的紧集铺开到空间中变成分形；<strong>折叠</strong>纸张的操作对应<span class="math inline">\(F^{-1}\)</span>，它把分形折叠回最初的紧集。</figcaption></figure><p>在设置 <span class="math inline">\(F^{-1}\)</span>的时候，我们完全不必关心每个 <span class="math inline">\(f_i\)</span>是什么，我们需要的只是准备一些折叠函数，然后将它们组合起来得到 <span class="math inline">\(F^{-1}\)</span>。</p><p>如果你去看那些分形作品的代码的话，会发现它们几乎都在 <span class="math inline">\(F^{-1}\)</span> 中使用了 <code>abs</code>函数。这个函数是最简单的空间折叠函数，它会把整个空间折叠到第一象限。进一步，再叠加关于平面/球面的反射可以产生出更复杂的折叠。</p><p>在下面的例子中，我们首先用 <code>p = abs(p)</code>将整个空间折叠到第一象限，这相当于折纸的时候将纸对折两次；然后只要在第一象限中剪出一个圆，就可以同时在其它象限自动得到另外三个圆：</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;    p = abs(p); //折叠    float d = length(p - vec2(0.5)) - 0.3; // 中心在 (0.5, 0.5), 半径为 0.3 的圆    d = smoothstep(-0.005, 0.005, d); // 平滑一下边缘    vec3 col = mix(vec3(0), vec3(0.9), d); //染色    fragColor = vec4(col, 1);}"></div><p>或者还用方阵的例子作比喻，相当于你对方阵下的指令是：“每个人，首先把自己的y 坐标归一化到 [-1, 1] 区间，然后计算自己坐标的绝对值，再计算到以 (0.5,0.5)，半径为 0.3 的圆的距离，最后根据距离值显示颜色”。如果把整个方阵记作<span class="math inline">\(A\)</span> 的话，取绝对值操作以后，<span class="math inline">\(A\)</span> 变成了 2x2 分块矩阵： <span class="math display">\[A = \begin{pmatrix}B&amp;B\\B&amp;B\end{pmatrix}.\]</span> 之后的计算对这 4 个 子方阵 <span class="math inline">\(B\)</span> 都是一样的，所以你会同时看到 4个圆。</p><p>这就体现出空间折叠操作的优势来了：你不需要在每个象限分别画一个圆，相反，你可以通过折叠象限，只画一个圆！</p><hr><div id="note-F" class="statement sta_d_p_f_n_k_____d_f___n__p___k_______ definition unnumbered"><p><span class="statement-heading"><span class="statement-label"><span class="math inline">\(d(p,F^n(K))\)</span> 和 <span class="math inline">\(d(F^{-n}(p), K)\)</span>之间的关系</span>：</span><span class="statement-spah"> </span><br></p><p>如果 <span class="math inline">\(F\)</span>是平移、旋转、反射这样的保持 Euclidean 距离不变的刚体运动，那么自然有<span class="math display">\[d(p, F(K)) = d(F^{-1}(p), K).\]</span></p><p>如果 <span class="math inline">\(F\)</span> 是一个缩放变换，比如<span class="math inline">\(F(x) = x/s\,(s&gt;1)\)</span>，那么 <span class="math display">\[d(p, F(K)) = d(p, 1/s\cdot K) = 1/s\cdot d(s\cdotp, K) = 1/s\cdot d(F^{-1}(p), K).\]</span>即我们要对折叠以后算出来的距离值再除以 <span class="math inline">\(s\)</span>。</p><p>既然每次迭代 <span class="math inline">\(F\)</span> 以比例 <span class="math inline">\(1/s\)</span> 缩小，所以用 <span class="math inline">\(F^{-1}\)</span> 迭代 <span class="math inline">\(n\)</span> 次以后累积放大的比例就是 <span class="math inline">\(s^n\)</span>，我们要将 <span class="math inline">\(d(F^{-n}(p), K)\)</span> 再除以 <span class="math inline">\(s^n\)</span> 才是最终正确的距离值。</p><p>对球的反演变换，甚至更一般的变换，我们可以通过计算 <span class="math inline">\(F^{-1}\)</span> 在 <span class="math inline">\(p\)</span> 处 Jacobian 矩阵的行列式的绝对值，作为<span class="math inline">\(p\)</span>处缩放的近似。把迭代过程中所有这些行列式的绝对值相乘，并对最后得到的<span class="math inline">\(d(F^{-n}(p), K)\)</span>再除以这个乘积，就可以作为 <span class="math inline">\(d(p,F(K))\)</span> 的近似。</p></div><h1 id="实战演示">实战演示</h1><p>我以 Shadertoy 上一个混淆过的 <a href="https://www.shadertoy.com/view/WlGyWK">作品</a>为例子来完整展示上面的理论。下面是重新改写后的可读版本，我在注释中解释了每一步的含义：</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/l3cXR7?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe>]]></content>
      
      
      <categories>
          
          <category> Shadertoy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>咖啡杯中的焦散线</title>
      <link href="/envelope-and-caustics/"/>
      <url>/envelope-and-caustics/</url>
      
        <content type="html"><![CDATA[<p>春节的晚上，外面鞭炮喧天，家人在看电视，我躲在屋里看数学，还是挺惬意的。</p><p>我最近一直在翻 <a href="https://johncarlosbaez.wordpress.com">JohnBaez</a> 和 <a href="https://www.gregegan.net">Greg Egan</a>的博客。John Baez是一位在科普方面非常高产的数学家，写过不计其数的科普文章。读他的文章非常让人享受，因为他总是从直观的例子入手，一步步启发读者，展开到更高级的数学。GregEgan是澳大利亚的一位非常高产的科幻小说作家，有不少作品已经被国内引入。他的小说属于硬科幻风格，而且是非常硬的那种。他也有不少有趣的<a href="https://www.gregegan.net/SCIENCE/Science.html">博客文章</a>。不过与John Baez 不同的是，Greg Egan的文章不太会去兼顾不同水平的读者，对我来说，要看懂他在说什么经常不是一件容易的事情。</p><p>John Baez 博客上有一个系列 <a href="https://johncarlosbaez.wordpress.com/2012/08/31/rolling-circles-and-balls-part-1/">Rollingcircles and balls</a> 讨论了圆的外摆线和焦散，Greg Egan 也有一篇 <a href="https://www.gregegan.net/SCIENCE/Catacaustics/Catacaustics.html">文章</a>更深入的讨论了曲线的焦散。这个话题非常有意思，我也一时手痒写代码实验了一番并记录在此。</p><span id="more"></span><h1 id="pov-ray-光学实验">POV-Ray 光学实验</h1><p>你肯定见过这个物理现象：当光线照在咖啡杯的内壁上时，会在杯子底部形成一道明亮的曲线，术语叫做焦散(caustic)。</p><p><img src="/images/caustics/cup.jpg" class="fig" width="400"></p><p>形成焦散的原因是，光线在杯子内壁反射以后，光子的分布是不均匀的，某些区域经过的光子特别密集，所以亮度就更高。</p><p>焦散是一条曲线，它和所有的反射光线相切。用数学的术语，焦散是所有反射光线的<a href="https://en.wikipedia.org/wiki/Envelope_(mathematics)">包络</a>(envelope)。焦散的具体形状和杯子的形状、光源的位置都有关。如果杯子是圆形的，则当光源是点光源且恰好位于杯子边缘上某一点时，焦散是<a href="https://en.wikipedia.org/wiki/Cardioid">心脏线</a>(cardioid)；当光源位于无穷远时（这时可以视作平行光源），焦散是 <a href="https://en.wikipedia.org/wiki/Nephroid">肾形线</a>(nephroid)。一般情况下焦散的形状介于心脏线和肾形线之间。</p><p>最令人称奇的是下面这个事实：如果我们进一步，用一个心脏线形状的杯子，并把光源放在它的尖点上，你猜我们会得到什么？</p><p>没错，是一条肾形线！</p><p>我写了一个 <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/catacaustic">POV-Ray脚本</a> 模拟来验证这一现象：</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr class="odd"><td style="text-align: center;">圆形杯子给出心脏线</td><td style="text-align: center;">心脏线杯子给出肾形线</td></tr><tr class="even"><td style="text-align: center;"><img src="/images/caustics/caustics_cardioid.png" class="fig" width="400"></td><td style="text-align: center;"><img src="/images/caustics/caustics_nephroid.png" class="fig" width="400"></td></tr></tbody></table><p>这太奇妙了！圆、心脏线、肾形线之间似乎存在着某种深刻的联系。事实上，心脏线和肾形线都属于一个优美的几何曲线家族，叫做<a href="https://en.wikipedia.org/wiki/Epicycloid">外摆线</a>。它们都是由一个小圆沿着一个大圆外侧滚动时，小圆上某一点的运动轨迹。它们的区别仅仅在于两圆的半径之比不同：</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr class="odd"><td style="text-align: center;">心脏线</td><td style="text-align: center;">肾形线</td></tr><tr class="even"><td style="text-align: center;"><video src="/images/caustics/cardioid.mp4" controls=""></video></td><td style="text-align: center;"><video src="/images/caustics/nephroid.mp4" controls=""></video></td></tr></tbody></table><p>这就引出了一个很自然的问题：既然圆生成了心脏线，心脏线又生成了肾形线，那我们用肾形线杯子在它的尖点放一个光源，是不是会得到下一个外摆线呢？</p><p>唉，根据 Greg Egan的实验，这个漂亮的猜想似乎并不成立。看来数学的规律有时并不像我们希望的那样无限延伸。</p><h1 id="求解参数曲线的焦散">求解参数曲线的焦散</h1><p>好了，欣赏完这些漂亮的图片，你可能会好奇，我们能用数学精确地证明这一切吗？</p><p>当然可以！这一节我们来介绍怎样计算一般的参数曲线 <span class="math inline">\(\mathbf{c}(t)=(x(t),y(t))\)</span> 的焦散。</p><p>设点光源的位置是 <span class="math inline">\((a,b)\)</span>，对于曲线上的一点 <span class="math inline">\((x,y)\)</span>，该点处入射光线的方向是 <span class="math display">\[\mathbf{l}=(x-a,y-b).\]</span> 这里不需要把 <span class="math inline">\(\mathbf{l}\)</span>单位化，因为我们列方程的时候只需要光线的方向，并不在乎长度。</p><p>接着，我们需要曲线在该点的法向量。如果你还记得微积分，法向量可以这样计算：<span class="math display">\[\mathbf{n}=\frac{(-y',x')}{\sqrt{(x')^2+(y')^2}}=\frac{(-y',x')}{|\mathbf{c}'|}.\]</span> 这里我们用 <span class="math inline">\(x',y'\)</span> 表示 <span class="math inline">\(x,y\)</span> 关于 <span class="math inline">\(t\)</span> 的导数。</p><p>根据反射定律，反射光线的方向 <span class="math inline">\(\mathbf{r}\)</span> 由下面的公式给出： <span class="math display">\[\mathbf{r}= \mathbf{l}- 2(\mathbf{l}\cdot\mathbf{n})\mathbf{n}.\]</span>现在，焦散是所有这些反射光线的包络。求解包络线是一个经典的微积分问题。</p><p>设 <span class="math inline">\((X,Y)\)</span>是反射光线上的任一点，由于 <span class="math inline">\((x,y)\)</span>是反射光线的起点，所以 <span class="math inline">\((X-x,Y-y)\)</span> 与<span class="math inline">\(\mathbf{r}\)</span> 平行。记 <span class="math inline">\(\mathbf{r}=(r_x,r_y)\)</span>，则 <span class="math inline">\((X-x,Y-y)\)</span> 与 <span class="math inline">\((-r_y, r_x)\)</span> 垂直，即 <span class="math display">\[(X-x, Y-y)\cdot(-r_y, r_x)=0.\]</span>不要急着把这个式子展开！保持它的矩阵形式会更方便。记 <span class="math display">\[F(X,Y,t)=(X-x, Y-y)\cdot(-r_y, r_x),\]</span>则我们得到了反射光线 <span class="math inline">\((X(t), Y(t))\)</span>满足的曲线族方程 <span class="math inline">\(F(X,Y,t)=0\)</span>。要求这族曲线的包络，我们需要解下面这个方程组：<span class="math display">\[\begin{align}F(X,Y,t)=0,\\\frac{\partialF}{\partial t}F(X,Y,t)=0.\end{align}\]</span> 也就是 <span class="math display">\[\begin{align}(X-x, Y-y)\cdot(-r_y,r_x)&amp;=0,\\-(x',y')\cdot(-r_y, r_x) +(X-x,Y-y)\cdot(-r_y', r_x') &amp;=0.\end{align}\]</span>然后解出 <span class="math inline">\(X,Y\)</span> 得到。</p><p>如果你还记得 2x2矩阵的逆公式的话，这个方程组其实可以目视写出解来。我们把它写成</p><p><span class="math display">\[\begin{pmatrix}-r_y &amp; r_x\\-r_y'&amp;r_x'\end{pmatrix}\cdot\begin{pmatrix}X-x\\Y-y\end{pmatrix}=\begin{pmatrix}0\\r_xy'-r_yx'\end{pmatrix}.\]</span> 于是不难解出 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix} +\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span></p><p>让我们请出值得信赖的计算伙伴 <code>sympy</code>来验证一下。假设圆心是原点，半径为 1，光源在 <span class="math inline">\((1,0)\)</span> 处。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>t, X, Y = symbols(<span class="hljs-string">"t X Y"</span>)<br>C = Matrix([cos(t), sin(t)]) <span class="hljs-comment"># curve</span><br>light = Matrix([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]) <span class="hljs-comment"># light source</span><br>l = C - light <span class="hljs-comment"># incident ray</span><br>dx, dy = diff(C, t)<br>n = Matrix([dy, -dx]) <span class="hljs-comment"># normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n)) <span class="hljs-comment"># reflected ray</span><br>F = (Y - y) * r[<span class="hljs-number">0</span>] - (X - x) * r[<span class="hljs-number">1</span>]<br>dF = diff(F, t)<br>result = solve((F, dF), X, Y) <span class="hljs-comment"># solve the envelope</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f"X(t)=<span class="hljs-subst">{trigsimp(result[X], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f"Y(t)=<span class="hljs-subst">{trigsimp(result[Y], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 给出的结果正是我们期待的心脏线参数方程：</p><p><span class="math display">\[\left\{\begin{align}x(t)&amp;=\frac{\cos(2t) +2\cos(t)}{3},\\ y(t)&amp;=\frac{\sin(2t) +2\sin(t)}{3}.\end{align}\right.\]</span></p><p>使用这个参数表示，我们继续计算当光源放在心脏线的尖点，即 <span class="math inline">\(t=\pi\)</span> 对应的点 <span class="math inline">\((-\frac{1}{3},0)\)</span> 时得到的焦散：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>t, X, Y = symbols(<span class="hljs-string">"t X Y"</span>)<br>C = Matrix([(<span class="hljs-number">2</span>*cos(t) + cos(<span class="hljs-number">2</span>*t)) / <span class="hljs-number">3</span>, (<span class="hljs-number">2</span>*sin(t) + sin(<span class="hljs-number">2</span>*t)) / <span class="hljs-number">3</span>])<br>light = Matrix([S(<span class="hljs-string">'-1/3'</span>, evaluate=<span class="hljs-literal">False</span>), <span class="hljs-number">0</span>])<br>l = C - light <span class="hljs-comment"># incident ray</span><br>dx, dy = diff(C, t)<br>n = Matrix([dy, -dx]) <span class="hljs-comment"># normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n)) <span class="hljs-comment"># reflected ray</span><br>F = (Y - y) * r[<span class="hljs-number">0</span>] - (X - x) * r[<span class="hljs-number">1</span>]<br>dF = diff(F, t)<br>result = solve((F, dF), X, Y) <span class="hljs-comment"># solve the envelope</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f"X(t)=<span class="hljs-subst">{trigsimp(result[X], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f"Y(t)=<span class="hljs-subst">{trigsimp(result[Y], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 很快算出了正确的结果：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X(t)=sin(t)*sin(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span> + cos(t)/<span class="hljs-number">3</span><br>Y(t)=-sin(t)*cos(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span> + sin(t)/<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>不难验证</p><p><span class="math display">\[\begin{align}\frac{\sin(t)\sin(2t) +\cos(t)}{3}&amp;=\frac{3\cos(t) - \cos(3t)}{6},\\ \frac{-\sin(t)\cos(2t)+ \sin(t)}{3}&amp;=\frac{3\sin(t) -\sin(3t)}{6}.\end{align}\]</span></p><p>这正是 <a href="https://en.wikipedia.org/wiki/Nephroid#Parametric">维基百科</a>中所列的肾形线的参数方程中取 <span class="math inline">\(a=1/6\)</span>的结果。</p><p>把上面的曲线画出来是这样的：</p><p><img src="/images/caustics/caustics_matplotlib.svg" class="fig" width="400"></p><h1 id="求解多项式曲线的焦散">求解多项式曲线的焦散</h1><p>很多时候曲线的方程是通过隐函数 <span class="math inline">\(P(x,y)=0\)</span> 的形式给出的，其中 <span class="math inline">\(P(x,y)\)</span> 是关于两个变元 <span class="math inline">\(x,y\)</span>的多项式。这样的曲线叫做平面代数曲线。这时求解焦散要用到 Gröbner基的工具。</p><p>在参数方程的情形，我们已经推导出了焦散的显式解</p><p><span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix} +\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span></p><p>其中 <span class="math inline">\(x,y,r_x,r_y\)</span> 都是关于 <span class="math inline">\(t\)</span>的函数，它们的导数也是可计算的，所以可以算出 <span class="math inline">\((X,Y)\)</span> 来。</p><p>但是在隐函数的情形，我们没有 <span class="math inline">\(x,y\)</span>的某种关于 <span class="math inline">\(t\)</span>的表达式。不过没关系，我们先假设有这样的参数表达式，看看能得到什么结论。设<span class="math inline">\(x=x(t),y=y(t)\)</span> 是某个参变元 <span class="math inline">\(t\)</span> 的函数，在 <span class="math inline">\(P(x,y)=0\)</span> 两边对 <span class="math inline">\(t\)</span> 求导可得 <span class="math display">\[\frac{\partial P}{\partial t}=\frac{\partialP}{\partial x}x'(t) + \frac{\partial P}{\partialy}y'(t)=0.\]</span> 记 <span class="math inline">\(k=-\frac{\partialP}{\partial x}/\frac{\partial P}{\partial y}\)</span>，则 <span class="math inline">\(y'(t)=kx'(t)\)</span>。</p><p>对反射光线 <span class="math inline">\(\mathbf{r}\)</span> 的两个分量<span class="math inline">\(r_x,r_y\)</span> 也分别使用链式求导，我们有<span class="math display">\[\begin{align}\frac{\partial r_x}{\partialt}&amp;=\frac{\partial r_x}{\partial x}x'(t) + \frac{\partialr_x}{\partial y}y'(t),\\\frac{\partial r_y}{\partial t}&amp;=\frac{\partial r_y}{\partialx}x'(t) + \frac{\partial r_y}{\partialy}y'(t).\end{align}\]</span> 于是我们发现比值 <span class="math display">\[\begin{align}\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}&amp;=\frac{r_xk-r_y}{r_y(\frac{\partialr_x}{\partial x}+\frac{\partial r_x}{\partial y}k)-r_x(\frac{\partialr_y}{\partial x} + \frac{\partial r_y}{\partial y}k)}\\&amp;=-\frac{r_x\frac{\partial P}{\partial x}+r_y\frac{\partialP}{\partial y}}{r_y(\frac{\partial r_x}{\partial x}\frac{\partialP}{\partial y}-\frac{\partial r_x}{\partial y}\frac{\partial P}{\partialx})-r_x(\frac{\partial r_y}{\partial x}\frac{\partial P}{\partial y} -\frac{\partial r_y}{\partial y}\frac{\partial P}{\partial x})}.\end{align}\]</span> 变成了一个不需要显式用到 <span class="math inline">\(t\)</span> 的量，即变量 <span class="math inline">\(t\)</span> “消掉”了。代入上面焦散的表达式中，我们得到 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix}-\frac{r_x\frac{\partialP}{\partial x}+r_y\frac{\partial P}{\partial y}}{r_y(\frac{\partialr_x}{\partial x}\frac{\partial P}{\partial y}-\frac{\partialr_x}{\partial y}\frac{\partial P}{\partial x})-r_x(\frac{\partialr_y}{\partial x}\frac{\partial P}{\partial y} - \frac{\partialr_y}{\partial y}\frac{\partial P}{\partial x})}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span> 这个式子还可以再简化一点：注意到曲线在 <span class="math inline">\((x,y)\)</span> 处的法向量由 <span class="math inline">\(\mathbf{n}=\frac{\nabla P}{|\nabla P|}\)</span>给出，其中 <span class="math inline">\(\nabla P=(\frac{\partialP}{\partial x},\frac{\partial P}{\partial y})\)</span>。于是由 <span class="math display">\[\mathbf{r}= \mathbf{l}- 2(\mathbf{l}\cdot\mathbf{n})\mathbf{n}\]</span> 两边与 <span class="math inline">\(\nablaP\)</span> 作内积，可得 <span class="math display">\[\mathbf{r}\cdot\nabla P=-\mathbf{l}\cdot \nabla P.\]</span> 从而 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix}+\frac{\mathbf{l}\cdot\nablaP}{r_y(\frac{\partial r_x}{\partial x}\frac{\partial P}{\partialy}-\frac{\partial r_x}{\partial y}\frac{\partial P}{\partialx})-r_x(\frac{\partial r_y}{\partial x}\frac{\partial P}{\partial y} -\frac{\partial r_y}{\partial y}\frac{\partial P}{\partialx})}\begin{pmatrix}r_x\\ r_y\end{pmatrix}.\]</span></p><p>这是四个变量 <span class="math inline">\(x,y,X,Y\)</span>满足的两个方程，形如 <span class="math inline">\(F(X,x,y)=0\)</span> 和<span class="math inline">\(G(Y,x,y)=0\)</span>。记住我们还有已知的方程<span class="math inline">\(P(x,y)=0\)</span>。为了从这三个方程中消掉<span class="math inline">\(x,y\)</span>，得到一个仅包含 <span class="math inline">\((X,Y)\)</span> 的表达式，我们可以尝试用 <a href="https://en.wikipedia.org/wiki/Gr%C3%B6bner_basis">Gröbnerbasis</a> 方法。Gröbner 基方法会把多项式方程组 <span class="math display">\[F=G=P=0\]</span> 转化为一组等价的新方程组 <span class="math display">\[g_1=g_2=\cdots=g_m=0.\]</span>即它们有完全相同的解集。</p><p><span class="math inline">\(\{g_1,\ldots,g_m\}\)</span> 是 <span class="math inline">\(F,G,P\)</span> 在多项式环 <span class="math inline">\(\mathbb{R}[x,y,X,Y]\)</span> 中生成的理想 <span class="math inline">\(I=\langle F,G,P\rangle\)</span>的一组生成元，<span class="math inline">\(\{g_1,\ldots,g_m\}\)</span>叫做 <span class="math inline">\(I\)</span> 的约化的 Gröbner基。在字典序 <span class="math inline">\(x\succ y\succ X\succ Y\)</span>下，约化的 Gröbner 基会有一个好的属性，即从 <span class="math inline">\(g_1\)</span> 到 <span class="math inline">\(g_m\)</span>，其中的变元会按照从 <span class="math inline">\(x\to y\to X\to Y\)</span>的先后顺序被消除掉。注意这是个不太严格的说法，我们并不是总能消掉顺序靠前的变元，但是如果消除发生的话，它就会按照这个顺序来。这样我们就可以执行类似高斯消元法中的回代操作，从而新方程组的求解会更加简单。</p><p>我们来用 <code>sympy</code> 实验一下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>x, y, X, Y = symbols(<span class="hljs-string">"x y X Y"</span>)<br>P = x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>dx = diff(P, x)  <span class="hljs-comment"># gradient of P</span><br>dy = diff(P, y)<br>curve = Matrix([x, y])<br>light_source = Matrix([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>l = curve - light_source  <span class="hljs-comment"># the incident ray</span><br>n = Matrix([dx, dy])  <span class="hljs-comment"># the normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n))  <span class="hljs-comment"># the reflected ray</span><br>rx, ry = r<br>dxrx = diff(rx, x)<br>dyrx = diff(rx, y)<br>dxry = diff(ry, x)<br>dyry = diff(ry, y)<br>denominator = ry * (dxrx * dy - dyrx * dx) - rx * (dxry * dy - dyry * dx)<br>nominator = dx * l[<span class="hljs-number">0</span>] + dy * l[<span class="hljs-number">1</span>]<br>F = (X - x) * denominator - nominator * rx<br>G = (Y - y) * denominator - nominator * ry<br>eqs = [eq.as_numer_denom()[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> eq <span class="hljs-keyword">in</span> [F, G, P]]<br>gb = groebner(eqs, [x, y, X, Y])<br><span class="hljs-built_in">print</span>(gb)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 给出的结果的最后一项是</p><p><span class="math display">\[27 X^{4} y^{2} + 54 X^{2} Y^{2} y^{2} -18 X^{2} y^{2} - 8 X y^{2} + 27 Y^{4} y^{2} - 18 Y^{2} y^{2} -y^{2}.\]</span></p><p><span class="math inline">\(x\)</span> 被消掉了！原方程组 <span class="math inline">\(F=G=P\)</span>的解必然是上面这个方程的解的子集。观察它的每一项都带有一个 <span class="math inline">\(y^2\)</span>，这显然不是我们要的解。把 <span class="math inline">\(y^2\)</span> 去掉，剩下的因子</p><p><span class="math display">\[27X^{4}+54X^{2}Y^{2}-18X^{2} -8X +27Y^{4}-18Y^{2}-1=0.\]</span></p><p>就是心脏线的隐函数表示。不信？在 <a href="https://www.desmos.com/geometry/vtjbq3ete1">Desmos</a>里面画出来看看！</p><p><img src="/images/caustics/desmos_cardioid.png" class="fig" width="300"></p><h1 id="后记">后记</h1><p>这篇文章主要覆盖了 Greg Egan博文的前半部分，他的后半部分内容我觉得有点放飞自我，也没怎么仔细看。</p><p>虽然我们用 <code>sympy</code>的实验很成功，但注意并不是所有情况下都能得到焦散曲线（比如光源位于抛物线的焦点时，反射光线都是平行的），而且对复杂的曲线<code>sympy</code> 算起来非常慢。</p><p>我研究生的时候上过计算机代数的课程，当时用的教学软件是 Maple。Maple编程是很不方便的，所以我其实没有多少计算机代数的编程经验。我之前一直觉得<code>sympy</code>运行又慢，输出的表达式也不够简化，所以不太愿意用它。这次实验有点刷新我对<code>sympy</code>的认知。我还记得当时课程要求每人提交一份读书报告，我写的是 <a href="https://link.springer.com/book/10.1007/978-3-319-16721-3">Ideals,Varieties, and Algorithms</a> 的笔记，但毕业多年以来这还是我第一次用到Gröbner 基！</p><p>我写这篇文章的时候正好临近情人节，所以我在想有没有什么曲线的焦散能给出<a href="https://www.desmos.com/geometry/ngdpq0zrei">爱心曲线</a>：</p><p><img src="/images/caustics/heart.png" class="fig" width="300"></p><p>于是我找到了 <a href="https://www.tandfonline.com/doi/full/10.1080/00029890.2020.1722019">这篇文章</a>。不过看起来里面给出的结论计算量很大，很难用在爱心线上（也许是我错了）。</p>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>遛狗中的数学：曲线的环绕数、Rouché 定理和开映射定理</title>
      <link href="/Rouche-theorem-winding-number/"/>
      <url>/Rouche-theorem-winding-number/</url>
      
        <content type="html"><![CDATA[<p>我写了一个 <a href="https://www.shadertoy.com/view/fdK3RD">shadertoy小动画</a>，演示 <span class="citation" data-cites="Needham1997">(<a href="#ref-Needham1997" role="doc-biblioref">Needham 1997</a>)</span>书中第 7 章 “Winding numbers and topology” 中的结论：</p><span id="more"></span><div class="statement simple plain unnumbered"><p>一个人和他的狗在公园里绕着一棵树散步，人和狗各自走的路径都是闭曲线，即经过一段时间后都会回到起点。如果人把狗绳抓的紧一些，使得整个过程中狗<strong>无法接触</strong>到树，则结束后人和狗绕着树走的圈数是一样的，这就是下面这个动画演示的：（树的位置是原点，用一个表盘标记）</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/fdK3RD?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe></div><p>对应的数学结论是：</p><blockquote><p>如果两条闭曲线 <span class="math inline">\(\gamma_1,\gamma_2\)</span>都不经过原点，且 <span class="math inline">\(\gamma_1\)</span>可以在不碰触到原点的前提下通过连续的形变变为 <span class="math inline">\(\gamma_2\)</span>（同伦），则 <span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点的环绕数相等。</p></blockquote><p>注意这个结论只要求 <span class="math inline">\(\gamma_1,\gamma_2\colon\[0,1]\to\mathbb{R}^2\)</span>是两条连续曲线，并不涉及解析性。因为环绕数和同伦都是拓扑概念，只涉及连续性。</p><p>但如果我们进一步考虑“人和狗的路线”分别是单位圆 <span class="math inline">\(S^1\colon\ \{z\in\mathbb{C}:|z|=1\}\)</span>经由两个解析函数 <span class="math inline">\(f,g\)</span>映射后的路径，那事情就变得有趣多了。</p><p>首先 <a href="https://en.wikipedia.org/wiki/Argument_principle">幅角原理</a>给出了环绕数的另一种解释：</p><blockquote><p><span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点的环绕数分别等于 <span class="math inline">\(f,g\)</span> 在<span class="math inline">\(S^1\)</span> 内部的零点个数。</p></blockquote><p>进一步 <a href="https://en.wikipedia.org/wiki/Rouch%C3%A9%27s_theorem">Rouché定理</a> 给出了 <span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点有相同环绕数的充分条件：</p><blockquote><p>如果对任何 <span class="math inline">\(z\in S^1\)</span> 都有 <span class="math inline">\(|f(z)|&gt;|f(z)-g(z)|\)</span> 成立，则 <span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点有相同的环绕数。于是 <span class="math inline">\(f,g\)</span> 在<span class="math inline">\(S^1\)</span> 内部的零点个数也相等。</p></blockquote><p>想象人的位置是 <span class="math inline">\(f(z)\)</span>，狗的位置是<span class="math inline">\(g(z)\)</span>，由于绳子 <span class="math inline">\(l(z)=f(z)-g(z)\)</span> 的长度 <span class="math inline">\(|l(z)|\)</span> 始终小于人到原点的距离 <span class="math inline">\(|f(z)|\)</span>，所以狗始终够不到原点。</p><p>在动画中，左下角的圆周是 <span class="math inline">\(S^1\)</span>，右边红、绿两条路径分别是 <span class="math inline">\(f(S^1)\)</span> 和 <span class="math inline">\(g(S^1)\)</span>。这里的 <span class="math inline">\(f\)</span> 我取的形如 <span class="math display">\[f(z)=\frac{z-a}{1-\overline{a}z}\frac{z-b}{1-\overline{b}z}\frac{z-c}{1-\overline{c}z}(z-2-2i),\quad |a|,|b|,|c|&lt;1.\]</span> <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(S^1\)</span> 的内部有 3 个根（我用红点标出来了），在 <span class="math inline">\(S^1\)</span> 上不为0，在 <span class="math inline">\(S^1\)</span>外部有一个根（图中没有画）。<span class="math inline">\(f(z)\)</span>的前三个因子构成一个 Blaschke 乘积，它把 <span class="math inline">\(S^1\)</span> 的内部仍然映射为内部，把 <span class="math inline">\(S^1\)</span> 仍然映射为 <span class="math inline">\(S^1\)</span>，于是对任何 <span class="math inline">\(z\in S^1\)</span> 有 <span class="math display">\[|f(z)| = |z - 2 - 2i| \geq 2\sqrt{2} - 1,\quadz\in S^1.\]</span> 所以只要绳子 <span class="math inline">\(l(z)\)</span> 满足 <span class="math inline">\(|l(S^1)| &lt; 2\sqrt{2}-1\)</span>，则狗走的路径<span class="math inline">\(g(S^1)=f(S^1)+l(S^1)\)</span>就不可能接触到原点。我这里取了 <span class="math inline">\(l(z) =cz\)</span>，其中 <span class="math inline">\(c\)</span> 是一个小于<span class="math inline">\(2\sqrt{2}-1\)</span> 的正实数。</p><p>Needham 的书中还介绍了一个有意思的事实：</p><blockquote><p><span class="math inline">\(\gamma\)</span> 的环绕数在 <span class="math inline">\(\mathbb{C}\setminus\gamma\)</span>的每个连通分支上都是常数。也就是说，对不在 <span class="math inline">\(\gamma\)</span> 上的一点 <span class="math inline">\(z\)</span>，我们可以稍稍移动 <span class="math inline">\(z\)</span> 到另一个点 <span class="math inline">\(z'\)</span>，只要保持 <span class="math inline">\(z'\)</span> 仍然位于 <span class="math inline">\(z\)</span> 所在的连通分支内，<span class="math inline">\(\gamma\)</span> 关于 <span class="math inline">\(z\)</span> 和 <span class="math inline">\(z'\)</span> 的环绕数就一定相同。</p></blockquote><p>利用这个事实并结合幅角原理不难得出下面的结论：</p><div id="connected-component" class="unnumbered statement sta___ plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(\gamma\)</span>是一条简单闭曲线，内部围的区域为 <span class="math inline">\(\Omega\)</span>，<span class="math inline">\(f(z)\)</span> 是一个非常数的解析函数，<span class="math inline">\(f\)</span> 在包含 <span class="math inline">\(\gamma\)</span>的某个区域内解析。假设有两棵树分别位于 <span class="math inline">\(w_0,\,w_1\)</span> 两点，且人行走的路线 <span class="math inline">\(f(\gamma)\)</span> 到 <span class="math inline">\(w_0\)</span> 的距离始终大于两棵树之间的距离：<span class="math display">\[|f(z)-w_0| &gt; |w_0-w_1|,\quad\forallz\in\gamma.\]</span></p><figure><img src="/images/rouche/winding_number.svg" width="250" alt="注意两棵树位于 \mathbb{C}\setminus f(\gamma) 的同一个连通分支中"><figcaption aria-hidden="true">注意两棵树位于 <span class="math inline">\(\mathbb{C}\setminus f(\gamma)\)</span>的同一个连通分支中</figcaption></figure><p>则 <span class="math inline">\(f(\gamma)\)</span> 关于 <span class="math inline">\(w_0,w_1\)</span> 的环绕数相等，从而 <span class="math inline">\(w_0,w_1\)</span> 在 <span class="math inline">\(\gamma\)</span> 内部的原像个数相同： <span class="math display">\[\sharp\{z\in \Omega: f(z)=w_0\} = \sharp\{z\in\Omega: f(z)=w_1\}.\]</span></p></div><p><strong>证明</strong>：根据条件，从 <span class="math inline">\(w_0\)</span> 沿着线段 <span class="math inline">\([w_0,w_1]\)</span> 移动到 <span class="math inline">\(w_1\)</span> 的过程中始终不会碰触到曲线 <span class="math inline">\(f(\gamma)\)</span>，所以 <span class="math inline">\(w_0,w_1\)</span> 必然位于同一连通分支内。<span class="math inline">\(\blacksquare\)</span></p><p>利用此推论我们不难得出复分析中的 <a href="https://en.wikipedia.org/wiki/Open_mapping_theorem_(complex_analysis)">开映射定理</a>：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>如果 <span class="math inline">\(U\subseteq\mathbb{C}\)</span>是开集，<span class="math inline">\(f\colon\ U\to\mathbb{C}\)</span>是非常数的解析函数，则 <span class="math inline">\(f(U)\)</span>也是开集。</p></div><p><strong>证明</strong>：任取 <span class="math inline">\(z_0\inU\)</span>，记 <span class="math inline">\(w_0=f(z_0)\)</span>。由于<span class="math inline">\(f\)</span> 不是常数，所以 <span class="math inline">\(f(z)-w_0\)</span> 的零点都是孤立的。我们可以取<span class="math inline">\(z_0\)</span> 的一个充分小的闭圆盘 <span class="math inline">\(B_\delta=\{z\in U\mid |z-z_0|\leq\delta\}\)</span>使得 <span class="math inline">\(f(z)-w_0\)</span> 在 <span class="math inline">\(B_\delta\)</span> 中除了 <span class="math inline">\(z_0\)</span> 以外没有其它零点。特别地，<span class="math inline">\(f(z)-w_0\)</span> 在 <span class="math inline">\(B_\delta\)</span> 的边界 <span class="math inline">\(\gamma =\{|z-z_0|=\delta\}\)</span> 上恒不为0，从而 <span class="math inline">\(|f(z)-w_0|\)</span> 在 <span class="math inline">\(\gamma\)</span> 上有正的极小值 <span class="math inline">\(e\)</span>，即对任何 <span class="math inline">\(z\in\gamma\)</span> 有 <span class="math inline">\(|f(z)-w_0|\geq e\)</span>。</p><p>现在我们考虑 <span class="math inline">\(w_0\)</span> 的邻域 <span class="math inline">\(V_e=\{|w-w_0|&lt;e\}\)</span>。则任何 <span class="math inline">\(w_1\in V_e\)</span> 都满足 <a href="#connected-component" title="推论">推论</a> 中的条件：</p><p><span class="math display">\[|f(z)- w_0| \geq e &gt; |w_1-w_0|,\quadz\in \gamma.\]</span></p><p>所以 <span class="math inline">\(w_1\)</span> 在 <span class="math inline">\(\gamma\)</span> 内部至少有一个原像。由 <span class="math inline">\(w_1\)</span> 的任意性可得 <span class="math inline">\(V_e\subset f(U)\)</span> 是 <span class="math inline">\(w_0\)</span> 在 <span class="math inline">\(f(U)\)</span> 中的开邻域，从而 <span class="math inline">\(f(U)\)</span> 是开集。<span class="math inline">\(\blacksquare\)</span></p><p>怎么样？一次简单的遛狗，帮助我们回顾了拓扑和复分析中几个核心的定理。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Needham1997" class="csl-entry" role="listitem">Needham, Tristan. 1997. <em>Visual Complex Analysis</em>. The ClarendonPress, Oxford University Press, New York.</div></div>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静电场与 Marden 定理</title>
      <link href="/Marden-theorem/"/>
      <url>/Marden-theorem/</url>
      
        <content type="html"><![CDATA[<p>我昨晚刚完成了一个 <a href="https://www.shadertoy.com/view/7lf3Wn">shadertoy小动画</a>，演示平面几何中的 <a href="https://en.wikipedia.org/wiki/Marden%27s_theorem">Marden定理</a>、复分析中的 <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Lucas_theorem">Gauss-Lucas定理</a> 和静电场之间的关系：</p><span id="more"></span><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/7lf3Wn?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><p>这个动画的含义如下：</p><ol type="1"><li><p>在复平面上三角形 <span class="math inline">\(\Delta ABC\)</span>的三个顶点处各自放置一个单位正电荷，则平面上电场强度为 0的点有两个（这两个点可能重合），它们位于 <span class="math inline">\(\Delta ABC\)</span> 的内部，并且是三次复多项式<span class="math inline">\(P(z) = (z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span> 的零点。</p></li><li><p>不仅如此，这两个零点还是一个内切于 <span class="math inline">\(\Delta ABC\)</span>的椭圆的两个焦点，此椭圆是所有内切于 <span class="math inline">\(\DeltaABC\)</span> 的椭圆中面积最大者，其与 <span class="math inline">\(\DeltaABC\)</span> 三边的切点均为各边中点。这个椭圆叫做 <a href="https://en.wikipedia.org/wiki/Steiner_inellipse">Steiner内切椭圆</a>。</p></li></ol><p>这个动画是受几天前 Albert Chern 的 <a href="https://twitter.com/theAlbertChern/status/1395468792788967428?s=20">一篇推文</a>启发所作，John Baez 也写了一篇关于这个话题的 <a href="https://johncarlosbaez.wordpress.com/2021/05/24/electrostatics-and-the-gauss-lucas-theorem/">文章</a>。我是由此才了解到Marden 定理还有如此有趣的物理学解释，的确大开眼界！</p><hr><p>在平面上不全共线的 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(a_1,\ldots,a_n\)</span>处放置若干单位正电荷，这规定了一个平面上的电势函数 <span class="math inline">\(V(z)\)</span> （标量） 和一个电场 <span class="math inline">\(\mathbf{E}(z)\)</span>（二维向量场）。电学知识告诉我们，在忽略物理常数意义下有 <span class="math display">\[V(z)=\sum_{i=1}^n\ln|z-a_i|=\ln\prod_{i=1}^n|z-a_i|=\ln|P(z)|.\]</span> 其中<span class="math inline">\(P(z)=(z-a_1)(z-a_2)\cdots(z-a_n)\)</span>是以 <span class="math inline">\(a_1,\ldots,a_n\)</span>为根的多项式。</p><p>此外 <span class="math inline">\(\mathbf{E} = -\nabla V\)</span>为电势的梯度向量取负。</p><blockquote><p><strong>问题</strong>：怎样确定平面上场强为 0 的点呢？</p></blockquote><p>场强为 0的点也叫做<strong>平衡点</strong>、<strong>鞍点</strong>，因为在这一点处的电荷不受电场的库仑力。</p><p>答案有点出人意料：平衡点必然是 <span class="math inline">\(P'(z)\)</span> 的零点，而且这些点都属于 <span class="math inline">\(a_1,\ldots,a_n\)</span> 的凸包！</p><p>注意 <span class="math inline">\(V(z)\)</span> 是 <span class="math inline">\(\ln P(z) = \ln |P(z)| + i\arg{P(z)}\)</span>的实部，由 Cauchy-Riemann 方程不难看出满足 <span class="math inline">\(\nabla V=0\)</span> 的点都是 <span class="math inline">\((\ln P(z))'=P'(z)/P(z)\)</span>的零点，所以平衡点都是 <span class="math inline">\(P'(z)\)</span>的零点。平衡点属于 <span class="math inline">\(\{a_1,\ldots,a_n\}\)</span> 的凸包是根据 <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Lucas_theorem">Gauss-Lucas定理</a>：任何复多项式 <span class="math inline">\(f\)</span>的导数的零点都属于 <span class="math inline">\(f\)</span>的零点构成的凸包！</p><p>John Baez 的文章中利用凸集分离定理给出了 Gauss-Lucas定理的一个简洁证明。</p><p>需要注意的是，反过来 <span class="math inline">\(P'(z)\)</span>的零点未必都是电场的平衡点，当 <span class="math inline">\(P(z)\)</span>有重根时，重根是 <span class="math inline">\(P'(z)\)</span>的零点但不是 <span class="math inline">\(P'(z)/P(z)\)</span>的零点，所以不是平衡点。</p><p>平衡点是鞍点 (saddle point) 是由于 <span class="math inline">\(V(z)\)</span>的调和性质，其不存在局部的极大极小值，所以使得 <span class="math inline">\(\nabla V=0\)</span> 的点都是鞍点。</p><p>在三个点电荷 <span class="math inline">\(A,B,C\)</span>的情形，平衡点有两个，它们位于 <span class="math inline">\(\DeltaABC\)</span> 的内部，且是多项式 <span class="math inline">\(P(z) =(z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span>的零点。那关于这两个点的具体位置我们可以说什么吗？这就是优美的 Marden定理，要表述这个定理，我们需要先介绍 Steiner 内切椭圆的概念：</p><div id="steiner-inellipse" class="unnumbered statement sta_steiner_inellipse plain"><p><span class="statement-heading"><span class="statement-label">Steinerinellipse</span>.</span><span class="statement-spah"></span>在所有内切于 <span class="math inline">\(\Delta ABC\)</span>的椭圆中，存在唯一的一个面积最大者，叫做 Steiner inellipse，此椭圆与<span class="math inline">\(\Delta ABC\)</span>三边的切点为各边的中点。</p></div><p>Marden 定理断言 <span class="math inline">\(P'(z)\)</span>的两个根正是 Steiner 内切椭圆的两个焦点：</p><div id="marden-------" class="unnumbered statement sta_marden___ plain"><p><span class="statement-heading"><span class="statement-label">Marden定理</span>.</span><span class="statement-spah"> </span>复多项式 <span class="math inline">\(P(z)=(z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span> 的两个零点正是 <span class="math inline">\(\Delta ABC\)</span> 的 Steiner inellipse的两个焦点。</p></div><p>Steiner inellipse 和 Marden定理的证明并不复杂，美国数学月刊上出现过两篇介绍其证明的文章，都非常值得一读：</p><ol type="1"><li><p><a href="https://www.researchgate.net/publication/228698127_Triangles_Ellipses_and_Cubic_Polynomials">Triangles,Ellipses, and Cubic Polynomials</a>.</p></li><li><p><a href="https://www.researchgate.net/publication/263136028_An_Elementary_Proof_of_Marden%27s_Theorem">AnElementary Proof of Marden’s Theorem</a>.</p></li></ol><p>其中第一篇文章采用了复数和仿射变换的途径，第二篇使用了椭圆的光学性质。</p>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Möbius 变换的分类与上半双曲空间的等距</title>
      <link href="/mobius-h3space/"/>
      <url>/mobius-h3space/</url>
      
        <content type="html"><![CDATA[<p>本文的想法源自 Roice Nelson 的 <a href="https://www.shadertoy.com/view/MstcWr">shadertoy项目</a>，我觉得他的创意很棒，就是效果有点糙，于是 <a href="https://www.shadertoy.com/view/4scfR2">动手改进了一番</a>。乍一看，这个动画的场景很简单，其实它背后的数学并不平凡。</p><p>这个动画从三个角度了演示 Möbius 变换，这三个角度是密切相关的：</p><ol type="1"><li>Möbius 变换作为扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 到自身的全纯函数。</li><li>Möbius 变换作为 Riemann 球面 <span class="math inline">\(S^2\)</span> 到自身的全纯函数。</li><li>Möbius 变换作为上半双曲空间中的等距变换。</li></ol><p>本文只作概括性的介绍，并不展开详细的数学证明。读者可以参考下面的资料：</p><blockquote><ol type="1"><li><a href="https://en.wikipedia.org/wiki/M%C3%B6bius_transformation">维基百科</a>.</li><li><span class="citation" data-cites="Needham1997">Needham (<a href="#ref-Needham1997" role="doc-biblioref">1997</a>)</span> .</li><li><span class="citation" data-cites="indra">Mumford, Series, andWright (<a href="#ref-indra" role="doc-biblioref">2002</a>)</span>,chapter 3.</li><li><span class="citation" data-cites="palka1991">Palka (<a href="#ref-palka1991" role="doc-biblioref">1991</a>)</span>, chapter IX,section 2.</li></ol></blockquote><p>本文的动画应该可以帮助你更好地理解这些资料中的内容。</p><span id="more"></span><h1 id="预备知识之正交圆族">预备知识之正交圆族</h1><p>设 <span class="math inline">\(z_1,z_2\)</span>是复平面上的两点，我们考虑两个不同的圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span>：</p><ol type="1"><li><span class="math inline">\(\mathcal{C}_1\)</span> 由所有同时过<span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 的圆组成（包含过 <span class="math inline">\(z_1,z_2\)</span> 的直线）。</li><li><span class="math inline">\(\mathcal{C}_2\)</span> 由所有使得 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 关于 <span class="math inline">\(C\)</span> 互为反演点的圆 <span class="math inline">\(C\)</span> 组成（包含线段 <span class="math inline">\([z_1,z_2]\)</span> 的垂直平分线）。</li></ol><p>则圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 中的任何圆<span class="math inline">\(C_1\)</span> 与 <span class="math inline">\(\mathcal{C}_2\)</span> 中的任何圆 <span class="math inline">\(C_2\)</span> 正交（交点处的切线互相垂直）。</p><p>我们将考察当 <span class="math inline">\(z_1,z_2\)</span> 是一个Möbius 变换 <span class="math inline">\(M\)</span> 的两个不动点时，<span class="math inline">\(M\)</span> 作用在 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span> 上的效果。</p><h1 id="möbius-变换的共轭分类">Möbius 变换的共轭分类</h1><p>一个 Möbius 变换 <span class="math inline">\(M\)</span>是一个分式线性变换，它将扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 一对一地映射为自身：<span class="math display">\[M(z) = \frac{az+b}{cz+d},\quada,b,c,d\in\mathbb{C},ad-bc\ne0, z\in \hat{\mathbb{C}}.\]</span> 所有的Möbius 变换构成一个群 <span class="math inline">\({\rmPSL}_2(\mathbb{C})\)</span>。</p><p>我们称两个 Möbius 变换 <span class="math inline">\(M_1,M_2\)</span>是共轭的，当且仅当存在 <span class="math inline">\(g\in{\rmPSL}_2(\mathbb{C})\)</span> 使得 <span class="math display">\[M_1=gM_2g^{-1}.\]</span></p><p>可以证明，在共轭的意义下，任何非恒等元的 Möbius变换都属于下面四种类型之一：</p><ol type="1"><li><span class="math inline">\(M\)</span> 称作是抛物型的(parabolic)，如果它共轭于平移：<span class="math inline">\(z\toz+1\)</span>。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上仅有一个不动点。</li><li><span class="math inline">\(M\)</span> 称作是椭圆型的(elliptic)，如果它共轭于旋转：<span class="math inline">\(z\toe^{i\theta}z\)</span>，其中 <span class="math inline">\(\theta\in\mathbb{R}\)</span> 且 <span class="math inline">\(\theta\ne0\)</span>。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li><li><span class="math inline">\(M\)</span> 称作是双曲型的(hyperbolic)，如果它共轭于缩放：<span class="math inline">\(z\to\lambdaz\)</span>，其中 <span class="math inline">\(\lambda&gt;0\)</span>是实数且不为 1。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li><li><span class="math inline">\(M\)</span> 称作是斜航型的(loxodromic)，如果它共轭于一个缩放和一个旋转的复合：<span class="math inline">\(z\to cz\)</span>，其中 <span class="math inline">\(c\in\mathbb{C}\setminus \mathbb{R}\)</span>。这时<span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li></ol><p>我们把形如 <span class="math inline">\(z\to z+a\)</span> 和 <span class="math inline">\(z\to\lambda z\)</span>的变换称作<strong>特殊位置</strong>的变换，前者是抛物型的，以 <span class="math inline">\(\infty\)</span>为唯一不动点，后者包含了所有非抛物型的变换，它的两个不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>。这两种 Möbius变换具有简单的表现形式，并且它们在两个圆族上的作用也很容易分析，所以在研究每种类型的变换时，我们都先考虑这种简单的形式，然后再通过取共轭扩展到一般的情形。</p><h2 id="抛物型">1. 抛物型</h2><p>我们先考察最简单的抛物型变换 <span class="math inline">\(z\toz+1\)</span>。</p><p>这时唯一的不动点是 <span class="math inline">\(\infty\)</span>，<span class="math inline">\(\mathcal{C}_1\)</span> 是直线族 <span class="math inline">\(\{y=k\mid k\in\mathbb{R}\}\)</span>，<span class="math inline">\(\mathcal{C}_2\)</span> 是直线族 <span class="math inline">\(\{x=l\mid l\in\mathbb{R}\}\)</span>。<span class="math inline">\(M\)</span> 保持 <span class="math inline">\(\mathcal{C}_1\)</span> 中的每条直线不变，把 <span class="math inline">\(\mathcal{C}_2\)</span>中的每条直线变成同族中的另一条直线：</p><object data="/images/mobius/parabolic-plane.svg"></object><p>由动画可见所有点都向着不动点 <span class="math inline">\(\infty\)</span> 的方向「前进」。</p><p>对一般的抛物型变换 <span class="math inline">\(M\)</span> 且 <span class="math inline">\(M\)</span> 的唯一不动点 <span class="math inline">\(z_0\)</span> 有限的情形，结论仍然类似：圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 中的圆都在 <span class="math inline">\(z_0\)</span> 处相切且共用同一条切线 <span class="math inline">\(\ell_1\)</span>，圆族 <span class="math inline">\(\mathcal{C}_2\)</span> 也都在 <span class="math inline">\(z_0\)</span> 处相切且共用同一条切线 <span class="math inline">\(\ell_2\)</span>，<span class="math inline">\(\ell_1\)</span> 和 <span class="math inline">\(\ell_2\)</span> 互相垂直：</p><object data="/images/mobius/parabolic-plane2.svg"></object><p>由动画可见左右两侧的圆在旋转，但是圆本身保持不变，它们是圆族 <span class="math inline">\(\mathcal{C}_1\)</span>；上下两侧的圆在「扩散」，它们是圆族<span class="math inline">\(\mathcal{C}_2\)</span>。可以证明对任何 <span class="math inline">\(z\in\mathbb{C}\)</span> 都有 <span class="math inline">\(\lim\limits_{n\to\infty}M^n(z)=z_0\)</span>，即任何点在<span class="math inline">\(M\)</span> 反复作用下的轨迹都朝着 <span class="math inline">\(z_0\)</span> 的位置移动。</p><p>在 <a href="http://klein.math.okstate.edu/IndrasPearls/">Indra’spearls</a> 一书中，把 <span class="math inline">\(\mathcal{C}_1\)</span>和 <span class="math inline">\(\mathcal{C_2}\)</span>形象地比喻为两组「扇贝壳」：</p><figure><img src="/images/mobius/seashell.jpeg" width="200" alt="我从网上找了一张扇贝壳的图片"><figcaption aria-hidden="true">我从网上找了一张扇贝壳的图片</figcaption></figure><h2 id="椭圆型">2. 椭圆型</h2><p>我们先考察最简单的椭圆型变换 <span class="math inline">\(z\toe^{i\theta}z\)</span>。</p><p>这时两个不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>。圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 由所有过 <span class="math inline">\(0\)</span> 的直线组成，<span class="math inline">\(\mathcal{C}_2\)</span> 由所有以 <span class="math inline">\(0\)</span> 为中心的同心圆组成。<span class="math inline">\(M\)</span> 是个旋转，所以会把 <span class="math inline">\(\mathcal{C}_1\)</span>中的直线变成同族的另一条直线，同时保持 <span class="math inline">\(\mathcal{C}_2\)</span> 中的每个圆不变：</p><object data="/images/mobius/elliptic-plane.svg"></object><p>对两个不动点 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 都有限的情形，结论同样成立，<span class="math inline">\(M\)</span> 保持 <span class="math inline">\(\mathcal{C}_2\)</span> 中的每个圆不变，把 <span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆变为同族中的另一个圆：</p><object data="/images/mobius/elliptic-plane2.svg"></object><h2 id="双曲型">3. 双曲型</h2><p>与椭圆变换 <span class="math inline">\(z\to e^{i\theta}z\)</span>的情形类似，<span class="math inline">\(z\to\lambda z\)</span> 也以<span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span> 为不动点，但是圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span> 的运动方式发生了互换：这次<span class="math inline">\(\mathcal{C}_1\)</span>中的每条直线在放缩下保持不变，<span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆在放缩下变成同族的另一个圆：</p><object data="/images/mobius/hyperbolic-plane.svg"></object><p>对两个不动点 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 都有限的双曲变换，结论仍然成立，圆族<span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆保持不变，<span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆被变成同族的另一个：</p><object data="/images/mobius/hyperbolic-plane2.svg"></object><p>这时在 <span class="math inline">\(M\)</span> 的作用下 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span>一个是「源点」，另一个是「汇点」，轨迹从源点源源不竭地发出，汇聚到汇点中。</p><h2 id="斜航型">4. 斜航型</h2><p>仍然先看 <span class="math inline">\(z\to cz\)</span> 的情形。</p><p>这时不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>，<span class="math inline">\(M\)</span> 把圆族 <span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆变为同族中的另一个圆，同样地也把圆族 <span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆变为同族中的另一个圆，<strong>所以斜航型的变换没有不变圆</strong>：</p><object data="/images/mobius/loxodromic-plane.svg"></object><p>这时平面上一点 <span class="math inline">\(z\)</span> 在 <span class="math inline">\(M\)</span>的反复作用下的轨迹是一条形如「旋臂」的曲线，方程为 <span class="math inline">\(\gamma(t)=c^tz\)</span>，这是一条对数螺线(spiral)，其与 <span class="math inline">\(\mathcal{C}_1\)</span> 和<span class="math inline">\(\mathcal{C}_2\)</span> 的夹角都是常数。</p><p>这个结论对一般的斜航型变换也成立：</p><object data="/images/mobius/loxodromic-plane2.svg"></object><p>由于斜航型变换包含双曲变换作为组成成分，因此看起来它也有一个源点和一个汇点。这时任意一点<span class="math inline">\(z\)</span> 在 <span class="math inline">\(M\)</span> 的反复作用下的轨迹是一条双螺线 (doublespiral)，其与 <span class="math inline">\(\mathcal{C}_1\)</span> 和<span class="math inline">\(\mathcal{C}_2\)</span> 的夹角仍然都是常数（Möbius 变换是保角的）。</p><p>判断 Möbius 变换 <span class="math inline">\(M\)</span>具体属于哪一类可以根据其迹的平方 <span class="math inline">\(\mu=(a+d)^2\)</span> 来判断（当然，需要把 <span class="math inline">\(M\)</span> 归一化使得 <span class="math inline">\(ad-bc=1\)</span>）：</p><ol type="1"><li><span class="math inline">\(M\)</span> 是抛物型的当且仅当 <span class="math inline">\(\mu=4\)</span>。</li><li><span class="math inline">\(M\)</span> 是椭圆型的当且仅当 <span class="math inline">\(0\leq\mu&lt;4\)</span>。</li><li><span class="math inline">\(M\)</span> 是双曲型的当且仅当 <span class="math inline">\(\mu&gt;4\)</span>。</li><li><span class="math inline">\(M\)</span> 是斜航型的当且仅当 <span class="math inline">\(\mu&lt;0\)</span> 或者 <span class="math inline">\(\mu\notin\mathbb{R}\)</span>。</li></ol><h2 id="斜航-loxodromic-是什么意思">斜航 (loxodromic) 是什么意思？</h2><p>斜航这个词听起来好像和船的航行有关，怎么就用来给 Möbius变换分类了呢？这里面肯定有故事，值得扒一扒。</p><p>斜航线 (loxodrome)指的是地球上的一条航行路径，其在每个点处的切线与过该点的经线的夹角为定值。比如说，如果船始终朝着东北方向30 度行驶，走过的轨迹就是一条斜航线。Loxodrome 最初是一个希腊词，loxos的意思是 oblique，即倾斜的，dromos 意为bearing，方位的意思，后来拉丁化以后成为现在的样子。葡萄牙数学家 PedroNunes (1492-1577)第一个认识到斜航线并非两点之间最短路径，而且它无限接近但永不可能到达极点。</p><p><img style="margin:0px auto;display:block" width="300" src="/images/mobius/loxodrome.png"></p><p>在大航海的时代，没有卫星导航，只能靠罗盘或者星座来标识船的航向，而星座的方法在遇到恶劣天气的时候又不能使用，只有罗盘是最可靠的方法。理论上地球表面两点之间的最短路径是过球心的大圆，但罗盘只能定出经线的方向（原理是地球的磁极和南北极近似重合），这二者的夹角不是固定的，要保持沿着大圆的弧走就必须不停调整船的航向，但现实中的船不可能一直有人守在船舵处调整方向，一般是事先定好航向以后接下来的若干天都沿着这个方向走，所以在一定路程内船实际上走的是斜航线。</p><p>荷兰地图学家墨卡托 (Mercator) 据此于 1569年提出了墨卡托地图，将地球投影至墨卡托地图是一个保角变换，即曲线的夹角保持不变。不仅如此，球面上的斜航线在墨卡托地图中成为一条直线：</p><figure><img src="/images/mobius/mercator.jpg" width="500" alt="网上找了一张墨卡托地图"><figcaption aria-hidden="true">网上找了一张墨卡托地图</figcaption></figure><p>所以要从地球上的 <span class="math inline">\(A\)</span> 点航向到<span class="math inline">\(B\)</span>点，只要找到它们在墨卡托地图上的对应点 <span class="math inline">\(A',B'\)</span>，算出地图上的直线 <span class="math inline">\(A'B'\)</span> 与经线的夹角 <span class="math inline">\(\theta\)</span>，航行时只要让罗盘与经线一直保持角度为<span class="math inline">\(\theta\)</span> 就可以按照斜航线从 <span class="math inline">\(A\)</span> 航行到 <span class="math inline">\(B\)</span>了。这个路径虽不是最短，但是好在不容易迷失航向。</p><p>那这和 Möbius 变换有什么关系呢？</p><h1 id="möbius-变换作用在-riemann-球面上">Möbius 变换作用在 Riemann球面上</h1><p>由于 Möbius 变换都是扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 到 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 的自同构，而 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 在球极投影下等同于Riemann 球面 <span class="math inline">\(S^2\)</span>，所以 Möbius变换也都是 Riemann 球面的自同构。我们来看看 Möbius 变换作用在 Riemann球面上是什么样子的。</p><p>这是一个作用在 Riemann 球上的斜航型变换：</p><object data="/images/mobius/loxodromic-sphere.svg"></object><p>从动画可见 Riemann球面上有一对源点和汇点，这对源点和汇点可以理解为球面的「北极」和「南极」，它们在球极投影下对应于<span class="math inline">\(M\)</span>在扩充复平面上的两个不动点。当这两个不动点分别是原点和无穷远点时，这两个极点就是通常意义下的北极和南极。这时球面上的「经线」是所有过两个极点的大圆，在球极投影下它们对应于同时过两个不动点的圆族<span class="math inline">\(\mathcal{C}_1\)</span>；球面上的「纬线」是所有与经线正交的圆，在球极投影下它们对应于反演圆族<span class="math inline">\(\mathcal{C}_2\)</span>，球面上每个点的轨迹是对数螺线轨迹在逆球极投影下在球面上的对应曲线，这条曲线与经线纬线的夹角都是常数（因为球极投影是保角的），从而是一条斜航线！</p><h1 id="möbius-变换作为上半双曲空间的等距">Möbius变换作为上半双曲空间的等距</h1><p>上半双曲空间 <span class="math inline">\(\mathbb{H}_3\)</span>的定义为 <span class="math display">\[\mathbb{H}_3 =\{(x,y,t)\in\mathbb{R}^3\ |\ t&gt;0\}.\]</span>这个空间中的度量是双曲度量：</p><p><span class="math display">\[\mathrm{d}s=\frac{(\mathrm{d}x)^2+(\mathrm{d}y)^2+(\mathrm{d}t)^2}{t}.\]</span></p><p>注意 <span class="math inline">\(xy\)</span> 平面，即复平面不属于<span class="math inline">\(\mathbb{H}_3\)</span>，它是 <span class="math inline">\(\mathbb{H}_3\)</span> 的无穷远边界，<span class="math inline">\(\mathbb{H}_3\)</span> 中任何一点到 <span class="math inline">\(xy\)</span> 平面的距离是无穷大。</p><p>一个复分析教材中不太常讲到的事实是：<strong>任何 Möbius变换都可以唯一地扩展为 <span class="math inline">\(\mathbb{H}_3\)</span>的一个等距变换 <span class="math inline">\(\overline{M}\)</span></strong>，此即所谓的Poincaré Extension。这个扩展用四元数来描述的话很简单：设 <span class="math display">\[M\colon\ z\to\frac{az+b}{cz+d},\quadad-bc=1.\]</span> 是任一 Möbius 变换。注意我们这里要求 <span class="math inline">\(ad-bc\)</span> 的值是1，其实任何非零实数都可以。这是可以做到的，因为给 Möbius 变换中的 <span class="math inline">\(a,b,c,d\)</span>同时乘以一个非零复数并不改变这个变换，所以同时乘以 <span class="math inline">\(1/\sqrt{ad-bc}\)</span> 就可以使得 <span class="math inline">\(ad-bc=1\)</span>。</p><p>对 <span class="math inline">\(p=(x,y,t)\in\mathbb{H}^3\)</span>，令<span class="math inline">\(q=x+yi+tj\)</span> 为与 <span class="math inline">\(p\)</span> 对应的四元数，定义 <span class="math display">\[\overline{M}(p) = (aq+b)(cq+d)^{-1}.\]</span>这里的运算都是在四元数体中进行。则 <span class="math inline">\(\overline{M}(p)\)</span> 是 <span class="math inline">\(\mathbb{H}_3\)</span> 到自身的等距，并且它限制在<span class="math inline">\(xy\)</span> 平面上与 <span class="math inline">\(M\)</span> 的作用一致。</p><p>关于 Poincaré Extension 读者可以参考 <span class="citation" data-cites="Bea95">(<a href="#ref-Bea95" role="doc-biblioref">Beardon1995, vol. 91, secs. 3.3, 4.1</a>)</span>。</p><p>我们还能像上面那样用动画演示 Möbius 变换 <span class="math inline">\(\overline{M}\)</span> 在 <span class="math inline">\(\mathbb{H}_3\)</span>上的作用吗？可以！比如下图是一个形如 <span class="math inline">\(z\tocz\)</span> 的斜航型变换扩展到 <span class="math inline">\(\mathbb{H}_3\)</span>后作用在一个<strong>圆柱</strong>体上的效果：</p><object data="/images/mobius/loxodromic-cone.svg"></object><p>你可能要问了：这明明是个圆锥体，你怎么说它是圆柱体呢？是不是笔误了啊？</p><p>其实是因为我们现在是在双曲空间里看待它，在双曲度量下，锥面上所有点到<span class="math inline">\(t\)</span>轴的距离都是一样的，实际上如果设锥的顶角为 <span class="math inline">\(2\alpha\)</span>，则锥面上任何一点到 <span class="math inline">\(t\)</span> 轴的双曲距离 <span class="math inline">\(d\)</span> 满足（见 <span class="citation" data-cites="Bea95">(<a href="#ref-Bea95" role="doc-biblioref">Beardon1995, vol. 91, sec. 7.9.1</a>)</span>） <span class="math display">\[\sinh d\cdot \cot\alpha = 1.\]</span> 即 <span class="math inline">\(d\)</span> 是定值。所以虽然在 <span class="math inline">\(\mathbb{R}^3\)</span> 中它是一个锥体，但是在 <span class="math inline">\(\mathbb{H}_3\)</span> 中它其实是圆柱体。</p><p>你可以看到这时 <span class="math inline">\(\overline{M}\)</span>有两个不动点，都位于无穷远边界上，这样的点叫做「理想点」。两个不动点之间的连线构成圆柱的轴。两个不动点一个是源点，一个是汇点，空间中的点在变换的作用下远离源点，趋向汇点。</p><p>对于一般的斜航型变换 <span class="math inline">\(M\)</span>，且其两个不动点都是扩充复平面上的有限点时，<span class="math inline">\(M\)</span> 在 <span class="math inline">\(\mathbb{H}_3\)</span> 上的扩展 <span class="math inline">\(\overline{M}\)</span> 仍然保持一个 <span class="math inline">\(\mathbb{H}_3\)</span> 中的圆柱体不变：</p><object data="/images/mobius/loxodromic-dupin.svg"></object><p>这个曲面叫做 <a href="https://www.maths.ox.ac.uk/about-us/departmental-art/dupin-cyclides">Dupincyclide</a>，它的两个端点恰好是 <span class="math inline">\(M\)</span>的两个不动点。但在双曲空间中它其实是一个圆柱体，由于其两端落在无穷远平面上，因此也是无限长的。圆柱体的轴是连接两个端点的测地线。如果<span class="math inline">\(M\)</span> 是椭圆型的话，那么 <span class="math inline">\(\overline{M}\)</span> 将该圆柱绕着轴旋转：</p><object data="/images/mobius/elliptic-dupin.svg"></object><h1 id="这些动画是怎么生成的">这些动画是怎么生成的？</h1><p>我以 Dupin cyclide 的动画为例子来说明动画的绘制过程。</p><p>一个非抛物型的变换 <span class="math inline">\(M\)</span>总是可以表示为 <span class="math inline">\(M = gM_\lambdag^{-1}\)</span> 的形式，其中 <span class="math inline">\(M_\lambda=z\to\lambda z\)</span>。我这里的 <span class="math inline">\(g\)</span> 取的是 <span class="math display">\[g^{-1}(z)=\frac{z-1}{z+1}.\]</span>注意我这里写的是 <span class="math inline">\(g^{-1}\)</span>，原因是我们不需要 <span class="math inline">\(g\)</span> 的显式表达式，相反我们只需要 <span class="math inline">\(g^{-1}\)</span>。</p><p>不难验证 <span class="math inline">\(g^{-1}(1)=0\)</span> 和 <span class="math inline">\(g^{-1}(-1)=\infty\)</span>，从而 <span class="math inline">\(g(0)=1\)</span> 和 <span class="math inline">\(g(\infty)=-1\)</span>，即 <span class="math inline">\(g\)</span> 将 <span class="math inline">\(M_\lambda\)</span> 的不动点 <span class="math inline">\(\{0,\infty\}\)</span> 分别映射为 <span class="math inline">\(M\)</span> 的不动点 <span class="math inline">\(\{1,-1\}\)</span>。<span class="math inline">\(g\)</span> 同时将 <span class="math inline">\(M_\lambda\)</span> 对应的圆族 <span class="math inline">\(\{\mathcal{C}_i,i=1,2\}\)</span> 映射为 <span class="math inline">\(M\)</span> 的圆族 <span class="math inline">\(\{g(\mathcal{C}_i),i=1,2\}\)</span>。</p><p><span class="math inline">\(g\)</span> 当然也可以扩展为 <span class="math inline">\(\mathbb{H}_3\)</span> 的等距，我们把扩展以后的<span class="math inline">\(g\)</span> 仍然记作 <span class="math inline">\(g\)</span>。</p><p>由 <span class="math inline">\(M = gM_\lambda g^{-1}\)</span> 可得<span class="math display">\[Mg(\mathcal{C}_i) = gM_\lambda(\mathcal{C}_i),\quad i=1,2.\]</span> 左边的 <span class="math inline">\(Mg(\mathcal{C}_i)\)</span> 是我们真正想绘制的<span class="math inline">\(M\)</span> 在其自己的圆族 <span class="math inline">\(g(\mathcal{C}_i)\)</span>上的作用，这等价于绘制右边的 <span class="math inline">\(gM_\lambda(\mathcal{C})_i\)</span>。<span class="math inline">\(M_\lambda(\mathcal{C}_i)\)</span>很好画，就是把一些同心圆和过原点的直线旋转或者放缩一下；但是它前面加了一个畸变<span class="math inline">\(g\)</span>。为此我们只要用 <span class="math inline">\(g^{-1}\)</span>作用在当前场景的物体上，把它们「去畸变」即可。所以在动画中，我其实根本没有计算Dupin cyclide 的任何显式或者隐式的曲面方程，而是直接用 <span class="math inline">\(g^{-1}\)</span> 作用在场景上。由于 <span class="math inline">\(g^{-1}\)</span> 是 <span class="math inline">\(\mathbb{H}_3\)</span> 上的等距，它一定会把连接<span class="math inline">\(\{\pm1\}\)</span> 的测地线映射为连接 <span class="math inline">\(\{0,\infty\}\)</span>的测地线，即锥面。换言之，判断场景中的一个点 <span class="math inline">\(p\)</span> 是不是落在 Dupin cyclide 上，只要判断<span class="math inline">\(g^{-1}(p)\)</span>是不是落在锥面上。这就好办了。</p><p>抛物的情形更简单一些，可以用 <span class="math inline">\(g(z)=1/z\)</span>把位于无穷远的不动点变到原点。</p><p>动画使用的是 GLSL 语言和 raymarching 的技术。我在 Roice的代码基础上作了许多优化，但肯定还可以更精炼。限于我写 shader的能力不足，做出更美轮美奂的效果就不指望了 …</p><p>严格讲，这些动画其实还是尝试在 Euclidean空间中去观察双曲空间中的对象，因为 raymarching技术假定的是光走直线，但在双曲空间中光一般不走直线，所以我们这里看到的效果与真实的生活在双曲空间中的“外星人”所看到的还是有差别的。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Bea95" class="csl-entry" role="listitem">Beardon, Alan F. 1995. <em>The Geometry of Discrete Groups</em>. Vol.91. Graduate Texts in Mathematics. Springer-Verlag, New York.</div><div id="ref-indra" class="csl-entry" role="listitem">Mumford, David, Caroline Series, and David J. Wright. 2002. <em>Indra’sPearls: An Atlas of Kleinian Groups</em>. Cambridge University Press.</div><div id="ref-Needham1997" class="csl-entry" role="listitem">Needham, Tristan. 1997. <em>Visual Complex Analysis</em>. The ClarendonPress, Oxford University Press, New York.</div><div id="ref-palka1991" class="csl-entry" role="listitem">Palka, B. P. 1991. <em>An Introduction to Complex Function Theory</em>.An Introduction to Complex Function Theory. World PublishingCorporation.</div></div>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Coupling from the past</title>
      <link href="/coupling-from-the-past/"/>
      <url>/coupling-from-the-past/</url>
      
        <content type="html"><![CDATA[<p>今天我要介绍一个 Markov 链采样中的精彩算法，叫做 coupling from thepast(CFTP)。这个算法看似简单，实则充满玄机。我相信你可以在五分钟内理解算法的步骤，然后再花五分钟左右看懂算法的证明，但是我打赌你需要几个星期甚至更久的时间来细细回味其中奥妙。</p><p>为了引出算法，我们从一个计数问题开始：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>下图是一个边长分别为 <span class="math inline">\(a,b,c\)</span> 的平行六边形，其中 <span class="math inline">\(a,b,c\)</span> 都是正整数，内角均为 120 度：</p><p><img src="/images/cftp/hexagon.svg" class="fig" width="400"></p><p>请问：用边长为 1 的菱形密铺它，有多少种不同的方法？</p></div><span id="more"></span><p>比如下图就是一种密铺的示例：</p><p><img src="/images/cftp/random_lozenge_tiling.svg" class="fig" width="400"></p><p>图中三种不同摆放角度的菱形被染成了不同的颜色。</p><p>这个问题的答案很不容易猜到，叫做 Macmahon 公式：</p><div id="macmahon-------" class="unnumbered statement sta_macmahon___ plain"><p><span class="statement-heading"><span class="statement-label">Macmahon 公式</span>.</span><span class="statement-spah"> </span>记 <span class="math inline">\(H(a,b,c)\)</span>为所求的六边形的不同菱形密铺的个数，则 <span class="math display">\[H(a,b,c)=\prod_{i=1}^a\prod_{j=1}^b\prod_{k=1}^c\frac{i+j+k-1}{i+j+k-2}.\]</span></p></div><p>关于 Macmahon 公式，以及它背后的 plane partition理论是另一段精彩的故事，这里不作介绍。需要注意的是，<span class="math inline">\(H(a,b,c)\)</span> 的值是指数级增长的，比如对 <span class="math inline">\(a=b=c=10\)</span> 这种比较小的情形 <span class="math inline">\(H(a,b,c)\approx9.265\times10^{33}\)</span>，已经是一个天文数字了。</p><p>真正的问题来了：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>怎样在全部 <span class="math inline">\(H(a,b,c)\)</span>种不同的密铺中完全随机地任选一种？也就是说，每一种密铺都应该以同样的概率被选中。不能有偏向，也不能近似凑合，必须是完完全全的随机。</p></div><p>由于 <span class="math inline">\(H(a,b,c)\)</span>太太太大了，我们不可能先把所有密铺都列出来然后再挑选，那样的话全世界的计算机内存加起来也装不下。所以得设计一个聪明点的方法，这就是CFTP 要做的。</p><h1 id="markov-链的随机取样">Markov 链的随机取样</h1><p>设 <span class="math inline">\(M\)</span> 是一个有限遍历的 Markov链，其状态空间为 <span class="math inline">\(S\)</span>，平稳分布为<span class="math inline">\(\pi\)</span>，我们希望以分布 <span class="math inline">\(\pi\)</span> 从 <span class="math inline">\(S\)</span> 中随机地取样，即对任何 <span class="math inline">\(s\in S\)</span>，取样抽到 <span class="math inline">\(s\)</span> 的概率为 <span class="math inline">\(\pi(s)\)</span>。这在许多实际应用中都有重要意义。通常的方法是任选一个初始状态<span class="math inline">\(s_0\)</span> 然后从 <span class="math inline">\(s_0\)</span> 出发跑这个 Markov链。可以证明只要运行的时间 <span class="math inline">\(n\)</span>足够大，其 <span class="math inline">\(n\)</span> 时刻的状态 <span class="math inline">\(s_n\)</span> 服从的分布就可以任意逼近平稳分布：<span class="math display">\[|\mathbb{P}(s_n=s) - \pi(s)| &lt;\epsilon,\quad\forall s\in S,\ \forall\epsilon&gt;0.\]</span>这个方法非常简单易行，但是它有两个缺陷：首先它只是一个近似算法，不管<span class="math inline">\(n\)</span> 取得多么大，返回的 <span class="math inline">\(s_n\)</span> 的分布只是近似而非严格等于平稳分布<span class="math inline">\(\pi\)</span>；其次为了获得足够的精度所需的时间<span class="math inline">\(n\)</span>（叫做 mixingtime）也不总是那么容易估计的，也就是说，你压根不知道需要跑多久才能让<span class="math inline">\(s_n\)</span> 的分布足够接近 <span class="math inline">\(\pi(s)\)</span>。那么有没有什么办法可以获得精确地服从<span class="math inline">\(\pi\)</span> 的采样呢？</p><p>Propp 和 Wilson 提出了如下的想法：既然从初始状态出发向未来 （<span class="math inline">\(+\infty\)</span> 方向） 跑 Markov链得不到真正的平稳分布，我们何不从无穷远的过去 （<span class="math inline">\(-\infty\)</span> 方向） 向现在 （时刻 0）跑呢？可以想象当这个链经过了无穷次迭代后，其 0 时刻的状态 <span class="math inline">\(s^\ast\)</span> 服从的分布就是 <span class="math inline">\(\pi\)</span>。当然，一个可行的算法必须在有限时间内输出结果，我们不可能做到真的从无穷远的过去出发。我们能做的只是选择一个足够大的<span class="math inline">\(n\)</span> 然后从 <span class="math inline">\(-n\)</span> 时刻出发向时刻 0 跑，但是这种做法和从0 时刻向时刻 <span class="math inline">\(n\)</span>跑没有什么区别。Propp 和 Wilson的观察的关键之处在于，只跑一个链是不行的，我们需要从每个 <span class="math inline">\(s\in S\)</span> 出发，同时跑 <span class="math inline">\(M\)</span> 的 <span class="math inline">\(|S|\)</span> 个不同的版本，并且观察它们是否在时刻0 时耦合在一起 (coupled together)，即相遇到了相同的状态 <span class="math inline">\(s^\ast\)</span>。一旦这件事情发生的话，那么假设我们还有一个额外的从无穷远出发、初始分布是<span class="math inline">\(\pi\)</span> 的链，由于它来到 0时刻必然也处于状态 <span class="math inline">\(s^\ast\)</span>，所以<span class="math inline">\(s^\ast\)</span> 就服从分布 <span class="math inline">\(\pi\)</span>。如果没有相遇呢？那就从某个更久远的位置开始再来一遍，直到耦合出现为止，这就是coupling from the past 的由来。</p><p>用不太准确的话说，我们是在时间 <span class="math inline">\(-n\)</span> 处设置了 <span class="math inline">\(|S|\)</span>个不同的链，封死了从无穷远过去出发的链在 <span class="math inline">\(-n\)</span>处的所有可能状态，然后通过将所有链在时刻 0“坍缩”为单个状态来获得采样。</p><p>其实我上面的描述仍然遗漏了 CFTP 的一些关键细节。为了准确的描述CFTP，我们首先引入 Markov 链的随机映射表示 (random mappingrepresentation)。</p><h1 id="markov-链的随机映射表示">Markov 链的随机映射表示</h1><p>随机映射表示能够让我们用计算机程序来模拟 Markov链，它是一个由随机数流驱动的更新函数 <span class="math inline">\(f:S\times [0, 1]\to S\)</span>。<span class="math inline">\(f\)</span>本身是确定的，对任何状态 <span class="math inline">\(s\in S\)</span> 和<span class="math inline">\(u\in [0,1]\)</span>，<span class="math inline">\(s'=f(s,u)\)</span> 给出 Markov链更新后的状态。我们要求 <span class="math inline">\(f\)</span> 满足当<span class="math inline">\(U\)</span> 是服从 <span class="math inline">\([0, 1]\)</span> 上的均匀分布的随机变量时，<span class="math inline">\(\mathbb{P}(f(s,U)=s')=P_{s,s'}\)</span>。这里 <span class="math inline">\(P_{s,s'}\)</span> 是 Markov 链从 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(s'\)</span> 的转移概率。任何有限 Markov链都存在随机映射表示，而且表示方法不是唯一的。最简单的构造方式是用一个阶梯函数：<span class="math display">\[f(s_i, u) =\begin{cases}\begin{array}{ll}s_1, &amp;\text{for } u\in[0,P_{i,1}),\\s_2, &amp;\text{for } u\in[P_{i,1}, P_{i,1}+P_{i,2}),\\\vdots&amp;\vdots\\s_j, &amp;\text{for } u\in\left[\sum_{k=1}^{j-1}P_{i,k},\sum_{k=1}^jP_{i,k}\right),\\\vdots &amp;\vdots\\s_n, &amp;\text{for }u\in\left[\sum_{k=1}^{n-1}P_{i,k},1\right].\end{array}\end{cases}\]</span></p><p>假设有一个随机数发生器可以产生独立且服从 <span class="math inline">\([0,1]\)</span> 上均匀分布的随机变量序列 <span class="math inline">\(U_0,U_{-1},U_{-2},\ldots\)</span>，则我们可以由此来驱动Markov 链 <span class="math inline">\(M\)</span>从过去的某个时刻向现在运行： <span class="math display">\[s_{-n}\xrightarrow{f(s_{-n+1},\,U_{-n+1})}s_{-n+1}\xrightarrow{f(s_{-n+2},\,U_{-n+2})}\cdots\xrightarrow{f(s_0,\,U_0)}s_0.\]</span></p><h1 id="coupling-from-the-past-算法">Coupling from the past 算法</h1><p>现在我们可以来表述 coupling from the past 算法了。</p><p>设 <span class="math inline">\(M\)</span> 是一个有限遍历的 Markov链，状态空间为 <span class="math inline">\(S\)</span>，<span class="math inline">\(f: S\times [0, 1]\to S\)</span>是其随机映射表示。<span class="math inline">\(U_0,U_{-1},\ldots\)</span>是一列随机数，它们分别来自一列独立且服从 <span class="math inline">\([0,1]\)</span> 上均匀分布的随机变量。记 <span class="math inline">\((N_1,N_2,\ldots)=(1,2,4,8,\ldots)\)</span>，<span class="math inline">\(-N_{m}\)</span> 将作为我们第 <span class="math inline">\(m\)</span> 次重启的出发时间。</p><div id="coupling-from-the-past-------" class="statement sta_coupling_from_the_past___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Coupling from the past 算法</span>.</span><span class="statement-spah"> </span>：</p><ol type="1"><li>令 <span class="math inline">\(m=1\)</span>。</li><li>对每个 <span class="math inline">\(s\in S\)</span>，以 <span class="math inline">\(s\)</span> 为初始状态，以 <span class="math inline">\(-N_m\)</span> 为初始时刻向时刻 0 的方向运行 Markov链 <span class="math inline">\(M\)</span>，所有 <span class="math inline">\(|S|\)</span> 个链使用的随机数流是一样的，都是<span class="math inline">\((U_{-N_m+1},\ldots,U_{-1},U_0)\)</span>。</li><li>如果步骤 2 中的 <span class="math inline">\(|S|\)</span> 个链在时刻0 给出的状态相同，记此状态为 <span class="math inline">\(s^\ast\)</span>，则输出 <span class="math inline">\(s^\ast\)</span> 并退出程序。否则将 <span class="math inline">\(m\)</span> 的值加 1 并重复步骤 2。</li></ol><p>下图显示了算法的每个重启时刻，相同颜色的随机数是在同一批中生成的。</p><p><img src="/images/cftp/random_numbers.svg" class="fig"></p><p><strong>断言</strong>：如果上述步骤以概率 1在有限时间内结束，则其返回值 <span class="math inline">\(s^\ast\)</span>服从平稳分布 <span class="math inline">\(\pi\)</span>: <span class="math display">\[\mathbb{P}(s^\ast = s) = \pi(s),\quad \foralls\in S.\]</span></p></div><p>注意这里的两个细节：</p><ol type="1"><li>我们强调了前提<strong>如果算法以概率 1在有限时间内结束，则返回值服从平稳分布</strong>。为了保证这个前提成立更新函数<span class="math inline">\(f\)</span>的选择就不能是任意的，特别地在后面的 monotone CFTP 中更新函数还要与<span class="math inline">\(S\)</span>上的偏序相容，更不能是任意的。</li><li>当第 <span class="math inline">\(m\)</span> 次执行步骤 2时，使用的随机数为 <span class="math inline">\((U_{-N_m+1},U_{-N_m+2},\ldots,U_{-1},U_0)\)</span>，其中的后半部分<span class="math inline">\((U_{-N_{m-1}+1},U_{-N_{m-1}+2},\ldots,U_{-1},U_0)\)</span>需要与上一次使用的相同，<strong>即每一次都重复使用上一次的随机数作为后半段的随机源</strong>，否则每次都重新生成一列新的随机数的话得到的最终状态未必服从平稳分布。</li></ol><p><strong>证明</strong>：任取 <span class="math inline">\(s_i\inS\)</span>，只要证明对任何 <span class="math inline">\(\epsilon&gt;0\)</span> 都有 <span class="math display">\[|\mathbb{P}(s^\ast=s_i) -\pi(s_i)|&lt;\epsilon.\]</span> 设 <span class="math inline">\(\Omega=\{(U_{-1},U_{-2},\ldots)\mid U_i \text{i.i.d on } [0,1]\}\)</span> 是所有随机数流组成的样本空间， <span class="math display">\[A=\{\omega\in\Omega\mid\text{算法在有限时间内结束}\}.\]</span> 则由已知有 <span class="math inline">\(\mathbb{P}(A)=1\)</span>。又记 <span class="math display">\[A_i = \{ \omega\in\Omega\mid \text{算法从某个$\geq -N_i$ 的时刻出发可以结束}\}.\]</span></p><p>显然我们有 <span class="math inline">\(A_i\uparrow A\)</span>，<span class="math inline">\(\mathbb{P}(A_i)\uparrow\mathbb{P}(A)=1\)</span>。因此对充分大的<span class="math inline">\(K\)</span> 有 <span class="math inline">\(\mathbb{P}(A_K) \geq1-\epsilon\)</span>。取定这样的 <span class="math inline">\(K\)</span>，则在事件 <span class="math inline">\(A_K\)</span> 上，所有的链在时刻 0 耦合到相同的状态<span class="math inline">\(s^\ast\)</span>。</p><p>除了以上 <span class="math inline">\(|S|\)</span>条链之外，我们再额外跑一条单独的链 <span class="math inline">\(Y\)</span>，这条链的初始状态选自平稳分布 <span class="math inline">\(\pi\)</span>，也从时刻 <span class="math inline">\(-N_K\)</span> 出发，也使用相同的随机数 <span class="math inline">\((U_{-N_K+1},\ldots,U_0)\)</span> 运行至时刻0，并设这个链在时刻 0 的状态为 <span class="math inline">\(Y_0\)</span>，则 <span class="math inline">\(Y_0\)</span> 服从平稳分布。</p><p>在事件 <span class="math inline">\(A_K\)</span>上，不管这条单独的链初始状态是什么，由于它使用了同样的随机数序列，所以它最后一定会和其余<span class="math inline">\(|S|\)</span> 条链一起耦合，所以 <span class="math display">\[\mathbb{P}(s^\ast=Y_0) \geq \mathbb{P}(A_K)\geq 1- \epsilon.\]</span> 从而对任何 <span class="math inline">\(s_i\inS\)</span>， <span class="math display">\[\begin{aligned}\mathbb{P}(s^\ast =s_i)-\pi(s_i)&amp;= \mathbb{P}(s^\ast = s_i)-\mathbb{P}(Y_0 =s_i)\\&amp;\leq\mathbb{P}(s^\ast=s_i, Y_0\ne s_i)\\&amp;\leq\mathbb{P}(Y_0\nes^\ast)\\&amp;\leq\epsilon.\end{aligned}\]</span> 类似地 <span class="math display">\[\begin{aligned}\pi(s_i)-\mathbb{P}(s^\ast =s_i)&amp;=\mathbb{P}(Y_0 = s_i)-\mathbb{P}(s^\ast =s_i)\\&amp;\leq\mathbb{P}(Y_0=s_i, s^\ast\ne s_i)\\&amp;\leq\mathbb{P}(Y_0\nes^\ast)\\&amp;\leq\epsilon.\end{aligned}\]</span> 从而 <span class="math display">\[|\mathbb{P}(s^\ast = s_i)-\pi(s_i)| \leq\epsilon.\]</span> 令 <span class="math inline">\(K\to\infty\)</span>，则 <span class="math inline">\(\epsilon\downarrow0\)</span>。注意到对任何样本点<span class="math inline">\(\omega\in A_K\)</span>，如果 <span class="math inline">\(\omega\)</span> 给出的所有链的耦合状态是 <span class="math inline">\(s^\ast=s_i\)</span>，则从更久远的时刻出发，<span class="math inline">\(\omega\)</span> 给出的耦合状态仍然是 <span class="math inline">\(s_i\)</span>，即 <span class="math inline">\(\omega\)</span> 输出的采样结果 <span class="math inline">\(s^\ast\)</span> 是不会随着 <span class="math inline">\(K\)</span> 增大而改变的，所以由 <span class="math inline">\(\epsilon\)</span> 的任意性即得 <span class="math inline">\(s^\ast\)</span> 服从平稳分布。</p><h1 id="算法中的若干陷阱">算法中的若干陷阱</h1><p>CFTP算法的证明看似不难，但其实微妙之处不少，值得细细品味。最主要的地方有三个：</p><blockquote><p><strong>问题 1</strong>：为什么说更新函数 <span class="math inline">\(f\)</span> 的选择不能是任意的？</p><p><strong>问题 2</strong>：既然 「coupling from the past」 可以，那「coupling to the future」 可不可以？从时刻 0 开始从每个 <span class="math inline">\(s\in S\)</span> 出发跑 <span class="math inline">\(|S|\)</span> 个不同的链，直到它们在未来某个时刻<span class="math inline">\(n\)</span>耦合为止，然后输出第一次耦合时的状态不行吗？</p><p><strong>问题 3</strong>：每次重启步骤 2时需要复用之前的随机数，这一点在证明中哪里用到了？使用一列新的随机数为什么不可以？</p></blockquote><p>我们用几个例子来说明这三个问题。</p><h2 id="为什么更新函数不能是任意的">为什么更新函数不能是任意的</h2><p>考虑含有两个状态 <span class="math inline">\(S=\{s_1, s_2\}\)</span>的 Markov 链，其转移矩阵为 <span class="math inline">\(P=\begin{bmatrix}0.5 &amp; 0.5\\0.5 &amp;0.5\end{bmatrix}\)</span>，更新函数为 <span class="math display">\[f(s_1, u) =\begin{cases}\begin{array}{ll}s_1&amp; \text{for } u \in [0, 0.5)\\s_2 &amp; \text{for } u \in [0.5,1]\end{array}\end{cases}\]</span> 和 <span class="math display">\[f(s_2,u) =\begin{cases}\begin{array}{ll}s_2 &amp; \text{for } u \in [0,0.5)\\s_1 &amp; \text{for } u \in [0.5,1]\end{array}\end{cases}\]</span> 于是若从 <span class="math inline">\(s_1,s_2\)</span>分别出发跑两个不同的链，但是每次使用相同的随机数，则它们要么保持不动，要么交换状态，永不耦合。</p><h2 id="为什么-coupling-into-the-future-不行">为什么 Coupling into thefuture 不行</h2><p>我打赌任何看到 CFTP算法的人都会想到同样的问题：为什么不能向未来耦合呢？</p><blockquote><p><strong>Coupling into the future</strong>: 从时刻 0 出发同时跑 <span class="math inline">\(|S|\)</span> 个不同的链，其中链 <span class="math inline">\(i\)</span> 的初始状态是 <span class="math inline">\(s_i\)</span>。当所有链首次耦合到同一状态 <span class="math inline">\(s^\ast\)</span> 时，终止算法并输出 <span class="math inline">\(s^\ast\)</span> 作为采样状态。</p></blockquote><p>向未来耦合与 CFTP有一个根本不同：向未来耦合的结束时间是一个随机时间，而在 CFTP中，我们总是在固定的时刻 0 观察所有链是否耦合。</p><p>我们来试试把上面 CFTP 的证明照抄在这里：设 <span class="math inline">\(\tau\)</span> 是所有 <span class="math inline">\(|S|\)</span> 条链首次耦合的时间，<span class="math inline">\(Y\)</span> 是额外的从时刻 0出发的、初始分布为平稳分布的链，并且使用相同的随机数流，则对任何时刻<span class="math inline">\(n\ge0\)</span>，<span class="math inline">\(Y_n\)</span>都服从平稳分布。但是当把下标换成随机时间 <span class="math inline">\(\tau\)</span> 时，<span class="math inline">\(Y_\tau\)</span>未必仍然服从平稳分布，所以之前的证明不再可用。</p><p>我们用一个反例来说明：仍然考虑两个状态 <span class="math inline">\(S=\{s_1, s_2\}\)</span> 的 Markov 链，其转移矩阵为<span class="math inline">\(P=\begin{bmatrix}0.5 &amp; 0.5\\1 &amp;0\end{bmatrix}\)</span>，即从 <span class="math inline">\(s_1\)</span>出发的话以 0.5 的概率待在原地，以 0.5 的概率跳到 <span class="math inline">\(s_2\)</span>，从 <span class="math inline">\(s_2\)</span> 出发的话则总是跳到 <span class="math inline">\(s_1\)</span>。</p><p><img style="margin:0px auto;display:block" width="250" src="/images/cftp/counter_example.svg"></p><p>这个链的平稳分布为 <span class="math inline">\(\pi=(\frac{2}{3},\frac{1}{3})\)</span>。现在假设从<span class="math inline">\(s_1,s_2\)</span> 分别出发，从时刻 0 开始向<span class="math inline">\(+\infty\)</span> 方向跑两个不同的链，<span class="math inline">\(\tau\)</span> 是它们首次耦合的时间，则 <span class="math inline">\(\tau-1\)</span> 时刻它俩必然一个位于 <span class="math inline">\(s_1\)</span>，一个位于 <span class="math inline">\(s_2\)</span>。但是位于 <span class="math inline">\(s_2\)</span> 的状态只能转移到 <span class="math inline">\(s_1\)</span>，所以 <span class="math inline">\(\tau\)</span> 时刻的输出永远是 <span class="math inline">\(s_1\)</span>，从而得到的采样 <span class="math inline">\(Y_\tau\)</span> 不满足平稳分布。</p><h2 id="为什么每次不能重新生成随机数">为什么每次不能重新生成随机数</h2><p>思考一下，在算法的证明当中，如果在每次迭代中都使用全新的随机数序列的话，那么事件<span class="math inline">\(A\)</span> 的定义会变成什么？难道是 <span class="math inline">\(\Omega\)</span>的某个有限子集，使得其包含一个可以耦合的序列？Hmm，这就不太对劲了。直观上看，在第<span class="math inline">\(m\)</span>次迭代时，由于生成的序列是全新的，有可能它实际上对某个 <span class="math inline">\(i&lt;m\)</span>，从 <span class="math inline">\(-N_i\)</span>出发就可以耦合，这会导致算法过度采样那些很快就可以耦合的短链，从而使得最终的分布不服从平稳分布。</p><p>我们继续用上一小节中的例子来说明。我们指定其更新函数 <span class="math inline">\(f\)</span>为随机映射表示一节中给出的阶梯函数形式。假设算法每次都使用一列新的随机数，其最终输出为<span class="math inline">\(s^\ast\)</span>。定义随机变量 <span class="math inline">\(\tau\)</span> 为正整数 <span class="math inline">\(m\)</span> 使得算法中使用的最早的出发时间为 <span class="math inline">\(-N_m\)</span>，则 <span class="math display">\[\begin{aligned}\mathbb{P}(s^\ast=s_1)&amp;=\sum_{m=1}^\infty\mathbb{P}(s^\ast=s_1,\tau=m)\\&amp;\geq\mathbb{P}(s^\ast=s_1,\tau=1)+\mathbb{P}(s^\ast=s_1,\tau=2)\\&amp;=\mathbb{P}(\tau=1)\mathbb{P}(s^\ast=s_1|\tau=1)+\mathbb{P}(\tau=2)\mathbb{P}(s^\ast=s_1|\tau=2)\end{aligned}\]</span> 注意事件 <span class="math inline">\(\{\tau=1\}\)</span> 包含两种不同的演化路径： <span class="math display">\[\begin{aligned}(1)\quad &amp; s_1\to s_1,\quads_2\to s_1.\\(2)\quad &amp; s_1\to s_2,\quad s_2\to s_1.\end{aligned}\]</span>其中只有前者能成功耦合，所以 <span class="math inline">\(\mathbb{P}(\tau=1)=\frac{1}{2}\)</span>，这时输出的状态只能是<span class="math inline">\(s_1\)</span>，所以<span class="math inline">\(\mathbb{P}(s^\ast=s_1|\tau=1)=1\)</span>。</p><p>可以看到这个长度是 1 的短链的耦合只发生在状态 <span class="math inline">\(s_1\)</span> 上，它非常偏爱 <span class="math inline">\(s_1\)</span>。</p><p>事件 <span class="math inline">\(\{\tau=2\}\)</span>包含四种不同的演化路径： <span class="math display">\[\begin{align*}(1)\quad &amp; s_1\to s_1\tos_1,\quad s_2\to s_1 \to s_1.\\(2)\quad &amp; s_1\to s_2\to s_1,\quad s_2\to s_1 \to s_1.\\(3)\quad &amp; s_1\to s_1\to s_2,\quad s_2\to s_1 \to s_2.\\(4)\quad &amp; s_1\to s_2\to s_1,\quad s_2\to s_1 \tos_2.\end{align*}\]</span>注意以下两种演化路径是非法的，因为每个时刻两个链使用的随机数一样，不可能在某个时刻同时出现一个链<span class="math inline">\(s_1\to s_2\)</span>，另一个 <span class="math inline">\(s_1\to s_1\)</span> 的情况： <span class="math display">\[\begin{array}{ll}(*)\quad &amp; s_1\to s_1\to s_2,\quad &amp;s_2\to s_1 \to s_1.\\(**)\quad &amp; s_1\to s_1\to s_1,\quad &amp;s_2\to s_1 \to s_2.\\\end{array}\]</span></p><p>在我们现在这个错误的版本中，由于使用了全新的随机数流，四种路径都是合法的。这四个路径中前三种都成功耦合，两个耦合于<span class="math inline">\(s_1\)</span> 一个耦合于 <span class="math inline">\(s_2\)</span>，所以 <span class="math inline">\(\mathbb{P}(s^\ast=s_1|\tau=2)=\frac{2}{3}\)</span>。</p><p>注意到其中第二条路径 <span class="math display">\[(2)\quad  s_1\tos_2\to s_1,\quad s_2\to s_1 \to s_1.\]</span> 从时刻 <span class="math inline">\(-1\)</span> 出发就可以耦合，它不应该属于事件 <span class="math inline">\(\{\tau=2\}\)</span>。每次使用全新的随机数流会导致偏爱<span class="math inline">\(s_1\)</span> 的短链被过度采样。</p><p>我们来具体验证一下： <span class="math display">\[\mathbb{P}(\tau=2)=\mathbb{P}(\tau\ne1)\cdot\mathbb{P}(\tau=2\\text{时耦合})=\frac{1}{2}\cdot\frac{3}{4}=\frac{3}{8}.\]</span></p><p>所以 <span class="math display">\[\begin{align*}\mathbb{P}(s^\ast=s_1)&amp;\geq\mathbb{P}(\tau=1)\mathbb{P}(s^\ast=s_1|\tau=1)+\mathbb{P}(\tau=2)\mathbb{P}(s^\ast=s_1|\tau=2)\\&amp;=\frac{1}{2}\cdot1+ \frac{3}{8}\cdot\frac{2}{3}\\&amp;=\frac{3}{4}&gt;\pi(s_1).\end{align*}\]</span></p><p>确实如我们的预言，<span class="math inline">\(s_1\)</span>被过度采样了。</p><h1 id="monotone-coupling-from-the-past">Monotone coupling from thepast</h1><p>在 CFTP 算法中，我们需要同时跑 <span class="math inline">\(|S|\)</span> 个不同的链并要求它们在时刻 0处耦合，当 <span class="math inline">\(|S|\)</span>很大时所耗的时间和计算量都很不划算，所以这个算法在应用中是有限制的。但是有一种情形它是非常好用的：如果<span class="math inline">\(S\)</span> 是一个偏序集 <span class="math inline">\((S, \preceq)\)</span>，有最大最小元 <span class="math inline">\(s_\max, s_\min\)</span>，并且更新函数 <span class="math inline">\(f\)</span> 与偏序 <span class="math inline">\(\preceq\)</span> 相容，即对任何 <span class="math inline">\(s,s'\in S\)</span>，<span class="math inline">\(u\in[0,1]\)</span>， <span class="math display">\[s\preceq s' \Rightarrow f(s, u) \preceqf(s', u),\]</span> 则我们只要对 <span class="math inline">\(s_\max,s_\min\)</span>这两个状态跑两个不同的链即可，当它俩耦合时，所有其它的链也会被“挤压”到相同的状态。这就是前面六边形的菱形密铺取样所采取的方法。</p><p>我们在所有菱形密铺组成的集合 <span class="math inline">\(S\)</span>上定义一个偏序 <span class="math inline">\(\preceq\)</span>，这个偏序的定义颇有技巧性，它需要将任一密铺对应到一个不相交的格点路径组，如下图所示：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/non-intersecting_paths_lozenge.svg"></p><p>图中一共出现了 <span class="math inline">\(c+2\)</span>条不相交的路径，其中最上方和最下方两条路径对任何密铺都是固定的（它俩是用来约束中间的 <span class="math inline">\(c\)</span>条路径，让它们在翻转的过程不要越界），中间的 <span class="math inline">\(c\)</span>条路径，每条路径的起点和终点也是固定的，它们从菱形最左边的边的每个单位线段中点出发，每一步分别向右上或者右下走一步，经过<span class="math inline">\(a+b\)</span>步后到达最右边的边的对应位置。</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/two_paths.svg"></p><p>上图中从菱形的最左边到最右边共有 <span class="math inline">\(a+b+1\)</span>条竖直的网格线，每一步向右上或者右下走一步会向右移动到下一个网格线，所以总共需要<span class="math inline">\(a + b\)</span>次到达最右边。不同的路径互不相交，所以它们的终点必须互不相同，因此这些终点必然分别依次是菱形最右边的单位线段的中点。</p><p>不难说明所有的菱形密铺和所有不相交路径组之间的一一对应关系：当密铺给定时，从左边每个起点出发开始，根据当前菱形的倾斜方向依次描出路径即可；反之当路径组给定时，可以沿着每条路径铺砖，这样确定所有的“斜”菱形的位置，余下的空白位置只有唯一的方式可以被水平的菱形填充。</p><p>我们在所有不相交的路径组之间定义一个偏序：两个路径组 <span class="math inline">\(\mathcal{P}\preceq\mathcal{P}'\)</span>当且仅当对任何 <span class="math inline">\(1\leq i\leqc+2\)</span>，<span class="math inline">\(\mathcal{P}\)</span> 中的第<span class="math inline">\(i\)</span> 条路径 <span class="math inline">\(p_i\)</span> 整体地位于 <span class="math inline">\(\mathcal{P}'\)</span> 中第 <span class="math inline">\(i\)</span> 条路径 <span class="math inline">\(p_i'\)</span>的下方。在这个偏序下的最大元就是所有路径尽可能地「向上拱」：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/max_state.svg"></p><p>而最小元则是所有路径尽可能地「向下走」：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/min_state.svg"></p><p>有了偏序，我们还要定义一个与之相容的更新函数 <span class="math inline">\(f\)</span>。<span class="math inline">\(f\)</span>的定义是这样的：对一个不相交路径组 <span class="math inline">\(\mathcal{P}\)</span>，我们每次在 <span class="math inline">\(\mathcal{P}\)</span> 的中间 <span class="math inline">\(c\)</span> 条路径中，在路径内部 （两头端点除外）任选一个顶点 <span class="math inline">\(v\)</span>：</p><ol type="1"><li>如果 <span class="math inline">\(v\)</span> 是一个「山峰」，即形如<span class="math inline">\(\wedge\)</span>，则我们以 1/2 的概率保持<span class="math inline">\(\mathcal{P}\)</span> 不变，以 1/2的概率尝试将 <span class="math inline">\(\mathcal{P}\)</span> 在 <span class="math inline">\(v\)</span> 处翻转为一个「山谷」 <span class="math inline">\(\vee\)</span>，如果翻转之后得到的路径组 <span class="math inline">\(\mathcal{P}'\)</span>仍然满足路径之间不相交的约束，则规定 <span class="math inline">\(\mathcal{P}'=f(\mathcal{P})\)</span>，否则仍然保持<span class="math inline">\(\mathcal{P}\)</span> 不变。</li><li>如果 <span class="math inline">\(v\)</span> 是一个「山谷」，即形如<span class="math inline">\(\vee\)</span>，则与上面的情形类似，我们以1/2 的概率保持 <span class="math inline">\(\mathcal{P}\)</span> 不变，以1/2 的概率尝试将 <span class="math inline">\(\mathcal{P}\)</span> 在<span class="math inline">\(v\)</span> 处翻转为一个「山峰」 <span class="math inline">\(\wedge\)</span>，如果翻转之后得到的路径组满足不相交的约束，则规定<span class="math inline">\(\mathcal{P}'=f(\mathcal{P})\)</span>，否则仍然保持<span class="math inline">\(\mathcal{P}\)</span> 不变。</li><li>如果 <span class="math inline">\(v\)</span>既不是「山峰」也不是「山谷」，则保持 <span class="math inline">\(\mathcal{P}\)</span> 不变。</li></ol><p>菱形密铺在三维空间中看起来像是「堆箱子」，这个翻转路径的操作就相当于从中添加/移除一个箱子，并且必须保证这个箱子有三个面可见：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/cftp/flip_lozenge.svg"></p><p>我们来验证 <span class="math inline">\(f\)</span>是和路径组之间的偏序 <span class="math inline">\(\preceq\)</span>相容的：设 <span class="math inline">\(\mathcal{P}\preceq\mathcal{P}'\)</span>是两个不相交路径组，对给定的随机操作 <span class="math inline">\(u\)</span>，<span class="math inline">\(f(\mathcal{P}, u)\)</span> 和 <span class="math inline">\(f(\mathcal{P}', u)\)</span> 就是对 <span class="math inline">\(\mathcal{P}\)</span> 和 <span class="math inline">\(\mathcal{P}'\)</span> 的同一个位置 <span class="math inline">\((k, j)\)</span>（即第 <span class="math inline">\(k\)</span> 条路径中的第 <span class="math inline">\(j\)</span> 个顶点）同时尝试进行一个 <span class="math inline">\(\vee\to\wedge\)</span> 或者 <span class="math inline">\(\wedge\to\vee\)</span> 的操作。不妨假设这个操作是<span class="math inline">\(\vee\to\wedge\)</span>，则有四种可能的结果：<span class="math inline">\(\mathcal{P}\)</span> 和 <span class="math inline">\(\mathcal{P}'\)</span>都操作成功，都保持不变或者一个操作成功另一个保持不变。不难验证这四种情况下都有<span class="math inline">\(f(\mathcal{P},u)\preceq f(\mathcal{P}',u)\)</span>。</p><p>由于每个不相交的路径组都可以通过适当操作变为最大元或者最小元，所以这个链是个互通的Markov 链。并且由于 <span class="math inline">\(\mathcal{P}\)</span>以至少 1/2 的概率在 <span class="math inline">\(f\)</span>下保持不变，这个链还是非周期的，因此是一个遍历的 Markov链，所以有唯一的平稳分布。但是不难看到这个链还是对称的，所以这个唯一的平稳分布是均匀分布。即从最大元和最小元出发跑CFTP，最终得到的样本服从全体菱形密铺上的均匀分布。</p><p>Monotone CFTP 也可以应用在其它许多密铺问题的均匀采样中，例如下图是在<span class="math inline">\(20\times 20\)</span>的矩形区域的所有多米诺骨牌密铺中均匀采样，同样可以把密铺一一对应到不相交的路径组：</p><p><img style="margin:0px auto;display:block" width="600" src="/images/cftp/domino_tiling_example.svg"></p><h1 id="参考文献">参考文献</h1><ol type="1"><li>Finite Markov chains and algorithmic applications, OlleHäggström.</li><li><a href="https://pages.uoregon.edu/dlevin/MARKOV/mcmt2e.pdf">Markovchains and mixing times</a>, Yuval Peres, Elizabeth L. Wilmer, David A.Levin.</li><li><a href="https://www.researchgate.net/publication/2455641_Markov_Chain_Algorithms_for_Planar_Lattice_Structures">MarkovChain Algorithms for Planar Lattice Structures</a>, Michael Luby, DanaRandall, Alistair Sinclair.</li><li><a href="https://arxiv.org/abs/math/0102193">Mixing times of lozengetiling and card shuffling Markov chains</a>, David B. Wilson.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 完美采样 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Wilson 均匀生成树算法</title>
      <link href="/wilson-algorithm/"/>
      <url>/wilson-algorithm/</url>
      
        <content type="html"><![CDATA[<div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>给定一个有限、无向的连通图 <span class="math inline">\(G= ( V,E )\)</span>，设 <span class="math inline">\(\mathcal{T}\)</span> 是 <span class="math inline">\(G\)</span> 的所有生成树组成的集合，怎样在 <span class="math inline">\(\mathcal{T}\)</span>中按照均匀分布进行采样？即设计一个算法，能够随机地给出 <span class="math inline">\(G\)</span> 的一个生成树，并且 <span class="math inline">\(\mathcal{T}\)</span>中每个生成树被取到的概率是相等的。</p></div><p>常见的生成树算法如 DFS/BFS 算法、Prim 算法、Kruskal算法等给出的生成树都不是完全随机的。例如，取 <span class="math inline">\(G\)</span> 为 <span class="math inline">\(\mathbb{Z}^2\)</span> 中 <span class="math inline">\(m\times n\)</span> 的网格图，<span class="math inline">\(G\)</span>的任何生成树都是一个迷宫，把背景平面涂黑，把生成树的边涂白，就可以清楚地看到迷宫的结构。迷宫的任何两个房间( 即树的顶点 )可以通过生成树中唯一的路径相连，这样的迷宫叫做完美迷宫。</p><p>DFS 算法 ( 每次将新顶点的顺序打乱再入栈 )倾向于尽可能深地探索整个图，因此得到的迷宫往往包含长且蜿蜒的路径，死角 (即叶节点 ) 是很少的：</p><figure><img src="/images/gifmaze/random_dfs.gif" class="fig" width="500" alt="DFS 算法动画"><figcaption aria-hidden="true">DFS 算法动画</figcaption></figure><span id="more"></span><p>与之相反，Prim算法由于每次是在当前树上随机添加一个叶节点，因此得到的迷宫往往包含很多死角，几乎没有笔直且长的路径：</p><figure><img src="/images/gifmaze/prim.gif" class="fig" width="500" alt="Prim 算法动画"><figcaption aria-hidden="true">Prim 算法动画</figcaption></figure><p>总之从直观上就可以看出这两个算法得到的生成树都不是完全随机的。</p><p>目前最快的生成均匀生成树的算法是 Wilson算法，这个算法描述起来很简单，但神奇的是，从描述里面你看不到任何关于均匀性的信息，但是它确实可以生成均匀的生成树！</p><div id="wilson-algo" class="statement sta_wilson___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Wilson算法</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(G\)</span> 是一个有限简单连通图。</p><ol type="1"><li>任取一个顶点 <span class="math inline">\(r\)</span>，维护一个树<span class="math inline">\(T\)</span>，初始时 <span class="math inline">\(T=\{r\}\)</span>。</li><li>任取一个不属于 <span class="math inline">\(T\)</span> 的顶点 <span class="math inline">\(v\)</span>，从 <span class="math inline">\(v\)</span>出发作图上的随机游动，一边走一边随时擦掉路径中出现的圈 ( 此谓之 looperased random walk ) ，即每当走到一个以前访问过的顶点 <span class="math inline">\(x\)</span>，则两次访问 <span class="math inline">\(x\)</span>之间的路径都被擦掉。按此规则持续行走直到与 <span class="math inline">\(T\)</span> 相遇为止，这时得到一条从 <span class="math inline">\(v\)</span> 到 <span class="math inline">\(T\)</span> 的不含圈的路径 <span class="math inline">\(p\)</span>，把 <span class="math inline">\(p\)</span> 加入到 <span class="math inline">\(T\)</span> 中，将 <span class="math inline">\(T\)</span> 更新为 <span class="math inline">\(T=T\cup p\)</span>。</li><li>重复步骤 2 直到 <span class="math inline">\(T\)</span> 包含 <span class="math inline">\(G\)</span> 的所有顶点，这时 <span class="math inline">\(T\)</span> 是一个服从均匀分布的生成树。</li></ol></div><p>下面是 Wilson 算法的 Javascript演示，你可以随时单击鼠标来重启动画。</p><script type="text/javascript" src="/code/wilson.js"></script><canvas id="wilson" width="600" height="600"></canvas><div id="two-arbitrary"><p>注意 Wilson 算法的描述中有两个<strong>任意</strong>：</p><ol type="1"><li>初始时可以任选一个初始根节点 <span class="math inline">\(r\)</span>。</li><li>每次可以任选一个不属于 <span class="math inline">\(T\)</span>的顶点出发作随机游动。</li></ol></div><p>Wilson 的 <a href="https://dl.acm.org/doi/10.1145/237814.237880">论文</a>中给出的证明相当有技巧性，而且有一些晦涩的部分，我是花了很久才真正理解。本文就来介绍这个证明。</p><h1 id="证明思路">证明思路</h1><p>先不管均匀分布的事情，我们来说明 Wilson 算法以概率 1会在有限时间内结束。</p><div id="algo-success" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题1.1</span>.</span><span class="statement-spah"> </span>Wilson 算法以概率1 在有限时间内返回一个生成树。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(G\)</span>有限且连通，所以其上的随机游动是常返的，在算法第 2步中，每次从一个新顶点 <span class="math inline">\(v\)</span>出发的随机游动以概率 1 在有限时间内撞到 <span class="math inline">\(T\)</span>。这样的循环只能执行有限多次 ( 次数以<span class="math inline">\(|V|\)</span> 为上界 ) ，所以算法以概率 1在有限时间内结束。<span class="math inline">\(\blacksquare\)</span></p><p>所以真正有挑战性的地方在于论证得到的生成树服从均匀分布。</p><p>证明的大致想法是这样的：我们构造概率空间 <span class="math inline">\(( \Omega,\mathbb{P} )\)</span> 和映射 <span class="math inline">\(\phi:\Omega\to\mathcal{T}\)</span>，使得它们满足如下的条件：</p><div id="requirements" class="statement simple plain unnumbered"><ol type="1"><li><span class="math inline">\(\phi\)</span> 对几乎处处的 <span class="math inline">\(\omega\in\Omega\)</span> 有定义 ( 不是所有的 <span class="math inline">\(\omega\)</span>都对应一个生成树，但这种例外发生的概率是 0 ) 。</li><li><span class="math inline">\(\phi\)</span> 是满射。 ( 不能漏掉任何树)</li><li>对任何树 <span class="math inline">\(T\in\mathcal{T}\)</span>，其在<span class="math inline">\(\Omega\)</span> 中的原像 <span class="math inline">\(\phi^{-1} ( T )\)</span> 的测度是一个与 <span class="math inline">\(T\)</span> 无关的常数。</li></ol></div><p>一旦找到了这样的概率空间 <span class="math inline">\((\Omega,\mathbb{P} )\)</span> 和映射 <span class="math inline">\(\phi\)</span>，则 <span class="math inline">\(\phi( \omega )\)</span> 以概率 1 是一个生成树，且服从 <span class="math inline">\(\mathcal{T}\)</span> 上的均匀分布。</p><p>构造 <span class="math inline">\(( \Omega,\mathbb{P} )\)</span> 和<span class="math inline">\(\phi\)</span> 的关键，是把 <span class="math inline">\(( \Omega,\mathbb{P} )\)</span>看作一个游戏的系统随机性，Wilson算法看作玩家的一种操作策略，但是这个策略对结果没有影响，即实际上任何游戏策略都会得到相同的结果，从而游戏结果完全由系统随机性<span class="math inline">\(\omega\in\Omega\)</span> 决定，这就是映射<span class="math inline">\(\phi\)</span>！</p><p>系统随机性在许多游戏中是一个常见的概念：玩家的出生地，道具的出现，各种boss的行为都是由系统随机性决定的。系统随机性和玩家的操作合起来决定了游戏的结果（当然我们忽略了玩家的硬件差异等其它因素）。</p><p>作为例子，我们来看看大家都熟悉的 Tetris游戏（俄罗斯方块）。我喜欢这个例子是因为它也涉及“消去”的操作。</p><p>经典的 Tetris 游戏是这样的，系统每次会随机从屏幕顶端落下 <span class="math inline">\(\{I,L,J,O,S,T,Z\}\)</span> 七种四方块 ( tetromino)中的一个。玩家可以在方块下落的过程中移动或者旋转它，尽可能地形成完整的水平行。每当出现完整的水平行时，这些行会被立刻消掉，同时玩家获得一定的分数。玩家的目的是获得尽可能高的分数。</p><figure><img src="/images/wilson/tetris.gif" class="fig" width="500" alt="Tetris 游戏动画"><figcaption aria-hidden="true">Tetris 游戏动画</figcaption></figure><p>Tetris 游戏的系统随机性可以用一个概率空间 <span class="math inline">\(( \Omega,\mathbb{P} )\)</span> 来描述：任何样本点<span class="math inline">\(\omega\in\Omega\)</span> 是一个无穷序列<span class="math inline">\(\omega=\{X_i\}_{i=1}^\infty\)</span>，<span class="math inline">\(X_i\)</span> 表示第 <span class="math inline">\(i\)</span> 个落下的方块的类型，它来自集合 <span class="math inline">\(\{I,L,J,O,S,T,Z\}\)</span> 的独立均匀采样。<span class="math inline">\(\Omega\)</span> 上的概率测度 <span class="math inline">\(\mathbb{P}\)</span> 是无穷乘积测度。</p><p>例如，一个样本点 <span class="math inline">\(\omega\)</span>可能是这样的 <span class="math display">\[\omega=\{J, S, I, O, J, I, T,T, S, Z, Z, Z,\ldots\}.\]</span> 即第一个落下的方块是 <span class="math inline">\(J\)</span>，第二个是 <span class="math inline">\(S\)</span>，第三个是 <span class="math inline">\(I\)</span>，等等。</p><p>一旦给定了 <span class="math inline">\(\omega\)</span>，游戏的结果将只依赖于玩家的操作。</p><p>现在我要告诉你，Wilson 算法背后是一个类似 Tetris的游戏，游戏的目标是获得一个生成树 <span class="math inline">\(T\)</span>。但这个游戏和 Tetris游戏有一个关键不同：它得到的 <span class="math inline">\(T\)</span>只依赖于系统的随机性，不依赖于玩家的操作。换句话说：对给定的 <span class="math inline">\(\omega\)</span>，要么玩家的任何操作都会得到同一个生成树；要么任何操作都不能。即<span class="math inline">\(T\)</span> 是由 <span class="math inline">\(\omega\)</span>完全决定的。于是我们有一个确定的映射 <span class="math inline">\(\phi (\omega ) =T\)</span>！根据 <a href="#algo-success" title="命题 1.1">命题1.1</a>, Wilson 算法以概率 1 成功得到一个生成树，所以 <span class="math inline">\(\phi\)</span> 对几乎处处的 <span class="math inline">\(\omega\)</span> 是有定义的！</p><h1 id="wilson-算法作为游戏策略">Wilson 算法作为游戏策略</h1><p>我们来玩一个叫做回路弹出 ( cycle popping )的游戏。我先介绍这个游戏背后的系统随机性 <span class="math inline">\((\Omega,\mathbb{P} )\)</span>。</p><div id="----------------omega--mathbb-p-------------" class="statement sta_________omega__mathbb_p_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">概率空间 <span class="math inline">\((\Omega,\mathbb{P} )\)</span> 的构造</span>.</span></p><ol type="1"><li>固定一个顶点 <span class="math inline">\(r\)</span>。对每个 <span class="math inline">\(v\ne r\)</span>，定义栈 <span class="math inline">\(S_v=\{S_{v,1},S_{v,2},\ldots\}\)</span>。<span class="math inline">\(S_v\)</span> 的长度是无穷，其元素 <span class="math inline">\(S_{v,i}\)</span> 都是来自 <span class="math inline">\(v\)</span>的邻居的均匀采样。所有栈元素都是独立的。顶点 <span class="math inline">\(r\)</span> 的栈是空栈：<span class="math inline">\(S_r=\emptyset\)</span>。</li><li>概率空间 <span class="math inline">\(\Omega\)</span> 是所有栈 <span class="math inline">\(\{S_v\mid v\ne r\}\)</span>的所有可能的状态组成的集合。这是一个无穷离散的概率空间，其上的测度 <span class="math inline">\(\mathbb{P}\)</span> 为乘积测度。</li></ol></div><p>为了方便，我们称 <span class="math inline">\(S_v\)</span> 的第 <span class="math inline">\(i\)</span> 个元素 <span class="math inline">\(S_{v,i}\)</span> 的颜色是 <span class="math inline">\(i\)</span>。</p><p>在任何时刻，这些栈 <span class="math inline">\(\{S_v,v\ner\}\)</span> 的栈顶元素都定义了一个有向图 <span class="math inline">\(\overrightarrow{G}_S\)</span>：在 <span class="math inline">\(\overrightarrow{G}_S\)</span> 中 <span class="math inline">\(v\rightarrow u\)</span> 当且仅当 <span class="math inline">\(u\)</span> 是 <span class="math inline">\(S_v\)</span> 的栈顶元素。每个 <span class="math inline">\(v\ne r\)</span> 的出度都恰好是 1，顶点 <span class="math inline">\(r\)</span> 的出度是 0。于是若 <span class="math inline">\(\overrightarrow{G}_S\)</span>不含回路的话它就是一个以 <span class="math inline">\(r\)</span>为根的生成树。</p><div id="------------------" class="statement sta_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">回路弹出游戏</span>.</span><span class="statement-spah"> </span>给定栈的一个状态 <span class="math inline">\(\omega\in\Omega\)</span>，<span class="math inline">\(\overrightarrow{G}_S\)</span> 是 <span class="math inline">\(\omega\)</span> 对应的栈顶图，若 <span class="math inline">\(\overrightarrow{G}_S\)</span>不含回路的话则它已经是一个生成树，游戏结束；否则设 <span class="math inline">\(C\)</span> 是 <span class="math inline">\(\overrightarrow{G}_S\)</span>中的一个回路，我们可以将其「弹出」：对每个 <span class="math inline">\(v\in C\)</span>，弹出 <span class="math inline">\(S_v\)</span> 的栈顶元素 ( 于是若当前 <span class="math inline">\(S_v\)</span> 的栈顶元素为 <span class="math inline">\(S_{v,i}\)</span>，则弹出 <span class="math inline">\(S_{v,i}\)</span> 以后栈顶元素变为 <span class="math inline">\(S_{v,i+1}\)</span> ) ，这样得到更新的 <span class="math inline">\(\overrightarrow{G}_S\)</span>。玩家每次可以任选<span class="math inline">\(\overrightarrow{G}_S\)</span>中的一个回路并将其弹出。如果玩家能够经过有限多次弹出操作后使得 <span class="math inline">\(\overrightarrow{G}_S\)</span> 中不含任何回路，即<span class="math inline">\(\overrightarrow{G}_S\)</span>是一个生成树，则玩家获胜。</p></div><p>在回路弹出游戏中，玩家能做的就是每次选择一个需要弹出的回路，别的什么也做不了。游戏开始之前，<span class="math inline">\(\overrightarrow{G}_S\)</span> 中所有顶点的颜色都是1，但是随着游戏的进行，<span class="math inline">\(\overrightarrow{G}_S\)</span>会变得「五颜六色」。一个回路中可以包含不同颜色的顶点。</p><div id="wilson-------------------------" class="statement sta_wilson_________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Wilson算法作为游戏策略</span>.</span><span class="statement-spah"></span>每次任选一个不属于 <span class="math inline">\(T\)</span> 的顶点<span class="math inline">\(v\)</span>，从 <span class="math inline">\(v\)</span> 出发按照 <span class="math inline">\(\overrightarrow{G}_S\)</span>的边的指引来搜索下一个要弹出的回路。</p></div><p>树 <span class="math inline">\(T\)</span>的作用是维护那些已经完全确定下来、必然属于最终生成树的那些边。这是因为，<span class="math inline">\(T\subset\overrightarrow{G}_S\)</span> 始终是一个以<span class="math inline">\(r\)</span> 为根节点的有向树，从 <span class="math inline">\(T\)</span> 中的任何顶点出发沿着 <span class="math inline">\(\overrightarrow{G}_S\)</span>的有向边都会走到根节点 <span class="math inline">\(r\)</span>。而 <span class="math inline">\(r\)</span> 是个死胡同 ( <span class="math inline">\(r\)</span> 的出度是 0 ) ，所以 <span class="math inline">\(T\)</span> 中的顶点不可能属于任何回路。</p><p>我们前面剧透过，回路弹出游戏的结果不依赖于玩家的操作。我们把这个事实的证明放在后面，先承认它是正确的，于是我们可以定义映射<span class="math inline">\(\phi\)</span>：</p><div id="-phi----------" class="statement sta__phi____ plain unnumbered"><p><span class="statement-heading"><span class="statement-label"><span class="math inline">\(\phi\)</span> 的构造</span>.</span><span class="statement-spah"> </span>设使用 Wilson 算法对 <span class="math inline">\(\omega\)</span> 执行操作以后得到的生成树为 <span class="math inline">\(T\)</span>，定义 <span class="math inline">\(\phi( \omega ) =T\)</span>。</p></div><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(T\)</span> 服从所有生成树组成的集合 <span class="math inline">\(\mathcal{T}\)</span> 上的均匀分布。</p></div><p>这个结论解释了为什么 Wilson 算法中的 <a href="#two-arbitrary">两个任意</a> 对最终结果是没有影响的。</p><p><strong>证明</strong>：我们来计算如下事件的概率：依次弹出回路 <span class="math inline">\(\mathcal{C}= ( C_1,\ldots,C_n )\)</span>后得到的生成树是 <span class="math inline">\(T\)</span>。注意 <span class="math inline">\(\mathcal{C}\)</span> 和 <span class="math inline">\(T\)</span>的顶点必然<strong>无缝隙</strong>地填满栈 <span class="math inline">\(\{S_v\}\)</span> 的上面的部分，所以这个概率就是<span class="math inline">\(\mathcal C\)</span> 和 <span class="math inline">\(T\)</span> 中的边各自指向正确位置的概率： <span class="math display">\[\mathbb{P} ( \mathcal{C},T ) =\prod_{e\in\mathcal{C}\cup T} p_e=\Phi ( T ) \cdot \Phi ( \mathcal{C} ).\]</span> 这里 <span class="math inline">\(\Phi ( \bullet )\)</span>返回集合 <span class="math inline">\(\bullet\)</span>中所有边的概率的乘积。</p><p>设 <span class="math inline">\(\mathcal{C}_T\)</span> 是所有可能得到<span class="math inline">\(T\)</span> 的那些 <span class="math inline">\(\mathcal{C}\)</span> 组成的集合，在上式两边对<span class="math inline">\(\mathcal{C}_T\)</span> 求和，则 <span class="math display">\[\mathbb{P} ( T ) =\left (\sum_{\mathcal{C}\in\mathcal{C}_T}\Phi ( \mathcal C ) \right ) \cdot\Phi( T ) .\]</span> 然而 <span class="math inline">\(\mathcal{C}_T\)</span>是一个与 <span class="math inline">\(T\)</span>无关的集合，这是因为在给定 <span class="math inline">\(\mathcal{C}\)</span> 后，任何生成树 <span class="math inline">\(T\)</span> 都有可能出现 ( 解释见后面 ) ，因此<span class="math display">\[\mathbb{P} ( T ) ={\rm const}\cdot \Phi ( T) .\]</span> 而 <span class="math inline">\(\Phi ( T ) =\prod\limits_{v\ne r} ( 1/d_v )\)</span> 是与 <span class="math inline">\(T\)</span> 无关的量，从而 <span class="math inline">\(\mathbb{P} ( T )\)</span> 是常数，这就证明了 <span class="math inline">\(\phi\)</span> 满足 <a href="#requirements" title="条件 3">条件 3</a> 。</p><p>为什么给定 <span class="math inline">\(\mathcal{C}\)</span> 以后任何<span class="math inline">\(T\)</span>都可能出现？打个比方，想象一个向弹夹里面压子弹的过程：把树 <span class="math inline">\(T\)</span> 放在栈顶，然后依次用 <span class="math inline">\(C_n,\ldots,C_1\)</span> 将 <span class="math inline">\(T\)</span> 往下压，得到一个栈的状态 <span class="math inline">\(\{S_v\}\)</span>，对这个状态执行回路弹出，显然依次弹出的就是<span class="math inline">\(C_1,\ldots,C_n\)</span>，最终得到的树是<span class="math inline">\(T\)</span>。这顺便也说明了 <span class="math inline">\(\phi\)</span> 是满射的。</p><p>现在 <span class="math inline">\(\phi\)</span> 满足前面提到的全部 <a href="#requirements" title="三个条件">三个条件</a> ，这就证明了 Wilson算法的正确性。</p><h1 id="游戏结果与策略无关">游戏结果与策略无关</h1><p>最后我们证明最关键的部分：Wilson算法的结果与每次选择弹出的回路无关。</p><p>假设有若干玩家分别玩回路弹出的游戏，每个人采取的策略是不同的。我们想知道，对给定的系统随机性<span class="math inline">\(\omega\)</span>，这些玩家都能获胜吗？他们最终得到的生成树一样吗？需要的操作次数相同吗？</p><p>答案是：不管这些玩家采取怎样的策略，只有两种可能的结果出现：</p><ol type="1"><li>所有人都不能获胜。</li><li>所有人都能获胜，而且每个人使用的操作次数也相同，最终得到的栈顶图<span class="math inline">\(\overrightarrow{G}_S\)</span>也相同。不仅如此，每个人弹出的回路组成的集合 <span class="math inline">\(\{C_1,\ldots,C_n\}\)</span>也都是相同的。注意这里的回路 <span class="math inline">\(C_i\)</span>是带有颜色标记的，两个回路相同不仅要求包含的顶点相同，也要求对应顶点的颜色相同。仅仅弹出的顺序可能不同。</li></ol><p>我们只要证明如下的结论即可：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>对任一栈状态 <span class="math inline">\(\omega\in\Omega\)</span>，若玩家 <span class="math inline">\(A\)</span> 可以经过 <span class="math inline">\(n\)</span> 次操作后获胜，其弹出的回路依次为 <span class="math inline">\(C_1,\ldots,C_n\)</span>，则不论玩家 <span class="math inline">\(B\)</span> 的策略如何，其必然也经过 <span class="math inline">\(n\)</span> 次操作后获胜，其弹出的回路集合 <span class="math inline">\(\{D_1,\ldots,D_n\}\)</span> 与 <span class="math inline">\(\{C_1,\ldots,C_n\}\)</span> 是相同的，即适当重排<span class="math inline">\(\{D_1,\ldots,D_n\}\)</span> 后有 <span class="math inline">\(D_i=C_i\)</span>。</p></div><p><strong>证明</strong>：对玩家 <span class="math inline">\(A\)</span>的操作次数 <span class="math inline">\(n\)</span> 归纳。<span class="math inline">\(n=0\)</span> 时结论显然成立 ( 双方均无任何操作 )，下面设 <span class="math inline">\(n\geq1\)</span> 且结论对所有小于<span class="math inline">\(n\)</span> 的情形成立。</p><p>设 <span class="math inline">\(B\)</span> 第一次弹出的回路是 <span class="math inline">\(D_1\)</span>，如果 <span class="math inline">\(C_1=D_1\)</span> 则这一步操作后 <span class="math inline">\(A,B\)</span> 到达了相同的状态，而 <span class="math inline">\(A\)</span> 可以继续经过 <span class="math inline">\(n-1\)</span> 次操作后获胜，于是根据归纳假设 <span class="math inline">\(B\)</span> 也一定经过 <span class="math inline">\(n-1\)</span> 次操作获胜且后续操作 <span class="math inline">\(\{D_2,\ldots,D_n\}=\{C_2,\ldots,C_n\}\)</span>。</p><p>如果 <span class="math inline">\(C_1\ne D_1\)</span>，我们断言 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(D_1\)</span> 没有公共的顶点。否则若 <span class="math inline">\(v\in C_1\cap D_1\)</span>，由于第一次操作时 <span class="math inline">\(C_1,D_1\)</span> 属于同一个栈顶图中，以及 <span class="math inline">\(v\)</span> 的出度是 1，所以 <span class="math inline">\(v\)</span> 在 <span class="math inline">\(G_S\)</span> 中的后继 <span class="math inline">\(v_1\)</span> 也同时属于 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(D_1\)</span>，进而 <span class="math inline">\(v_1\)</span> 的后继 <span class="math inline">\(v_2\)</span> 也是如此，这样一直下去回到 <span class="math inline">\(v\)</span> 就会有 <span class="math inline">\(C_1=D_1\)</span>，矛盾。</p><p>既然 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(D_1\)</span> 没有相同顶点，那说明不论先弹 <span class="math inline">\(C_1\)</span> 后弹<span class="math inline">\(D_1\)</span>，或是先弹 <span class="math inline">\(D_1\)</span> 后弹 <span class="math inline">\(C_1\)</span>，得到的栈顶图是一样的。</p><p>接下来的论述是钻石引理 ( diamond lemma )的典型操作：我们引入两个新玩家 <span class="math inline">\(A'\)</span> 和 <span class="math inline">\(B'\)</span>：<span class="math inline">\(A'\)</span> 的前两步操作是先弹出 <span class="math inline">\(C_1\)</span> 后弹出 <span class="math inline">\(D_1\)</span>，<span class="math inline">\(B'\)</span> 的前两步操作是先弹出 <span class="math inline">\(D_1\)</span> 后弹出 <span class="math inline">\(C_1\)</span>。</p><ol type="1"><li><span class="math inline">\(A\)</span> 和 <span class="math inline">\(A'\)</span> 第一步操作相同，因此由归纳假设<span class="math inline">\(A'\)</span> 可以经过 <span class="math inline">\(n-2\)</span> 步后获胜；</li><li><span class="math inline">\(A'\)</span> 和 <span class="math inline">\(B'\)</span> 前两步操作后到达相同的状态，而已知<span class="math inline">\(A'\)</span> 可以在 <span class="math inline">\(n-2\)</span> 步后获胜，所以由归纳假设 <span class="math inline">\(B'\)</span> 也可以在 <span class="math inline">\(n-2\)</span> 步后获胜；</li><li><span class="math inline">\(B'\)</span> 和 <span class="math inline">\(B\)</span> 第一步操作相同，而已知 <span class="math inline">\(B'\)</span> 可以在 <span class="math inline">\(n-1\)</span> 步后获胜，所以由归纳假设 <span class="math inline">\(B\)</span> 也可以在 <span class="math inline">\(n-1\)</span> 步后获胜。</li></ol><p><span class="math inline">\(A,B,A',B'\)</span>弹出的回路集合相同是显然的。</p><p>至此我们就说明了 <span class="math inline">\(\phi\)</span>的定义是合理的，它是一个确定的映射。</p><p>对没有接触过钻石引理的读者，我这个论述比 Wilson的原证明的论述要繁琐，但是这个角度更本质地揭示了为什么游戏的结果不依赖于具体的策略。</p>]]></content>
      
      
      <categories>
          
          <category> 完美采样 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>相亲问题与倒向归纳法</title>
      <link href="/optimal-stopping-and-backward-induction/"/>
      <url>/optimal-stopping-and-backward-induction/</url>
      
        <content type="html"><![CDATA[<div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"></span>假设你是一位大龄单身男士，年纪不小，但仍心怀浪漫。你准备参加 100场相亲 （别介意具体数字）。你打算依次与每个女士 <span class="math inline">\(i\)</span> 约会，然后根据印象给她打一个分数 <span class="math inline">\(X_i\)</span>，<span class="math inline">\(X_i\)</span> 的值介于 <span class="math inline">\([0,1]\)</span> 之间。如果你对女士 <span class="math inline">\(i\)</span>很满意，那么就和她结婚，否则就放弃她，参加下一场相亲，当然拒绝了人家可就没有回头的机会了。如果你拒绝了前99 位女士，那么不论第 100次相亲结果如何你都只能和最后这位女士结婚。在相亲之前，你对这些女士的情况一无所知，所以姑且假定她们的分数<span class="math inline">\(X_i\)</span> 都是 <span class="math inline">\([0,1]\)</span>上均匀分布的独立的随机变量。问题是：应该采取怎样的相亲策略，才能娶到你最中意的女士？</p></div><span id="more"></span><p>再费点笔墨解释下。每次相亲结束以后，你都面临一个选择：要么和当前的女士结婚，要么继续见下一位女士，这依赖于你之前相亲的结果：如果你挑挑拣拣到了90号女士还拿不定主意，最后发现「糟了，我快要变剩男了！」，那很可能接下来你就会放低择偶标准，遇到一个还凑合的就赶紧结婚了，哪怕她可能比你之前拒绝的许多女士分数还低。当然也不排除你对第一位女士就一见钟情的可能，因此你最终选择的女士的编号<span class="math inline">\(\tau\)</span>是一个随机变量，你要做的就是让你的未来太太的期望分数 <span class="math inline">\(\mathbb{E}X_\tau\)</span> 尽可能的高。</p><p>那么应该采取怎样的策略为好呢？就像买东西讨价还价时总有一个心理价位一样，似乎可以先设定一个心理的期望值，如果遇到的女士的分数大于等于这个值，那就和她结婚；否则就继续下一位女士。这个思路很合理，但是问题是，期望值应该设定为多少呢？</p><p>在概率论里面我们学过如下关于顺序统计量的经典结论：设 <span class="math inline">\(X_1,\cdots,X_N\)</span> 是 <span class="math inline">\([0,1]\)</span> 上独立同分布的均匀随机变量，则<span class="math inline">\(Y=\max_{1\leq i\leq N}X_i\)</span> 的期望是<span class="math inline">\(\frac{N}{N+1}\)</span>。所以如果你把 100次相亲全部进行完，得分最高的女士的期望值理论上应该是 <span class="math inline">\(\frac{100}{101}\)</span>，于是你应该把心理门槛设置在<span class="math inline">\(\frac{100}{101}\)</span>，是这样吗？</p><p>答案是NO！首先门槛值应该是一个随着相亲的进行而逐渐降低的数列，这才符合实际的情形：如果前面太挑剔，为了不当剩男你后面的标准就会放低。其次我们会用倒向归纳法计算出，最优策略下初始的门槛值并不是最中意的女士的期望值<span class="math inline">\(\frac{100}{101}\)</span>，实际上它更接近于得分第二高的女士的期望值<span class="math inline">\(\frac{99}{101}\)</span>。正如梅艳芳在《似是故人来》中唱的那样：「但凡未得到，但凡是过去，总是最登对」— 最好的那个永远是你得不到的那个。</p><h1 id="倒向归纳法">倒向归纳法</h1><p>相亲问题是应用倒向归纳法的一个典型例子。</p><p>我们从最后的情形开始分析，假设只剩一位女士可选，那么你只能去和她结婚，而她的期望值是1/2，我们记作 <span class="math inline">\(a_1=1/2\)</span>。</p><p>假设还剩两位女士可选呢？这种情况下应该先和其中一个相亲，如果她的分数大于等于1/2，那就应该和她结婚 （后者的期望只有 1/2，很可能不如她），而小于 1/2的话则去和第二位女士相亲 （后者的期望是1/2，所以我没道理现在娶一个分数小于 1/2 的）。而第一位女士分数大于等于1/2 的概率是 1/2，在大于等于 1/2 的条件下她的分数服从 <span class="math inline">\([1/2,1]\)</span> 上的均匀分布，期望值是3/4；第二位女士的期望分数就是 1/2。所以你以 1/2 的概率娶到一个期望值为3/4 的女士，以 1/2 的概率娶到一个期望值为 1/2的女士。因此有两位女士可选时这个策略的期望分数为 <span class="math display">\[a_2=\frac{1}{2}\cdot\frac{3}{4}+\frac{1}{2}\cdot\frac{1}{2}=\frac{5}{8}.\]</span></p><p>一般地，假设还剩下 <span class="math inline">\(i\)</span>位女士的时候你的心理期望值是 <span class="math inline">\(a_i\)</span>，我们来推导 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{i+1}\)</span>之间的递推关系：首先和其中一位女士相亲，如果她的分数大于等于 <span class="math inline">\(a_i\)</span> 那么就和她结婚，否则就拒绝她（因为后面 <span class="math inline">\(i\)</span> 个人的心理期望是 <span class="math inline">\(a_i\)</span>，我没道理现在娶一个分数小于 <span class="math inline">\(a_i\)</span> 的）。前一种情形的期望是 <span class="math inline">\(\frac{1+a_i}{2}\)</span> 但是发生的概率是 <span class="math inline">\(1-a_i\)</span>，后一种情形的期望是 <span class="math inline">\(a_i\)</span> 发生的概率也是 <span class="math inline">\(a_i\)</span>，因此 <span class="math display">\[a_{i+1}=(1-a_i)\left(\frac{1+a_i}{2}\right)+a_i\cdota_i=\frac{1+a_i^2}{2}.\]</span> 结合初值 <span class="math inline">\(a_1=\frac{1}{2}\)</span>就可以算出整个序列来，因此我们的相亲策略应该是：</p><div class="statement simple plain unnumbered"><p>假设当前还剩 <span class="math inline">\(i\)</span>位女士。就把心里期望设定在 <span class="math inline">\(a_i\)</span>，然后进行一次相亲。如果相亲结果大于等于<span class="math inline">\(a_i\)</span>，那就和这位女士结婚；否则就把心里期望降低为<span class="math inline">\(a_{i-1}\)</span>，然后继续去见下一位女士。这里序列<span class="math inline">\(\{a_i\}\)</span> 由 <span class="math inline">\(a_1=1/2\)</span>，<span class="math inline">\(a_{i+1}=\frac{1+a_i^2}{2}\)</span> 给出。</p></div><p>在这个策略下，你最终娶到的女士得分期望是 <span class="math inline">\(a_{100}\)</span>。</p><p>序列 <span class="math inline">\((a_n)_{n\geq1}\)</span> 是所谓的QuadraticMap，它的通项公式是求不出来的，只能用计算机来算。不过可以用归纳法证明<span class="math inline">\(\frac{N-1}{N+1}&lt;a_{N}&lt;\frac{N-0.5}{N+1}\)</span>，即<span class="math inline">\(a_N\)</span> 的值更接近于次优女士的期望值<span class="math inline">\(\frac{N-1}{N+1}\)</span>。当 <span class="math inline">\(N=100\)</span> 时，<span class="math inline">\(a_{100}\approx0.981\)</span>，<span class="math inline">\(\frac{N-1}{N+1}\approx 0.98\)</span> 而 <span class="math inline">\(\frac{N}{N+1}=100/101\approx 0.99\)</span>，可见<span class="math inline">\(a_{100}\)</span> 与 <span class="math inline">\(\frac{N-1}{N+1}\)</span>更接近。这印证了之前说过的：和你结婚的往往不是你最中意的那个。</p><p>请注意，虽然我们已经设计出了一个不错的策略，但这个策略到底是不是最优的呢？我们还没有严格证明。而且就算这个策略是最优的，是否只有这一种最优策略呢？没准还有其它最优策略能让你更省时省心地娶到好太太呢！要严格的解释这些，就要用到鞅的理论。</p><h1 id="翻译为鞅的语言">翻译为鞅的语言</h1><p>用鞅的语言重新表述上面的问题，会给人一种画风突变的感觉，看起来非常晦涩，不像是在说人话：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>设 <span class="math inline">\(N\)</span>是一个给定的正整数，<span class="math inline">\(\{\mathcal{F}_n\}_{n=0}^N\)</span>是某概率空间上的递增的 <span class="math inline">\(\sigma\)</span>-域流，<span class="math inline">\(\{X_n\}_{n=0}^N\)</span>是一列可积的随机变量且 <span class="math inline">\(X_k\in\mathcal{F}_k\)</span>。设 <span class="math inline">\(\mathcal{M}\)</span> 是所有满足 <span class="math inline">\(0\leq\tau\leq N\)</span> 的停时 <span class="math inline">\(\tau\)</span> 组成的集合。我们想求出值函数 <span class="math display">\[V= \sup_{\tau\in\mathcal{M}}\mathbb{E}X_\tau\]</span> 以及使得这个最大值取到的停时 <span class="math inline">\(\tau\)</span>。</p></div><p>这里下标改成了 从 0 开始，以符合大多数文献的习惯。<span class="math inline">\(X_0=0\)</span>，<span class="math inline">\(\mathcal{F}_0=\{\emptyset,\Omega\}\)</span>是平凡的，表示在 0 时刻，即相亲开始之前，你对未来太太“一无所知”。<span class="math inline">\(\mathcal{F}_n=\sigma(X_0,\ldots,X_n)\)</span> 是前<span class="math inline">\(n\)</span> 位女士得分生成的 <span class="math inline">\(\sigma\)</span>- 域，它包含了所有前 <span class="math inline">\(n\)</span>次相亲后可能知道的信息。你的一个相亲策略对应一个停时 <span class="math inline">\(\tau\)</span>，你所有可能的策略由集合 <span class="math inline">\(\mathcal{M}\)</span> 描述。</p><p>定义 <span class="math inline">\(\{X_n\}\)</span> 的 <strong>Snell包络</strong>为 <span class="math display">\[S_n=\begin{cases}X_N&amp;n=N,\\\max\{X_n,\,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}&amp;n=N-1,\ldots,0.\end{cases}\]</span> 这里的 <span class="math inline">\(S_n\)</span> 是从 <span class="math inline">\(N\)</span> 开始倒向递归定义的。注意 <span class="math inline">\(S_n\)</span> 关于 <span class="math inline">\(\mathcal{F}_n\)</span> 可测。</p><p><span class="math inline">\(S_n\)</span> 的直观意义是：在时刻 <span class="math inline">\(n\)</span>，比较当前女士的分数 <span class="math inline">\(X_n\)</span>，和 <span class="math inline">\(n+1\)</span> 时刻对后面所有女士的最佳得分估计<span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>，二者取最大值<span class="math inline">\(\max\{X_n,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}\)</span>即为 <span class="math inline">\(n\)</span>时刻对未来太太最佳分数的估计。注意这里 <span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>要取条件期望，因为一般情况下 <span class="math inline">\(\{X_n\}\)</span>之间不是独立的，从而对未来最佳收益的估计依赖于历史信息。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>在相亲问题中，<span class="math inline">\(\{X_n\}\)</span>是独立的随机变量序列，于是 <span class="math inline">\(S_{n+1}\)</span>与 <span class="math inline">\(\mathcal{F}_n\)</span> 独立（你可以倒着从<span class="math inline">\(S_N\)</span> 开始验证 <span class="math inline">\(S_{n+1}\)</span> 完全由 <span class="math inline">\(X_{n+1},\ldots,X_N\)</span> 决定），从而 <span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]=\mathbb{E}S_{n+1}\)</span>，所以</p><p><span class="math display">\[S_n=\begin{cases}X_N&amp;n=N,\\\max\{X_n,\,\mathbb{E}S_{n+1}\}&amp;n=N-1,\ldots,0.\end{cases}\]</span></p><p>记事件 <span class="math inline">\(A_n=\{X_n&gt;\mathbb{E}S_{n+1}\}\)</span>，则<span class="math inline">\(\mathbb{P}(A_n)=1-\mathbb{E}S_{n+1}\)</span>。于是序列<span class="math inline">\(\{\mathbb{E}S_n\}\)</span> 满足倒向递推关系<span class="math display">\[\mathbb{E}S_n=\mathbb{P}(A_n)\frac{1+\mathbb{E}S_{n+1}}{2} +\mathbb{E}S_{n+1}\cdot(1-\mathbb{P}(A_n))=\frac{1+(\mathbb{E}S_{n+1})^2}{2}.\]</span> 这正是我们前一节中推导的序列 <span class="math inline">\((a_n)_{n\geq1}\)</span>的递推关系，只是相差一个下标的翻转。</p></div><p>设 <span class="math inline">\(\tau=\inf\,\{n:\,S_n=X_n\}\)</span>，则 <span class="math inline">\(\tau\)</span>是停时。由于 <span class="math inline">\(S_N=X_N\)</span>，因此 <span class="math inline">\(0\leq\tau\leq N\)</span>。<span class="math inline">\(\tau\)</span> 就是我们采取的相亲策略：在 <span class="math inline">\(\tau\)</span> 时刻，由于这时 <span class="math inline">\(\max\{X_n,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}=X_n\)</span>，即<span class="math inline">\(n\)</span> 号女士的分数 <span class="math inline">\(X_n\)</span>大于等于后面继续相亲所能获得的最佳收益 <span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>，剩下的相亲就不必再进行了。</p><p>到目前为止，我们已经把相亲问题完整地翻译成了鞅的语言。我们来证明<span class="math inline">\(\tau\)</span>确实是最优策略。为此我们需要做一些准备：</p><div id="super" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\{S_n\}\)</span> 是控制 <span class="math inline">\(\{X_n\}\)</span> 的最小上鞅。</p></div><p><strong>证明</strong>：由 <span class="math inline">\(S_n=\max\{X_n,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}\)</span>直接可见 <span class="math inline">\(S_n\geq X_n\)</span> 并且 <span class="math inline">\(\{S_n\}\)</span> 是上鞅。设 <span class="math inline">\(\{Y_n\}\)</span> 是任意满足 <span class="math inline">\(Y_n\geq X_n\)</span> 的上鞅序列，我们要证明必有<span class="math inline">\(Y_n\geq S_n\)</span>。这只要从最后一项 <span class="math inline">\(n=N\)</span> 开始逐项验证即可。由定义 <span class="math inline">\(Y_N\geq X_N=S_N\)</span>，这一项没问题。假设 <span class="math inline">\(Y_n\geq S_n\)</span>，两边对 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 取条件期望可得 <span class="math display">\[Y_{n-1}\geq \mathbb{E}[Y_n|\mathcal{F}_{n-1}]\geq \mathbb{E}[S_n|\mathcal{F}_{n-1}].\]</span>其中第一个不等号是根据上鞅的定义，第二个不等号是根据条件期望的单调性。再结合<span class="math inline">\(Y_{n-1}\geq X_{n-1}\)</span> 可得 <span class="math inline">\(Y_{n-1}\geq\max\{X_{n-1},\mathbb{E}[S_n|\mathcal{F}_{n-1}]\}=S_{n-1}\)</span>，所以<span class="math inline">\(n-1\)</span>项也没有问题。这样倒着向前递推即得结论成立。<span class="math inline">\(\blacksquare\)</span></p><div id="martingale" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\{S_{n\wedge\tau}\}\)</span> 是一个鞅。</p></div><p><strong>证明</strong>：<span class="math display">\[S_{(n+1)\wedge\tau}-S_{n\wedge\tau}=1_{\{\tau&gt;n\}}(S_{n+1}-S_n).\]</span></p><p>对上式右边求条件期望： <span class="math display">\[\mathbb{E}[1_{\{\tau&gt;n\}}(S_{n+1}-S_n)|\mathcal{F}_n]=1_{\{\tau&gt;n\}}\mathbb{E}[(S_{n+1}-S_n)|\mathcal{F}_n]=0.\]</span></p><p>这是因为如果 <span class="math inline">\(\tau&gt;n\)</span>的话那么由 <span class="math inline">\(\tau\)</span> 的定义 <span class="math inline">\(S_n=\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="expectation-tau" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathbb{E}X_\tau=\mathbb{E}S_0\)</span>。</p></div><p><strong>证明</strong>：注意 <span class="math inline">\(X_\tau=S_\tau\)</span>，利用 <span class="math inline">\(0\leq\tau\leq N\)</span> 和鞅性质即可： <span class="math display">\[\mathbb{E}X_\tau=\mathbb{E}S_\tau=\mathbb{E}S_{\tau\wedgeN}=\mathbb{E}S_{\tau\wedge0}=\mathbb{E}S_0.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div id="optimal" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{M}\)</span> 是所有满足 <span class="math inline">\(0\leq T\leq N\)</span> 的停时 <span class="math inline">\(T\)</span> 组成的集合，则 <span class="math inline">\(\tau\)</span> 是其中最优的： <span class="math display">\[\mathbb{E}S_0=\mathbb{E}X_\tau=\sup_{T\in\mathcal{M}}\mathbb{E}X_T.\]</span></p></div><p><strong>证明</strong>：设 <span class="math inline">\(T\)</span>是任意停时，我们要证明 <span class="math inline">\(\mathbb{E}X_\tau\geq\mathbb{E}X_T\)</span>。为此只要注意到 <span class="math display">\[\mathbb{E}X_\tau =\mathbb{E}S_0\geq \mathbb{E}S_T\geq\mathbb{E}X_T.\]</span> 第一个等号是根据 <a href="#expectation-tau" title="推论 2.3">推论 2.3</a>，中间的不等号是因为 <span class="math inline">\(\{S_n\}\)</span> 是上鞅，所以对任何停时 <span class="math inline">\(T\)</span> 都有 <span class="math inline">\(\mathbb{E}S_T\leq\mathbb{E}S_0\)</span>。最后的不等号是因为 <span class="math inline">\(S_n\)</span> 控制 <span class="math inline">\(X_n\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>至此我们就从数学上严格论证了前面的相亲策略确实是最优的。</p><p>回顾上面的分析，可以发现我们实际上使用了 <span class="math inline">\(\tau\)</span> 的两个性质：<span class="math inline">\(S_\tau=X_\tau\)</span> 和 <span class="math inline">\(\{S_{n\wedge\tau}\}\)</span>是鞅。这两个性质保证了 <span class="math inline">\(\tau\)</span>是最优策略。那这是不是说明还有其它最优的策略呢？</p><div id="suff-nece" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.5</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\nu\in\mathcal{M}\)</span>是最优停时的充要条件是：</p><ol type="1"><li><span class="math inline">\(S_\nu=X_\nu\)</span>。</li><li><span class="math inline">\(\{S_{n\wedge\nu}\}\)</span> 是鞅。</li></ol></div><p><a href="#suff-nece" title="定理 2.5">定理 2.5</a>告诉我们，前面采用的相亲策略是所有最优策略中时间成本最低的：即若 <span class="math inline">\(\nu\)</span> 是任意最优停时，则 <span class="math inline">\(\tau\leq\nu\)</span> （回顾一下 <span class="math inline">\(\tau\)</span> 的定义）。</p><p>我们还可以给出最优策略中最大的一个来：</p><div id="largest" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.6</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(S_n=M_n-A_n\)</span> 是 Snell 包络 <span class="math inline">\(\{S_n\}\)</span> 的 Doob-Meyer 分解，其中 <span class="math inline">\(\{M_n\}\)</span> 是鞅，<span class="math inline">\(A_n\)</span> 是可料递增过程，由 <span class="math display">\[A_n=\sum_{k=1}^n(S_{k-1}-\mathbb{E}[S_k|\mathcal{F}_{k-1}]) \]</span> 给出。定义</p><p><span class="math display">\[\tau_\max = \begin{cases}N &amp; A_N=0,\\\min\{n\geq0 \mid A_{n+1}&gt;0\} &amp; A_N&gt;0.\end{cases}\]</span></p><p>则 <span class="math inline">\(\tau_\max\)</span>是所有最优停时中最大的。</p></div><p>这个策略在现实很有用，它是以最优方式行使美式期权的最大停时。</p><p><a href="#suff-nece" title="定理 2.5">定理 2.5</a> 和 <a href="#largest" title="定理 2.6">定理 2.6</a>的证明都不难，这里就省略了。读者可以参考 <span class="citation" data-cites="RiskNeutralValuation">(<a href="#ref-RiskNeutralValuation" role="doc-biblioref">Bingham and Kiesel 2004, sec. 3.6</a>)</span>。</p><p>我猜某些读者可能会对 <span class="math inline">\(\tau_\max\)</span>对应的相亲策略感兴趣，因为这个策略有点渣男：它会在保证娶到最优女士的前提下和尽可能多的女士相亲。不过在<span class="math inline">\(\{X_n\}\)</span>是独立随机变量序列的情形，你还是死了这份心吧。因为这时 <span class="math display">\[A_n=\sum_{k=1}^n(S_{k-1}-\mathbb{E}S_k)=\sum_{k=1}^n\max\{X_{k-1}-\mathbb{E}S_k,0\}.\]</span>所以使得 <span class="math inline">\(A_{n+1}&gt;0\)</span> 成立的最小<span class="math inline">\(n\)</span> 正是使得 <span class="math inline">\(X_n&gt;\mathbb{E}S_{n+1}\)</span> 成立的最小 <span class="math inline">\(n\)</span>，即使得 <span class="math inline">\(X_n=S_n\)</span> 成立的最小 <span class="math inline">\(n\)</span>。这不就是前面见好就收的策略 <span class="math inline">\(\tau\)</span> 嘛！换句话说，在 <span class="math inline">\(\{X_n\}\)</span>是独立随机变量序列的情形，只有一种最优相亲策略！</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-RiskNeutralValuation" class="csl-entry" role="listitem">Bingham, N. H., and Rüdiger Kiesel. 2004. <em>Risk-Neutral Valuation :Pricing and Hedging of Financial Derivatives / n.h. Bingham and r.Kiesel.</em> Second edition. Springer Finance. London: Springer.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洛奇绵羊问题</title>
      <link href="/mabinogion-sheep-problem/"/>
      <url>/mabinogion-sheep-problem/</url>
      
        <content type="html"><![CDATA[<figure><img src="/images/midjourney/mabinogion.png" class="fig" width="350" alt="感谢 MidJourney，这下更有画面感了！"><figcaption aria-hidden="true">感谢MidJourney，这下更有画面感了！</figcaption></figure><p>今天的问题源自中世纪威尔士人的故事集《Mabinogion》中的一段：</p><blockquote><p>一个男孩来到了一个美丽的山谷，有一条小河在谷中流淌。他看到河一边的草地上有一群黑绵羊，另一边的草地上有一群白绵羊。羊群被施以一种魔法：每个时刻都恰有一只绵羊发出咩咩的叫声。如果发出叫声的是白绵羊，就会有一只黑绵羊趟过小河跑过来并且变成白绵羊；如果发出叫声的是黑绵羊，则会有一只白绵羊趟过小河跑过去并且变成黑绵羊。每个时刻发出叫声的绵羊是完全随机的，整个过程没有绵羊出生或者死亡，一直持续到所有绵羊都变成同一种颜色为止。</p></blockquote><p>问题是这样的：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>如果男孩可以选择在初始时刻 <span class="math inline">\(0\)</span>，或者是每个魔法时刻 <span class="math inline">\(1,2,\ldots\)</span>结束后将任意数量的白绵羊赶出山谷，那么为了最终得到尽可能多的黑绵羊，他应该采取怎样的策略？</p></div><span id="more"></span><p>洛奇绵羊问题出自 <span class="citation" data-cites="Williams1991">(<a href="#ref-Williams1991" role="doc-biblioref">Williams1991</a>)</span>，是一个很有趣的问题。这种在随机的环境中施加一个控制的力，以最大化期望收益的问题属于随机控制的范畴。</p><p>我们首先说明不论男孩采取怎样的策略，最终羊群都会以概率 1全部变成同一种颜色。</p><p>设 <span class="math inline">\(\Omega=\{(w,b)\in\mathbb{Z}_{\geq0}\times\mathbb{Z}_{\geq0}\}\)</span>是羊群所有可能的状态组成的集合，其中 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span>分别表示白绵羊和黑绵羊的数目。男孩采取的一个策略 <span class="math inline">\(S\)</span> 就是从一个状态 <span class="math inline">\((w,b)\)</span> 移动到另一个状态 <span class="math inline">\((w',b')\)</span> 的规则：根据当前 <span class="math inline">\((w,b)\)</span> 的值，男孩决定到底是按兵不动（不做任何干预），还是赶走 <span class="math inline">\(c\)</span>只白绵羊，把状态 <span class="math inline">\((w,b)\)</span> 变成状态<span class="math inline">\((w-c,b)\)</span>，这里 <span class="math inline">\(0&lt;c\leq w\)</span>是一个正整数。如果男孩始终不做任何干预的话，那么羊群状态将始终保持在线段<span class="math display">\[\{ (x,y)\mid x\geq0, y\geq0,x+y=w+b\}\]</span> 上，这是一个互通的 Markov 链，因此以概率 1撞到吸收状态 <span class="math inline">\((0,w+b)\)</span> 或 <span class="math inline">\((w+b,0)\)</span>，即最终变成同一种颜色。如果男孩在某个时刻移走了<span class="math inline">\(c\)</span>只白绵羊，那么系统将会被强制转移到线段 <span class="math display">\[\{(x,y)\mid x\geq0, y\geq0, x+y=w+b-c\}\]</span>上，如此下去。由于男孩只能进行有限次移走绵羊的操作，可见不论男孩策略如何，羊群总是会最终变成同色的。</p><p>对任何策略 <span class="math inline">\(S\)</span>，我们用 <span class="math inline">\(V_S(w,b)\)</span> 表示从 <span class="math inline">\((w,b)\)</span> 状态出发，在策略 <span class="math inline">\(S\)</span> 下最终得到的黑绵羊数量的期望值。这里<span class="math inline">\(V_S\)</span> 是一个由 <span class="math inline">\(S\)</span> 决定的确定的函数，它不包含随机性。<span class="math inline">\(V_S\)</span> 叫做策略 <span class="math inline">\(S\)</span> 的值函数。显然 <span class="math inline">\(V_S\)</span> 总是满足边界条件 <span class="math display">\[V_S(0,b)=b,\quadV_S(w,0)=0\label{eq:boundary}\tag{$\ast$}.\]</span></p><p>假设我们能够找到这样一个策略 <span class="math inline">\(A\)</span>，它的值函数 <span class="math inline">\(V_A\)</span> 有如下性质，那么它就是最佳策略：</p><blockquote><p><strong>最优策略的充分条件</strong>：如果策略 <span class="math inline">\(A\)</span> 的值函数 <span class="math inline">\(V_A\)</span> 满足如下条件：对任何初始状态 <span class="math inline">\((w,b)\)</span> 和任何的策略 <span class="math inline">\(S\)</span>，设羊群在策略 <span class="math inline">\(S\)</span> 下第 <span class="math inline">\(n\)</span> 个魔法时刻结束后的状态为 <span class="math inline">\((W_n,B_n)\)</span>，序列 <span class="math inline">\(\{V_A(W_n,B_n),n=0,1,\ldots\}\)</span>是上鞅，则策略 <span class="math inline">\(A\)</span> 就是最优的。</p></blockquote><p>注意这里是把任一策略 <span class="math inline">\(S\)</span>下的状态序列 <span class="math inline">\((W_n, B_n)\)</span> 代入策略<span class="math inline">\(A\)</span> 的值函数中。</p><p>证明非常简单：对任何策略 <span class="math inline">\(S\)</span>，由于其吸收状态 <span class="math inline">\((W_\infty,B_\infty)\)</span> 中必有一个分量是0，从而由值函数边界条件 <span class="math inline">\((\ref{eq:boundary})\)</span> 有 <span class="math inline">\(B_\infty=V_A(W_\infty,B_\infty)\)</span>，所以<span class="math display">\[\mathbb{E}[B_\infty]=\mathbb{E}[V_A(W_\infty,B_\infty)]\leq\mathbb{E}[V_A(w,b)]=V_A(w,b).\]</span> 其中最后一个等号是因为 <span class="math inline">\(V_A(w,b)\)</span>是一个常数，常数的期望等于自身。</p><p>Williams 直接「猜出」了策略 <span class="math inline">\(A\)</span>：</p><blockquote><p><strong>策略 <span class="math inline">\(A\)</span></strong>：如果当前黑绵羊的数量多于白绵羊，则什么也不做；否则就把白绵羊的数量变为黑绵羊的数量减1。</p></blockquote><p>显然 <span class="math inline">\(V_A\)</span> 有如下性质：</p><div id="recurrence" class="statement sta_v_a______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label"><span class="math inline">\(V_A\)</span> 的递推关系</span>.</span></p><ol type="1"><li>边界条件 <span class="math inline">\(V_A(0,b)=b\)</span>，<span class="math inline">\(V_A(w,0)=0\)</span>。</li><li><span class="math inline">\(V_A(w,b)=V_A(w-1,b), w\geqb&gt;0\)</span>。</li><li><span class="math inline">\(V_A(w,b)=\frac{w}{w+b}V_A(w+1,b-1)+\frac{b}{w+b}V_A(w-1,b+1)\)</span>,<span class="math inline">\(b&gt;w&gt;0\)</span>。</li></ol></div><p><span class="math inline">\(V_A\)</span> 由边界条件 1 和递推关系 2, 3完全决定。</p><p>从定义上看，关系 2 只在一半的区域上成立，而关系 3则在另一半的区域上成立。但是花费一番功夫，我们其实可以证明它们各自的「弱形式」在整个区域上都是对的：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>在区域 <span class="math inline">\(\Omega\)</span> 上，<span class="math inline">\(V_A\)</span> 函数满足如下的不等式：</p><ol start="4" type="1"><li><span class="math inline">\(V_A(w,b)\geq V_A(w-1,b),w&gt;0\)</span>。</li><li><span class="math inline">\(V_A(w,b)\geq\frac{w}{w+b}V_A(w+1,b-1)+\frac{b}{w+b}V_A(w-1,b+1),w&gt;0,b&gt;0\)</span>。</li></ol></div><p>4 表明如果男孩执行移走白绵羊的操作，则他得到的黑绵羊的期望会下降； 5表明如果男孩不执行操作，而是让系统自发改变状态的话，最终得到的黑绵羊的期望仍然会下降。总之无论男孩策略如何，<span class="math inline">\(\{ V_A(W_n,B_n)\}\)</span> 总是一个上鞅！因此策略<span class="math inline">\(A\)</span> 确实是最优的。</p><p>引理的证明是纯粹的分析，过程比较繁琐，我把它留给 Williams 的教材第15.3 节。写出 <span class="math inline">\(V(w,b)\)</span>的显式表达式来是很难的，Williams 证明了 <span class="math display">\[\lim_{k\to\infty}V(k,k)-(2k+\frac{\pi}{4}-\sqrt{\pik})=0.\label{eq:vkk}\tag{$\ast\ast$}\]</span> 因此如果开始有黑、白绵羊各10000 只，则策略 <span class="math inline">\(A\)</span>下黑绵羊的期望数目大约是 19824 只。</p><p>我对 Williams给出的估计不太放心，于是用书中给出的递推关系写了一段代码验证了一下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> *<br><br>pi = <span class="hljs-number">3.14159265358979</span><br>getcontext().prec = <span class="hljs-number">20</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve_sheep</span>(<span class="hljs-params">n</span>):<br>    p = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    v = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    v[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    p[<span class="hljs-number">1</span>] = Decimal(<span class="hljs-number">0.5</span>)<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        p[k] = (<span class="hljs-number">1</span> - <span class="hljs-number">1</span> / Decimal(<span class="hljs-number">2</span> * k)) * p[k - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        w = (<span class="hljs-number">1</span> - p[k]) / (<span class="hljs-number">1</span> + p[k])<br>        v[k + <span class="hljs-number">1</span>] = w * v[k] + (<span class="hljs-number">1</span> - w) * (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">return</span> v[n]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">estimate_sheep</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * n + pi / <span class="hljs-number">4</span> - (pi * n)**<span class="hljs-number">0.5</span><br><br><span class="hljs-built_in">print</span>(solve_sheep(<span class="hljs-number">10000</span>))<br><span class="hljs-built_in">print</span>(estimate_sheep(<span class="hljs-number">10000</span>))<br></code></pre></td></tr></tbody></table></figure><p>递推公式给出的真实值结果是 19823.5422285701，渐进公式给出的结果是19823.540013，准确的有点离谱啊！这真的有点刷新我对 Stirling公式的认知。</p><p>猜出最优策略、证明弱化的不等式、给出渐进公式，每一步都是神操作啊。</p><h1 id="附录">附录</h1><p>Williams 书中对渐进公式 <span class="math inline">\((\ref{eq:vkk})\)</span>的证明比较难读，我这里解释下其中的想法。关键是用对角线上的值 <span class="math inline">\(v_k=V(k,k)\)</span> 来表示出所有的 <span class="math inline">\(V(w, b),b&gt;w&gt;0\)</span>：</p><p><span class="math display">\[\begin{cases}V(k-c,k+c)=v_k+(2k-v_k)a_c,\\ V(k+1-c,k+c)=v_k+(2k+1-v_k)b_c.\end{cases}\]</span></p><p>其中</p><p><span class="math display">\[\begin{cases}a_c=2^{-(2k-2)}\sum\limits_{j=k}^{k+c-1}\dbinom{2k-1}{j},\\b_c=\left(2^{2k-1}+\frac{1}{2}\dbinom{2k}{k}\right)^{-1}\sum\limits_{j=k}^{k+c-1}\dbinom{2k}{j}.\end{cases}\]</span></p><p>Williams没有解释这组公式是怎么求出来的，它看起来很吓人，其实道理不复杂。我们用<span class="math inline">\(V(k-c,k+c)\)</span> 为例子来说明：</p><p>记 <span class="math inline">\(g(c) = V(k-c, k+c),0\leq c\leqk\)</span>，则 <span class="math inline">\(g(0)=v_k,\,g(k)=2k\)</span>，由前面 <a href="#recurrence" title="V_A 的递推关系"><span class="math inline">\(V_A\)</span> 的递推关系</a> 中的 3知其满足递推关系</p><p><span class="math display">\[g(c) = \frac{k-c}{2k}g(c-1) +\frac{k+c}{2k}g(c+1),\quad 1\leq c \leq k-1.\]</span> 这是一个 <span class="math inline">\([0,k]\)</span> 上的递推序列，并且已知边界条件<span class="math inline">\(g(0)\)</span> 和 <span class="math inline">\(g(k)\)</span>，我们来求解这个序列。</p><p>记</p><p><span class="math display">\[h(c) = \frac{g(c) - g(0)}{g(k)-g(0)} =\frac{g(c) - v_k}{g(k)-v_k}.\label{eq:hc}\tag{1}\]</span></p><p>则 <span class="math inline">\(h(c)\)</span>同样满足上述递推关系，但是边界条件为 <span class="math inline">\(h(0)=0\)</span>，<span class="math inline">\(h(k)=1\)</span>。于是</p><p><span class="math display">\[\begin{align}h(c+1)-h(c)&amp;=\frac{k-c}{k+c}(h(c)-h(c-1))\\&amp;=\cdots\\&amp;=\frac{(k-c)\cdots(k-1)}{(k+c)\cdots(k+1)}(h(1)-h(0))\\&amp;=\frac{\dbinom{2k-1}{k+c}}{\dbinom{2k-1}{k}}h(1).\label{eq:hrec}\tag{2}\end{align}\]</span></p><p>利用 <span class="math inline">\((\ref{eq:hrec})\)</span>我们可以解出 <span class="math inline">\(h(1)\)</span> 来：</p><p><span class="math display">\[1=h(k)=\sum_{c=0}^{k-1}\big(h(c+1)-h(c)\big)=h(1)\frac{\sum_{c=0}^{k-1}\dbinom{2k-1}{k+c}}{\dbinom{2k-1}{k}}=h(1)\dfrac{2^{2k-2}}{\dbinom{2k-1}{k}}.\]</span></p><p>即 <span class="math inline">\(h(1)=2^{-(2k-2)}\binom{2k-1}{k}\)</span>。再次利用<span class="math inline">\((\ref{eq:hrec})\)</span> 可得</p><p><span class="math display">\[h(c)=\sum_{j=0}^{c-1}\big(h(j)-h(j-1)\big)=\sum_{j=0}^{c-1}\frac{\dbinom{2k-1}{k+j}}{\dbinom{2k-1}{k}}h(1)=2^{-(2k-2)}\sum_{j=k}^{k+c-1}\dbinom{2k-1}{j}.\]</span></p><p>将上式代入 <span class="math inline">\((\ref{eq:hc})\)</span>即得结论。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Williams1991" class="csl-entry" role="listitem">Williams, David. 1991. <em>Probability with Martingales</em>. CambridgeUniversity Press.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>飞船空间跳跃问题</title>
      <link href="/spaceship-jump/"/>
      <url>/spaceship-jump/</url>
      
        <content type="html"><![CDATA[<div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"></span>一艘太空船正在宇宙中做星际航行时，飞船的控制系统出了故障，飞船不能正常地进行空间跳跃，而是只能预先设定一个距离，然后以此距离进行一次方向完全随机的跳跃。现在飞船想要返回太阳系。假设太阳系的半径是<span class="math inline">\(r\)</span>，发生故障时飞船与太阳的距离为<span class="math inline">\(R&gt;r\)</span>。好消息是在每个时刻，飞船能够知道自身与太阳系的距离。</p><p>求证：不论采用怎样的跳跃策略，飞船返回太阳系的概率都小于 <span class="math inline">\(r/R\)</span>；但是对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，可以采取适当的策略，使得飞船返回太阳系的概率大于<span class="math inline">\((r-\epsilon)/R\)</span>，即 <span class="math inline">\(r/R\)</span> 是最优概率。这个最优策略是什么？</p></div><p>这个问题是 Williams 的教材 <a href="https://www.cambridge.org/highereducation/books/probability-with-martingales/B4CFCE0D08930FB46C6E93E775503926#overview">Probabilitywith Martingales</a>中的一道习题，这个问题的设定很有趣，但是给出一个严格的解答却并不轻松（基于测度论！）。下面是我的解答。</p><span id="more"></span><h1 id="预备知识">预备知识</h1><h2 id="冻结引理">“冻结”引理</h2><p>设 <span class="math inline">\(X,Y\)</span> 是两个随机变量，<span class="math inline">\(\varphi\)</span> 是可测函数。条件期望 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|X]\)</span>是一个关于 <span class="math inline">\(\sigma(X)\)</span>可测的随机变量，根据 Doob-Dynkin 引理，它可以写成 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|X]=g(X)\]</span>的形式，其中 <span class="math inline">\(g\)</span> 是一个 Borel可测函数。但是这个 <span class="math inline">\(g\)</span>具体是什么呢？下面的 freezing lemma <span class="citation" data-cites="Williams1991">(<a href="#ref-Williams1991" role="doc-biblioref">Williams 1991, sec. 9.10</a>)</span> or <span class="citation" data-cites="Durrett2019">(<a href="#ref-Durrett2019" role="doc-biblioref">Durrett 2019, sec. 4.1</a>)</span>告诉我们，在一定条件下，我们可以这样计算 <span class="math inline">\(g\)</span>：先将 <span class="math inline">\(X\)</span> 冻结为一个实数值 <span class="math inline">\(x\)</span>，上式的右边变成 <span class="math inline">\(g(x)\)</span>，左边变成 <span class="math inline">\(\{X=x\}\)</span> 条件下的期望 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|X=x]=\mathop{\mathrm{\mathbb{E}}}\varphi(x,Y).\]</span>即 <span class="math inline">\(g(x)=\mathop{\mathrm{\mathbb{E}}}\varphi(x,Y)\)</span>。</p><div id="freeze" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span>是一个概率空间，<span class="math inline">\(X, Y\)</span>是两个取值在某可测空间 <span class="math inline">\((S,\mathcal{S})\)</span> 中的随机变量，子 <span class="math inline">\(\sigma\)</span> 域 <span class="math inline">\(\mathcal{G}\subseteq\mathcal{F}\)</span> 满足<span class="math inline">\(X\in\mathcal{G}\)</span> 且 <span class="math inline">\(\mathcal{G}\)</span> 与 <span class="math inline">\(Y\)</span> 独立。可测函数 <span class="math inline">\(\varphi: S\times S\to\mathbb{R}\)</span> 满足<span class="math inline">\(\varphi\)</span> 非负或者 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}|\varphi(X,Y)|&lt;\infty\)</span>。令 <span class="math inline">\(g(x)=\mathop{\mathrm{\mathbb{E}}}\varphi(x,Y)\)</span>，则 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|\mathcal{G}]=g(X).\]</span></p></div><p>在进入证明之前，我们来看个例子：</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>设 <span class="math inline">\(X, Y\)</span>是两个独立的随机变量，<span class="math inline">\(Y\)</span> 服从的是<span class="math inline">\([0, 1]\)</span> 上的均匀分布，<span class="math inline">\(X\)</span> 服从的分布我们可以不用关心。问条件期望<span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\sin(XY)|X]\)</span>是什么？</p><p>这相当于在 <a href="#freeze" title="引理 1.1">引理 1.1</a> 中取 <span class="math inline">\(\varphi(X,Y)=\sin(XY)\)</span> 和 <span class="math inline">\(\mathcal{G}=\sigma(X)\)</span>。<a href="#freeze" title="引理 1.1">引理 1.1</a> 告诉我们可以把 <span class="math inline">\(\sin(XY)\)</span> 中的 <span class="math inline">\(X\)</span> 冻结为常数 <span class="math inline">\(X=x\)</span>，把 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\sin(XY)|X]\)</span>视作关于常数 <span class="math inline">\(x\)</span> 的积分 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\sin(xY)]=\int_0^1\sin(xy)\,\mathrm{d}y = \frac{1}{x}\int_0^x\sin(z)\,\mathrm{d}z=\frac{1-\cos x}{x}.\]</span> 然后把 <span class="math inline">\(x\)</span> 解冻为 <span class="math inline">\(X\)</span> 即得 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\sin(XY)|X] =\frac{1-\cos X}{X}.\]</span></p></div><p><a href="#freeze" title="引理 1.1">引理 1.1</a> 中的可测空间 <span class="math inline">\((S,\mathcal{S})\)</span> 可以是多维空间 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>，<span class="math inline">\(X,Y\)</span> 也可以是独立的随机向量。即如果 <span class="math inline">\(\varphi(X_1,\ldots,X_n,Y_1,\ldots,Y_m)\)</span>是关于随机变量的可测函数，<span class="math inline">\(\sigma(X_1,\ldots,X_n)\subset\mathcal{G}\)</span>并且 <span class="math inline">\(\mathcal{G}\)</span> 和 <span class="math inline">\(\sigma(Y_1,\ldots,Y_m)\)</span> 独立，那么条件期望<span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|\mathcal{G}]\)</span>就是一个以 <span class="math inline">\((x_1,\ldots,x_n)\)</span>为参变元的多重积分 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(x_1,\ldots,x_n,Y_1,\ldots,Y_m)]=g(x_1,\ldots,x_n).\]</span></p><p><strong>证明</strong>：我们要证明对任何可测集 <span class="math inline">\(C\in\mathcal{G}\)</span> 有</p><p><span class="math display">\[\int_C \varphi(X, Y)\mathrm{d}\mu =\int_C g(X)\mathrm{d}\mu.\]</span> 当 <span class="math inline">\(\varphi(x,y)=\mathbb{1}_A(x)\mathbb{1}_B(y)\)</span> 时，<span class="math inline">\(g(x)=\mathbb{1}_A(x)\mathbb{P}(\{Y\inB\})\)</span>，从而 <span class="math display">\[\begin{align*}\int_C\mathbb{1}_A(X)\mathbb{1}_B(Y)\mathrm{d}\mu&amp;=\mathbb{P}(\{X\inA\}\cap C\cap\{Y\in B\})\\&amp;=\mathbb{P}(\{X\in A\}\capC)\cdot\mathbb{P}(\{Y\inB\})\\&amp;=\int_C\mathbb{1}_A(X)\mathrm{d}\mu\cdot\mathbb{P}(\{Y\inB\})\\&amp;=\int_C g(X)\mathrm{d}\mu.\end{align*}\]</span></p><p>于是结论对所有形如 <span class="math inline">\(A\times B\)</span>的集合的示性函数成立。这样的示性函数构成一个 <span class="math inline">\(\pi\)</span>- 系。根据可测函数的单调类定理(monotone class theorem)，结论对所有非负或者可积函数都成立。<span class="math inline">\(\blacksquare\)</span></p><h2 id="newton-势">Newton 势</h2><div id="newton-potential" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B=B(A,R)\)</span> 是 <span class="math inline">\(\mathbb{R}^3\)</span> 中以点 <span class="math inline">\(A\)</span> 为中心，半径为 <span class="math inline">\(R\)</span> 的球，<span class="math inline">\(X\)</span> 是球面上均匀分布的随机点，则 <span class="math inline">\(X\)</span> 与原点 <span class="math inline">\(O\)</span> 之间距离倒数的期望为 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}\frac{1}{|X|}=\begin{cases}1/a&amp; a&gt;R,\\ 1/R &amp; a\leq R.\end{cases}\]</span> 其中 <span class="math inline">\(a=|A|\)</span> 是 <span class="math inline">\(A\)</span> 与原点之间的距离。</p></div><p>这个引理其实是我们都熟悉的高中物理知识：假设以 <span class="math inline">\(A\)</span> 为中心，半径为 <span class="math inline">\(R\)</span> 的球壳上有总量为 1的均匀分布的电荷，则球壳表面和内部的电势处处等于 <span class="math inline">\(1/R\)</span>，球壳外部任意一点 <span class="math inline">\(P\)</span> 的电势等于 <span class="math inline">\(P\)</span> 和球心距离的倒数，即 <span class="math inline">\(1/|P-A|\)</span>（不计物理常数），此即为结论。</p><p>当然这不是一个严格的证明，实际上这个积分正是 Newton势函数的简单情形。由于这不是本文的重点，就不再展开讲了，读者可以参考<span class="citation" data-cites="Donoghue2014">(<a href="#ref-Donoghue2014" role="doc-biblioref">Donoghue 2014, chap.8</a>)</span>。</p><h1 id="建立模型">建立模型</h1><p>我们开始正式求解本文开头的问题。</p><ol type="1"><li><p>初始时刻为 0，太阳系是以原点为圆心，半径为 <span class="math inline">\(r\)</span> 的球，飞船初始位置在 <span class="math inline">\((R,0,0)\)</span> 处。</p></li><li><p>设 <span class="math inline">\(\{U_n\}_{n\geq 1}\)</span>是定义在某个概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\)</span>上的一组独立同分布的、在单位球面上均匀分布的随机向量，它们表示飞船每次空间跳跃的随机方向。并设<span class="math inline">\(\mathcal{F}_n=\sigma(U_1,\ldots,U_n)\)</span> 以及<span class="math inline">\(\mathcal{F}_0=(\Omega,\emptyset)\)</span>。</p></li><li><p>设第 <span class="math inline">\(n\)</span> 次空间跳跃的距离为<span class="math inline">\(l_n(n\geq1)\)</span>，由于 <span class="math inline">\(l_n\)</span> 是根据 <span class="math inline">\(n\)</span> 时刻之前的信息决定的，所以 <span class="math inline">\(l_n\)</span> 关于 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 可测。</p></li><li><p>设第 <span class="math inline">\(n\)</span>次空间跳跃后飞船的坐标为 <span class="math inline">\(X_n\)</span>，那么<span class="math display">\[X_n=X_{n-1} + l_n U_n.\quadn=1,2,\ldots.\]</span> 其中 <span class="math inline">\(X_0=(R,0,0)\)</span> 是飞船的初始位置。</p></li><li><p>设 <span class="math inline">\(T\)</span>是飞船首次返回太阳系的时间： <span class="math display">\[T = \inf\,\{n\mid X_n\in B(0,r)\},\]</span>则 <span class="math inline">\(T\)</span>的取值范围是 <span class="math inline">\(\mathbb{N^+}\cup\{+\infty\}\)</span>。我们要估算的是事件<span class="math inline">\(\{T&lt;+\infty\}\)</span>的概率，这正是飞船能够在有限时间内回到太阳系的概率。</p></li></ol><p>现在我们着手研究一下飞船的运动规律。</p><p>记 <span class="math inline">\(|X_n|\)</span> 为第 <span class="math inline">\(n\)</span>次跳跃以后飞船与太阳系的距离，我们来推导 <span class="math inline">\(|X_n|\)</span> 和 <span class="math inline">\(|X_{n+1}|\)</span> 之间的关系。</p><p>对 <span class="math inline">\(\mathcal{F}=\mathcal{F}_n,\,\mathcal{G}=\mathcal{F}_{n-1},\,X=(X_{n-1},l_n),\,Y=U_n,\,\varphi(X,Y)=1/|X_{n-1}+l_nY|\)</span> 应用 <a href="#freeze" title="引理 1.1">引理 1.1</a> 和 <a href="#newton-potential" title="引理 1.2">引理 1.2</a> 得到</p><p><span class="math display">\[\mathop{\mathrm{\mathbb{E}}}\left[\left.\frac{1}{|X_n|}\right|\mathcal{F}_{n-1}\right]=\mathop{\mathrm{\mathbb{E}}}\left.\frac{1}{\left|X_{n-1}+l_nU_n\right|}\right|_{X_{n-1}=A}\leq\frac{1}{|A|}=\frac{1}{|X_{n-1}|}.\]</span></p><p>这里由于 <span class="math inline">\(X_{n-1}\)</span> 和 <span class="math inline">\(l_n\)</span> 都是关于 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 可测的，而 <span class="math inline">\(U_n\)</span> 和 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 是独立的，所以 <a href="#freeze" title="引理 1.1">引理 1.1</a> 的条件是满足的。</p><p>总结一下：</p><div id="supermartingale" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"></span>无论采取何种策略，<span class="math inline">\(\left\{\dfrac{1}{|X_n|}\right\}_{n\geq0}\)</span>总是一个上鞅。如果跳跃距离 <span class="math inline">\(l_n\)</span>满足对任何 <span class="math inline">\(n\geq1\)</span> 有 <span class="math inline">\(l_n\leq |X_{n-1}|\)</span>，则 <span class="math inline">\(\left\{\dfrac{1}{|X_n|}\right\}_{n\geq0}\)</span>还是一个鞅。</p></div><p><strong>证明</strong>：只要再说明 <span class="math inline">\(\dfrac{1}{|X_n|}\)</span> 可积即可。由于 <span class="math inline">\(\dfrac{1}{|X_n|}\)</span> 非负，因此条件期望 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}\left[\dfrac{1}{|X_n|}\bigg|\mathcal{F}_{n-1}\right]\)</span>有定义，并且上面已经证明了它小于等于 <span class="math inline">\(\dfrac{1}{|X_{n-1}|}\)</span>，于是 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}\left[\dfrac{1}{|X_n|}\right]=\mathop{\mathrm{\mathbb{E}}}\left[\mathop{\mathrm{\mathbb{E}}}\left[\dfrac{1}{|X_n|}\bigg|\mathcal{F}_{n-1}\right]\right]\leq\mathop{\mathrm{\mathbb{E}}}\left[\dfrac{1}{|X_{n-1}|}\right].\]</span>对 <span class="math inline">\(n\)</span> 归纳即可。<span class="math inline">\(\blacksquare\)</span></p><p><a href="#supermartingale" title="定理 2.1">定理 2.1</a>是解决整个问题最关键的一步，有了它就海阔天空，没有它就寸步难行。由它我们立刻可以导出一个有趣的观察：由于非负上鞅必然几乎处处收敛，因此<span class="math inline">\(\lim\limits_{n\to\infty}|X_n|\)</span>几乎处处存在。这有两种可能：<span class="math inline">\(\lim\limits_{n\to\infty}|X_n|=+\infty\)</span>或者 <span class="math inline">\(\lim\limits_{n\to\infty}|X_n|&lt;+\infty\)</span>。所以飞船要么飞向无穷远，即迷失在宇宙的深处，要么被吸引到某个有限的位置。</p><p>现在我们可以证明：</p><div id="lessthan" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.2</span>.</span><span class="statement-spah"></span>不论飞船采取怎样的策略，返回太阳系的概率都严格小于 <span class="math inline">\(r/R\)</span>。</p></div><p><strong>证明</strong>：记 <span class="math inline">\(Z_n=\dfrac{1}{|X_n|}\)</span>，根据 <a href="#supermartingale" title="定理 2.1">定理 2.1</a> <span class="math inline">\(\{Z_n\}_{n\geq0}\)</span> 是非负上鞅，所以 <span class="math inline">\(Z_\infty=\lim\limits_{n\to\infty}Z_n\)</span>几乎处处存在。考虑停时 <span class="math inline">\(T\)</span>截断的非负上鞅序列 <span class="math inline">\(\{Z_{T\wedgen}\}\)</span>。由非负可积函数列的 Fatou 引理有 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]\leq\varliminf_{n\to\infty}\mathop{\mathrm{\mathbb{E}}}[Z_{T\wedgen}]\leq \mathop{\mathrm{\mathbb{E}}}[Z_0]=\frac{1}{R}.\]</span>另一方面</p><p><span class="math display">\[\begin{align*}\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]&amp;=\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]+\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_n\mathbb{1}_{\{T=\infty\}}]\\&amp;\geq \mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]\geq\frac{\mathbb{P}(T&lt;\infty)}{r}.\end{align*}\]</span></p><p>其中最后一个不等号是因为在 <span class="math inline">\(\{T&lt;\infty\}\)</span> 上有 <span class="math inline">\(Z_T\geq 1/r\)</span>。综合这两个不等式就得到了<span class="math inline">\(\mathbb{P}(T&lt;\infty)\leqr/R\)</span>，即任何策略下飞船最终返回太阳系的概率不大于 <span class="math inline">\(r/R\)</span>。</p><p>要证明这个概率是严格小于 <span class="math inline">\(r/R\)</span>的，只要证明上面式子中，最后的不等号是严格成立的： <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]&gt;\frac{\mathbb{P}(T&lt;\infty)}{r}.\]</span></p><p>为此只要证明在事件 <span class="math inline">\(\{T&lt;\infty\}\)</span> 上几乎处处有 <span class="math inline">\(Z_T&gt;1/r\)</span>，即 <span class="math inline">\(|X_T|&lt;r\)</span> 即可。由于在 <span class="math inline">\(\{T&lt;\infty\}\)</span> 上 <span class="math inline">\(|X_T|\leq r\)</span>，所以我们只要证明在 <span class="math inline">\(\{T&lt;\infty\}\)</span> 上 事件 <span class="math inline">\(\{|X_T|=r\}\)</span> 具有零测度。进一步，由于<span class="math display">\[\{|X_T|=r,\,T&lt;\infty\}=\bigcup_{n=0}^\infty\{|X_n|=r,\,T=n\}\subset\bigcup_{n=0}^\infty\{|X_n|=r\}.\]</span>所以我们只要证明对每个 <span class="math inline">\(n\geq0\)</span>，事件<span class="math inline">\(\{|X_n|=r\}\)</span> 具有零测度即可。</p><p>我们来证明一个稍微加强的结论：对每个 <span class="math inline">\(n\geq0\)</span>，事件 <span class="math display">\[A_n=\{|X_n|=0\}\cup\{|X_n|=r\}\]</span>都是零概率事件。</p><p>对 <span class="math inline">\(n\)</span> 归纳：<span class="math inline">\(n=0\)</span> 时 <span class="math inline">\(|X_0|=R&gt;r\)</span>，结论成立。设结论在小于<span class="math inline">\(n\)</span> 时都成立。由于 <span class="math display">\[\mathbb{P}(A_n)=\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}]=\mathop{\mathrm{\mathbb{E}}}[\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}|\mathcal{F}_{n-1}]].\]</span>我们只要证明 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}|\mathcal{F}_{n-1}]\)</span>是几乎处处为 0 的随机变量即可。</p><p>在 <a href="#freeze" title="引理 1.1">引理 1.1</a> 中取 <span class="math inline">\(X=(X_{n-1},l_n),\,Y=U_n,\,\mathcal{G}=\mathcal{F}_{n-1}\)</span>，我们得到<span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}|\mathcal{F}_{n-1}]=\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\bigg|\mathcal{F}_{n-1}]=\mathop{\mathrm{\mathbb{E}}}\left[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\right].\]</span> 其中上式最右边的期望是冻结 <span class="math inline">\((X_{n-1},l_n)\)</span>，对单位球面上均匀分布的<span class="math inline">\(U_n\)</span> 进行积分，结果是一个关于 <span class="math inline">\((X_{n-1},l_n)\)</span>的函数。显然，上式右边作为一个只取 <span class="math inline">\(\{0,1\}\)</span>两个值的函数的概率积分，结果必然在区间 <span class="math inline">\([0,1]\)</span> 中。即 <span class="math display">\[0\leq\mathop{\mathrm{\mathbb{E}}}\left[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\right]\leq1.\]</span></p><p>注意到如果 <span class="math inline">\(|X_{n-1}|\ne 0\)</span> 且<span class="math inline">\(|X_{n-1}|\ne r\)</span>，这时以 <span class="math inline">\(X_{n-1}\)</span> 为中心，<span class="math inline">\(l_n\)</span> 为半径的球面上，与原点之间的距离为<span class="math inline">\(0\)</span> 或者 <span class="math inline">\(r\)</span> 的点的测度为 0，即积分项 <span class="math inline">\(\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\)</span> 对几乎处处的 <span class="math inline">\(U_n\)</span> 都是 0，当然积分值 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}\left[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\right]=0\)</span>。</p><p>于是我们有 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}\left[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\right]=\begin{cases}\in[0,1], &amp; |X_{n-1}|=0 \text{ or } |X_{n-1}|=r\\0,        &amp; |X_{n-1}|\ne 0 \text { and } |X_{n-1}|\ne r\end{cases}\]</span></p><p>根据归纳假设，<span class="math inline">\(|X_{n-1}|=0 \text{ or }|X_{n-1}|=r\)</span> 的概率是 0，即 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}\left[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\right]\)</span> 是一个几乎处处为 0 的函数，从而 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}|\mathcal{F}_{n-1}]\)</span>也几乎处处为 0，即得所证。<span class="math inline">\(\blacksquare\)</span></p><h1 id="对策略的进一步分析">对策略的进一步分析</h1><p>现在我们把注意力转移到飞船不能返回太阳系这个事件上来。前面已经说过，飞船的运动只有两种可能，迷失在无穷远处或者被禁锢在一个有限的区域内，所以如果飞船不能返回太阳系，则飞船要么飞向无穷远，要么在太阳系之外的一个有限区域内打转。我们想知道，怎么判断这两种情形哪一种会发生呢？</p><p>举个例子，考虑这样一个明显不合理的策略：第 <span class="math inline">\(n\)</span> 次的跳跃距离总是设定为 <span class="math inline">\(1/2^n\)</span>，在这个策略下飞船永远飞不出一个半径为1 的空间，所以这种策略是应该避免的。</p><p>你可以注意到这个糟糕的策略的问题出在跳跃距离之和是收敛的。如果我们强迫每次跳跃的距离都大于一个固定的值<span class="math inline">\(\epsilon\)</span>（<span class="math inline">\(\epsilon\)</span>可以是任意的正数），就可以避免这种情形出现，这就是下面的定理：</p><div id="goinf" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\epsilon\)</span> 是任一正数 <span class="math display">\[E:=\{\omega:\T(\omega)=\infty,\  l_n(\omega)\geq\epsilon,\ \forall n\geq1\},\]</span>则我们有 <span class="math display">\[\lim_{n\to\infty}|X_n|=+\infty,\quad \text{for a.e.}\ \omega\in E.\]</span></p></div><p><strong>证明</strong>：记 <span class="math inline">\(\theta_n\)</span> 是 <span class="math inline">\(X_{n-1}\)</span> 和 <span class="math inline">\(U_n\)</span> 的夹角，即 <span class="math inline">\(\cos\theta_n=\dfrac{X_{n-1}}{|X_{n-1}|}\cdotU_n\)</span>。由 <span class="math inline">\(X_n=X_{n-1}+l_nU_n\)</span>可得 <span class="math display">\[|X_n|^2=|X_{n-1}|^2+2l_n|X_{n-1}|\cos\theta_n+l_n^2.\]</span>令 <span class="math inline">\(B_n=\{\cos\theta_n\geq1/2\}\)</span>，则在事件 <span class="math inline">\(B_n\)</span>上我们有 <span class="math display">\[|X_n|^2\geq|X_{n-1}|^2+l_n|X_{n-1}|+l_n^2\geq(|X_{n-1}|+l_n/2)^2.\]</span>又已知在事件 <span class="math inline">\(E\)</span> 上有 <span class="math inline">\(l_n\geq\epsilon\)</span>，所以在事件 <span class="math inline">\(B_n\cap E\)</span> 上有 <span class="math display">\[|X_n|\geq |X_{n-1}|+\epsilon/2,\quad\omega\inB_n\cap E.\]</span> 如果我们能证明 <span class="math inline">\(\mathbb{P}(\{B_n\\text{i.o.}\})=1\)</span>，则对几乎处处的 <span class="math inline">\(\omega\in E\)</span>，<span class="math inline">\(|X_n|\geq |X_{n-1}|+\epsilon/2\)</span> 对无穷多个<span class="math inline">\(n\)</span> 成立。对这些 <span class="math inline">\(\omega\)</span>，<span class="math inline">\(\lim\limits_{n\to\infty}|X_n|\)</span>不可能是一个有限点，所以必然是 <span class="math inline">\(\lim\limits_{n\to\infty}|X_n|=\infty\)</span>，这就说明飞船在<span class="math inline">\(E\)</span> 上几乎处处飞向无穷远。</p><p>为此我们只要证明有 <span class="math inline">\(\sum_{n=1}^\infty\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{B_n}\big|\mathcal{F}_{n-1}]=\infty\)</span>成立，这样由鞅版本的 second Borel-Cantelli lemma <span class="citation" data-cites="Durrett2019">(<a href="#ref-Durrett2019" role="doc-biblioref">Durrett 2019</a>, thm 4.3.4)</span> 即得 <span class="math inline">\(\mathbb{P}(\{B_n\ \text{i.o.}\})=1\)</span>。</p><p>在 <a href="#freeze" title="引理 1.1">引理 1.1</a> 中令 <span class="math inline">\(X=X_{n-1},Y=U_n,\mathcal{G}=\mathcal{F}_{n-1},\varphi(X,Y)=\mathbb{1}_{[1/2,1]}\circ\cos\theta_n\)</span>，有</p><p><span class="math display">\[\begin{aligned}\mathbb{E}[\mathbb{1}_{B_n}|\mathcal{F}_{n-1}] &amp;=\mathbb{E}[\mathbb{1}_{[1/2,1]}\circ\cos\theta_n\,\bigg|\,\mathcal{F}_{n-1}]\\&amp;\overset{(1)}{=}\mathbb{P}[(v\cdot U_n)\geq1/2]\,\bigg|_{v=\frac{X_{n-1}}{|X_{n-1}|}}\\&amp;\overset{(2)}{=}\mathbb{P}[U_n\in \{(x,y,z)\in\mathbb{R}^3:\ z\geq1/2\}]\\&amp;=\frac{1}{4}.\end{aligned}\]</span></p><ul><li>在 (1) 中，我们将 <span class="math inline">\(\dfrac{X_{n-1}}{|X_{n-1}|}\)</span>冻结为一个固定的单位向量 <span class="math inline">\(v\)</span>，转为计算 <span class="math inline">\(U_n\)</span> 和 <span class="math inline">\(v\)</span> 的内积大于等于 1/2 的概率；</li><li>在 (2) 中，由于 <span class="math inline">\(U_n\)</span>是在单位球面上均匀分布的，所以无妨设 <span class="math inline">\(v=(0,0,1)\)</span> 是 <span class="math inline">\(z\)</span> 轴正向，从而使得 <span class="math inline">\(v\cdot U_n\geq1/2\)</span> 的 <span class="math inline">\(U_n\)</span> 正是球面上满足 <span class="math inline">\(z\geq1/2\)</span> 的点构成的球冠。根据 <a href="https://en.wikipedia.org/wiki/Spherical_cap">球冠面积公式</a>这些点占整个球面的 1/4。</li></ul><p>从而确实有 <span class="math inline">\(\sum_{n=1}^\infty\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{B_n}\big|\mathcal{F}_{n-1}]=\sum_{n=1}^\infty1/4=\infty\)</span>。<a href="#goinf" title="定理 3.1">定理 3.1</a> 得证。<span class="math inline">\(\blacksquare\)</span></p><h1 id="最优策略">最优策略</h1><p>现在我们已经知道飞船返回太阳系的概率总是小于 <span class="math inline">\(r/R\)</span>，也知道只要策略得当，就可以避免飞船在原地打转的糟糕情况。接下来的问题是：最好的策略到底是什么？</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.1</span>.</span><span class="statement-spah"></span>定义如下的跳跃策略：在准备第 <span class="math inline">\(n\)</span> 次跳跃时，如果飞船已经在太阳系内，则令<span class="math inline">\(l_n=0\)</span>，否则令 <span class="math inline">\(l_n=R_{n-1}-r+\epsilon\)</span>，这里 <span class="math inline">\(0&lt;\epsilon&lt;r\)</span>。在这个跳跃策略下，飞船返回太阳系的概率大于<span class="math inline">\((r-\epsilon)/R\)</span>。</p></div><p>注意在这个策略中总是有 <span class="math inline">\(l_n&lt;R_{n-1}\)</span>，因此 <span class="math inline">\(\{Z_n=1/R_n\}\)</span>实际上是一个鞅。此外由于总是有 <span class="math inline">\(R_n\geqr-\epsilon\)</span>，所以 <span class="math inline">\(Z_n\leq1/(r-\epsilon)\)</span>，即 <span class="math inline">\(\{Z_n\}\)</span> 被常数 <span class="math inline">\(1/(r-\epsilon)\)</span> 所控制。</p><p>接下来的证明不过是 <a href="#lessthan" title="定理 2.2">定理 2.2</a>证明的重复：</p><p>这次根据控制收敛定理有 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]=\lim_{n\to\infty}\mathop{\mathrm{\mathbb{E}}}[Z_{T\wedgen}]=\mathop{\mathrm{\mathbb{E}}}[Z_0]=\frac{1}{R}.\]</span> 另一方面<span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]=\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]+\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_n\mathbb{1}_{\{T=\infty\}}].\]</span>这个时候要注意到在 <span class="math inline">\(\{T=\infty\}\)</span>上总是有 <span class="math inline">\(l_n\geq\epsilon\)</span>，因此根据<a href="#goinf" title="定理 3.1">定理 3.1</a>的结论，飞船几乎必然飞向无穷远，即 <span class="math display">\[\lim_{n\to\infty}Z_n=0,\quad\omega\in\{T=\infty\}.\]</span> 所以 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]=\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]\leq\frac{1}{r-\epsilon}\mathbb{P}(T&lt;\infty).\]</span>综合两个式子就证明了 <span class="math inline">\(\mathbb{P}(T&lt;\infty)\geq(r-\epsilon)/R\)</span>。</p><h1 id="star-trek-3">Star Trek 3</h1><p><span class="citation" data-cites="Williams1991">(<a href="#ref-Williams1991" role="doc-biblioref">Williams 1991</a>)</span>的习题 E12.3 提出了一个新问题：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"></span>如果每次飞船的跳跃距离总是等于当前飞船到太阳系的距离，即对任意<span class="math inline">\(n\geq1\)</span> 有 <span class="math inline">\(R_n=l_{n-1}\)</span>，求证 <span class="math display">\[\sum_{n=1}^\infty\frac{1}{R_n^2}&lt;\infty,\quad\mathrm{a.e.}\]</span></p></div><p><strong>证明</strong>：记 <span class="math inline">\(V_n=X_n/R_n\)</span> 是位置 <span class="math inline">\(X_n\)</span> 的单位方向向量。由 <span class="math inline">\(X_n=X_{n-1}+R_{n-1}U_n\)</span> 可得 <span class="math display">\[R_n^2 =|X_{n-1}+R_{n-1}U_n|^2=R_{n-1}^2|V_{n-1}+U_n|^2=R_{n-1}^2(2+2V_{n-1}\cdotU_n).\]</span> 记 <span class="math inline">\(Y_n=V_{n-1}\cdotU_n\)</span>。设 <span class="math inline">\(f:\mathbb{R}\to\mathbb{R}\)</span>是任一有界可测函数。由于 <span class="math inline">\(V_{n-1}\)</span>关于 <span class="math inline">\(\mathcal{F_{n-1}}\)</span> 可测，<span class="math inline">\(U_n\)</span> 与 <span class="math inline">\(\mathcal{F_{n-1}}\)</span> 独立，所以我们可以使用<a href="#freeze" title="引理 1.1">引理 1.1</a>，得到</p><p><span class="math display">\[\mathbb{E}\left[f(V_{n-1}\cdotU_n)\mid\mathcal F_{n-1}\right]= g(V_{n-1}),\quadg(v):=\mathbb E\big[f(v\cdot U_n)\big].\]</span> 由于 <span class="math inline">\(U_n\)</span> 均匀分布在单位球面上，而 <span class="math inline">\(v\)</span> 是固定的单位球面上的向量，因此 <span class="math inline">\(v\cdot U_n\)</span> 的分布是旋转不变的。我们可以取<span class="math inline">\(v=(0,0,1)\)</span>，于是 <span class="math inline">\(v\cdot U_n\)</span> 就是 <span class="math inline">\(U_n\)</span> 的 <span class="math inline">\(z\)</span> 分量，当 <span class="math inline">\(U_n\)</span> 是单位球面上均匀分布的向量时，其<span class="math inline">\(z\)</span> 分量服从 <span class="math inline">\([-1,1]\)</span> 上的均匀分布。从而 <span class="math display">\[g(z)=\frac{1}{2} \int_{-1}^{1}f(z)\,\mathrm{d}z.\]</span> 至此我们证明了对任何有界可测函数 <span class="math inline">\(f\)</span> 有 <span class="math display">\[\mathbb{E}[f(Y_n)\mid\mathcal{F}_{n-1}]=\frac{1}{2}\int_{-1}^{1} f(z)\,\mathrm{d}z.\]</span> 即 <span class="math inline">\(\mathbb{E}[f(Y_n\mid\mathcal{F}_{n-1})]\)</span>是与 <span class="math inline">\(\omega\)</span>无关的常数（这个常数当然就是 <span class="math inline">\(\mathbb{E}[f(Y_n)]\)</span>）。这正说明了 <span class="math inline">\(Y_n\)</span> 与 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 独立。于是 <span class="math inline">\(\{Y_n\}\)</span> 是 i.i.d 的序列。</p><p>取对数，并迭代可得 <span class="math display">\[\log R_n^2 = \logR_0^2 + \sum_{k=1}^n \log(2+2Y_n).\]</span> 根据强大数定律， <span class="math display">\[\frac{1}{n}\sum_{k=1}^n \log(2+2Y_n)\xrightarrow{\rm a.e.} \mathbb{E}[Y_1] = \frac{1}{2}\int_{-1}^{1}\log(2+2z)\,\mathrm{d}z = \log 4-1&gt;0.\]</span> 任取正数<span class="math inline">\(0&lt;\alpha&lt;\mu\)</span>，则对几乎处处的<span class="math inline">\(\omega\)</span>，存在随机变量 <span class="math inline">\(N(\omega)\)</span> 使得当 <span class="math inline">\(n\geq N(\omega)\)</span> 时， <span class="math display">\[\sum_{k=1}^n Y_k\geq \alpha n.\]</span>于是对几乎处处的 <span class="math inline">\(\omega\)</span>，当 <span class="math inline">\(n\geq N(\omega)\)</span> 时有 <span class="math display">\[R_n^2=R_0^2e^{\sum_{k=1}^n Y_k}\geqR_0^2e^{\alpha n}.\]</span> 从而 <span class="math display">\[\frac{1}{R_n^2}\leq \frac{1}{R_0^2}e^{-\alphan},\quad n\geq N(\omega).\]</span> 因此几乎处处有 <span class="math inline">\(\sum_{n=1}^\infty1/R_n^2&lt;\infty\)</span>成立。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Donoghue2014" class="csl-entry" role="listitem">Donoghue, W. F. 2014. <em>Distributions and Fourier Transforms</em>.ISSN. Elsevier Science. <a href="https://books.google.com/books?id=P30Y7daiGvQC">https://books.google.com/books?id=P30Y7daiGvQC</a>.</div><div id="ref-Durrett2019" class="csl-entry" role="listitem">Durrett, Rick. 2019. <em>Probability: Theory and Examples</em>. 5th ed.Cambridge Series in Statistical and Probabilistic Mathematics. CambridgeUniversity Press.</div><div id="ref-Williams1991" class="csl-entry" role="listitem">Williams, David. 1991. <em>Probability with Martingales</em>. CambridgeUniversity Press.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中心单代数的三个基本结论</title>
      <link href="/central-simple-algebra/"/>
      <url>/central-simple-algebra/</url>
      
        <content type="html"><![CDATA[<p>本文整理自我在讨论班上做的一次约两小时的报告，介绍中心单代数的三个基本结论：</p><ol type="1"><li>中心单代数对张量积运算是封闭的。</li><li>Noether-Skolem 定理。</li><li>双重中心化子定理。</li></ol><p>这些内容虽然经典，但不同教材的讲解方式差异很大，找到一个完全符合自己口味的不是件容易的事情。对初学者而言，一些名气很大的教材反而不见得友好。我当初念<span class="citation" data-cites="Jacobson_alg">(<a href="#ref-Jacobson_alg" role="doc-biblioref">Jacobson 1980</a>)</span>就感觉很抓狂。后来我查阅了不少教材后经过提炼整理得到了本文。我个人认为这是最直接清楚的讲法。</p><span id="more"></span><h1 id="中心单代数对张量积运算是封闭的">中心单代数对张量积运算是封闭的</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的一个有限维的结合代数，有乘法单位元<span class="math inline">\(\rm 1\)</span>。如果 <span class="math inline">\(A\)</span> 除了 <span class="math inline">\((0)\)</span> 和自身以外不含有其它的双边理想，就称<span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的<strong>单代数</strong>；进一步如果<span class="math inline">\(A\)</span> 的中心 <span class="math inline">\(Z(A)=F\cdot{\rm 1}\cong F\)</span>，就称 <span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的<strong>中心单代数</strong>。</p></div><p>中心单代数的典型例子是 <span class="math inline">\({\rmMat}_n(F)\)</span>，研究一般中心单代数的常见手段是建立它们与 <span class="math inline">\({\rm Mat}_n(F)\)</span> 之间的同态。</p><div id="A-otimes-B" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A,B\)</span> 是域 <span class="math inline">\(F\)</span> 上的两个中心单代数，则 <span class="math inline">\(A\otimes_F B\)</span> 也是中心单代数。</p></div><p><strong>证明</strong>：证明大致分三步：</p><p><strong>第一步：<span class="math inline">\(I\)</span> 必然包含形如<span class="math inline">\(1\otimes b\)</span> 的元素</strong></p><p>设 <span class="math inline">\(\dim B=m\)</span>，固定 <span class="math inline">\(B\)</span> 的一组基 <span class="math inline">\(\{b_1,\ldots,b_m\}\)</span>，则任何 <span class="math inline">\(x\in A\otimes B\)</span> 可以唯一地写成 <span class="math display">\[x= a_1\otimes b_1+a_2\otimesb_2+\cdots+a_m\otimes b_m,\quad a_i\in A.\]</span> 当然某些 <span class="math inline">\(a_i\)</span> 可以是 <span class="math inline">\(0\)</span>。我们称上面这个表达式中非零项的个数为<span class="math inline">\(x\)</span> 的长度。</p><p>设 <span class="math inline">\(I\ne(0)\)</span> 是 <span class="math inline">\(A\otimes B\)</span>的双边理想，取其中长度最小的非零元素 <span class="math inline">\(x\)</span>，不妨假设 <span class="math display">\[x= a_1\otimes b_1+a_2\otimesb_2+\cdots+a_r\otimes b_r,\quad 0&lt;r\leq m.\]</span> 于是每个 <span class="math inline">\(a_i\)</span> 都不是 <span class="math inline">\(0\)</span>，特别 <span class="math inline">\(a_1\ne0\)</span>。由于 <span class="math inline">\(A\)</span> 是单代数因此 <span class="math inline">\(A=Aa_1A\)</span> （即 <span class="math inline">\(a_1\)</span> 在 <span class="math inline">\(A\)</span> 中生成的双边理想），所以存在一组 <span class="math inline">\(\{c_j, d_j\mid 1\leq j\leq p\}\)</span> 满足 <span class="math display">\[1=\sum_{j=1}^p c_ja_1d_j.\]</span> 由于 <span class="math inline">\(I\)</span> 是双边理想因此每个 <span class="math display">\[(c_j\otimes 1)x(d_j\otimes 1)=(c_ja_1d_j)\otimesb_1+\cdots+(c_ja_rd_j)\otimes b_r\]</span> 都在 <span class="math inline">\(I\)</span> 中，当然它们的和 <span class="math display">\[\begin{aligned}x'&amp;=\left(\sum_{j=1}^p c_ja_1d_j\right)\otimes b_1 + \cdots +\left(\sum_{j=1}^p c_ja_rd_j\right)\otimes b_r \\&amp;=1\otimes b_1 + \cdots + \left(\sum_{j=1}^p c_ja_rd_j\right)\otimesb_r\end{aligned}\]</span> 也在 <span class="math inline">\(I\)</span>中。<span class="math inline">\(x'\)</span> 与 <span class="math inline">\(x\)</span> 有同样的长度但是形如 <span class="math inline">\(x'=1\otimesb_1+\cdots\)</span>，所以我们不妨一开始就假设在 <span class="math inline">\(x\)</span> 的表达式中有 <span class="math inline">\(a_1=1\)</span>。</p><p>任取 <span class="math inline">\(a\in A\)</span>，则 <span class="math display">\[(a\otimes 1)x -x(a\otimes1) =(aa_2-a_2a)\otimesb_2+\cdots+(aa_r-a_ra)\otimes b_r\in I.\]</span> 然而它的长度小于 <span class="math inline">\(r\)</span> 因此必须是 <span class="math inline">\(0\)</span>，即对每个 <span class="math inline">\(i=2,\ldots,r\)</span> 有 <span class="math inline">\(aa_i=a_ia\)</span>，由 <span class="math inline">\(a\)</span> 的任意性可知每个 <span class="math inline">\(a_i\)</span> 都属于 <span class="math inline">\(A\)</span> 的中心 <span class="math inline">\(Z(A)=F\)</span>，因此这些 <span class="math inline">\(a_i\)</span> 可以拿到 <span class="math inline">\(\otimes\)</span> 的右边去： <span class="math display">\[x=1\otimes b_1+\cdots+1\otimesa_rb_r=1\otimes(b_1+a_2b_2+\cdots+a_rb_r)\in I.\]</span> 注意由于 <span class="math inline">\(b_i\)</span> 是线性无关的所以 <span class="math inline">\(b=b_1+a_2b_2+\cdots+a_rb_r\ne0\)</span>。</p><p>总之我们证明了在 <span class="math inline">\(I\)</span>中存在一个形如 <span class="math inline">\(1\otimes b\)</span>的元素。</p><p><strong>第二步：<span class="math inline">\(A\otimes B\)</span>是单代数</strong></p><p>由 <span class="math inline">\(1\otimes b\in I\)</span> 且 <span class="math inline">\(B= BbB\)</span>，我们得出 <span class="math display">\[I\supset (1\otimes B)1\otimes b(1\otimesB)=1\otimes BbB=1\otimes B.\]</span> 从而 <span class="math display">\[I\supset (A\otimes1)(1\otimes B)=A\otimesB.\]</span> 这就证明了 <span class="math inline">\(I=A\otimesB\)</span>，即 <span class="math inline">\(A\otimes B\)</span>是单代数。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在上面的证明中，我们只用到了 <span class="math inline">\(A\)</span> 是中心单代数和 <span class="math inline">\(B\)</span> 是单代数作为条件，即只要 <span class="math inline">\(A,B\)</span>中一个是单代数，另一个是中心单代数，则 <span class="math inline">\(A\otimes B\)</span> 就是单代数。这个结论对 <span class="math inline">\(A,B\)</span> 都是单代数的情形是不成立的，比如<span class="math inline">\(\mathbb{C}\)</span> 是 <span class="math inline">\(\mathbb{R}\)</span> 上的单代数但不是中心单的，这时<span class="math inline">\(\mathbb{C}\otimes_\mathbb{R}\mathbb{C}\cong\mathbb{C}\oplus\mathbb{C}\)</span> 就不是单代数。</p></div><p><strong>第三步：<span class="math inline">\(Z(A\otimesB)=F\)</span></strong></p><div id="C-otimes-D" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A,B\)</span> 是域 <span class="math inline">\(F\)</span> 上的代数，<span class="math inline">\(R\subset A\)</span> 和 <span class="math inline">\(S\subset B\)</span> 分别是子代数，则 <span class="math inline">\(R\otimes S\)</span> 在 <span class="math inline">\(A\otimes B\)</span> 中的中心化子是 <span class="math inline">\(C_{A\otimes B}(R\otimes S)=C_A(R)\otimesC_B(S)\)</span>。也就是分别取 <span class="math inline">\(R,S\)</span>在 <span class="math inline">\(A,B\)</span>里的中心化子，然后作张量积。</p></div><p>特别地取 <span class="math inline">\(R=A,S=B\)</span> 我们有 <span class="math inline">\(Z(A\otimes B)=Z(A)\otimes Z(B)\)</span>。</p><p>当 <span class="math inline">\(A,B\)</span> 都是中心单代数时，由<span class="math inline">\(Z(A)\otimes Z(B)=F\otimes F\cong F(1\otimes1)\)</span> 即得 <a href="#A-otimes-B" title="定理 1.2">定理 1.2</a>结论。</p><p><a href="#C-otimes-D" title="引理 1.3">引理 1.3</a> 的证明：<span class="math inline">\(C_{A\otimes B}(R\otimes S)\supseteq C_A(R)\otimesC_B(S)\)</span> 是显然的，只要再证明反向的包含关系。</p><p>仍然固定 <span class="math inline">\(B\)</span> 的一组基 <span class="math inline">\(\{b_1,\ldots,b_m\}\)</span>，任何 <span class="math inline">\(z\in C_{A\otimes B}(R\otimes S)\)</span>可以唯一地写成 <span class="math display">\[z= a_1\otimes b_1+a_2\otimesb_2+\cdots+a_m\otimes b_m.\]</span> 由于 <span class="math inline">\(z\)</span> 和 <span class="math inline">\(R\otimesS\)</span> 交换，当然也就和 <span class="math inline">\(R\otimes1\)</span> 交换，所以对任何 <span class="math inline">\(r\in R\)</span>有 <span class="math display">\[(r\otimes1)z-z(r\otimes1)=\sum_{i=1}^m(ra_i-a_ir)\otimesb_i=0.\]</span></p><p>由于 <span class="math inline">\(b_i\)</span> 线性无关，因此每个<span class="math inline">\(ra_i=a_ir\)</span>，由 <span class="math inline">\(r\)</span> 的任意性有 <span class="math inline">\(a_i\in C_A(R)\)</span>。设 <span class="math inline">\(\{x_1,\ldots,x_k\}\)</span> 是 <span class="math inline">\(C_A(R)\)</span> 的一组基，再将每个 <span class="math inline">\(a_i\)</span> 表示为 <span class="math inline">\(\{x_1,\ldots,x_k\}\)</span> 的线性组合，我们得到<span class="math inline">\(z\)</span> 形如 <span class="math display">\[z=a_1\otimes b_1+a_2\otimes b_2+\cdots+a_m\otimesb_m=x_1\otimes b_1'+\cdots + x_kb_k'.\]</span> 其中每个 <span class="math inline">\(b_k'\in B\)</span>。进一步由于 <span class="math inline">\(z\)</span> 也和任何形如 <span class="math inline">\(1\otimes s,s\in S\)</span> 的元素交换，所以 <span class="math display">\[(1\otimes s)z-z(1\otimess)=\sum_{i=1}^kx_i\otimes (sb_i'-b_i's)=0.\]</span> 由于 <span class="math inline">\(x_i\)</span> 线性无关，所以每个 <span class="math inline">\(sb_i'-b_i's=0\)</span>，由 <span class="math inline">\(s\)</span> 的任意性可得 <span class="math inline">\(b_i'\in C_B(S)\)</span>。从而 <span class="math display">\[z=x_1\otimes b_1'+\cdots + x_rb_r'\inC_A(R)\otimes C_B(S).\]</span> 反向包含得证。<span class="math inline">\(\blacksquare\)</span></p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的中心单代数，<span class="math inline">\(\dim_F A=n\)</span>，则 <span class="math inline">\(A\otimes A^{\rm op}\cong{\rmMat}_n(F)\)</span>。</p></div><p>背后的道理很简单：<span class="math inline">\(A\)</span> 显然是 <span class="math inline">\((A,A)\)</span>- 双模，从而是一个左 <span class="math inline">\(A\otimes A^{\rm op}\)</span>- 模（回忆一下，<span class="math inline">\((R,S)\)</span>- 双模与左 <span class="math inline">\(R\otimes S^{\rm op}\)</span>-模是一回事），即存在代数同态 <span class="math display">\[A\otimesA^{\rm op}\to \mathrm{End}_F(A).\]</span> （<span class="math inline">\(M\)</span> 是左 <span class="math inline">\(R\)</span>- 模当且仅当存在环同态 <span class="math inline">\(R\to{\rm End}(M)\)</span>）</p><p>由 <a href="#A-otimes-B" title="定理 1.2">定理 1.2</a> 知道 <span class="math inline">\(A\otimes A^{\rm op}\)</span>是单代数从而这是一个单射，比较维数即得这是一个同构。</p><h1 id="noether-skolem-定理">Noether-Skolem 定理</h1><div id="N-S" class="statement sta_noether_skolem___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Noether-Skolem 定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span>是一个中心单代数，<span class="math inline">\(B\)</span> 是单代数，<span class="math inline">\(f,g\colon\ B\to A\)</span> 是从 <span class="math inline">\(B\)</span> 到 <span class="math inline">\(A\)</span> 的两个代数同态，则存在 <span class="math inline">\(u\in A^{\times}\)</span> 满足 <span class="math display">\[f(b) =u^{-1}g(b)u,\quad \forall b\in B.\]</span>特别的，我们得到中心单代数的自同构都是内自同构。</p></div><p>这个定理背后的想法不难，只是需要一点 Wedderburn-Artin半单代数理论的知识：对于一个单代数 <span class="math inline">\(B\)</span>，在同构意义下 <span class="math inline">\(B\)</span> 只有唯一的不可约模左 <span class="math inline">\(B\)</span>- 模 <span class="math inline">\(V\)</span>。任何左 <span class="math inline">\(B\)</span>- 模都可以分解为若干 <span class="math inline">\(V\)</span> 的直和。两个左 <span class="math inline">\(B\)</span>- 模 <span class="math inline">\(W,W'\)</span> 同构当且仅当它们作为 <span class="math inline">\(F\)</span>- 向量空间的维数相同： <span class="math display">\[W\cong W'\Leftrightarrow\dim_F W=\dim_FW'.\]</span> 所以判断两个 <span class="math inline">\(B\)</span>-模是否同构是很简单的，只看维数就行。</p><p>回到 <a href="#N-S" title="Noether-Skolem 定理">Noether-Skolem定理</a>。我们先处理 <span class="math inline">\(A={\rmMat}_n(F)\)</span> 的情形：我们可以在 <span class="math inline">\(F^n\)</span> 上定义两种不同的 <span class="math inline">\(B\)</span>- 模结构： <span class="math display">\[\begin{aligned}(B,\,\cdot)&amp;:\quad b\cdot x=f(b)x,\\(B,\,\circ)&amp;:\quad b\circ x=g(b)x.\end{aligned}\]</span> 由于 <span class="math inline">\(B\)</span>是单代数，同一个向量空间 <span class="math inline">\(F^n\)</span>上的不同左 <span class="math inline">\(B\)</span>-模结构必然是同构的，因此存在可逆线性变换 <span class="math inline">\(T:F^n\to F^n\)</span> 使得 <span class="math display">\[b\cdot (Tx)=T(b\circ x),\]</span> 即 <span class="math inline">\(f(b)=T^{-1}g(b)T\)</span>，因此在 <span class="math inline">\(A={\rm Mat}_n(F)\)</span> 的情形定理成立。</p><p>对于一般的情形，我们当然要向矩阵代数靠拢。考虑 <span class="math inline">\(A\otimes A^{\rm op}\)</span> 的两个单子代数 <span class="math inline">\(f(B)\otimes A^{\rm op}\)</span> 和 <span class="math inline">\(g(B)\otimes A^{\rm op}\)</span>。由于 <span class="math inline">\(A\otimes A^{\rm op}\cong{\rmMat}_n(F)\)</span>，根据我们刚刚证得的结论，存在可逆元 <span class="math inline">\(T \in (A\otimes A^{\rm op})^\times\)</span>满足对任何 <span class="math inline">\(b\otimes a^{\rm op}\)</span> 有<span class="math display">\[f(b)\otimes a^{\rm op}=T^{-1}(g(b)\otimesa^{\rm op})T. \tag{$\ast$}\label{ast}\]</span> 取 <span class="math inline">\(b=1\)</span> 代入上式有 <span class="math display">\[1\otimes a^{\rm op}=T^{-1}(1\otimes a^{\rmop})T.\]</span> 即 <span class="math inline">\(T\)</span> 与 <span class="math inline">\(1\otimes A^{\rm op}\)</span> 交换。于是根据 <a href="#C-otimes-D" title="引理 1.3">引理 1.3</a>，<span class="math inline">\(T\in A\otimes1\)</span>，从而存在 <span class="math inline">\(u\in A\)</span> 使得 <span class="math inline">\(T=u\otimes1\)</span>，<span class="math inline">\(T\in (A\otimes A^{\rm op})^\times\)</span> 说明<span class="math inline">\(u\in A^{\times}\)</span>，代入到 <span class="math inline">\(\ref{ast}\)</span> 中去即得 <span class="math inline">\(f(b)=u^{-1}g(b)u\)</span>。<span class="math inline">\(\blacksquare\)</span></p><h1 id="双重中心化子定理">双重中心化子定理</h1><div id="------------------------" class="statement sta_________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">双重中心化子定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span>是 <span class="math inline">\(F\)</span> 上的中心单代数，<span class="math inline">\(B\)</span> 是 <span class="math inline">\(A\)</span> 的单子代数，<span class="math inline">\(C\)</span> 是 <span class="math inline">\(B\)</span> 在 <span class="math inline">\(A\)</span> 中的中心化子： <span class="math display">\[C=C_A(B)=\{ c\in A:\ cb=bc,\ \forall b\inB\}.\]</span> 则以下结论成立：</p><ol type="1"><li><span class="math inline">\(C\)</span> 也是 <span class="math inline">\(A\)</span> 的单子代数。</li><li><span class="math inline">\(\dim_F A=(\dim_F B)(\dim_FC)\)</span>。</li><li><span class="math inline">\(C\)</span> 的中心化子是 <span class="math inline">\(B\)</span>。</li></ol></div><p><strong>证明</strong>：整个证明都包含在下图中 （<span class="math inline">\(i\)</span> 是嵌入映射）：</p><p><span class="math display">\[\require{amsCd}\begin{CD}B\otimes1 @&gt;{i}&gt;&gt; A\otimes\mathrm{End}_F(B) @&lt;{i}&lt;&lt;1\otimes l(B)\\@V{\rm centralizer}VV @. @VV{\rm centralizer}V \\C\otimes\mathrm{End}_F(B) @&gt;{i}&gt;&gt; A\otimes\mathrm{End}_F(B)@&lt;{i}&lt;&lt; A\otimes r(B)\end{CD}\]</span></p><p>我来解释：<span class="math inline">\(A\otimes\mathrm{End}_F(B)\)</span>是中心单代数，它有两个子代数 <span class="math inline">\(B\otimes1\)</span> 和 <span class="math inline">\(1\otimes l(B)\)</span>，这里<span class="math inline">\(l(B)\)</span> 是 <span class="math inline">\(B\)</span> 在自身上的左乘。它们都同构于单子代数<span class="math inline">\(B\)</span>，因此 Noether-Skolem定理断言它俩是共轭的，于是它俩在 <span class="math inline">\(A\otimes\mathrm{End}_F(B)\)</span>中的中心化子也是共轭的。利用 <a href="#C-otimes-D" title="引理 1.3">引理1.3</a> 的结论，对它俩在 <span class="math inline">\(A\otimes\mathrm{End}_F(B)\)</span>中分别求中心化子，得到 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span> 和 <span class="math inline">\(A\otimes r(B)\)</span> 是共轭的。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span><span class="math inline">\(l(B)\)</span> 在 <span class="math inline">\(\mathrm{End}_F(B)\)</span> 中的中心化子是 <span class="math inline">\(r(B)\)</span>，即 <span class="math inline">\(B\)</span> 在自身上的右乘。<span class="math inline">\(r(B)\)</span> 同构于 <span class="math inline">\(B\)</span> 的反环 <span class="math inline">\(B^{\rm op}\)</span>。</p></div><p>由 <a href="#A-otimes-B" title="定理 1.2">定理 1.2</a> <span class="math inline">\(A\otimes r(B)\)</span> 是单代数，于是 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span>也是单代数，从而 <span class="math inline">\(C\)</span> 必须是单代数（否则若 <span class="math inline">\(C\)</span> 有非平凡理想 <span class="math inline">\(I\)</span> 则 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span> 有理想 <span class="math inline">\(I\otimes\mathrm{End}_F(B)\)</span>），这证明了1。</p><p>由于 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span>和 <span class="math inline">\(A\otimes r(B)\)</span>共轭，所以它们的维数相等，即 <span class="math display">\[(\dim_F C)(\dim_F B)^2=(\dim_F A)(\dim_F B),\]</span> 从而 <span class="math inline">\((\dim_F C)(\dim_F B)=\dim_F A\)</span>，这证明了2。</p><p>最后设 <span class="math inline">\(C\)</span> 的中心化子为 <span class="math inline">\(C_A(C)\)</span>，对单子代数 <span class="math inline">\(C\)</span> 应用结论 2， <span class="math display">\[\dim_F C =\frac{\dim_F A}{\dim_FC_A(C)}=\frac{\dim_F A}{\dim_F B}.\]</span> 即 <span class="math inline">\(\dim_F C_A(C)=\dim_F B\)</span>。然而 <span class="math inline">\(B\subsetC_A(C)\)</span>，二者维数相同因此必然相等，3 得证。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Jacobson_alg" class="csl-entry" role="listitem">Jacobson, Nathan. 1980. <em>Basic Algebra. <span>II</span></em>. SanFrancisco, Calif.: W. H. Freeman; Co.</div></div>]]></content>
      
      
      <categories>
          
          <category> 有限群表示与结合代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jordan 标准形</title>
      <link href="/jordan-canonical-form/"/>
      <url>/jordan-canonical-form/</url>
      
        <content type="html"><![CDATA[<p>Jordan标准形定理是线性代数中的基本定理，你可能会好奇，这么一个老掉牙的，在无数教材和讲义中都可以找到的定理，还能写出什么新意来呢？</p><p>理由有两个。第一个是我曾经在做助教给学生讲这个定理的时候，突然发现不知道该怎么启发他们为好。虽然我知道Jordan标准形定理的很多种证法，照念几个不在话下，但是感觉很不自然：为什么要引入Jordan块？这些块究竟代表了什么？怎么才能说清定理背后的想法，让学生觉得定理的成立是顺理成章的呢？于是我知道我对这个定理的理解还有模糊的地方。</p><p>第二个原因是 Jordan块有一个重要的代数性质是通常教材中不讲的，而这个性质是代数学中一类重要而常见的性质的雏形，这就是不可分解性。与之对应的是可对角化的线性变换的完全可约性。从一开始就让学生接触这些现象是有好处的。</p><span id="more"></span><h1 id="什么是-jordan-标准形">什么是 Jordan 标准形</h1><p>你肯定知道，整数环和多项式环有唯一因子分解定理：每个整数可以唯一地分解为素数的乘积，每个域上的多项式可以唯一地分解为不可约多项式的乘积。数学里面有很多这样的唯一分解定理，现在我们想问：有没有所谓的“线性变换的唯一分解定理”呢？可以猜测如果有这样的定理存在，那么大概可以表述为如下的样子：</p><div id="unique-1" class="statement sta____________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">线性变换的唯一分解定理</span>.</span><span class="statement-spah"> </span>（粗糙的版本）：设 <span class="math inline">\(V\)</span> 是域 <span class="math inline">\(F\)</span> 上的有限维向量空间，<span class="math inline">\(T\)</span> 是 <span class="math inline">\(V\)</span> 上的线性变换，则 <span class="math inline">\(T\)</span>可以唯一地分解为若干个「简单的」线性变换，而这些「简单的」线性变换本身不能再分解。</p></div><p>虽然这个表述还很不清楚，但是已经抓住了 Jordan 标准形的核心思想。</p><p>不过我们需要先说清楚，什么是线性变换的分解？什么是不可分解的线性变换？这就要借助直和的概念：</p><div class="statement simple plain unnumbered"><p>设 <span class="math inline">\(T\)</span> 是向量空间 <span class="math inline">\(V\)</span> 上的线性变换，如果 <span class="math inline">\(V\)</span> 可以分解为一些非平凡的子空间的直和<span class="math inline">\(V=V_1\oplus\cdots\oplusV_k\)</span>，使得每一个 <span class="math inline">\(V_i\)</span> 都是<span class="math inline">\(T\)</span>- 不变的子空间，则称 <span class="math inline">\(T\)</span> 是可以分解的；如果 <span class="math inline">\(V\)</span> 不存在这样的分解，则称 <span class="math inline">\(T\)</span> 是不可分解的线性变换。</p></div><p>现在我们可以比较准确的表述线性变换的唯一分解定理了：</p><div id="unique-2" class="statement sta____________-1 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">线性变换的唯一分解定理</span>.</span><span class="statement-spah"> </span>（修正的版本）：设 <span class="math inline">\(V\)</span> 是域 <span class="math inline">\(F\)</span> 上的有限维向量空间，<span class="math inline">\(T\)</span> 是 <span class="math inline">\(V\)</span> 上的线性变换，则 <span class="math inline">\(V\)</span> 可以分解为若干个 <span class="math inline">\(T\)</span>- 不变子空间的直和 <span class="math inline">\(V=V_1\oplus\cdots\oplus V_k\)</span>，<span class="math inline">\(T\)</span> 限制在每个 <span class="math inline">\(V_i\)</span>上是不可分解的线性变换。这个分解还是唯一的，即如果 <span class="math inline">\(V=W_1\oplus\cdots\oplus W_l\)</span>是另一种分解，则 <span class="math inline">\(k=l\)</span>且适当重排以后，对每个 <span class="math inline">\(i\)</span>，<span class="math inline">\(T\)</span> 在 <span class="math inline">\(V_i\)</span> 上的限制与 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(W_i\)</span> 上的限制是相似的。</p></div><p>这里有一个重要的问题需要说明：在一般的域上研究不可分解的线性变换是一个棘手的多的问题，这个问题的解决要用到Frobenius 有理标准形，而在复数域上问题就简单很多，这就是 Jordan标准形做的事情。在本文中我们都在复数域上讨论。</p><p>那么什么样的线性变换算是不可分解的线性变换呢？</p><p>最简单也是最重要的例子就是移位算子：假设 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(V\)</span> 的一组基 <span class="math inline">\(\{v_1,\cdots,v_n\}\)</span>的作用是一个向右的移位： <span class="math display">\[T:\quadv_n\rightarrow v_{n-1}\rightarrow\cdots\rightarrowv_1\rightarrow0.\]</span> 则称 <span class="math inline">\(T\)</span>是一个移位算子。<span class="math inline">\(T\)</span>在这组基下的矩阵为 <span class="math inline">\(J_0\)</span>: <span class="math display">\[(v_1, v_2, \ldots, v_n)J_0 = (0, v_1, \ldots,v_{n-1}),\quad J_0=\begin{pmatrix}0&amp;1&amp;&amp;\\ &amp;\ddots&amp;\ddots &amp;\\ &amp;&amp;0&amp;1\\&amp;&amp;&amp;0\end{pmatrix}.\]</span></p><p><span class="math inline">\(J_0\)</span> 叫做特征值为 0 的 Jordan块。注意 <span class="math inline">\(T\)</span> 是一个幂零算子：<span class="math inline">\(T^n=0\)</span>，它仅有唯一的特征值 0。</p><p>为什么 <span class="math inline">\(T\)</span> 是不可分解的？假设<span class="math inline">\(V=U\oplus W\)</span> 是两个非平凡 <span class="math inline">\(T\)</span>- 不变子空间的直和，则 <span class="math inline">\(T\)</span> 作为 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(W\)</span> 上的幂零线性变换必然各有一个特征值为 0的特征向量，因此齐次线性方程组 <span class="math inline">\(TX=0\)</span>的解空间至少包含两个线性无关的向量。但是 <span class="math inline">\(T\)</span> 的秩是 <span class="math inline">\(n-1\)</span>，所以 <span class="math inline">\(TX=0\)</span> 的解空间是 1维的，这就导致了矛盾。</p><p>现在我们做个小变化。把 <span class="math inline">\(T\)</span> 改成<span class="math inline">\(S=T+\lambdaI\,(\lambda\in\mathbb{C})\)</span>，<span class="math inline">\(S\)</span> 对应的矩阵 <span class="math display">\[J_\lambda=\begin{pmatrix}\lambda&amp;1&amp;&amp;\\&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\lambda&amp;1\\&amp;&amp;&amp;\lambda\end{pmatrix}\]</span>叫做特征值为 <span class="math inline">\(\lambda\)</span> 的 Jordan块。<span class="math inline">\(S\)</span>也是不可分解的线性变换，道理完全相同，它的秩是 <span class="math inline">\(n-1\)</span>，只有唯一的特征值 <span class="math inline">\(\lambda\)</span>，所以 <span class="math inline">\(V\)</span> 不可能分解成两个非平凡 <span class="math inline">\(S\)</span>- 不变子空间的直和。　</p><p>Jordan块是我们在线性变换的世界中找到的“原子”，是那些不能再分解的变换。那是不是每个线性变换都可以拆成若干个Jordan 块呢？答案是肯定的：</p><div id="jordan-canonical" class="unnumbered statement sta_jordan______ plain"><p><span class="statement-heading"><span class="statement-label">Jordan标准形定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span> 上有限维向量空间 <span class="math inline">\(V\)</span> 上的线性变换，则存在 <span class="math inline">\(V\)</span> 的一组基使得 <span class="math inline">\(T\)</span> 在这组基下的矩阵为 Jordan 块的直和：<span class="math display">\[T=J_{\lambda_1}\oplus\cdots\oplusJ_{\lambda_r}.\]</span>如果不在乎块的排列顺序，那么这种分解就是唯一的，即如果存在 <span class="math inline">\(V\)</span> 的另一组基使得 <span class="math inline">\(T\)</span> 的矩阵也是 Jordan 块的直和 <span class="math display">\[T=J_{\mu_1}\oplus\cdots\oplus J_{\mu_s},\]</span>则 <span class="math inline">\(r=s\)</span> 且适当重排后有 <span class="math inline">\(J_{\lambda_i}=J_{\mu_i}\)</span>。</p></div><h1 id="jordan-标准形定理的证明">Jordan 标准形定理的证明</h1><p>定理的结论包含存在性和唯一性两部分，我们先来处理存在性的证明。</p><h2 id="分解存在性-1转化为幂零的情形">分解存在性1：转化为幂零的情形</h2><p>我们之前提到了幂零的 Jordan 标准形 <span class="math inline">\(J_0\)</span>，它是最简单的 Jordan 标准形，只有<span class="math inline">\(n-1\)</span> 个 <span class="math inline">\(1\)</span> 在对角线上方，其余位置都是 <span class="math inline">\(0\)</span>。但实际上，任何线性变换都可以通过一个叫做<strong>准素分解定理（PrimaryDecomposition）</strong>的东西，拆成若干“只有单一特征值”的部分，每个部分再减去那个特征值，就成了幂零算子。所以本质上，Jordan标准形定理等价于证明“任何幂零线性变换总是可以分解为一些零特征值的 Jordan块的直和”。</p><div id="primary-decomposition" class="unnumbered statement sta_______ plain"><p><span class="statement-heading"><span class="statement-label">准素分解定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(T\)</span>的特征多项式为 <span class="math inline">\(f(x)\)</span>，且 <span class="math inline">\(f(x)\)</span> 在复数域上分解为一次因式的乘积 <span class="math display">\[f(x)=(x-\lambda_1)^{n_1}\cdots(x-\lambda_k)^{n_k},\]</span>这里的 <span class="math inline">\(\lambda_i\)</span> 互不相同。令 <span class="math inline">\(V_i=\mathrm{Ker}(T-\lambda_i I)^{n_i}\)</span>，则每个 <span class="math inline">\(V_i\)</span> 都是 <span class="math inline">\(T\)</span>- 不变子空间而且 <span class="math display">\[V=V_1\oplus\cdots\oplus V_m.\]</span></p></div><p><strong>证明</strong>：我们从一个简单的引理出发：</p><div id="coprime" class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(T\)</span> 是域 <span class="math inline">\(F\)</span> 上有限维向量空间 <span class="math inline">\(V\)</span> 上的线性变换，<span class="math inline">\(p(x),q(x)\in F[x]\)</span>是两个互素的多项式，且有 <span class="math inline">\(p(T)\cdotq(T)=0\)</span>。则 <span class="math inline">\(V=\mathrm{Ker}p(T)\oplus\mathrm{Ker}q(T)\)</span>。</p></div><p>引理的证明：由于 <span class="math inline">\(p(x),q(x)\)</span>是互素的多项式，所以存在多项式 <span class="math inline">\(s(x),t(x)\)</span> 满足 <span class="math display">\[s(x)p(x)+t(x)q(x)=1.\]</span> 即 <span class="math display">\[s(T)p(T)+t(T)q(T)=I.\]</span> 于是对任何 <span class="math inline">\(v\in V\)</span> 有 <span class="math display">\[v= \underbrace{s(T)p(T)v}_{\in\mathrm{Ker}q(T)} +\underbrace{t(T)q(T)v}_{\in\mathrm{Ker}p(T)}.\]</span> 这说明 <span class="math inline">\(V = \mathrm{Ker}p(T) +\mathrm{Ker}q(T)\)</span>。要验证这是直和，不妨设 <span class="math inline">\(v\in\mathrm{Ker}p(T)\cap\mathrm{Ker}q(T)\)</span>，则<span class="math inline">\(p(T)v=q(T)v=0\)</span>，于是 <span class="math display">\[v =s(T)p(T)v+t(T)q(T)v = 0.\]</span></p><p>把引理的结论反复应用在 <span class="math inline">\(f(x)\)</span>上即可得出准素分解定理。<span class="math inline">\(\blacksquare\)</span></p><h2 id="分解存在性-2证明幂零的情形">分解存在性 2：证明幂零的情形</h2><p>借助 <a href="#primary-decomposition" title="准素分解定理">准素分解定理</a>，我们把分解存在性转化为论证若<span class="math inline">\(N\)</span> 是某个向量空间 <span class="math inline">\(V\)</span> 上的幂零线性变换，则存在 <span class="math inline">\(V\)</span> 的一组基，使得 <span class="math inline">\(N\)</span> 在这组基下的矩阵是若干零特征值 Jordan块 <span class="math inline">\(J_0\)</span> 的和。注意一个 Jordan块对应的是一个链 <span class="math display">\[v\rightarrow Nv\rightarrow\cdots \rightarrow N^kv\rightarrow 0.\]</span>我们要证明存在若干条这样的互不相交的链，这些链所包含的全部非零向量构成<span class="math inline">\(V\)</span> 的一组基。</p><p>这一步的证明方法很多，但是相差不是很大，具体喜欢那种要看个人主观，这里介绍的是最简单也是最容易被初学者接受的一种。</p><p>对 <span class="math inline">\(V\)</span> 的维数 <span class="math inline">\(\dim V\)</span> 归纳，<span class="math inline">\(\dim V=1\)</span> 时显然结论成立。</p><p>现假设结论对所有维数小于 <span class="math inline">\(\dim V\)</span>的向量空间成立，考虑 <span class="math inline">\(V\)</span> 的像空间<span class="math inline">\(\mathrm{Im}(V)\)</span>。这是一个 <span class="math inline">\(N\)</span>- 不变子空间，且由于 <span class="math inline">\(N\)</span> 是幂零线性变换所以 <span class="math inline">\(\dim \mathrm{Im}(V)&lt;\dim V\)</span>，所以可以对<span class="math inline">\(\mathrm{Im}(V)\)</span> 使用归纳假设：存在<span class="math inline">\(\mathrm{Im}(V)\)</span>的一组基如下，它们构成 <span class="math inline">\(q\)</span>条不相交的链 <span class="math inline">\(\mathcal{O}_1,\cdots,\mathcal{O}_q\)</span>：</p><p><span class="math display">\[\begin{array}{l}&amp;v_{1,1}\rightarrowv_{1,2}\rightarrow\cdots\rightarrow v_{1,n_1}\rightarrow0.\\&amp;v_{2,1}\rightarrow v_{2,2}\rightarrow\cdots\rightarrowv_{2,n_2}\rightarrow 0.\\&amp;\cdots\\&amp; v_{q,1}\rightarrowv_{q,2}\rightarrow\cdots\rightarrow v_{q,n_q}\rightarrow0.\end{array}\]</span></p><p>由于 <span class="math inline">\(v_{i,1}\in \mathrm{Im}(V)\)</span>因此可以设 <span class="math inline">\(v_{i,1}=Nw_i\)</span>，从而我们得到一组更长的链（就是在前面加上一项）</p><p><span class="math display">\[\begin{array}{l}&amp;w_1\rightarrowv_{1,1}\rightarrow v_{1,2}\rightarrow\cdots\rightarrowv_{1,n_1}\rightarrow 0.\\&amp;w_2\rightarrow v_{2,1}\rightarrowv_{2,2}\rightarrow\cdots\rightarrow v_{2,n_2}\rightarrow0.\\&amp;\cdots\cdots\cdots\\&amp;w_q\rightarrow v_{q,1}\rightarrowv_{q,2}\rightarrow\cdots\rightarrow v_{q,n_q}\rightarrow0.\end{array}\]</span></p><p>那么这些新链包含的向量是否构成 <span class="math inline">\(V\)</span>的一组基？答案是我们还要补上一些在 <span class="math inline">\(V\)</span> 中长度是 1，但是在 <span class="math inline">\(\mathrm{Im}(V)\)</span> 中“消失”了的链：注意 <span class="math inline">\(\{v_{1,n_1},\cdots,v_{q,n_q}\}\)</span> 是 <span class="math inline">\(\mathrm{Ker}N\)</span> 中的线性无关元，但是 <span class="math inline">\(\mathrm{Ker}N\)</span>还可能有其它的基向量。将它们扩充为 <span class="math inline">\(\mathrm{Ker}N\)</span> 的一组基</p><p><span class="math display">\[\{ v_{1,n_1},\cdots,v_{q,n_1}\}\cup \{w_{q+1},\cdots,w_{K}\},\quad K=\dim\mathrm{Ker}N.\]</span></p><p>从而我们最终得到下面的链图：</p><p><span class="math display">\[\begin{array}{r}\mathbf{w_1}\rightarrowv_{1,1}\rightarrow v_{1,2}\rightarrow\cdots\rightarrowv_{1,n_1}\rightarrow 0.&amp;\\\mathbf{w_2}\rightarrow v_{2,1}\rightarrowv_{2,2}\rightarrow\cdots\rightarrow v_{2,n_2}\rightarrow0.&amp;\\\cdots\cdots\cdots&amp;\\\mathbf{w_q}\rightarrowv_{q,1}\rightarrow v_{q,2}\rightarrow\cdots\rightarrowv_{q,n_q}\rightarrow 0.&amp;\\\mathbf{w_{q+1}}\rightarrow0.&amp;\\\cdots\cdots&amp;\\\mathbf{w_K}\rightarrow0.\end{array}\]</span></p><p>你可以看到 <span class="math inline">\(w_{q+1},\ldots,w_K\)</span>正是那些在 <span class="math inline">\(V\)</span> 中长度为 1，但是在<span class="math inline">\(\mathrm{Im}(V)\)</span>中「消失」了的链。</p><p>最后只剩下验证这些向量确实构成 <span class="math inline">\(V\)</span>的一组基。显然这些向量一共有 <span class="math display">\[\dim\mathrm{Im}(V)+\dim\mathrm{Ker}N=\dim V\]</span>个，所以只要再说明它们是线性无关的。</p><p>假设有线性关系</p><p><span class="math display">\[\cdots+(c_0w_i+c_1v_{i,1}+\cdots+c_{n_i}v_{i,n_i})+\cdots+\sum_{j=q+1}^Kd_jw_j=0,\]</span></p><p>我们要说明出现在上式中的所有系数 <span class="math inline">\(c_i,d_j\)</span> 都是 0。左边用 <span class="math inline">\(N\)</span> 作用得到</p><p><span class="math display">\[\cdots+(c_0v_{i,1}+c_1v_{i,2}+\cdots+c_{n_i-1}v_{i,n_i})+\cdots=0.\]</span></p><p>这是一个关于 <span class="math inline">\(\mathrm{Im}(V)\)</span>的一组基的一个线性关系，于是 <span class="math inline">\(c_0=\cdots=c_{n_i-1}=0\)</span>，从而剩下的线性关系为</p><p><span class="math display">\[\cdots+c_{n_i}v_{i,n_i}+\cdots+\sum_{j=q+1}^Kd_jw_j=0.\]</span></p><p>而这是一个关于 <span class="math inline">\(\mathrm{Ker}N\)</span>的一组基的一个线性关系，于是 <span class="math inline">\(c_{n_i}=d_{q+1}=\cdots=d_K=0\)</span>，从而所有的系数都是0，这就完成了 Jordan 标准形存在性的证明。</p><h2 id="分解唯一性的证明">分解唯一性的证明</h2><p>要证明分解的唯一性，我们只要证明任何幂零线性变换 <span class="math inline">\(N\)</span> 分解为 Jordan 块的方式是唯一的。根据Jordan 标准形存在性的证明，我们有如下的链图： <span class="math display">\[\begin{array}{r}v_{1,1}\rightarrowv_{1,2}\rightarrow\cdots\rightarrow v_{1,n_1}\rightarrow0.&amp;\\v_{2,1}\rightarrow v_{2,2}\rightarrow\cdots\rightarrowv_{2,n_2}\rightarrow 0.&amp;\\\cdots\cdots&amp;\\ v_{q,1}\rightarrowv_{q,2}\rightarrow\cdots\rightarrow v_{q,n_q}\rightarrow0.\end{array}\]</span> 这里每个链代表一个 Jordan 块，按照 <span class="math inline">\(n_1\geq\cdots\geq n_q\)</span>的顺序排列。我们要证明链图中行数 <span class="math inline">\(q\)</span>和行的长度 <span class="math inline">\((n_1,\ldots,n_q)\)</span>都是唯一确定的，不依赖于基的选择。</p><p>我用一个具体的例子来说明：</p><p><span class="math display">\[\begin{array}{r}\bullet\rightarrow {\color{blue}{\bullet}}\rightarrow{\color{green}{\bullet}}\rightarrow{\color{red}{\bullet}}\rightarrow 0.\\{\color{blue}{\bullet}}\rightarrow{\color{green}{\bullet}}\rightarrow{\color{red}{\bullet}}\rightarrow0.&amp;\\{\color{green}{\bullet}}\rightarrow{\color{red}{\bullet}}\rightarrow0.&amp;\\{\color{red}{\bullet}}\rightarrow 0.\\{\color{red}{\bullet}}\rightarrow 0.\end{array}\]</span></p><p>注意到在链图中，从右边数起，从第 <span class="math inline">\(1\)</span> 到第 <span class="math inline">\(i\)</span> 列，都会被 <span class="math inline">\(N^i\)</span> 变成零向量。这些向量构成了 <span class="math inline">\(\mathrm{Ker}N^i\)</span>的一组基。例如在上面例子中，<span class="math inline">\(\{{\color{red}{\bullet}} \}\)</span> 的列构成了 <span class="math inline">\(\mathrm{Ker}N\)</span> 的一组基，<span class="math inline">\(\{ {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}\)</span> 的列构成了 <span class="math inline">\(\mathrm{Ker}N^2\)</span> 的一组基，等等。</p><p>于是我们有子空间的升链： <span class="math display">\[(0)\subset\underbrace{\mathrm{Ker}N}_{\{ {\color{red}{\bullet}} \}}\subset\underbrace{\mathrm{Ker}N^2}_{\{ {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}} \subset \underbrace{\mathrm{Ker}N^3}_{\{{\color{blue}{\bullet}}\mid {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}} \subset \underbrace{\mathrm{Ker}N^4}_{\{\bullet\mid {\color{blue}{\bullet}}\mid {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}}=V.\]</span> 不难看到右边的第 <span class="math inline">\(i\)</span> 列正好构成商空间 <span class="math inline">\(\mathrm{Ker}N^{i}/\mathrm{Ker}N^{i-1}\)</span>的一组基。 <span class="math display">\[\begin{aligned}\mathrm{Ker}N: \quad &amp;  \{ {\color{red}{\bullet}} \}\\\mathrm{Ker}N^2/\mathrm{Ker}N: \quad &amp; \{ {\color{green}{\bullet}}\}\\\mathrm{Ker}N^3/\mathrm{Ker}N^2: \quad &amp; \{ {\color{blue}{\bullet}}\}\\\mathrm{Ker}N^4/\mathrm{Ker}N^3=U/\mathrm{Ker}N^3: \quad &amp; \{\bullet \}\\\end{aligned}\]</span> 所以右边第 <span class="math inline">\(i\)</span> 列的长度等于<span class="math inline">\(\dim\mathrm{Ker}N^i -\dim\mathrm{Ker}N^{i-1}\)</span>。</p><p>另一方面右边第 <span class="math inline">\(i\)</span>列的长度还等于“长度 <span class="math inline">\(\geq i\)</span>的链的个数”。所以长度恰好等于 <span class="math inline">\(i\)</span>的链，即 <span class="math inline">\(i\)</span> 阶 Jordan 块的个数，等于<span class="math display">\[\begin{aligned}&amp;(\dim\mathrm{Ker}N^i -\dim\mathrm{Ker}N^{i-1})-(\dim\mathrm{Ker}N^{i+1} -\dim\mathrm{Ker}N^i)\\=&amp;\,2\dim\mathrm{Ker}N^i -\dim\mathrm{Ker}N^{i-1}-\dim\mathrm{Ker}N^{i+1}.\end{aligned}\]</span>这是一个由 <span class="math inline">\(N\)</span>完全确定的值。这就证明了分解的唯一性。</p><h1 id="进一步的思考">进一步的思考</h1><p>一个很有意思的问题是，给定</p><p><span class="math display">\[J_\lambda=\begin{pmatrix}\lambda&amp;1&amp;&amp;\\&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\lambda&amp;1\\&amp;&amp;&amp;\lambda\end{pmatrix}_{n\timesn}\]</span></p><p>为一个特征值 <span class="math inline">\(\lambda\)</span> 的 Jordan块，计算其 <span class="math inline">\(k\)</span> 次幂 <span class="math inline">\(J_\lambda^k\)</span> 的 Jordan 标准形。</p><p>当 <span class="math inline">\(\lambda\ne0\)</span> 时，</p><p><span class="math display">\[J_\lambda^k = \begin{pmatrix}\lambda^k&amp;k\lambda^{k-1}&amp;\ddots&amp;\\&amp;\lambda^k&amp;\ddots&amp;\ddots\\&amp;&amp;\ddots&amp;k\lambda^{k-1}\\&amp;&amp;&amp;\lambda^k\end{pmatrix}.\]</span></p><p>你知道怎样计算 <span class="math inline">\(J_\lambda^k\)</span>吗？记住这个技巧：把多项式 <span class="math inline">\(x^k\)</span> 在<span class="math inline">\(\lambda\)</span> 处 Taloy 展开：</p><p><span class="math display">\[x^k=(x-\lambda)^k+a_{k-1}(x-\lambda)^{k-1}+a_1(x-\lambda)+a_0,\]</span></p><p>然后代入即可。</p><p>和 Jordan 块不可分解性的证明完全一样，我们发现 <span class="math inline">\(J_\lambda^k-\lambda^k I\)</span> 的秩是 <span class="math inline">\(n-1\)</span>，因此方程组 <span class="math inline">\(J_\lambda^kX=\lambda^k X\)</span> 的解空间是 1维的，从而 <span class="math inline">\(J_\lambda^k\)</span>是不可分解的，因此其 Jordan 标准形只有一块，就是</p><p><span class="math display">\[\begin{pmatrix}\lambda^k&amp;1&amp;&amp;\\&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\lambda^k&amp;1\\&amp;&amp;&amp;\lambda^k\end{pmatrix}_{n\timesn}.\]</span></p><p>最有意思的情形发生在 <span class="math inline">\(\lambda=0\)</span>时，这个时候 Jordan 会均匀的碎裂为一些小的 Jordan 块的和。</p><p>这时 <span class="math inline">\(J_0\)</span> 是一个移位算子：</p><p><span class="math display">\[J_0:\quad v_n\rightarrowv_{n-1}\rightarrow \cdots \rightarrow v_1\rightarrow 0.\]</span></p><p>整个链只有一条。但是 <span class="math inline">\(J_0^k\)</span> 则是<span class="math inline">\(k\)</span> 步 <span class="math inline">\(k\)</span> 步地「跳」：</p><p><span class="math display">\[J_0^k:\quad \left\{\begin{array}{l}v_n\rightarrow v_{n-k}\rightarrow \cdots\rightarrow0,\\v_{n-1}\rightarrow v_{n-1-k}\rightarrow \cdots\rightarrow0,\\\cdots\\v_{n-k+1}\rightarrow v_{n-2k+1}\rightarrow \cdots\rightarrow 0.\end{array}\right.\]</span></p><p>所以 <span class="math inline">\(J_0^k\)</span> 有 <span class="math inline">\(k\)</span> 条链，每个链都是一个 Jordan 块，即<span class="math inline">\(J_0^k\)</span> 的标准形中有 <span class="math inline">\(k\)</span> 个 Jordan 块。设 <span class="math inline">\(n=qk+r\)</span>，这里 <span class="math inline">\(0\leq r&lt; k\)</span>，则这 <span class="math inline">\(k\)</span> 个 Jordan 块中有 <span class="math inline">\(r\)</span> 个是 <span class="math inline">\(q+1\)</span> 阶的，<span class="math inline">\(k-r\)</span> 个是 <span class="math inline">\(q\)</span> 阶的。</p><p>举个例子就明白了，一个 8 阶的 0 特征值 Jordan 块 <span class="math inline">\(J_0\)</span>，<span class="math inline">\(J_0^3\)</span> 的 Jordan标准形是什么样子的？这个时候 <span class="math inline">\(J_0^3\)</span>有 3 个链 <span class="math inline">\(\{v_8,v_5,v_2\}\)</span>, <span class="math inline">\(\{v_7,v_4,v_1 \}\)</span>, <span class="math inline">\(\{v_6,v_3\}\)</span>，所以 <span class="math inline">\(J_0^3\)</span> 的 Jordan 标准形有 2 个 3 阶的Jordan 块和 1 个 2 阶的 Jordan 块。</p><p>总结一下：零特征值的 Jordan块的高次幂一定会分裂，而且是尽可能均匀的分裂；非零特征值的 Jordan块的任意次幂都不会分裂。</p><p>一个不可约的代数结构，在某种限制或者扩张的意义下却能均匀的「碎裂」，这是代数学中一个常见而重要的现象。比如设<span class="math inline">\(f\)</span> 是一个有理数域 <span class="math inline">\(\mathbb{Q}\)</span> 上的不可约多项式，<span class="math inline">\(F\)</span> 是 <span class="math inline">\(\mathbb{Q}\)</span> 的一个正规扩域，则如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(F\)</span> 上是可约的，那么 <span class="math inline">\(f\)</span>必然分解成一些次数相同的多项式的乘积：</p><p><span class="math display">\[f=f_1f_2\cdots f_r,\quad \degf_1=\cdots=\deg f_r.\]</span></p><p>类似的现象还有代数数论中素理想的分解，群表示论中不可约表示（在诱导和限制下） 的分解，代数几何中不可约代数簇的分解等等。</p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>平面分拆的 Macmahon 公式</title>
      <link href="/macmahon-formula-plane-partitions/"/>
      <url>/macmahon-formula-plane-partitions/</url>
      
        <content type="html"><![CDATA[<div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>假设你家的浴室地面是一个边长为 <span class="math inline">\(a\times b\times c\)</span> 的平行六边形（<span class="math inline">\(a,b,c\)</span> 都是正整数），每个内角都是 120度。你订购了一批边长为 1的菱形瓷砖用来铺满整个浴室地面。问：有多少种不同的方法？</p><p><img src="/images/macmahon/hexagon.svg" class="fig" width="400"></p></div><p>你可以试着数一数。但你很快就会放弃，因为只要很小的 <span class="math inline">\(a,b,c\)</span> 就可以数到让你怀疑人生。</p><p>下图是一种密铺的示例：</p><p><img src="/images/macmahon/planepartition.svg" class="fig" width="400"></p><span id="more"></span><p>我们观察这张图，想象在空间中鸟瞰它，发现它很像是在墙角“堆箱子”。不仅如此，箱子的堆放方式还满足规律：从墙角开始，沿着两侧墙壁的方向，箱子的高度是递减的。</p><p>我们把可以把这个堆箱子的方式对应到一个 <span class="math inline">\(a\)</span> 行 <span class="math inline">\(b\)</span> 列的矩阵，其中 <span class="math inline">\(a_{ij}\)</span> 表示地面上第 <span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 列位置箱子的高度（习惯上空白位置的 0不写出来）：</p><table><tbody><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">3</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p><span class="math inline">\(A\)</span> 有如下特点：</p><blockquote><ul><li><span class="math inline">\(A\)</span>的每一行从左到右，每一列从上到下都是递减的。</li><li><span class="math inline">\(a_{ij}\)</span> 都是介于 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(c\)</span>之间的整数（箱子的高度不能超过天花板的高度 <span class="math inline">\(c\)</span>）。</li></ul></blockquote><p>我们把矩阵 <span class="math inline">\(A\)</span> 叫做一个参数为<span class="math inline">\((a,b,c)\)</span>的受限制的<strong>平面分拆</strong>。</p><p>每个受限制的平面分拆都对应一种堆箱子的方式，从而对应六边形的一个菱形密铺。这个对应是一一的。较真的读者可能会说：“且慢，你这只是从视觉直观上看出来菱形密铺和堆箱子是一一对应的，这不够严格吧？”没错，严格的证明是可以有的，但是这里我们的目的是欣赏一处数学奇趣，不必搞得那么学究。</p><p>总之，我们把开头的密铺问题转化为平面分拆的计数问题：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>满足如下两个条件的 <span class="math inline">\(a\)</span> 行 <span class="math inline">\(b\)</span> 列矩阵有多少个？</p><ol type="1"><li>元素都是 <span class="math inline">\([0,c]\)</span>之间的非负整数；</li><li>每一行从左到右，每一列从上到下都是递减的。</li></ol></div><p>设答案为 <span class="math inline">\(M(a,b,c)\)</span>，则我们有一个非常令人吃惊的表达式：</p><div id="macmahon" class="unnumbered statement sta_macmahon___ plain"><p><span class="statement-heading"><span class="statement-label">Macmahon 公式</span>.</span><span class="statement-spah"> </span><br></p><p><span class="math display">\[M(a,b,c)=\prod_{i=1}^a\prod_{j=1}^b\prod_{k=1}^c\frac{i+j+k-1}{i+j+k-2}.\]</span></p></div><p>这不是一个开玩笑的公式——它几乎像是出现在某本炼金术手册里的。居然是一个完美整洁的分数连乘积，给出一个三维堆箱子问题的答案！话说光看这个表达式，你可能根本不会觉得它是一个整数！</p><p>虽然问题看起来很初等，但是答案的复杂暗示我们它并不像看起来那么容易。接下来你会看到，用一个巧妙的方法可以把问题转化为求一个行列式的值。</p><h1 id="不相交的路径组">不相交的路径组</h1><p>我们知道在平面上从原点 <span class="math inline">\((0,0)\)</span>出发，每次向右或者向上移动一个单位的距离，到达点 <span class="math inline">\((b,a)\)</span> 的路径个数是组合数 <span class="math inline">\(\binom{a+b}{b}\)</span>，这样的一条路径叫做 Gauss路径。</p><p>每个平面分拆的矩阵 <span class="math inline">\(A\)</span> 都对应<span class="math inline">\(c\)</span> 条这样的路径，其中第 <span class="math inline">\(k\)</span> 条路径是高度为 <span class="math inline">\(k\,(1\leq k\leq c)\)</span>的那一层的「等高线」：</p><figure><img src="/images/macmahon/paths-on-cubes.svg" class="fig" width="400" alt="我们把每一层都画出来（你也可以想象是洪水上涨时每一层的水痕）："><figcaption aria-hidden="true">我们把每一层都画出来（你也可以想象是洪水上涨时每一层的水痕）：</figcaption></figure><p>我们把这些路径投影到 2D，和矩阵 <span class="math inline">\(A\)</span> 画在一起。从最下方的路径开始，第 <span class="math inline">\(i\)</span> 条路径对应的是矩阵中 <span class="math inline">\(\geq i\)</span> 的那些方格构成的区域的边界：</p><p><img src="/images/macmahon/gauss_path.svg" class="fig" width="500"></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在上图中，我稍微移动了各个路径的位置，使得它们容易在视觉中区分，所以导致看起来它们的起点和终点是不同的。实际上它们都是从<span class="math inline">\((0,0)\)</span> 到 <span class="math inline">\((b,a)\)</span> 的 Gauss 路径。</p></div><p>注意 <span class="math inline">\(A\)</span>的行和列满足递降关系，这个递降关系反映在这 <span class="math inline">\(c\)</span>条路径上就是，对任何两条路径，它们可以有接触点或者重合的边，但彼此不能穿过对方。</p><p>接下来我们做一件小把戏：对每个 <span class="math inline">\(i\)</span>，把第 <span class="math inline">\(i\)</span> 条路径整体往 <span class="math inline">\((-1,1)\)</span> 方向平移 <span class="math inline">\(i-1\)</span>单位。这就让路径们完全不相交了。如下图所示：</p><p><img src="/images/macmahon/nonintersecting_paths.gif" id="nonintersect-anim" class="fig" width="550"></p><p>在平移后，第 <span class="math inline">\(i\)</span> 条路径的起点是<span class="math inline">\(A_i=(1-i,i-1)\)</span>，终点是 <span class="math inline">\(B_i=(b+1-i,a-1+i)\)</span>。我们把这样的 <span class="math inline">\(c\)</span>条路径组成的集合称之为一个不相交的路径组。</p><p>我再强调一次，不相交的路径组是指任何两条路径之间没有公共点，避免一切交叉和接触。</p><p>反过来对每一个这样的不相交的路径组，我们也很容易还原出对应的平面分拆来。</p><p>于是我们的问题又进一步转化为</p><div id="paths-problem" class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{A_i=(1-i,i-1)\}\)</span> 和 <span class="math inline">\(\{B_j=(b+1-j,a-1+j)\}\)</span>是平面上两组顶点集，计算所有不相交路径组 <span class="math inline">\(\mathcal{P}=\{p_i,1\leq i\leq c\}\)</span>的数目，其中 <span class="math inline">\(p_i\)</span> 是从 <span class="math inline">\(A_i\)</span> 出发到 <span class="math inline">\(B_i\)</span> 的 Gauss 路径。</p></div><p>这听起来像是某种城市道路或者管线设计问题。神奇的是，这个计数问题的答案，居然藏在一个行列式中。</p><h1 id="gessel-viennot-的巧妙方法">Gessel-Viennot 的巧妙方法</h1><p>考虑 <span class="math inline">\(c\times c\)</span> 的矩阵 <span class="math inline">\(M\)</span>，其元素 <span class="math inline">\(m_{ij}\)</span> 是从 <span class="math inline">\(A_i\)</span> 出发到达 <span class="math inline">\(B_j\)</span> 的所有 Gauss 路径的数目。注意，现在Gauss 路径不再必须是从 <span class="math inline">\(A_i\)</span> 走到<span class="math inline">\(B_i\)</span>，而是可以走到任何 <span class="math inline">\(B_j\)</span>。由于 <span class="math inline">\(A_i\)</span> 坐标为 <span class="math inline">\((1-i,i-1)\)</span>，<span class="math inline">\(B_j\)</span> 坐标为 <span class="math inline">\((b+1-j,a-1+j)\)</span>，所以 <span class="math display">\[m_{ij}=\binom{a+b}{b+i-j}.\]</span> 其中如果<span class="math inline">\(b+i-j&lt;0\)</span> 则规定 <span class="math inline">\(m_{ij}=0\)</span>。因为这时 <span class="math inline">\(B_j\)</span> 的横坐标在 <span class="math inline">\(A_i\)</span> 的左边，这种 Gauss路径根本不存在。</p><p>现在，奇迹要发生了：</p><div id="gessel-viennot-------" class="unnumbered statement sta_gessel_viennot___ plain"><p><span class="statement-heading"><span class="statement-label">Gessel-Viennot 引理</span>.</span><span class="statement-spah"> </span><br></p><p>记 <span class="math inline">\(\mathcal{A}=\{A_i,1\leq i\leqc\}\)</span> 和 <span class="math inline">\(\mathcal{B}=\{B_j,1\leqj\leq c\}\)</span> 是 <a href="#paths-problem" title="问题中所述">问题中所述</a>的两个顶点集，则所有不相交路径组的个数为 <span class="math display">\[\det M=\det_{1\leq i,j\leqc}\left(\left(\begin{array}{c}a+b\\b+i-j\end{array}\right)\right).\]</span></p></div><p>这个结论乍一看可太不可思议了，行列式的几何意义不是平行多面体的有向体积吗？怎么突然成了计数工具？要揭示这个魔法背后的秘密，我们得先看看上面的行列式真正干了什么。</p><p><strong>证明</strong>：对 <span class="math inline">\(c\)</span>元组上的任一置换 <span class="math inline">\(\sigma\inS_c\)</span>，记路径组 <span class="math inline">\(\mathcal{P}_\sigma=\{p_i:A_i\rightarrowB_{\sigma(i)},1\leq i\leq c\}\)</span>。</p><p>把 <span class="math inline">\(\det M\)</span>按照行列式的定义展开。由于 <span class="math inline">\(m_{i\sigma(i)}\)</span> 是从 <span class="math inline">\(A_i\)</span> 到 <span class="math inline">\(B_{\sigma(i)}\)</span> 的 Gauss 路径的个数，所以<span class="math display">\[m_{i\sigma(i)} = \sum_{p_i:A_i\toB_{\sigma(i)}}1.\]</span> 于是</p><p><span class="math display">\[\begin{aligned}\detM&amp;=\sum_{\sigma}\mathrm{sgn}(\sigma)m_{1\sigma(1)}\cdotsm_{c\sigma(c)}\\&amp;=\sum_{\sigma}\mathrm{sgn}(\sigma)\left(\sum_{p_1:A_1\toB_{\sigma(1)}}1\right)\cdots\left(\sum_{p_c:A_c\toB_{\sigma(c)}}1\right).\end{aligned}\]</span></p><p>其中 <span class="math inline">\(\sigma\)</span> 跑遍对称群 <span class="math inline">\(S_c\)</span>。<span class="math inline">\(\mathrm{sgn}(\sigma)\)</span> 是置换 <span class="math inline">\(\sigma\)</span> 的符号，偶置换时为 <span class="math inline">\(+1\)</span>，奇置换时为 <span class="math inline">\(-1\)</span>。</p><p>我们考虑如下的项：</p><p><span class="math display">\[\left(\sum_{p_1:A_1\toB_{\sigma(1)}}1\right)\cdots\left(\sum_{p_c:A_c\toB_{\sigma(c)}}1\right).\]</span></p><p>把它展开会得到很多个 1，每个 1 对应一个路径组 <span class="math inline">\(\mathcal{P}_\sigma\)</span>，因此</p><p><span class="math display">\[\detM=\sum_{\sigma,\mathcal{P}_\sigma}\text{sgn}(\sigma).\tag{$\ast$}\label{eq:det}\]</span></p><p>这个求和是对每个置换 <span class="math inline">\(\sigma\)</span>，跑遍所有可能的路径组 <span class="math inline">\(P_\sigma\)</span>。<span class="math inline">\(P_\sigma\)</span>可以是相交的路径组，也可以是不相交的路径组。</p><p>奇妙的是，所有那些相交的路径组对应的项最后都会互相抵消，剩下的只有不相交的路径组！</p><p>让我们看看这个抵消是怎么发生的。设 <span class="math inline">\(\mathcal{P}=\mathcal{P}_\sigma\)</span>是一个相交的路径组，我们构造与之抵消的路径组 <span class="math inline">\(\mathcal{P}'\)</span> 如下：</p><ol type="1"><li>在 <span class="math inline">\(\mathcal{P}\)</span>的所有交点中，选择位于最“东北”方向的那一个，将其记作 <span class="math inline">\(C\)</span>。</li><li>选择最大的 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(p_i\)</span> 经过 <span class="math inline">\(C\)</span>，再选择最大的 <span class="math inline">\(j&lt;i\)</span> 使得 <span class="math inline">\(p_j\)</span> 也经过 <span class="math inline">\(C\)</span>。</li><li>交换 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(p_j\)</span> 在 <span class="math inline">\(C\)</span>点之后的部分，保持路径组其它部分不动。记得到的新路径组为 <span class="math inline">\(\mathcal{P}'\)</span>。</li></ol><p>直观上，你可以想象两个人分别从 <span class="math inline">\(A_i\)</span> 和 <span class="math inline">\(A_j\)</span> 出发沿着路径 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(p_j\)</span> 前往目的地 <span class="math inline">\(B_{\sigma(i)}\)</span> 和 <span class="math inline">\(B_{\sigma(j)}\)</span>。当他们到达 <span class="math inline">\(C\)</span>时同时调转路线，沿着对方剩下的路径前往对方的目的地。</p><p><img src="/images/macmahon/gessel_viennot.svg" class="fig" width="550"></p><p>这个新路径组 <span class="math inline">\(\mathcal{P}'\)</span>对应的置换 <span class="math inline">\(\sigma'\)</span> 与 <span class="math inline">\(\sigma\)</span> 相差一个对换 <span class="math inline">\((ij)\)</span>，因此 <span class="math inline">\(\mathrm{sgn}(\sigma')=-\mathrm{sgn}(\sigma)\)</span>。不仅如此，如果对<span class="math inline">\(\mathcal{P}'\)</span>也按照上述规则寻找与之抵消的路径组的话，找到的路径仍然是 <span class="math inline">\(\mathcal{P}\)</span>，这就构成了一个漂亮的“湮灭配对”：相交的路径组成对出现，符号相反，相加为零。</p><p>于是我们可以把 <span class="math inline">\((\ref{eq:det})\)</span>改写为 <span class="math display">\[\detM=\sum_{\sigma,\,\mathcal{P}_\sigma \text{non-intersecting}}\mathrm{sgn}(\sigma).\]</span></p><p>但是注意，不相交的路径组只有在 <span class="math inline">\(\sigma=1\)</span> 时才可能发生，即每个 <span class="math inline">\(A_i\)</span> 的目的地必须是 <span class="math inline">\(B_i\)</span>。你可以很容易从前面的图中看出来。所以我们进一步得到<span class="math display">\[\det M=\sum_{\sigma=1\text{ and } \mathcal{P}_\sigma \text{non-intersecting}}1.\]</span> 这正是所求的不相交路径组的个数。<span class="math inline">\(\blacksquare\)</span></p><h1 id="dodgsons-condensation-method">Dodgson’s condensation method</h1><p>为了求出行列式的值，我们介绍一个古老的方法：Dodgson’scondensation。这是一个递归求解行列式的方法：设 <span class="math inline">\(A\)</span> 是一个 <span class="math inline">\(n\times n\)</span> 矩阵，用 <span class="math inline">\(A_i^j\)</span> 表示删去 <span class="math inline">\(A\)</span> 的第 <span class="math inline">\(i\)</span> 行和第 <span class="math inline">\(j\)</span> 列后剩下的 <span class="math inline">\(n-1\)</span> 阶矩阵，用 <span class="math inline">\(A_{1,n}^{1,n}\)</span> 表示删去 <span class="math inline">\(A\)</span> 的第 1 行第 1 列和第 <span class="math inline">\(n\)</span> 行第 <span class="math inline">\(n\)</span> 列后剩下的 <span class="math inline">\(n-2\)</span> 阶矩阵，则我们有恒等式</p><p><span class="math display">\[\det A\cdot \det A_{1,n}^{1,n}=\detA_1^1\det A_n^n-\det A_1^n\det A_n^1.\]</span></p><p>用一个形象的图片描述：</p><p><img src="/../images/macmahon/dodgson.svg" class="fig" width="450"></p><p>这个结论的证明不难，可以见 <a href="http://en.wikipedia.org/wiki/Dodgson_condensation">维基百科</a>，这里就不再写了。</p><p>我们对 <span class="math inline">\(c\)</span> 归纳来证明</p><div id="macmahon-thm" class="unnumbered statement sta_macmahon___-1 plain"><p><span class="statement-heading"><span class="statement-label">Macmahon 公式</span>.</span><span class="statement-spah"> </span><br></p><p><span class="math display">\[\det_{1\leq i,j\leqc}\left(\left(\begin{array}{c}a+b\\b+i-j\end{array}\right)\right)=\prod_{i=1}^a\prod_{j=1}^b\prod_{k=1}^c\frac{i+j+k-1}{i+j+k-2}.\]</span></p></div><p>首先你需要对 <span class="math inline">\(c=1\)</span> 和 <span class="math inline">\(c=2\)</span> 的情形手算验证（略繁琐，不过只是一个2 阶矩阵），设 <span class="math inline">\(M_c(a, b)\)</span>为所求的行列式，注意到</p><p><span class="math display">\[\begin{cases}(M_c(a,b))_1^1=M_{c-1}(a,b),\\(M_c(a,b))_n^n=M_{c-1}(a,b),\\(M_c(a,b))_1^n=M_{c-1}(a-1,b+1),\\(M_c(a,b))_n^1=M_{c-1}(a+1,b-1),\\(M_c(a,b))^{1,n}_{1,n}=M_{c-2}(a,b).\end{cases}\]</span></p><p>然后应用归纳假设即可。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>问题的 <span class="math inline">\(q-\)</span> 计数版本也可以用Gessel-Viennot 引理来做，只是行列式的求值略复杂。其实也可以用 <a href="https://arxiv.org/abs/math/9902004">Krattenthaler 公式</a>来计算，不过那个方法不是我们要讲的。</p></div><h1 id="番外话">番外话</h1><p>说点八卦的东西。Dodgson 是 19世纪的英国数学家，细心点的读者可能注意到这位老兄的名字实在让人不敢恭维：Dodgson,dog…son？大概他也知道自己的名字难登大雅之堂，所以他给自己取了一个很好听的笔名：LewisCarroll（路易斯·卡罗尔）。</p><p>你对这个名字没有印象么？那好，我们继续说说他的轶事。这位老兄虽然名字略俗，受过的教育可不含糊，是牛津大学的数学教授，也算上层社会体面人物，但是按照今天的话说，是个不折不扣的怪蜀黍，对萝莉有着特别的喜爱，尤其喜爱给她们拍裸照，所以后人基本认定他是一个恋童癖大叔。他曾经专门为邻居家的女儿写了一部童话来哄她开心，这就是大名鼎鼎的《爱丽斯漫游奇境记》。虽然创作动机不纯，但是这部童话非常精彩，以至于当时的英国女王都变成了他的粉丝。女王命令手下的大臣把Dodgson的全部著作都搜集呈上来，于是大臣献上了一本厚厚的《符号逻辑》，当然结果你猜得到的…</p><p>时光一转到了 20 世纪 80 年代，三位数学家 William Mills，David Robbins和 Howard Rumsey 在研究计算行列式的快速数值算法时，受 Dodgson算法的启发，发现了交错符号矩阵猜想。这是计数组合学里面最精彩的猜想之一。我向你推荐Bressoud 的书 <span class="citation" data-cites="Bressoud1999">(<a href="#ref-Bressoud1999" role="doc-biblioref">Bressoud1999</a>)</span>，我保证里面的故事和《爱丽丝漫游奇境记》一样奇妙 …</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Bressoud1999" class="csl-entry" role="listitem">Bressoud, David M. 1999. <em>Proofs and Confirmations: The Story of theAlternating-Sign Matrix Conjecture</em>. Spectrum. Cambridge UniversityPress.</div></div>]]></content>
      
      
      <categories>
          
          <category> 计数组合学 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>欢迎来到 <strong>赵亮</strong> 的个人网站。</p><p>这个博客使用 <a href="https://hexo.io/">hexo</a> 搭建，<a href="https://pandoc.org/">Pandoc</a> 渲染，<a href="https://github.com/dialoa/statement">statement</a>生成自动编号的定理环境。主题修改自 <a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism">raytaylorism</a>。</p><p>转载文章和图片注明出处即可。所有代码均采用 <a href="https://opensource.org/licenses/MIT">MIT LICENSE</a>。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群语言正则的证明</title>
      <link href="/coxeter-automatic/index.html"/>
      <url>/coxeter-automatic/index.html</url>
      
        <content type="html"><![CDATA[<div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.1</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha,\beta\in\Phi\)</span> 满足 <span class="math inline">\(|(\alpha,\beta)|&lt;1\)</span>，则必然有 <span class="math inline">\((\alpha,\beta)=\cos(p\pi/q)\)</span>，其中 <span class="math inline">\(p,q\)</span> 是互素的正整数，而且反射 <span class="math inline">\(r_\alpha,r_\beta\)</span> 生成的子群是有限群。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(|(\alpha,\beta)|&lt;1\)</span>，则内积 <span class="math inline">\((\,,)\)</span> 限制在 <span class="math inline">\(\alpha,\beta\)</span> 张成的二维子空间 <span class="math inline">\(U=\mathop{\mathrm{span}}{\{\alpha,\beta\}}\)</span>上是正定的。</p><p>我们可以不妨假定 <span class="math inline">\(\alpha\)</span>是正根，以及 <span class="math inline">\(\beta=\alpha_s\)</span>是单根。设 <span class="math display">\[\alpha = c_s\alpha_s +\sum_{t\ne s }c_t\alpha_t.\]</span> 由于 <span class="math inline">\(\alpha\)</span> 不可能是 <span class="math inline">\(\alpha_s\)</span> 的正倍数，所以 <span class="math inline">\(\gamma=\alpha - c_s\alpha_s\ne0\)</span>。</p><p>注意到如果 <span class="math inline">\(a,b\in\mathbb{R}\)</span> 使得<span class="math inline">\(a\gamma+b\alpha_s\in\Phi\)</span>，则 <span class="math inline">\(a,b\)</span> 必须同时非负，或者同时非正。如果<span class="math inline">\(\alpha,\beta\)</span> 所夹的角度是 <span class="math inline">\(\pi\)</span> 的无理数倍，那么 <span class="math inline">\((r_\alpha s)\)</span> 是 <span class="math inline">\(U\)</span> 上角度为 <span class="math inline">\(\pi\)</span> 的无理数倍的旋转，它的各次幂 <span class="math inline">\(\{(r_\alpha s)^n,n=0,1,\ldots,\}\)</span> 会将<span class="math inline">\(\alpha\)</span> 映射为 <span class="math inline">\(U\)</span>中单位圆周上稠密的集合，特别地必然有某个 <span class="math inline">\(k\)</span> 使得 <span class="math inline">\((r_\alpha s)^k\alpha\)</span> 位于区域 <span class="math inline">\(\{a\gamma+b\alpha_s\mid a &gt; 0,b&lt;0\}\)</span> 中，这与此区域不包含任何根矛盾。所以 <span class="math inline">\(\alpha,\beta\)</span> 所夹的角度必须是 <span class="math inline">\(\pi\)</span> 的有理数倍，形如 <span class="math inline">\(p\pi/q\)</span>，从而 <span class="math inline">\(r_\alpha,r_\beta\)</span> 生成的子群 <span class="math inline">\(D\)</span> 在 <span class="math inline">\(U\)</span> 上的作用是一个二面体群。另一方面 <span class="math inline">\((\,,)\)</span> 限制在 <span class="math inline">\(U\)</span> 上是正定的，所以 <span class="math inline">\(V=U\oplus U^\bot\)</span>。而 <span class="math inline">\(D\)</span> 作用在 <span class="math inline">\(U^\bot\)</span> 上是平凡的，所以 <span class="math inline">\(D\)</span> 在全空间上的作用也是二面体群。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义0.2</span>.</span><span class="statement-spah"> </span>对任何正根 <span class="math inline">\(\alpha\in\Phi^+\)</span>，定义其深度为 <span class="math display">\[\mathrm{dp}(\alpha)=\min\{\,l(w) \midw\alpha\in\Phi^-\,\}.\]</span> 对两个正根 <span class="math inline">\(\alpha,\beta\)</span>，定义 <span class="math inline">\(\alpha\preceq\beta\)</span> 当且仅当存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(\beta=w\alpha\)</span> 并且 <span class="math display">\[\mathrm{dp}(\beta)=\mathrm{dp}(\alpha)+l(w).\]</span>如果 <span class="math inline">\(\alpha\preceq\beta\)</span> 且 <span class="math inline">\(\alpha\ne\beta\)</span> 我们记为 <span class="math inline">\(\alpha\prec\beta\)</span>。</p></div><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha_s\)</span> 是单根，<span class="math inline">\(\beta\ne\alpha_s\)</span> 是正根，则 <span class="math display">\[\mathrm{dp}(s\beta)=\begin{cases}\mathrm{dp}(\beta)-1 &amp; \text{if } (\beta,\alpha_s)&gt;0,\\\mathrm{dp}(\beta)   &amp; \text{if } (\beta,\alpha_s)=0.\\\mathrm{dp}(\beta)+1 &amp; \text{if } (\beta,\alpha_s)&lt;0.\end{cases}\]</span></p></div><p>第二条是显然的，而第三条可以由第一条得出：只要对 <span class="math inline">\(s\alpha\)</span>应用第一条的结论即可。所以我们只需要证明第一条。</p><p>首先取 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(l(w)=\mathrm{dp}(\beta)\)</span> 且 <span class="math inline">\(w\beta\in\Phi^-\)</span>。</p><ol type="1"><li><p>如果 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>，则<span class="math inline">\(l(ws)=l(w)-1\)</span>。由于 <span class="math inline">\((ws)(s\beta)=w\beta&lt;0\)</span>，所以 <span class="math display">\[\mathrm{dp}(s\beta)\leq l(ws)=l(w)-1.\]</span>从而 <span class="math inline">\(\mathrm{dp}(s\beta)=l(w)-1=\mathrm{dp}(\beta)-1\)</span>。</p></li><li><p>如果 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>，则<span class="math display">\[w(s\beta)=w(\beta -2(\beta,\alpha_s)\alpha_s)=w\beta-cw\alpha_s (c&gt;0).\]</span> 可见<span class="math inline">\(w(s\beta)\)</span> 是负根。由于 <span class="math inline">\(\beta\ne\alpha_s\)</span>是不同的正根，所以它们不共线，从而 <span class="math inline">\(w\beta\)</span> 和 <span class="math inline">\(w\alpha_s\)</span>也不共线，于是上式是两个不共线的负根的和，所以任何单反射不能将 <span class="math inline">\(w(s\beta)\)</span> 变成正根。取 <span class="math inline">\(t\in S\)</span> 使得 <span class="math inline">\(l(tw)&lt;l(w)\)</span>，则 <span class="math inline">\(tw(s\beta)\)</span> 仍然是负根，所以 <span class="math display">\[\mathrm{dp}(s\beta)\leql(tw)=l(w)-1=\mathrm{dp}(\beta)-1.\]</span> 结论仍然得证。<span class="math inline">\(\blacksquare\)</span></p></li></ol><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.4</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha\preceq\beta\)</span>，则存在序列 <span class="math display">\[\alpha=\alpha_0\preceq\alpha_1\preceq\cdots\preceq\alpha_k=\beta\]</span>使得对每个 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(\mathrm{dp}(\alpha_{i+1})=\mathrm{dp}(\alpha_i)+1\)</span>。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(w=s_k\cdotss_1\)</span> 满足 <span class="math inline">\(\beta=w\alpha\)</span> 且<span class="math inline">\(l(w)=\mathrm{dp}(\beta)-\mathrm{dp}(\alpha)\)</span>，考虑<span class="math inline">\(\alpha_i=s_i\cdots s_1\alpha\)</span>，其中<span class="math inline">\(\alpha_0=\alpha\)</span>，<span class="math inline">\(\alpha_k=\beta\)</span>。从 <span class="math inline">\(\alpha_0\)</span> 到 <span class="math inline">\(\alpha_k\)</span> 经过了 <span class="math inline">\(k=l(w)\)</span> 次单反射，depth 增加了 <span class="math inline">\(l(w)\)</span>，但上面的引理告诉我们每次单反射depth 至多增加 1，所以只能是每一项的 depth 都比前一项增加了1，即得结论。</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.5</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha\preceq\beta\)</span>，且 <span class="math inline">\(\alpha=\sum c_s\alpha_s,\, \beta=\sumd_s\alpha_s\)</span>，则对每个 <span class="math inline">\(s\)</span> 有<span class="math inline">\(c_s\leq d_s\)</span>。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(\beta=s\alpha\)</span> 则 <span class="math inline">\(\alpha,\beta\)</span> 只有在 <span class="math inline">\(\alpha_s\)</span> 项的系数不同。又 <span class="math inline">\((\alpha,\alpha_s)&lt;0\)</span> 所以 <span class="math inline">\(d_s&gt;c_s\)</span> 得证。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义0.6</span>.</span><span class="statement-spah"> </span>对 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span>，如果对任何 <span class="math inline">\(w\in W\)</span> 都有 <span class="math inline">\(w\alpha\in\Phi^-\Rightarroww\beta\in\Phi^-\)</span>，我们就称 <span class="math inline">\(\alpha\)</span> 支配 <span class="math inline">\(\beta\)</span>，记作 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>。</p></div><p>由于 <span class="math inline">\(w\alpha\in\Phi^-\)</span> 等价于<span class="math inline">\((w\alpha,\mathcal{D})=(\alpha,w^{-1}\mathcal{D})&lt;0\)</span>，所以这个定义也可以表述为： <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span> 当且仅当<span class="math inline">\((\alpha, w\mathcal{D})&lt;0\Rightarrow(\beta, w\mathcal{D})&lt;0\)</span> 对任何 <span class="math inline">\(w\in W\)</span> 成立。即任何落在镜子 <span class="math inline">\(\alpha\)</span> 背面的房间，也必然落在镜子 <span class="math inline">\(\beta\)</span> 的背面。这意味着镜子 <span class="math inline">\(\beta\)</span> 完全挡在镜子 <span class="math inline">\(\alpha\)</span> 和基本区域 <span class="math inline">\(\mathcal{D}\)</span> 之间，任何从 <span class="math inline">\(\mathcal{D}\)</span> 出发走到 <span class="math inline">\(\alpha\)</span> 背面的路径都必须先穿过 <span class="math inline">\(\beta\)</span>。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.7</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span> 且 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>，则：</p><ol type="1"><li><span class="math inline">\((\alpha,\beta)&gt;0\)</span>。</li><li>若 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\beta\)</span> 是正根，则 <span class="math inline">\(w\alpha\,\mathrm{dom}\,w\beta\)</span>。</li><li>若 <span class="math inline">\(\alpha\prec\alpha'\)</span> 则<span class="math inline">\(\alpha'\)</span>不是极小根。换句话说，若一个根是极小根，则在偏序 <span class="math inline">\(\preceq\)</span> 下小于它的根也都是极小根。</li><li><span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>，等号当且仅当<span class="math inline">\(\alpha=\beta\)</span> 时成立。</li></ol></div><p><strong>证明</strong>：</p><ol type="1"><li><p><span class="math inline">\(r_\alpha\)</span> 满足 <span class="math inline">\(r_\alpha\alpha=-\alpha\in\Phi^-\)</span>，所以<span class="math inline">\(r_\alpha\beta=\beta-2(\alpha,\beta)\alpha&lt;0\)</span>，这必须<span class="math inline">\((\alpha,\beta)&gt;0\)</span> 才行。</p></li><li><p>显然。</p></li><li><p>只要对 <span class="math inline">\(\mathrm{dp}(\alpha')=\mathrm{dp}(\alpha)+1\)</span>进行证明即可。这时存在单反射 <span class="math inline">\(s\)</span> 使得<span class="math inline">\(\alpha'=s\alpha\)</span>，并且 <span class="math inline">\((\alpha_s,\alpha)&lt;0\)</span>。<span class="math inline">\((\alpha,\beta)&gt;0\)</span> 说明 <span class="math inline">\(\beta\ne\alpha_s\)</span>，从而 <span class="math inline">\(s\beta\)</span> 是正根，从而 <span class="math inline">\(\alpha'=s\alpha\,\mathrm{dom}\,s\beta\)</span>不是极小根。</p></li><li><p><span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>显然意味着 <span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>。设<span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\alpha=-\alpha_s\)</span> 是某个负的单根，则<span class="math inline">\(w\beta\in\Phi^-\)</span>。注意这时 <span class="math inline">\(w^{-1}\alpha_s=-\alpha&lt;0\)</span>，所以 <span class="math inline">\(l(sw)&lt;l(w)\)</span>。</p><ul><li><p>若 <span class="math inline">\(sw\beta\in\Phi^+\)</span>，则由<span class="math inline">\(w\beta&lt;0\)</span> 可知 <span class="math inline">\(w\beta=-\alpha_s\)</span>，再结合 <span class="math inline">\(w\alpha=-\alpha_s\)</span> 可得 <span class="math inline">\(\alpha=\beta\)</span>。</p></li><li><p>若 <span class="math inline">\(sw\beta\in\Phi^-\)</span>，则<span class="math inline">\(\mathrm{dp}(\beta)\leql(sw)&lt;\mathrm{dp}(\alpha)\)</span>。</p></li></ul></li></ol><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.8</span>.</span><span class="statement-spah"> </span>在有限 Coxeter群中，所有根都是极小根。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(w_0\)</span>是最长元，则 <span class="math inline">\(\alpha\to -w_0(\alpha)\)</span>置换 <span class="math inline">\(\Phi^+\)</span>。我们来验证这个置换保持每个正根的深度不变：若<span class="math inline">\(w\alpha&lt;0\)</span>，则 <span class="math inline">\(w_0w\alpha&gt;0\)</span>，从而 <span class="math inline">\((w_0ww_0)(-w_0\alpha)&lt;0\)</span>，这说明 <span class="math inline">\(\mathrm{dp}(-w_0\alpha)\leql(w_0ww_0)=l(w)\)</span>。对 <span class="math inline">\(-w_0\alpha\)</span> 应用此结论可得 <span class="math inline">\(\mathrm{dp}(\alpha)\leq\mathrm{dp}(-w_0\alpha)\)</span>。从而二者相等。</p><p>另一方面我们来验证它翻转 <span class="math inline">\(\,\mathrm{dom}\,\)</span> 这个偏序：若 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>，则 <span class="math display">\[\begin{aligned}w\alpha&lt;0&amp;\Rightarrow w\beta&lt;0\\&amp;\Downarrow\\w\beta &gt; 0&amp;\Rightarrow w\alpha&gt;0\\&amp;\Downarrow\\ww_0\beta &gt; 0&amp;\Rightarrow ww_0\alpha&gt;0\\&amp;\Downarrow\\w(-w_0\beta) &lt; 0&amp;\Rightarrow w(-w_0\alpha)&lt;0\\\end{aligned}\]</span> 即确实有 <span class="math inline">\(-w_0\beta\,\mathrm{dom}\,-w_0\alpha\)</span>。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.9</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span> 的充要条件是<span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>且 <span class="math inline">\((\alpha,\beta)\geq1\)</span>。</p></div><p><strong>证明</strong>：我们只考虑 <span class="math inline">\(\alpha\ne\beta\)</span> 的情形即可。</p><p><span class="math inline">\(\Rightarrow\)</span>：只要再证明 <span class="math inline">\((\alpha,\beta)\geq1\)</span>。用反证法，若不然，则<span class="math inline">\(0&lt;(\alpha,\beta)&lt;1\)</span>，从而<span class="math inline">\(r_\alpha,r_\beta\)</span>生成一个有限二面体群 <span class="math inline">\(D\)</span>。由于在有限群中没有支配关系，所以存在<span class="math inline">\(w\in D\)</span> 使得 <span class="math inline">\(w\alpha\in\Phi^-,\,w\beta\in\Phi^+\)</span>。这与<span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>矛盾。</p><p><span class="math inline">\(\Leftarrow\)</span>：我们先考虑 <span class="math inline">\(\beta=\alpha_s\)</span> 是一个单根的情形。由于<span class="math inline">\(\alpha\ne\beta\)</span> 所以 <span class="math inline">\(s\alpha\)</span> 仍然是正根。我们发现 <span class="math display">\[(\alpha,s\alpha)=(\alpha,\alpha-2(\alpha,\alpha_s)\alpha_s)=1-2(\alpha,\alpha_s)^2\leq-1.\]</span> 所以有无穷多个形如 <span class="math inline">\(a\alpha+b\alpha_s\)</span> 的正根，其中 <span class="math inline">\(a,b&gt;0\)</span>。</p><p>用反证法，如果 <span class="math inline">\(\alpha\)</span> 不支配<span class="math inline">\(\beta=\alpha_s\)</span>，则存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\alpha\in\Phi^-\)</span> 但 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>。由于 <span class="math display">\[w(s\alpha)=w\alpha -2(\alpha,\alpha_s)w\alpha_s\]</span> 是负根 <span class="math inline">\(w\alpha\)</span> 减去正根 <span class="math inline">\(w\alpha_s\)</span>的一个正倍数，必然仍然是负根。于是 <span class="math inline">\(\{\alpha,s\alpha\}\subsetN(w)\)</span>，从而所有形如 <span class="math inline">\(\{a\alpha+bs\alpha\mid a,b&gt;0\}\)</span>的根都在 <span class="math inline">\(N(w)\)</span> 中，这与 <span class="math inline">\(|N(w)|=l(w)&lt;\infty\)</span> 矛盾。</p><p>对 <span class="math inline">\(\beta\)</span> 是一般正根的情形，取<span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\beta\in\Delta\)</span>，<span class="math inline">\(l(w)=\mathrm{dp}(\beta)-1\)</span>。由于 <span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>所以 <span class="math inline">\(w\alpha\)</span> 仍然是正根，当然就有<span class="math inline">\(\mathrm{dp}(w\alpha)\geq\mathrm{dp}(w\beta)=1\)</span>和 <span class="math inline">\((w\alpha,w\beta)=(\alpha,\beta)\geq1\)</span>。根据上面的证明，<span class="math inline">\(w\alpha\,\mathrm{dom}\,w\beta\)</span>，所以 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.10</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\lambda,\mu\)</span> 是正根，且 <span class="math inline">\(s_\lambda,s_\mu\)</span>生成一个无限群，则下面三种情况必居其一：</p><ol type="1"><li><span class="math inline">\(\lambda\,\mathrm{dom}\,\mu\)</span>.</li><li><span class="math inline">\(\mu\,\mathrm{dom}\,\lambda\)</span>.</li><li><span class="math inline">\(s_\mu\lambda\,\mathrm{dom}\,\mu\)</span>且 <span class="math inline">\(s_\lambda\mu\,\mathrm{dom}\,\lambda\)</span>.</li></ol></div><p><strong>证明</strong>：<span class="math inline">\(s_\lambda,s_\mu\)</span> 生成一个无限群说明 <span class="math inline">\(|(\lambda,\mu)|\geq1\)</span>。如果 <span class="math inline">\((\lambda,\mu)\geq1\)</span> 那么 <span class="math inline">\(\lambda,\mu\)</span> 中 depth更大的那一个支配另一个。</p><p>如果 <span class="math inline">\((\lambda,\mu)\leq-1\)</span>我们来证明 <span class="math inline">\(s_\mu\lambda\,\mathrm{dom}\,\mu\)</span>，<span class="math inline">\(s_\lambda\mu\,\mathrm{dom}\,\lambda\)</span>的论证是一样的。注意到这时 <span class="math inline">\((s_\mu\lambda,\mu)=-(\lambda,\mu)\geq1\)</span>，所以只要再证明 <span class="math inline">\(\mathrm{dp}(s_\mu\lambda)\geq\mathrm{dp}(\mu)\)</span> 即可。</p><p>设 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w(s_\mu\lambda)&lt;0\)</span> 且 <span class="math inline">\(l(w)=\mathrm{dp}(s_\mu\lambda)\)</span>，我们来证明必有一个长度<span class="math inline">\(l(w')\leq l(w)\)</span> 的元素 <span class="math inline">\(w'\)</span> 使得 <span class="math inline">\(w'\mu&lt;0\)</span>，从而 <span class="math inline">\(\mathrm{dp}(s_\mu\lambda)\geq\mathrm{dp}(\mu)\)</span>。</p><p>首先若 <span class="math inline">\(w\mu&lt;0\)</span> 则可以取 <span class="math inline">\(w'=w\)</span>。否则若 <span class="math inline">\(w\mu&gt;0\)</span>，我们来计算 <span class="math display">\[w(s_\mu\lambda)=w\lambda-2(\mu,\lambda)w\mu.\]</span>我们知道这是一个负根，而且它是 <span class="math inline">\(w\lambda\)</span> 加上正根 <span class="math inline">\(w\mu\)</span> 的正倍数，所以必须 <span class="math inline">\(w\lambda&lt;0\)</span>，从而 <span class="math inline">\(l(ws_\lambda)&lt;l(w)\)</span>。</p><p>进一步我们计算 <span class="math display">\[(ws_\lambda)\mu=w\mu-2(\mu,\lambda)w\lambda.\]</span>我们来证明 <span class="math inline">\((ws_\lambda)\mu\)</span>是一个负根，从而 <span class="math inline">\(\mathrm{dp}(\mu)\leql(ws_\lambda)&lt;l(w)=\mathrm{dp}(s_\mu\lambda)\)</span>。</p><p>若不然，记 <span class="math inline">\(c=-2(\mu,\lambda)\geq2\)</span>，若 <span class="math inline">\((ws_\lambda)\mu=w\mu+cw\lambda&gt;0\)</span>，乘以<span class="math inline">\(c\)</span> 得到 <span class="math inline">\(cw\mu+c^2w\lambda\)</span>是正根的非负线性组合（未必还是根），根据上面 <span class="math inline">\(w\lambda+cw\mu&lt;0\)</span>，减去后者得到 <span class="math inline">\((c^2-1)w\lambda\)</span> 是正根的非负线性组合，但<span class="math inline">\(c^2-1\geq 3\)</span>，这与 <span class="math inline">\(w\lambda&lt;0\)</span> 矛盾。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.11</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span> 满足 <span class="math inline">\(\beta\preceq\alpha\)</span>，并且 <span class="math inline">\(\alpha\)</span> 是极小根。进一步设 <span class="math inline">\(\alpha_s\in\Delta\)</span> 满足 <span class="math inline">\((\beta,\alpha_s)\leq-1\)</span>，则 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> 的 <span class="math inline">\(\alpha_s\)</span> 项的系数相等。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(\beta\preceq\gamma\preceq\alpha\)</span> 使得<span class="math inline">\(\gamma\)</span> 是偏序 <span class="math inline">\(\preceq\)</span> 下最大的与 <span class="math inline">\(\beta\)</span> 有相同的 <span class="math inline">\(\alpha_s\)</span> 项系数。如果 <span class="math inline">\(\gamma\ne\alpha\)</span>，则存在 <span class="math inline">\(t\)</span> 使得 <span class="math inline">\(\gamma\prec t\gamma\preceq\alpha\)</span>。由<span class="math inline">\(\gamma\)</span> 的极大性可得 <span class="math inline">\(s=t\)</span>。</p><p>但是 <span class="math inline">\(\gamma-\beta=\sum_{t\nes}c_t\alpha_t\)</span>，且每个 <span class="math inline">\(c_t\geq0\)</span>。因此 <span class="math display">\[(s\gamma,\alpha_s)=(\gamma,-\alpha_s)=-(\beta,\alpha_s)-\sum_{t\ner}c_t(\alpha_t,\alpha_s)\geq1.\]</span> 于是 <span class="math inline">\(s\gamma\,\mathrm{dom}\,\alpha_s\)</span>不是极小根，从而 <span class="math inline">\(\alpha\succeqs\gamma\)</span> 也不是极小根。矛盾！所以 <span class="math inline">\(\gamma=\alpha\)</span>，从而命题得证。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.12</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi\)</span> 满足 <span class="math inline">\(|(\alpha,\beta)|\leq 1\)</span>，则这样的 <span class="math inline">\((\alpha,\beta)\)</span> 只有有限多个值。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(|(\alpha,\beta)|&lt;1\)</span> 则 <span class="math inline">\(r_\alpha,r_\beta\)</span> 生成的子群 <span class="math inline">\(D\)</span> 是有限的，所以存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(wDw^{-1}\)</span> 属于某个有限的标准椭圆子群 <span class="math inline">\(W_J\)</span>，特别地，<span class="math inline">\(r_\alpha r_\beta\)</span> 的阶 <span class="math inline">\(m\)</span> 应该整除 <span class="math inline">\(W_J\)</span> 的阶，从而 <span class="math inline">\((\alpha,\beta)\)</span> 形如 <span class="math inline">\(\cos(a\pi/m)\)</span>，其中 <span class="math inline">\(0\leq a\leq 2m\)</span> 而且 <span class="math inline">\(m\)</span>是某个有限标准椭圆子群的阶的因子。由于这样的子群是有限的，所以这样的<span class="math inline">\(\cos\)</span> 值也是有限的。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.13</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha=\sum a_s\alpha_s\)</span> 和 <span class="math inline">\(\beta=\sum b_s\alpha_s\)</span> 都是正根。进一步设<span class="math inline">\(S=I\cup J\)</span> 使得</p><ol type="1"><li>对任何 <span class="math inline">\(t\in I\)</span> 有 <span class="math inline">\((\alpha,\alpha_t)=(\beta,\beta_t)\)</span>。</li><li><span class="math inline">\(c_t=b_t\)</span> 对任何 <span class="math inline">\(t\in J\)</span> 成立。</li></ol><p>则 <span class="math inline">\((\alpha,\beta)=1\)</span>。</p></div><p>注意这里 <span class="math inline">\(I\)</span> 或者 <span class="math inline">\(J\)</span> 允许有一个是空集。</p><p><strong>证明</strong>：我们有 <span class="math inline">\(\alpha-\beta=\sum_{s\inI}(a_s-b_s)\alpha_s\)</span>，所以 <span class="math display">\[(\alpha,\alpha-\beta)=\sum_{s\inI}(a_s-b_s)(\alpha,\alpha_s)=\sum_{s\inI}(a_s-b_s)(\beta,\alpha_s)=(\beta,\alpha-\beta).\]</span> 即 <span class="math inline">\((\alpha,\beta)=1\)</span>。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理0.14</span>.</span><span class="statement-spah"></span>极小根集合是有限的。</p></div><p><strong>证明</strong>：我们来证明极小根的深度是有上界的。设 <span class="math inline">\(\beta\)</span> 是一个深度为 <span class="math inline">\(d\)</span> 的极小根，<span class="math inline">\(\beta_1\prec\cdots\prec\beta_d=\beta\)</span>是一个序列满足 <span class="math inline">\(\mathrm{dp}(\beta_i)=i\)</span>，则每个 <span class="math inline">\(\beta_i\)</span> 都是极小根。</p><p>记 <span class="math inline">\(J_i=\{\gamma\in\Delta \mid (\gamma,\beta_i)\geq-1\}\)</span>。我们来证明 <span class="math inline">\(\{J_i,1\leq i\leq d\}\)</span>是递降的，并且最终会降为空集。</p><p>对 <span class="math inline">\(1\leq i\leq d\)</span>，若 <span class="math inline">\(\gamma\notin J_i\)</span>，则 <span class="math inline">\(\gamma\)</span> 在所有 <span class="math inline">\(\beta_j(j\geq i)\)</span> 中的系数都相同。</p><p>设 <span class="math inline">\(\beta_i=\sum c_s\alpha_s,\,\beta_j=\sum d_s\alpha_s\)</span>，则 <span class="math inline">\(0\leqc_s\leq d_s\)</span> 且 <span class="math inline">\(c_\gamma=d_\gamma\)</span>。注意到 <span class="math inline">\((\beta_j,\gamma)=\sum_{s\in\Delta}d_s(\alpha_s,\gamma)\leq \sum_{s\in\Delta}c_s(\alpha_s, \gamma)=(\beta_i,\gamma)&lt;-1\)</span>。所以 <span class="math inline">\(\gamma\not\inJ_j\)</span>。即 <span class="math inline">\(\{J_i\}\)</span>确实是递降的。</p><p>设 <span class="math inline">\(J_i=\cdots=J_i=J\)</span> 对某个 <span class="math inline">\(i&lt;j\)</span> 成立。对任何 <span class="math inline">\(\gamma\in J\)</span> 和 <span class="math inline">\(i\leq k\leq j\)</span>，由于 <span class="math inline">\(\beta_k\)</span> 不能支配 <span class="math inline">\(\gamma\)</span>，所以 <span class="math inline">\(-1\leq (\beta,\gamma)\leq 1\)</span>，等于 1当且仅当 <span class="math inline">\(\beta=\gamma\)</span>。于是 <span class="math inline">\((\beta_k,\gamma)\in\mathcal{C}(S)\)</span>。于是如果<span class="math inline">\(j-i&gt;|\mathcal{C}(S)|^{|S|}\)</span>那么必然存在 <span class="math inline">\(i\leq m &lt; n\leq j\)</span>使得 <span class="math inline">\((\beta_m, J)=(\beta_n,J)\)</span>。（鸽笼原理，<span class="math inline">\(\beta\)</span>和一个单根的内积有 <span class="math inline">\(|c|\)</span>种不同的可能值，和所有单根的内积共有 <span class="math inline">\(c^{|S|}\)</span> 种不同的可能值）。</p><p>但是如果 <span class="math inline">\(\gamma\not\in J\)</span>，则<span class="math inline">\(\gamma\)</span> 在 <span class="math inline">\(\beta_m,\beta_n\)</span>中的系数相同，所以根据前面的引理 <span class="math inline">\((\beta_m,\beta_n)=1\)</span>，但这导致 <span class="math inline">\(\beta_n \,\mathrm{dom}\,\beta_m\)</span>，所以如果<span class="math inline">\(j-i&gt;c^{|S|}\)</span> 时 <span class="math inline">\(J_j\)</span> 必须比 <span class="math inline">\(J_i\)</span> 严格地小，所以整个链的长度有限，即<span class="math inline">\(d\)</span> 有限。</p><blockquote><p><strong>引理</strong>：设 <span class="math inline">\(\gamma\)</span>不是极小根，<span class="math inline">\(u,v\in W\)</span> 使得 <span class="math inline">\(u\gamma, v^{-1}\gamma\)</span> 都是单根，则 <span class="math inline">\(l(uv)\ne l(u)+l(v)\)</span>。</p></blockquote><p>证明：设 <span class="math inline">\(u\gamma=\alpha_s,v^{-1}\gamma=\alpha_t\)</span>，则<span class="math inline">\(\gamma\in N(su)\capN(tv^{-1})\)</span>。又设 <span class="math inline">\(\gamma\,\mathrm{dom}\,\beta\)</span>，则 <span class="math inline">\(\beta\in N(su)\cap N(tv^{-1})\)</span>。但是 <span class="math inline">\(u\beta\ne u\gamma=\alpha_s\)</span>，所以 <span class="math inline">\(su\beta\in\Phi^-\)</span> 说明 <span class="math inline">\(u\beta\in\Phi^-\)</span>。同理 <span class="math inline">\(v^{-1}\beta\in\Phi^-\)</span>，所以 <span class="math inline">\(N(u)\cap N(v^{-1})\)</span>非空，所以引理得证。</p><hr><p>设 <span class="math inline">\(\Sigma\)</span>是所有极小根组成的集合，则 <span class="math inline">\(|\Sigma|&lt;\infty\)</span> 是有限集。</p><p>定义状态机如下：</p><p>一个状态 <span class="math inline">\(S_i\subset\Sigma\)</span>是极小根的子集。转移 <span class="math inline">\(S_i\xrightarrow{s}S_{i+1}\)</span> 为：</p><ol type="1"><li>如果 <span class="math inline">\(s\in S_i\)</span> 则 <span class="math inline">\(S_i\xrightarrow{s}\mathrm{NO}\)</span>。</li><li>如果 <span class="math inline">\(s\notin S_i\)</span> 则 <span class="math inline">\(S_i\xrightarrow{s} (sS_i\cup \{\alpha_s\}\cup\{s\alpha_t,t&lt;s\})\cap\Sigma\)</span>。</li></ol><p>我们来证明这个状态机识别语言 <span class="math inline">\(\mathcal{L}\)</span>。</p><p>为方便我们记 <span class="math inline">\(\mathcal{R}_i=\{\alpha_s\in\Delta,s&lt;i\}\)</span> 是那些字典序下小于 <span class="math inline">\(\alpha_i\)</span> 的单根组成的集合。</p><p>假设 <span class="math inline">\(s_1\cdots s_l\in\mathcal{L}\)</span>，但是 <span class="math inline">\(s_1\cdotss_{l+1}\notin \mathcal{L}\)</span> 当且仅当 <span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。其中 <span class="math inline">\(S_i\subset\Sigma\)</span> 是状态机读入 <span class="math inline">\(s_i\)</span> 以后的状态。</p><p>我们来证明对任何 <span class="math inline">\(k\leq l\)</span> 有<span class="math display">\[S_k\subset\{(s_k\cdots s_{i+1})\alpha_i\mid1\leq i\leq l\}\cup\cup_{i=1}^{k}(s_k\cdotss_i)\cdot\mathcal{R}_i.\]</span> 首先 <span class="math inline">\(k=1\)</span> 时 <span class="math inline">\(S_1=\{\alpha_1\}\)</span>，</p><p>由于下一步读入 <span class="math inline">\(s_{l+1}\)</span>的时候是拒绝态，所以 <span class="math inline">\(\alpha_{l+1}\)</span>也属于上面的集合。</p><ul><li><p>如果 <span class="math inline">\(\alpha_{l+1}\in \{(s_l\cdotss_{i+1})\alpha_i\mid 1\leq i\leq l\}\)</span>，则 <span class="math inline">\(s_1\cdots s_ls_{l+1}\)</span> 不是既约的，所以不在<span class="math inline">\(\mathcal{L}\)</span> 中。</p></li><li><p>如果 <span class="math inline">\(\alpha_{l+1}\notin \{(s_l\cdotss_{i+1})\alpha_i\mid 1\leq i\leq l\}\)</span>，则 <span class="math inline">\(s_1\cdots s_ls_{l+1}\)</span> 是既约的，但是 <span class="math inline">\(\alpha_{l+1}\)</span> 形如 <span class="math inline">\(s_l\cdots s_{i}\alpha_r(r&lt;i)\)</span>，所以<span class="math inline">\(s_1\cdotss_{l+1}\notin\mathcal{L}\)</span>。</p></li></ul><p>反之，我们要证明如果 <span class="math inline">\(\mathcal{L}\)</span>拒绝一个字 <span class="math inline">\(w=s_1\cdots s_n\)</span>，设<span class="math inline">\(l\)</span> 是使得 <span class="math inline">\(\mathcal{L}\)</span> 接受 <span class="math inline">\(w\)</span> 的最大位置，则必有 <span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。用反证法，设 <span class="math inline">\(\alpha_{l+1}\notin S_l\)</span>。</p><ul><li><p>如果 <span class="math inline">\(s_1\cdots s_{l+1}\)</span>不是既约的，则存在 <span class="math inline">\(1\leq i\leq l\)</span>使得 <span class="math inline">\(\alpha_{l+1}=s_l\cdotss_{i+1}\alpha_i\)</span>。于是 <span class="math inline">\(l\)</span>在集合 <span class="math inline">\(\{i\leq k\leq l \mid (s_k\cdotss_{i+1})\alpha_i\notin S_k\}\)</span> 中。设 <span class="math inline">\(j\)</span> 是此集合的最小元素，<span class="math inline">\(\beta=s_j\cdots s_{i+1}\alpha_i\)</span>。由于<span class="math inline">\(\alpha_i\in S_i\)</span>，所以 <span class="math inline">\(j&gt;i\)</span>。于是 <span class="math inline">\(s_{j-1}\cdots s_{i+1}\alpha_i\inS_{j-1}\)</span>，<span class="math inline">\(\beta\ins_jS_{j-1}\)</span>。由于 <span class="math inline">\(s_j\cdotS_{j-1}\cap\Sigma\subset S_j\)</span> 这说明 <span class="math inline">\(\beta\)</span> 不是极小根。注意到 <span class="math inline">\((s_{i+1}\cdots s_j)\beta=\alpha_i\)</span> 和<span class="math inline">\((s_{j+1}\cdotss_l)^{-1}\beta=\alpha_{l+1}\)</span>，根据上面的引理 <span class="math inline">\(l(s_{r+1}\cdots s_l)\ne l-i\)</span>，这与 <span class="math inline">\(s_1\cdots s_l\in\mathcal{L}\)</span> 矛盾，所以<span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。</p></li><li><p>如果 <span class="math inline">\(s_1\cdots s_{l+1}\)</span>既约但不属于 <span class="math inline">\(\mathcal{L}\)</span>，则 <span class="math inline">\(\alpha_{l+1}=(s_l\cdotss_{i+1})\alpha_s(s&lt;i)\)</span>。设 <span class="math inline">\(i\leqj\leq l\)</span> 使得 <span class="math inline">\(\beta=(s_js_{j-1}\cdots s_i)\alpha_s\notinS_j\)</span>。如果 <span class="math inline">\(j\ne i\)</span>，则由于<span class="math inline">\(\{s_i\alpha_r\mid r&lt;i\}\cap\Sigma\subsetS_i\)</span> 这说明 <span class="math inline">\(\beta\)</span>不是极小根。若 <span class="math inline">\(j&gt;i\)</span> 同样可得<span class="math inline">\(\beta\)</span>不是极小根。于是根据上面同样的论证得出矛盾。</p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Make awesome gif animation in a few seconds with pure Python!</title>
      <link href="/gifmaze/index.html"/>
      <url>/gifmaze/index.html</url>
      
        <content type="html"><![CDATA[<p>This program can help you make gif animations of various algorithmsrunning on the 2d square grid.</p><blockquote><p><strong>Requirements</strong>: <code>tqdm</code> for showing processbar and <code>pillow</code> for reading images.</p></blockquote><h1 id="examples">Examples</h1><ul><li><p>Wilson’s uniform spanning tree algorithm (my favourite, 2349frames, 333KB, generated in 3 seconds):</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/wilson-bfs.gif"></p></li><li><p>Prim’s algorithm:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/prim.gif"></p></li><li><p>Kruskal’s algorithm:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/kruskal.gif"></p></li><li><p>Langton’s ant:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/langton-ant.gif"></p></li><li><p>Hilbert curve：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/hilbert.gif"></p></li><li><p>Conway’s game of life (gosper glider gun):</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/gosperglidergun.gif"></p></li></ul><h1 id="whats-special-about-this-program">What’s special about thisprogram</h1><p>The code is implemented in pure Python, no third-party modules norsoftwares are required, just built-in modules like <code>struct</code>,<code>random</code>, <code>colorsys</code> and some built-in functions,and without any “color” or “draw” function calls. In later versions Iadded some features like showing process bars (requires<code>tqdm</code>) and enabling the user to embed the animtion into abackground image (requires <code>pillow</code>). The program runs muchfaster than expected, it can generate highly optimized gif output inonly a few seconds. One drawback is that it’s not quite user-friendly:the user must have some basic knowledge of the GIF89a specification toknow how to set parameters correctly in the animation.</p><h1 id="how-did-this-program-come-out">How did this program comeout</h1><p>This program is motivated by Mike Bostock’s wonderful <a href="https://bl.ocks.org/mbostock/11357811">Javascript animation</a>. Afew years ago when I saw Mike’s page I immediately had the idea ofwriting a Python version to produce gif animations of Wilson’salgorithm. A first thought on this was to save the animation into framesand then pack them back into a whole gif. But the animation usuallycontains thousands of frames so this is definitely a horrible task andis far from being efficient. Luckily five years later I learnt theGIF89a specification by chance and suddenly realized the new approach ofencoding the animation into a byte stream. So basically I implemented asmall gif encoder first, then run the algorithm on a 2d grid (use a 2darray to represent it) and encode it into frames along the way.</p><h1 id="what-is-wilsons-algorithm">What is Wilson’s algorithm</h1><p>Consider the following problem:</p><blockquote><p><strong>Problem</strong>: Let <span class="math inline">\(G\)</span>be a finite, connected and undirected graph. How can one choose a randomspanning tree among all spanning trees of <span class="math inline">\(G\)</span> from uniform probability? (we shallcall such a tree an uniform spanning tree, or simply an<strong>UST</strong>.)</p></blockquote><p>The following image shows an UST of a 48x36 grid, the circled dot isthe root vertex:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/ust.png"></p><p>You might say “that’s easy, just write a program that lists allspanning trees and then use a random integer to choose one”. But let’sconsider the complete graph <span class="math inline">\(K_n\)</span> forexample: <span class="math inline">\(K_n\)</span> has <span class="math inline">\(n^{n/2}\)</span> many different spanning trees by<a href="https://en.wikipedia.org/wiki/Cayley%27s_formula">Cayley’sformula</a>, for <span class="math inline">\(n=100\)</span> this numberis <span class="math inline">\(100^{98}\)</span>, far more larger thanthe number of particles in the universe! (which is estimated about <span class="math inline">\(10^{90}\)</span>)</p><p>Currently the most efficient algorithm known is the one proposed inWilson’s paper</p><blockquote><p>“generating random spanning trees more quickly than the covertime”.</p></blockquote><p>It’s a random algorithm, that is, some times you may be very lucky toget an UST soon, or you may wait forever. But one can prove that thisalgorithm will terminate in finite steps with probability one (note thisdoes not exclude the possibility of running forever, think about this),and it performs really well in most cases.</p><p>The key to understand Wilson’s algorithm is the so called <a href="https://en.wikipedia.org/wiki/Loop-erased_random_walk">loop erasedrandom walk</a>, that is, once the random walk visits a vertex thatalready existed in its path, it immediately erases the loop betweenthese two visits and continues the walk from this vertex. Just watch theJavascript animation if you don’t understand this, it’s obvious to seewhat “loop erased random walk” means from it. (click on the canvas torestart the animation)</p><script type="text/javascript" src="/images/code/wilson.js"></script><div data-align="center"><canvas id="wilson" width="600" height="600"></canvas></div><p>The algorithm runs as follows:</p><blockquote><p><strong>Wilson’s algorithm</strong>:</p><ol type="1"><li>Choose any vertex <span class="math inline">\(v\)</span> as the rootand maintain a tree <span class="math inline">\(T\)</span>, initially<span class="math inline">\(T=\{v\}\)</span>.</li><li>For any vertex <span class="math inline">\(z\)</span> that is not in<span class="math inline">\(T\)</span>, start a loop erased random walkfrom <span class="math inline">\(z\)</span> until the walk hits <span class="math inline">\(T\)</span>, then add the resulting path of thewalk to <span class="math inline">\(T\)</span>.</li><li>Repeat step 2 until all vertices of the graph are in <span class="math inline">\(T\)</span>.</li></ol></blockquote><p>The proof of the correctness of this algorithm is a bit tricky andwill not be discussed here, you may refer to Wilson’s original paper orthe book by Russell Lyons and Yuval Peres:</p><blockquote><p>“Probability on Trees and Networks”.</p></blockquote><h1 id="implementation">Implementation</h1><p>As mentioned before, the animation of Wilson’s algorithm (and alsoLangton’s ant animation) usually contains thousands of frames in it, soit’s quite surprising that this program takes only a few seconds toproduce a highly optimized image. The key points are:</p><ul><li><p>Only encode a minimum region at a time. We can maintain arectangular region to store which cells are changed between successiveframes, this enables us to encode only a small portion of the windowinstead of the whole into a frame.</p></li><li><p>Use variable mimimum code length for the LZW compression. Whenencoding a frame into bytearrays LZW compression allows the minimum codelength <span class="math inline">\(k\)</span> can be as small as thecolor depth of this frame (and must satisfy <span class="math inline">\(2\leq k\leq12\)</span>), this is another benifitsince most frames only contain very few colors.</p></li><li><p>Write the frames to a temporary <code>BytesIO</code> file inmemory and flush it to disk in the end.</p></li></ul><p>The code is divided into three layers: at the top layer is the<code>Maze</code> class on which we run various algoirthms. This layerknows nothing about the gif image. At the bottom layer is the<code>GIFSurface</code> class which holds the raw information like imagesize, global color table, number of loops, background color index, etc.It knows nothing about the <code>Maze</code>. At the middle layer is the<code>Animation</code> class which controls how the <code>Maze</code> isencoded and writes to the <code>GIFSurface</code>.</p><h1 id="a-short-introduction-to-the-gif89a-specification">A shortintroduction to the GIF89a specification</h1><p>In this section I’ll give a not-so-detailed introduction to theGIF89a specification. It’s not meant to be comprehensive norself-contained, you should always refer to <a href="http://giflib.sourceforge.net/whatsinagif/index.html">What’s in aGIF</a> when you have difficulties understanding my words here.</p><p>Roughly a GIF image consists of:</p><blockquote><p><strong>Structure of a GIF File</strong></p><ol type="1"><li>Always begins with 6 bytes <code>GIF89a</code>.</li><li>Then follows the <strong>logical screen descriptor</strong> whichspecifies the width and height of the image and the size of the<strong>global color table</strong>.</li><li>Then follows the global color table.</li><li>Then follows the <strong>loop control block</strong> which specifiesthe number of loops of the image.</li><li>Then comes the actual data of the frames. The data of each frame canbe further divided into 3 parts:<ol type="1"><li>the <strong>graphics control block</strong> which specifies thedelay and transparent color of this frame.</li><li>the <strong>image descriptor</strong> which specifies the relativeposition of this frame in the window and the size of the local colortable.</li><li>the local color table of this frame (if there is a local color tablefor this frame).</li><li>the LZW compressed pixel data of this frame.</li></ol></li><li>Finally the image file ends with a byte <code>0x3B</code>.</li></ol></blockquote><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>The above description does not apply to all GIF images, there canbe some variations. For example:</p><ol type="1"><li><p>The image may not contain a global color table (so you have tospecify a local color table for each frame).</p></li><li><p>For a static image the loop control block is not required; for astacit frame the graphcs control block is not required.</p></li><li><p>The file may end without the byte <code>0x3B</code>, mostdecoders can still decode the image correctly.</p></li></ol></div><p>Now we explain each part in more details.</p><h2 id="the-header-gif89a">The header GIF89a</h2><p>In python you can write it as</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">'6s'</span>, <span class="hljs-string">b'GIF89a'</span>)<br></code></pre></td></tr></tbody></table></figure><p>Why <code>b'GIF89a'</code> not simply <code>'GIF89a'</code>? This isfor compatibility with Python2 and 3 since the default encoding inPython3 is unicode whereas in python2 it’s ascii.</p><h2 id="the-logical-screen-descriptor">The logical screendescriptor</h2><p>Example:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">'&lt;2H3B'</span>, width, height, <span class="hljs-number">0b10010001</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><p>Here you shoud note the format string <code>&lt;</code> (littleendian).</p><p>The byte <code>0b10010001</code> is called a packed field. Let’s readit from left to right:</p><ol type="1"><li>The first bit 1 means we have a global color table (0 forabsent).</li><li>The next 3 bits specify the “color depth”. You don’t need care aboutwhat they mean since modern decoders like firefox and chrome do not usethem.</li><li>The fifth bit is the “sort flag” and is not used today, always setto 0.</li><li>The ending 3 bits represent an integer <span class="math inline">\(x\)</span> in range 0-7, <span class="math inline">\(x\)</span> specifies the size of the global colortable (<span class="math inline">\(=2^{x+1})\)</span>.</li></ol><p>The last two bytes are of little importance and we don’t discuss themhere.</p><h2 id="global-color-table">Global color table</h2><p><strong>Example</strong>: if we want to use 4 colors red, green,blue, yellow, then the global color table can be written as</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">bytearray</span>([<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>])<br></code></pre></td></tr></tbody></table></figure><p>It’s important that the number of colors in this array must be apower of 2 and match the size of the global color table specified in thepacked byte in the logical screen descriptor, otherwise the decoder willnot be able to parse the image correctly.</p><h2 id="graphics-control-block">Graphics control block</h2><p><strong>Example</strong>:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">"&lt;4BH2B"</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0xF9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0b00000101</span>, delay, trans_index, <span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><p>The 3 beginning bytes <code>0x21, 0xF9, 4</code> are fixed and areused to inform the decoder “Hey, I’m a graphics control block, see thenext 4 bytes!”</p><p>The next byte <code>0b00000101</code> is also a packed field, let’sread it from left to right:</p><ol type="1"><li>The first 3 bits are useless and are always 0.</li><li>The next 3 bits are called “desposal method”, they represent aninteger <span class="math inline">\(x\)</span> in range 0-7 and <span class="math inline">\(x\)</span> specifies how we should dispose thisframe after it’s displayed.<ol type="1"><li><p><span class="math inline">\(x=0\)</span> means it’s undefined,decoders will use default 1 instead in this case.</p></li><li><p><span class="math inline">\(x=1\)</span> is the default, it meansleave this frame here. So if the next frame is not overlapped with thisframe then both these two frames will be displayed. Otherwise theoverlapped area in this frame will be covered by the next one. See theexample below:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/disposal1.gif"></p></li><li><p><span class="math inline">\(x=2\)</span> means remove this frameand restore the image to background image/color, see the followingexample:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/disposal2.gif"></p><p>You can see each frame is remove immediately after it’s displayed,and its region is filled with transparent background (so you are reallyseeing the browser’s background color through the image).</p></li><li><p><span class="math inline">\(x=3\)</span> also means remove thisframe, but restore the image to the previous frame.<img style="margin:0px auto;display:block" src="/images/gifmaze/disposal3.gif"></p></li><li><p>4-7 are unused.</p></li></ol></li></ol><p>The next 2 bytes <code>delay</code> specifies the delay of the framein centiseconds, so <code>delay=3</code> means “keep staying here for0.03 second”.</p><p>The last byte <code>trans_index</code> specifies the transparentcolor in this frame, the pixels in this frame using this color aretransparent: you can see the previous frame through them (of course onlywhen the previous frame is still there (reserved), otherwise you areseeing the previous previous frame, …, etc).</p><h2 id="image-descriptor-block">Image descriptor block</h2><p>Example:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">'&lt;B4HB'</span>, <span class="hljs-number">0x2C</span>, left, top, width, height, <span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><p>Quite straight-forward to understand. Note the last byte is 0 sincewe do not need local color tables here.</p><h2 id="the-lzw-compression-algorithm">The LZW compressionalgorithm</h2><p>Finally we are left with the most difficult part: the LZW algorithm.It’s too long to include an introduction to the algorithm here, soplease refer to <a href="http://www.matthewflickinger.com/lab/whatsinagif/lzw_image_data.asp">thesecond article in What’s in a gif</a> for a complete treatment. But it’squite simple to implement it in Python, see the file <a href="https://github.com/neozhaoliang/pywonderland/blob/master/src/gifmaze/gifmaze/encoder.py">encoder.py</a>for an example.</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Reaction-Diffusion simulation with pyglet and glsl</title>
      <link href="/grayscott/index.html"/>
      <url>/grayscott/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/grayscott">Thisproject</a> is motivated by <a href="http://pmneila.github.io/jsexp/grayscott/">pmneila’s javascriptproject</a>. The core part of the code are the two GLSL shaders<code>reaction.frag</code> and <code>render.frag</code>. The pythonscripts are merely for setting the UI and compiling the GLSL code.</p><blockquote><p>Requirements: <code>pyglet</code> for the UI and OpenGL environmentand <code>ffmpeg</code> for saving the animation to video files.</p></blockquote><h1 id="examples">Examples</h1><ol type="1"><li><p>Unstable</p><p><video src="/images/grayscott/unstable.mp4" controls=""></video></p></li><li><p>Coral</p><p><video src="/images/grayscott/coral.mp4" controls=""></video></p></li><li><p>Baceria</p><p><video src="/images/grayscott/bacteria.mp4" controls=""></video></p></li></ol><h1 id="usage">Usage</h1><p>You may simply run <code>python main.py</code> and then use keyboardand mouse to play with the simulation (for keyboard and mouse controlplease see the printed doc).</p><p>You may also initialize the window by passing more options:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python main.py -size 800x600 -fps 400 -conf 1 -scale 2<br></code></pre></td></tr></tbody></table></figure><p>Here <code>-size</code> is the size of the window, <code>-fps</code>is the frames per second of the animation, if not specified then maxpossible value will be used, <code>-conf</code> is the line number ofthe pattern that the program will load from the file<code>config.txt</code> (which contains a few precomputed patterns),<code>-scale</code> is the “resolution” factor of the texture.</p><p>You may also use an image file to control the growth of the patternby adding the <code>-mask</code> option:</p><video src="/images/grayscott/mask.mp4" controls=""><h1 id="how-to-save-the-animation-to-a-video-file">How to save theanimation to a video file</h1><p>Make sure <code>ffmpeg</code> is installed on your computer and canbe found on system path, windows users need to manually add the path toyour ffmpeg.exe to environment variables, then press <code>ctrl+v</code>to start saving the video and press <code>ctrl+v</code> again to stopthe saving.</p><p>You can use the option <code>-videorate</code> to control the fps ofthe video (not the animation!) and the option <code>-samplerate</code>to control how often a frame is sampled from the animation. If theframes are sampled too frequently the size of the video file will growvery large.</p><h1 id="about-the-code">About the code</h1><p><code>pyglet</code> is only a thin wrapper of OpenGL so one has towrite his own classes to manage things like <code>vao</code>,<code>vbo</code>, <code>framebuffer</code>, etc. There are some moduleslike <code>vispy</code> and <code>gletools</code> that does similar job,but that lays the burden of learning one more package.</p><p>I wrote two scripts <code>shader.py</code> and<code>framebuffer.py</code> for compiling the shader programs andrendering to texture. They are not meant to be serious tools, just keptsimple and suffice for our work.</p><p>The GLSL code borrows heavily from pmneila’s work, the most geniuspart in his code is the use of a <code>brush</code> variable(<code>u_mouse</code> in our program) as the interface between theshader and the UI.</p></video>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Humphreys《反射群与 Coxeter 群》笔记</title>
      <link href="/humphreys/index.html"/>
      <url>/humphreys/index.html</url>
      
        <content type="html"><![CDATA[<p>本文是我学习 <span class="citation" data-cites="Humphreys90">Humphreys (<a href="#ref-Humphreys90" role="doc-biblioref">1990</a>)</span> 时的一些笔记。</p><span id="more"></span><h1 id="generation-by-simple-reflections">1.5 Generation by simplereflections</h1><p>这一节证明了整个反射群 <span class="math inline">\(W\)</span>可以由单反射 <span class="math inline">\(\{s_\alpha\mid\alpha\in\Delta\}\)</span>生成。</p><div id="thm-1.5" class="statement sta____1_5 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">定理1.5</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 可以由 <span class="math inline">\(\{s_\alpha\mid\alpha\in\Delta\}\)</span>生成。</p></div><p><strong>证明概要</strong>：设 <span class="math inline">\(W'\)</span> 是 <span class="math inline">\(\{s_\alpha\mid\alpha\in\Delta\}\)</span>生成的群。目标是证明 <span class="math inline">\(W'=W\)</span>。我们来一步步推理：</p><ol type="1"><li>由于 <span class="math inline">\(W\)</span>是由关于整个根系的镜面反射 <span class="math inline">\(\{s_\beta\mid\beta\in\Phi\}\)</span> 生成的，所以只要证明每个生成元 <span class="math inline">\(s_\beta\in W'\)</span> 即可。</li><li>要证明 1，只要证明任何 <span class="math inline">\(\beta\in\Phi\)</span> 可以写成 <span class="math inline">\(\beta=w'\alpha\)</span> 的形式，其中 <span class="math inline">\(w'\in W',\,\alpha\in\Pi\)</span>。这样<span class="math inline">\(s_\beta=w's_\alpha w'^{-1}\inW'\)</span>。</li><li>要证明 2，只需要分析 <span class="math inline">\(\beta\)</span>是正根且不是单根的情形，因为 <span class="math inline">\(-\beta =w's_\alpha\alpha\)</span>。</li><li>如果 <span class="math inline">\(\beta&gt;0\)</span> 但不是单根，设<span class="math inline">\(\beta=\sum c_s\alpha_s\)</span>，那么 <span class="math inline">\(0&lt;(\beta,\beta)=\sum c_s(\beta,\alpha_s)\)</span>，这说明一定存在单根 <span class="math inline">\(\alpha_s\)</span> 满足 <span class="math inline">\((\beta,\alpha_s)&gt;0\)</span>。考察 <span class="math inline">\(\gamma=s\beta\)</span>。</li><li><span class="math inline">\(\gamma\)</span> 仍然是正根，并且 <span class="math inline">\(\mathrm{ht}(\gamma) &lt;\mathrm{ht}(\beta)\)</span>。如果 <span class="math inline">\(\gamma\)</span> 不是单根，那就一直重复此步骤直到<span class="math inline">\(\gamma\)</span>变成单根为止。这个操作一定会在有限次后终止，否则我们会得到一个无穷的、高度严格降低、从而互不相同的正根序列，这与根系是有限集矛盾。</li><li>设 <span class="math inline">\(\gamma=s_1\cdotss_r\beta\in\Delta\)</span> 是最终得到的单根，则 <span class="math inline">\(\beta\in W'\Delta\)</span>，结论成立。<span class="math inline">\(\blacksquare\)</span></li></ol><h1 id="the-length-function">1.6 The length function</h1><p>这一节证明了函数 <span class="math inline">\(n(w)\)</span>满足的递推关系。</p><p>设 <span class="math inline">\(\mathrm{Neg}(w)\)</span> 是那些被<span class="math inline">\(w\)</span> 变成负根的正根的集合： <span class="math display">\[\mathrm{Neg}(w)=\{\lambda&gt;0,\lambda\in\Phi\midw\lambda&lt;0\}.\]</span> 并记 <span class="math inline">\(n(w)=|\mathrm{Neg}(w)|\)</span>。</p><div id="lem-1.6" class="statement sta____1_6 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">引理1.6</span>.</span><span class="statement-spah"> </span> 函数 <span class="math inline">\(n(w)\)</span> 满足如下的递推关系： <span class="math display">\[n(ws_\alpha)=\begin{cases}n(w)+1 &amp; w\alpha&gt;0,\\n(w)-1 &amp; w\alpha&lt;0.\end{cases}\]</span></p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在后面 5.4 节中，针对一般的 Coxeter 群证明了长度函数 <span class="math inline">\(l(w)\)</span> 也满足同样的递推关系，从而 <span class="math inline">\(l(w)=n(w)\)</span>。但是那里的证明要复杂一些。</p></div><p><strong>证明</strong>：首先注意到任何单根 <span class="math inline">\(\alpha\in\Delta\)</span> 必然恰好属于 <span class="math inline">\(\mathrm{Neg}(w)\)</span> 或者 <span class="math inline">\(\mathrm{Neg}(ws_\alpha)\)</span> 之一，这取决于<span class="math inline">\(w\alpha\)</span> 是正根还是负根：</p><ul><li><span class="math inline">\(w\alpha&lt;0\Rightarrow\alpha\in\mathrm{Neg}(w)\)</span>。</li><li><span class="math inline">\(w\alpha&gt;0\Rightarrowws_\alpha\alpha&lt;0\Rightarrow \alpha\in\mathrm{Neg}(ws_\alpha)\)</span>。</li></ul><p>另一方面对任何正根 <span class="math inline">\(\gamma\ne\alpha\)</span>，<span class="math inline">\(s_\alpha\gamma\)</span> 仍然是正根。从恒等式 <span class="math display">\[(ws_\alpha)\gamma &lt; 0\Longleftrightarroww(s_\alpha\gamma)&lt;0\]</span> 可见 <span class="math inline">\(\gamma\in\mathrm{Neg}(ws_\alpha)\)</span> 当且仅当<span class="math inline">\(\gamma\in\mathrm{Neg}(w)\)</span>，所 <span class="math inline">\(\gamma\leftrightarrow s_\alpha\gamma\)</span>给出了 <span class="math inline">\(\mathrm{Neg}(ws_\alpha)\)</span> 和<span class="math inline">\(\mathrm{Neg}(w)\)</span> 中除 <span class="math inline">\(\alpha\)</span> 之外的正根的一一对应，所以</p><p><span class="math display">\[n(ws_\alpha)=\begin{cases}n(w)+1 &amp; \alpha\in\mathrm{Neg}(ws_\alpha),\\n(w)-1 &amp; \alpha\in \mathrm{Neg}(w).\end{cases}\]</span></p><p><span class="math inline">\(\blacksquare\)</span></p><h1 id="deletion-and-exchange-conditions">1.7 Deletion and ExchangeConditions</h1><p>这一节证明了有限反射群必然满足 deletion 和 exchange条件。开头的定理乍看起来非常不直观，包含了一大堆下标。我来解释下背后的几何直观。</p><p>设 <span class="math inline">\(w=s_1\cdots s_r\)</span> 是 <span class="math inline">\(W\)</span> 的任一元素。从基本区域 <span class="math inline">\(C\)</span> 出发，我们有一个gallery，即一列两两相邻的房间</p><p><span class="math display">\[C,\, s_1C,\, s_1s_2C,\, \ldots,\,s_1\cdots s_rC.\]</span></p><p>可以这样理解：记 <span class="math inline">\(w_i=s_1\cdotss_i\)</span>，则 <span class="math inline">\(w_{i-1}\)</span>将相邻的两个房间 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(s_iC\)</span> 映射为另外两个相邻的房间 <span class="math inline">\(w_{i-1}C\)</span> 和 <span class="math inline">\(w_iC\)</span>。</p><p>不仅如此，由于 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(s_iC\)</span> 之间的墙壁是超平面 <span class="math inline">\(H_i = H_{s_i}\)</span>，它在 <span class="math inline">\(w_{i-1}\)</span> 作用下被映射为超平面 <span class="math inline">\(w_{i-1}H_i\)</span>，所以 <span class="math inline">\(w_{i-1}C\)</span> 和 <span class="math inline">\(w_iC\)</span> 之间的墙壁是 <span class="math inline">\(w_{i-1} H_i\)</span>。即</p><p><span class="math display">\[C\stackrel{H_1}{\bigl\lvert} s_1C\stackrel{s_1H_2}{\bigl\lvert}s_1s_2C\stackrel{\quad}{\bigl\lvert}\cdots\stackrel{w_{r-1}H_r}{\bigl\lvert}w_{r}C.\]</span></p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>表达式 <span class="math inline">\(w=s_1s_2\cdots s_r\)</span>是既约的，当且仅当上述镜面集合 <span class="math display">\[\{H_1,s_1H_2,\ldots,s_1\cdotss_{r-1}H_r\}\]</span> 互不相同。</p></div><p>这个引理的含义是，任何既约单词对应的 gallery不能两次跨越同一个超平面。</p><p>这个引理的证明见 4.5 小节 simpletransitivity。那里仿射的情形和这里的证明是一样的。</p><p>我们来问问自己，如果一个镜子在上面的集合中出现两次会发生什么？设<span class="math inline">\(1\leq i&lt;j\leq r\)</span> 使得 <span class="math display">\[s_1\cdots s_{i-1}H_i = s_1\cdotss_{j-1}H_j.\]</span> 两边消去 <span class="math inline">\(s_1\cdotss_{i-1}\)</span> 得到 <span class="math display">\[H_i = s_i\cdotss_{j-1}H_j.\]</span> 即 <span class="math display">\[s_i = (s_i\cdotss_{j-1})s_j(s_{j-1}\cdots s_i)=(s_i\cdots s_{j})(s_{j-1}\cdotss_i).\]</span> 把右边的 <span class="math inline">\(s_{j-1}\cdotss_i\)</span> 挪到左边来得到 <span class="math display">\[s_{i+1}\cdotss_{j-1} = s_i\cdots s_j.\]</span> 这意味着 <span class="math inline">\(s_i\cdots s_j\)</span> 这一段可以用更短的 <span class="math inline">\(s_{i+1}\cdots s_{j-1}\)</span>来代替，这就是书中定理 1.7 中的 (c)。</p><h1 id="generators-and-relations">1.9 Generators and relations</h1><p>这是比较难读的一节。这一节证明了满足 deletion 条件的有限反射群一定是Coxeter 群。</p><div id="thm-1.9" class="unnumbered statement sta____1_9 plain"><p><span class="statement-heading"><span class="statement-label">定理1.9</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\Delta\)</span> 是某 Euclidean 的一组基，<span class="math inline">\(S=\{s_\alpha\mid \alpha\in\Delta\}\)</span>是一组单反射，<span class="math inline">\(W\)</span> 是 <span class="math inline">\(S\)</span> 生成的群，并且 <span class="math inline">\(W\)</span> 满足 deletion 条件。则 <span class="math inline">\(W\)</span> 具有表现 <span class="math display">\[(s_\alpha s_\beta)^{m_{\alpha,\beta}}=1.\]</span>其中 <span class="math inline">\(m_{\alpha,\beta}\geq1\in\mathbb{Z}\)</span>。</p></div><p>注意 <span class="math inline">\(m_{\alpha,\alpha}=1\)</span>。</p><p><strong>证明</strong>：我们要说明生成元之间的任何关系 <span class="math display">\[s_1s_2\cdots s_r=1\]</span> 都可以通过形如 <span class="math inline">\((s_\alpha s_\beta)^{m_{\alpha,\beta}}=1\)</span>这样的关系推导出来。</p><p>若不然，设 <span class="math display">\[s_1s_2\cdots s_r=1,\quadr=2q\]</span> 是一个长度最短的反例。这里 <span class="math inline">\(r\)</span> 必须是偶数，因为每个 <span class="math inline">\(\det s_i=-1\)</span>。</p><p>我们将证明有 <span class="math inline">\(s_1=s_3=\cdots\)</span> 以及<span class="math inline">\(s_2=s_4=\cdots\)</span>成立，从而上述关系可以写成 <span class="math inline">\((s_1s_2)^q=1\)</span>，得出矛盾。</p><ul><li><p>我们只要证明 <span class="math inline">\(s_1=s_3\)</span>即可。然后将结论用在 <span class="math inline">\(s_2s_3\cdotss_rs_1=1\)</span> 上得到 <span class="math inline">\(s_2=s_4\)</span>；再进一步用在 <span class="math inline">\(s_3s_4\cdots s_rs_2s_1=1\)</span> 上得到 <span class="math inline">\(s_3=s_5\)</span>，等等。</p></li><li><p>为此我们只要证明如下两个等式：</p><p>(I). <span class="math inline">\(s_1s_2\cdots s_q=s_2s_3\cdotss_{q+1}\)</span>.</p><p>(II). <span class="math inline">\(s_3s_2\cdots s_q=s_2s_3\cdotss_{q+1}\)</span>.</p><p>这两个式子几乎是一样的，第一个最左边是 <span class="math inline">\(s_1\)</span>，第二个最左边是 <span class="math inline">\(s_3\)</span>，所以如果它们都成立的话就有 <span class="math inline">\(s_1=s_3\)</span>。</p></li><li><p>为了证明 I，我们把 <span class="math inline">\(s_1\cdotss_r=1\)</span> 改写为 <span class="math display">\[s_1\cdots s_{q+1} =s_r\cdots s_{q+2}.\]</span> 左边是 <span class="math inline">\(q+1\)</span> 项的乘积，右边是 <span class="math inline">\(q-1\)</span> 项的乘积，所以 <span class="math inline">\(l(s_1\cdots s_{q+1})\leq q-1\)</span>。根据deletion 条件，存在 <span class="math inline">\(1\leq i&lt;j\leqq+1\)</span> 使得有 <span class="math display">\[s_i\cdots s_j =s_{i+1}\cdots s_{j-1}. \tag{$\ast$}\]</span> 我们来论证 <span class="math inline">\(i=1,j=q+1\)</span>，也就是 I 成立。若不然，<span class="math inline">\((\ast)\)</span> 式至多包含 <span class="math inline">\(2q-2=r-2\)</span> 项，从而由假设可以由 Coxeter关系 <span class="math inline">\(\{(s_\alphas_\beta)^{m_{\alpha,\beta}}=1\mid \alpha,\beta\in\Delta\}\)</span>推导出来。然而 <span class="math inline">\((\ast)\)</span> 式等价于<span class="math display">\[s_1\cdots s_r =s_1\cdots\hat{s_i}\cdots\hat{s_j}\cdots s_r.\]</span> 此外我们已知 <span class="math inline">\(s_1\cdots s_r=1\)</span>，所以 <span class="math display">\[s_1\cdots\hat{s_i}\cdots\hat{s_j}\cdotss_r=1.\]</span> 根据 <span class="math inline">\(r\)</span>的选取，<span class="math inline">\(s_1\cdots\hat{s_i}\cdots\hat{s_j}\cdotss_r=1\)</span> 可以由 Coxeter 关系推导得到，从而 <span class="math inline">\(s_1\cdots s_r=1\)</span>也可以，这导致了矛盾，于是 I 得证。</p></li><li><p>为了证明 II，将 <span class="math inline">\(s_1\cdots s_r=1\)</span> 改写为 <span class="math inline">\(s_2\cdotss_rs_1=1\)</span>，仿照 I 的证明，我们可以得到 <span class="math display">\[s_2\cdots s_{q+1} = s_3(s_4\cdotss_{q+2}).\]</span> 把 <span class="math inline">\(s_3\)</span>挪到左边的前面，把 <span class="math inline">\(s_4\cdotss_{q+2}\)</span> 挪到左边的后面，得到 <span class="math display">\[s_3s_2\cdots s_{q+1}s_{q+2}\cdots s_4 =1.\]</span> 仍然和 I 的证明同理，我们可以得到 <span class="math display">\[s_3s_2\cdots s_q = s_2\cdots s_{q+1}.\]</span>这就是 II 中的等式。</p></li></ul><p><span class="math inline">\(\blacksquare\)</span></p><h1 id="subgraphs">2.6 Subgraphs</h1><p>在本节中，<span class="math inline">\(\Gamma\)</span> 是一个不可约Coxeter 图，内积 <span class="math inline">\((\alpha_s,\alpha_t)=-\cos\frac{\pi}{m_{s,t}}\)</span>是半正定的，但不是正定的。</p><p>记 <span class="math inline">\(N=\{v\in V\mid (v,v)=0\}\)</span> 以及<span class="math display">\[\mathrm{rad}(V)=\{v\in V\mid (v, u)=0\text{ for all } u \in V\}.\]</span> 显然 <span class="math inline">\(\mathrm{rad}(V)\)</span> 总是 <span class="math inline">\(V\)</span> 的子空间并且 <span class="math inline">\(\mathrm{rad}(V)\subset N\)</span>，但是一般来说<span class="math inline">\(N\)</span> 并不是 <span class="math inline">\(V\)</span> 的子空间。</p><p>但是在内积半正定时，我们有如下的结论：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>若内积半正定，则 <span class="math inline">\(N=\mathrm{rad}(V)\)</span>。</p></div><p>证明：只要证明 <span class="math inline">\(N\subset\mathrm{rad}(V)\)</span> 即可，即若 <span class="math inline">\(u\in V\)</span> 满足 <span class="math inline">\((u,u)=0\)</span>，则对任何 <span class="math inline">\(v\in V\)</span> 都有 <span class="math inline">\((u,v)=0\)</span>。若不然，设 <span class="math inline">\(v\)</span> 满足 <span class="math inline">\((u,v)\ne0\)</span>，我们给 <span class="math inline">\(v\)</span> 乘以适当实数使得 <span class="math inline">\((u,v)=1\)</span>。设 <span class="math inline">\(k\)</span> 是实数，考虑向量 <span class="math inline">\(z=ku +v\)</span>： <span class="math display">\[(z,z)=(ku+v,ku+v) = (v,v) + 2k.\]</span>所以只要选择 <span class="math inline">\(k\)</span> 满足 <span class="math inline">\(2k &lt; -(v,v)\)</span> 就有 <span class="math inline">\((z,z)&lt;0\)</span>，这与内积的半正定性矛盾。<span class="math inline">\(\blacksquare\)</span></p><p>这一节的主要结论是：</p><div id="-------2-6" class="unnumbered statement sta____2_6 plain"><p><span class="statement-heading"><span class="statement-label">命题2.6</span>.</span></p><ol type="1"><li><span class="math inline">\(\mathrm{rad}(V)\)</span>是一维的，由一个向量 <span class="math inline">\(\delta=\sum_{s\inS}c_s\alpha_s\)</span> 生成，并且每个系数 <span class="math inline">\(c_s\)</span> 都大于 0。</li><li><span class="math inline">\(\Gamma\)</span>删去任意多个顶点后得到的子图是正定的。</li></ol></div><p>这里给出一个不同于 Humphreys 书上的证明。</p><p>1 的证明：</p><p>设 <span class="math inline">\(u=\sum_{s\inS}c_s\alpha_s\in\mathrm{rad}(V)\)</span> 是一个非零向量，记 <span class="math display">\[I_+=\{s\in S\mid c_s&gt;0\},\quad I_-=\{s\inS\mid c_s&lt;0\},\quad I_0=\{s\in S\mid c_s=0\}.\]</span> <span class="math display">\[u_+=\sum_{s\in I_+}c_s\alpha_s,\quadu_-=\sum_{s\in I_-}c_s\alpha_s.\]</span> 则 <span class="math inline">\(u=u_++u_-\)</span>，并且 <span class="math display">\[(u_+,u_-)=\sum_{c\in I_+}\sum_{t\inI_-}\underbrace{c_sc_t}_{&lt;0}\,\underbrace{\alpha_s\alpha_t}_{\leq0}\geq0.\]</span></p><p>由于 <span class="math inline">\(u\in\mathrm{rad}(V)\)</span> 所以<span class="math inline">\((u,u)=0\)</span>，即 <span class="math display">\[(u,u)=(u_+,u_+)+(u_-,u_-)+2(u_+,u_-)=0.\]</span>根据半正定性和上面的分析，上式的三项都是非负的，所以只能是 <span class="math display">\[(u_+,u_+)=(u_-,u_-)=(u_+,u_-)=0.\]</span></p><p>此外 <span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 中至少有一个非空，不妨设 <span class="math inline">\(I_+\ne\emptyset\)</span>，我们来证明 <span class="math inline">\(I_-\)</span> 和 <span class="math inline">\(I_0\)</span> 必须都是空集。</p><p>若不然，<span class="math inline">\(I_-\cup I_0\)</span> 非空，任取<span class="math inline">\(t\in I_-\cup I_0\)</span>，设 <span class="math inline">\(\delta\)</span> 是正数，考虑向量 <span class="math inline">\(z=u_+ +\delta\alpha_t\)</span>。我们有</p><p><span class="math display">\[(z,z)=\delta^2+2\delta(u_+,\alpha_t)=\delta^2+2\delta\sum_{s\inI_+}\underbrace{c_s}_{&gt;0}\underbrace{(\alpha_s,\alpha_t)}_{\leq0}.\]</span>注意到每一项 <span class="math inline">\(c_s(\alpha_s,\alpha_t)\leq0\)</span>，所以 <span class="math inline">\(\sum_{s\inI_+}c_s(\alpha_s,\alpha_t)\leq0\)</span>，并且如果存在 <span class="math inline">\(s\in I_+\)</span> 使得 <span class="math inline">\(s\)</span> 与 <span class="math inline">\(t\)</span> 之间有边相连的话则 <span class="math inline">\(\sum_{s\in I_+}c_s(\alpha_s,\alpha_t)\)</span>严格小于 0。这时取 <span class="math inline">\(\delta\)</span>足够小可以使得 <span class="math inline">\((z,z)&lt;0\)</span>，这与内积<span class="math inline">\((,)\)</span>是半正定的矛盾。所以必须是对每个 <span class="math inline">\(s\inI_+\)</span> 有 <span class="math inline">\((\alpha_s,\alpha_t)=0\)</span>。由 <span class="math inline">\(t\)</span> 的任意性可得 <span class="math inline">\(I_-\cup I_0\)</span> 与 <span class="math inline">\(I_+\)</span> 互不连通，但这又与 <span class="math inline">\(\Gamma\)</span> 不可约矛盾。</p><p>总之我们证明了 <span class="math inline">\(\mathrm{rad}(V)\)</span>中非零向量的系数必须同时为正或者同时为负。</p><p>如果 <span class="math inline">\(\mathrm{rad}(V)\)</span>包含两个线性无关的向量 <span class="math inline">\(u,v\)</span>，根据上面的证明，我们可以不妨设 <span class="math inline">\(u,v\)</span>的各项系数都是正数。适当缩放以后我们可以让 <span class="math inline">\(u,v\)</span> 的 <span class="math inline">\(\alpha_1\)</span> 项系数都是 1。于是 <span class="math inline">\(u-v\)</span> 也在 <span class="math inline">\(\mathrm{rad}(V)\)</span> 中，并且其 <span class="math inline">\(\alpha_1\)</span> 项系数是 0，这就导致了矛盾。</p><p>2 的证明：</p><p>我们只要证明若 <span class="math inline">\(I\subsetneqq\Gamma\)</span> 是真子集，则对任何非零向量 <span class="math inline">\(u=\sum_{s\in I}c_s\alpha_s\)</span> 都有 <span class="math inline">\((u,u)&gt;0\)</span>。若不然，<span class="math inline">\(u=\sum_{s\in I}c_s\alpha_s+\sum_{t\notinI}0\cdot\alpha_t\)</span> 并且 <span class="math inline">\((u,u)=0\)</span>，这与 <span class="math inline">\(u\)</span> 的系数必须全部非零矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 id="uniqueness-of-the-degrees">3.7 Uniqueness of the degrees</h1><p>这一节介绍了不变多项式环 <span class="math inline">\(S^G\)</span>的任何一组齐次生成元的次数 <span class="math inline">\(d_1,d_2,\ldots,d_n\)</span>是唯一确定的。证明不难，但是采用的方法很典型，以后会反复用到。</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(f_1,\ldots,f_n\inK[x_1,\ldots,x_n]\)</span> 是一组齐次、代数无关的多项式；其次数分别为<span class="math inline">\(d_1,\ldots,d_n\)</span>；<span class="math inline">\(g_1,\ldots,g_n\)</span>是另一组齐次、代数无关的多项式，次数分别为 <span class="math inline">\(e_1,\ldots,e_n\)</span>，并且每个 <span class="math inline">\(g_i\)</span> 可以写成 <span class="math inline">\(f_1,\ldots,f_n\)</span> 的多项式，则适当重排以后有<span class="math inline">\(e_i\geq d_i\)</span>。</p></div><p>证明：利用链式法则对导可得 <span class="math display">\[\frac{\partial g_i}{\partial x_k} = \sum_{j=1}^n\frac{\partial g_i}{\partial f_j}\frac{\partial f_j}{\partialx_k}.\]</span></p><p>由于 <span class="math inline">\(g_1,\ldots,g_n\)</span>代数无关，根据 Jacobian 判定左边的矩阵 <span class="math inline">\(\left(\frac{\partial g_i}{\partialx_k}\right)\)</span> 可逆，从而右边的矩阵 <span class="math inline">\(\left(\frac{\partial g_i}{\partialf_j}\right)\)</span> 也可逆，其行列式非零，于是存在置换 <span class="math inline">\(\pi\)</span> 使得 <span class="math display">\[\prod_{i=1}^n\frac{\partial g_i}{\partialf_{\pi(i)}}\ne0.\]</span> 适当重排 <span class="math inline">\(g_1,\ldots,g_n\)</span> 以后可以不妨设 <span class="math inline">\(\pi\)</span> 是恒等置换，即 <span class="math display">\[\prod_{i=1}^n\frac{\partial g_i}{\partialf_{i}}\ne0.\]</span> 这说明每个 <span class="math inline">\(\frac{\partial g_i}{\partialf_i}\ne0\)</span>，即当把 <span class="math inline">\(g_i\)</span> 写成<span class="math inline">\(f_1,\ldots, f_n\)</span> 的多项式时，<span class="math inline">\(f_i\)</span> 一定出现在其中。于是至少存在一个形如<span class="math display">\[f_1^{k_1}\cdots f_n^{k_n},\quad k_i\geq1\]</span> 的单项式，它出现在 <span class="math inline">\(g_i\)</span>的表达式中，并且不会被抵消掉。从而 <span class="math inline">\(e_i=\sumk_id_i\geq d_i\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="unique-degrees" class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span><span class="math inline">\(S^G\)</span>的任何一组齐次、代数无关生成元的次数是唯一却定的。</p></div><h1 id="coxeter-elements">3.16 Coxeter elements</h1><p>我们来证明任何两个 Coxeter 元都是共轭的。我们只要取一个特殊的 Coxeter元，并证明其它 Coxeter 元都和这个特殊元共轭即可。</p><p>首先，取 Coxeter 图 <span class="math inline">\(\Gamma\)</span>的一个叶节点，将其记作 <span class="math inline">\(s_n\)</span>。从<span class="math inline">\(\Gamma\)</span> 中移走 <span class="math inline">\(s_n\)</span> 以后，剩下的部分 <span class="math inline">\(\Gamma_1=\Gamma-\{s_n\}\)</span>仍然是一个树，于是我们又可以取其叶节点，记作 <span class="math inline">\(s_{n-1}\)</span>。<span class="math inline">\(\Gamma_1-\{s_{n-1}\}\)</span>仍然是树，又可以取其一个叶节点 <span class="math inline">\(s_{n-2}\)</span>，以此类推。即我们将生成元排列为<span class="math inline">\(s_1,\ldots,s_n\)</span>，使得对每个 <span class="math inline">\(1\leq i\leq n\)</span>，<span class="math inline">\(s_1,\ldots,s_i\)</span> 构成 <span class="math inline">\(\Gamma\)</span> 的一个子树，并且 <span class="math inline">\(s_i\)</span> 是这个树的叶节点。</p><p>首先我们注意到任何 Coxeter 元都可以通过循环移位共轭于某个以 <span class="math inline">\(s_n\)</span> 结尾的 Coxeter 元 <span class="math inline">\(s_{i_1}\cdotss_{i_{n-1}}s_n\)</span>，我们来证明这样的元素都共轭于 <span class="math inline">\(s_1s_2\cdots s_n\)</span>。</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>任何形如 <span class="math inline">\(s_{i_1}\cdotss_{i_{n-2}}{\color{blue}s_{i_{n-1}}}s_n\)</span> 的 Coxeter 元共轭于<span class="math display">\[{\color{blue}s_{i_{n-1}}}s_{i_1}\cdotss_{i_{n-2}}s_n.\]</span></p></div><p><strong>证明</strong>：如果 <span class="math inline">\(s_{i_{n-1}}\)</span> 与 <span class="math inline">\(s_n\)</span> 交换，那么 <span class="math display">\[s_{i_1}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}s_n\to s_{i_1}\cdotss_{i_{n-2}}s_n\textcolor{blue}{s_{i_{n-1}}}\to\textcolor{blue}{s_{i_{n-1}}}s_{i_1}\cdots s_{i_{n-2}}s_n.\]</span>结论成立。否则 <span class="math inline">\(s_n\)</span> 唯一的边是与<span class="math inline">\(s_{i_{n-1}}\)</span> 连接，从而 <span class="math inline">\(s_n\)</span> 与 <span class="math inline">\(\{s_{i_1},\ldots,s_{i_{n-2}}\}\)</span>都交换，所以 <span class="math display">\[\begin{aligned}s_{i_1}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}\textcolor{red}{s_n}&amp;\to\textcolor{red}{s_n}s_{i_1}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}\to s_{i_1}\textcolor{red}{s_n}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}\\&amp;\to s_{i_1}\cdotss_{i_{n-2}}\textcolor{red}{s_n}\textcolor{blue}{s_{i_{n-1}}}\\&amp;\to\textcolor{blue}{s_{i_{n-1}}}s_{i_1}\cdotss_{i_{n-2}}\textcolor{red}{s_n}.\end{aligned}\]</span> 结论同样成立。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(k\geq1\)</span>，任何形如 <span class="math inline">\(s_{i_1}\cdots\textcolor{blue}{s_{i_{n-k}}}s_{n-k+1}\cdots s_n\)</span> 的 Coxeter 元都共轭于 <span class="math display">\[\textcolor{blue}{s_{i_{n-k}}} s_{i_1}\cdotss_{i_{n-k-1}}s_{n-k+1}\cdots s_n.\]</span></p></div><p><strong>证明</strong>：<span class="math inline">\(k=1\)</span>的情形在前一个的引理中已经证明了。对 <span class="math inline">\(k\geq2\)</span> 用归纳法，假设结论对小于 <span class="math inline">\(k\)</span> 的情形成立。</p><p>如果 <span class="math inline">\(s_{i_{n-k}}\)</span> 和 <span class="math inline">\(s_{n-k+1}\)</span> 交换，那么 <span class="math display">\[s_{i_1}\cdots \textcolor{blue}{s_{i_{n-k}}}s_{n-k+1}\cdots s_n\to s_{i_1}\cdotss_{n-k+1}\textcolor{blue}{s_{i_{n-k}}}\cdots s_n.\]</span></p><p>然而对 <span class="math inline">\(k-1\)</span>的情形应用归纳假设，上面右边共轭于 <span class="math display">\[\textcolor{blue}{s_{i_{n-k}}} s_{i_1}\cdotss_{n-k+1}\cdots s_n.\]</span> 于是结论成立。</p><p>如果 <span class="math inline">\(s_{i_{n-k}}\)</span> 和 <span class="math inline">\(s_{n-k+1}\)</span> 不交换，那么 <span class="math inline">\(s_{n-k+1}\)</span> 和所有 <span class="math inline">\(s_{i_1}\sim s_{i_{n-k-1}}\)</span>都交换，于是直接用归纳假设有 <span class="math display">\[s_{i_1}\cdots\textcolor{blue}{s_{i_{n-k}}}\textcolor{red}{s_{n-k+1}}\cdotss_n\to\textcolor{red}{s_{n-k+1}}s_{i_1}\cdots\textcolor{blue}{s_{i_{n-k}}}\cdotss_n\tos_{i_1}\cdots\textcolor{red}{s_{n-k+1}}\textcolor{blue}{s_{i_{n-k}}}\cdotss_n.\]</span> 再一次应用归纳假设，上面右边共轭于 <span class="math display">\[\textcolor{blue}{s_{i_{n-k}}}s_{i_1}\cdots\textcolor{red}{s_{n-k+1}}\cdotss_n.\]</span> 结论同样成立。<span class="math inline">\(\blacksquare\)</span></p><p>这样一来，下面的结论就是显然的了：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>任何 Coxeter 元都共轭于 <span class="math inline">\(s_1\cdotss_n\)</span>。</p></div><h1 id="acting-on-a-plane">3.17 Acting on a plane</h1><p>设 <span class="math inline">\(A=(a_{ij})_{1\leq i,j\leqn}=((\alpha_i,\alpha_j))\)</span> 是 Cartan 矩阵，<span class="math inline">\(\{\omega_i\}_{i=1}^n\)</span> 是关于 <span class="math inline">\(\Delta=\{\alpha_i\}_{i=1}^n\)</span>的对偶基。<span class="math inline">\(A\)</span> 正是 <span class="math inline">\(V\)</span> 上线性变换 <span class="math inline">\(\bf A\)</span> 在基 <span class="math inline">\(\{\omega_i\}\)</span> 下的矩阵： <span class="math display">\[a_{ij}=(\alpha_i,\alpha_j)=({\bfA}\omega_i,\alpha_j).\]</span> 我们知道矩阵 <span class="math inline">\(A\)</span> 有一个特征值 <span class="math inline">\(c\)</span>，它对应的特征向量 <span class="math inline">\((c_1,\ldots, c_n)\)</span> 的分量 <span class="math inline">\(c_i\)</span> 都是大于 0 的，于是 <span class="math inline">\(\sum_{i=1}^nc_i\omega_i\)</span> 是变换 <span class="math inline">\({\bf A}\)</span> 的特征向量： <span class="math display">\[{\bf A}\sum_{i=1}^nc_i\omega_i =\sum_{i=1}^ncc_i\omega_i.\]</span> 另一方面 <span class="math inline">\({\bfA}\sum_{i=1}^nc_i\omega_i=\sum_{i=1}^nc_i\alpha_i\)</span>，所以 <span class="math display">\[\sum_{i=1}^nc_i\alpha_i =\sum_{i=1}^ncc_i\omega_i.\]</span> 两边用某个 <span class="math inline">\(\alpha_j,\,(j\in J)\)</span> 作内积，并注意到<span class="math inline">\(\alpha_j\)</span> 与 <span class="math inline">\(J\)</span> 中除自己之外其它 <span class="math inline">\(J\)</span> 中的 <span class="math inline">\(\alpha_i\)</span> 正交，得到 <span class="math display">\[cc_j=\sum_{i=1}^nc_i(\alpha_i,\alpha_j)=c_j +\sum_{i\in I}c_ia_{ij}.\]</span> 即 <span class="math display">\[(c-1)c_j = \sum_{i\in I}c_ia_{ij}.\]</span>两边乘以 <span class="math inline">\(\omega_j\)</span> 并对 <span class="math inline">\(j\in J\)</span> 求和，然后交换和号得到 <span class="math display">\[\begin{aligned}(c-1)\sum_{j\in J}c_j\omega_j &amp;= \sum_{j\in J}\left(\sum_{i\inI}c_ia_{ij}\right)\omega_j\\&amp;=\sum_{i\in I}c_i\left(\sum_{j\in J}a_{ij}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\sum_{j=1}^n a_{ij}\omega_j- \sum_{j\inI}a_{ij}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\alpha_i- \sum_{j\inI}a_{ij}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\alpha_i- \omega_i-\sum_{j\in I,\,j\nei}\underbrace{a_{ij}}_{=0}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\alpha_i- \omega_i\right)\\&amp;=\sum_{i\in I}c_i\alpha_i- \mu.\\\end{aligned}\]</span> 即 <span class="math inline">\((c-1)\nu + \mu =\sum_{i\in I}c_i\alpha_i\)</span>。注意到 <span class="math inline">\(\sum_{i\in I}c_i\alpha_i\)</span> 被 <span class="math inline">\(x=\prod_{i\in I}s_i\)</span> 映射为它的负 <span class="math inline">\(-\sum_{i\in I}c_i\alpha_i\)</span>。此外 <span class="math inline">\(x\)</span> 保持 <span class="math inline">\(\nu\)</span> 不动，所以 <span class="math inline">\(x\)</span> 保持 <span class="math inline">\(\mu,\nu\)</span> 生成的二维子空间 <span class="math inline">\(P\)</span> 不变。<span class="math inline">\(x\)</span> 作为 <span class="math inline">\(P\)</span> 上的正交变换保持直线 <span class="math inline">\(\nu\)</span> 上的点不动，所以 <span class="math inline">\(x\)</span> 限制在 <span class="math inline">\(P\)</span> 上是一个反射。同理 <span class="math inline">\(y\)</span> 也是如此。所以 <span class="math inline">\(w^t=xy\)</span> 在 <span class="math inline">\(P\)</span> 上的作用是一个旋转。设这个旋转角度是<span class="math inline">\(2\pi/h\)</span>，则 <span class="math inline">\(w^t\)</span> 在 <span class="math inline">\(P\)</span> 上的阶是 <span class="math inline">\(h\)</span>。</p><p>又因为 <span class="math inline">\(\mu+\nu\)</span> 严格属于 <span class="math inline">\(C\cap P\)</span>，所以它在 <span class="math inline">\(w^t\)</span> 作用下一定在 <span class="math inline">\(V\)</span> 中有 <span class="math inline">\(k\)</span> 个不同的像，即 <span class="math inline">\(P\)</span> 上的阶等于它在 <span class="math inline">\(V\)</span> 上的阶。</p><h1 id="the-coxeter-number">3.18 The Coxeter number</h1><p>这一节证明了如下结论：对一个有限 Coxeter 群，正根的个数 <span class="math inline">\(N=|\Phi^+|\)</span>，Coxeter 数 <span class="math inline">\(h\)</span>，单根的个数 <span class="math inline">\(n=|\Delta|\)</span> 满足 <span class="math display">\[N = \frac{nh}{2}.\]</span></p><p>回忆 <span class="math inline">\(y=s_1\cdots s_r,z=s_{r+1}\cdotss_n\)</span> 在 <span class="math inline">\(P\)</span>上的作用都是反射，它们在 <span class="math inline">\(P\)</span>上生成的群是二面体群 <span class="math inline">\(I_2(h)\)</span>，这个群包含 <span class="math inline">\(h\)</span> 个反射和 <span class="math inline">\(h\)</span> 个旋转。记 <span class="math inline">\(I_2(h)\)</span> 中的 <span class="math inline">\(h\)</span> 个反射对应的超平面在 <span class="math inline">\(P\)</span> 上的截线分别是 <span class="math inline">\(L_1,\ldots,L_h\)</span>，这些 <span class="math inline">\(L_i\)</span> 是 <span class="math inline">\(I_2(h)\)</span> 作用在直线 <span class="math inline">\(L=\mathbb{R}\lambda\)</span> 和 <span class="math inline">\(M=\mathbb{R}\mu\)</span> 上得到的。设 <span class="math inline">\(\beta\in\Phi\)</span>，我们来分析 <span class="math inline">\(\beta\)</span> 对应的超平面 <span class="math inline">\(H_\beta\)</span> 在 <span class="math inline">\(P\)</span> 上的截线是什么。</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>对任何 <span class="math inline">\(\beta\in\Phi\)</span>，<span class="math inline">\(H_\beta\cap P\in \{L_1,\ldots,L_h\}\)</span>。</p></div><p>证明：首先注意到 <span class="math inline">\(P\)</span> 不可能包含在<span class="math inline">\(H_\beta\)</span> 中。因为 <span class="math inline">\(P\)</span> 和基本区域 <span class="math display">\[C=\{v\in V\mid (\alpha, v)&gt;0 \text { for all}\alpha\in\Delta\}\]</span> 的交是 <span class="math display">\[P\capC=\{a\lambda + b\mu\mid a&gt;0,b&gt;0\}.\]</span> 它当然是非空的，而<span class="math inline">\(H_\beta\)</span> 不可能包含 <span class="math inline">\(C\)</span> 中的点，所以 <span class="math inline">\(H_\beta\cap P\)</span> 是 <span class="math inline">\(P\)</span> 的一条截线。</p><p>其次如果这条截线不是上述 <span class="math inline">\(\{L_i\}\)</span>任何之一，那么我们可以用 <span class="math inline">\(y,z\)</span>的某个组合将其变换到 <span class="math inline">\(P\cap C\)</span>中，这相当于用某个 <span class="math inline">\(w\in I_2(h)\)</span> 使得<span class="math inline">\(\gamma=w\beta\)</span> 的超平面 <span class="math inline">\(H_\gamma\)</span> 与 <span class="math inline">\(P\)</span> 的交线穿过 <span class="math inline">\(P\cap C\)</span>，这与任何根的镜面与 <span class="math inline">\(C\)</span> 之交为空集矛盾。<span class="math inline">\(\blacksquare\)</span></p><p>我们只要讨论哪些 <span class="math inline">\(H_\beta\)</span> 满足<span class="math inline">\(H_\beta\cap P =L\)</span> 或者 <span class="math inline">\(H_\beta\cap P =M\)</span> 即可。其它的 <span class="math inline">\(L_i\)</span> 由于形如 <span class="math inline">\(L_i=wL\)</span> 或者 <span class="math inline">\(L_i=wM\)</span>，这里 <span class="math inline">\(w\in I_2(h)\)</span>，所以对应的是 <span class="math inline">\(wH_\beta\)</span>。</p><p>如果 <span class="math inline">\(H_\beta\cap P = L\)</span>，则反射<span class="math inline">\(s_\beta\)</span> 保持 <span class="math inline">\(L\)</span> 不动。这时 <span class="math inline">\((\beta,\lambda=0)\)</span>。设 <span class="math inline">\(\beta=\sum\limits_{i=1}^n a_i\alpha_i (a_i\geq0)\)</span>，由于 <span class="math inline">\(\lambda=\sum_{i\inI}c_i\omega_i\)</span>，所以 <span class="math display">\[(\beta,\lambda) = \sum_{i\in I} a_ic_i=0.\]</span> 由于 <span class="math inline">\(c_i(1\leq i\leq n)\)</span>都是正的，所以必须对每个 <span class="math inline">\(i\in I\)</span> 有<span class="math inline">\(a_i=0\)</span>，即 <span class="math inline">\(\beta\)</span> 是 <span class="math inline">\(\{\alpha_j,j\in J\}\)</span> 的线性组合，从而<span class="math inline">\(\beta\)</span> 属于标准椭圆子群 <span class="math inline">\(J\)</span> 的根系 <span class="math inline">\(\Phi_J\)</span>。但是 <span class="math inline">\(J\)</span> 中的生成元两两交换，<span class="math inline">\(\Phi_J\)</span> 中的正根只有 <span class="math inline">\(\{\alpha_j,j\in J\}\)</span>，所以满足 <span class="math inline">\(H_\beta\cap P=L\)</span> 的正根 <span class="math inline">\(\beta\)</span> 有 <span class="math inline">\(|J|=n-r\)</span> 个。</p><p>同样的分析可得满足 <span class="math inline">\(H_\beta\capP=M\)</span> 的正根 <span class="math inline">\(\beta\)</span> 有 <span class="math inline">\(|I|=r\)</span> 个。</p><p>当 <span class="math inline">\(h\)</span> 是偶数时，<span class="math inline">\(I_2(h)\)</span> 在 <span class="math inline">\(\{L_1,\ldots,L_h\}\)</span>上的作用分成两个长度同为 <span class="math inline">\(h/2\)</span>的轨道，分别由 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span> 生成，<span class="math inline">\(L\)</span> 所在的轨道每个超平面来自 <span class="math inline">\(n-r\)</span> 个正根，<span class="math inline">\(M\)</span> 所在的轨道每个超平面来自 <span class="math inline">\(r\)</span> 个正根，所以一共是 <span class="math inline">\(h(n-r)/2 + hr/2 = nh/2=N\)</span> 个正根。</p><p>当 <span class="math inline">\(h\)</span> 是奇数时，<span class="math inline">\(I_2(h)\)</span> 传递地作用在 <span class="math inline">\(\{L_1,\ldots,L_h\}\)</span> 上，所以 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span> 来自同样数目的正根，即 <span class="math inline">\(r=n-r\)</span>，所以 <span class="math inline">\(r=n/2\)</span>。同样地 <span class="math inline">\(N=nh/2\)</span>。</p><p>这里需要对 <span class="math inline">\(h\)</span>的奇偶性分别讨论是因为在二面体群中，奇数时两个生成元是共轭的，偶数时则不共轭。</p><h1 id="eigenvalues-of-coxeter-elements">3.19 Eigenvalues of Coxeterelements</h1><p>设 <span class="math inline">\(u,v\)</span> 是 Coxeter 平面 <span class="math inline">\(P\)</span> 的一组正交基，则 <span class="math inline">\(z=u+iv\)</span> 是 <span class="math inline">\(w\)</span> 在 <span class="math inline">\(V_{\mathbb{C}}\)</span> 上的特征向量，特征值为<span class="math inline">\(e^{2\pi i/h}\)</span>。对任何 <span class="math inline">\(\beta\in\Phi^+\)</span>，<span class="math inline">\((\beta,z)=(\beta,u) + (\beta,v)i\ne0\)</span>，否则会导致 <span class="math inline">\(P\inH_\beta\)</span>，与 <span class="math inline">\(P\cap C\)</span>非空矛盾。</p><p>设 <span class="math inline">\(\{v_i\}\)</span> 是 <span class="math inline">\(V\)</span> 的一组基，<span class="math inline">\(\{x_i\}\in V^\ast\)</span> 是对偶基：<span class="math inline">\(x_i(v_j)=\delta_{ij}\)</span>。<span class="math inline">\(x_1,\cdots,x_n\)</span>是坐标函数，它们是代数无关的：<span class="math inline">\(\mathbb{C}[x_1,\cdots,x_n]\)</span>是一个多项式环。我们把 <span class="math inline">\(\mathbb{C}[x_1,\cdots,x_n]\)</span> 称作 <span class="math inline">\(V\)</span> 上的坐标环，简记作 <span class="math inline">\(\mathbb{C}[V]\)</span>。设 <span class="math inline">\(G\subset GL(V)\)</span>是一个有限的可逆线性变换群，则 <span class="math inline">\(G\)</span>也作用在 <span class="math inline">\(\mathbb{C}[V]\)</span>上：对任何多项式 <span class="math inline">\(f\in\mathbb{C}[V]\)</span>，定义 <span class="math inline">\(g\)</span> 在<span class="math inline">\(f\)</span> 上作用的结果 <span class="math inline">\(g\cdot f\)</span> 为</p><p><span class="math display">\[g\cdot f(v)=f(g^{-1}v).\]</span> 对<span class="math inline">\(f=\sum a_{i_1\cdots i_n}x_1^{i_1}\cdotsx_n^{i_n}\in\mathbb{C}[V]\)</span>，<span class="math inline">\(f\)</span> 在 <span class="math inline">\(v=\sum_{i}c_iv_i\)</span> 处的值为 <span class="math display">\[f(v)=\sum a_{i_1\cdots i_n}x_1(v)^{i_1}\cdotsx_n(v)^{i_n} = \sum a_{i_1\cdots i_n}c_1^{i_1}\cdots c_n^{i_n}.\]</span>于是如果不含常数项的多项式 <span class="math inline">\(f\in\mathbb{C}[V]\)</span> 满足 <span class="math inline">\(f(v_1)\ne 0\)</span>，则若 <span class="math inline">\(f=\sum a_{i_1\cdots i_n}x_1^{i_1}\cdotsx_n^{i_n}\)</span>，我们有 <span class="math display">\[0\ne f(v_1)=\suma_{i_1\cdots i_n}x_1^{i_1}\cdotsx_n^{i_n}\mid_{x_1=1,x_2=\cdots=x_n=0}.\]</span> 即 <span class="math inline">\(f\)</span> 的单项式里面必有一项只含有 <span class="math inline">\(x_1\)</span>。</p><p>进一步，如果 <span class="math inline">\(\frac{\partial f}{\partialx_i}\)</span> 满足 <span class="math inline">\(\frac{\partialf}{\partial x_i}(v_1)\ne0\)</span>，那就说明 <span class="math inline">\(f\)</span> 的单项式里面必有一项形如 <span class="math inline">\(ax_1^{m}x_i\)</span>，即 <span class="math inline">\(f\)</span> 形如 <span class="math inline">\(f=ax_1^mx_i + \cdots\)</span>。</p><p>设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(V\)</span> 上可对角化的线性变换，<span class="math inline">\(Tv_i=\lambda_i v_i\)</span>，则 <span class="math inline">\(Tx_i=\lambda_i^{-1}x_i\)</span>。并且设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(T\)</span>- 不变的多项式，则 <span class="math display">\[f=T\cdot f =a\lambda_1^{-m}x_1^m\lambda_i^{-1}x_i + \cdots.\]</span> 比较即得 <span class="math display">\[ax_1^mx_i =a\lambda_1^{-m}x_1^m\lambda_i^{-1}x_i.\]</span> 即 <span class="math inline">\(1 = \lambda_1^{-m}\lambda_i^{-1}\)</span>，从而<span class="math inline">\(\lambda_i = \lambda_1^{-m}\)</span>。</p><p>对 Coxeter 元 <span class="math inline">\(w\)</span>，它的特征值是<span class="math inline">\(\{\zeta^{m_i},\,1\leq i\leqn\}\)</span>，并且 <span class="math inline">\(m_1=1,m_{n-1}=h-1\)</span>。<span class="math inline">\(m_1=1\)</span> 对应的是 <span class="math inline">\(w\)</span> 的重数为 1 的特征值 <span class="math inline">\(\zeta\)</span>。</p><p>以 <span class="math inline">\(w\)</span> 的特征向量为基，由于 <span class="math inline">\(\zeta\)</span> 对应的特征向量 <span class="math inline">\(v_1\)</span> 在 <span class="math inline">\(C\)</span> 内，它不在任何根平面 <span class="math inline">\(H_\alpha\)</span> 上，所以 Jacobian <span class="math inline">\(J=\det\left(\frac{\partial f_i}{\partialx_j}\right)\)</span> 在 <span class="math inline">\(v_1\)</span> 处不为0，于是某个 <span class="math inline">\(\prod_{i=1}^n \frac{\partialf_i}{\partial x_{\pi(j)}}\)</span> 在 <span class="math inline">\(v_1\)</span> 处不为 0，适当重排 <span class="math inline">\(f_i\)</span> 以后可以不妨设每个 <span class="math inline">\(\frac{\partial f_i}{\partialx_i}(v_1)\ne0\)</span>。根据上面的讨论，<span class="math inline">\(f_i\)</span> 形如 <span class="math display">\[f_i=ax_1^{d_i-1}x_i+\cdots.\]</span> 并且 <span class="math inline">\(\lambda_i=\zeta^{m_i}=\zeta^{1-d_i}\)</span>。从而 <span class="math inline">\(h-m_i\equiv d_i-1\pmodh\)</span>。我们知道对每个 <span class="math inline">\(i\)</span> 有<span class="math inline">\(0&lt;h-m_i&lt;h\)</span>，所以对每个 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(d_i-1\geq h-m_i\)</span>。另一方面，集合 <span class="math inline">\(\{h-m_i\}\)</span> 不过是集合 <span class="math inline">\(\{m_i\}\)</span> 的一个置换，所以 <span class="math display">\[\sum (h-m_i) = \sum m_i = \sum(d_i-1).\]</span>这只能是对每个 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(h-m_i=d_i-1\)</span>，即集合相等 <span class="math inline">\(\{d_i-1\}=\{m_i\}\)</span>。</p><h1 id="counting-hyperplanes">4.4 Counting hyperplanes</h1><p>回忆 <span class="math inline">\(\mathcal{H}\)</span> 是所有超平面<span class="math inline">\(\{H_{\alpha,k}\mid\alpha\in\Phi,k\in\mathbb{Z}\}\)</span> 组成的集合。其中 <span class="math display">\[H_{\alpha,k}=\{v\in V\mid(\alpha,v)=k\}.\]</span></p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span><span class="math inline">\(H_s\)</span> 是 <span class="math inline">\(\mathcal{H}\)</span> 中唯一分隔 <span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 的超平面，即 <span class="math inline">\(\mathcal{L}(s)=\{H_s\}\)</span>。</p></div><p>证明：我们先说明对任何正根 <span class="math inline">\(\beta\ne\alpha_s\)</span>，以及任何 <span class="math inline">\(k\in\mathbb{Z}\)</span>，<span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 都在超平面 <span class="math inline">\(H_{\beta,k}\)</span> 的同一侧。</p><p>首先根据 <span class="math inline">\(A_o\)</span>的刻画，它满足对任何正根 <span class="math inline">\(\gamma\)</span>都有 <span class="math inline">\(0&lt;(A_o,\gamma)&lt;1\)</span>，特别地<span class="math inline">\(0&lt;(A_o,\beta)&lt;1\)</span>。由于 <span class="math inline">\(\beta\ne\alpha_s\)</span> 所以 <span class="math inline">\(s\beta\)</span> 仍然是正根，因此 <span class="math display">\[0&lt;(A_o,s\beta)&lt;1\Longrightarrow0&lt;(sA_o,\beta)&lt;1.\]</span> 这说明 <span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 在 <span class="math inline">\(H_\beta\)</span> 和 <span class="math inline">\(H_{\beta,1}\)</span>围成的带状区域中间。所以对任何 <span class="math inline">\(k\)</span>它们都在 <span class="math inline">\(H_{\beta,k}\)</span> 的同一侧。</p><p>另一方面不难看出 <span class="math inline">\(-1 &lt;(sA_o,\alpha_s)&lt;0\)</span>，也就是说 <span class="math inline">\(sA_o\)</span> 和 <span class="math inline">\(A_o\)</span> 位于 <span class="math inline">\(H_{\alpha_s,0}\)</span> 的两侧，但是对任何 <span class="math inline">\(k\ne0\)</span>，它们位于 <span class="math inline">\(H_{\alpha_s,k}\)</span> 的同侧。</p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>固定 <span class="math inline">\(s\in S_a\)</span>。对任何 <span class="math inline">\(w\in\widehat{W_a}\)</span>，有如下结论成立：</p><ul><li><span class="math inline">\(H_s\)</span> 恰好属于 <span class="math inline">\(\mathcal{L}(w)\)</span> 和 <span class="math inline">\(\mathcal{L}(sw)\)</span> 之一。</li><li><span class="math inline">\(s(\mathcal{L}(w)\setminus\{H_s\}) =\mathcal{L}(sw)\setminus\{H_s\}\)</span>。</li></ul></div><p>证明：第一点是显然的，因为 <span class="math inline">\(wA_o\)</span>和 <span class="math inline">\(swA_o\)</span> 位于 <span class="math inline">\(H_s\)</span> 的两侧，它俩有且恰有一个和 <span class="math inline">\(A_o\)</span> 位于 <span class="math inline">\(H_s\)</span> 的同一侧。</p><p>对于第二点，我们要证明的是 <span class="math inline">\(H\leftrightarrow sH\)</span> 给出了 <span class="math inline">\(\mathcal{L}(w)\)</span> 和 <span class="math inline">\(\mathcal{L}(sw)\)</span> 中除 <span class="math inline">\(H_s\)</span> 之外的超平面的一一对应。然而若 <span class="math inline">\(H\ne H_s\)</span>，根据上面的引理，<span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 位于 <span class="math inline">\(H\)</span> 的同一侧，所以</p><p><span class="math display">\[H\in\mathcal{L}(w)\Longleftrightarrow\begin{matrix}A_o\\ sA_o\end{matrix}\stackrel{H=0}{\biggl\lvert} wA_o\Longleftrightarrow \begin{matrix}sA_o\\A_o\end{matrix}\stackrel{sH=0}{\biggl\lvert} swA_o.\]</span> 可见 <span class="math inline">\(sH\in \mathcal{L}(sw)\)</span> 并且显然 <span class="math inline">\(sH\ne H_s\)</span>。此即为所证。</p><h1 id="a-formula-for-the-order-of-w">4.9 A formula for the order of<span class="math inline">\(W\)</span></h1><p>从前面的学习中我们知道，一个仿射 Weyl 群 <span class="math inline">\(W_a\)</span> 总是可以写成一个有限 Weyl 群 <span class="math inline">\(W\)</span> 和一个格点群 <span class="math inline">\(L\)</span> 的半直积：<span class="math inline">\(W_a=W\ltimes L\)</span>。这里的 <span class="math inline">\(L\)</span> 实际上是 <span class="math inline">\(W\)</span> 的余根格点：<span class="math inline">\(L=L(\Phi^\vee)\)</span>。这一节介绍了怎样计算<span class="math inline">\(W\)</span> 的阶 <span class="math inline">\(|W|\)</span>。</p><p>我们以 <span class="math inline">\(\widetilde{B}_2\)</span>为例来说明。<span class="math inline">\(\Delta\)</span> 包含两个单根<span class="math inline">\(\alpha_1=e_1-e_2,\,\alpha_2=e_2\)</span>。最高根<span class="math inline">\(\widetilde{\alpha}=\alpha_1+2\alpha_2\)</span>，于是<span class="math inline">\(c_1=1,c_2=2\)</span>。</p><p><img style="margin:0px auto;display:block" width="500" src="/images/humphreys/b2.svg"></p><ul><li>图中<strong>黄色</strong>区域是由所有的房间 <span class="math inline">\(\{wA_o\mid w\in W\}\)</span> 组成。即 <span class="math inline">\(\Pi=\bigcup_{w\inW}wA_o\)</span>。另一个等价的描述是 <span class="math display">\[ \Pi =\{x\in V\mid -1 &lt; (x,\alpha) &lt; 1 \text{ for all }\alpha\in\Phi^+\}.\]</span> 所以 <span class="math inline">\(\mathrm{Vol}(\Pi)=|W|\cdot\mathrm{Vol}(A_o)\)</span>。<span class="math inline">\(\Pi\)</span> 是余根格点 <span class="math inline">\(L(\Phi^\vee)\)</span>的基本区域，因为书中已经证明了 <span class="math inline">\(W_a=W\ltimesL\)</span>，并且 <span class="math inline">\(A_o\)</span> 是 <span class="math inline">\(W_a\)</span> 作用下的基本区域，所以 <span class="math inline">\(\Pi\)</span> 在 <span class="math inline">\(L\)</span>的作用下互不相交，并且密铺了整个平面。</li><li>图中<strong>绿色</strong>区域是余权格点 <span class="math inline">\(\hat{L}(\Phi^\vee)\)</span> 的基本区域 <span class="math inline">\(\hat{\Pi}\)</span>，它是一个平行多面体，由基本余权<span class="math inline">\(\{\omega_1,\ldots,\omega_n\}\)</span>张成，并且 <span class="math inline">\(\dfrac{\mathrm{Vol}(\Pi)}{\mathrm{Vol}(\hat{\Pi}) } = f\)</span>。</li><li>基本区域 <span class="math inline">\(A_o\)</span> 是由 <span class="math inline">\(\left\{0,\dfrac{\omega_1}{c_1},\ldots,\dfrac{\omega_n}{c_n}\right\}\)</span>生成的单纯形，它和 <span class="math inline">\(\{\omega_1,\ldots,\omega_n\}\)</span>生成的平行多面体 <span class="math inline">\(\hat{\Pi}\)</span>的体积关系为 <span class="math display">\[\mathrm{Vol}(\hat{\Pi}) =n!c_1\cdots c_n\cdot\mathrm{Vol}(A_o).\]</span></li><li>综上可得 <span class="math display">\[\dfrac{\mathrm{Vol}(\Pi)}{\mathrm{Vol}(\hat{\Pi}) } =\frac{|W|\mathrm{Vol}(A_o)}{n!c_1\cdotsc_n\cdot\mathrm{Vol}(A_o)}=f.\]</span> 即 <span class="math inline">\(|W| = n!c_1\cdots c_n f\)</span>。</li></ul><h1 id="bruhat-ordering">5.9 Bruhat ordering</h1><p>这一节介绍了 Bruhat 序，以及重要的 lifting property。Humphreys书中是先介绍的 liftingproperty，然后在下一小节证明子表达式定理。实际上，如果我们采用 Bjornerand Brenti 教材的处理方式，先证明子表达式定理的话，那么 lifting property更好证。</p><div id="lifting" class="unnumbered statement sta_lifting_property plain"><p><span class="statement-heading"><span class="statement-label">Liftingproperty</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(u&lt; w\)</span>，<span class="math inline">\(s\inS\)</span> 满足 <span class="math inline">\(sw&lt;w\)</span> 和 <span class="math inline">\(su&gt;u\)</span>，则 <span class="math inline">\(u\leq sw\)</span> 并且 <span class="math inline">\(su\leq w\)</span>。</p></div><p>证明：用 <span class="math inline">\(\alpha\prec\beta\)</span> 表示word <span class="math inline">\(\alpha\)</span> 是 word <span class="math inline">\(\beta\)</span> 的子表达式。设 <span class="math inline">\(sw=s_1\cdots s_q\)</span> 是 <span class="math inline">\(sw\)</span> 的一个既约表示。由于 <span class="math inline">\(sw&lt;w\)</span>，所以 <span class="math inline">\(w=ss_1\cdots s_q\)</span> 也是既约表示。又因为已知<span class="math inline">\(u&lt;w\)</span>，所以根据子表达式定理，存在<span class="math inline">\(u=s_{i_1}\cdots s_{i_k}\)</span>的某个既约表示满足 <span class="math display">\[s_{i_1}\cdotss_{i_k}\prec ss_1\cdots s_q.\]</span> 又已知 <span class="math inline">\(su&gt;u\)</span>，所以 <span class="math inline">\(s\ne s_{i_1}\)</span>，从而 <span class="math display">\[u=s_{i_1}\cdots s_{i_k}\prec s_1\cdotss_q=sw.\]</span> 这意味着 <span class="math display">\[su=ss_{i_1}\cdotss_{i_k}\prec ss_1\cdots s_q=w,\]</span> 从而 <span class="math inline">\(u\leq sw\)</span> 且 <span class="math inline">\(su\leq w\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(u\ne w\)</span>，则存在 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(u&lt;x\)</span> 且 <span class="math inline">\(w&lt;x\)</span>。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(l(u)+l(w)\)</span> 归纳。<span class="math inline">\(l(u)+l(w)=0\)</span>时结论是显然的。假设结论对小于 <span class="math inline">\(l(u)+l(w)\)</span> 的情形已经成立。取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(su&lt;u\)</span>，则根据归纳假设，存在 <span class="math inline">\(y\)</span> 使得 <span class="math inline">\(su&lt;y\)</span> 且 <span class="math inline">\(w&lt;y\)</span>。</p><ol type="1"><li>如果 <span class="math inline">\(sy&lt;y\)</span>，那么由提升引理，<span class="math inline">\(u&lt;y\)</span>，从而 <span class="math inline">\(y\)</span> 就是所求的 <span class="math inline">\(x\)</span>。</li><li>如果 <span class="math inline">\(sy&gt;y\)</span>，那么 <span class="math inline">\(sy\)</span> 就是所求的 <span class="math inline">\(x\)</span>。</li></ol><p><span class="math inline">\(\blacksquare\)</span></p><p>这个推论的一个直接结论是，任何有限 Coxeter 群中必有 Bruhat序下唯一的极大元 <span class="math inline">\(w_0\)</span>。<span class="math inline">\(w_0\)</span> 必然满足 <span class="math inline">\(w_0^2=1\)</span>，因为如果 <span class="math inline">\(w_0\ne w_0^{-1}\)</span>的话，它们就会还有一个更大的覆盖元。</p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>如果 <span class="math inline">\(w\in W\)</span> 满足对任何 <span class="math inline">\(s\in S\)</span> 都有 <span class="math inline">\(sw&lt;w\)</span>，则 <span class="math inline">\(W\)</span> 必然是有限群，并且 <span class="math inline">\(w=w_0\)</span> 是极大元。</p></div><p><strong>证明</strong>：我们对 <span class="math inline">\(l(x)\)</span> 归纳证明对任何 <span class="math inline">\(x\in W\)</span> 有 <span class="math inline">\(x\leq w\)</span>。设结论对长度小于 <span class="math inline">\(l(x)\)</span> 的元素都成立，取 <span class="math inline">\(s\)</span> 使得 <span class="math inline">\(l(sx)&lt;l(x)\)</span>，根据归纳假设 <span class="math inline">\(sx\leq w\)</span>。但是 <span class="math inline">\(sx\)</span> 不可能等于 <span class="math inline">\(w\)</span>，因为 <span class="math inline">\(l(s\cdotsx)=l(x)&gt;l(sx)\)</span>。所以根据提升性质可得 <span class="math inline">\(x\leq w\)</span>。于是 <span class="math inline">\(W\)</span> 中任何元素都在区间 <span class="math inline">\([1,x]\)</span>中，这样的元素显然只有有限多个。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(W\)</span> 是有限群，则对任何<span class="math inline">\(w\in W\)</span> 有 <span class="math inline">\(l(ww_0)=l(w_0)-l(w)\)</span>。</p></div><p><strong>证明</strong>：只要证明 <span class="math inline">\(l(ww_0)\leq l(w_0)-l(w)\)</span> 即可。对 <span class="math inline">\(l(w_0)-l(w)\)</span> 归纳，等于 0 的情况对应 <span class="math inline">\(w=w_0\)</span>，结论显然成立。设 <span class="math inline">\(w&lt;w_0\)</span> 并且结论对任何 <span class="math inline">\(x&gt;w\)</span> 成立。根据上一个推论，必然存在<span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(sw&gt;w\)</span>。对 <span class="math inline">\(sw\)</span> 应用归纳假设可得</p><p><span class="math display">\[l(ww_0)\leq l(sww_0)+1 \leq l(w_0) -l(sw) + 1 = l(w_0) - l(w).\]</span> <span class="math inline">\(\blacksquare\)</span></p><p>对任何 <span class="math inline">\(l(w)\)</span>，记 <span class="math inline">\(T_L(w)=\{t\in T\mid l(tw) &lt;l(w)\}\)</span>。</p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(W\)</span> 是有限群，则对任何<span class="math inline">\(w\in W\)</span> 有 <span class="math inline">\(T_L(ww_0)=T\setminus T_L(w)\)</span>。</p></div><p><strong>证明</strong>：根据上一个推论，<span class="math inline">\(l(tww_0)=l(w_0)-l(tw)\)</span>。所以 <span class="math inline">\(l(tww_0)&gt;l(ww_0)\)</span> 当且仅当 <span class="math inline">\(l(tw)&lt;l(w)\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span><span class="math inline">\(l(w_0)=|T|\)</span>.</p></div><p><strong>证明</strong>：在上一个推论中取 <span class="math inline">\(w=1\)</span> 有 <span class="math inline">\(T_L(w_0)=T\)</span>，结合 <span class="math inline">\(l(w)=|T_L(w)|\)</span> 对任何 <span class="math inline">\(w\in W\)</span> 成立即得。<span class="math inline">\(\blacksquare\)</span></p><h1 id="subexpressions">5.10 Subexpressions</h1><div id="thm-5.10" class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(w=s_1\cdots s_q\)</span>是一个既约表达式，<span class="math inline">\(u\ne w\)</span> 并且 <span class="math inline">\(u\)</span> 的某个既约表达式恰好是 <span class="math inline">\(s_1\cdots s_q\)</span> 的子表达式。则存在 <span class="math inline">\(v\in W\)</span> 满足以下三点：</p><ol type="1"><li><span class="math inline">\(v &gt; u\)</span>。</li><li><span class="math inline">\(l(v) = l(u)+1\)</span>。</li><li><span class="math inline">\(v\)</span> 的某个既约表达式是 <span class="math inline">\(s_1\cdots s_q\)</span> 的子表达式。</li></ol></div><p><strong>证明</strong>：设 <span class="math inline">\(u\)</span>的既约表达式是从 <span class="math inline">\(s_1\cdots s_q\)</span>中删去 <span class="math inline">\(i_1,\ldots,i_k\)</span> 位置得到的：<span class="math display">\[u = s_1\cdots\hat{s_{i_1}}\cdots\hat{s_{i_k}}\cdots s_q.\]</span> 这样的既约表达式可能不唯一，选择使得<span class="math inline">\(i_k\)</span> 最小的那一个。令 <span class="math display">\[t=s_qs_{q-1}\cdots s_{i_k}\cdotss_{q-1}s_q.\]</span> 则 <span class="math inline">\(ut\)</span> 就是把<span class="math inline">\(s_{i_k}\)</span> 补回 <span class="math inline">\(u\)</span> 的表达式中： <span class="math display">\[ut= s_1\cdots\hat{s_{i_1}}\cdots\hat{s_{i_{k-1}}}\cdots s_{i_k}\cdots s_q.\]</span> 这个 <span class="math inline">\(ut\)</span> 的表达式未必是既约的，但是无论如何<span class="math inline">\(l(ut)\)</span> 不会超过这个表达式的长度，即<span class="math inline">\(l(ut)\leql(u)+1\)</span>。我们来证明等号是成立的。如果确实如此，那么取 <span class="math inline">\(v=ut\)</span> 即可满足要求。</p><p>若不然，<span class="math inline">\(l(ut)&lt;l(u)\)</span>，则根据strong exchange 条件，<span class="math inline">\(ut\)</span> 等于在<span class="math inline">\(u\)</span> 的表达式再删掉一个 <span class="math inline">\(s_p\)</span>。这个 <span class="math inline">\(p\)</span> 出现的位置有两种可能：</p><p>第一种可能是 <span class="math inline">\(p&gt;i_k\)</span>，即 <span class="math display">\[ut=s_1\cdots\hat{s_{i_1}}\cdots\hat{s_{i_k}}\cdots \hat{s_p}\cdotss_q.\]</span> 这种情况下 <span class="math inline">\(t\)</span> 还等于<span class="math inline">\(t=s_qs_{q-1}\cdots s_p\cdotss_{q-1}s_q\)</span>。于是 <span class="math display">\[w=wt^2=w(s_qs_{q-1}\cdots s_{i_k}\cdotss_{q-1}s_q)(s_qs_{q-1}\cdots s_p\cdotss_{q-1}s_q)=s_1\cdots\hat{s_{i_k}}\cdots\hat{s_p}\cdots s_q.\]</span>这与 <span class="math inline">\(s_1\cdots s_q\)</span> 是 <span class="math inline">\(w\)</span> 的既约表达式矛盾。</p><p>第二种可能是 <span class="math inline">\(p&lt;i_k\)</span> 出现在<span class="math inline">\(i_k\)</span> 之前的某个位置，当然 <span class="math inline">\(p\notin\{i_1,\ldots,i_k\}\)</span>。这种情况下<span class="math display">\[u=ut\cdott=s_1\cdots\hat{s_{i_1}}\cdots\hat{s_p}\cdots\hat{s_{i_k}}\cdotss_q\cdot(s_qs_{q-1}\cdots s_{i_k}\cdotss_{q-1}s_q)=s_1\cdots\hat{s_{i_1}}\cdots\hat{s_p}\cdots s_{i_k}\cdotss_q.\]</span> 这与 <span class="math inline">\(i_k\)</span>的极小性矛盾。<span class="math inline">\(\blacksquare\)</span></p><p>在上面的例子中我把 <span class="math inline">\(p\)</span> 写在了<span class="math inline">\(i_1\)</span> 和 <span class="math inline">\(i_k\)</span> 中间的某个位置上，实际上 <span class="math inline">\(p\)</span> 当然可以小于 <span class="math inline">\(i_1\)</span>，但这不影响论证。</p><div id="thm-5.10-1" class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(w=s_1\cdots s_q\)</span>是一个既约表达式，则 <span class="math inline">\(u\leq w\)</span>当且仅当 <span class="math inline">\(u\)</span> 的某个既约表达式是 <span class="math inline">\(s_1\cdots s_q\)</span> 的子表达式。</p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>: 设 <span class="math inline">\(u=x_0\xrightarrow{t_1}x_1\xrightarrow{t_2}\cdots\xrightarrow{t_m}x_m=w\)</span>，则根据strong exchange 条件，<span class="math inline">\(x_{m-1}=wt_m\)</span>是 <span class="math inline">\(w\)</span> 的子表达式，进一步 <span class="math inline">\(x_{m-2}=x_{m-1}t_{m-1}\)</span> 是 <span class="math inline">\(x_{m-1}\)</span>的子表达式，这样一直下去，得到一个 <span class="math inline">\(u=x_0\)</span> 的表达式，它是 <span class="math inline">\(s_1\cdots s_q\)</span> 的子表达式。最后根据deletion condition，这个子表达式又包含一个 <span class="math inline">\(u\)</span> 的既约子表达式。</p><p><span class="math inline">\(\Leftarrow\)</span>: 如果 <span class="math inline">\(u\)</span> 的某个既约表达式是 <span class="math inline">\(s_1\cdots s_q\)</span>的子表达式，根据上面的引理，只要 <span class="math inline">\(u\new\)</span>，那么就存在反射 <span class="math inline">\(t\)</span> 使得<span class="math inline">\(u&lt;ut\)</span>，并且 <span class="math inline">\(ut\)</span> 仍然是 <span class="math inline">\(w\)</span> 的子表达式。对 <span class="math inline">\(ut\)</span> 继续此步骤直到结果 <span class="math inline">\(w\)</span> 为止即可。<span class="math inline">\(\blacksquare\)</span></p><h1 id="more-on-the-geometric-representation">6.2 More on the geometricrepresentation</h1><p>这一节证明了如果几何实现中的二次型 <span class="math inline">\(B(\alpha_s,\alpha_t)=-\cos\frac{\pi}{m_{s,t}}\)</span>是正定的，则 <span class="math inline">\(W\)</span>是有限群。这一点是两个结论合起来的结果：</p><div id="discrete-action" class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span><span class="math inline">\(W\)</span> 是 <span class="math inline">\(O(n,\mathbb{R})\)</span> 的离散子集，即对任何<span class="math inline">\(w\in W\)</span>，存在 <span class="math inline">\(w\)</span> 的开邻域 <span class="math inline">\(w\in U\)</span> 使得 <span class="math inline">\(U\)</span> 不包含 <span class="math inline">\(W\)</span> 中除 <span class="math inline">\(w\)</span> 外的任何元素。</p></div><p>证明：固定一个基本区域中的点 <span class="math inline">\(x\inC\)</span>，考虑从 <span class="math inline">\(\mathrm{GL}(V^\ast)\)</span> 到 <span class="math inline">\(V^\ast\)</span> 的连续映射 <span class="math display">\[g\to g\cdot x,\quadg\in\mathrm{GL}(V^\ast).\]</span> <span class="math inline">\(C\)</span>在此映射下的逆像是 <span class="math inline">\(\mathrm{GL}(V^\ast)\)</span> 中的某个开集 <span class="math inline">\(U\)</span>，并且 <span class="math inline">\(U\)</span> 显然包含恒等元 1，因为 <span class="math inline">\(1\cdot x=x\in C\)</span>，即 <span class="math inline">\(U\)</span> 是 1 的一个开邻域。<span class="math inline">\(U\)</span> 不包含其它任何 <span class="math inline">\(w\ne 1\in W\)</span>，否则 <span class="math inline">\(w\cdot x\in C\)</span>，这与 <span class="math inline">\(C\)</span> 是基本区域矛盾。同理任何 <span class="math inline">\(w\in W\)</span> 都有一个开邻域不包含其它 <span class="math inline">\(W\)</span> 中的点。</p><div id="discrete-subgroup" class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>紧 Hausdorff 拓扑群 <span class="math inline">\(G\)</span>的离散子群 <span class="math inline">\(H\)</span> 必然是有限群。</p></div><p>证明：</p><p>第一步：设 <span class="math inline">\(U\)</span> 是单位元 <span class="math inline">\(e\)</span> 的邻域且满足 <span class="math inline">\(U \cap H = \{e\}\)</span>，我们来说明存在一个邻域<span class="math inline">\(e\in V\subset U\)</span> 满足 <span class="math inline">\(VV^{-1}\subset U\)</span>。</p><p>令 <span class="math inline">\(\sigma:U\times U\to G\)</span> 为映射<span class="math inline">\(\sigma(x, y) =xy^{-1}\)</span>。由连续性，存在一个邻域 <span class="math inline">\(N\subset U\times U\)</span> 包含 <span class="math inline">\((e,e)\)</span> 使得 <span class="math inline">\(\sigma(N)\subset U\)</span>。那么 <span class="math inline">\(N\)</span> 包含一个形如 <span class="math inline">\(V_1\times V_2\)</span> 的开集，其中 <span class="math inline">\(V_1, V_2 \subset U\)</span> 是开集且 <span class="math inline">\(e\in V_1\cap V_2\)</span>。取 <span class="math inline">\(V=V_1 \cap V_2\)</span>，于是 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(e\)</span> 的一个邻域，并且 <span class="math inline">\(V\times V\subset V_1\times V_2\)</span>，因此<span class="math inline">\(VV^{-1}=\sigma(V \timesV)\subset\sigma(V_1\times V_2) \subset U\)</span>。</p><p>第二步：我们来论证 <span class="math inline">\(G\backslash H\)</span>是开集。为此只要说明对任意 <span class="math inline">\(x\in G\backslashH\)</span>，存在 <span class="math inline">\(x\)</span> 的邻域 <span class="math inline">\(U\)</span> 使得 <span class="math inline">\(U\capH=\emptyset\)</span>。设 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(e\)</span> 的邻域且 <span class="math inline">\(U\cap H=\{e\}\)</span>。令 <span class="math inline">\(V\subset U\)</span> 为具有上面第一步中性质的 <span class="math inline">\(e\)</span> 的邻域，则 <span class="math inline">\(N=Vx\)</span> 是 <span class="math inline">\(x\)</span> 的邻域。假设 <span class="math inline">\(h_1, h_2\in N\cap H\)</span>，那么存在 <span class="math inline">\(v_1,v_2\in V\)</span> 满足 <span class="math inline">\(h_1 = v_1x\)</span> 且 <span class="math inline">\(h_2=v_2x\)</span>。于是 <span class="math display">\[v_1^{-1}h_1=x=v_2^{-1}h_2\implies h_1h_2^{-1} =v_1v_2^{-1}\in VV^{-1} \subset U.\]</span> 因此 <span class="math inline">\(v_1v_2^{-1}\in H\cap U\)</span>，所以 <span class="math inline">\(h_1h_2^{-1}=e\)</span>，因此 <span class="math inline">\(h_1=h_2\)</span>。这意味着 <span class="math inline">\(N\)</span> 至多包含 <span class="math inline">\(H\)</span> 的一个元素。如果 <span class="math inline">\(N\)</span> 不包含 <span class="math inline">\(H\)</span> 的任何元素，则 <span class="math inline">\(N\)</span> 即为所求。否则若 <span class="math inline">\(N\cap H=\{h\}\)</span>，由于 <span class="math inline">\(G\)</span> 是 Hausdorff 空间，我们可以取开邻域<span class="math inline">\(U_x, U_h\subset N\)</span> 将 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(h\)</span> 分开，那么 <span class="math inline">\(U_x\)</span> 是所求的邻域。</p><p>第三步：<span class="math inline">\(H\)</span>是有限的。这是因为对每个 <span class="math inline">\(x\inH\)</span>，取其邻域 <span class="math inline">\(U_x\)</span> 使得 <span class="math inline">\(U_x\cap H=\{x\}\)</span>，这些开集加上 <span class="math inline">\(G\backslash H\)</span> 构成 <span class="math inline">\(G\)</span> 的一个开覆盖，由 <span class="math inline">\(G\)</span> 的紧性可得存在 <span class="math inline">\(G\)</span> 的有限子覆盖。于是有限多个 <span class="math inline">\(\{U_{x_i}\}_{i=1}^n\)</span> 覆盖了 <span class="math inline">\(H\)</span>。然而每个 <span class="math inline">\(U_{x_i}\)</span> 只包含一个 <span class="math inline">\(H\)</span> 中的元素 <span class="math inline">\(x_i\)</span>，所以 <span class="math inline">\(H\)</span> 是有限的。<span class="math inline">\(\blacksquare\)</span></p><p>现在 <span class="math inline">\(W\)</span> 保持 Euclidean 内积 <span class="math inline">\(B\)</span> 不变，从而是正交群 <span class="math inline">\(O(n,\mathbb{R})\)</span> 的子群。而 <span class="math inline">\(O(n,\mathbb{R})\)</span> 是紧群，<span class="math inline">\(W\)</span> 是离散子群，所以 <span class="math inline">\(W\)</span> 是有限群。</p><h1 id="and-6.4-radical-of-the-bilinear-form-finite-coxeter-groups">6.3and 6.4 Radical of the bilinear form / Finite Coxeter groups</h1><p>这两节合起来证明了 6.2 的逆命题：如果 <span class="math inline">\(W\)</span> 是有限群，则 <span class="math inline">\(B\)</span>必然是正定的。这个结论是如下几个命题合起来得到的：</p><div id="-------1" class="unnumbered statement sta____1 plain"><p><span class="statement-heading"><span class="statement-label">命题1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(V\)</span> 的一个真 <span class="math inline">\(W-\)</span> 子模，则 <span class="math inline">\(U\subset V^\bot\)</span>。</p></div><p>这个命题背后的关键是任何单根 <span class="math inline">\(\alpha_s\)</span> 必须属于 <span class="math inline">\(U\)</span> 或者 <span class="math inline">\(U^\bot\)</span> 之一。由于 <span class="math inline">\(W\)</span> 是不可约 Coxeter 群，<span class="math inline">\(\Delta\)</span>不能分成两个互相正交的子集，所以要么 <span class="math inline">\(\Delta\in U\)</span>，这与 <span class="math inline">\(U\)</span> 是真子模矛盾；要么 <span class="math inline">\(\Delta\in U^\bot\)</span>，从而 <span class="math inline">\(U\subset V^\bot\)</span>。</p><div id="-------2" class="unnumbered statement sta____2 plain"><p><span class="statement-heading"><span class="statement-label">命题2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 在 <span class="math inline">\(V\)</span> 上的作用是完全可约的。</p></div><p>这是群表示论里面的 Maschke 定理。证明技巧就是取平均构造 <span class="math inline">\(W-\)</span> 不变的正定内积。</p><div id="-------3" class="unnumbered statement sta____3 plain"><p><span class="statement-heading"><span class="statement-label">命题3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B\)</span> 是非退化的。</p></div><p>若不然 <span class="math inline">\(V^\bot\ne(0)\)</span>，完全可约性说明 <span class="math inline">\(V^\bot\)</span> 有直和补 <span class="math inline">\(U\)</span>，但是 <span class="math inline">\(U\)</span> 也在 <span class="math inline">\(V^\bot\)</span> 中，矛盾。</p><div id="-------4" class="unnumbered statement sta____4 plain"><p><span class="statement-heading"><span class="statement-label">命题4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 在 <span class="math inline">\(V\)</span> 上是不可约的。</p></div><p>这是命题 3 的直接结论，因为有非平凡的真子模意味着 <span class="math inline">\(V^\bot\)</span> 也非平凡，与 <span class="math inline">\(B\)</span> 非退化矛盾。</p><div id="-------5" class="unnumbered statement sta____5 plain"><p><span class="statement-heading"><span class="statement-label">命题5</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B\)</span> 是正定的。</p></div><p>实际上 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(W\)</span> 的不可约表示说明 <span class="math inline">\(V\)</span> 上的 <span class="math inline">\(W-\)</span>不变双线性函数构成的向量空间是一维的。而我们已经有一个 <span class="math inline">\(W-\)</span> 不变的正定内积，所以 <span class="math inline">\(B\)</span>必然是它的一个倍数，从而也是正定的。</p><h1 id="affine-coxeter-groups">6.5 Affine Coxeter groups</h1><p>之前第 4 章介绍的仿射 Coxeter群是通过关于超平面的反射构造的，这种反射未必是线性的；而 Coxeter群的几何实现中，<span class="math inline">\(W\)</span>是由线性反射生成的。这一节将这两种方式统一起来。</p><p>设 <span class="math inline">\((W,S)\)</span> 是不可约 Coxeter群，<span class="math inline">\(|S|=n+1\)</span>。根据第 5章几何实现的讨论，我们知道 <span class="math inline">\((W,S)\)</span>可以实现为 <span class="math inline">\(n+1\)</span> 维实向量空间 <span class="math inline">\(V\)</span> 上的反射群。设 <span class="math inline">\(V\)</span> 的一组基为 <span class="math inline">\(\Delta=\{\alpha_i\}\)</span>，每个 <span class="math inline">\(s_i\in S\)</span> 对应于 <span class="math inline">\(V\)</span> 上的反射 <span class="math inline">\(s_{\alpha_i}\)</span>。</p><p>此外设 <span class="math inline">\(V^\ast\)</span> 是 <span class="math inline">\(V\)</span> 的对偶空间，<span class="math inline">\(\langle \cdot,\cdot \rangle\)</span> 是 <span class="math inline">\(V\times V^\ast\to\mathbb{R}\)</span>的自然配对。</p><p>我们来分析当 Cartan 矩阵是半正定，但不是正定时 <span class="math inline">\((W,S)\)</span> 的结构。</p><p>根据 2.6 小节的结论，<span class="math inline">\(\mathrm{rad}{(V)}=\mathbb{R}\delta\)</span>可以由一个向量 <span class="math inline">\(\delta\)</span> 生成，并且<span class="math inline">\(W\)</span> 保持子空间 <span class="math inline">\(\mathbb{R}\delta\)</span> 不变。在 <span class="math inline">\(V/\mathbb{R}\delta\)</span>上诱导的内积是正定的。</p><p>我们知道，<span class="math inline">\(W\)</span> 也作用在 <span class="math inline">\(V^\ast\)</span> 上，这个作用的定义是规定 <span class="math inline">\(W\)</span> 保持双线性对 <span class="math inline">\(\langle \cdot,\cdot \rangle\)</span> 不变： <span class="math display">\[\langle wv,wx \rangle = \langle v, x\rangle.\quad w\in W,v\in V, x\in V^\ast.\]</span> 记 <span class="math display">\[\begin{aligned}H_0&amp;=\{x\in V^\ast\mid \langle\delta,x\rangle=0\},\\H_1&amp;=\{x\in V^\ast\mid \langle\delta,x\rangle=1\}.\end{aligned}\]</span> 则 <span class="math inline">\(H_0\)</span>是线性子空间，<span class="math inline">\(H_1\)</span>是仿射超平面。<span class="math inline">\(W\)</span> 保持 <span class="math inline">\(H_0,H_1\)</span> 不变：因为对任何 <span class="math inline">\(x\in V^\ast\)</span> 都有 <span class="math display">\[\langle\delta,wx\rangle=\langlew^{-1}\delta,x\rangle=\langle\delta,x\rangle.\]</span></p><p>注意到 <span class="math inline">\(H_0\)</span> 与 <span class="math inline">\(V/\mathbb{R}\delta\)</span> 是对偶的，所以它是一个Euclidean空间（通过指定一组对偶基，你可以把一个空间上的度量挪到它的对偶空间上）；<span class="math inline">\(H_1\)</span> 作为 <span class="math inline">\(H_0\)</span> 平移得到的超平面也具有 Euclidean度量。<span class="math inline">\(W\)</span> 同样保持 <span class="math inline">\(H_0\)</span> 和 <span class="math inline">\(H_1\)</span> 上的度量不变。</p><p>所以我们只要在 <span class="math inline">\(V^\ast\)</span>中考虑问题即可。现在的问题变成，已知 <span class="math inline">\(W\leqslant {\rm GL}(V^\ast)\)</span> 保持 <span class="math inline">\(H_0,H_1\)</span> 不变，分析 <span class="math inline">\(W\)</span> 在 <span class="math inline">\(H_1\)</span> 上的作用。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(f: H_1\to H_1\)</span>是映射，如果存在 <span class="math inline">\(T\in {\rmGL}(V^\ast)\)</span> 满足 <span class="math inline">\(f(x + y) - f(x) =T(y)\)</span> 对任何 <span class="math inline">\(x\in H_1,y\inH_0\)</span> 成立，就称 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(H_1\)</span> 上的仿射变换。记 <span class="math inline">\({\bf Aff}(H_1)\)</span> 是 <span class="math inline">\(H_1\)</span> 上所有仿射变换构成的集合，不难验证<span class="math inline">\({\bf Aff}(H_1)\)</span>在映射的复合下构成一个群。</p></div><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span><span class="math inline">\(W\)</span> 在 <span class="math inline">\(H_1\)</span> 上的作用诱导了群同态 <span class="math inline">\(W\to {\bf Aff}(H_1)\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(w\)</span> 在<span class="math inline">\(V^\ast\)</span> 上的作用是线性的，<span class="math inline">\(w(x+y)-w(x)=w(y)\)</span>，所以结论是显然的。<span class="math inline">\(\blacksquare\)</span></p><h1 id="hecke-algebras-and-inverses">7.4 Hecke algebras andinverses</h1><p>这一节引入了 <span class="math inline">\(R\)</span>多项式，并给出了它们满足的递推关系。这部分用对合来处理会比较方便。</p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>对任何 <span class="math inline">\(w\in W\)</span>， <span class="math display">\[q^{l(w)}\,\overline{T_w}=\sum_{x\leqw}(-1)^{l(x)+l(w)}R_{x,w}(q)T_x.\]</span> 其中 <span class="math inline">\(R_{x,w}(q)\in\mathbb{Z}[q]\)</span> 是关于 <span class="math inline">\(q\)</span> 的多项式，满足 <span class="math inline">\(R_{w,w}(q)=1\)</span>。</p></div><p><strong>证明</strong>：由 <span class="math inline">\(q^{l(e)}\,\overline{T_e}=q^0\,\overline{T_e}=T_e\)</span>，结论对<span class="math inline">\(w=e\)</span> 成立。当 <span class="math inline">\(l(w)&gt;0\)</span> 时，设 <span class="math inline">\(w=s_1\cdots s_r\)</span> 是一个既约表示，则 <span class="math display">\[\begin{align}q^{l(w)}\,\overline{T_w}&amp;=q^r\,\overline{T_{s_1\cdots s_r}}\\&amp;=q^r\,\overline{T_{s_1}}\cdots\overline{T_{s_r}}\\&amp;=(qT_{s_1}^{-1})\cdots (qT_{s_r}^{-1})\\&amp;=(T_{s_1}+1-q)\cdots (T_{s_r}+1-q)\\&amp;=\sum_{k=1}^r\sum_{1\leq i_1\leq\cdots\leq i_k\leqr}(1-q)^{r-k}T_{s_{i_1}}\cdots T_{s_{i_k}} + (1-q)^r.\end{align}\]</span> 注意到每个 <span class="math inline">\(T_{s_{i_1}}\cdots T_{s_{i_k}}=T_{s_1\cdotss_k}=T_x\)</span>，<span class="math inline">\(x\)</span> 是 <span class="math inline">\(w\)</span> 的子表达式，所以 <span class="math inline">\(x\leq w\)</span>。合并相同的 <span class="math inline">\(x\)</span> 的系数以后，显然 <span class="math inline">\(T_x\)</span> 的系数在 <span class="math inline">\(\mathbb{Z}[q]\)</span> 中，所以存在 <span class="math inline">\(R_{x,w}\in\mathbb{Z}[q]\)</span> 满足 <span class="math display">\[\sum_{k=1}^r\sum_{1\leq i_1\leq\cdots\leq i_k\leqr}(1-q)^{r-k}T_{s_{i_1}}\cdots T_{s_{i_k}} +(1-q)^r=\sum_{x\leqw}(-1)^{l(x)+l(w)}R_{x,w}(q)T_x.\]</span> 由于 <span class="math inline">\(s_{i_1}\cdots s_{i_k}=w\)</span>只有一种可能，就是 <span class="math inline">\(k=r\)</span> 并且 <span class="math inline">\((i_1,\ldots,i_r)=(1,\ldots,r)\)</span>，所以 <span class="math inline">\(R_{w,w}(q)=1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(s\in S\)</span>，<span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(sw&lt;w\)</span>，则 <span class="math display">\[R_{x,w}(q) = \begin{cases}R_{sx,sw}(q) &amp; \text{if } sx&lt;x,\\qR_{sx,sw}(q)+(q-1)R_{x,sw}(q) &amp; \text{if } x&lt;sx.\end{cases}\]</span></p></div><p><strong>证明</strong>： <span class="math display">\[\begin{aligned}&amp;\qquad\sum_{w\in W}(-1)^{l(x)+l(w)}R_{x,w}(q)T_x =q^{l(w)}\,\overline{T_w}=q^{l(s)+l(sw)}\overline{T_s}\,\overline{T_{sw}}=q\,\overline{T_s}\,q^{l(sw)}\,\overline{T_{sw}}\\&amp;=(T_s +1-q)\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x\\&amp;=\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)(T_sT_x+(1-q)T_x)\\&amp;=(1-q)\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x + \sum_{w\inW}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_sT_x\\&amp;=(1-q)\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x +\sum_{w\inW,\,x&lt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_{sx}\\&amp;\quad +\sum_{w\inW,\,x&gt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)(qT_{sx}+(q-1)T_x)\\&amp;=(1-q)\sum_{w\inW,\,x&lt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x+\sum_{w\inW,\,x&lt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_{sx}\\&amp;\quad+\,q\sum_{w\in W,\,x&gt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_{sx}\\&amp;\overset{y=sx}=(q-1)\sum_{w\inW,\,x&lt;sx}(-1)^{l(w)+l(x)}R_{x,sw}(q)T_x+\sum_{w\in W,\,sy&lt;y}(-1)^{l(sw)+l(sy)}R_{sy,sw}(q)T_y\\&amp;\quad +q\sum_{w\inW,\,sy&gt;y}(-1)^{l(sw)+l(sy)}R_{sy,sw}(q)T_y\\&amp;\overset{y=x}=\sum_{w\inW,\,sx&lt;x}(-1)^{l(w)+l(x)}R_{sx,sw}(q)T_x+\sum_{w\inW,\,sx&gt;x}(-1)^{l(w)+l(x)}\left(qR_{sx,sw}+(q-1)R_{x,sw}\right)T_x.\end{aligned}\]</span> 比较两边 <span class="math inline">\(T_x\)</span>的系数即可得到结论。</p><h1 id="further-properties-of-r-polynomials">7.8 Further properties of<span class="math inline">\(R\)</span>-polynomials</h1><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span><span class="math inline">\(R\)</span>-多项式满足如下性质：</p><ol type="1"><li><span class="math inline">\((-q)^{l(w)-l(x)}\overline{R_{x,w}(q)}=R_{x,w}\)</span>。</li><li><span class="math inline">\(\sum_{x\leq y\leqw}(-1)^{l(x)+l(y)}R_{x,y}(q) R_{y,w}(q)=\delta_{x,w}\)</span>。</li></ol></div><p>1 的证明：对 <span class="math inline">\(w\)</span> 的长度归纳。如果<span class="math inline">\(l(w)=0\)</span> 则 <span class="math inline">\(w=x=e\)</span>，<span class="math inline">\(R_{e,e}=1\)</span>，结论成立。</p><p>设结论对所有长度 <span class="math inline">\(&lt;l(w)\)</span>的元素成立，取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(l(sw)&lt;l(w)\)</span>。考虑两种情况：</p><ul><li><span class="math inline">\(sx &lt; x\)</span>。这时 <span class="math inline">\(R_{x,w}=R_{sx,sw}\)</span>，对 <span class="math inline">\(sw\)</span> 应用归纳假设 <span class="math display">\[(-q)^{l(sw)-l(sx)}\overline{R_{sx,sw}}=R_{sx,sw}=R_{x,w}.\]</span>由于 <span class="math inline">\(l(sw)-l(sx)=l(w)-l(x)\)</span>所以结论对 <span class="math inline">\(w\)</span> 也成立。</li><li><span class="math inline">\(sx&gt;x\)</span>。 <span class="math display">\[\begin{align}(-q)^{l(w) - l(x)} R_{x,w}(q) &amp;= (-1)^{l(w) + l(x)} q^{l(w) - l(x)}R_{x,w}(q^{-1}) \\&amp;= (-1)^{l(w) + l(x)} q^{l(w) - l(x)} \left( q^{-1}R_{sx,sw}(q^{-1}) + (q^{-1} - 1) R_{x,sw}(q^{-1}) \right) \\&amp;= (-1)^{l(w) + l(x)} q^{l(sw) - l(sx)} q^2\left( q^{-1}R_{sx,sw}(q^{-1}) + (q^{-1} - 1) R_{x,sw}(q^{-1}) \right) \\&amp;= q (-1)^{l(sw) + l(sx)} q^{l(sw) - l(sx)} R_{sx,sw}(q^{-1}) \\&amp;\quad - (-1)^{l(sw) + l(x)} q^{l(sw) - l(x)} (1 - q)R_{x,sw}(q^{-1}) \\&amp;= q (-q)^{l(sw) - l(sx)} R_{sx,sw}(q) + (q - 1)(-q)^{l(sw) - l(x)}R_{x,sw}(q) \\&amp;= q R_{sx,sw}(q) + (q - 1) R_{x,sw}(q) \\&amp;= R_{x,w}(q).\end{align}\]</span></li></ul><p>2 的证明：根据 <span class="math inline">\(R\)</span>-多项式的定义，<span class="math display">\[\overline{T_w}=q^{-l(w)}\sum_{y\inW}(-1)^{l(y)+l(w)}R_{y,w}T_y.\]</span> 两边取对合得到 <span class="math display">\[\begin{aligned}T_w&amp;=\overline{q^{-l(w)}\sum_{y\in W}(-1)^{l(y)+l(w)}R_{y,w}T_y}\\&amp;=q^{l(w)}\sum_{y\inW}(-1)^{l(y)+l(w)}\overline{R_{y,w}}\,\overline{T_y}\\&amp;=q^{l(w)}\sum_{y\in W}(-1)^{l(y)+l(w)}q^{l(y)-l(w)}R_{y,w}\cdotq^{-l(y)}\sum_{x\in W}(-1)^{l(x)+l(y)}R_{x,y}T_y\\&amp;=\sum_{x\in W}\left(\sum_{x\leq y\leqw}(-1)^{l(y)+l(x)}R_{x,y}R_{y,w}\right)T_x\end{aligned}\]</span> 比较两边关于 <span class="math inline">\(T_w\)</span> 项的系数即可。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Indra&#39;s pearls 中英双语对照</title>
      <link href="/indra/index.html"/>
      <url>/indra/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="扉页">扉页</h1><figure><img src="/images/indra/inner-cover.jpg" class="fig" width="400" alt="The ancient Buddhist dream of Indra’s Net 佛教古老的因陀罗网想象"><figcaption aria-hidden="true">The ancient Buddhist dream of Indra’s Net佛教古老的因陀罗网想象</figcaption></figure><div class="statement simple plain unnumbered"><p>In the heaven of the great god Indra is said to be a vast andshimmering net, finer than a spider’s web, stretching to the outermostreaches of space. Strung at the each intersection of its diaphanousthreads is a reflecting pearl. Since the net is infinite in extent, thepearls are infinite in number. In the glistening surface of each pearlare reflected all the other pearls, even those in the furthest cornersof the heavens. In each reflection, again are reflected all theinfinitely many other pearls, so that by this process, reflections ofreflections continue without end.</p></div><p>在印度教主神因陀罗的梵天之中，悬有一张璀璨绝伦的珍珠宝网，其纤细更胜蛛丝，绵延至宇宙的终极边际。这轻若云烟的罗网间，每一经纬交汇处皆垂缀明珠，因法界无尽，故明珠无量。每颗宝珠的莹润光华中，俱现十方世界一切珠影，纵使远在梵天极隅之珠亦纤毫毕现。更妙者，珠中所映万千珠影，复现重重无尽珠光，如镜镜相照，光光互摄，遂成华严玄境，映现大千世界之无穷法界。</p><p><strong>Cover picture</strong>: A mathematically generated pictureforetold in the Buddhist myth of Indra’s net? We sometimes call theseKlein Bubbles. The smallest ones are sehr klein.</p><div id="------------" class="statement sta_____ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">封面图片</span>.</span><span class="statement-spah"></span>这幅由数学生成的瑰丽图案，是否暗合了佛教因陀罗网的古老寓言？我们称之为”克莱因泡泡”，其中最小的泡泡在德语中恰被称作“sehr klein”　（“意为极小”）。</p></div><h1 id="前言">前言</h1><h2 id="这是什么类型的书">这是什么类型的书？</h2><div class="statement simple plain unnumbered"><p>This is a book about serious mathematics, but one which we hope willbe enjoyed by as wide an audience as possible. It is the story of ourcomputer aided explorations of a family of unusually symmetrical shapes,which arise when two spiral motions of a very special kind are allowedto interact. These shapes display intricate ‘fractal’ complexity onevery scale from very large to very small. Their visualisation formspart of a century-old dream conceived by the great German geometer FelixKlein. Sometimes the interaction of the two spiral motions is quiteregular and harmonious, sometimes it is total disorder and sometimes andthis is the most intriguing case - it has layer upon layer of structureteetering on the very brink of chaos.</p></div><p>这是一本关于严谨数学的著作，但我们希望尽可能多的读者都能从中获得乐趣。本书讲述了我们借助计算机，对一类具有非同寻常对称性的图形进行探索的过程。这些图形源自两种特殊螺旋运动的相互作用，展现出在从宏观到微观各个尺度上都极为复杂的“分形”结构。它们的可视化工作实现了德国伟大几何学家菲利克斯·克莱因一个百年前的数学梦想。有时候，这两种螺旋运动的相互作用是规律而和谐的；有时则是完全无序的，最引人入胜的是它们在秩序与混乱的临界状态下，层层结构交织，令人着迷。</p><div class="statement simple plain unnumbered"><p>As we progressed in our explorations, the pictures that our computerprograms produced were so striking that we wanted to tell our tale in amanner which could be appreciated beyond the narrow confines of a smallcircle of specialists. You can get a foretaste of their variety bytaking a look at the Road Map on the final page. Mathematicians oftenuse the word ‘beautiful’ in talking about their proofs and ideas, but inthis case our judgment has been confirmed by a number of unbiassed anddefinitely non-mathematical people. The visual beauty of the pictures isa veneer which covers a core of important and elegant mathematicalideas; it has been our aspiration to convey some of this inneraesthetics as well. There is no religion in our book but we were amazedat how our mathematical constructions echoed the ancient Buddhistmetaphor of Indra’s net, spontaneously creating reflections withinreflections, worlds without end.</p></div><p>随着我们探索的深入，计算机程序生成的几何图像展现出令人震撼的数学美感，这促使我们渴望以一种超越专业圈子，为更广泛读者所欣赏的方式来讲述这个故事。读者可以通过书末的“探索路线图”先睹为快，感受这些图像的多样风貌。</p><p>数学家在谈论他们的证明理念时常常使用“美”这个词，但这一次，不只是我们这样认为——许多并不具数学背景的外行人也认同这些图像具有非凡的美感。图像的视觉美只是一层表面，它所覆盖的内核是重要而优雅的数学思想；我们也希望能够传达这种深层次的美。</p><p>虽然本书并不涉及宗教，但我们惊讶地发现，我们的数学结构与佛教“因陀罗网”这一古老隐喻之间产生了意外的共鸣，层层反射自发地衍生出无尽的宇宙。</p><div class="statement simple plain unnumbered"><p>Most mathematics is accessible, as it were, only by crawling througha long tunnel in which you laboriously build up your vocabulary andskills as you abstract your understanding of the world. The mathematicsbehind our pictures, though, turned out not to need too much in the wayof preliminaries. So long as you can handle high school algebra withconfidence, we hope everything we say is understandable. Indeed giventime and patience, you should be able to make programs to create newpictures for yourself. And if not, then browsing through the figuresalone should give a sense of our journey. Our dream is that this bookwill reveal to our readers that mathematics is not alien and remote butjust a very human exploration of the patterns of the world, one whichthrives on play and surprise and beauty.</p></div><p>大多数数学的学习过程就像是在一条漫长的隧道中缓慢前行。在这个过程中，你不断积累词汇和技巧，一步步抽象出对世界的理解。然而，本书图像背后的数学却并不需要太多前置知识。只要你能自信地掌握高中代数，我们相信你能理解书中的所有内容。事实上，若有足够的时间和耐心，你应该能编写程序，自己创造新的图像。即使不这样，仅仅浏览这些图像，也能感受到我们这段旅程的魅力。我们的梦想是通过这本书让读者意识到，数学并非遥远而陌生的事物，而是人类探索世界规律的一种方式，是对世界中各种模式的追寻，它源于游戏、惊喜与美的激发。</p><h2 id="我们是如何开始写它的">我们是如何开始写它的？</h2><div id="david-m----s-story" class="statement sta_david_m__s_story plain unnumbered"><p><span class="statement-heading"><span class="statement-label">DavidM.’s story</span>.</span><span class="statement-spah"> </span>This bookhas been over twenty years in the writing. The project began when BenoitMandelbrot visited Harvard in 1979/80, in the midst of his explorationsof complex iteration - the ‘fractals’ known as Julia sets - and the nowfamous ‘Mandelbrot Set’. He had also looked at some nineteenth centuryfigures produced by infinite repetitions of simple reflections incircles, a prototypical example of which had fascinated Felix Klein.David W. and I pooled our expertise and began to develop these ideasfurther in the Kleinian context. The computer rapidly began producingpictures like the ones you will find throughout the book.</p></div><p><strong>戴维·芒福德（DavidMumford）的故事</strong>。本书的写作历时二十余年。项目的起点可以追溯到1979/80 年，当时贝努瓦·曼德布罗特（Benoit B.Mandelbrot）正在访问哈佛大学。彼时他正在探索复迭代系统——即后来被称为朱利亚集的“分形”以及如今广为人知的“曼德布洛特集合”。在此期间，曼德布罗特还研究了一些19世纪的图形，这些图形是通过圆反射的无限迭代所生成的，其中一个原型曾经让菲利克斯·克莱因（FelixKlein）深感着迷。大卫·怀特（DavidW.）和我结合了各自的专业知识，开始在克莱因群的框架下进一步发展这些想法。计算机很快就生成了类似本书中随处可见的那些图像。</p><div class="statement simple plain unnumbered"><p>What to do with the pictures? Two thoughts surfaced: the first wasthat they were unpublishable in the standard way. There were notheorems, only very suggestive pictures. They furnished convincingevidence for many conjectures and lures to further exploration, buttheorems were the coin of the realm and the conventions of that daydictated that journals only publish theorems. The second thought wasequally daunting: here was a piece of real mathematics that we couldexplain to our non-mathematical friends. This dangerous temptationprevailed, but it turned out to be much, much more difficult than weimagined.</p></div><p>这些图像该如何处理呢？我脑海中浮现出两个念头：首先，它们无法以传统方式发表。它们没有定理，只有一些极具启发性的图像。虽然它们为许多猜想提供了令人信服的证据，也为进一步探索指引了方向，但定理才是数学界通行的“硬通货”，而当时的惯例是，期刊只发表包含定理的文章。</p><p>第二个念头同样令人生畏：这是一段真正的数学内容，而我们竟然可以把它讲给非数学背景的朋友听。这种危险的诱惑最终占了上风，但我们很快发现，这远比我们想象的要困难得多。</p><div class="statement simple plain unnumbered"><p>We persevered off and on for a decade. One thing held us back:whenever we got together, it was so much more fun to produce morefigures than to write what Dave W. named in his computer TheBook. I havefond memories of traipsing through sub-zero degree gales to thebunker-like supercomputer in Minneapolis to push our calculations stillfurther. The one loyal believer in the project was our ever-faithful andpatient editor, David Tranah. However, things finally took off whenCaroline was recruited a bit more than a decade ago. It took a while tolearn how to write together, not to mention spanning the gulfs betweenour three warring operating systems. But our publisher, our families andour friends told us in the end that enough was enough.</p></div><p>我们断断续续坚持了十年。最大的障碍是，每次见面时，大家都觉得创作新图比写David W. 在他的电脑里命名为 “The Book”的那本书要有趣得多。我至今仍清晰记得，在明尼阿波利斯刺骨的寒风中，我们跋涉到堡垒般的超级计算机中心，只为将计算推向新的极限。始终对这个项目抱有信心的，是我们忠诚而耐心的编辑David Tranah。但真正的转折点，是十多年前 Caroline的加入。我们花了好一阵子才学会如何一起写作，更别提如何在三个“势不两立”的操作系统之间架起桥梁。不过最终，我们的出版商、家人和朋友都对我们说：够了，该收尾了。</p><div class="statement simple plain unnumbered"><p>You know that ‘word problem’ you hated the most in elementary school?The one about ditch diggers. Ben digs a ditch in 4 hours, Ned in 5 andTed in 6. How long do they take to dig it together? The textbook willtell you 1 hour, 37 minutes and 17 seconds. Baloney! We have uncoveredincontrovertable evidence that the right answer is hours. This is a deepprinciple involving not merely mathematics but sociology, psychology,and economics. We have a remarkable proof of this but even CambridgeUniversity Press’s generous margin allowance is too small to containit.</p></div><p>你还记得你小学时最讨厌的那道“应用题”吗？就是关于挖沟工人的那题。Ben 4小时能挖完一条沟，Ned 需要 5 小时，Ted 要 6小时。那他们一起挖，要多久才能挖完？课本会告诉你答案是 1 小时 37 分 17秒。胡说八道！我们已经通过实践得到了确凿的证据，真正的耗时应该是 4 + 5 +6 = 15小时。这背后蕴藏着一个深刻的原理，不仅仅涉及数学，还牵扯到社会学、心理学和经济学。我们有一个精彩绝伦的证明过程，但即使是剑桥大学出版社那慷慨的版面，也无法容纳它。</p><div id="david-w----s-story" class="statement sta_david_w__s_story plain unnumbered"><p><span class="statement-heading"><span class="statement-label">DavidW.’s story</span>.</span><span class="statement-spah"> </span>This is abook of a thousand beginnings and for a long time apparently no end. Forme, though, the first beginning was in 1979 when my friend and fellowgrad student at Harvard Mike Stillman told me about a problem that histeacher David Mumford had described to him: Take two very simpletransformations of the plane and apply all possible combinations ofthese transformations to a point in the plane. What does the resultingcollection of points look like?</p><p>Of course, the thing was not just to think about the shapes but toactually draw them with the computer. Mike knew I was interested indiscrete groups, and we shared a common interest in programming. Also,thanks to another friend and grad student Max Benson, I was alerted to avery nice C library for drawing on the classic Tektronix 4014 graphicsterminal. The only missing ingredient was happily filled by a curiousfeature of a Harvard education: I had passed my qualifying exams, andthen I had nothing else to do except write my doctoral thesis. I have avery distinct memory of feeling like I had a lot of time on my hands. Astime has passed, I have been astonished to discover that that was thelast time I felt that way.</p></div><p><strong>David W.的故事</strong>。这是一本拥有千百种开端、却似乎长久没有结局的书。对我来说，最初的开端是在1979 年，那时我在哈佛的朋友、也是研究生同学的 Mike Stillman跟我讲了一个问题，这是他的老师 David Mumford描述给他的：取平面上的两种非常简单的变换，将这些变换以各种可能的组合作用在平面上的某个点上。最终得到的这一系列点组成的集合，会是什么样子呢？</p><p>当然，事情不仅仅是思考这些图形的形状，而是要真正用计算机把它们画出来。Mike知道我对离散群感兴趣，我们在编程方面也有共同爱好。此外，多亏了另一位朋友兼研究生Max Benson 的提醒，我发现了一个非常棒的 C 语言库，可以在经典的 Tektronix4014图形终端上进行绘图。最后一个缺失的要素，恰好被哈佛教育中一个颇为特别的安排所填补：我已经通过了资格考试，接下来除了写博士论文之外，几乎没有其他事可做。我清楚地记得当时有一种“手头时间充裕”的感觉。随着时间流逝，我愈发惊讶地意识到，那竟然是我最后一次有那种感觉。</p><div class="statement simple plain unnumbered"><p>Anyway, as a complete lark, I tagged along with David M. while hebuilt a laboratory of computer programs to visualize Kleinian groups. Itwas a mathematical joy-ride. As it so happened, in the summer of 1980 ,there was a great opportunity to share the results of these computerexplorations with the world at the historic Bowdoin College conferencein which Thurston presented his revolutionary results inthree-dimensional topology and hyperbolic geometry. We arranged for aTektronix terminal to be set up in Maine, and together with anacoustically coupled modem at the blazing speed of 300 bits per seconddisplayed several limit sets. The reaction to the limit curves wigglingtheir way across the screen was very positive, and severalmathematicians there also undertook the construction of various computerprograms to study different aspects of Kleinian groups.</p><p>That left us with the task of writing an explanation of ouralgorithms and computations. However, at that point it was certainlypast time for me to complete my thesis. Around 1981, I had the very goodfortune of chatting with a new grad student at Harvard by the name ofCurt McMullen who had intimate knowledge of the computer systems at theThomas J. Watson Research Center of IBM, thanks to summer positionsthere. After roping Curt in, and at the invitation and encouragement ofBenoit Mandelbrot, Curt and David M. made a set of extremely highquality and beautiful black-and-white graphics of limit sets. I wouldlike to express my gratitude for Curt’s efforts of that time and hisfriendship over the years; he has had a deep influence on my own effortson the project.</p></div><p>总之，出于一种完全随性的心态，我跟着 David M.一起参与了一个项目，他正在构建一个用于可视化 Kleinian群的计算机程序实验室。这段经历堪称一次数学上的狂欢之旅。恰巧在 1980年夏天，出现了一个极好的机会，可以在一场意义非凡的会议上向世人展示这些计算机探索的成果——那就是在鲍登学院（BowdoinCollege）举办的历史性会议上，Thurston发表了他在三维拓扑和双曲几何方面的革命性成果。我们设法在缅因州安装了一台Tektronix 终端，并通过一台声耦合调制解调器，以惊人的 300比特每秒的速度，展示了多个极限集。当这些极限曲线在屏幕上蜿蜒浮现时，反响非常热烈。与会的几位数学家也纷纷投身其中，开始构建各类计算机程序，以研究Kleinian 群的不同方面。</p><p>接下来，我们需要撰写一份关于我们算法和计算过程的说明。然而，那时我确实已经到了必须完成论文的最后期限了。大约在1981 年，我非常幸运地结识了哈佛的一位新晋研究生 CurtMcMullen，他因为暑期曾在 IBM 的 Thomas J. Watson研究中心工作，对那里的计算机系统非常熟悉。在 Benoit Mandelbrot的邀请与鼓励下，我拉上了 Curt 一起参与项目，Curt 和 David M.一同制作了一组非常高质量且精美的极限集黑白图像。在此，我要感谢 Curt当时的辛勤付出，以及多年来给予我的友谊；他对我在这个项目上的努力产生了深远的影响。</p><div class="statement simple plain unnumbered"><p>Unfortunately, as we moved on to new and separate institutions, withvarying computing facilities, it was difficult to maintain the programsand energy to pursue this project. I would like to acknowledge theencouragement I received from many people including my friend BillGoldman while we were at M.I.T., Peter Tatian and James Russell, whoworked with me while they were undergraduates at M.I.T., Al Marden andthe staff of the Geometry Center, Charles Matthews, who worked with meat Oklahoma State, and many other mathematicians in the Kleinian groupscommunity. I would also like to thank Jim Cogdell and the SouthwesternBell Foundation for some financial support in the final stages. Theserious and final beginning of this book took place when Caroline agreedto contribute her own substantial research work in this area and herexpository gifts, and also step into the middle between the first andthird authors to at least moderate their tendency to keep programmingduring our sporadic meetings to find the next cool picture. At last, weactually wrote some text.</p></div><p>遗憾的是，随着我们各自前往新的、彼此独立的机构，计算设施也各不相同，这使得我们难以维持继续推进这个项目所需的程序和热情。我想对许多人表达感谢，他们给予了我鼓励，包括我在麻省理工时的朋友比尔·戈德曼，以及在本科期间与我一同工作的彼得·塔廷和詹姆斯·拉塞尔，还有几何中心的艾尔·马登和工作人员，曾与我在俄克拉荷马州立大学共事的查尔斯·马修斯，以及许多来自克莱因群研究领域的数学家。我还要感谢吉姆·科格德尔和西南贝尔基金会在本书最后阶段给予的一些资金支持。</p><p>这本书真正意义上的严肃开端，是在卡罗琳同意贡献她在该领域的重要研究成果和她出色的讲解才能之后。同时，她还在第一作者和第三作者之间起到了“缓冲”作用——至少能抑制他们在我们偶尔聚会时总想继续编程、寻找下一幅炫酷图像的冲动。最终，我们终于开始真正动笔写作了。</p><div class="statement simple plain unnumbered"><p>We have witnessed a revolution in computing and graphics during theyears of this project, and it has been difficult to keep pace. I wouldalso like to thank the community of programmers around the world forcreating such wonderful free software such as TEX, Gnu Emacs, X Windowsand Linux, without which it would have been impossible to bring thisproject to its current end.</p><p>During the years of this project, the most momentous endings andbeginnings of my life have happened, including the loss of my motherElizabeth, my father William, and my grandmother and family’s matriarchElizabeth, as well as the birth of my daughters Julie and Alexandra. Ioffer my part in these pictures and text in the hope of new beginningsfor those who share our enjoyment of the human mind’s beautiful capacityto puzzle through things. Programming these ideas is both vexing andimmensely fun. Every little twiddle brings something fascinating tothink about. But for now I’ll end.</p></div><p>在这个项目进行的这些年里，我们见证了计算和图形领域的一场革命，步伐之快令人难以跟上。我也想感谢全球程序员社区，他们创造了如此出色的免费软件，如TeX、Gnu Emacs、X Windows 和Linux。没有这些软件，这个项目根本无法走到今天这一步。</p><p>在这个项目进行的岁月里，我人生中最重大的结束与开始也相继发生了：我失去了母亲伊丽莎白、父亲威廉、祖母兼家族的女族长伊丽莎白，也迎来了我两个女儿朱莉和亚历山德拉的出生。我献上这些图画与文字，是希望在新的开始中，与同样热爱人类思维之美的人们分享这份乐趣。将这些思想转化为程序既令人头疼，又妙趣横生。每一个微小的调整，都会带来值得深思的趣味。不过，现在，我将告一段落。</p><div id="caroline---s-story" class="statement sta_caroline_s_story plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Caroline’s story</span>.</span><span class="statement-spah"> </span>I first saw some of David M. and DavidW.’s pictures in the mid-80s, purloined by my colleague David Epstein onone of his periodic visits to the Geometry Center in Minneapolis. I wasstruck by how pretty they were - they reminded me of the kind of lacework called tatting, which in another lifetime I would have liked tomake myself.</p><p>I presumed that everyone else understood all about the pictures, anddidn’t pay too much attention, until a little while later Linda Keen andI were looking round for a new project. I had spent many years workingon Fuchsian groups (see Chapter 6), and was wanting something whichwould lead me in to the Kleinian realm where at that time it was all go,developing Thurston’s wonderful new ideas about three-dimensionalnon-Euclidean geometry (see Chapter 12). By that time, I had somehow gothold of Dave W.’s preprint which described the explorations reported inChapter 9. I suggested to Linda that it might fit the bill.</p></div><p><strong>卡罗琳的故事</strong>。我第一次看到 David M. 和 David W.的一些图像是在 80 年代中期，那是我同事 David Epstein去明尼阿波利斯的几何中心定期访问时偷偷带回来的。我被这些图像的美丽深深吸引——它们让我想起一种叫做梭编（tatting）的蕾丝工艺，如果我换一种人生路径，或许也会喜欢亲手做这种东西。</p><p>我原以为其他人都已经完全理解这些图像的意义，因此起初也没有太在意。直到后来，我和Linda Keen 正在寻找一个新的研究课题。当时我已经在 Fuchs 群（见第 6章）上工作了很多年，想要转向 Kleinian群的研究领域——那时这个领域正如火如荼地发展，围绕 Thurston提出的关于三维非欧几何的奇妙新思想（见第 12章）。那时，我不知怎么搞到了一份 Dave W. 的预印本，里面描述了第 9章中提到的探索。我于是向 Linda 提议：或许我们可以从这里入手。</p><div class="statement simple plain unnumbered"><p>The first year was one of frustration, staring at pictures like theones in Chapter 9 without being able to get any real handle on what wasgoing on. Then one morning one of us woke up with an idea. We tried afew hand calculations and it seemed promising, so we asked Dave W. todraw us a picture of what we called the ‘real trace rays’. What cameback was a rudimentary version of the last picture in this book the onewe have called ‘The end of the rainbow’. For me it was more like ‘Thebeginning of the rainbow’, one of the defining moments of mymathematical life. Here we were, having made a total shot in the dark,having no idea what the rays could mean, but knowing they had absolutelyno right to be arranged in such a nice way. It was obvious we hadstumbled on something important, and from that moment, I was hooked.</p><p>For another year we struggled to fit the rays into the onemathematical straight-jacket we could think of, but it just didn’t quitework. One day, I ran into Curt McMullen and mentioned to him what wewere playing with. ‘Real trace’, he pondered, ‘That’s the convex hullboundary’.’ And with that clue, we were off. What Curt had told us wasthat to understand the two dimensional pictures we had to look inthreedimensional non-Euclidean space, real Thurston stuff, as you mightsay. Finally we were able to verify at least most of the two Dave’sconjectures theoretically.</p></div><p>第一年充满了挫败感，我们盯着第 9章那样的图看了许久，却始终无法真正理解其中的奥秘。直到某天早上，我们中的一个人突然灵光一现。我们做了一些手工计算，结果看起来很有希望，于是就请Dave W. 帮我们画一张图，描绘我们所说的“真实迹线射线”（real tracerays）。他给我们画回来的，是本书最后一幅图的雏形——我们称之为“彩虹的尽头”。对我而言，那更像是“彩虹的起点”，是我数学生涯中一个具有决定性意义的时刻。那时我们完全是摸着黑前进，根本不知道这些射线意味着什么，但我们清楚它们绝不可能如此巧妙地排列在一起。这太不可思议了，我们知道自己撞上了某个重要的东西。就在那一刻，我被彻底吸引住了。</p><p>接下来的一年里，我们努力尝试将这些射线纳入我们所能想到的某种数学框架中，但始终无法完美契合。某天，我碰巧遇到CurtMcMullen，并向他提起我们正在研究的东西。“真实迹线？”他若有所思地说，“那是凸包的边界。”有了这个提示，我们一下子豁然开朗。Curt告诉我们，若想理解这些二维图像，我们需要在三维的非欧几里得空间中去观察——说得直白点，就是研究真正的Thurston 理论。从那以后，我们终于能够在理论上验证 Dave提出的两个猜想中的大部分内容了。</p><div class="statement simple plain unnumbered"><p>When the 19th century mathematician Mary Somerville received a letterinviting her to make a translation, with commentary, of Laplace’s greatbook Mécanique Céléste, she was so surprised she almost returned theletter thinking there must have been some mistake. I suppose I wasn’tquite so surprised to get a letter from David M. asking me to help themwrite about their pictures, but it wasn’t quite an everyday occurrenceeither. Although I may perhaps write another book, I am unlikely everagain to have the chance to work on one which will be so much troubleand so much fun.</p><p>And don’t think this book is the end of the story. If you flickthrough you will see cartoons of a rather portly character gluing uppieces of rubber into things like doughnuts. In fact all our presenttale revolves about ‘one-holed doughnuts with a puncture’. For the lastfew years, I have been trying to understand what happens when thedoughnuts acquire more holes. The main thing I can report is - it’s alot more complicated! But the same wonderful structures, yet moreintricate and inviting, are out there waiting to be tamed.</p><p>I would like to thank the EPSRC for the generous support of a SeniorResearch Fellowship, which has recently allowed me to devote much timeto both the mathematical and literary aspects of this challengingproject.</p></div><p>当当 19世纪的数学家玛丽·萨默维尔收到一封信，邀请她翻译并评论拉普拉斯的巨著《天体力学》时，她惊讶得几乎要退回信件，认为一定是出了什么差错。我想，我收到大卫·M.写信邀请我帮忙为他们的图片撰文时，虽说没有那么惊讶，但这绝非日常小事。尽管我或许还会写另一本书，但恐怕再也不会有机会参与一本既如此费神又如此有趣的书了。</p><p>不过别以为这本书就讲完了全部的故事。如果你随手翻一翻，会看到一位略显圆润的角色，正在把橡胶片粘成类似甜甜圈的东西。事实上，我们整个故事都围绕着“打了一个洞的单孔甜甜圈”展开。过去几年里，我一直在试图理解当甜甜圈获得更多洞时会发生什么。我目前唯一能汇报的是——事情会复杂得多！但同样奇妙的结构，更加错综复杂且引人入胜，依然在那里，等着我们去驾驭。</p><p>我衷心感谢英国工程与自然科学研究委员会（EPSRC）的慷慨资助，这使我近期能够投入大量时间，专注于这个充满挑战的项目中的数学与文学两个方面。</p><h2 id="读者指南">读者指南</h2><div class="statement simple plain unnumbered"><p>This is a book which can be read on many levels. Like mostmathematics books, it builds up in sequence, but the best way to read itmay be skipping around, first skimming through to look at the pictures,then dipping in to the text to get the gist and finally a return tounderstand some of the details. We have tried to make the first part ofeach chapter relatively simple, giving the essence of the ideas andpostponing the technicalities until later. The more technical parts ofthe discussion have been relegated to the Notes and can be skipped asdesired. Material important for later reference is displayed inBoxes.</p><p>The first two chapters, on Euclidean symmetries and complex numbersrespectively, contain material which may be partially familiar to manyreaders. We have aimed to present it in a form suited to our viewpoint,at the same time introducing as clearly as possible and withcomplementary graphics the mathematical terminology which will be usedthroughout the book. Chapter 3 introduces the basic double spiral maps,called Möbius symmetries, on which all of our later constructions rest.From then on, we build up ever more complicated ways in which a pair ofMöbius maps can interact, generating more and more convoluted andintricate fractals, until in Chapters 10 and 11 we actually reach thefrontiers of current research. The entire development is summarised inthe Road Map on the final page.</p></div><p>这是一本可以从多个层次阅读的书。像大多数数学书一样，它是按顺序逐步展开的，但最佳的阅读方式可能是跳跃式阅读：先快速浏览一遍，看一下插图，然后跳入文本抓住大意，最后再回头理解一些细节。我们尽力让每一章的前半部分相对简单，传达思想的精髓，技术性的内容则推迟到后面再讲。更为技术性的部分被放在了注释中，可以根据需要跳过。对以后参考很重要的内容会以框框的形式展示。</p><p>前两章分别讨论了欧几里得对称性和复数，内容对于许多读者来说可能部分熟悉。我们旨在以符合我们视角的形式呈现这些内容，同时尽可能清晰地引入并配以补充图形，介绍本书中将使用的数学术语。第三章介绍了基本的双螺旋映射，称为莫比乌斯对称性，所有后续构建都基于此。从这一章开始，我们逐步构建出越来越复杂的莫比乌斯映射对相互作用的方式，生成越来越复杂、精巧的分形，直到第十章和第十一章，我们实际上达到了当前研究的前沿。整个发展过程在最后一页的路线图中进行了总结。</p><div class="statement simple plain unnumbered"><p>Words which have a precise mathematical meaning are in bold face thefirst time they appear. We have not always spelled out the intricaciesof the precise mathematical definition, but we have also tried not tosay anything which is mathematically incorrect. We have used a smallamount of our own terminology, but in so far as possible have stuck tostandard usage. Non-professional readers will therefore have to forgiveus such terms as quasifuchsian and modular group, while readers with amathematical training should be able to follow what we mean.</p><p>The book is written as a guide to actually coding the algorithmswhich we have used to generate the figures. A vast set of furtherexplorations is possible for those readers who invest the time toprogram. This is prime hacking country! Because we hope for a widevariety of readers with many different platforms at their disposal, wehave sketched each step in ‘pseudo-code’, the universal programmingpidgin.</p></div><p>具有精确数学含义的数学术语在首次出现时以粗体显示。我们并不总是详细阐述这些数学定义的复杂性，但我们也尽量避免说出任何数学上不正确的内容。我们使用了一些自己的术语，但尽可能遵循标准用法。因此，非专业读者可能需要原谅我们使用诸如准富克斯群（quasifuchsian）和模群（modulargroup）等术语，而具有数学背景的读者应该能够理解我们的意思。</p><p>本书的目的是作为编写实际算法的指南，这些算法用于生成我们所展示的图形。对于那些愿意投入时间编程的读者来说，仍有大量的进一步探索空间。这是编程爱好者的天堂！由于我们希望能吸引各种平台上的读者，我们已经以“伪代码”形式勾画了每个步骤，这是编程的通用语言。</p><div class="statement simple plain unnumbered"><p>Inevitably we have suppressed a good deal of relevant mathematics andanyone wishing to pursue these ideas seriously will doubtless sooner orlater have to resort to more technical works. Actually there are no veryaccessible books about Kleinian group limit sets’, but there are plentyof texts which discuss the basics of symmetry and complex numbers. Somecomplex analysis books touch on Möbius maps and there is more in modernbooks on two-dimensional hyperbolic geometry. In the later part of thebook we have cited a rather random collection of recent research paperswhich have important bearing on our work. These are absolutely not meantto be exhaustive, but should serve to help professional readers findtheir way round the literature.</p><p>Finally our Projects need some comment. They can be ignored: wearen’t going to grade them or supply answers! Rather, we intend them as‘explorations’ to tempt you if you enjoy the material and want to takeit further. Some are fairly straightforward extensions or elucidationsof material in the text and some involve open-ended questions for whichthere is no definite answer. A few are definitely research problems.Others again explain details which are needed for full understanding orverification of the more technical points in our story. We have to leaveit to the reader to pick and choose which ones suit their taste andmathematical experience.</p></div><p>不可避免地，我们压缩了许多相关的数学内容，任何希望深入研究这些想法的人无疑迟早都需要参考更专业的著作。实际上，关于克莱因群极限集的可读性强的书籍并不多，但有许多书籍讨论了对称性和复数的基础知识。一些复分析的书籍会涉及莫比乌斯变换，现代的二维双曲几何书籍则有更多的相关内容。在本书后部分，我们列举了一些与我们工作密切相关的近期研究论文。这些引用绝不是详尽无遗的，但应该能够帮助专业读者在文献中找到方向。</p><p>最后，我们的项目需要做些说明。它们可以被忽略：我们不会给它们打分或提供答案！相反，我们将其作为“探索”，如果你喜欢这些内容并希望深入了解，它们将激发你的兴趣。有些项目是对书中材料的简单扩展或阐述，有些则是开放性问题，没有确切答案。少数是明确的研究问题。还有一些则是解释书中更技术性内容的细节，帮助理解或验证我们的故事中的关键点。我们只能留给读者自己选择，决定哪些项目适合他们的兴趣和数学经验。</p><h2 id="致谢">致谢</h2><div class="statement simple plain unnumbered"><p>We thank especially our cartoonist Larry Gonick for his uncannyability to translate a complicated three-dimensional manipulation intoan immediately evident cartoon. For historical background we areindebted to the St.&nbsp;Andrews History of Maths web site, tempered withmany erudite details and healthy doses of scholarly scepticism from ourfriends David Fowler and Paddy Patterson. (All remaining errors, are, ofcourse, our own.) Klein’s own book Entwicklung der Mathematikim 19.Jahrhundert has also been an important source. We have read the Hua-YenSutra in the translation The Flower Ornament Scripture by Thomas Cleary,Shambhala Publications, 1993, and quotations are reproduced here withthanks. We should like to thank the Mathematics Departments of Brown,Oklahoma State, Warwick, Harvard and Minnesota for their hospitality. Weshould like to thank the NSF through its grant to the Geometry Centerand EPSRC from their Public Understanding of Science budget forfinancial support. Finally we should like to thank our publisher DavidTranah of Cambridge University Press, without whose constant proddingand encouragement this book would almost certainly never have seen thelight of day.</p></div><p>我们特别感谢我们的漫画家 LarryGonick，他拥有将复杂的三维操作转化为一目了然的漫画的神奇能力。关于历史背景，我们要感谢圣安德鲁斯数学历史网站，并且我们特别感谢我们的朋友David Fowler 和 Paddy Patterson提供了许多博学的细节和健康的学术怀疑态度。（当然，所有剩余的错误都是我们自己的。）Klein的《19世纪数学发展》一书也是一个重要的参考来源。我们阅读了 Thomas Cleary翻译的《华严经》，由 Shambhala出版社于1993年出版，引用的内容在此谨表示感谢。我们还要感谢布朗大学、俄克拉荷马州立大学、沃里克大学、哈佛大学和明尼苏达大学的数学系对我们的热情接待。感谢美国国家科学基金会（NSF）通过其对几何中心的资助，以及英国工程与物理学研究委员会（EPSRC）从其公共科学传播预算中提供的资助。最后，我们要感谢剑桥大学出版社的出版人David Tranah，如果没有他不断的督促和鼓励，这本书几乎不可能问世。</p><h1 id="the-glowing-gasket">7 The glowing gasket</h1><figure id="fig-7.1"><img src="/images/indra/fig-7.1.jpg" class="fig" width="600" alt="Figure 7.1. The Apollonian gasket. The lacy web in the two pictures is the same: on the left, it is drawn in the complex plane and, on the right, on the sphere. As you might imagine, many people have tried calculating the Hausdorff dimension of the gasket. Curt McMullen has found the most accurate value, which is estimated as about 1.305688. 图 7.1. 阿波罗尼奥斯垫片。两幅图中的蕾丝网状结构是相同的：左边是在复平面上绘制的，右边是在球面上绘制的。你可能已经猜到，许多人都曾尝试计算该垫片的豪斯多夫维数。柯特·麦克马伦（Curt McMullen）给出了目前最精确的估计值，约为 1.305688。"><figcaption aria-hidden="true">Figure 7.1. The Apollonian gasket. Thelacy web in the two pictures is the same: on the left, it is drawn inthe complex plane and, on the right, on the sphere. As you mightimagine, many people have tried calculating the Hausdorff dimension ofthe gasket. Curt McMullen has found the most accurate value, which isestimated as about 1.305688.<br>图 7.1.阿波罗尼奥斯垫片。两幅图中的蕾丝网状结构是相同的：左边是在复平面上绘制的，右边是在球面上绘制的。你可能已经猜到，许多人都曾尝试计算该垫片的豪斯多夫维数。柯特·麦克马伦（CurtMcMullen）给出了目前最精确的估计值，约为 1.305688。</figcaption></figure><div class="statement simple plain unnumbered"><p>The lacy web in Figure 7.1 is called the Apollonian gasket. Usually,it is constructed by a simple geometric procedure, dating back to thosemost famous of geometers, the ancient Greeks. We shall start byexplaining the traditional construction, but as we shall discloseshortly, the gasket also represents another remarkable way in which theSchottky dust can congeal. The pictures you see here were actually alldrawn using a refinement of the DFS algorithm for tangent Schottkycircles.</p></div><p><a href="#fig-7.1">图 7.1</a>中的镂空结构被称为阿波罗尼奥斯分形。其构造基于一种简单的几何方法，可追溯至古希腊著名的几何学家。我们将首先解释传统的构造方法，但稍后也会揭示，这个分形结构同样展现了肖特基尘埃凝聚的另一种独特形式。此处所见的所有图像，实际上都是通过一种改进版的DFS 算法绘制的，该算法专门用于处理相切肖特基圆的情况。</p><div class="statement simple plain unnumbered"><p>The starting point of the traditional construction is a chain ofthree non-overlapping disks, each tangent to both of the others. Aregion between three tangent disks is a ‘triangle’ with circular arcsfor sides. This shape is often called an ideal triangle: the sides aretangent at each of the three vertices so the angle between them is zerodegrees.</p><p>The gasket is activated by the fact that in the middle of each idealtriangle there is always a unique ‘inscribed disk’ or incircle, tangentto the three outer circles. It is really better to think of the gasketas a construction on the sphere. Insides and outsides don’t matter anymore, so we may as well start with any three mutually tangent circles.You can see lots of disks and incircles in Figure 7.2.</p></div><p>传统构造的起点是三个互不重叠且两两相切的圆盘，呈链状排列。三个相切圆盘围成的区域，形状类似一个以圆弧为边的“三角形”。这种几何图形通常被称为理想三角形：由于其三条边在顶点处相切，因此每个顶点的夹角恰为零度。阿波罗尼奥斯垫片的构造正是由这一特性触发的：每个理想三角形的中心都有且仅有一个内切圆，它同时与这三个外接圆相切。更直观的理解方式是将这一构造置于球面上来考察。这样一来，“内外”之分已无意义，因此我们大可从任意三个两两相切的圆开始。在<a href="#fig-7.2">图 7.2</a>中，你会看到许多这样的圆盘及其内切圆结构。</p><figure id="fig-7.2"><img src="/images/indra/fig-7.2.jpg" class="fig" width="600" alt="Figure 7.2. Activating the gasket. On the top left, the three largest disks which activate the gasket are shown in blue. One of the three disks appears as the outer blue region which frames the picture, because it contains the point \infty, the North Pole on the Riemann sphere. On the top right, two of the disks are tangent at \infty, so that you see them in the picture as parallel blue strips. Removing the blue circles leaves two red ideal triangles. Inside each ideal triangle is an incircle, coloured yellow. Below, we see more levels of incircles. 图 7.2. 激活垫片。左上图中，标出的三个最大圆盘以蓝色呈现，正是它们激活了垫片。其中一个圆盘显示为环绕整幅图像的外部蓝色区域，这是因为它包含了点 \infty，即黎曼球面上的北极点。右上图中，其中两个圆盘在 \infty 处相切，因此在图中呈现为两条平行的蓝色带状区域。当我们移除这些蓝色圆盘后，图中便显现出两个红色的理想三角形。每个理想三角形内部都嵌有一个黄色内切圆。下方图示进一步展示了更深层次的内切圆结构。"><figcaption aria-hidden="true">Figure 7.2. Activating the gasket. On thetop left, the three largest disks which activate the gasket are shown inblue. One of the three disks appears as the outer blue region whichframes the picture, because it contains the point <span class="math inline">\(\infty\)</span>, the North Pole on the Riemannsphere. On the top right, two of the disks are tangent at <span class="math inline">\(\infty\)</span>, so that you see them in thepicture as parallel blue strips. Removing the blue circles leaves twored ideal triangles. Inside each ideal triangle is an incircle, colouredyellow. Below, we see more levels of incircles.<br>图 7.2.激活垫片。左上图中，标出的三个最大圆盘以蓝色呈现，正是它们激活了垫片。其中一个圆盘显示为环绕整幅图像的外部蓝色区域，这是因为它包含了点<span class="math inline">\(\infty\)</span>，即黎曼球面上的北极点。右上图中，其中两个圆盘在<span class="math inline">\(\infty\)</span>处相切，因此在图中呈现为两条平行的蓝色带状区域。当我们移除这些蓝色圆盘后，图中便显现出两个红色的理想三角形。每个理想三角形内部都嵌有一个黄色内切圆。下方图示进一步展示了更深层次的内切圆结构。</figcaption></figure><div class="statement simple plain unnumbered"><p>In the figure, we show two initial configurations of three tangentblue disks. When you take out the three blue disks you are left with twored ideal triangles. Each red ideal triangle has a yellow incircle. Seehow each yellow incircle divides the red triangle into three moretriangles.</p></div><p>在图中，我们展示了三个相切的蓝色圆盘的两种初始排布。当你移除这三个蓝色圆盘后，会留下两个红色的理想三角形。每个红色理想三角形各含一个黄色内切圆。仔细观察这些黄色的内切圆如何将红色三角形进一步分割为三个子三角形。</p><div class="statement simple plain unnumbered"><p>For repetitive people (a necessary quality in this subject, you mightsay), it is only natural to draw the incircles in these new triangles,resulting, of course, in even more triangles of the same kind. Thebottom frame shows this subdivision carried out twice more, with greenand then even smaller purple disks. In The Cat in the Hat Comes Back,’the cat takes off his hat to reveal Little Cat, who then removes his hatand releases Little Cat, who then uncovers Little Cat, and so on. Nowimagine there are not one but three new cats inside each cat’s hat. Thatgives a good impression of the explosive proliferation of these tinyideal triangles. Carry out this process to infinity, and Voom, theApollonian Gasket appears.</p></div><p>对于那些乐此不疲的人（或许正是研究这一主题的必备素质），在新三角形中继续绘制内切圆简直是顺理成章的事。这当然会催生出更多相似的三角形。下方的子图展示了这种细分过程再重复两次的结果——先是绿色圆盘，接着是更小的紫色圆盘，密密层层地堆叠起来。这让我想起《戴帽子的猫又来了》中的情节——大猫摘下帽子，露出一只小猫；小猫摘下自己的帽子，又冒出一只更小的小猫；接着更小的小猫再摘帽……如此反复，仿佛无穷无尽。现在，试着想象每顶帽子里不是藏着一只，而是三只小猫，那你就能体会这些微型理想三角形是如何爆炸式增长的了。让这一过程无限延续，砰——阿波罗尼奥斯分形便瞬间跃然眼前。</p><div class="statement simple plain unnumbered"><p>The Apollonian gasket is indeed very pretty, but the reason forintroducing it here is that, remarkably, it is also the limit set of aSchottky group made by pairing tangent circles. Exactly the sameintricate mathematical object can created by completely different means!You can see better how this works in the beautiful glowing version inFigure 7.3. The solid red circles in this picture are the initialSchottky circles in a very special configuration which we will look atclosely in the next section. The glowing yellow limit set can berecognized as the same as the Apollonian gasket of Figure 7.1. Thepicture was made by pairing four tangent circles arranged in theconfiguration shown in Figure 7.4. The four circles are tangent not onlyin a chain; there are also extra tangencies between <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span>, and between <span class="math inline">\(C_b\)</span> and <span class="math inline">\(C_B\)</span>.</p></div><p>阿波罗尼奥斯分形确实非常美丽，但我们在此介绍它的原因是：令人惊讶的是，它也是由切圆配对生成的肖特基群的极限集。这一精妙的数学对象，竟然能通过完全不同的方式构造出来！您可以通过<a href="#fig-7.3">图 7.3</a>中的荧光渲染图，看到这一过程是如何运作的。图中的实心红色圆环是以一种特殊配置排列的初始肖特基圆（具体分析请参见下一节），其荧黄色的极限集与<a href="#fig-7.1">图 7.1</a>中的阿波罗尼奥斯垫片完全一致。这幅图像是通过配对四个相切圆生成的，排列方式如<a href="#fig-7.4">图 7.4</a>所示：这些圆不仅形成了链式相切的关系，而且在 <span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span>、<span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 之间还存在额外的切点。</p><figure id="fig-7.3"><img src="/images/indra/fig-7.3.jpg" width="600" alt="Figure 7.3. (Overleaf.) The glowing gasket. This picture was created by applying the generating transformations a,A,b,B to the chain of four solid red disks bounding the black ideal triangles. At higher levels, the image circles tone from red to orange to yellow, through green to blue, finally cycling back to red. Don’t let the picture fool you - the red circles are not the circles which activate the gasket in the traditional construction. The ones which appear in the traditional construction are the ‘dual’ circles with the yellow glow. 图 7.3. 荧光垫片。此图像是通过对围绕黑色理想三角形的四个实心红色圆盘施加生成变换 a,A,b,B 而生成的。在更高的层级中，图像中的圆环色调从红色渐变为橙色、黄色，接着是绿色，再到蓝色，最终循环回红色。需要特别注意的是：图中的红色圆并非传统阿波罗尼奥斯构造中激活垫片的圆——在传统构造中，起激活作用的是发出黄色光辉的“对偶圆”。"><figcaption aria-hidden="true">Figure 7.3. (Overleaf.) The glowinggasket. This picture was created by applying the generatingtransformations <span class="math inline">\(a,A,b,B\)</span> to thechain of four solid red disks bounding the black ideal triangles. Athigher levels, the image circles tone from red to orange to yellow,through green to blue, finally cycling back to red. Don’t let thepicture fool you - the red circles are not the circles which activatethe gasket in the traditional construction. The ones which appear in thetraditional construction are the ‘dual’ circles with the yellowglow.<br>图 7.3.荧光垫片。此图像是通过对围绕黑色理想三角形的四个实心红色圆盘施加生成变换<span class="math inline">\(a,A,b,B\)</span>而生成的。在更高的层级中，图像中的圆环色调从红色渐变为橙色、黄色，接着是绿色，再到蓝色，最终循环回红色。需要特别注意的是：图中的红色圆并非传统阿波罗尼奥斯构造中激活垫片的圆——在传统构造中，起激活作用的是发出黄色光辉的“对偶圆”。</figcaption></figure><div class="statement simple plain unnumbered"><p>As you iterate the pairing transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, the extra tangency proliferates, withthe effect that inside each disk <span class="math inline">\(D\)</span>you see three further Schottky disks tangent to <span class="math inline">\(D\)</span> and each of the other two. In ourversion, the circles have been coloured depending on their level,starting with red at the first or lowest level, gradually changing toyellow, green and then blue. The small yellow and blue circles pile up,highlighting the limit set with a mysterious glow.</p></div><p>当你不断迭代配对变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>时，额外的切点会迅速增殖。几何上，这表现为：在每个圆盘 <span class="math inline">\(D\)</span>内部，都会涌现出三个新的肖特基子圆盘——它们不仅与 <span class="math inline">\(D\)</span>相切，而且两两之间也彼此相切。在我们的可视化方案中，圆盘根据迭代的层级依次着色——最底层从红色起步，逐步过渡到黄色、绿色、蓝色。随着黄色和蓝色的小圆盘层层堆叠，极限集被一圈神秘的光晕所笼罩，愈发清晰而引人入胜。</p><div class="statement simple plain unnumbered"><p>In this chapter, we shall be exploring various features of thegasket. Notwithstanding the extra tangency, it turns out that each limitpoint is still associated to exactly one or two infinite words in thegenerators <span class="math inline">\(a,b,A\)</span> and <span class="math inline">\(B\)</span>. You will be able to make your ownversion of the glowing gasket by running our DFS algorithm for the groupgenerated by the transformations <span class="math inline">\(a\)</span>and <span class="math inline">\(b\)</span>. The algorithm draws thiscomplicated lacework as a continuous curve, which is hard to imagineuntil you see it in progress on a computer screen. The curve snakes itsway through the gasket, apparently leaving one region for quite a whileuntil finally weaving its way back. Animation is the true reward ofsuccessfully implementing the program we have been learning tobuild.</p></div><p>在本章中，我们将深入探索垫片结构的各种特性。尽管存在额外的相切关系，但事实证明，每个极限点仍然对应于生成元<span class="math inline">\(a, b, A, B\)</span>所构成的一至两个无限字。通过运行我们为变换群 <span class="math inline">\(\langle a,b\rangle\)</span>特别设计的深度优先搜索（DFS）算法，你将能够制作出自己专属的发光垫片。该算法将这种复杂的镂空结构绘制成一条连续的曲线——这种奇妙的生成过程，唯有在计算机屏幕上亲眼目睹，方能真正感受到其变幻莫测之美。曲线如同灵蛇般在gasket中蜿蜒穿梭，仿佛要彻底离开某个区域，却又在某个时刻悄然折返。成功实现我们精心构建的程序后，最令人欣喜的收获正是这些跃然屏上的动态演绎。</p><div id="apollonius--circa-250-200-bc" class="statement sta_apollonius__circa_250_200_bc plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Apollonius, circa 250-200 BC</span>.</span><span class="statement-spah"> </span><br></p><p>Apollonius, known to his contemporaries as the Great Geometer, livedin Perga, now part of Turkey. One of the giants of Greek mathematics, hewas famed for his 8 volume treatise Conics which studied ellipses,hyperbolas and parabolas as sections of a cone by a plane at variousangles. His writings swiftly became standard texts in the ancient world.Many are now lost and we know them only through mention in othercommentaries, among them works on regular solids, irrational numbers,and approximations to <span class="math inline">\(\pi\)</span>. Ptolemycredits Apollonius with the theory of epicycles on which he based histheory of planetary motion.</p><p>One of Apollonius’ lost works is a book called Tangencies, reportedto provide methods of constructing circles tangent to various othercombinations of lines and circles, for example finding a circle tangentto two given lines and another circle. You can think of the problem offinding the incircle of an ideal triangle in this way. The mostdifficult problem, that of constructing the two circles tangent to threeother given disjoint circles, was probably not solved in ancient times,however Sir Isaac Newton wrote down a proof. According to Pappus,Tangencies gave a formula for the radius of the incircle to an idealtriangle in terms of the radii of the circles which bound its threesides. Be that as it may, exactly such a formula was described byDescartes in 1643, and a version was known in eighteenth century Japan.In fact this formula seems to have been rediscovered many times, mostrecently by Sir Frederick Soddy, in whose honour the incircles aresometimes known as Soddy circles. Awarded the Nobel prize in 1921, forthe discovery of isotopes, Soddy had a natural interest in how to packspherical atoms of differing size.</p><p>Soddy was so taken with the formula that he published it in theunusual form of a poem, which appeared in the journal Nature in 1936.The central part is contained in the middle verse quoted at the head ofthis chapter. For those who feel more comfortable with symbols, supposethe radii of the chain of three circles are <span class="math inline">\(a,b\)</span> and <span class="math inline">\(c\)</span>, and that the incircle has radius <span class="math inline">\(d\)</span>. Soddy’s formula is: <span class="math display">\[\left(\frac{1}{a}+\frac{1}{b}+\frac{1}{c}+\frac{1}{d}\right)^2=2\left(\frac{1}{a^2}+\frac{1}{b^2}+\frac{1}{c^2}+\frac{1}{d^2}\right).\]</span></p><p>阿波罗尼奥斯，被同时代人誉为伟大的几何学家，生活在佩尔加，即现今土耳其的一部分。作为希腊数学的巨擘之一，他因八卷本专著《圆锥曲线论》而闻名，该著作研究了椭圆、双曲线和抛物线作为平面以不同角度切割圆锥所得截面的性质。其著作迅速成为古代世界的标准教材。许多作品现已遗失，我们仅通过其他评论中的提及了解它们，其中包括关于正多面体、无理数及对<span class="math inline">\(\pi\)</span>的近似值的研究。托勒密将本轮理论归功于阿波罗尼奥斯，这一理论成为他行星运动学说的基础。</p><p>阿波罗尼奥斯遗失的著作之一名为《切触》，据记载，该书提供了构建与各种直线和圆组合相切的圆的方法，例如寻找与两条给定直线及另一个圆相切的圆。你可以将寻找理想三角形内切圆的问题视为此类问题。最难的难题，即构建与三个给定且互不相交的圆相切的两个圆，在古代可能并未解决，然而艾萨克·牛顿爵士记录了一个证明。根据帕普斯的说法，《切触》给出了一个公式，用于计算理想三角形内切圆的半径，该半径与限定其三条边的圆的半径有关。尽管如此，笛卡尔在1643 年确实描述了这样一个公式，且在 18世纪的日本也已知晓其版本。实际上，这个公式似乎被多次重新发现，最近一次是由弗雷德里克·索迪爵士完成的。为了纪念他，内切圆有时被称为索迪圆。索迪因发现同位素而于1921 年获得诺贝尔奖，他对如何排列不同大小的球形原子自然产生了兴趣。</p><p>索迪对这个公式深深着迷，以至于他以一首诗的形式将其发表，这首诗出现在1936年的《自然》杂志上。其核心部分包含在本章开头引用的中间诗句中。对于那些更偏好使用符号的读者，假设三个连锁圆的半径分别为<span class="math inline">\(a, b\)</span> 和 <span class="math inline">\(c\)</span>，内切圆的半径为 <span class="math inline">\(d\)</span>。索迪的公式为：</p><p><span class="math display">\[\left(\frac{1}{a}+\frac{1}{b}+\frac{1}{c}+\frac{1}{d}\right)^2=2\left(\frac{1}{a^2}+\frac{1}{b^2}+\frac{1}{c^2}+\frac{1}{d^2}\right).\]</span></p></div><h2 id="generating-the-gasket-生成垫片">Generating the gasket生成垫片</h2><div class="statement simple plain unnumbered"><p>The configuration of tangent circles which produced the gasket isshown in the right frame of Figure 7.4. The picture has been arranged sothat <span class="math inline">\(C_a\)</span> goes through <span class="math inline">\(\infty\)</span>, hence it appears in the figure asa straight line. In addition, <span class="math inline">\(C_A\)</span>and <span class="math inline">\(C_a\)</span> are tangent at 0 and <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> are tangent at <span class="math inline">\(-i\)</span>. You can see how this picture is madeby creating extra tangencies among a kissing chain of four circles bycomparing with the nearby arrangement of four circles in the left handframe.</p></div><p>生成垫片的相切圆配置如 <a href="#fig-7.4">图 7.4</a>右图所示。图中特意令圆 <span class="math inline">\(C_a\)</span> 经过<span class="math inline">\(\infty\)</span>，从而它在图中呈现为一条直线。此外，我们令圆<span class="math inline">\(C_A\)</span> 与 <span class="math inline">\(C_a\)</span> 在原点 0 处相切，圆 <span class="math inline">\(C_B\)</span> 与 <span class="math inline">\(C_b\)</span> 在<span class="math inline">\(-i\)</span>处相切。通过与左边图中四个圆的排列进行对比，可以清晰观察到右图通过在四圆相切链中引入额外切点形成的特殊结构。</p><figure id="fig-7.4"><img src="/images/indra/fig-7.4.jpg" class="fig" width="600" alt="Figure 7.4. The right frame shows the starting configuration of tangent Schottky circles which produces the glowing gasket. The red circles C_a and C_A are paired by the transformation a and the blue circles C_B and C_b by b. Using notation from the last chapter, the tangency points P,Q,R and S are at 1,-1,-0.2-0.4i and 0.2-0.4i respectively. On the left is a nearby Schottky configuration of circles which are not quite tangent and a and b are loxodromic. This is similar to the configuration shown in frame (vi) of Figure 6.10. The centre frame is an intermediate stage where a is parabolic but b is not. 图 7.4. 右图展示了生成发光垫片的相切 Schottky 圆的初始配置。红色圆 C_a 与 C_A 通过变换 a 配对，蓝色圆 C_B 与 C_b 通过变换 b 配对。根据前一章的记号，切点 P, Q, R, S 分别位于坐标 1, -1, -0.2-0.4i 和 0.2-0.4i 处。左图展示了一个相似的 Schottky 圆配置，其中圆未完全相切，且变换 a 和 b 均为斜航的。该配置与 图 6.10 (vi) 中的结构相似。中间图呈现了过渡状态，其中变换 a 是抛物线型的，而 b 不是。"><figcaption aria-hidden="true">Figure 7.4. The right frame shows thestarting configuration of tangent Schottky circles which produces theglowing gasket. The red circles <span class="math inline">\(C_a\)</span>and <span class="math inline">\(C_A\)</span> are paired by thetransformation <span class="math inline">\(a\)</span> and the bluecircles <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> by <span class="math inline">\(b\)</span>. Using notation from the last chapter,the tangency points <span class="math inline">\(P,Q,R\)</span> and <span class="math inline">\(S\)</span> are at <span class="math inline">\(1,-1,-0.2-0.4i\)</span> and <span class="math inline">\(0.2-0.4i\)</span> respectively. On the left is anearby Schottky configuration of circles which are not quite tangent and<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are loxodromic. This is similar to theconfiguration shown in frame (vi) of Figure 6.10. The centre frame is anintermediate stage where <span class="math inline">\(a\)</span> isparabolic but <span class="math inline">\(b\)</span> is not.<br>图 7.4. 右图展示了生成发光垫片的相切 Schottky 圆的初始配置。红色圆 <span class="math inline">\(C_a\)</span> 与 <span class="math inline">\(C_A\)</span> 通过变换 <span class="math inline">\(a\)</span> 配对，蓝色圆 <span class="math inline">\(C_B\)</span> 与 <span class="math inline">\(C_b\)</span> 通过变换 <span class="math inline">\(b\)</span> 配对。根据前一章的记号，切点 <span class="math inline">\(P, Q, R, S\)</span> 分别位于坐标 <span class="math inline">\(1, -1, -0.2-0.4i\)</span> 和 <span class="math inline">\(0.2-0.4i\)</span> 处。左图展示了一个相似的Schottky 圆配置，其中圆未完全相切，且变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 均为斜航的。该配置与 <a href="#fig-6.10">图 6.10</a> (vi)中的结构相似。中间图呈现了过渡状态，其中变换 <span class="math inline">\(a\)</span> 是抛物线型的，而 <span class="math inline">\(b\)</span> 不是。</figcaption></figure><div class="statement simple plain unnumbered"><p>The generating matrices for the gasket are quite simple: <span class="math display">\[a=\begin{pmatrix}1&amp;0\\-2i&amp;1\end{pmatrix}\quad\text{and}\quadb=\begin{pmatrix}1-i&amp;1\\1&amp;1+i\end{pmatrix}.\]</span></p><p>We shall have more to say about how we arrived at these particularformulas later on. Note that <span class="math inline">\(\mathop{\mathrm{Tr}}{a}=\mathop{\mathrm{Tr}}{b}=2\)</span>,so <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are parabolic. Looking at thearrangement of Schottky circles in Figure 7.4, you see the fixed pointof <span class="math inline">\(a\)</span> is 0, the tangency point ofthe circles <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span>. In Figure 7.3, you can see twochains of tangent circles nesting down on 0 from above and below. Thesame phenomenon occurs at <span class="math inline">\(-i\)</span>, thetangency point of <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> and the fixed point of <span class="math inline">\(b\)</span>. Notwithstanding extra tangencies, thegenerators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> still pair opposite circles in theinitial tangent chain <span class="math inline">\(C_a,C_b,C_A\)</span>and <span class="math inline">\(C_B\)</span>. This means that fornesting circles we still need the commutator condition <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB}=2\)</span>, which isnot hard to check.</p></div><p>生成该垫片的矩阵非常简单：</p><p><span class="math display">\[a=\begin{pmatrix}1&amp;0\\-2i&amp;1\end{pmatrix}\quad\text{and}\quadb=\begin{pmatrix}1-i&amp;1\\1&amp;1+i\end{pmatrix}.\]</span></p><p>关于这两个特定的矩阵，我们稍后会详细解释它们的推导过程。值得注意的是，由于<span class="math inline">\(\mathop{\mathrm{Tr}}{a}=\mathop{\mathrm{Tr}}{b}=2\)</span>，因此<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 都是抛物型变换。观察 <a href="#fig-7.4">图 7.4</a> 中 Schottky 圆的排列，可以发现 <span class="math inline">\(a\)</span> 的不动点是原点 0，即圆 <span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span> 的切点。在 <a href="#fig-7.3">图7.3</a> 中，你可以看到两条相切的圆链从上下两侧分别向 0点逐渐嵌套收缩。相同的现象也出现在 <span class="math inline">\(-i\)</span> 处，这既是圆 <span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 的切点，也是变换 <span class="math inline">\(b\)</span> 的不动点。尽管存在额外的切点，生成元<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 依然将初始的相切链 <span class="math inline">\(C_a,C_b,C_A,C_B\)</span>中的圆配对。这意味着要实现圆链的无穷嵌套，我们仍需满足交换子条件 <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB}=2\)</span>，而这一迹值条件并不难验证。</p><div class="statement simple plain unnumbered"><p>We have been speaking as if there is only one Apollonian gasket, butcould we not get different gaskets by starting with different tangentchains? Not really, because it turns out that any chain of three tangentcircles can be conjugated to any other three. As you can work out inProject 7.1, this stems from the fact that there is always a Möbius mapcarrying any three points to any other three. Since the gasket isactivated by its initial ideal triangle, and since the procedure at eachstep consists in adding incircles, a Möbius map which conjugates oneideal triangle to another carries the whole gasket along in itswake.</p><p>This explains why it makes sense to talk about the Apollonian gasket,because up to conjugation by Möbius maps there is really only one.</p></div><p>我们此前的讨论似乎一直都默认了阿波罗尼奥斯垫片是独一无二的，但如果我们从不同的初始相切圆链出发，难道不会得到不同的垫片吗？答案是否定的。事实上，任何由三个相切圆组成的链，都可以通过某个莫比乌斯变换转化为另一组（事先给定的）相切圆链。如<a href="#proj-7.1">项目 7.1</a>中的推导所示，这一结论的根本原因在于：在复平面上，任意三个不同点总能通过某个莫比乌斯变换映射到任意其它三点。由于垫片的构造源于其初始理想三角形，而每一步的操作都是添加内切圆，因此将一个理想三角形共轭到另一个理想三角形的莫比乌斯变换，会将整个垫片一同带动并映射过去。</p><p>这就解释了为什么谈论“阿波罗尼奥斯垫片”是有意义的，因为在莫比乌斯变换的共轭意义下，归根结底，阿波罗尼奥斯垫片只有一个。</p><figure id="fig-7.5"><img src="/images/indra/fig-7.5.jpg" width="600" alt="Figure 7.5. The strip gasket. This shows the gasket as it appears when we conjugate so that the extra tangency point of C_b and C_B is at \infty. Any parabolic with a fixed point at \infty is a Euclidean translation, in this case b(z)=z+2, which explains the translational symmetry along the infinite strip. 图 7.5. 带状垫片。图中展示了当我们进行共轭变换，使得 C_b 和 C_B 的额外切点位于 \infty 处时，垫片的样貌。任何以 \infty 为不动点的抛物型变换都是欧几里得平移，在本例中为 b(z)=z+2，这解释了沿着无限带的平移对称性。"><figcaption aria-hidden="true">Figure 7.5. The strip gasket. This showsthe gasket as it appears when we conjugate so that the extra tangencypoint of <span class="math inline">\(C_b\)</span> and <span class="math inline">\(C_B\)</span> is at <span class="math inline">\(\infty\)</span>. Any parabolic with a fixed pointat <span class="math inline">\(\infty\)</span> is a Euclideantranslation, in this case <span class="math inline">\(b(z)=z+2\)</span>,which explains the translational symmetry along the infinitestrip.<br>图 7.5. 带状垫片。图中展示了当我们进行共轭变换，使得 <span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 的额外切点位于 <span class="math inline">\(\infty\)</span> 处时，垫片的样貌。任何以 <span class="math inline">\(\infty\)</span>为不动点的抛物型变换都是欧几里得平移，在本例中为 <span class="math inline">\(b(z)=z+2\)</span>，这解释了沿着无限带的平移对称性。</figcaption></figure><p>另一个著名的垫片版本可以在 <a href="#fig-7.5">图 7.5</a>中看到。为了得到这个，我们进行了共轭，使得 <span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span> 在 0 处相切，因此它们是垂直线。映射<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 现在在 <span class="math inline">\(0\)</span> 处有一个固定点。该群的生成元为：</p><p><span class="math display">\[a=\begin{pmatrix}2&amp;-i\\-i&amp;0\end{pmatrix}\quad\text{and}\quadb=\begin{pmatrix}1&amp;2\\0&amp;1\end{pmatrix}.\]</span></p><h2 id="pinching-tiles">Pinching tiles</h2><figure id="fig-7.6"><img src="/images/indra/fig-7.6.jpg" width="600" alt="Figure 7.6. Dr.&nbsp;Stickler meets Apollonius. Placing Dr.&nbsp;Stickler in the Apollonian gasket, we let the group of symmetries carry him around. He appears exactly in those disks which were pink in Figure 7.4. If we had started him off in a white one, his images would fill the white disks instead. The symmetry a is parabolic and on both sides of its fixed point 0, circles of Sticklers are streaming out. A startling feature is the circle of Sticklers streaming out from and into 1. Every alternate Stickler is standing on his head! The upright Sticklers are just powers of abAB (which fixes 1) applied to the Stickler standing on the right hand horizontal axis, while the upside down ones are the images of this same Stickler under (abAB)^nA. 图 7.6. Stickler 博士邂逅阿波罗尼奥斯分形。我们将 Stickler 博士置于阿波罗尼奥斯垫片中，然后让对称群带他四处转转。结果，他恰好出现在 图 7.4 里那些粉红色的圆盘中。若是他最初出现在某个白色圆盘中，那么他的身影就会填满所有的白色圆盘。对称 a 是抛物型的，在它的不动点 0 的两侧，成群的 Stickler 博士正沿着圆圈向外扩散。最令人惊奇的是，在坐标 1 附近，竟然出现了一圈 Stickler 博士首尾相连、双向流动的奇妙图案。更绝的是，相邻的 Stickler 博士还头朝上、头朝下交替出现。那些站得笔直的 Stickler 博士，是通过不断对右侧水平轴上那位 Stickler 施加变换 (abAB)^n（该变换以 1 为不动点）得到的。而那些倒立的 Stickler 博士，则是这位 Stickler 在变换 (abAB)^nA 作用下的映射结果。"><figcaption aria-hidden="true">Figure 7.6. Dr.&nbsp;Stickler meetsApollonius. Placing Dr.&nbsp;Stickler in the Apollonian gasket, we let thegroup of symmetries carry him around. He appears exactly in those diskswhich were pink in Figure 7.4. If we had started him off in a white one,his images would fill the white disks instead. The symmetry <span class="math inline">\(a\)</span> is parabolic and on both sides of itsfixed point 0, circles of Sticklers are streaming out. A startlingfeature is the circle of Sticklers streaming out from and into 1. Everyalternate Stickler is standing on his head! The upright Sticklers arejust powers of <span class="math inline">\(abAB\)</span> (which fixes 1)applied to the Stickler standing on the right hand horizontal axis,while the upside down ones are the images of this same Stickler under<span class="math inline">\((abAB)^nA\)</span>.<br>图 7.6. Stickler 博士邂逅阿波罗尼奥斯分形。我们将 Stickler博士置于阿波罗尼奥斯垫片中，然后让对称群带他四处转转。结果，他恰好出现在<a href="#fig-7.4">图 7.4</a>里那些粉红色的圆盘中。若是他最初出现在某个白色圆盘中，那么他的身影就会填满所有的白色圆盘。对称<span class="math inline">\(a\)</span> 是抛物型的，在它的不动点 0的两侧，成群的 Stickler 博士正沿着圆圈向外扩散。最令人惊奇的是，在坐标 1附近，竟然出现了一圈 Stickler博士首尾相连、双向流动的奇妙图案。更绝的是，相邻的 Stickler博士还头朝上、头朝下交替出现。那些站得笔直的 Stickler博士，是通过不断对右侧水平轴上那位 Stickler 施加变换 <span class="math inline">\((abAB)^n\)</span>（该变换以 1为不动点）得到的。而那些倒立的 Stickler 博士，则是这位 Stickler 在变换<span class="math inline">\((abAB)^nA\)</span>作用下的映射结果。</figcaption></figure><div class="statement simple plain unnumbered"><p>Figure 7.6 is a wonderful picture of what happened when we introducedDr.&nbsp;Stickler to Apollonius! It is a pretty intricate arrangement, solet’s take a bit of time understanding what has happened to the tiles.To get a grasp on the situation, look back at the three pictures inFigure 7.4, and watch the progression across the three frames. On theleft the limit set is a loop or quasicircle, so the ordinary set - whatis left when you take away the limit set - has two parts, a pink insideand a white outside. In the central picture, the pink part has collapsedinto a myriad of tangent disks, and the red Schottky circles <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span> touch at 0. On the right, the gasketgroup, the ‘horns’ of the pink region have also come together, causingthe white outside to fracture into disks as well. Notice how the memoryof which was inside and which was outside still persists, because whatwere the ‘inside’ disks are pink while the ‘outside’ ones are white.</p></div><p><a href="#fig-7.6">图 7.6</a> 是一幅精彩的画面，生动展现了当我们邀请Stickler博士探索阿波罗尼奥斯分形时所发生的奇妙事情！图中的结构相当复杂，因此我们不妨花些时间，仔细剖析图案的变化。要理解这一过程，不妨回顾<a href="#fig-7.4">图 7.4</a>的三幅子图，并观察这三帧之间的演变：左图中的极限集是一个回路或拟圆，因此普通集（即去掉极限集后剩下的部分）分为粉色的内部和白色的外部。中间的图中，粉色区域已收缩成无数相切的圆盘，而红色的肖特基圆<span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span> 在 0处相切。右图则展示了垫片群，其中粉色区域的“触角”也汇聚在一起，使得白色外部区域也裂解成圆盘。令人惊奇的是，尽管整体结构支离破碎，内外区域仍清晰保留着原始的记忆——曾经“内部”的圆盘依旧是粉色，而“外部”的圆盘依旧是白色。</p><div class="statement simple plain unnumbered"><p>In each picture, the initial Schottky circles are blue and red. Watchthem to follow the fate of the tiles. On the left, as usual for akissing Schottky group, they surround the central inner four sided tile.If we transported this tile around by the group, we would see atessellation　of the pink region similar to the one in Figure 6.6.(There is also an outer tile, the region outside the four Schottkycircles, which as usual you can see more clearly by imagining it on theRiemann sphere.) The inner and outer parts of the ordinary set areinvariant under the group, so if you apply any transformation of thegroup to any tile in the pink region ‘inside’ the limit set, you getanother tile which is also ‘inside’.</p></div><p>在每幅图中，最初的 Schottky圆分别是蓝色和红色。仔细观察它们的变化，有助于追踪瓷砖的去向。在左图中，和典型的“亲吻”Schottky群一样，这些圆环绕着中央的四边形瓷砖。如果我们将这块瓷砖沿着群的变换移动开来，就会在粉色区域中形成类似于<a href="#fig-6.6">图 6.6</a>的镶嵌图案（此外，还有一个外部瓷砖，即位于四个 Schottky圆之外的区域，通常，通过在黎曼球面上想象它的位置，可以更清楚地看到它的轮廓）。普通集的内部和外部在群作用下各自保持不变，因此，如果对极限集“内部”粉色区域中的某块瓷砖施加群中的某个变换，得到的仍会是另一块位于“内部”的瓷砖。</p><div class="statement simple plain unnumbered"><p>In the central picture, where <span class="math inline">\(a\)</span>has become parabolic, the inner tile has been pinched into two halves.Each half-tile is an ideal triangle, with two red sides and one blue.You should think of this pair of triangles as one composite two-parttile. Moved around by the group, the composite tile will cover all thepink circles. There is an outer tile in this picture too, which (on theRiemann sphere) remains in one piece.</p><p>On the right, in the gasket group, both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> have been pinched so that now <span class="math inline">\(C_b\)</span> and <span class="math inline">\(C_B\)</span> also tuch at <span class="math inline">\(-i\)</span>. Now there are four basic half-tiles.The two pink ones will produce a tiling of the pink circles and thewhite ones will make a tiling of the white circles. In the glowinggasket picture, these four tiles are black. The upper two ‘horizontal’ideal triangles are the remnants of the inner Schottky tile, while thelower ‘vertical’ triangle is a remnant of the outer one. If you lookcarefully, you can just see its twin peeping out in the bottom centre ofthe page.</p></div><p>在中央的图片中，<span class="math inline">\(a\)</span>已变成了抛物型，内部的瓷砖被挤压成了两半。每个半瓷砖都是一个理想三角形，带有两条红边和一条蓝边。你可以把这对三角形视作一个由两部分组成的复合瓷砖。通过群的作用，这个复合瓷砖将覆盖所有的粉色圆盘。图中还有一个外部瓷砖，它在黎曼球面上依然保持完整。</p><p>在右侧的垫片图中，<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 都被挤压变形，使得 <span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 现在也在 <span class="math inline">\(-i\)</span>处相切。此时出现了四个基本的半瓷砖。两块粉色的会铺满粉色圆盘，而两块白色的则会铺满白色圆盘。在那幅发光的垫片图中，这四块瓷砖都呈现为黑色。上方的两个“水平”理想三角形是内部Schottky瓷砖的残迹，而下方的“垂直”三角形则是外部瓷砖的残迹。仔细观察，你会在页面底部中央隐约发现它的孪生兄弟正悄悄探出头来。</p><div class="statement simple plain unnumbered"><p>Now we can go back to the picture of Dr.&nbsp;Stickler meeting Apollonius.The party is taking place in the remnants of the ‘pink’ circles. If youcompare with the half-tiles in Figure 7.4, something rather odd hashappened to Dr.&nbsp;Stickler - when the original tile split in two, his headended up in the green half-tile and his feet in the blue one.Fortunately, there is a transformation of the group (namely <span class="math inline">\(B\)</span>) which carries the blue Stickler to thegreen one, moving the blue half-tile containing the blue feet to theyellow half-tile containing the green feet. Had we not pointed out hisdifficulties you might not even have noticed that anything was wrong.After gluing the yellow half-tile to the green halftile, the relieved(but still slightly greenish) Dr.&nbsp;Stickler stands reunited in a new andcomplete tile whose images under the group map to all the Sticklers inthe picture.</p></div><p>现在我们可以回到 Stickler博士与阿波罗尼奥斯相遇的画面。聚会正在“粉色”圆圈的残迹中举行。对照 <a href="#fig-7.4">图 7.4</a> 中的半瓷砖，你会发现 Stickler博士身上发生了一件相当奇怪的事——当原始瓷砖裂成两半时，原始瓷砖裂成两半时，他的头跑到了绿色半瓷砖里，而他的脚却留在了蓝色半瓷砖上。幸好，群中有一个变换（即<span class="math inline">\(B\)</span>）可以将蓝色的 Stickler 带到绿色Stickler的位置，把装着蓝色脚丫的蓝色半瓷砖挪到装着绿色脚丫的黄色半瓷砖上。要不是我们特意指出这种窘况，你可能根本没发现哪里不对劲。等到黄色半瓷砖和绿色半瓷砖粘合完毕，那位如释重负（却仍然带着一丝“绿意”）的Stickler博士终于又完整地站在了一块崭新的瓷砖上。通过群的映射，这块瓷砖的影像铺展开来，构成了画面中所有Stickler 博士的身影。</p><h2 id="and-pinching-surfaces">And pinching surfaces</h2><div class="statement simple plain unnumbered"><p>What happened to the tiles in the last section, has, of course, alsoan interpretation in terms of surfaces. Looking back to the picture onp.&nbsp;190 which showed how tiles were glued up in a kissing Schottky group,we can work out what happens when we bring the four circles together tomake the gasket. It takes a bit of stretching and squeezing to do this,which we have illustrated in Figure 7.7.</p><p>The result, shown in the last panel, is our old friend the pretzelwith three circles pinched to points or cusps: the waist as in the lastchapter and, in addition, loops around the top and bottom tori. Both topand bottom are now ‘spheres’ with three cusps or punctures each. Onepair of cusps on each sphere are joined together like ‘horns’, and thesetwo ‘horned spheres’ are themselves joined together at the last twocusps.</p></div><p>上一节中瓷砖的演变过程，当然也可以从曲面角度得到诠释。回顾第 190页展示的亲吻 Schottky群的基本域粘合过程的示意图，我们可以推导出当将四个圆粘合为垫片群时会发生什么。这一过程需要一些拉伸和压缩，我们在<a href="#fig-7.7" title="图 7.7">图 7.7</a> 中进行了直观展示。</p><p>最终结果呈现于最后一幅示意图中，正是我们熟悉的三叶椒盐脆饼造型——三个圆周被压缩为尖点（cusp）：其中一个是上一章提到的“腰部”尖点，另外两个则是围绕顶部和底部的环面。此时，顶部与底部都变成了各自有三个尖点（或称穿孔）的”球面”。每个球面上的一对尖点像”犄角”一样连接在一起，而这两个“带角球面”则通过它们剩下的两个尖点相互连接。</p><div class="statement simple plain unnumbered"><p>The gasket group is called doubly cusped because we have pinched twoextra loops, <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. It is also sometimes called maximallycusped, because, after all this squeezing, there are no more curves leftto pinch. In Chapter 9, we shall see that you can make many variants ofthe gasket group by imposing more complicated relationships between thecurves we choose to pinch on the top and bottom halves of the pinchedpretzel.</p></div><p>垫片群被称为双尖群，因为我们挤压了两个额外的环路 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>。它也常被称为“极大尖群”，因为经过这般操作后，已不存在可供进一步挤压的曲线。在第九章中我们将看到，通过在挤压后的椒盐卷曲曲面（pretzel）的上下半部之间，对选定挤压曲线施加更复杂的关联约束，可以构造出多种垫片群的变体。</p><div id="fig-7.7" class="statement simple plain unnumbered"><p>Figure 7.7. Pinching curves. How gluing up the gasket configurationof tangent circles leads to a pair of triply-punctured spheres. The<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> curves we have to shrink are are marked<span class="math inline">\(L\)</span> and <span class="math inline">\(M\)</span>. Instead of pulling the upper and lowerpartially glued-up cylinders logether right away, as we did in Figure6.16, it now takes some effort first to twist them relative to eachother in such a way that when we glue-up, the dotted loops are in theirproper position ready to be shrunk.</p><p>图 7.7.捏合曲线。如何通过粘合垫片的切圆得到一对带有三穿孔球面。需要收缩的 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 曲线分别标记为 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span>。与 <a href="#fig-6.16">图 6.16</a>中直接粘合上下圆柱体的操作不同，此时需要先使两者相对扭转，确保粘合时虚线环处于正确位置以便后续收缩。</p><figure><img src="/images/indra/fig-7.7-1.jpg" width="200" alt="BEGIN WITH A PLANE WITH FOUR HOLES, EACH OF WHICH JUST TOUCHES THREE OTHERS, WHAT HAPPENS WHEN WE GLUE A TO a (THE SMALL ONE) AND B TO b? 从一个带有四个孔的平面开始，每个孔都与另外三个孔相切。当我们将 A 粘合到 a（较小的孔），并将 B 粘合到 b 时，会发生什么？"><figcaption aria-hidden="true">BEGIN WITH A PLANE WITH FOUR HOLES, EACHOF WHICH JUST TOUCHES THREE OTHERS, WHAT HAPPENS WHEN WE GLUE <span class="math inline">\(A\)</span> TO <span class="math inline">\(a\)</span> (THE SMALL ONE) AND <span class="math inline">\(B\)</span> TO <span class="math inline">\(b\)</span>?<br>从一个带有四个孔的平面开始，每个孔都与另外三个孔相切。当我们将 <span class="math inline">\(A\)</span> 粘合到 <span class="math inline">\(a\)</span>（较小的孔），并将 <span class="math inline">\(B\)</span> 粘合到 <span class="math inline">\(b\)</span> 时，会发生什么？</figcaption></figure><figure><img src="/images/indra/fig-7.7-2.jpg" width="200" alt="FIRST PULL a AWAY FROM A AND B AWAY FROM b ALONG THE ARCS L AND M. HOW WE SEE A DISTORTED BUT FAMILIAR PICTURE: ABab. 首先，沿弧线 L 将 a 从 A 处拉开，沿弧线 M 将 B 从 b 处拉开。此时会呈现一个扭曲但熟悉的图案：ABab。"><figcaption aria-hidden="true">FIRST PULL a AWAY FROM A AND B AWAY FROMb ALONG THE ARCS <span class="math inline">\(L\)</span> AND <span class="math inline">\(M\)</span>. HOW WE SEE A DISTORTED BUT FAMILIARPICTURE: <span class="math inline">\(ABab\)</span>.<br>首先，沿弧线 <span class="math inline">\(L\)</span> 将 <span class="math inline">\(a\)</span> 从 <span class="math inline">\(A\)</span> 处拉开，沿弧线 <span class="math inline">\(M\)</span> 将 <span class="math inline">\(B\)</span> 从 <span class="math inline">\(b\)</span>处拉开。此时会呈现一个扭曲但熟悉的图案：<span class="math inline">\(ABab\)</span>。</figcaption></figure><figure><img src="/images/indra/fig-7.7-3.jpg" width="200" alt="ADO THE POINT AT INFINITY TO WRAP UP THE PLANE. 通过添加无穷远点使平面闭合。"><figcaption aria-hidden="true">ADO THE POINT AT INFINITY TO WRAP UP THEPLANE.<br>通过添加无穷远点使平面闭合。</figcaption></figure><figure><img src="/images/indra/fig-7.7-4.jpg" width="200" alt="STRETCH TO MAKE THIS FAMILIAR SURFACE. NOTE ARCS L AND M. 拉伸形成我们熟悉的曲面。注意观察弧线 L 和 M。"><figcaption aria-hidden="true">STRETCH TO MAKE THIS FAMILIAR SURFACE.NOTE ARCS <span class="math inline">\(L\)</span> AND <span class="math inline">\(M\)</span>.<br>拉伸形成我们熟悉的曲面。注意观察弧线 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span>。</figcaption></figure><figure><img src="/images/indra/fig-7.7-5.jpg" width="200" alt="NOW SOMETHING STRANGE: PULL TOGETHER THE TOP HALVES OF A AND a AND THE BOTTOM HALVES OF B AND b. 进行奇怪的操作：将 A 和 a 的上半部分、B 和 b 的下半部分别拉到一起。"><figcaption aria-hidden="true">NOW SOMETHING STRANGE: PULL TOGETHER THETOP HALVES OF <span class="math inline">\(A\)</span> AND <span class="math inline">\(a\)</span> AND THE BOTTOM HALVES OF <span class="math inline">\(B\)</span> AND <span class="math inline">\(b\)</span>.<br>进行奇怪的操作：将 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(a\)</span> 的上半部分、<span class="math inline">\(B\)</span> 和 <span class="math inline">\(b\)</span> 的下半部分别拉到一起。</figcaption></figure><figure><img src="/images/indra/fig-7.7-6.jpg" width="200" alt="GUE TOP OF A TO TOP of a, BOTTOM OF B TO BOTTOM OF b. 将 A 的顶部和 a 的顶部粘在一起，将 B 的底部和 b 的底部粘在一起。"><figcaption aria-hidden="true">GUE TOP OF <span class="math inline">\(A\)</span> TO TOP of <span class="math inline">\(a\)</span>, BOTTOM OF <span class="math inline">\(B\)</span> TO BOTTOM OF <span class="math inline">\(b\)</span>.<br>将 <span class="math inline">\(A\)</span> 的顶部和 <span class="math inline">\(a\)</span> 的顶部粘在一起，将 <span class="math inline">\(B\)</span> 的底部和 <span class="math inline">\(b\)</span> 的底部粘在一起。</figcaption></figure><figure><img src="/images/indra/fig-7.7-7.jpg" width="200" alt="NOW JOIN THE REST OF A TO a ANP B TO b. 继续完成 A 与 a、B 与 b 剩余部分的粘合。"><figcaption aria-hidden="true">NOW JOIN THE REST OF <span class="math inline">\(A\)</span> TO <span class="math inline">\(a\)</span> ANP <span class="math inline">\(B\)</span> TO <span class="math inline">\(b\)</span>.<br>继续完成 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(a\)</span>、<span class="math inline">\(B\)</span>与 <span class="math inline">\(b\)</span> 剩余部分的粘合。</figcaption></figure><figure><img src="/images/indra/fig-7.7-8.jpg" width="200" alt="FINALLY, SHORTEN THE ARCS L AND M … 最终收缩弧线 L 和 M …"><figcaption aria-hidden="true">FINALLY, SHORTEN THE ARCS <span class="math inline">\(L\)</span> AND <span class="math inline">\(M\)</span> …<br>最终收缩弧线 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span> …</figcaption></figure><figure><img src="/images/indra/fig-7.7-9.jpg" width="200" alt="UNTIL EACH ARC SHRINKS TO A POINT, MAKING TWO TRIPLY-PUNCTURED SPHERES. 直至每个弧线都坍缩为一点，形成两个三穿孔球面。"><figcaption aria-hidden="true">UNTIL EACH ARC SHRINKS TO A POINT, MAKINGTWO TRIPLY-PUNCTURED SPHERES.<br>直至每个弧线都坍缩为一点，形成两个三穿孔球面。</figcaption></figure></div><h2 id="tiling-the-inner-disks">Tiling the inner disks</h2><div class="statement simple plain unnumbered"><p>Figure 7.6 is made up of lots of disks full of Dr.&nbsp;Sticklers, eachtiled by ideal triangles shown in grey. These disks are the remnants ofthe pink region in Figure 7.4. For most of the rest of this chapter, weshall be occupied with the tiling of just one of these disks. The sametiling fills out the insides of each of the glowing circles in Figure7.3. The group of symmetries which goes with this very special disktessellation is called the modular group and has been the well-spring ofa huge body of mathematics.</p></div><p><a href="#fig-7.6">图 7.6</a> 由无数布满 Sticklers博士身影的圆盘构成，每个圆盘都被灰色的理想三角形所镶嵌。这些圆盘正是 <a href="#fig-7.4">图 7.4</a>中粉色区域的遗迹。在本章接下来的大部分篇幅里，我们将专注于研究其中一个圆盘的密铺结构。同样的密铺图案也出现在<a href="#fig-7.3">图 7.3</a>中每个发光圆圈的内部。这种独特的圆盘镶嵌的对称群称为模群，它一直是众多数学成果的源泉。</p><div class="statement simple plain unnumbered"><p>Since the tiling in each disk is the same, we may as well focus onthe large disk through -1 and 0, shown in yellow in Figure 7.8. Tounderstand how these ideal triangle tiles cover the yellow disk we needto find the subgroup of all the transformations in the gasket groupwhich map the inside of this disk to itself. This subgroup (which is ofcourse also a group in its own right), or any of its conjugates, is whatwe call the modular group. The basic tile is made up of two idealtriangles, the ones coloured green and yellow in Figure 7.6. The twotriangles together form one of our familiar four-sided pinched-off tileswith four circular arc sides. Moved around by the modular group, theytile the whole yellow disk.</p></div><p>由于每个圆盘中的密铺方式相同，我们可以将注意力集中在通过 -1 和 0的大圆盘上，这在 <a href="#fig-7.8">图 7.8</a>中以黄色部分表示。为了理解这些理想三角形如何覆盖黄色圆盘，我们需要找出垫片群中所有将圆盘内部映射到自身的变换子群。这个子群（显然，它本身也是一个群），或者它的任何共轭子群，便是我们所称的模群。基本的瓷砖由两个理想三角形组成，即<a href="#fig-7.6">图 7.6</a>中绿色和黄色的三角形。这两个三角形合在一起，构成了我们熟悉的四边弧形瓷砖。通过模群的作用，它们密铺了整个黄色圆盘。</p><figure id="fig-7.8"><img src="/images/indra/fig-7.8.jpg" width="600" alt="Figure 7.8. The set-up of tangent circles for the modular subgroup. The left frame is just to get oriented. The red circles C_A and C_a, together with the level 2 green circles B(C_a)=C_{Ba} and B(C_A)=C_{BA} form the boundary of the new four-sided tile. The arrows show how a pairs C_A to C_a and b pairs C_B to C_b. The boundary of the yellow disk is the limit set of the modular group generated by a and BAb. 图 7.8. 模群的切线圆配置。左侧子图仅用于帮助定位。红色圆圈 C_A 和 C_a，以及二级绿色圆圈 B(C_a)=C_{Ba} 和 B(C_A)=C_{BA} 共同构成了新四边形瓷砖的边界。箭头指示了变换 a 如何将 C_A 和 C_a 配对，变换 b 如何将 C_B 和 C_b 配对。黄色圆盘的边界是由 a 和 BAb 生成的模群的极限集。"><figcaption aria-hidden="true">Figure 7.8. The set-up of tangent circlesfor the modular subgroup. The left frame is just to get oriented. Thered circles <span class="math inline">\(C_A\)</span> and <span class="math inline">\(C_a\)</span>, together with the level 2 greencircles <span class="math inline">\(B(C_a)=C_{Ba}\)</span> and <span class="math inline">\(B(C_A)=C_{BA}\)</span> form the boundary of thenew four-sided tile. The arrows show how <span class="math inline">\(a\)</span> pairs <span class="math inline">\(C_A\)</span> to <span class="math inline">\(C_a\)</span> and <span class="math inline">\(b\)</span> pairs <span class="math inline">\(C_B\)</span> to <span class="math inline">\(C_b\)</span>. The boundary of the yellow disk isthe limit set of the modular group generated by <span class="math inline">\(a\)</span> and <span class="math inline">\(BAb\)</span>.<br>图 7.8. 模群的切线圆配置。左侧子图仅用于帮助定位。红色圆圈 <span class="math inline">\(C_A\)</span> 和 <span class="math inline">\(C_a\)</span>，以及二级绿色圆圈 <span class="math inline">\(B(C_a)=C_{Ba}\)</span> 和 <span class="math inline">\(B(C_A)=C_{BA}\)</span>共同构成了新四边形瓷砖的边界。箭头指示了变换 <span class="math inline">\(a\)</span> 如何将 <span class="math inline">\(C_A\)</span> 和 <span class="math inline">\(C_a\)</span> 配对，变换 <span class="math inline">\(b\)</span> 如何将 <span class="math inline">\(C_B\)</span> 和 <span class="math inline">\(C_b\)</span> 配对。黄色圆盘的边界是由 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(BAb\)</span> 生成的模群的极限集。</figcaption></figure><div class="statement simple plain unnumbered"><p>We worked out the labels of the boundary circles <span class="math inline">\(C_a, C_A, C_{BA}\)</span> and <span class="math inline">\(C_{Ba}\)</span> in Figure 7.8 of the four-sidedtile by going to part of the level-two Schottky chain for the gasketgroup. (You may find it easiest to check the arrangement in a picturelike the left frame of Figure 7.4 without all the extra gaskettangencies first.) Notice the four tangency points of these circles areall on the boundary of the yellow disk. As you can see, the four circlesform a new chain of tangent circles. As usual, <span class="math inline">\(a\)</span> pairs <span class="math inline">\(C_A\)</span> to <span class="math inline">\(C_a\)</span>. In addition, <span class="math inline">\(BAb\)</span> pairs <span class="math inline">\(C_{Ba}\)</span> to <span class="math inline">\(C_{BA}\)</span> because:</p><p><span class="math display">\[BAb\left(C_{Ba}\right) =BAb\left(B\left(C_a\right)\right) = BA\left(C_a\right) =B\left(C_A\right) = C_{BA}.\]</span></p><p>Inside the gasket group we have found another mini-chain of fourtangent circles, together with a pair of transformations which matchthem together in pairs!</p></div><p>我们通过研究垫片群的二级 Schottky 链的局部结构，确定了 <a href="#fig-7.8">图 7.8</a> 中四边形瓷砖的边界圆 <span class="math inline">\(C_a,C_A,C_{BA}\)</span> 和 <span class="math inline">\(C_{Ba}\)</span> 的标签。（建议首先参考 <a href="#fig-7.4">图 7.4</a>左图中圆的排列，暂时忽略所有额外的垫片切点，会更容易理解）。值得注意的是，这些圆的四个切点全部位于黄色圆盘的边界上。正如你所见，这四个圆形成了一个新的切圆链。按照惯例，变换<span class="math inline">\(a\)</span> 将圆 <span class="math inline">\(C_A\)</span> 和 <span class="math inline">\(C_a\)</span> 配对。此外，变换 <span class="math inline">\(BAb\)</span> 将圆 <span class="math inline">\(C_{Ba}\)</span> 和 <span class="math inline">\(C_{BA}\)</span> 配对，原因如下： <span class="math display">\[BAb\left(C_{Ba}\right) =BAb\left(B\left(C_a\right)\right) = BA\left(C_a\right) =B\left(C_A\right) = C_{BA}.\]</span>在垫片群中，我们发现了一个由四个相切圆组成的迷你链，以及一对将它们成对匹配的变换！</p><div class="statement simple plain unnumbered"><p>This construction shows that the modular group is a new kind of‘necklace group’, made by disregarding all the rest of the gasket andlooking only at the disks produced by acting with <span class="math inline">\(a\)</span> and <span class="math inline">\(BAb\)</span> on the four circles which bound thenew tile. The new group is generated by the transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(BAb\)</span>. Indeed in Figure 7.3, you canactually pick out chains of image disks nicely shrinking down onto theglowing limit circle through -1 and 0 . The only difference from thekissing Schottky groups we met in the last chapter is that the twogenerators pair not opposite circles but adjacent ones. As we shallexplain in more detail on p.&nbsp;213 ff., the image circles shrink because<span class="math inline">\(a,BAb\)</span> and their product <span class="math inline">\(aBAb\)</span> are all parabolic.</p></div><p>这一构造表明，模群是一种新型的“项链群”，它是通过忽略垫片的其余部分，仅关注由变换<span class="math inline">\(a\)</span> 和 <span class="math inline">\(BAb\)</span>作用于新瓷砖边界的四个圆所产生的圆盘而形成的。这个新群由变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(BAb\)</span> 生成。实际上，在 <a href="#fig-7.3">图 7.3</a>中，你可以清晰地看到一串映像圆盘，它们逐渐缩小并收敛到经过点 -1 和 0的发光极限圆上。这与上一章讨论的“接吻式 Schottky群”的唯一关键时，这两个生成元配对的不是相对的圆，而是相邻的圆。正如我们将在第213 页及以后章节中详细解释的那样，这些映像圆之所以缩小，是因为 <span class="math inline">\(a,BAb\)</span> 以及它们的乘积 <span class="math inline">\(aBAb\)</span> 都是抛物型变换。</p><div class="statement simple plain unnumbered"><p>The same pattern of pairing circles is repeated all over the gasket.Every pink disk is the image of the yellow one under some element in thegasket group, which conjugates our modular group to another ‘modulargroup’ acting in the new disk. The white disks are different from thepink ones, because you can never get from pink to white usingtransformations in the gasket group. However you can still find a chainof four tangent circles matched in the same pattern, as described in <a href="#proj-7.4">Project 7.4</a>.</p></div><p>在垫片的每一个局部区域，都能观察到完全相同的圆配对模式。每个粉色圆盘均可视为黄色圆盘经垫片群中某个变换作用后的像——这个变换元素会将我们原本的模群共轭到一个新的”模群”，而新模群将作用在对应的粉色圆盘上。白色圆盘与粉色圆盘存在本质区别：垫片群中的任意变换都无法将粉色圆盘映射为白色圆盘。不过，我们仍能找到四个相切圆构成的配对链，其模式与前文所述完全一致（具体构造方法详见项目7.4）。</p><div class="statement simple plain unnumbered"><p>You might well imagine that we should be set to repeat everything wedid in the last chapter. By taking four tangent circles and pairing themin this new pattern we should presumably get a whole new lot ofquasifuchsian groups. Not so! It turns out that the rigours imposed byspecifying that the two generators and their product are all parabolicactually ‘freeze’ the group. Without any mention of circle chains, weprove in Note 7.1 the remarkable fact that all groups made with pairingconditions like this are, up to conjugation, ‘the same’. What this meansin more detail is this. Suppose that <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are any two parabolic Möbiustransformations with the property that <span class="math inline">\(UV\)</span> is also parabolic, and such that thefixed points <span class="math inline">\({\rm Fix}\,U\)</span> and <span class="math inline">\({\rm Fix}\,V\)</span> of <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are not the same. Then there is alwaysa conjugating map <span class="math inline">\(M\)</span> such that:<span class="math display">\[MUM^{-1} = \begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix}, \quadMVM^{-1} = \begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}.\]</span> This explains why there are so many circles in the gasketgroup, and why you get an identical tiling pattern in each one.</p></div><p>你或许会认为我们需要完全重复上一章的研究过程。通过选取四个相切圆并采用这种新配对模式，我们理应会得到一大堆新的拟富克斯群。然而事实并非如此！事实证明，要求两个生成元及其乘积均为抛物型变换的刚性条件，实质上”冻结”了群的结构。我们在注记7.1中不涉及任何圆链概念，证明了如下引人注目的结论：所有满足此类配对条件的群在共轭意义下都是”相同”的。具体而言，设<span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 是任意两个抛物型莫比乌斯变换，满足<span class="math inline">\(UV\)</span> 仍为抛物型，且两者的不动点 ${},U$与 <span class="math inline">\({\rm Fix}\,V\)</span>$互异，则必存在共轭变换 <span class="math inline">\(M\)</span> 使得：</p><p><span class="math display">\[MUM^{-1} = \begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix}, \quadMVM^{-1} = \begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}.\]</span>这解释了垫片群中为什么有如此多的圆圈，以及每个圆内部都会呈现完全相同的密铺图案。</p><div id="note-7-1--uniqueness-of-the-modular-group" class="statement sta_note_7_1__uniqueness_of_the_modular_group definition unnumbered"><p><span class="statement-heading"><span class="statement-label">Note7.1: Uniqueness of the modular group</span>：</span><span class="statement-spah"> </span><br></p><p><strong>注 7.1：模群的唯一性</strong></p><p>Suppose that <span class="math inline">\(U\)</span>, <span class="math inline">\(V\)</span> and <span class="math inline">\(UV\)</span> are all parabolic (and therefore notthe identity!) and the fixed point of <span class="math inline">\(U\)</span> is <span class="math inline">\(z_U\)</span> and the fixed point of <span class="math inline">\(V\)</span> is <span class="math inline">\(z_V\)</span>. We are trying to conjugate <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> to the generators of the modular group.We have seen that we can find a Möbius transformation <span class="math inline">\(M\)</span> that maps <span class="math inline">\(z_U\)</span> to <span class="math inline">\(0\)</span> and <span class="math inline">\(z_V\)</span> to <span class="math inline">\(\infty\)</span>. Conjugating our originaltransformations <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> by <span class="math inline">\(M\)</span> arranges that <span class="math inline">\(MUM^{-1}(0) = 0\)</span> and <span class="math inline">\(MVM^{-1}(\infty) = \infty\)</span>, and still thetwo transformations <span class="math inline">\(MUM^{-1}\)</span> and<span class="math inline">\(MVM^{-1}\)</span> are parabolic. Since wecan simultaneously conjugate them in this way, we may just as wellassume the original transformations <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> have fixed points <span class="math inline">\(0\)</span> and <span class="math inline">\(\infty\)</span>, respectively.</p><p>A parabolic transformation that fixes <span class="math inline">\(\infty\)</span> is always conjugate to any other,up to a minus sign. (See Chapter 3.) Let’s arrange by conjugation andpossibly multiplying by -1 that <span class="math inline">\(V\)</span>corresponds to the matrix <span class="math inline">\(\begin{pmatrix} 1&amp; 2 \\ 0 &amp; 1 \end{pmatrix}\)</span>.　Now all that’s left is<span class="math inline">\(U\)</span>. Since <span class="math inline">\(U(0)=0\)</span>, after again possibly multiplyingby -1, we can conclude that the matrix of <span class="math inline">\(U\)</span> is <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix}\]</span> for some number <span class="math inline">\(x\)</span>.</p><p>That brings us to the last hypothesis that <span class="math inline">\(UV\)</span> is parabolic. Let’s multiply thisout:</p><p><span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix} \begin{pmatrix} 1&amp; 2 \\ 0 &amp; 1 \end{pmatrix} = \begin{pmatrix} 1 &amp; 2 \\ x&amp; 1+2x \end{pmatrix}.\]</span></p><p>The trace of <span class="math inline">\(UV\)</span> under theseassumptions is <span class="math inline">\(2 + 2x\)</span>. This is<span class="math inline">\(\pm 2\)</span> for precisely two values of<span class="math inline">\(x\)</span>, namely, <span class="math inline">\(x = -2\)</span> and <span class="math inline">\(x= 0\)</span>. In the latter case, <span class="math inline">\(U\)</span>is the identity, which we are definitely excluding. That means <span class="math inline">\(x = -2\)</span>, and we have shown that <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are simultaneously conjugate to <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix} \text{ and }\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}.\]</span> (We may have to multiply one or both matrices by -1 to arrangethat they both have trace 2.)</p><p>假设 <span class="math inline">\(U\)</span>, <span class="math inline">\(V\)</span> 和 <span class="math inline">\(UV\)</span>均为抛物型变换（因此不是恒等变换！），且 <span class="math inline">\(U\)</span> 的不动点是 <span class="math inline">\(z_U\)</span>，<span class="math inline">\(V\)</span> 的不动点是 <span class="math inline">\(z_V\)</span>。我们的目标是将 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span>共轭变换为模群的生成元。我们已经看到，可以找到一个莫比乌斯变换 <span class="math inline">\(M\)</span>，它将 <span class="math inline">\(z_U\)</span> 映射到 <span class="math inline">\(0\)</span>，<span class="math inline">\(z_V\)</span> 映射到 <span class="math inline">\(\infty\)</span>。通过 <span class="math inline">\(M\)</span> 对原变换 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 进行共轭后，新变换 <span class="math inline">\(MUM^{-1}\)</span> 将保持 0 不变，<span class="math inline">\(MVM^{-1}\)</span> 将保持 <span class="math inline">\(\infty\)</span>不变，且两者仍为抛物型变换。既然这种共轭可同步完成，我们不妨直接假设原变换<span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 的不动点分别是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>。</p><p>固定 <span class="math inline">\(\infty\)</span>的抛物型变换在相差一个符号的意义下彼此共轭（参见第3章）。通过适当共轭及可能的符号调整，可以使<span class="math inline">\(V\)</span> 对应于矩阵 <span class="math inline">\(\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1\end{pmatrix}\)</span>。此时仅需确定 <span class="math inline">\(U\)</span> 的形式。由于 <span class="math inline">\(U(0) = 0\)</span>，经可能的符号调整后，<span class="math inline">\(U\)</span> 的矩阵必为： <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix}\quad(x\in\mathbb{C}).\]</span> 接下来验证 <span class="math inline">\(UV\)</span>的抛物型条件。计算其乘积：</p><p><span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix} \begin{pmatrix} 1&amp; 2 \\ 0 &amp; 1 \end{pmatrix} = \begin{pmatrix} 1 &amp; 2 \\ x&amp; 1+2x \end{pmatrix}.\]</span> 此时 <span class="math inline">\(UV\)</span> 的迹是 <span class="math inline">\(2 + 2x\)</span>。抛物型变换的迹需满足 <span class="math inline">\(|\mathop{\mathrm{Tr}}|=2\)</span>，这恰好对 <span class="math inline">\(x\)</span> 的两个值成立，即 <span class="math inline">\(x = -2\)</span> 和 <span class="math inline">\(x =0\)</span>。当 <span class="math inline">\(x=0\)</span> 时，<span class="math inline">\(U\)</span> 退化为恒等变换（已排除），因此必有<span class="math inline">\(x=−2\)</span>。由此可知 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 可共轭于矩阵：</p><p><span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix} \text{ and }\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}\]</span></p><p>（必要时可对其中一个或两个矩阵取负，以确保其迹均为 2）</p></div><h2 id="the-modular-group-of-arithmetic">The modular group ofarithmetic</h2><div class="statement simple plain unnumbered"><p>The result just discussed shows that the modular group is conjugateto a very famous group of great importance in number theory. It is madeby arranging the four Schottky circles with their tangency points at<span class="math inline">\(-1,0,1\)</span> and <span class="math inline">\(\infty\)</span>. You can see these, coloured redand green, in the left frame of Figure 7.9. Since one of the tangencypoints is the point at infinity, two of the circles show up as greenvertical lines. These green lines are paired by <span class="math inline">\(b=\begin{pmatrix}1&amp;2\\0&amp;1\end{pmatrix}\)</span>,while the two red circles tangent at 0 are paired by <span class="math inline">\(a=\begin{pmatrix}1&amp;0\\-2&amp;1\end{pmatrix}\)</span>.Notice how <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> match adjacent circles in the chain inexactly the pattern of the red and green arrows in Figure 7.8. In fact,as you can easily calculate, <span class="math inline">\(ab\)</span> isthe parabolic transformation <span class="math inline">\(\begin{pmatrix}1&amp;2\\-2&amp;-3\end{pmatrix}\)</span>.</p></div><p>刚刚讨论的结果表明，模群与一个在数论中极为著名且重要的群是共轭的。这个群是通过排列四个肖特基圆生成的，其切点分别位于<span class="math inline">\(-1, 0, 1\)</span> 和 <span class="math inline">\(\infty\)</span>。在 <a href="#fig-7.9">图 7.9</a>的左图中，这些圆分别以红绿两色呈现。由于其中一个切点是无穷远点，因此有两个圆在图中呈现为绿色的垂直直线。这两条绿色直线由变换<span class="math inline">\(b=\begin{pmatrix}1&amp;2\\0&amp;1\end{pmatrix}\)</span>配对，而在原点 0 处相切的两个红色圆则通过变换 <span class="math inline">\(a=\begin{pmatrix}1&amp;0\\-2&amp;1\end{pmatrix}\)</span>配对。请注意，变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 对相邻圆的配对方式，恰好与 <a href="#fig-7.8">图 7.8</a>中红绿箭头所示的模式完全一致。事实上，通过简单的计算即可验证，<span class="math inline">\(ab\)</span> 是抛物型变换 <span class="math inline">\(\begin{pmatrix}1&amp;2\\-2&amp;-3\end{pmatrix}\)</span>。</p><figure id="fig-7.9"><img src="/images/indra/fig-7.9.jpg" width="600" alt="Figure 7.9. The modular tessellation of the upper half plane. The left frame shows the tiling or tessellation of the upper half plane by ideal triangles belonging to the smaller modular group coming from pairing tangent circles, while the right frame shows the richer tessellation associated to the full modular group with its added symmetries. Each tile on the left is subdivided into twelve tiles on the right. 图 7.9. 上半平面的模群密铺。左图展示了通过配对相切圆生成的子模群对应的理想三角形密铺结构；右图则展示具有完整模群对称性的更加精细的密铺。左侧的每个瓷砖在右侧被细分为十二个小瓷砖。"><figcaption aria-hidden="true">Figure 7.9. The modular tessellation ofthe upper half plane. The left frame shows the tiling or tessellation ofthe upper half plane by ideal triangles belonging to the smaller modulargroup coming from pairing tangent circles, while the right frame showsthe richer tessellation associated to the full modular group with itsadded symmetries. Each tile on the left is subdivided into twelve tileson the right.<br>图 7.9.上半平面的模群密铺。左图展示了通过配对相切圆生成的子模群对应的理想三角形密铺结构；右图则展示具有完整模群对称性的更加精细的密铺。左侧的每个瓷砖在右侧被细分为十二个小瓷砖。</figcaption></figure><div class="statement simple plain unnumbered"><p>It is no coincidence that the entries of these three matrices areintegers. The right frame of Figure 7.9 is a more complicated picturewhich shows all the symmetries of the tiling on the left. Each idealtriangle has been subdivided into three hatched and three unhatchedsub-triangles. (The sub-triangles are not quite ideal, because only oneof their angles is 0 .) The group of symmetries of this more complicatedtiling is, from the point of view of Möbius maps, the simplest group ofall: just the set of all <span class="math inline">\(2\times 2\)</span>matrices <span class="math inline">\(\begin{pmatrix}p&amp;q\\r&amp;s\end{pmatrix}\)</span>with integer entries <span class="math inline">\(p,q,r\)</span> and<span class="math inline">\(s\)</span> and determinant <span class="math inline">\(ps-qr\)</span> equal to 1. To distinguish from thegroup of the left frame, we sometimes call it the full modular group.The matrices in the (smaller) modular group of the left picture are justthose matrices with integer entries for which <span class="math inline">\(q\)</span> and <span class="math inline">\(r\)</span> are even and <span class="math inline">\(p\)</span> and <span class="math inline">\(s\)</span> are odd.</p></div><p>这三个矩阵的元素都是整数，此现象绝非偶然。<a href="#fig-7.9">图7.9</a>右侧的复杂图像完整呈现了左侧密铺图案的所有对称性。每个理想三角形都被剖分为三个阴影子三角形和三个非阴影子三角形。（这些子三角形并不完全是理想的，因为它们只有一个角为0）。从莫比乌斯变换的角度来看，这个更复杂的密铺结构的对称群是最简单的：即所有元素为整数且行列式<span class="math inline">\(ps-qr\)</span> 等于 1 的 <span class="math inline">\(2\times2\)</span> 矩阵 <span class="math inline">\(\begin{pmatrix}p&amp;q\\r&amp;s\end{pmatrix}\)</span>构成的集合。为了与左图的对称群区分开来，该群常被称为全模群。而左侧密铺对应的（较小）模群则由满足特殊同余条件的整数矩阵构成——其<span class="math inline">\(q\)</span> 与 <span class="math inline">\(r\)</span> 元素都是偶数，<span class="math inline">\(p\)</span> 与 <span class="math inline">\(s\)</span> 元素都是奇数。</p><div class="statement simple plain unnumbered"><p>There is a very beautiful connection between the modular tessellationand fractions: the points where the ideal triangles meet the real axisare exactly the rational numbers. Although it is something of adigression here, we want to take the time to explain the pattern, whichturns out to be indispensible when we come to map making in Chapter9.</p></div><p>模镶嵌与有理数之间有着极为精妙的联系：理想三角形与实轴交点恰恰是有理数。虽然这一内容在此略显偏离主题，但我们希望花些时间来阐明这个规律，因为它在第9 章的制图过程中将变得至关重要。</p><figure id="fig-7.10"><img src="/images/indra/fig-7.10.jpg" width="600" alt="Figure 7.10. The modular tiling from our ancestral home. The tessellation generated by the full modular group, conjugated over to the unit disk. This beautiful rendition is Figure 35 in Vol. 1 of Vorlesungen äber elliptischen Modulfunctionen by Klein and Fricke. 图 7.10. 来自我们祖居的模密铺。由完整模群生成的镶嵌图案，经共轭映射到单位圆盘上。这幅美丽的图像是克莱因和弗里克所著《椭圆模函数讲义》第一卷中的图 35。"><figcaption aria-hidden="true">Figure 7.10. The modular tiling from ourancestral home. The tessellation generated by the full modular group,conjugated over to the unit disk. This beautiful rendition is Figure 35in Vol. 1 of Vorlesungen äber elliptischen Modulfunctionen by Klein andFricke.<br>图 7.10.来自我们祖居的模密铺。由完整模群生成的镶嵌图案，经共轭映射到单位圆盘上。这幅美丽的图像是克莱因和弗里克所著《椭圆模函数讲义》第一卷中的图35。</figcaption></figure><div class="statement simple plain unnumbered"><p>Figure 7.11 shows the first few levels in the modular tessellation.The basic tile is the four-sided region, called an ideal quadrilateral,which was bounded by the coloured lines in Figure 7.9. Images of thisideal quadrilateral are shown bounded by solid arcs. The dotted arcsdivide them into the two ideal triangles which we saw, half hatched andhalf white, on the left in Figure 7.9. As the group acts on the basictile, we get more and more smaller and smaller tiles nesting down to thereal axis. The vertices of all these tiles meet the real axis in pointswhich are all fractions. Several things can be read off from a carefulexamination of this intricate pattern:</p><ul><li>All vertices of the tiles are rational numbers <span class="math inline">\(p/q\)</span>.</li><li>If <span class="math inline">\(r/s\)</span> and <span class="math inline">\(p/q\)</span> are two vertices of the same tile,then <span class="math inline">\(ps - rq = \pm 1\)</span>.</li><li>If <span class="math inline">\(r/s &lt; p/q\)</span> are the outertwo vertices of a tile, then the third vertex between them is <span class="math inline">\((r + p)/(s + q)\)</span>.</li></ul><p>Check this out! For instance, between <span class="math inline">\(2/3\)</span> and <span class="math inline">\(1/2\)</span>, we get <span class="math inline">\((2 + 1)/(3 + 2)\)</span>, that is <span class="math inline">\(3/5\)</span>.</p></div><p><a href="#fig-7.11">图 7.11</a>展示了模镶嵌的前几个层级。基本瓷砖是一个四边形，称为理想四边形，它由 <a href="#fig-7.9">图 7.9</a>中的彩色线条围成。实线弧显示了这个理想四边形的图像，而虚线弧将其分割成两个理想三角形，这两个三角形可以在<a href="#fig-7.9">图 7.9</a>的左侧看到，一半是阴影，一半是空白。随着群对基本瓷砖的作用，我们得到越来越多、越来越小的瓷砖，逐层嵌套，直至延伸到实轴。所有这些瓷砖的顶点都与实轴相交，这些交点都是分数。仔细观察这个复杂的图案，我们可以得出以下几个结论：</p><ul><li>所有瓷砖的顶点都是有理数 <span class="math inline">\(p/q\)</span>。</li><li>如果 <span class="math inline">\(r/s\)</span> 和 <span class="math inline">\(p/q\)</span> 是同一瓷砖的两个顶点，则 <span class="math inline">\(ps - rq = \pm 1\)</span>。</li><li>如果 <span class="math inline">\(r/s &lt; p/q\)</span>是同一瓷砖的两个外顶点，那么它们之间的第三个顶点是 <span class="math inline">\((r + p)/(s + q)\)</span>。</li></ul><p>验证一下吧！比如，在 <span class="math inline">\(2/3\)</span> 和<span class="math inline">\(1/2\)</span> 之间，我们得到 <span class="math inline">\((2 + 1)/(3 + 2)\)</span>，即 <span class="math inline">\(3/5\)</span>。</p><div class="statement simple plain unnumbered"><p>It’s easy to see why this happens. As we have seen, a typical matrixin the modular group will look like</p><p><span class="math display">\[M = \begin{pmatrix} p &amp; q \\ r &amp;s \end{pmatrix}\]</span></p><p>where <span class="math inline">\(p, q, r\)</span> and <span class="math inline">\(s\)</span> are integers and <span class="math inline">\(ps - rq = 1\)</span>. If <span class="math inline">\(M\)</span> acts on the vertices of the initialtriangle with vertices <span class="math inline">\(0 = 0/1, 1 =1/1\)</span> and <span class="math inline">\(\infty = 1/0\)</span>, thenwe get the new triangle with vertices <span class="math inline">\(M(0) =r/s, M(\infty) = p/q\)</span> and <span class="math inline">\(M(1) = (p+ r)/(q + s)\)</span>. Assuming all four entries are positive, we have<span class="math inline">\(r/s &lt; (p + r)/(q + s) &lt; p/q\)</span>(you can see this by multiplying out). This is just what we found inFigure 7.11. If <span class="math inline">\(p, q, r, s\)</span> are notall positive, there are half a dozen other cases in which the order ofthe points <span class="math inline">\(M(0), M(1)\)</span> and <span class="math inline">\(M(\infty)\)</span> is different but we get thesame result. The same thing happens if we start from the other triangle<span class="math inline">\(M(-1), M(0), M(\infty)\)</span>.</p></div><p>这个现象不难理解。我们知道，模群中的一个典型矩阵可以表示为 <span class="math display">\[M = \begin{pmatrix} p &amp; q \\ r &amp; s\end{pmatrix},\]</span> 其中 <span class="math inline">\(p, q,r\)</span> 和 <span class="math inline">\(s\)</span> 是整数，且满足<span class="math inline">\(ps - rq = 1\)</span>。如果矩阵 <span class="math inline">\(M\)</span>作用于初始三角形的顶点，该初始三角形的顶点分别是 <span class="math inline">\(0 = 0/1, 1 = 1/1\)</span> 和 <span class="math inline">\(\infty =1/0\)</span>，那么变换后的新三角形的顶点将变成 <span class="math inline">\(M(0) = r/s, M(\infty) = p/q\)</span> 和 <span class="math inline">\(M(1) = (p + r)/(q + s)\)</span>。假设 <span class="math inline">\(p,q,r,s\)</span> 都是正数，我们可以验证不等式<span class="math inline">\(r/s &lt; (p + r)/(q + s) &lt; p/q\)</span>成立（通过乘法可轻松验证）。这正是 <a href="#fig-7.11">图 7.11</a>所示的情况。如果 <span class="math inline">\(p, q, r, s\)</span>并非全为正数，还有几种不同的情形，此时点 <span class="math inline">\(M(0), M(1), M(\infty)\)</span>的顺序可能会改变，但结果仍然一致。类似地，若从另一个三角形 <span class="math inline">\(M(-1), M(0), M(\infty)\)</span>出发，也会得到相同的结论。</p><div class="statement simple plain unnumbered"><p>Any two fractions <span class="math inline">\(r/s\)</span> and <span class="math inline">\(p/q\)</span> such that <span class="math inline">\(ps - qr = \pm 1\)</span> are called neighbours.Thus any two vertices of an ideal triangle in the modular tessellationare neighbours. If <span class="math inline">\(p/q\)</span> is afraction, then, as we explain in Project 7.5, the process of finding itsneighbours is essentially Euclid’s two thousand year old algorithm forfinding the highest common factor of two numbers, surely one of the mostuseful and clever algorithms of all time. The rule for finding the‘next’ point <span class="math inline">\(\frac{p+r}{q+s}\)</span>between two neighbours is every student’s dream of what addition offractions should be. This simple form of fraction ‘addition’ issometimes called Farey addition’, which one might want to symbolise witha funny symbol like:</p><p><span class="math display">\[\frac{p}{q} \oplus \frac{r}{s} = \frac{p + r}{q + s}\]</span></p><p>Farey addition gives a neat way of organising the rational numbers.Instead of the usual way of arranging them in increasing order (which isdifficult, because you never know which one should come ‘next’),fractions can be described by a sequence of left or right moves,reflecting the choice at each stage of whether we choose the new pair ofneighbours to the right, or the pair of neighbours to the left.</p></div><p>任何两个分数 <span class="math inline">\(r/s\)</span> 和 <span class="math inline">\(p/q\)</span>，若满足 <span class="math inline">\(ps - qr = \pm1\)</span>，则称它们为邻居。因此，模群镶嵌中的理想三角形的任意两个顶点都是邻居。如果<span class="math inline">\(p/q\)</span> 是一个分数，那么正如我们在项目7.5中所解释的那样，寻找其邻居的过程，本质上就是欧几里得两千年前发明的最大公约数算法——这无疑是人类历史上最实用、最巧妙的算法之一。计算两个邻居之间“下一个”点<span class="math inline">\(\frac{p+r}{q+s}\)</span>的规则，正是每个学生心目中理想的分数加法方式。这种简单的分数“加法”有时被称为“法雷加法”（Fareyaddition），人们或许会用一个有趣的符号来表示它，比如： <span class="math display">\[\frac{p}{q} \oplus \frac{r}{s} = \frac{p + r}{q + s}\]</span></p><p>法雷加法提供了一种巧妙的方式来组织有理数。不像按递增顺序排列那样麻烦（毕竟你很难确定下一个该是谁），分数可以通过一系列左移或右移的操作来描述，这正对应了我们在每一步中选择将新的邻居对放置在左边还是右边的决定。</p><div class="statement simple plain unnumbered"><p>For positive fractions, the starting point are the two fractions<span class="math inline">\(0/1\)</span> and <span class="math inline">\(1/0\)</span>, which we can regard as specialhonourary neighbours because they are connected by a side of our initialtriangle, the vertical imaginary axis. Farey addition gives thein-between fraction <span class="math inline">\(0/1\oplus1/0=1/1\)</span>.</p><p>Now we have a choice: go to the ‘left’ and look in the intervalbetween 0 and 1, or go to the ‘right’ and look in the interval between 1and <span class="math inline">\(\infty\)</span>. Suppose we are aimingfor the fraction <span class="math inline">\(3/5\)</span>. Then we turnto the left and apply the Farey addition <span class="math inline">\(0/1\oplus 1/1 = 1/2\)</span>. At the next stage, we choose the rightinterval and Farey add to get <span class="math inline">\(1/2 \oplus 1/1= 2/3\)</span>. Finally, we choose the left interval and Farey add <span class="math inline">\(1/2 \oplus 2/3 = 3/5\)</span>. An exactly similarprocedure could be applied to home in on any fraction <span class="math inline">\(p/q\)</span>. Our choice of left-right turns is adriving map: <span class="math inline">\(3/5\)</span> is given by theinstructions ‘left, right, left’. This arrangement of fractions andsequence of right-left moves is closely related to a way of writingfractions as what are called continued fractions, explained in Note7.2.</p></div><p>对于正分数，我们的起点是两个特殊的分数：<span class="math inline">\(0/1\)</span> 和 <span class="math inline">\(1/0\)</span>。我们不妨将它们视作“荣誉邻居”，因为它们由初始三角形的一条边——垂直的虚轴——连接在一起。利用Farey 加法，我们可以在它们之间找到一个中间分数：<span class="math inline">\(0/1 \oplus 1/0 = 1/1\)</span>。</p><p>接下来，我们需要做出选择：向“左”走，查看 0 到 1之间的区间；还是向“右”走，查看 1 到 <span class="math inline">\(\infty\)</span> 之间的区间。假设我们的目标是分数<span class="math inline">\(3/5\)</span>。那么我们选择向左，执行 Farey加法：<span class="math inline">\(0/1 \oplus 1/1 =1/2\)</span>。在下一步，我们转向右侧区间，并执行 Farey 加法得到：<span class="math inline">\(1/2 \oplus 1/1 =2/3\)</span>。最后，我们再次选择左侧区间，进行 Farey 加法：<span class="math inline">\(1/2 \oplus 2/3 = 3/5\)</span>。</p><p>通过完全相同的步骤，我们可以找到任意分数 <span class="math inline">\(p/q\)</span>。我们每次选择向左或向右的决策就像一张“导航图”：例如，分数<span class="math inline">\(3/5\)</span>对应的指令是“左、右、左”。这种分数的排列方式和左右转向的序列，与将分数表示为连分数的写法密切相关，详见注释7.2。</p><h2 id="the-pairing-pattern-of-the-modular-group">The pairing pattern ofthe modular group</h2><div class="statement simple plain unnumbered"><p>The modular group is a new kind of ‘necklace group’. It is still madeby pairing four tangent circles, and the only difference from thekissing Schottky groups we met in the last chapter is that thegenerators pair not opposite circles but adjacent ones. Whenever we havean arrangement of paired tangent circles like this, something like thenecklace condition on p.&nbsp;168 must still be true, but because we arepairing the circles in a different pattern, we can expect that differentelements must be parabolic to cause the image circles to shrink.</p></div><p>模群是一种新型的“项链群”。它同样由四个相切的圆配对构成，不同之处在于，生成元这次配对的不是相对的圆，而是相邻的圆。每当我们遇到这样的相切圆配对排列时，类似于第168页提到的“项链条件”仍然必须成立。不过，由于这次采用了不同的配对模式，我们可以预见，只有某些不同的元素变成抛物型时，映像圆才会缩小。</p><div class="statement simple plain unnumbered"><p>With the notation of the figure beside Box 20, we have <span class="math inline">\(a(P) = R\)</span> and <span class="math inline">\(b(R) = P\)</span>, so that the four tangencypoints of the circles are <span class="math inline">\(S =\text{Fix}(a)\)</span>, <span class="math inline">\(Q =\text{Fix}(b)\)</span>, <span class="math inline">\(P =\text{Fix}(ba)\)</span>, and <span class="math inline">\(R =\text{Fix}(ab)\)</span>. By similar reasoning to that in Chapter 6, inorder for the image circles near <span class="math inline">\(S\)</span>and <span class="math inline">\(Q\)</span> to shrink, the generators<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> must be parabolic. Moreover, <span class="math inline">\(ba\)</span> must also be parabolic, to make thecircles shrink at <span class="math inline">\(P\)</span>. Notice that<span class="math inline">\(ab\)</span> and <span class="math inline">\(ba\)</span> are conjugate (since <span class="math inline">\(b(ab)b^{-1} = ba\)</span>), so saying that <span class="math inline">\(ab\)</span> or <span class="math inline">\(ba\)</span> must be parabolic is really one andthe same thing. The wonderful thing is, that as we proved in Note 7.1,all groups with these three elements parabolic are automaticallyconjugate. This is so important to us that we summarize it in Box20.</p><p>Because the pattern of pairing circles is different, so is thearrangement in which the labelled circles are laid down in the plane.The Schottky circles in Figure 7.11 are labelled according to our usualrules, so for example, <span class="math inline">\(C_{ba}\)</span> stillmeans the image of circle <span class="math inline">\(C_a\)</span> underthe map <span class="math inline">\(b\)</span>. However, if you lookcarefully, you will see that the order of the circles along the line isnot the same as our original order round the boundary of the word treeon p.&nbsp;104. The labels can be read off in their correct order from therevised version in Figure 7.12. (To see this you will have to twiddlethe diagram around so the arrows from the vertex you are interested inare pointing ‘down’ rather than ‘up’.) There is a subtle difference fromour original word tree, because there the cyclic order round a vertexwas <span class="math inline">\(a,B,A,b\)</span> while now it is <span class="math inline">\(a,A,b,B\)</span>. The ramifications of thisseemingly minor change propagate down the tree.</p></div><p>根据盒 20 旁的图示，我们有 <span class="math inline">\(a(P) =R\)</span> 且 <span class="math inline">\(b(R) =P\)</span>，因此四个切点分别是：<span class="math inline">\(S =\text{Fix}(a)\)</span>, <span class="math inline">\(Q =\text{Fix}(b)\)</span>, <span class="math inline">\(P =\text{Fix}(ba)\)</span> 和 <span class="math inline">\(R =\text{Fix}(ab)\)</span>。类似于第 6 章的推理，为了使靠近 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(Q\)</span> 的映像圆缩小，生成元 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 必须是抛物型的。此外，<span class="math inline">\(ba\)</span> 也必须是抛物型的，才能确保圆在 <span class="math inline">\(P\)</span> 处缩小。需要注意的是，<span class="math inline">\(ab\)</span> 和 <span class="math inline">\(ba\)</span> 是共轭的（因为 <span class="math inline">\(b(ab)b^{-1} = ba\)</span>），因此说 <span class="math inline">\(ab\)</span> 或 <span class="math inline">\(ba\)</span>必须是抛物型的，实际上是同一回事。奇妙的是，正如我们在注释 7.1中所证明的，所有包含这三个抛物型元素的群自动共轭。这一点对我们来说非常重要，因此我们在图20 中专门进行了总结。</p><p>由于配对圆的模式不同，标记圆在平面上的排列方式也随之改变。<a href="#fig-7.11">图 7.11</a> 中的 Schottky圆仍按照我们通常的规则标记，例如，<span class="math inline">\(C_{ba}\)</span> 依然表示圆 <span class="math inline">\(C_a\)</span> 在映射 <span class="math inline">\(b\)</span>下的像。然而，如果你仔细观察，就会发现这些圆沿着直线的排列顺序与我们最初在边界上的顺序并不相同。</p><h1 id="playing-with-parameters">Playing with parameters</h1><div class="statement simple plain unnumbered"><p>I could spin a web if I tried.’ said Wilbur, boasting. ‘Ive justnever tried.’</p><p>‘Let’s see you do it,’ said Charlotte…</p><p>‘OK.’ replied Wilhur. ‘You coach me and I’t’ spin one. It must be alot of fun to spill a web. How do I start?</p><p>“要是我愿意，我也能织网。”威尔伯吹嘘道，“只是我从来没试过。”</p><p>“那你来织一个给我们看看吧。”夏洛特说。</p><p>“好啊。”威尔伯答道，“你来指导我，我就织一个。织网一定很好玩。我该怎么开始呢？”</p></div><div class="statement simple plain unnumbered"><p>As any mathematician who has revealed his (or her) occupation to aneighbour on a plane flight has discovered, most people associatemathematics with something akin to the more agonizing forms of medievaltorture. It seems indeed unlikely that mathematics would be done at all,were it not that a few people discover the play that lies at its heart.Most published mathematics appears long after the play is done, cloakedin lengthy technicalities which obscure the original fun. The book inhand is unfortunately scarcely an exception. Never mind; after a fairlydetailed introduction to the art of creating tilings and fractal limitsets out of two very carefully chosen Möbius maps, we are finally set toembark on some serious mathematical play. The greatest rewards will bereaped by those who invest the time to set up their own programs andjoin us charting mathematical territory which is still only partiallyexplored.</p></div><p>正如任何一位曾在飞机上向邻座透露自己职业的数学家都会发现的那样，大多数人对数学的印象，似乎与某种中世纪酷刑的痛苦体验无异。倘若不是有少数人发现了数学的核心妙趣，数学恐怕早已无人问津。大多数已发表的数学成果，往往是在趣味探索结束许久之后才浮出水面的，而那些冗长繁复的技术细节，往往掩盖了最初的乐趣。遗憾的是，手头的这本书也未能完全例外。不过，别担心——在颇为详尽地介绍了如何用两个精心挑选的莫比乌斯变换来构造密铺图案和分形极限集之后，我们终于可以开始一场真正的数学探险了。那些愿意投入时间亲手编写程序、与我们一道探索这片尚未完全揭示的数学版图的读者，定将收获最丰厚的回报。</p><div class="statement simple plain unnumbered"><p>All the limit sets we have constructed thus far began from a specialarrangement of four circles, the Schottky circles, grouped into twopairs. For each pair, we found a Möbius map which moved the inside ofone circle to the outside of the other. Our initial tile was the regionoutside these four circles. By iterating, we produced a tiling whichcovered the the plane minus the limit set, near which the tiles shrankto minute size. Depending on how we chose the initial Schottky circles,the limit set was either fractal dust, a very crinkled fractal loop wecalled a quasicircle or, in certain very special cases, a truecircle.</p></div><p>迄今为止，我们构造的所有极限集都源自四个圆的独特排列，这些圆被称为肖特基圆，分为两对。对于每一对圆，我们找到一个莫比乌斯映射，将一个圆的内部映射到另一个圆的外部。我们的初始瓷砖是这四个圆外部的区域。通过不断迭代，我们生成了一种密铺，覆盖了平面上除了极限集以外的区域，在极限集附近，瓷砖逐渐缩小至微不可见的尺寸。根据我们选择的初始肖特基圆的不同，极限集可能呈现为分形尘埃，或者是我们称之为拟圆的极度扭曲的分形环，亦或在某些极其特殊的情况下，成为一个真正的圆。</p><div class="statement simple plain unnumbered"><p>The problem with this approach is that it is just too time-consumingto set up the circles and maps which pair them. Free-spirited playshouldn’t be ruined by too much preparation. Why not throw the Schottkycircles away, take any pair of <span class="math inline">\(2\times2\)</span> matrices for our generators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, run our limit point plotting program,and see what we get?</p><p>Hold on though - how exactly will this work? The shrinking disks wereso reassuring, and the limit set was so comfortably nestled within them,that it is hard to see why we won’t get chaos in their absence. Nomatter, the worst that is likely to happen is that the hard diskcrashes, so why not give it a try? Luckily, on p.&nbsp;182 ff.&nbsp;we alreadyupgraded the DFS code to remove the calculation of Schottky disks fromthe branch termination procedure. All we need do is take the plunge andrun the very same algorithm for any pair of transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</p></div><p>这个方法的弊端在于，设置这些圆及其配对映射实在太耗时了。自由随性的探索不应该被繁杂的准备工作束缚住手脚。为什么不干脆抛开Schottky 圆，随便挑一对 <span class="math inline">\(2 \times 2\)</span>矩阵作为我们的生成元 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，然后直接运行极限点绘图程序，看看会蹦出什么结果呢？</p><p>不过，先别急——这真的行得通吗？那些嵌套收缩的圆盘曾给予我们清晰的秩序感，极限集恰如其分地安居其中。若失去这种结构约束，系统难道不会陷入混沌？但没关系，最糟糕的结果不过是硬盘崩溃罢了，那为什么不试试看呢？</p><p>幸运的是，在第 182 页及后续章节中，我们已经对 DFS算法进行改良，去掉了分支终止判定中对 Schottky圆盘的计算。我们所需要的，只有一股冲劲——运行同样的算法，随便选一对变换<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，放手一试就好。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Playing with parameters</title>
      <link href="/indra/playing-with-parameters.html"/>
      <url>/indra/playing-with-parameters.html</url>
      
        <content type="html"><![CDATA[<div class="statement simple plain unnumbered"><p>I could spin a web if I tried.’ said Wilbur, boasting. ‘Ive justnever tried.’</p><p>‘Let’s see you do it,’ said Charlotte…</p><p>‘OK.’ replied Wilhur. ‘You coach me and I’t’ spin one. It must be alot of fun to spill a web. How do I start?</p><p>“要是我愿意，我也能织网。”威尔伯吹嘘道，“只是我从来没试过。”</p><p>“那你来织一个给我们看看吧。”夏洛特说。</p><p>“好啊。”威尔伯答道，“你来指导我，我就织一个。织网一定很好玩。我该怎么开始呢？”</p></div><div class="statement simple plain unnumbered"><p>As any mathematician who has revealed his (or her) occupation to aneighbour on a plane flight has discovered, most people associatemathematics with something akin to the more agonizing forms of medievaltorture. It seems indeed unlikely that mathematics would be done at all,were it not that a few people discover the play that lies at its heart.Most published mathematics appears long after the play is done, cloakedin lengthy technicalities which obscure the original fun. The book inhand is unfortunately scarcely an exception. Never mind; after a fairlydetailed introduction to the art of creating tilings and fractal limitsets out of two very carefully chosen Möbius maps, we are finally set toembark on some serious mathematical play. The greatest rewards will bereaped by those who invest the time to set up their own programs andjoin us charting mathematical territory which is still only partiallyexplored.</p></div><p>正如任何一位曾在飞机上向邻座透露自己职业的数学家都会发现的那样，大多数人对数学的印象，似乎与某种中世纪酷刑的痛苦体验无异。倘若不是有少数人发现了数学的核心妙趣，数学恐怕早已无人问津。大多数已发表的数学成果，往往是在趣味探索结束许久之后才浮出水面的，而那些冗长繁复的技术细节，往往掩盖了最初的乐趣。遗憾的是，手头的这本书也未能完全例外。不过，别担心——在颇为详尽地介绍了如何用两个精心挑选的莫比乌斯变换来构造密铺图案和分形极限集之后，我们终于可以开始一场真正的数学探险了。那些愿意投入时间亲手编写程序、与我们一道探索这片尚未完全揭示的数学版图的读者，定将收获最丰厚的回报。</p><div class="statement simple plain unnumbered"><p>All the limit sets we have constructed thus far began from a specialarrangement of four circles, the Schottky circles, grouped into twopairs. For each pair, we found a Möbius map which moved the inside ofone circle to the outside of the other. Our initial tile was the regionoutside these four circles. By iterating, we produced a tiling whichcovered the the plane minus the limit set, near which the tiles shrankto minute size. Depending on how we chose the initial Schottky circles,the limit set was either fractal dust, a very crinkled fractal loop wecalled a quasicircle or, in certain very special cases, a truecircle.</p></div><p>迄今为止，我们构造的所有极限集都源自四个圆的独特排列，这些圆被称为肖特基圆，分为两对。对于每一对圆，我们找到一个莫比乌斯映射，将一个圆的内部映射到另一个圆的外部。我们的初始瓷砖是这四个圆外部的区域。通过反复迭代，我们生成了一种密铺，覆盖了平面上除了极限集以外的区域，在极限集附近，瓷砖逐渐缩小至微不可察的尺寸。根据我们选择的初始肖特基圆的不同，极限集可能呈现为分形尘埃，或者是我们称之为拟圆的极度扭曲的分形环，亦或在某些极其特殊的情况下，成为一个完美的圆。</p><div class="statement simple plain unnumbered"><p>The problem with this approach is that it is just too time-consumingto set up the circles and maps which pair them. Free-spirited playshouldn’t be ruined by too much preparation. Why not throw the Schottkycircles away, take any pair of <span class="math inline">\(2\times2\)</span> matrices for our generators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, run our limit point plotting program,and see what we get?</p><p>Hold on though - how exactly will this work? The shrinking disks wereso reassuring, and the limit set was so comfortably nestled within them,that it is hard to see why we won’t get chaos in their absence. Nomatter, the worst that is likely to happen is that the hard diskcrashes, so why not give it a try? Luckily, on p.&nbsp;182 ff.&nbsp;we alreadyupgraded the DFS code to remove the calculation of Schottky disks fromthe branch termination procedure. All we need do is take the plunge andrun the very same algorithm for any pair of transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</p></div><p>这个方法的弊端在于，设置这些圆及其配对映射实在太耗时了。自由随性的探索不应该被繁琐的准备工作束缚住手脚。为什么不干脆抛开Schottky 圆，随便挑一对 <span class="math inline">\(2 \times 2\)</span>矩阵作为我们的生成元 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，然后直接运行极限点绘图程序，看看会蹦出什么结果呢？</p><p>慢着，这真的行得通吗？那些嵌套收缩的圆盘让人倍感安心，极限集恰如其分地安居其中。没有了它们的庇护，系统难道不会陷入混沌？不过没关系，大不了就是硬盘崩了呗，那为什么不试试看呢？</p><p>幸运的是，在第 182 页及后续章节中，我们已经对 DFS算法进行改良，去掉了分支终止判定中对 Schottky圆盘的计算。我们所需要的，只是鼓起勇气，运行同样的算法，随便选一对变换<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，放手一试就好。</p><div class="statement simple plain unnumbered"><p>The reward is the glorious Figure 8.1! See intricate dance of spiralsof two loxodromic transformations. This is a quasifuchsian group verydifferent from the circle groups we met in Chapter 6. As usual, once acertain feature appears, the Mobius transformations in the grouptransport it around. Theoretical knowledge is one thing, but it wasn’tuntil we got our programs up and running that the first ever pictures ofexploding spirals brought the reality home. The authors, and later theparticipants in 1980 Thurston Theory Conference at Bowdoin College,could not suppress their awe at the eerie glowing image of the limitcurve snaking its way across an old Tektronix terminal.</p></div><p>奖励是辉煌的 <a href="#fig-8.1">图8.1</a>！看看两个斜驶变换螺旋的复杂舞蹈。这是一个与我们在第 6章遇到的圆群截然不同的拟 Fuchs群。像往常一样，一旦某个特征出现，群中的莫比乌斯变换便会将其传递开来。理论知识是一回事，但直到我们的程序启动并运行，第一张爆炸螺旋的图片才让人真正感受到其中的魅力。作者们，以及后来参加1980 年鲍登学院 Thurston 理论会议的与会者，无法抑制对极限曲线在老式Tektronix 显示器上蜿蜒而出的那张诡异发光图像的敬畏。</p><div class="statement simple plain unnumbered"><p>There’s one question here you may be asking: how did we choose <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>? The answer is, we built a machine.When engineers design a new sports car, do you really think they firsttest it by creeping down the driveway carefully at 5 miles per hour,then 10 miles per hour, and so on? Of course not; they push it madlythrough its paces to see how it drives. In order to carry out ourexplorations, we needed an easy-to-use program so we could quickly testout all sorts of possible matrices. In the next section, we shallexplain a recipe which allows us to easily make as many variants ofpictures like this as we please. The recipe depends on just two complexnumbers, the traces of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. These will be our parameters; justfeed them in and let the program fly.</p></div><p>接下来，你可能会有一个问题：我们是如何选择 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>的？答案是，我们构建了一台机器。当工程师设计一辆新跑车时，你真的认为他们会先以每小时5 英里的速度小心翼翼地沿着车道缓慢测试，然后是每小时 10英里，依此类推吗？当然不是；他们会毫不犹豫地将它推向极限，以各种速度行驶，观察它的驾驶表现如何。为了进行我们的探索，我们需要一个易于使用的程序，能够快速测试各种可能的矩阵。在下一节中，我们将解释一种方法，让我们轻松地制作出任意数量的此类图片变体。这个方法仅依赖于两个复数——<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>的迹。它们将作为我们的参数；只需输入它们，启动程序即可。</p><div class="statement simple plain unnumbered"><p>Actually you may get even greater satisfaction by varying theparameters continuously and watching the limit set writhing in response.For that, you will have to write another small program which plots asequence of frames of limit sets whose parameters are just slightlychanged step-by-step. Several people have done this, but stills are thebest we can offer in a book. Jeff Brock offers some films of crawlinglimit bugs on his web page www.math.uchicago.edu/~brock. For theMacintosh, we recommend a program by Masaaki Wada called <em>OPTi</em>,available at vivaldi.ics.nara-wu.ac.jp/~wada.</p></div><p>其实，如果你尝试连续调整参数，并观察极限集在这种变化中不断扭动、变形，你可能会感受到更大的乐趣。为此，你需要编写一个小程序，绘制一系列极限集的动画帧，每一帧的参数都稍稍有所变化。虽然已经有人做过这类工作，但在书中我们只能展示静态图像。JeffBrock 在他的网站 www.math.uchicago.edu/~brock上提供了一些关于“爬行的极限虫”的短片。对于 Macintosh 用户，我们推荐Masaaki Wada 开发的 OPTi 程序，可在 vivaldi.ics.nara-wu.ac.jp/~wada下载。</p><figure id="fig-8.1"><img src="/images/indra/fig-8.1.jpg" class="fig" width="500" alt="Figure 8.1. Mating snails? The limit set of a group generated by two maps a and b with complex conjugate traces t_a=1.87+0.1i and t_b=1.87-0.1i. This group is quasifuchsian because its limit set is a continuous loop which never crosses or meets itself. Curves like this are called Jordan curves: the celebrated Jordan Curve Theorem innocently states that every Jordan curve divides the plane into two parts, an ‘inside’ (gray) and an ‘outside’ (white). The proof of this seemingly obvious result is not easy. and this picture gives some idea of just how complicated a Jordan curve can be. We had to devise a handerafted algorithm to colour the inside. 图 8.1 交配的蜗牛？ 这是由两个映射 a 和 b 所生成的群的极限集，它们的迹互为复共轭，分别为 t_a = 1.87 + 0.1i 和 t_b = 1.87 - 0.1i。该群是拟 Fuchsian 群，因为它的极限集是一条既不交叉也不自交的连续闭曲线。这样的曲线被称为 Jordan 曲线。著名的 Jordan 曲线定理看似简单：每一条 Jordan 曲线都将平面分成两个部分，一个“内部”（灰色）和一个“外部”（白色）。尽管这个结果听起来显而易见，证明它却并不容易。而这幅图正好展示了 Jordan 曲线可以复杂到什么程度。为了给内部区域上色，我们不得不专门设计一个手工打造的算法。"><figcaption aria-hidden="true">Figure 8.1. Mating snails? The limit setof a group generated by two maps <span class="math inline">\(a\)</span>and <span class="math inline">\(b\)</span> with complex conjugate traces<span class="math inline">\(t_a=1.87+0.1i\)</span> and <span class="math inline">\(t_b=1.87-0.1i\)</span>. This group isquasifuchsian because its limit set is a continuous loop which nevercrosses or meets itself. Curves like this are called Jordan curves: thecelebrated Jordan Curve Theorem innocently states that every Jordancurve divides the plane into two parts, an ‘inside’ (gray) and an‘outside’ (white). The proof of this seemingly obvious result is noteasy. and this picture gives some idea of just how complicated a Jordancurve can be. We had to devise a handerafted algorithm to colour theinside.<br><strong>图 8.1 交配的蜗牛？</strong> 这是由两个映射 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>所生成的群的极限集，它们的迹互为复共轭，分别为 <span class="math inline">\(t_a = 1.87 + 0.1i\)</span> 和 <span class="math inline">\(t_b = 1.87 - 0.1i\)</span>。该群是拟 Fuchsian群，因为它的极限集是一条既不交叉也不自交的连续闭曲线。这样的曲线被称为Jordan 曲线。著名的 Jordan 曲线定理看似简单：每一条 Jordan曲线都将平面分成两个部分，一个“内部”（灰色）和一个“外部”（白色）。尽管这个结果听起来显而易见，证明它却并不容易。而这幅图正好展示了Jordan曲线可以复杂到什么程度。为了给内部区域上色，我们不得不专门设计一个手工打造的算法。</figcaption></figure><h1 id="grandmas-recipe">Grandma’s recipe</h1><div class="statement simple plain unnumbered"><p>To make pictures, we need two Möbius maps <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, given by matrices <span class="math display">\[a = \begin{pmatrix} a_1 &amp; a_2 \\ a_3 &amp; a_4 \end{pmatrix} \quad\text{and} \quad b = \begin{pmatrix} b_1 &amp; b_2 \\ b_3 &amp; b_4\end{pmatrix}.\]</span> Numerical inputs to a device or program are often calledparameters. On the face of it, two matrices means eight complex numberswhich means sixteen real numbers: that’s quite a few! To build our‘easy-to-use’ program, we need reduce the parameters to a minimum. Wecan get the number down to six by assuming that each matrix hasdeterminant 1. We can further reduce the number by remembering that theinteresting thing is to study groups up to conjugation. In practice thismeans that after we have studied one particular group <span class="math inline">\(G\)</span>, we no longer need study any of theconjugate groups <span class="math inline">\(hGh^{-1}\)</span> for anyconjugating Möbius map <span class="math inline">\(h\)</span> (apart ofcourse from the fun of getting a quite different ‘view’ of the limitset). A definite choice among all the conjugate groups <span class="math inline">\(hGh^{-1}\)</span> is called a normalization for<span class="math inline">\(G\)</span>.</p></div><p>为了绘制图形，我们需要两个莫比乌斯映射 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，它们分别由以下矩阵给出： <span class="math display">\[a = \begin{pmatrix} a_1 &amp; a_2 \\ a_3 &amp; a_4 \end{pmatrix} \quad\text{and} \quad b = \begin{pmatrix} b_1 &amp; b_2 \\ b_3 &amp; b_4\end{pmatrix}.\]</span>设备或程序的数值输入通常被称为参数。从表面上看，两个矩阵意味着八个复数，即十六个实数：这可真不少！为为了让我们的程序“好用”，我们需要尽量减少参数的数量。通过假设每个矩阵的行列式为1，我们可以将参数数减少到六个。我们还可以通过记住，研究群的共轭类才是关键，进一步减少参数数量。实际上，这意味着一旦我们研究了某个特定的群<span class="math inline">\(G\)</span>，我们就不再需要研究任何共轭群<span class="math inline">\(hGh^{-1}\)</span>，其中 <span class="math inline">\(h\)</span>是任何共轭的莫比乌斯映射（当然，除非你想体验一下从完全不同的角度观察极限集的乐趣）。在所有共轭群<span class="math inline">\(hGh^{-1}\)</span>中，选定一个特定的群作为代表，这个选择就称为对 <span class="math inline">\(G\)</span> 的归一化。</p><div class="statement simple plain unnumbered"><p>Choosing a particular normalization allows you to eliminate threefurther parameters, because there is always exactly one Möbius map whichcarries any three points to any other three. This means that you canprespecify the position of three points; for example, you might specifythat the attracting fixed points of <span class="math inline">\(a\)</span>, <span class="math inline">\(A\)</span>and <span class="math inline">\(b\)</span> are <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span>, and <span class="math inline">\(\infty\)</span> respectively. This is exactly whatwe did on p.&nbsp;207 when we proved that, up to conjugation, the modulargroup is unique. The upshot is that up to conjugacy, we should be ableto reduce the number of complex parameters necessary to describe atwo-generator group from eight to just three. The question is, whichthree? From our experience in the last two chapters, a good guess mightbe the three traces <span class="math inline">\(\mathop{\mathrm{Tr}}{a}\)</span>, <span class="math inline">\(\mathop{\mathrm{Tr}}{b}\)</span> and <span class="math inline">\(\mathop{\mathrm{Tr}}{ab}\)</span>. These numbersdon’t change when you conjugate, moreover we have already seen in somespecial cases that, up to conjugation, they completely determine thegroup.</p></div><p>选择特定的归一化方式，可以进一步消去三个参数。原因是，总存在一个莫比乌斯映射，能够将任意三个点映射到另一个任意的三点组合。这意味着，你可以预先指定这三个点的位置。例如，你可以规定映射<span class="math inline">\(a\)</span>、<span class="math inline">\(A\)</span> 和 <span class="math inline">\(b\)</span> 的吸引不动点分别为 <span class="math inline">\(0\)</span>、<span class="math inline">\(1\)</span>和 <span class="math inline">\(\infty\)</span>。事实上，这正是我们在第207 页中证明模群在共轭意义下唯一时所采用的方法。</p><p>由此可见，在共轭等价的条件下，我们应该能够将描述一个双生成元群所需的复数参数数量，从八个减少到仅三个。问题是，这三个参数该如何选取？根据我们在前两章中的经验，一个合理的猜测是：选取<span class="math inline">\(\mathop{\mathrm{Tr}}{a},\mathop{\mathrm{Tr}}{b}\)</span>和 <span class="math inline">\(\mathop{\mathrm{Tr}}{ab}\)</span>作为参数。这三个数在共轭下保持不变，而且我们已经在一些特殊情形中见过，单凭它们（在共轭意义下）就足以完全确定该群。</p><div class="statement simple plain unnumbered"><p>Our upgraded algorithm is going to work by moving systematicallyround the boundary of the word tree, plotting limit points in order whenit detects they are close. This means that for the program to workreasonably efficiently, it will be best if the limit set is still, atleast roughly speaking, a connected loop. In the situation of pairingopposite Schottky circles this happens provided all four basiccommutators are parabolic with traces equal <span class="math inline">\(-2\)</span>. As we saw on p.&nbsp;189, we can arrangethis by choosing <span class="math inline">\(\mathop{\mathrm{Tr}}{ab}\)</span> to satisfy theMarkov identity <span class="math display">\[(\mathop{\mathrm{Tr}}{a})^2 + (\mathop{\mathrm{Tr}}{b})^2 +(\mathop{\mathrm{Tr}}{ab})^2 = \mathop{\mathrm{Tr}}{a}\mathop{\mathrm{Tr}}{b} \mathop{\mathrm{Tr}}{ ab}.\]</span></p></div><p>我们升级后的算法将通过沿着单词树的边界系统地移动，在发现极限点接近时按顺序将其标出。为了让程序尽可能高效地运行，极限集最好仍然是一个连通的环，或者至少大致如此。</p><p>在配对相对的 Schottky 圆时，只要四个基本交换子都是迹为 <span class="math inline">\(-2\)</span>的抛物型元素，这种情况就会成立。正如我们在第 189页所看到的，可以通过选择 <span class="math inline">\(\mathop{\mathrm{Tr}}{ab}\)</span>满足马尔可夫恒等式来实现这一点： <span class="math display">\[(\mathop{\mathrm{Tr}}{a})^2 +(\mathop{\mathrm{Tr}}{b})^2 + (\mathop{\mathrm{Tr}}{ab})^2 =\mathop{\mathrm{Tr}}{a} \mathop{\mathrm{Tr}}{b} \mathop{\mathrm{Tr}}{ab}.\]</span></p><div class="statement simple plain unnumbered"><p>So for most of this chapter, we shall insist that <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB} = -2\)</span>, orequivalently that our three parameters <span class="math inline">\(t_a\)</span>, <span class="math inline">\(t_b\)</span> and <span class="math inline">\(t_{ab}\)</span> satisfy the Markov equation. Giveor take some trouble with square roots, this reduces our parameter countfrom 3 to 2, namely <span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span>. We shall give the name<strong>parabolic commutator groups</strong> to those groups in which<span class="math inline">\(\mathop{\mathrm{Tr}}{abAB} = -2\)</span>.They are also sometimes known as <strong>once-punctured torusgroups</strong>, because of the topological picture on p.&nbsp;190.</p></div><p>因此，在本章的大部分内容中，我们将始终假设 <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB} =-2\)</span>。换句话说，我们的三个参数 <span class="math inline">\(t_a\)</span>、<span class="math inline">\(t_b\)</span> 和 <span class="math inline">\(t_{ab}\)</span>满足马尔可夫方程。撇开一些与平方根有关的麻烦不谈，这一假设将参数的数量从3 个降至 2 个，即 <span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span>。我们将把满足 <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB} = -2\)</span>的群称为抛物交换子群（parabolic commutatorgroups）。它们有时也被称为一次穿孔环面群（once-punctured torusgroups），这是因为在第 190 页的拓扑图景中可以看到它们的相关性。</p><div class="statement simple plain unnumbered"><p>In Box 21 we have revealed Grandma’s treasured family recipe for thespecially normalized two-parameter family which we used for most of ourown explorations.^1 The matrix entries of the two generators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are written down entirely in terms ofthe parameters <span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span>, which you can set equal to any twocomplex numbers you care to choose. As you can see, the recipe isdesigned so that these numbers are the traces of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. Among all possible normalizations andhence many different possible recipes she might equally well have tried,Grandma selected this one mixed with some special spices to make thepictures come out really nice. If you put in real values for <span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span>, you get the group which pairsSchottky circles arranged in the pattern in frame (vi) on p.&nbsp;176. Thesame formula gave us the generators for the Apollonian gasket on p.&nbsp;201.There are some hints on how to verify that just knowing <span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span> really does fix the group in Project8.4.</p></div><p>在框 21中，我们揭示了奶奶传下来的秘制家族配方，这是一种特定归一化的双参数族，我们的大部分探索都采用了这种方法。两个生成元<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的矩阵元素完全由参数 <span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span>表示，你可以任意选择这两个参数为任何复数。正如你所见，这份配方经过奶奶亲手调配，加上了一些独家秘制香料，使得这两个数恰好是<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的迹。</p><p>归一化的方法有很多种，奶奶特意选择了这一份，加上她的独门手法，调出了让图像变得格外出彩的效果。如果你将<span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span> 设为实数值，就会得到与第 176 页图(vi) 中排列的 Schottky 圆相配对的群。同样的公式还为我们提供了第 201页阿波罗尼奥斯垫片的生成元。项目 8.4 提供了一些提示，教你如何验证仅凭<span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span> 确实足以确定该群。</p><div class="statement simple plain unnumbered"><p>Gosh, it’s so easy; why is there any need to explain? As you can see,in the second step of her recipe Grandma arranged that <span class="math inline">\(t_{ab}\)</span> satisfies the Markov identity,thereby ensuring that <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB} = -2\)</span>. We hadbetter check that multiplying <span class="math inline">\(a\)</span> and<span class="math inline">\(b\)</span> gives the formula we have writtendown for <span class="math inline">\(ab\)</span>, and that thedeterminants of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are both 1. You may wish to resort toyour favourite symbolic algebra program, or, for the traditionalists, werecommend beginning with a good pile of blank scratch paper, copying thetwo matrices <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> carefully, and multiplying them outvery slowly indeed.</p></div><p>天哪，这也太简单了，还需要解释吗？正如你所见，在她的食谱第二步中，奶奶巧妙地安排了<span class="math inline">\(t_{ab}\)</span> 满足马尔可夫恒等式，从而确保<span class="math inline">\(\mathop{\mathrm{Tr}}{abAB} =-2\)</span>。不过，我们还是最好核对一下：把 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 相乘，是否确实得到了我们写下的 <span class="math inline">\(ab\)</span> 公式？还有，<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的行列式是否真的都是1？你可能想借助自己喜欢的符号代数程序，或者，如果你更喜欢传统方法，我们建议你备上一大堆干净的草稿纸，把矩阵<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>仔细抄下来，然后一步一步、慢吞吞地把它们算出来。</p><div id="box21" class="statement sta_box_21__grandma_s_special_parabolic_commutator_groups plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Box 21:Grandma’s special parabolic commutator groups</span>.</span><span class="statement-spah"> </span><strong>框21：外婆的特殊抛物线换位子群</strong></p><ol type="1"><li>Choose any complex numbers <span class="math inline">\(t_a\)</span>and <span class="math inline">\(t_b\)</span>.</li><li>Choose one of the solutions <span class="math inline">\(x\)</span>of the quadratic equation <span class="math display">\[x^2 - t_a t_b x +t_a^2 + t_b^2 = 0\]</span> and set <span class="math inline">\(t_{ab} =x\)</span>.</li><li>Compute <span class="math display">\[z_0 = \frac{(t_{ab} - 2)t_b}{t_b t_{ab} - 2 t_a + 2 i t_{ab}}.\]</span></li><li>Compute the generator matrices: <span class="math display">\[a =\begin{pmatrix}\frac{t_a}{2} &amp; \frac{t_a t_{ab} - 2 t_b + 4i}{(2 t_{ab} + 4) z_0}\\\frac{(t_a t_{ab} - 2 t_b - 4i) z_0}{2 t_{ab} - 4} &amp; \frac{t_a}{2}\end{pmatrix}\]</span> <span class="math display">\[b = \begin{pmatrix}\frac{t_b - 2i}{2} &amp; \frac{t_b}{2} \\\frac{t_b}{2} &amp; \frac{t_b + 2i}{2}\end{pmatrix}.\]</span></li><li>It’s worth noting that the product <span class="math inline">\(ab\)</span> is also quite simple: <span class="math display">\[ab = \begin{pmatrix}\frac{t_{ab}}{2} &amp; \frac{t_{ab} - 2}{2 z_0} \\\frac{(t_{ab} + 2) z_0}{2} &amp; \frac{t_{ab}}{2}\end{pmatrix}.\]</span></li></ol><p>One could compute <span class="math inline">\(b\)</span> and <span class="math inline">\(ab\)</span> first, and then find <span class="math inline">\(a\)</span> by multiplying <span class="math inline">\(ab\)</span> on the right by the inverse of <span class="math inline">\(b\)</span>, that is, <span class="math inline">\(a= (ab)B\)</span>.</p><ol type="1"><li>选取任意复数 <span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span>。<br></li><li>解以下二次方程，取其中一个解为 <span class="math inline">\(x\)</span>： <span class="math display">\[x^2 -t_a t_b x + t_a^2 + t_b^2 = 0.\]</span><br>然后令 <span class="math inline">\(t_{ab} = x\)</span>。<br></li><li>计算 <span class="math display">\[z_0 = \frac{(t_{ab} - 2) t_b}{t_bt_{ab} - 2 t_a + 2 i t_{ab}}.\]</span><br></li><li>计算生成元矩阵： <span class="math display">\[a = \begin{pmatrix}\frac{t_a}{2} &amp; \frac{t_a t_{ab} - 2 t_b + 4i}{(2 t_{ab} + 4) z_0}\\\frac{(t_a t_{ab} - 2 t_b - 4i) z_0}{2 t_{ab} - 4} &amp; \frac{t_a}{2}\end{pmatrix}\]</span><br><span class="math display">\[b = \begin{pmatrix}\frac{t_b - 2i}{2} &amp; \frac{t_b}{2} \\\frac{t_b}{2} &amp; \frac{t_b + 2i}{2}\end{pmatrix}.\]</span><br></li><li>值得注意的是，矩阵 <span class="math inline">\(ab\)</span>也有一个相对简单的形式：<br><span class="math display">\[ab = \begin{pmatrix}\frac{t_{ab}}{2} &amp; \frac{t_{ab} - 2}{2 z_0} \\\frac{(t_{ab} + 2) z_0}{2} &amp; \frac{t_{ab}}{2}\end{pmatrix}.\]</span></li></ol><p>我们也可以先计算 <span class="math inline">\(b\)</span> 和 <span class="math inline">\(ab\)</span>，然后通过将 <span class="math inline">\(ab\)</span> 右乘以 <span class="math inline">\(b\)</span> 的逆矩阵来求得 <span class="math inline">\(a\)</span>，即 <span class="math inline">\(a =(ab) B\)</span>。</p></div><div class="statement simple plain unnumbered"><p>All the groups made using Grandma’s recipe have a rather beautifulsymmetry, which Grandma felt was a very flavourful ingredient in hergroups. You may notice that the diagonal entries in both <span class="math inline">\(a\)</span> and <span class="math inline">\(ab\)</span> are the same. This has theconsequence, immediately noticeable in all our pictures, that the limitset of any group made using her recipe is symmetrical under the 180°rotation about the origin <span class="math inline">\(O\)</span>. Howthis works is explained in Note 8.1.</p><p>Lastly, what about that mysterious number <span class="math inline">\(z_0\)</span> in the off-diagonal entries of <span class="math inline">\(a\)</span> and <span class="math inline">\(ab\)</span>? Grandma could just have left it outof her recipes altogether, and then <span class="math inline">\(z_0\)</span> would have been none other than thefixed point of the commutator <span class="math inline">\(abAB\)</span>.By conjugating by a map that moves <span class="math inline">\(z_0\)</span> to 1, Grandma has added a littleextra style to her pictures. To get the hang of her recipe, you may liketo work through Projects 8.1 and 8.2.</p></div><p>所有按照祖母配方制作的群都具有相当美丽的对称性，祖母认为这是她的群中一个非常独特且富有风味的“成分”。你可能会注意到，矩阵<span class="math inline">\(a\)</span> 和 <span class="math inline">\(ab\)</span>的对角线元素是相同的。这个特性直接导致了一个显而易见的结果：在我们所有的图像中，使用她配方制作的群的极限集在关于原点<span class="math inline">\(O\)</span> 的 <span class="math inline">\(180^\circ\)</span>旋转下是对称的。这个现象的原理在注释 8.1 中已经做了详细说明。</p><p>最后，再来谈谈矩阵 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(ab\)</span> 非对角线元素中的那个神秘数字 <span class="math inline">\(z_0\)</span>。祖母本可以完全省略它，这样，<span class="math inline">\(z_0\)</span> 就会成为交换子 <span class="math inline">\(abAB\)</span> 的不动点。通过使用一个将 <span class="math inline">\(z_0\)</span> 移动到 1的映射进行共轭，祖母为她的图像增添了一点额外的风格。如果你想更好地理解她的配方，不妨尝试完成项目8.1 和 8.2。</p><h1 id="lets-play-gently-at-first">Let’s play (gently at first)</h1><figure id="fig-8.2"><img src="/images/indra/fig-8.2.jpg" width="500" alt="Figure 8.2. Varying parameters: from t_a = t_b = 3 to t_a = t_b = 2. We wrote down the generators for the group in frame (iii) in Project 6.5, and frame (vi) is the Apollonian gasket. 图 8.2. 参数变化：从 t_a = t_b = 3 到 t_a = t_b = 2。我们在项目 6.5 的框架 (iii) 中写下了该群的生成元，而框架 (vi) 则是阿波罗尼亚垫片。"><figcaption aria-hidden="true">Figure 8.2. Varying parameters: from<span class="math inline">\(t_a = t_b = 3\)</span> to <span class="math inline">\(t_a = t_b = 2\)</span>. We wrote down thegenerators for the group in frame (iii) in Project 6.5, and frame (vi)is the Apollonian gasket.<br>图 8.2. 参数变化：从 <span class="math inline">\(t_a = t_b = 3\)</span>到 <span class="math inline">\(t_a = t_b = 2\)</span>。我们在项目 6.5的框架 (iii) 中写下了该群的生成元，而框架 (vi)则是阿波罗尼亚垫片。</figcaption></figure><div class="statement simple plain unnumbered"><p>To ensure all is working smoothly and to gain familiarity with whatto expect from Grandma’s recipe, we are going start our play rathergently with groups in which the traces of the generators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are both real.</p><p>Figure 8.2 shows the outcome of our first experiment. We made it byrunning the program many times, keeping the two traces <span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span> equal and real-valued, sliding downfrom the initial value 3 to the final value 2. These groups can be madeby pairing tangent circles, and we have shown the Schottky circles. Inthe first three frames, the limit set is just the unit circle and thegroup is Fuchsian. The arcs rotate as the traces decrease until theyreach the symmetrical position in frame (iii). You may recognize thispicture - it is exactly the group in frame (vi) on p.&nbsp;176. As we movepast the symmetric position, something dramatic happens. The limit setcrinkles up and the group has become quasifuchsian. As we keep moving,the lowermost limit points (these are actually the fixed points <span class="math inline">\(\overline{b},\overline{B}\)</span>) become cornerswith evermore pronounced angles, until finally they come together like acrab’s pincers, chopping the region enclosed by the limit set into amyriad of tiny disks. This last frame should look familiar too - we havearrived at our old friend the Apollonian gasket from Chapter 7!</p></div><p>为了确保一切顺利，并且熟悉祖母食谱的“味道”，我们打算从轻松的开始，先从那些生成元<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的迹都是实数的群开始。</p><p>图 8.2展示了我们第一次实验的结果。我们通过多次运行程序获得了这个结果，始终保持两个迹<span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span> 相等且为实数值，并让它们从初始值 3缓慢滑动至最终值 2。这样的群体可以通过配对相切的圆来构造，而我们标出了Schottky 圆。</p><p>在最初的三个画面中，极限集仅仅是单位圆，群是 Fuchsian群。随着迹的减小，弧线缓慢旋转，直到它们在画面 (iii)中达到了对称位置。你可能会觉得这幅图有些眼熟——它正是第 176 页画面 (vi)中的那个群。</p><p>当我们越过对称位置时，戏剧性的变化发生了。极限集皱缩起来，群变成了拟Fuchsian 群。继续移动时，最下方的极限点（实际上是不动点 <span class="math inline">\(\overline{b}\)</span> 和 <span class="math inline">\(\overline{B}\)</span>）逐渐变得越来越尖锐，最终它们像螃蟹的钳子一样夹拢在一起，将极限集所围成的区域切割成无数个微小的圆盘。</p><p>这最后一帧你一定也觉得眼熟——我们回到了第七章中那个熟悉的老朋友——阿波罗尼奥斯垫片！</p><div id="note-8.1" class="statement sta_note_8_1__grandma_s_symmetry definition unnumbered"><p><span class="statement-heading"><span class="statement-label">Note8.1: Grandma’s symmetry</span>：</span><span class="statement-spah"></span><strong>注解 8.1：外婆的对称性</strong></p><p>Suppose <span class="math inline">\(M\)</span> is a matrix whosediagonal entries are equal, in other words with the special form <span class="math display">\[M = \begin{pmatrix} r &amp; s \\ t &amp; r\end{pmatrix}.\]</span> Such transformations have a special symmetry,encoded in the equation <span class="math display">\[-M(-z) =\frac{r(-z) + s}{t(-z) + r} = \frac{rz - s}{-tz + r} =M^{-1}(z).\]</span> To interpret this equation, write <span class="math inline">\(j\)</span> for the 180° rotation <span class="math inline">\(z \mapsto -z\)</span>. Using the relation <span class="math inline">\(j^{-1} = j\)</span>, this equation says that <span class="math inline">\(jMj^{-1} = M^{-1}\)</span>. In other words,conjugating the transformation <span class="math inline">\(M\)</span> by180° rotation about <span class="math inline">\(O\)</span> carries <span class="math inline">\(M\)</span> to <span class="math inline">\(M^{-1}\)</span>.</p><p>In Grandma’s recipe, both <span class="math inline">\(a\)</span> and<span class="math inline">\(ab\)</span> have this property, which means<span class="math inline">\(jaj = A\)</span> and <span class="math inline">\(jabj = BA\)</span>. Since <span class="math inline">\(j\)</span> is its own inverse, these imply <span class="math inline">\(jAj = a\)</span> and <span class="math inline">\(jBAj = ab\)</span>. By combining these relations,we can show that any word in <span class="math inline">\(a\)</span>,<span class="math inline">\(b\)</span>, <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is conjugated by <span class="math inline">\(j\)</span> into some other word in <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(A\)</span>and <span class="math inline">\(B\)</span>. That is, conjugation by<span class="math inline">\(j\)</span> does not change the group <span class="math inline">\(G\)</span> generated by <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, nor does it change the completecollection of infinite words in the generators. That is enough to tellus that the limit set of <span class="math inline">\(G\)</span> isunchanged by the transformation <span class="math inline">\(j\)</span>.As an example, consider applying <span class="math inline">\(j\)</span>to the infinite word <span class="math inline">\(abaBA\cdots\)</span>:</p><p><span class="math display">\[jabaBA \cdots = jabj jaj jBAj \cdots =BA A ab \cdots.\]</span></p><p>设 <span class="math inline">\(M\)</span>是一个对角元素相等的矩阵，具体形式为 <span class="math display">\[M=\begin{pmatrix} r &amp; s \\ t &amp; r\end{pmatrix}.\]</span>这种变换具有一种特殊的对称性，它可以通过以下等式来描述： <span class="math display">\[-M(-z) = \frac{r(-z) + s}{t(-z) + r} = \frac{rz -s}{-tz + r} = M^{-1}(z).\]</span></p><p>要理解这个等式，设 <span class="math inline">\(j\)</span> 表示将<span class="math inline">\(z\)</span> 映射到 <span class="math inline">\(-z\)</span> 的 180° 旋转。利用 <span class="math inline">\(j^{-1} = j\)</span> 这一性质，上述等式表明 <span class="math inline">\(jMj^{-1} = M^{-1}\)</span>。换句话说，对变换 <span class="math inline">\(M\)</span> 施加以原点为中心的 180°旋转，其结果是将 <span class="math inline">\(M\)</span> 变为其逆变换<span class="math inline">\(M^{-1}\)</span>。</p><p>在外婆的配方中，<span class="math inline">\(a\)</span> 和 <span class="math inline">\(ab\)</span> 都具有这一性质，这意味着 <span class="math inline">\(jaj = A\)</span>，<span class="math inline">\(jabj= BA\)</span>。由于 <span class="math inline">\(j\)</span>是它自身的逆映射，这些关系进一步推出 <span class="math inline">\(jAj =a\)</span>，以及 <span class="math inline">\(jBAj = ab\)</span>。</p><p>通过结合这些关系，我们可以证明，任何由 <span class="math inline">\(a,b,A,B\)</span> 组成的词在经过 <span class="math inline">\(j\)</span> 的共轭后，仍然是由 <span class="math inline">\(a,b,A,B\)</span> 构成的某个词。也就是说，<span class="math inline">\(j\)</span> 的共轭不会改变由 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 生成的群 <span class="math inline">\(G\)</span>，也不会改变由这些生成元构成的所有无限词的完整集合。这足以说明，群<span class="math inline">\(G\)</span> 的极限集在变换 <span class="math inline">\(j\)</span> 作用下保持不变。</p><p>举个例子，考虑将 <span class="math inline">\(j\)</span> 作用于无限词<span class="math inline">\(abaBA\cdots\)</span>： <span class="math display">\[jabaBA \cdots = jabj jaj jBAj \cdots = BA A ab\cdots.\]</span></p></div><figure id="fig-8.3"><img src="/images/indra/fig-8.3.jpg" width="500" alt="Figure 8.3. The program hits chaos. The left side is the result of running the DFS algorithm for just a short length of time; on the right we had slightly more patience. The picture resulting from running the program forever (that is, without the safety cut-off lev_max) is slightly less interesting. Groups whose limit set look like this are called non-discrete. 图 8.3 程序进入混沌状态。左侧是 DFS 算法运行短短一段时间的结果；右侧则是我们稍作耐心等待后得到的成果。如果让程序一直运行下（即不设安全上限 lev_max），得到的图像就会显得略微单调。那些极限集呈现这种形态的群体，被称为非离散群。"><figcaption aria-hidden="true">Figure 8.3. The program hits chaos. Theleft side is the result of running the DFS algorithm for just a shortlength of time; on the right we had slightly more patience. The pictureresulting from running the program forever (that is, without the safetycut-off lev_max) is slightly less interesting. Groups whose limit setlook like this are called non-discrete.<br>图 8.3 程序进入混沌状态。左侧是 DFS算法运行短短一段时间的结果；右侧则是我们稍作耐心等待后得到的成果。如果让程序一直运行下（即不设安全上限lev_max），得到的图像就会显得略微单调。那些极限集呈现这种形态的群体，被称为非离散群。</figcaption></figure><div class="statement simple plain unnumbered"><p>What happens if we decrease the traces just a little bit further andtry <span class="math inline">\(t_a = t_b = 1.9\)</span>? <em>Warning,warning, danger, danger</em>! The Schottky circles will start tooverlap, and it becomes not at all clear what to expect. You can seewhat we are worried about in Figure 8.3. In this picture, we chose apretty large cut-off value <code>epsilon = 0.1</code> in comparison tothe frame size, 2.2 by 2.2. In contrast to the previous pictures, youcan actually see the line segments drawn by the DFS program. Some ofthem are actually much larger than <code>epsilon</code>. That is becauseno matter how far we go down the branch, limit points which are supposedto be neighbours never get truly close. The branch is terminated only bythe built-in maximum depth levjnax. It is lucky we built in thissafeguard; otherwise our program would be stuck running a never endingloop. The truth is, Figure 8.3 should be a solid black square.</p></div><p>如果我们将迹的值再稍微减少一些，并尝试设定 <span class="math inline">\(t_a = t_b =1.9\)</span>，会发生什么呢？警告，警告，危险，危险！肖特基圆开始重叠，情况变得完全不可预测。你可以在图8.3 中看到我们担心的情况。</p><p>在这幅图中，我们选择了一个相对于帧尺寸（2.2×2.2）来说相当大的阈值<code>epsilon = 0.1</code>。与之前的图像不同，你现在可以看到 DFS程序绘制的线段。其中一些线段的长度实际上远远超过了<code>\epsilon</code>。这是因为无论我们沿着分支向下走多远，原本应相邻的极限点始终无法真正靠近。分支的终止仅由内置的最大深度<code>lev_max</code> 控制。</p><p>幸运的是，我们设置了这个保护机制，否则程序将陷入永无止境的循环。事实上，图8.3 本应是一块实心的黑色方块。</p><div class="statement simple plain unnumbered"><p>The groups in Figure 8.2 are actually conjugates of the groups madefrom our original circle pairing recipe on p.170 in Chapter 6. Toseethis, let <span class="math inline">\(x = u = t_a/2\)</span>. Theconnection between the two constructions is shown in Figure 8.4 whichwas drawn using Grandma’s recipe for the quasifuchsian group with <span class="math inline">\(t_a = t_b = 2.2\)</span>. Our original recipe gaveroughly equal weight to each of the four generators <span class="math inline">\(a\)</span>, <span class="math inline">\(A\)</span>, <span class="math inline">\(b\)</span>and <span class="math inline">\(B\)</span>. By contrast, Grandma’srecipe emphasizes symmetry relative to the alternative generators <span class="math inline">\(a\)</span> and <span class="math inline">\(ab\)</span>. The word tree comes out distorted sothat words beginning with <span class="math inline">\(a\)</span> occupyhalf the picture, the other half being divided among words beginningwith the other three letters <span class="math inline">\(A\)</span>,<span class="math inline">\(b\)</span> and <span class="math inline">\(B\)</span>. The basic tile in Figure 8.4 is theone which has one side of each colour. The red side is part of thecircle <span class="math inline">\(C_a\)</span>, the blue side of <span class="math inline">\(C_b\)</span>, and so on. Its vertices are thefixed points of the four commutators <span class="math inline">\(abAB\)</span>, <span class="math inline">\(bABA\)</span>, <span class="math inline">\(ABab\)</span> and <span class="math inline">\(BabA\)</span>. As you can see, the red part isexactly half the limit set. The other half can be obtained by reflectingthrough the origin, using the map <span class="math inline">\(j : z\mapsto -z\)</span>. (This trick was in part the original motivation forGrandma’s normalization: we had only to plot a quarter of the limitpoints, and by reflecting got the rest of the picture for free.)</p></div><p>图 8.2 中的群实际上是我们在第 6 章第 170页使用原始圆配对方法构造的群的共轭群。为了理解这一点，设 <span class="math inline">\(x = u = t_a / 2\)</span>。两种构造之间的联系如图8.4 所示，该图是按照祖母的拟富克斯群配方绘制的，其中 <span class="math inline">\(t_a = t_b = 2.2\)</span>。</p><p>我们的原始配方对四个生成元 <span class="math inline">\(a\)</span>、<span class="math inline">\(A\)</span>、<span class="math inline">\(b\)</span>和 <span class="math inline">\(B\)</span>赋予了大致相等的权重。而与此不同，祖母的配方则更加强调相对于替代生成元<span class="math inline">\(a\)</span> 和 <span class="math inline">\(ab\)</span>的对称性。结果，单词树出现了扭曲，导致以字母 <span class="math inline">\(a\)</span>开头的单词占据了图像的一半，另一半则被以字母 <span class="math inline">\(A\)</span>、<span class="math inline">\(b\)</span>和 <span class="math inline">\(B\)</span> 开头的单词所瓜分。</p><p>图 8.4 中的基本瓷砖是每条边各具一种颜色的那一块。红色边属于圆 <span class="math inline">\(C_a\)</span> 的一部分，蓝色边属于圆 <span class="math inline">\(C_b\)</span>的一部分，依此类推。该瓷砖的顶点是四个交换子 <span class="math inline">\(abAB\)</span>、<span class="math inline">\(bABA\)</span>、<span class="math inline">\(ABab\)</span> 和 <span class="math inline">\(BabA\)</span>的不动点。如你所见，红色部分恰好是极限集的一半。另一半可以通过使用映射<span class="math inline">\(j : z \mapsto -z\)</span>对原点进行反射得到。（这一技巧在某种程度上正是 Grandma归一化的原始动机：我们只需绘制四分之一的极限点，然后通过反射即可免费获得图像的其余部分。）</p><figure id="fig-8.4"><img src="/images/indra/fig-8.4.jpg" width="500" alt="Figure 8.4. The anatomy of the limit set for the group specified by Grandma’s recipe with t_a = t_b = 2.2. The different colours show the pieces of the limit set that begin with different one letter prefixes: red for those beginning with a, green for A, blue for b, and yellow for B. We have marked certain limit points by their infinite words, for example \overline{a} marks the attracting fixed point of a. Since it is represented by the infinite word aaaa\cdots, it appears in the red section. This section also contains the fixed point of aba^{-1} whose infinite word is a\overline{b} = abbbb\cdots, and aBa^{-1} with infinite word a\overline{B} = aBBBB\cdots. Notice the various fixed points which seem to be coming together as the traces t_a and t_b get near 2. 图 8.4. 按照“奶奶的配方”中设定的群（参数 t_a = t_b = 2.2）生成的极限集的剖析图。不同颜色表示以不同单字母前缀开头的极限集部分：红色对应以 a 开头的部分，绿色对应以 A 开头的部分，蓝色对应以 b 开头的部分，黄色对应以 B 开头的部分。我们用它们的无穷字标出了某些极限点。例如，\overline{a} 表示 a 的吸引不动点。由于它的无穷字是 aaaa\cdots，因此出现在红色区域内。该区域还包含 aba^{-1} 的不动点，其无穷字为 a\overline{b} = abbbb\cdots，以及 aBa^{-1} 的不动点，其无穷字为 a\overline{B} = aBBBB\cdots。请注意，随着迹数 t_a 和 t_b 接近 2，某些不动点似乎逐渐聚集在一起。"><figcaption aria-hidden="true">Figure 8.4. The anatomy of the limit setfor the group specified by Grandma’s recipe with <span class="math inline">\(t_a = t_b = 2.2\)</span>. The different coloursshow the pieces of the limit set that begin with different one letterprefixes: red for those beginning with <span class="math inline">\(a\)</span>, green for <span class="math inline">\(A\)</span>, blue for <span class="math inline">\(b\)</span>, and yellow for <span class="math inline">\(B\)</span>. We have marked certain limit points bytheir infinite words, for example <span class="math inline">\(\overline{a}\)</span> marks the attracting fixedpoint of <span class="math inline">\(a\)</span>. Since it is representedby the infinite word <span class="math inline">\(aaaa\cdots\)</span>, itappears in the red section. This section also contains the fixed pointof <span class="math inline">\(aba^{-1}\)</span> whose infinite word is<span class="math inline">\(a\overline{b} = abbbb\cdots\)</span>, and<span class="math inline">\(aBa^{-1}\)</span> with infinite word <span class="math inline">\(a\overline{B} = aBBBB\cdots\)</span>. Notice thevarious fixed points which seem to be coming together as the traces<span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span> get near 2.<br>图 8.4. 按照“奶奶的配方”中设定的群（参数 <span class="math inline">\(t_a= t_b =2.2\)</span>）生成的极限集的剖析图。不同颜色表示以不同单字母前缀开头的极限集部分：红色对应以<span class="math inline">\(a\)</span> 开头的部分，绿色对应以 <span class="math inline">\(A\)</span> 开头的部分，蓝色对应以 <span class="math inline">\(b\)</span> 开头的部分，黄色对应以 <span class="math inline">\(B\)</span>开头的部分。我们用它们的无穷字标出了某些极限点。例如，<span class="math inline">\(\overline{a}\)</span> 表示 <span class="math inline">\(a\)</span> 的吸引不动点。由于它的无穷字是 <span class="math inline">\(aaaa\cdots\)</span>，因此出现在红色区域内。该区域还包含<span class="math inline">\(aba^{-1}\)</span> 的不动点，其无穷字为 <span class="math inline">\(a\overline{b} = abbbb\cdots\)</span>，以及 <span class="math inline">\(aBa^{-1}\)</span> 的不动点，其无穷字为 <span class="math inline">\(a\overline{B} =aBBBB\cdots\)</span>。请注意，随着迹数 <span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span> 接近2，某些不动点似乎逐渐聚集在一起。</figcaption></figure><h1 id="the-fun-begins-traces-go-complex">The fun begins: traces gocomplex</h1><figure id="fig-8.5"><img src="/images/indra/fig-8.5.jpg" width="500" alt="Figure 8.5. Testing some complex values of the traces. For comparison we have made the viewing window the same in all four frames. 图 8.5 测试一些复杂值的轨迹。为了便于比较，我们在所有四个帧中设置了相同的观察窗口。"><figcaption aria-hidden="true">Figure 8.5. Testing some complex valuesof the traces. For comparison we have made the viewing window the samein all four frames.<br>图 8.5测试一些复杂值的轨迹。为了便于比较，我们在所有四个帧中设置了相同的观察窗口。</figcaption></figure><div class="statement simple plain unnumbered"><p>Our play has been kept artificially gentle by restricting to examplesin which <span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span> are both real. Such groups alwayscome equipped with a chain of four tangent Schottky circles, so plottingtheir limit sets is really nothing new. The real fun starts when ta andtb go properly complex. Figure 8.5 shows the results of gingerly testingthe waters. What were the Schottky circles appear to have gone haywire,but at least the limit sets are still loops.</p></div><p>为了保持温和的氛围，我们仅选取了 <span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span>都为实数的例子。这样的群总是配备有一条由四个切线 Schottky圆组成的链条，因此，绘制它们的极限集实际上并不算什么新鲜事。真正有趣的部分出现在当<span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span> 变为复数时。图 8.5展示了我们小心翼翼地试水的结果。原本是 Schottky圆的部分似乎已经乱成一团，但至少极限集仍然是环状的。</p><div class="statement simple plain unnumbered"><p>The curling and twisting you can see in these limit sets is caused bytiny spiralling motions of loxodromic transformations. Transformationswith non-real traces are always loxodromic, so as soon as we make <span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span> complex, we can expect curling tooccur. The amount of curling of a transformation depends not so much onthe imaginary part of its trace as on the tightness of the spiral motionnear its fixed points. Referring back to Chapter 3, you will see thespiral is tightly coiled if the multiplier is near 1, so the trace isnear 2, and if in addition the imaginary part is comparatively small.You can see this in evidence in the substantial curling in the last twoframes in Figure 8.5, where <span class="math inline">\(t_a\)</span> and<span class="math inline">\(t_b\)</span> are near 2 and only slightlycomplex. There are no Schottky circles, but on the <code>inside</code>,we have drawn red circular arcs meeting at the fixed points of the fourbasic commutators. (We made the first arc perpendicular to the directionof the parabolic at the fixed point.) You can tell they are no longerpieces of Schottky circles, because Schottky circles never intersect.You might wonder if the same group might be constructed as a Schottkygroup starting from a different set of circles, and with differentgenerators doing the pairings. Whether or not this is possible, we don’tknow.</p></div><p>你在这些极限集上看到的弯曲和扭曲，是由斜航型变换的小螺旋运动引起的。具有非实迹的变换总是斜航型变换，因此，只要我们将<span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span>设为复数，就可以预见到弯曲现象的出现。变换的弯曲程度不仅仅取决于迹的虚部，更依赖于其不动点附近螺旋运动的紧密程度。回到第三章，你会发现当乘数接近1 时，螺旋会紧密盘绕，此时迹接近2，且如果虚部相对较小，这种情况更加明显。你可以在图 8.5的最后两帧中看到这一现象，这里 <span class="math inline">\(t_a\)</span>和 <span class="math inline">\(t_b\)</span> 接近 2 且仅稍微为复数。没有Schottky圆，但在“内部”，我们画出了红色的圆弧，它们在四个基本交换子点的固定点相交。（我们使第一条圆弧垂直于固定点的抛物线方向。）你可以判断它们不再是Schottky 圆的部分，因为 Schottky圆是永远不会相交的。你可能会好奇，是否可以从一组不同的圆出发，构造出一个Schottky 群，并使用不同的生成元来完成配对。我们不知道这是否可能。</p><figure id="fig-8.6"><img src="/images/indra/fig-8.6.jpg" width="500" alt="Figure 8.6. Dr.&nbsp;Stickler blown about inside the limit set of a quasifuchsian group with t_a=t_b=1.91+0.05i. . You can see a full view of this limit set in Figure 8.1. We made this picture by implementing a tiling type plot with the prostrate Dr.&nbsp;Stickler as the initial seed. 图 8.6. 斯蒂克勒博士在一个拟福克斯群的极限集内被吹动，参数 t_a=t_b=1.91+0.05i。你可以在图 8.1 中看到这个极限集的完整视图。我们通过实现一种镶嵌类型的图形，并以斯蒂克勒博士躺倒的形象作为初始种子，制作了这张图片。"><figcaption aria-hidden="true">Figure 8.6. Dr.&nbsp;Stickler blown aboutinside the limit set of a quasifuchsian group with <span class="math inline">\(t_a=t_b=1.91+0.05i\)</span>. . You can see a fullview of this limit set in Figure 8.1. We made this picture byimplementing a tiling type plot with the prostrate Dr.&nbsp;Stickler as theinitial seed.<br>图 8.6. 斯蒂克勒博士在一个拟福克斯群的极限集内被吹动，参数 <span class="math inline">\(t_a=t_b=1.91+0.05i\)</span>。你可以在图 8.1中看到这个极限集的完整视图。我们通过实现一种镶嵌类型的图形，并以斯蒂克勒博士躺倒的形象作为初始种子，制作了这张图片。</figcaption></figure><div class="statement simple plain unnumbered"><p>As you can see, all these groups are still quasifuchsian, meaningthat the limit set is a connected curve which doesn’t cross itself andwhich divides the plane into an inside’ and ‘outside’. These are thefirst groups whose limit sets we genuinely could not have drawn usingour old Schottky circle algorithm. It would be nice to explore theregion inside the limit set, but since there are no Schottky circles towork with, it can become a very tricky problem to find suitable tiles.Undeterred, we blew up a small part of a nice limit set with <span class="math inline">\(t_a = t_b= 1.91 + 0.05i\)</span> and setDr.&nbsp;Stickler lying flat on his back in red on the righthand side. Youcan see him in Figure 8.6 spinning around, carried into every nook andcranny, so that there is exactly one Dr.&nbsp;Stickler for every word in thegroup.</p></div><p>正如你所看到的，这些群仍然是准福克群（quasifuchsian），意味着其极限集是一个连通曲线，既不交叉自身，也将平面分成了“内部”和“外部”两部分。这些是我们通过旧的Schottky圆算法，确实无法画出的第一个群体极限集。虽然我们很想探索极限集内部的区域，但由于没有Schottky圆可以使用，找到合适的瓷砖就变成了一个非常棘手的问题。尽管如此，我们依然不气馁，放大了一个漂亮的极限集的一小部分，设定了<span class="math inline">\(t_a = t_b = 1.91 +0.05i\)</span>，并让斯蒂克勒博士躺在右侧的平面上，用红色标出。你可以在图 8.6中看到他旋转的样子，他被带入每一个角落与缝隙中，所以每一个群体中的每个词语都对应着一个斯蒂克勒博士。</p><figure id="fig-8.7"><img src="/images/indra/fig-8.7.jpg" width="500" alt="Figure 8.7. All the tiles are obtained from the red one by applying words in the group. What is the red tile? In Figure 8.6, note that the red Dr.&nbsp;Stickler is larger than all his copies. We could try putting a miniscule Dr.&nbsp;Stickler anywhere and see if he is larger than his copies. The places where this happens are the points of the red tile. 图 8.7 中，所有瓷砖都是通过对红色瓷砖应用群中的词语得到的。红色瓷砖是什么？在图 8.6 中，注意红色的 Dr.&nbsp;Stickler 比所有复制品都要大。我们可以尝试在任何地方放置一个微小的 Dr.&nbsp;Stickler，看看他是否比他的复制品大。这种情况发生的地方就是红色瓷砖的点。"><figcaption aria-hidden="true">Figure 8.7. All the tiles are obtainedfrom the red one by applying words in the group. What is the red tile?In Figure 8.6, note that the red Dr.&nbsp;Stickler is larger than all hiscopies. We could try putting a miniscule Dr.&nbsp;Stickler anywhere and seeif he is larger than his copies. The places where this happens are thepoints of the red tile.<br>图 8.7中，所有瓷砖都是通过对红色瓷砖应用群中的词语得到的。红色瓷砖是什么？在图8.6 中，注意红色的 Dr.&nbsp;Stickler比所有复制品都要大。我们可以尝试在任何地方放置一个微小的Dr.&nbsp;Stickler，看看他是否比他的复制品大。这种情况发生的地方就是红色瓷砖的点。</figcaption></figure><div class="statement simple plain unnumbered"><p>In Figure 8.7 we have actually found a tiling for a quasifuchsiangroup with <span class="math inline">\(t_a = 2 + 0.1i, t_b = 3\)</span>.Notice that the tiles are no longer four- but six-sided. As ever, thedifferent tiles are carried onto each other by the transformations inthe group. They get exceedingly skinny in the middle: if we varied ourparameters just a little bit each of these tiles would fall apart intotwo halves. We found this particular tiling by a completely differentmethod explained briefly in the caption.</p></div><p>在图 8.7 中，我们实际上为一个准福克斯群找到了一个铺砖，参数为 <span class="math inline">\(t_a = 2 + 0.1i\)</span>，<span class="math inline">\(t_b =3\)</span>。注意，这些瓷砖不再是四边形，而是六边形。正如往常一样，不同的瓷砖通过群中的变换相互映射。它们在中间变得异常狭长：如果我们稍微调整一下参数，每一块瓷砖都会裂成两半。我们通过一种完全不同的方法找到了这个特殊的铺砖，简要的解释见图注。</p><figure id="fig-8.8"><img src="/images/indra/fig-8.8.jpg" width="500" alt="Figure 8.8. Our first probe. In this sequence, t_b=3 and t_a=x+0.05i with x varying from 3 down to 1.9. 图 8.8. 我们的第一次探测。在这个序列中，t_b = 3，t_a = x + 0.05i，其中 x 从 3 变化到 1.9。"><figcaption aria-hidden="true">Figure 8.8. Our first probe. In thissequence, <span class="math inline">\(t_b=3\)</span> and <span class="math inline">\(t_a=x+0.05i\)</span> with <span class="math inline">\(x\)</span> varying from 3 down to 1.9.<br>图 8.8. 我们的第一次探测。在这个序列中，<span class="math inline">\(t_b= 3\)</span>，<span class="math inline">\(t_a = x + 0.05i\)</span>，其中<span class="math inline">\(x\)</span> 从 3 变化到 1.9。</figcaption></figure><div class="statement simple plain unnumbered"><p>The curling in the last two frames of Figure 8.5 piqued our interest,hinting at directions which might be interesting to explore. Just howmuch curling is possible? The interest seems to centre on traces near 2,but ever so slightly complex. To investigate, we shall run an experimentin which we fix the trace <span class="math inline">\(t_b\)</span>safely equal 3, and then let <span class="math inline">\(t_a\)</span>run through values <span class="math inline">\(x + 0.05i\)</span>, where<span class="math inline">\(x\)</span> is a real number which starts at3 and slowly decreases to some dangerous transitional value, as yetunknown. Figure 8.8 shows the preliminary results. The first frame isjust a slightly wobbly circle. The second and third frames show somebumps forming, with the first hints of spiralling in the third frame at<span class="math inline">\(x = 2\)</span>. From the chaotic fourthframe we deduce that somewhere between <span class="math inline">\(x =2.0\)</span> and <span class="math inline">\(x = 1.9\)</span>, westepped over the boundary. The live version of the last frame is moreinteresting: the DFS algorithm frantically criss-crosses the picturetrying to draw a solid black square. To locate the transition point moreexactly, in Figure 8.9 we decrease <span class="math inline">\(x\)</span> by finer increments from 2.0 to 1.9.From 1.97 to 1.94 to 1.91, you can see the bumps on the limit setdeveloping into pronounced and ever more tightly whirling spirals. Weknow from our earlier probe that the boundary lies above <span class="math inline">\(x = 1.90\)</span>; when we ever-so-carefullystepped to 1.905, the DFS plot tried to fake sanity for a while, untilits turbulent behaviour at last manifested and we terminated theprogram, allowing us at least to see some of the spirals that are stillevident. We have pinned down the transition to madness somewhere between<span class="math inline">\(x = 1.91\)</span> and 1.905.</p></div><p>图 8.5的最后两帧中出现的弯曲引起了我们的兴趣，暗示了一些可能值得探索的方向。那么，究竟有多少弯曲是可能的呢？兴趣似乎集中在接近2的轨迹上，但又略微带有复数特性。为了探讨这一点，我们进行了一次实验，将轨迹<span class="math inline">\(t_b\)</span> 固定为安全的 3，然后让 <span class="math inline">\(t_a\)</span> 通过值 <span class="math inline">\(x+ 0.05i\)</span> 变化，其中 <span class="math inline">\(x\)</span>是一个实数，起始值为 3，并逐渐减小到某个尚未确定的危险过渡值。图 8.8展示了初步结果。第一帧只是一个略微晃动的圆形。第二帧和第三帧显示出一些隆起的形成，第3 帧在 <span class="math inline">\(x = 2\)</span>时出现了螺旋的初步迹象。从混乱的第四帧中，我们推断出在 <span class="math inline">\(x = 2.0\)</span> 到 <span class="math inline">\(x= 1.9\)</span>之间的某个位置，我们跨越了边界。最后一帧的实时版本更加有趣：DFS算法疯狂地交叉扫描图像，试图绘制一个实心的黑色正方形。为了更精确地定位过渡点，在图8.9 中，我们将 <span class="math inline">\(x\)</span> 从 2.0 到 1.9以更小的增量减少。从 1.97 到 1.94 再到1.91，你可以看到极限集上的隆起逐渐发展成明显且越来越紧密旋转的螺旋。我们从早前的探索中知道，边界位于<span class="math inline">\(x = 1.90\)</span> 之上；当我们小心翼翼地走到1.905 时，DFS图尝试保持“理智”了一段时间，直到它的动荡行为最终显现出来，我们终止了程序，至少让我们看到了仍然明显存在的一些螺旋。我们已经将过渡到混乱的边界定位在<span class="math inline">\(x = 1.91\)</span> 和 1.905 之间。</p><figure id="fig-8.9"><img src="/images/indra/fig-8.9.jpg" width="500" alt="Figure 8.9. In this refined probe, t_b = 3 and t_a = x + 0.05i with x varying from 1.97 down to 1.905. In (iv), the program was terminated prematurely, when the erratic nature of the plot became clear. 图 8.9. 在这个改进的探针中，t_b = 3，t_a = x + 0.05i，其中 x 从 1.97 变化到 1.905。在 (iv) 中，当图像的不规则性变得明显时，程序被提前终止。"><figcaption aria-hidden="true">Figure 8.9. In this refined probe, <span class="math inline">\(t_b = 3\)</span> and <span class="math inline">\(t_a = x + 0.05i\)</span> with <span class="math inline">\(x\)</span> varying from 1.97 down to 1.905. In(iv), the program was terminated prematurely, when the erratic nature ofthe plot became clear.<br>图 8.9. 在这个改进的探针中，<span class="math inline">\(t_b =3\)</span>，<span class="math inline">\(t_a = x + 0.05i\)</span>，其中<span class="math inline">\(x\)</span> 从 1.97 变化到 1.905。在 (iv)中，当图像的不规则性变得明显时，程序被提前终止。</figcaption></figure><h1 id="transition-to-madness">Transition to madness</h1><div class="statement simple plain unnumbered"><p>We have now three times bumped into places where our limit set plothas gone wild. What is going on? As we warned at the outset, there is noreason to expect that our limit set plot, bereft of the Schottkycircles, will produce anything reasonable at all. The greater miracle,perhaps, is that it ever does! What is happening here is this. If youmultiply a large number of matrices together, then you would expect thatthe resulting matrix product would automatically get ‘large’. In thegroups which produce reasonable limit sets this is certainly the case.What is going wrong when the limit set goes haywire is that a word inthe group which is a long matrix product of many generators unexpectedlyturns out to be actually very ‘small’. The matrices cancel in amysterious way, so the manner in which this particular group elementmoves points around in the plane is not at all what you might expect. Ofcourse, not all entries can be near 0 because the determinant of anymatrix in our group is always to equal to 1. So what we mean by sayingthat a matrix is ‘small’ is that it is very near the identity matrix<span class="math inline">\(I\)</span>. From this point of view, <span class="math inline">\(I\)</span> is the ‘smallest’ matrix and we measurehow large a matrix is by measuring the distance of its entries fromthose of <span class="math inline">\(\begin{pmatrix} 1 &amp; 0 \\ 0&amp; 1 \end{pmatrix}\)</span>. Groups for which large products stayaway from <span class="math inline">\(I\)</span> are calleddiscrete.</p></div><p>我们现在已经遇到三次极限集图形异常的情况。这是怎么回事呢？正如我们一开始所警告的，完全没有理由期望没有Schottky圆的极限集图形会产生任何合理的结果。也许更大的奇迹是，它居然偶尔会产生一些合理的东西！现在发生的情况是这样的。如果你将大量矩阵相乘，那么你会期望结果矩阵的乘积会自动变得“很大”。在那些能够产生合理极限集的群体中，这种情况无疑是成立的。而当极限集出现异常时，问题出在某个群中的一个词，它是许多生成元的长矩阵积，结果竟然变得非常“小”。这些矩阵以一种神秘的方式相互抵消，因此这个特定群元素在平面上移动点的方式与你预期的完全不同。当然，并非所有的元素都可以接近0，因为我们群中任何矩阵的行列式总是等于1。那么，当我们说一个矩阵是“小”的时候，指的是它非常接近单位矩阵 <span class="math inline">\(I\)</span>。从这个角度来看，<span class="math inline">\(I\)</span>是“最小”的矩阵，我们通过测量矩阵的元素与 <span class="math inline">\(\begin{pmatrix} 1 &amp; 0 \ 0 &amp; 1\end{pmatrix}\)</span> 的元素之间的距离来衡量矩阵的大小。那些大乘积远离<span class="math inline">\(I\)</span> 的群称为离散群。</p><div class="statement simple plain unnumbered"><p>You can look for discreteness in our plots by seeing how close <span class="math inline">\(M(z)\)</span> can get to <span class="math inline">\(z\)</span>, for any point <span class="math inline">\(z\)</span> in the plane. In the groups we havestudied so far, you can always find tiles which cover all of theordinary set, that is, all parts of the plane not occupied by the limitset itself. If you sit at a point <span class="math inline">\(z\)</span>in the middle of one tile, no points in any other tile can be too close,because no point can be nearer to you than the edges of your tile. Butif <span class="math inline">\(M\)</span> was very near to <span class="math inline">\(I\)</span>, then <span class="math inline">\(M(z)\)</span> would be very near to <span class="math inline">\(I(z) = z\)</span>. This shows that very nastycancellations can never occur as long as there are some ‘limit set free’regions in the plane which can be covered by tiles.</p></div><p>可以通过观察我们图表中的离散性，来查看平面上任意点 <span class="math inline">\(z\)</span> 能有多接近 <span class="math inline">\(M(z)\)</span>。在我们目前研究的群组中，你总能找到一些瓷砖，覆盖整个普通集，即覆盖平面上那些没有被极限集本身占据的部分。如果你坐在某个瓷砖中间的点<span class="math inline">\(z\)</span>，那么其他瓷砖上的任何点都不会离你太近，因为没有点能比你的瓷砖边缘更接近你。但如果<span class="math inline">\(M\)</span> 非常接近 <span class="math inline">\(I\)</span>，那么 <span class="math inline">\(M(z)\)</span> 就会非常接近 <span class="math inline">\(I(z) =z\)</span>。这表明，只要平面上存在一些可以被瓷砖覆盖的“无极限集”区域，就永远不会发生非常糟糕的抵消现象。</p><div class="statement simple plain unnumbered"><p>It turns out that there is yet another layer of complication becausethere are groups for which there is no ordinary set at all but which arestill discrete. We will look at these in Chapter 10 where we shall bemeeting some amazing pictures of groups which are discrete in the strictsense that they contain no matrices too close to <span class="math inline">\(I\)</span>, but for which the limit set plot fillsout the whole plane, in a magically organised and yet extremelycomplicated way. For now, though, looking at whether or not the computerplot goes wild and seems to be filling up the page will not lead you farwrong. If you can find a tiling, then it shows you visually that thegroup is discrete, and if there is no tiling, you had better watchout!</p></div><p>事实证明，还有另一层复杂性存在，因为有些群体根本没有普通集，但它们仍然是离散的。我们将在第10章中讨论这些群体，届时我们将看到一些令人惊叹的群体图像，这些群体在严格意义上是离散的，因为它们不包含过于接近<span class="math inline">\(I\)</span>的矩阵，但它们的极限集却以一种神奇且极其复杂的方式填满了整个平面。不过，暂时而言，观察计算机绘图是否失控并看起来似乎填满整个页面，通常不会让你走错方向。如果你能找到密铺图案，那么它直观地向你展示了该群体是离散的；如果没有密铺图案，那你最好小心了！</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Shadertoy 学习</title>
      <link href="/learn-shadertoy/index.html"/>
      <url>/learn-shadertoy/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>The glowing gasket</title>
      <link href="/indra/the-glowing-gasket.html"/>
      <url>/indra/the-glowing-gasket.html</url>
      
        <content type="html"><![CDATA[<div class="statement simple plain unnumbered"><p>Four circles to the kissing come.<br>The smafter are the benter.<br>The bend is just the inverse of The distance from the centre.<br>Though sheir intrigue left Euclid dumb There’s now no need for nule ofthumb.<br>Since zero bend’s a dead straight line And concave bends have minussign.<br>The sum of the squares of alt four bends Is half the square of theirsum.</p><p>The Kiss Precise, Sir Frederick Soddy <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>四圆相吻巧相连，大小虽异自周全。<br>曲率正是心距倒，欧几里得愁煞然。<br>拇指法则今无用，零曲率者乃直线。<br>若为凹者曲率负，四曲率平方来加。<br>其和平方恰一半。</p><p>精确之吻，弗雷德里克·索迪爵士</p></div><figure id="fig-7.1"><img src="/images/indra/fig-7.1.jpg" class="fig" width="600" alt="Figure 7.1. The Apollonian gasket. The lacy web in the two pictures is the same: on the left, it is drawn in the complex plane and, on the right, on the sphere. As you might imagine, many people have tried calculating the Hausdorff dimension of the gasket. Curt McMullen has found the most accurate value, which is estimated as about 1.305688. 图 7.1. 阿波罗尼奥斯垫片。两幅图中的蕾丝网状结构是相同的：左边是在复平面上绘制的，右边是在球面上绘制的。你可能已经猜到，许多人都曾尝试计算该垫片的豪斯多夫维数。柯特·麦克马伦（Curt McMullen）给出了目前最精确的估计值，约为 1.305688。"><figcaption aria-hidden="true">Figure 7.1. The Apollonian gasket. Thelacy web in the two pictures is the same: on the left, it is drawn inthe complex plane and, on the right, on the sphere. As you mightimagine, many people have tried calculating the Hausdorff dimension ofthe gasket. Curt McMullen has found the most accurate value, which isestimated as about 1.305688.<br>图 7.1.阿波罗尼奥斯垫片。两幅图中的蕾丝网状结构是相同的：左边是在复平面上绘制的，右边是在球面上绘制的。你可能已经猜到，许多人都曾尝试计算该垫片的豪斯多夫维数。柯特·麦克马伦（CurtMcMullen）给出了目前最精确的估计值，约为 1.305688。</figcaption></figure><div class="statement simple plain unnumbered"><p>The lacy web in Figure 7.1 is called the Apollonian gasket. Usually,it is constructed by a simple geometric procedure, dating back to thosemost famous of geometers, the ancient Greeks. We shall start byexplaining the traditional construction, but as we shall discloseshortly, the gasket also represents another remarkable way in which theSchottky dust can congeal. The pictures you see here were actually alldrawn using a refinement <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> of the DFS algorithm for tangentSchottky circles.</p></div><p><a href="#fig-7.1">图 7.1</a>中蕾丝状的图案被称为阿波罗尼奥斯垫片。其构造基于一种简单的几何方法，这种方法可以追溯到最著名的几何学家——古希腊人。我们将首先解释这种传统的构造方式，但很快你会看到，这种圆垫其实还展现了另一个非同寻常的形式，即所谓的Schottky尘埃如何聚集成形。你所看到的这些图像，实际上都是使用一种针对相切Schottky 圆的 DFS 算法改进版本 <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> 绘制出来的。</p><div class="statement simple plain unnumbered"><p>The starting point of the traditional construction is a chain ofthree non-overlapping disks, each tangent to both of the others. Aregion between three tangent disks is a ‘triangle’ with circular arcsfor sides. This shape is often called an ideal triangle: the sides aretangent at each of the three vertices so the angle between them is zerodegrees.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> The gasket is activated by the factthat in the middle of each ideal triangle there is always a unique‘inscribed disk’ or incircle, tangent to the three outer circles. It isreally better to think of the gasket as a construction on the sphere.Insides and outsides don’t matter any more, so we may as well start withany three mutually tangent circles. You can see lots of disks andincircles in Figure 7.2.</p></div><p>传统构造的起点是由三个互不重叠的圆盘组成的一条链，每个圆盘都与另外两个相切。三个相切圆盘之间的区域构成了一个“三角形”，其边界是由圆弧构成的。这种形状常被称为理想三角形：由于其三条边在三个顶点处相切，因此它们之间的夹角为零度。该垫片（gasket）的关键在于，每个理想三角形的中间总存在一个唯一的“内切圆”，即同时与三个外接圆相切的圆。事实上，更好的理解方式是将这个垫片看作是在球面上的一种构造。在球面上，内侧与外侧的区别已不复存在，因此我们可以从任意三个两两相切的圆开始。你可以在<a href="#fig-7.2">图 7.2</a> 中看到大量的圆盘和它们的内切圆。</p><figure id="fig-7.2"><img src="/images/indra/fig-7.2.jpg" class="fig" width="600" alt="Figure 7.2. Activating the gasket. On the top left, the three largest disks which activate the gasket are shown in blue. One of the three disks appears as the outer blue region which frames the picture, because it contains the point \infty, the North Pole on the Riemann sphere. On the top right, two of the disks are tangent at \infty, so that you see them in the picture as parallel blue strips. Removing the blue circles leaves two red ideal triangles. Inside each ideal triangle is an incircle, coloured yellow. Below, we see more levels of incircles. 图 7.2. 激活垫片。左上图中，标出的三个最大圆盘以蓝色呈现，正是它们激活了垫片。其中一个圆盘显示为环绕整幅图像的外部蓝色区域，这是因为它包含了点 \infty，即黎曼球面上的北极点。右上图中，其中两个圆盘在 \infty 处相切，因此在图中呈现为两条平行的蓝色带状区域。当我们移除这些蓝色圆盘后，图中便显现出两个红色的理想三角形。每个理想三角形内部都嵌有一个黄色内切圆。下方图示进一步展示了更深层次的内切圆结构。"><figcaption aria-hidden="true">Figure 7.2. Activating the gasket. On thetop left, the three largest disks which activate the gasket are shown inblue. One of the three disks appears as the outer blue region whichframes the picture, because it contains the point <span class="math inline">\(\infty\)</span>, the North Pole on the Riemannsphere. On the top right, two of the disks are tangent at <span class="math inline">\(\infty\)</span>, so that you see them in thepicture as parallel blue strips. Removing the blue circles leaves twored ideal triangles. Inside each ideal triangle is an incircle, colouredyellow. Below, we see more levels of incircles.<br>图 7.2.激活垫片。左上图中，标出的三个最大圆盘以蓝色呈现，正是它们激活了垫片。其中一个圆盘显示为环绕整幅图像的外部蓝色区域，这是因为它包含了点<span class="math inline">\(\infty\)</span>，即黎曼球面上的北极点。右上图中，其中两个圆盘在<span class="math inline">\(\infty\)</span>处相切，因此在图中呈现为两条平行的蓝色带状区域。当我们移除这些蓝色圆盘后，图中便显现出两个红色的理想三角形。每个理想三角形内部都嵌有一个黄色内切圆。下方图示进一步展示了更深层次的内切圆结构。</figcaption></figure><div class="statement simple plain unnumbered"><p>In the figure, we show two initial configurations of three tangentblue disks. When you take out the three blue disks you are left with twored ideal triangles. Each red ideal triangle has a yellow incircle. Seehow each yellow incircle divides the red triangle into three moretriangles. For repetitive people (a necessary quality in this subject,you might say), it is only natural to draw the incircles in these newtriangles, resulting, of course, in even more triangles of the samekind. The bottom frame shows this subdivision carried out twice more,with green and then even smaller purple disks. In The Cat in the HatComes Back,’ the cat takes off his hat to reveal Little Cat, who thenremoves his hat and releases Little Cat, who then uncovers Little Cat,and so on. Now imagine there are not one but three new cats inside eachcat’s hat. That gives a good impression of the explosive proliferationof these tiny ideal triangles. Carry out this process to infinity, andVoom, the Apollonian Gasket appears.</p></div><p>图中展示了三个相切蓝色圆盘的两种初始配置。当你移除这三个蓝色圆盘时，剩下的是两个红色理想三角形。每个红色理想三角形都有一个黄色的内切圆。观察每个黄色内切圆如何将红色三角形分割成三个更小的三角形。</p><p>对于那些乐此不疲的人（或许正是研究这一主题的必备素质），在新三角形中继续绘制内切圆简直是顺理成章的事。这当然会催生出更多相似的三角形。下方的子图展示了这种细分过程再执行两次的结果——先是绿色圆盘，接着是更小的紫色圆盘，密密层层地堆叠起来。这让我想起《戴帽子的猫又来了》中的情节——大猫摘下帽子，露出一只小猫；小猫摘下自己的帽子，又冒出一只更小的小猫；接着更小的小猫再摘帽……如此反复进行。现在，想象每顶帽子里不是藏着一只，而是三只小猫，那你就能体会这些微型理想三角形是如何爆炸式增长的了。让这一过程无限延续，砰——阿波罗尼奥斯分形就出现了。</p><div class="statement simple plain unnumbered"><p>The Apollonian gasket is indeed very pretty, but the reason forintroducing it here is that, remarkably, it is also the limit set of aSchottky group made by pairing tangent circles. Exactly the sameintricate mathematical object can created by completely different means!You can see better how this works in the beautiful glowing version inFigure 7.3. The solid red circles in this picture are the initialSchottky circles in a very special configuration which we will look atclosely in the next section. The glowing yellow limit set can berecognized as the same as the Apollonian gasket of Figure 7.1. Thepicture was made by pairing four tangent circles arranged in theconfiguration shown in Figure 7.4. The four circles are tangent not onlyin a chain; there are also extra tangencies between <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span>, and between <span class="math inline">\(C_b\)</span> and <span class="math inline">\(C_B\)</span>.</p></div><p>阿波罗尼奥斯分形确实非常美丽，但我们在此介绍它的原因是：令人惊讶的是，它也是由切圆配对生成的肖特基群的极限集。完全不同的方式也能创造出完全相同的复杂数学对象！您可以通过<a href="#fig-7.3">图 7.3</a>中的荧光渲染图更好地理解它是如何运作的。图中的实心红色圆环是以一种特殊配置排列的初始肖特基圆（具体分析请参见下一节），其荧黄色的极限集与<a href="#fig-7.1">图 7.1</a>中的阿波罗尼奥斯垫片完全一致。这幅图像是通过配对四个相切圆生成的，排列方式如<a href="#fig-7.4">图 7.4</a>所示：这些圆不仅形成了链式相切的关系，而且在 <span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span>、<span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 之间还存在额外的切点。</p><figure id="fig-7.3"><img src="/images/indra/fig-7.3.jpg" width="600" alt="Figure 7.3. (Overleaf.) The glowing gasket. This picture was created by applying the generating transformations a,A,b,B to the chain of four solid red disks bounding the black ideal triangles. At higher levels, the image circles tone from red to orange to yellow, through green to blue, finally cycling back to red. Don’t let the picture fool you - the red circles are not the circles which activate the gasket in the traditional construction. The ones which appear in the traditional construction are the ‘dual’ circles with the yellow glow. 图 7.3. 荧光垫片。此图像是通过对围绕黑色理想三角形的四个实心红色圆盘施加生成变换 a,A,b,B 而生成的。在更高的层级中，图像中的圆环色调从红色渐变为橙色、黄色，接着是绿色，再到蓝色，最终循环回红色。需要特别注意的是：图中的红色圆并非传统阿波罗尼奥斯构造中激活垫片的圆——在传统构造中，起激活作用的是发出黄色光辉的“对偶圆”。"><figcaption aria-hidden="true">Figure 7.3. (Overleaf.) The glowinggasket. This picture was created by applying the generatingtransformations <span class="math inline">\(a,A,b,B\)</span> to thechain of four solid red disks bounding the black ideal triangles. Athigher levels, the image circles tone from red to orange to yellow,through green to blue, finally cycling back to red. Don’t let thepicture fool you - the red circles are not the circles which activatethe gasket in the traditional construction. The ones which appear in thetraditional construction are the ‘dual’ circles with the yellowglow.<br>图 7.3.荧光垫片。此图像是通过对围绕黑色理想三角形的四个实心红色圆盘施加生成变换<span class="math inline">\(a,A,b,B\)</span>而生成的。在更高的层级中，图像中的圆环色调从红色渐变为橙色、黄色，接着是绿色，再到蓝色，最终循环回红色。需要特别注意的是：图中的红色圆并非传统阿波罗尼奥斯构造中激活垫片的圆——在传统构造中，起激活作用的是发出黄色光辉的“对偶圆”。</figcaption></figure><div class="statement simple plain unnumbered"><p>As you iterate the pairing transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, the extra tangency proliferates, withthe effect that inside each disk <span class="math inline">\(D\)</span>you see three further Schottky disks tangent to <span class="math inline">\(D\)</span> and each of the other two. In ourversion, the circles have been coloured depending on their level,starting with red at the first or lowest level, gradually changing toyellow, green and then blue. The small yellow and blue circles pile up,highlighting the limit set with a mysterious glow.</p></div><p>当你不断迭代配对变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>时，额外的切点会迅速增殖。结果是在每个圆盘 <span class="math inline">\(D\)</span>内部，都会涌现出三个新的肖特基子圆盘——它们不仅与 <span class="math inline">\(D\)</span>相切，而且两两之间也彼此相切。在我们的可视化方案中，圆盘根据迭代的层级依次着色——最底层从红色起步，逐步过渡到黄色、绿色、蓝色。随着黄色和蓝色的小圆盘层层堆叠，突出了极限集，并散发出一种神秘的光辉。</p><div class="statement simple plain unnumbered"><p>In this chapter, we shall be exploring various features of thegasket. Notwithstanding the extra tangency, it turns out that each limitpoint is still associated to exactly one or two infinite words in thegenerators <span class="math inline">\(a,b,A\)</span> and <span class="math inline">\(B\)</span>. You will be able to make your ownversion of the glowing gasket by running our DFS algorithm for the groupgenerated by the transformations <span class="math inline">\(a\)</span>and <span class="math inline">\(b\)</span>. The algorithm draws thiscomplicated lacework as a continuous curve, which is hard to imagineuntil you see it in progress on a computer screen. The curve snakes itsway through the gasket, apparently leaving one region for quite a whileuntil finally weaving its way back. Animation is the true reward ofsuccessfully implementing the program we have been learning tobuild.</p></div><p>在本章中，我们将深入探索垫片结构的各种特性。尽管存在额外的相切关系，但事实证明，每个极限点仍然对应于生成元<span class="math inline">\(a, b, A, B\)</span>所构成的一至两个无限字。通过运行我们为变换群 <span class="math inline">\(\langle a,b\rangle\)</span>特别设计的深度优先搜索（DFS）算法，你将能够制作出自己专属的发光垫片。该算法将这种复杂的蕾丝结构绘制成一条连续的曲线——这种奇妙的生成过程，唯有在计算机屏幕上亲眼目睹，方能真正感受到其变幻莫测之美。曲线如同灵蛇般在垫片中蜿蜒穿梭，仿佛要彻底离开某个区域，却又在某个时刻悄然折返。成功实现我们精心构建的程序后，最令人欣喜的收获正是这些跃然屏上的动态演绎。</p><div id="apollonius--circa-250-200-bc" class="statement sta_apollonius__circa_250_200_bc plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Apollonius, circa 250-200 BC</span>.</span><span class="statement-spah"> </span><br></p><p>Apollonius, known to his contemporaries as the Great Geometer, livedin Perga, now part of Turkey. One of the giants of Greek mathematics, hewas famed for his 8 volume treatise Conics which studied ellipses,hyperbolas and parabolas as sections of a cone by a plane at variousangles. His writings swiftly became standard texts in the ancient world.Many are now lost and we know them only through mention in othercommentaries, among them works on regular solids, irrational numbers,and approximations to <span class="math inline">\(\pi\)</span>. Ptolemycredits Apollonius with the theory of epicycles on which he based histheory of planetary motion.</p><p>One of Apollonius’ lost works is a book called Tangencies, reportedto provide methods of constructing circles tangent to various othercombinations of lines and circles, for example finding a circle tangentto two given lines and another circle. You can think of the problem offinding the incircle of an ideal triangle in this way. The mostdifficult problem, that of constructing the two circles tangent to threeother given disjoint circles, was probably not solved in ancient times,however Sir Isaac Newton wrote down a proof. According to Pappus,Tangencies gave a formula for the radius of the incircle to an idealtriangle in terms of the radii of the circles which bound its threesides. Be that as it may, exactly such a formula was described byDescartes in 1643, and a version was known in eighteenth century Japan.In fact this formula seems to have been rediscovered many times, mostrecently by Sir Frederick Soddy, in whose honour the incircles aresometimes known as Soddy circles. Awarded the Nobel prize in 1921, forthe discovery of isotopes, Soddy had a natural interest in how to packspherical atoms of differing size.</p><p>Soddy was so taken with the formula that he published it in theunusual form of a poem, which appeared in the journal Nature in 1936.The central part is contained in the middle verse quoted at the head ofthis chapter. For those who feel more comfortable with symbols, supposethe radii of the chain of three circles are <span class="math inline">\(a,b\)</span> and <span class="math inline">\(c\)</span>, and that the incircle has radius <span class="math inline">\(d\)</span>. Soddy’s formula is: <span class="math display">\[\left(\frac{1}{a}+\frac{1}{b}+\frac{1}{c}+\frac{1}{d}\right)^2=2\left(\frac{1}{a^2}+\frac{1}{b^2}+\frac{1}{c^2}+\frac{1}{d^2}\right).\]</span></p><p>阿波罗尼奥斯，被同时代人誉为伟大的几何学家，生活在佩尔加，即现今土耳其的一部分。作为希腊数学的巨擘之一，他因八卷本专著《圆锥曲线论》而闻名，该著作研究了椭圆、双曲线和抛物线作为平面以不同角度切割圆锥所得截面的性质。其著作迅速成为古代世界的标准教材。许多作品现已遗失，我们仅通过其他评论中的提及了解它们，其中包括关于正多面体、无理数及对<span class="math inline">\(\pi\)</span>的近似值的研究。托勒密将本轮理论归功于阿波罗尼奥斯，这一理论成为他行星运动学说的基础。</p><p>阿波罗尼奥斯遗失的著作之一名为《切触》，据记载，该书提供了构建与各种直线和圆组合相切的圆的方法，例如寻找与两条给定直线及另一个圆相切的圆。你可以将寻找理想三角形内切圆的问题视为此类问题。最难的难题，即构建与三个给定且互不相交的圆相切的两个圆，在古代可能并未解决，然而艾萨克·牛顿爵士记录了一个证明。根据帕普斯的说法，《切触》给出了一个公式，用于计算理想三角形内切圆的半径，该半径与限定其三条边的圆的半径有关。尽管如此，笛卡尔在1643 年确实描述了这样一个公式，且在 18世纪的日本也已知晓其版本。实际上，这个公式似乎被多次重新发现，最近一次是由弗雷德里克·索迪爵士完成的。为了纪念他，内切圆有时被称为索迪圆。索迪因发现同位素而于1921 年获得诺贝尔奖，他对如何排列不同大小的球形原子自然产生了兴趣。</p><p>索迪对这个公式深深着迷，以至于他以一首诗的形式将其发表，这首诗出现在1936年的《自然》杂志上。其核心部分包含在本章开头引用的中间诗句中。对于那些更偏好使用符号的读者，假设三个连锁圆的半径分别为<span class="math inline">\(a, b\)</span> 和 <span class="math inline">\(c\)</span>，内切圆的半径为 <span class="math inline">\(d\)</span>。索迪的公式为：</p><p><span class="math display">\[\left(\frac{1}{a}+\frac{1}{b}+\frac{1}{c}+\frac{1}{d}\right)^2=2\left(\frac{1}{a^2}+\frac{1}{b^2}+\frac{1}{c^2}+\frac{1}{d^2}\right).\]</span></p></div><h1 id="generating-the-gasket">Generating the gasket</h1><div class="statement simple plain unnumbered"><p>The configuration of tangent circles which produced the gasket isshown in the right frame of Figure 7.4. The picture has been arranged sothat <span class="math inline">\(C_a\)</span> goes through <span class="math inline">\(\infty\)</span>, hence it appears in the figure asa straight line. In addition, <span class="math inline">\(C_A\)</span>and <span class="math inline">\(C_a\)</span> are tangent at 0 and <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> are tangent at <span class="math inline">\(-i\)</span>. You can see how this picture is madeby creating extra tangencies among a kissing chain of four circles bycomparing with the nearby arrangement of four circles in the left handframe.</p></div><p>生成垫片的相切圆配置如 <a href="#fig-7.4">图 7.4</a>右图所示。图中特意令圆 <span class="math inline">\(C_a\)</span> 经过<span class="math inline">\(\infty\)</span>，从而它在图中呈现为一条直线。此外，我们令圆<span class="math inline">\(C_A\)</span> 与 <span class="math inline">\(C_a\)</span> 在原点 0 处相切，圆 <span class="math inline">\(C_B\)</span> 与 <span class="math inline">\(C_b\)</span> 在<span class="math inline">\(-i\)</span>处相切。通过与左边图中四个圆的排列进行对比，可以清晰观察到右图通过在四圆相切链中引入额外切点形成的特殊结构。</p><figure id="fig-7.4"><img src="/images/indra/fig-7.4.jpg" class="fig" width="600" alt="Figure 7.4. The right frame shows the starting configuration of tangent Schottky circles which produces the glowing gasket. The red circles C_a and C_A are paired by the transformation a and the blue circles C_B and C_b by b. Using notation from the last chapter, the tangency points P,Q,R and S are at 1,-1,-0.2-0.4i and 0.2-0.4i respectively. On the left is a nearby Schottky configuration of circles which are not quite tangent and a and b are loxodromic. This is similar to the configuration shown in frame (vi) of Figure 6.10. The centre frame is an intermediate stage where a is parabolic but b is not. 图 7.4. 右图展示了生成发光垫片的相切 Schottky 圆的初始配置。红色圆 C_a 与 C_A 通过变换 a 配对，蓝色圆 C_B 与 C_b 通过变换 b 配对。根据前一章的记号，切点 P, Q, R, S 分别位于坐标 1, -1, -0.2-0.4i 和 0.2-0.4i 处。左图展示了一个相似的 Schottky 圆配置，其中圆未完全相切，且变换 a 和 b 均为斜航的。该配置与 图 6.10 (vi) 中的结构相似。中间图呈现了过渡状态，其中变换 a 是抛物线型的，而 b 不是。"><figcaption aria-hidden="true">Figure 7.4. The right frame shows thestarting configuration of tangent Schottky circles which produces theglowing gasket. The red circles <span class="math inline">\(C_a\)</span>and <span class="math inline">\(C_A\)</span> are paired by thetransformation <span class="math inline">\(a\)</span> and the bluecircles <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> by <span class="math inline">\(b\)</span>. Using notation from the last chapter,the tangency points <span class="math inline">\(P,Q,R\)</span> and <span class="math inline">\(S\)</span> are at <span class="math inline">\(1,-1,-0.2-0.4i\)</span> and <span class="math inline">\(0.2-0.4i\)</span> respectively. On the left is anearby Schottky configuration of circles which are not quite tangent and<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are loxodromic. This is similar to theconfiguration shown in frame (vi) of Figure 6.10. The centre frame is anintermediate stage where <span class="math inline">\(a\)</span> isparabolic but <span class="math inline">\(b\)</span> is not.<br>图 7.4. 右图展示了生成发光垫片的相切 Schottky 圆的初始配置。红色圆 <span class="math inline">\(C_a\)</span> 与 <span class="math inline">\(C_A\)</span> 通过变换 <span class="math inline">\(a\)</span> 配对，蓝色圆 <span class="math inline">\(C_B\)</span> 与 <span class="math inline">\(C_b\)</span> 通过变换 <span class="math inline">\(b\)</span> 配对。根据前一章的记号，切点 <span class="math inline">\(P, Q, R, S\)</span> 分别位于坐标 <span class="math inline">\(1, -1, -0.2-0.4i\)</span> 和 <span class="math inline">\(0.2-0.4i\)</span> 处。左图展示了一个相似的Schottky 圆配置，其中圆未完全相切，且变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 均为斜航的。该配置与 <a href="#fig-6.10">图 6.10</a> (vi)中的结构相似。中间图呈现了过渡状态，其中变换 <span class="math inline">\(a\)</span> 是抛物线型的，而 <span class="math inline">\(b\)</span> 不是。</figcaption></figure><div class="statement simple plain unnumbered"><p>The generating matrices for the gasket are quite simple: <span class="math display">\[a=\begin{pmatrix}1&amp;0\\-2i&amp;1\end{pmatrix}\quad\text{and}\quadb=\begin{pmatrix}1-i&amp;1\\1&amp;1+i\end{pmatrix}.\]</span></p><p>We shall have more to say about how we arrived at these particularformulas later on. Note that <span class="math inline">\(\mathop{\mathrm{Tr}}{a}=\mathop{\mathrm{Tr}}{b}=2\)</span>,so <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are parabolic. Looking at thearrangement of Schottky circles in Figure 7.4, you see the fixed pointof <span class="math inline">\(a\)</span> is 0, the tangency point ofthe circles <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span>. In Figure 7.3, you can see twochains of tangent circles nesting down on 0 from above and below. Thesame phenomenon occurs at <span class="math inline">\(-i\)</span>, thetangency point of <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> and the fixed point of <span class="math inline">\(b\)</span>. Notwithstanding extra tangencies, thegenerators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> still pair opposite circles in theinitial tangent chain <span class="math inline">\(C_a,C_b,C_A\)</span>and <span class="math inline">\(C_B\)</span>. This means that fornesting circles we still need the commutator condition <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB}=2\)</span>, which isnot hard to check.</p></div><p>生成该垫片的矩阵非常简单：</p><p><span class="math display">\[a=\begin{pmatrix}1&amp;0\\-2i&amp;1\end{pmatrix}\quad\text{and}\quadb=\begin{pmatrix}1-i&amp;1\\1&amp;1+i\end{pmatrix}.\]</span></p><p>关于这两个特定的矩阵，我们稍后会详细解释它们的推导过程。注意到 <span class="math inline">\(\mathop{\mathrm{Tr}}{a}=\mathop{\mathrm{Tr}}{b}=2\)</span>，因此<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 都是抛物型变换。观察 <a href="#fig-7.4">图 7.4</a> 中 Schottky 圆的排列，可以看到 <span class="math inline">\(a\)</span> 的不动点是 0，即圆 <span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span> 的切点。在 <a href="#fig-7.3">图7.3</a> 中，你可以看到两条相切的圆链从上下两侧分别向 0点逐渐嵌套收缩。相同的现象也出现在 <span class="math inline">\(-i\)</span> 处，这既是圆 <span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 的切点，也是变换 <span class="math inline">\(b\)</span> 的不动点。尽管存在额外的切点，生成元<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 依然将初始的相切链 <span class="math inline">\(C_a,C_b,C_A,C_B\)</span>中的圆配对。这意味着要实现圆链的无穷嵌套，我们仍需满足交换子条件 <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB}=2\)</span>，这一点并不难验证。</p><div class="statement simple plain unnumbered"><p>We have been speaking as if there is only one Apollonian gasket, butcould we not get different gaskets by starting with different tangentchains? Not really, because it turns out that any chain of three tangentcircles can be conjugated to any other three. As you can work out inProject 7.1, this stems from the fact that there is always a Möbius mapcarrying any three points to any other three. Since the gasket isactivated by its initial ideal triangle, and since the procedure at eachstep consists in adding incircles, a Möbius map which conjugates oneideal triangle to another carries the whole gasket along in itswake.</p><p>This explains why it makes sense to talk about the Apollonian gasket,because up to conjugation by Möbius maps there is really only one.</p></div><p>我们此前的讨论似乎一直都默认了阿波罗尼奥斯垫片是独一无二的，但如果我们从不同的初始相切圆链出发，难道不会得到不同的垫片吗？其实不能。事实上，任何由三个相切圆组成的链，都可以通过某个莫比乌斯变换转化为另一组任意的相切圆链。正如你在<a href="#proj-7.1" title="项目 7.1">项目 7.1</a>中可以推导出的那样，这源于总有一个莫比乌斯映射将任意三个点映射到其他任意三个点。由于垫片的构造源于其初始理想三角形，而每一步的操作都是添加内切圆，一个将一个理想三角形共轭到另一个理想三角形的莫比乌斯映射会将整个垫片一起带走。</p><p>这就解释了为什么谈论“阿波罗尼奥斯垫片”是有意义的，因为在莫比乌斯变换的共轭意义下，归根结底，阿波罗尼奥斯垫片只有一个。</p><figure id="fig-7.5"><img src="/images/indra/fig-7.5.jpg" width="600" alt="Figure 7.5. The strip gasket. This shows the gasket as it appears when we conjugate so that the extra tangency point of C_b and C_B is at \infty. Any parabolic with a fixed point at \infty is a Euclidean translation, in this case b(z)=z+2, which explains the translational symmetry along the infinite strip. 图 7.5. 带状垫片。图中展示了当我们进行共轭变换，使得 C_b 和 C_B 的额外切点位于 \infty 处时，垫片的样貌。任何以 \infty 为不动点的抛物型变换都是欧几里得平移，在本例中为 b(z)=z+2，这解释了沿着无限带的平移对称性。"><figcaption aria-hidden="true">Figure 7.5. The strip gasket. This showsthe gasket as it appears when we conjugate so that the extra tangencypoint of <span class="math inline">\(C_b\)</span> and <span class="math inline">\(C_B\)</span> is at <span class="math inline">\(\infty\)</span>. Any parabolic with a fixed pointat <span class="math inline">\(\infty\)</span> is a Euclideantranslation, in this case <span class="math inline">\(b(z)=z+2\)</span>,which explains the translational symmetry along the infinitestrip.<br>图 7.5. 带状垫片。图中展示了当我们进行共轭变换，使得 <span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 的额外切点位于 <span class="math inline">\(\infty\)</span> 处时，垫片的样貌。任何以 <span class="math inline">\(\infty\)</span>为不动点的抛物型变换都是欧几里得平移，在本例中为 <span class="math inline">\(b(z)=z+2\)</span>，这解释了沿着无限带的平移对称性。</figcaption></figure><p>另一个著名的垫片版本可以在 <a href="#fig-7.5">图 7.5</a>中看到。为了得到这个，我们进行了共轭，使得 <span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span> 在 0 处相切，因此它们是垂直线。映射<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 现在在 <span class="math inline">\(0\)</span> 处有一个不动点。该群的生成元为：</p><p><span class="math display">\[a=\begin{pmatrix}2&amp;-i\\-i&amp;0\end{pmatrix}\quad\text{and}\quadb=\begin{pmatrix}1&amp;2\\0&amp;1\end{pmatrix}.\]</span></p><h1 id="pinching-tiles">Pinching tiles</h1><figure id="fig-7.6"><img src="/images/indra/fig-7.6.jpg" width="600" alt="Figure 7.6. Dr.&nbsp;Stickler meets Apollonius. Placing Dr.&nbsp;Stickler in the Apollonian gasket, we let the group of symmetries carry him around. He appears exactly in those disks which were pink in Figure 7.4. If we had started him off in a white one, his images would fill the white disks instead. The symmetry a is parabolic and on both sides of its fixed point 0, circles of Sticklers are streaming out. A startling feature is the circle of Sticklers streaming out from and into 1. Every alternate Stickler is standing on his head! The upright Sticklers are just powers of abAB (which fixes 1) applied to the Stickler standing on the right hand horizontal axis, while the upside down ones are the images of this same Stickler under (abAB)^nA. 图 7.6. Stickler 博士邂逅阿波罗尼奥斯分形。我们将 Stickler 博士置于阿波罗尼奥斯垫片中，然后让对称群带他四处转转。结果，他恰好出现在 图 7.4 里那些粉红色的圆盘中。若是他最初出现在某个白色圆盘中，那么他的身影就会填满所有的白色圆盘。对称 a 是抛物型的，在它的不动点 0 的两侧，成群的 Stickler 博士正沿着圆圈向外扩散。最令人惊奇的是，在坐标 1 附近，竟然出现了一圈 Stickler 博士首尾相连、双向流动的奇妙图案。更绝的是，相邻的 Stickler 博士还头朝上、头朝下交替出现。那些站得笔直的 Stickler 博士，是通过不断对右侧水平轴上那位 Stickler 施加变换 (abAB)^n（该变换以 1 为不动点）得到的。而那些倒立的 Stickler 博士，则是这位 Stickler 在变换 (abAB)^nA 作用下的映射结果。"><figcaption aria-hidden="true">Figure 7.6. Dr.&nbsp;Stickler meetsApollonius. Placing Dr.&nbsp;Stickler in the Apollonian gasket, we let thegroup of symmetries carry him around. He appears exactly in those diskswhich were pink in Figure 7.4. If we had started him off in a white one,his images would fill the white disks instead. The symmetry <span class="math inline">\(a\)</span> is parabolic and on both sides of itsfixed point 0, circles of Sticklers are streaming out. A startlingfeature is the circle of Sticklers streaming out from and into 1. Everyalternate Stickler is standing on his head! The upright Sticklers arejust powers of <span class="math inline">\(abAB\)</span> (which fixes 1)applied to the Stickler standing on the right hand horizontal axis,while the upside down ones are the images of this same Stickler under<span class="math inline">\((abAB)^nA\)</span>.<br>图 7.6. Stickler 博士邂逅阿波罗尼奥斯分形。我们将 Stickler博士置于阿波罗尼奥斯垫片中，然后让对称群带他四处转转。结果，他恰好出现在<a href="#fig-7.4">图 7.4</a>里那些粉红色的圆盘中。若是他最初出现在某个白色圆盘中，那么他的身影就会填满所有的白色圆盘。对称<span class="math inline">\(a\)</span> 是抛物型的，在它的不动点 0的两侧，成群的 Stickler 博士正沿着圆圈向外扩散。最令人惊奇的是，在坐标 1附近，竟然出现了一圈 Stickler博士首尾相连、双向流动的奇妙图案。更绝的是，相邻的 Stickler博士还头朝上、头朝下交替出现。那些站得笔直的 Stickler博士，是通过不断对右侧水平轴上那位 Stickler 施加变换 <span class="math inline">\((abAB)^n\)</span>（该变换以 1为不动点）得到的。而那些倒立的 Stickler 博士，则是这位 Stickler 在变换<span class="math inline">\((abAB)^nA\)</span>作用下的映射结果。</figcaption></figure><div class="statement simple plain unnumbered"><p>Figure 7.6 is a wonderful picture of what happened when we introducedDr.&nbsp;Stickler to Apollonius! It is a pretty intricate arrangement, solet’s take a bit of time understanding what has happened to the tiles.To get a grasp on the situation, look back at the three pictures inFigure 7.4, and watch the progression across the three frames. On theleft the limit set is a loop or quasicircle, so the ordinary set - whatis left when you take away the limit set - has two parts, a pink insideand a white outside. In the central picture, the pink part has collapsedinto a myriad of tangent disks, and the red Schottky circles <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span> touch at 0. On the right, the gasketgroup, the ‘horns’ of the pink region have also come together, causingthe white outside to fracture into disks as well. Notice how the memoryof which was inside and which was outside still persists, because whatwere the ‘inside’ disks are pink while the ‘outside’ ones are white.</p></div><p><a href="#fig-7.6">图 7.6</a> 是一幅精彩的画面，生动展现了当我们邀请Stickler博士探索阿波罗尼奥斯分形时所发生的奇妙事情！图中的结构相当复杂，因此我们不妨花些时间，仔细剖析图案的变化。要理解这一过程，不妨回顾<a href="#fig-7.4">图 7.4</a>的三幅子图，并观察这三帧之间的演变：左图中的极限集是一个回路或拟圆，因此普通集（即去掉极限集后剩下的部分）分为粉色的内部和白色的外部。中间的图中，粉色区域已收缩成无数相切的圆盘，而红色的肖特基圆<span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span> 在 0处相切。右图则展示了垫片群，其中粉色区域的“触角”也汇聚在一起，使得白色外部区域也裂解成圆盘。令人惊奇的是，尽管整体结构支离破碎，内外区域仍清晰保留着原始的记忆——曾经“内部”的圆盘依旧是粉色，而“外部”的圆盘依旧是白色。</p><div class="statement simple plain unnumbered"><p>In each picture, the initial Schottky circles are blue and red. Watchthem to follow the fate of the tiles. On the left, as usual for akissing Schottky group, they surround the central inner four sided tile.If we transported this tile around by the group, we would see atessellation　of the pink region similar to the one in Figure 6.6.(There is also an outer tile, the region outside the four Schottkycircles, which as usual you can see more clearly by imagining it on theRiemann sphere.) The inner and outer parts of the ordinary set areinvariant under the group, so if you apply any transformation of thegroup to any tile in the pink region ‘inside’ the limit set, you getanother tile which is also ‘inside’.</p></div><p>在每幅图中，最初的 Schottky圆分别是蓝色和红色。仔细观察它们的变化，有助于追踪瓷砖的运动轨迹。在左图中，和典型的“亲吻”Schottky群一样，这些圆环绕着中央的四边形瓷砖。如果我们将这块瓷砖沿着群的变换不断移动，就会在粉色区域中形成类似于<a href="#fig-6.6">图 6.6</a>的镶嵌图案（此外，还有一个外部瓷砖，即位于四个 Schottky圆之外的区域，通常，通过在黎曼球面上想象它的位置，可以更清楚地看到它的轮廓）。普通集的内部和外部在群作用下各自保持不变，因此，如果对极限集“内部”粉色区域中的某块瓷砖施加群中的某个变换，得到的仍会是另一块位于“内部”的瓷砖。</p><div class="statement simple plain unnumbered"><p>In the central picture, where <span class="math inline">\(a\)</span>has become parabolic, the inner tile has been pinched into two halves.Each half-tile is an ideal triangle, with two red sides and one blue.You should think of this pair of triangles as one composite two-parttile. Moved around by the group, the composite tile will cover all thepink circles. There is an outer tile in this picture too, which (on theRiemann sphere) remains in one piece.</p><p>On the right, in the gasket group, both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> have been pinched so that now <span class="math inline">\(C_b\)</span> and <span class="math inline">\(C_B\)</span> also tuch at <span class="math inline">\(-i\)</span>. Now there are four basic half-tiles.The two pink ones will produce a tiling of the pink circles and thewhite ones will make a tiling of the white circles. In the glowinggasket picture, these four tiles are black. The upper two ‘horizontal’ideal triangles are the remnants of the inner Schottky tile, while thelower ‘vertical’ triangle is a remnant of the outer one. If you lookcarefully, you can just see its twin peeping out in the bottom centre ofthe page.</p></div><p>在中央的图片中，<span class="math inline">\(a\)</span>已变成了抛物型，内部的瓷砖被挤压成了两半。每个半瓷砖都是一个理想三角形，带有两条红边和一条蓝边。你可以把这对三角形视作一个由两部分组成的复合瓷砖。通过群的作用，这个复合瓷砖将覆盖所有的粉色圆盘。图中还有一个外部瓷砖，它在黎曼球面上依然保持完整。</p><p>在右侧的垫片图中，<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 都被挤压变形，使得 <span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 现在也在 <span class="math inline">\(-i\)</span>处相切。此时出现了四个基本的半瓷砖。两块粉色的会铺满粉色圆盘，而两块白色的则会铺满白色圆盘。在那幅发光的垫片图中，这四块瓷砖都呈现为黑色。上方的两个“水平”理想三角形是内部Schottky瓷砖的残迹，而下方的“垂直”三角形则是外部瓷砖的残迹。仔细观察，你会在页面底部中央隐约发现它的孪生兄弟正悄悄探出头来。</p><div class="statement simple plain unnumbered"><p>Now we can go back to the picture of Dr.&nbsp;Stickler meeting Apollonius.The party is taking place in the remnants of the ‘pink’ circles. If youcompare with the half-tiles in Figure 7.4, something rather odd hashappened to Dr.&nbsp;Stickler - when the original tile split in two, his headended up in the green half-tile and his feet in the blue one.Fortunately, there is a transformation of the group (namely <span class="math inline">\(B\)</span>) which carries the blue Stickler to thegreen one, moving the blue half-tile containing the blue feet to theyellow half-tile containing the green feet. Had we not pointed out hisdifficulties you might not even have noticed that anything was wrong.After gluing the yellow half-tile to the green halftile, the relieved(but still slightly greenish) Dr.&nbsp;Stickler stands reunited in a new andcomplete tile whose images under the group map to all the Sticklers inthe picture.</p></div><p>现在我们可以回到 Stickler博士与阿波罗尼奥斯相遇的画面。聚会正在“粉色”圆圈的残迹中举行。对照 <a href="#fig-7.4">图 7.4</a> 中的半瓷砖，你会发现 Stickler博士身上发生了一件相当奇怪的事——当原始瓷砖裂成两半时，原始瓷砖裂成两半时，他的头跑到了绿色半瓷砖里，而他的脚却留在了蓝色半瓷砖上。幸好，群中有一个变换（即<span class="math inline">\(B\)</span>）可以将蓝色的 Stickler 带到绿色Stickler的位置，把装着蓝色脚丫的蓝色半瓷砖挪到装着绿色脚丫的黄色半瓷砖上。要不是我们特意指出这种窘况，你可能根本没发现哪里不对劲。等到黄色半瓷砖和绿色半瓷砖粘合完毕，那位如释重负（却仍然带着一丝“绿意”）的Stickler博士终于又完整地站在了一块崭新的瓷砖上。通过群的映射，这块瓷砖的影像铺展开来，构成了画面中所有Stickler 博士的身影。</p><h1 id="and-pinching-surfaces">And pinching surfaces</h1><div class="statement simple plain unnumbered"><p>What happened to the tiles in the last section, has, of course, alsoan interpretation in terms of surfaces. Looking back to the picture onp.&nbsp;190 which showed how tiles were glued up in a kissing Schottky group,we can work out what happens when we bring the four circles together tomake the gasket. It takes a bit of stretching and squeezing to do this,which we have illustrated in Figure 7.7.</p><p>The result, shown in the last panel, is our old friend the pretzelwith three circles pinched to points or cusps: the waist as in the lastchapter and, in addition, loops around the top and bottom tori. Both topand bottom are now ‘spheres’ with three cusps or punctures each. Onepair of cusps on each sphere are joined together like ‘horns’, and thesetwo ‘horned spheres’ are themselves joined together at the last twocusps.</p></div><p>上一节中瓷砖的演变过程，当然也可以从曲面角度得到诠释。回顾第 190页展示的亲吻 Schottky群的基本域粘合过程的示意图，我们可以推导出当将四个圆粘合为垫片群时会发生什么。这一过程需要一些拉伸和压缩，我们在<a href="#fig-7.7" title="图 7.7">图 7.7</a> 中进行了直观展示。</p><p>最终结果呈现于最后一幅示意图中，正是我们熟悉的椒盐脆饼造型——三个圆周被压缩为尖点（cusp）：其中一个是上一章提到的“腰部”尖点，另外两个则是围绕顶部和底部的环面。此时，顶部与底部都变成了各自有三个尖点（或称穿孔）的”球面”。每个球面上的一对尖点像”犄角”一样连接在一起，而这两个“带角球面”则通过它们剩下的两个尖点相互连接。</p><div class="statement simple plain unnumbered"><p>The gasket group is called doubly cusped because we have pinched twoextra loops, <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. It is also sometimes called maximallycusped, because, after all this squeezing, there are no more curves leftto pinch. In Chapter 9, we shall see that you can make many variants ofthe gasket group by imposing more complicated relationships between thecurves we choose to pinch on the top and bottom halves of the pinchedpretzel.</p></div><p>垫片群被称为双尖群，因为我们挤压了两个额外的环路 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>。它也常被称为“极大尖群”，因为经过这般操作后，已不存在可供进一步挤压的曲线。在第九章中我们将看到，通过在挤压后的椒盐卷曲曲面（pretzel）的上下半部之间，对选定挤压曲线施加更复杂的关联约束，可以构造出多种垫片群的变体。</p><div id="fig-7.7" class="statement simple plain unnumbered"><p>Figure 7.7. Pinching curves. How gluing up the gasket configurationof tangent circles leads to a pair of triply-punctured spheres. The<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> curves we have to shrink are are marked<span class="math inline">\(L\)</span> and <span class="math inline">\(M\)</span>. Instead of pulling the upper and lowerpartially glued-up cylinders logether right away, as we did in Figure6.16, it now takes some effort first to twist them relative to eachother in such a way that when we glue-up, the dotted loops are in theirproper position ready to be shrunk.</p><p>图 7.7.捏合曲线。如何通过粘合垫片的切圆得到一对带有三穿孔球面。需要收缩的 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 曲线分别标记为 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span>。与 <a href="#fig-6.16">图 6.16</a>中直接粘合上下圆柱体的操作不同，此时需要先使两者相对扭转，确保粘合时虚线环处于正确位置以便后续收缩。</p><figure><img src="/images/indra/fig-7.7-1.jpg" width="200" alt="BEGIN WITH A PLANE WITH FOUR HOLES, EACH OF WHICH JUST TOUCHES THREE OTHERS, WHAT HAPPENS WHEN WE GLUE A TO a (THE SMALL ONE) AND B TO b? 从一个带有四个孔的平面开始，每个孔都与另外三个孔相切。当我们将 A 粘合到 a（较小的孔），并将 B 粘合到 b 时，会发生什么？"><figcaption aria-hidden="true">BEGIN WITH A PLANE WITH FOUR HOLES, EACHOF WHICH JUST TOUCHES THREE OTHERS, WHAT HAPPENS WHEN WE GLUE <span class="math inline">\(A\)</span> TO <span class="math inline">\(a\)</span> (THE SMALL ONE) AND <span class="math inline">\(B\)</span> TO <span class="math inline">\(b\)</span>?<br>从一个带有四个孔的平面开始，每个孔都与另外三个孔相切。当我们将 <span class="math inline">\(A\)</span> 粘合到 <span class="math inline">\(a\)</span>（较小的孔），并将 <span class="math inline">\(B\)</span> 粘合到 <span class="math inline">\(b\)</span> 时，会发生什么？</figcaption></figure><figure><img src="/images/indra/fig-7.7-2.jpg" width="200" alt="FIRST PULL a AWAY FROM A AND B AWAY FROM b ALONG THE ARCS L AND M. HOW WE SEE A DISTORTED BUT FAMILIAR PICTURE: ABab. 首先，沿弧线 L 将 a 从 A 处拉开，沿弧线 M 将 B 从 b 处拉开。此时会呈现一个扭曲但熟悉的图案：ABab。"><figcaption aria-hidden="true">FIRST PULL a AWAY FROM A AND B AWAY FROMb ALONG THE ARCS <span class="math inline">\(L\)</span> AND <span class="math inline">\(M\)</span>. HOW WE SEE A DISTORTED BUT FAMILIARPICTURE: <span class="math inline">\(ABab\)</span>.<br>首先，沿弧线 <span class="math inline">\(L\)</span> 将 <span class="math inline">\(a\)</span> 从 <span class="math inline">\(A\)</span> 处拉开，沿弧线 <span class="math inline">\(M\)</span> 将 <span class="math inline">\(B\)</span> 从 <span class="math inline">\(b\)</span>处拉开。此时会呈现一个扭曲但熟悉的图案：<span class="math inline">\(ABab\)</span>。</figcaption></figure><figure><img src="/images/indra/fig-7.7-3.jpg" width="200" alt="ADO THE POINT AT INFINITY TO WRAP UP THE PLANE. 通过添加无穷远点使平面闭合。"><figcaption aria-hidden="true">ADO THE POINT AT INFINITY TO WRAP UP THEPLANE.<br>通过添加无穷远点使平面闭合。</figcaption></figure><figure><img src="/images/indra/fig-7.7-4.jpg" width="200" alt="STRETCH TO MAKE THIS FAMILIAR SURFACE. NOTE ARCS L AND M. 拉伸形成我们熟悉的曲面。注意观察弧线 L 和 M。"><figcaption aria-hidden="true">STRETCH TO MAKE THIS FAMILIAR SURFACE.NOTE ARCS <span class="math inline">\(L\)</span> AND <span class="math inline">\(M\)</span>.<br>拉伸形成我们熟悉的曲面。注意观察弧线 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span>。</figcaption></figure><figure><img src="/images/indra/fig-7.7-5.jpg" width="200" alt="NOW SOMETHING STRANGE: PULL TOGETHER THE TOP HALVES OF A AND a AND THE BOTTOM HALVES OF B AND b. 进行奇怪的操作：将 A 和 a 的上半部分、B 和 b 的下半部分别拉到一起。"><figcaption aria-hidden="true">NOW SOMETHING STRANGE: PULL TOGETHER THETOP HALVES OF <span class="math inline">\(A\)</span> AND <span class="math inline">\(a\)</span> AND THE BOTTOM HALVES OF <span class="math inline">\(B\)</span> AND <span class="math inline">\(b\)</span>.<br>进行奇怪的操作：将 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(a\)</span> 的上半部分、<span class="math inline">\(B\)</span> 和 <span class="math inline">\(b\)</span> 的下半部分别拉到一起。</figcaption></figure><figure><img src="/images/indra/fig-7.7-6.jpg" width="200" alt="GUE TOP OF A TO TOP of a, BOTTOM OF B TO BOTTOM OF b. 将 A 的顶部和 a 的顶部粘在一起，将 B 的底部和 b 的底部粘在一起。"><figcaption aria-hidden="true">GUE TOP OF <span class="math inline">\(A\)</span> TO TOP of <span class="math inline">\(a\)</span>, BOTTOM OF <span class="math inline">\(B\)</span> TO BOTTOM OF <span class="math inline">\(b\)</span>.<br>将 <span class="math inline">\(A\)</span> 的顶部和 <span class="math inline">\(a\)</span> 的顶部粘在一起，将 <span class="math inline">\(B\)</span> 的底部和 <span class="math inline">\(b\)</span> 的底部粘在一起。</figcaption></figure><figure><img src="/images/indra/fig-7.7-7.jpg" width="200" alt="NOW JOIN THE REST OF A TO a ANP B TO b. 继续完成 A 与 a、B 与 b 剩余部分的粘合。"><figcaption aria-hidden="true">NOW JOIN THE REST OF <span class="math inline">\(A\)</span> TO <span class="math inline">\(a\)</span> ANP <span class="math inline">\(B\)</span> TO <span class="math inline">\(b\)</span>.<br>继续完成 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(a\)</span>、<span class="math inline">\(B\)</span>与 <span class="math inline">\(b\)</span> 剩余部分的粘合。</figcaption></figure><figure><img src="/images/indra/fig-7.7-8.jpg" width="200" alt="FINALLY, SHORTEN THE ARCS L AND M … 最终收缩弧线 L 和 M …"><figcaption aria-hidden="true">FINALLY, SHORTEN THE ARCS <span class="math inline">\(L\)</span> AND <span class="math inline">\(M\)</span> …<br>最终收缩弧线 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span> …</figcaption></figure><figure><img src="/images/indra/fig-7.7-9.jpg" width="200" alt="UNTIL EACH ARC SHRINKS TO A POINT, MAKING TWO TRIPLY-PUNCTURED SPHERES. 直至每个弧线都坍缩为一点，形成两个三穿孔球面。"><figcaption aria-hidden="true">UNTIL EACH ARC SHRINKS TO A POINT, MAKINGTWO TRIPLY-PUNCTURED SPHERES.<br>直至每个弧线都坍缩为一点，形成两个三穿孔球面。</figcaption></figure></div><h1 id="tiling-the-inner-disks">Tiling the inner disks</h1><div class="statement simple plain unnumbered"><p>Figure 7.6 is made up of lots of disks full of Dr.&nbsp;Sticklers, eachtiled by ideal triangles shown in grey. These disks are the remnants ofthe pink region in Figure 7.4. For most of the rest of this chapter, weshall be occupied with the tiling of just one of these disks. The sametiling fills out the insides of each of the glowing circles in Figure7.3. The group of symmetries which goes with this very special disktessellation is called the modular group and has been the well-spring ofa huge body of mathematics.</p></div><p><a href="#fig-7.6">图 7.6</a> 由无数布满 Sticklers博士身影的圆盘构成，每个圆盘都被灰色的理想三角形所镶嵌。这些圆盘正是 <a href="#fig-7.4">图 7.4</a>中粉色区域的残迹。在本章接下来的大部分篇幅里，我们将专注于研究其中一个圆盘的密铺结构。同样的密铺图案也出现在<a href="#fig-7.3">图 7.3</a>中每个发光圆圈的内部。这种独特的圆盘镶嵌的对称群称为模群，它一直是众多数学成果的源泉。</p><div class="statement simple plain unnumbered"><p>Since the tiling in each disk is the same, we may as well focus onthe large disk through -1 and 0, shown in yellow in Figure 7.8. Tounderstand how these ideal triangle tiles cover the yellow disk we needto find the subgroup of all the transformations in the gasket groupwhich map the inside of this disk to itself. This subgroup (which is ofcourse also a group in its own right), or any of its conjugates, is whatwe call the modular group. The basic tile is made up of two idealtriangles, the ones coloured green and yellow in Figure 7.6. The twotriangles together form one of our familiar four-sided pinched-off tileswith four circular arc sides. Moved around by the modular group, theytile the whole yellow disk.</p></div><p>由于每个圆盘中的密铺方式相同，我们可以将注意力集中在通过 -1 和 0的大圆盘上，这在 <a href="#fig-7.8">图 7.8</a>中以黄色部分表示。为了理解这些理想三角形如何覆盖黄色圆盘，我们需要找出垫片群中所有将圆盘内部映射到自身的变换子群。这个子群（显然，它本身也是一个群），或者它的任何共轭子群，便是我们所称的模群。基本的瓷砖由两个理想三角形组成，即<a href="#fig-7.6">图 7.6</a>中绿色和黄色的三角形。这两个三角形合在一起，构成了我们熟悉的四边弧形瓷砖。通过模群的作用，它们密铺了整个黄色圆盘。</p><figure id="fig-7.8"><img src="/images/indra/fig-7.8.jpg" width="600" alt="Figure 7.8. The set-up of tangent circles for the modular subgroup. The left frame is just to get oriented. The red circles C_A and C_a, together with the level 2 green circles B(C_a)=C_{Ba} and B(C_A)=C_{BA} form the boundary of the new four-sided tile. The arrows show how a pairs C_A to C_a and b pairs C_B to C_b. The boundary of the yellow disk is the limit set of the modular group generated by a and BAb. 图 7.8. 模群的切线圆配置。左侧子图仅用于帮助定位。红色圆圈 C_A 和 C_a，以及二级绿色圆圈 B(C_a)=C_{Ba} 和 B(C_A)=C_{BA} 共同构成了新四边形瓷砖的边界。箭头指示了变换 a 如何将 C_A 和 C_a 配对，变换 b 如何将 C_B 和 C_b 配对。黄色圆盘的边界是由 a 和 BAb 生成的模群的极限集。"><figcaption aria-hidden="true">Figure 7.8. The set-up of tangent circlesfor the modular subgroup. The left frame is just to get oriented. Thered circles <span class="math inline">\(C_A\)</span> and <span class="math inline">\(C_a\)</span>, together with the level 2 greencircles <span class="math inline">\(B(C_a)=C_{Ba}\)</span> and <span class="math inline">\(B(C_A)=C_{BA}\)</span> form the boundary of thenew four-sided tile. The arrows show how <span class="math inline">\(a\)</span> pairs <span class="math inline">\(C_A\)</span> to <span class="math inline">\(C_a\)</span> and <span class="math inline">\(b\)</span> pairs <span class="math inline">\(C_B\)</span> to <span class="math inline">\(C_b\)</span>. The boundary of the yellow disk isthe limit set of the modular group generated by <span class="math inline">\(a\)</span> and <span class="math inline">\(BAb\)</span>.<br>图 7.8. 模群的切线圆配置。左侧子图仅用于帮助定位。红色圆圈 <span class="math inline">\(C_A\)</span> 和 <span class="math inline">\(C_a\)</span>，以及二级绿色圆圈 <span class="math inline">\(B(C_a)=C_{Ba}\)</span> 和 <span class="math inline">\(B(C_A)=C_{BA}\)</span>共同构成了新四边形瓷砖的边界。箭头指示了变换 <span class="math inline">\(a\)</span> 如何将 <span class="math inline">\(C_A\)</span> 和 <span class="math inline">\(C_a\)</span> 配对，变换 <span class="math inline">\(b\)</span> 如何将 <span class="math inline">\(C_B\)</span> 和 <span class="math inline">\(C_b\)</span> 配对。黄色圆盘的边界是由 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(BAb\)</span> 生成的模群的极限集。</figcaption></figure><div class="statement simple plain unnumbered"><p>We worked out the labels of the boundary circles <span class="math inline">\(C_a, C_A, C_{BA}\)</span> and <span class="math inline">\(C_{Ba}\)</span> in Figure 7.8 of the four-sidedtile by going to part of the level-two Schottky chain for the gasketgroup. (You may find it easiest to check the arrangement in a picturelike the left frame of Figure 7.4 without all the extra gaskettangencies first.) Notice the four tangency points of these circles areall on the boundary of the yellow disk. As you can see, the four circlesform a new chain of tangent circles. As usual, <span class="math inline">\(a\)</span> pairs <span class="math inline">\(C_A\)</span> to <span class="math inline">\(C_a\)</span>. In addition, <span class="math inline">\(BAb\)</span> pairs <span class="math inline">\(C_{Ba}\)</span> to <span class="math inline">\(C_{BA}\)</span> because:</p><p><span class="math display">\[BAb\left(C_{Ba}\right) =BAb\left(B\left(C_a\right)\right) = BA\left(C_a\right) =B\left(C_A\right) = C_{BA}.\]</span></p><p>Inside the gasket group we have found another mini-chain of fourtangent circles, together with a pair of transformations which matchthem together in pairs!</p></div><p>我们通过研究垫片群的二级 Schottky 链的局部结构，确定了 <a href="#fig-7.8">图 7.8</a> 中四边形瓷砖的边界圆 <span class="math inline">\(C_a,C_A,C_{BA}\)</span> 和 <span class="math inline">\(C_{Ba}\)</span> 的标签。（建议首先参考 <a href="#fig-7.4">图 7.4</a>左图中圆的排列，暂时忽略所有额外的垫片切点，会更容易理解）。值得注意的是，这些圆的四个切点全部位于黄色圆盘的边界上。正如你所见，这四个圆形成了一个新的切圆链。按照惯例，变换<span class="math inline">\(a\)</span> 将圆 <span class="math inline">\(C_A\)</span> 和 <span class="math inline">\(C_a\)</span> 配对。此外，变换 <span class="math inline">\(BAb\)</span> 将圆 <span class="math inline">\(C_{Ba}\)</span> 和 <span class="math inline">\(C_{BA}\)</span> 配对，原因如下： <span class="math display">\[BAb\left(C_{Ba}\right) =BAb\left(B\left(C_a\right)\right) = BA\left(C_a\right) =B\left(C_A\right) = C_{BA}.\]</span>在垫片群中，我们发现了一个由四个相切圆组成的迷你链，以及一对将它们成对匹配的变换！</p><div class="statement simple plain unnumbered"><p>This construction shows that the modular group is a new kind of‘necklace group’, made by disregarding all the rest of the gasket andlooking only at the disks produced by acting with <span class="math inline">\(a\)</span> and <span class="math inline">\(BAb\)</span> on the four circles which bound thenew tile. The new group is generated by the transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(BAb\)</span>. Indeed in Figure 7.3, you canactually pick out chains of image disks nicely shrinking down onto theglowing limit circle through -1 and 0 . The only difference from thekissing Schottky groups we met in the last chapter is that the twogenerators pair not opposite circles but adjacent ones. As we shallexplain in more detail on p.&nbsp;213 ff., the image circles shrink because<span class="math inline">\(a,BAb\)</span> and their product <span class="math inline">\(aBAb\)</span> are all parabolic.</p></div><p>这一构造表明，模群是一种新型的“项链群”，它是通过忽略垫片的其余部分，仅关注由变换<span class="math inline">\(a\)</span> 和 <span class="math inline">\(BAb\)</span>作用于新瓷砖边界的四个圆所产生的圆盘而形成的。这个新群由变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(BAb\)</span> 生成。实际上，在 <a href="#fig-7.3">图 7.3</a>中，你可以清晰地看到一串映像圆盘，它们逐渐缩小并收敛到经过点 -1 和 0的发光极限圆上。这与上一章讨论的“接吻式 Schottky群”的唯一关键时，这两个生成元配对的不是相对的圆，而是相邻的圆。正如我们将在第213 页及以后章节中详细解释的那样，这些像圆之所以缩小，是因为 <span class="math inline">\(a,BAb\)</span> 以及它们的乘积 <span class="math inline">\(aBAb\)</span> 都是抛物型变换。</p><div class="statement simple plain unnumbered"><p>The same pattern of pairing circles is repeated all over the gasket.Every pink disk is the image of the yellow one under some element in thegasket group, which conjugates our modular group to another ‘modulargroup’ acting in the new disk. The white disks are different from thepink ones, because you can never get from pink to white usingtransformations in the gasket group. However you can still find a chainof four tangent circles matched in the same pattern, as described in <a href="#proj-7.4" title="Project 7.4">Project 7.4</a>.</p></div><p>在垫片的每一个局部区域，都能观察到完全相同的圆配对模式。每个粉色圆盘均可视为黄色圆盘经垫片群中某个变换作用后的像——这个变换元素会将我们原本的模群共轭到一个新的”模群”，而新模群将作用在对应的粉色圆盘上。白色圆盘与粉色圆盘存在本质区别：垫片群中的任意变换都无法将粉色圆盘映射为白色圆盘。不过，我们仍能找到四个相切圆构成的配对链，其模式与前文所述完全一致（具体构造方法详见项目7.4）。</p><div class="statement simple plain unnumbered"><p>You might well imagine that we should be set to repeat everything wedid in the last chapter. By taking four tangent circles and pairing themin this new pattern we should presumably get a whole new lot ofquasifuchsian groups. Not so! It turns out that the rigours imposed byspecifying that the two generators and their product are all parabolicactually ‘freeze’ the group. Without any mention of circle chains, weprove in Note 7.1 the remarkable fact that all groups made with pairingconditions like this are, up to conjugation, ‘the same’. What this meansin more detail is this. Suppose that <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are any two parabolic Möbiustransformations with the property that <span class="math inline">\(UV\)</span> is also parabolic, and such that thefixed points <span class="math inline">\({\rm Fix}\,U\)</span> and <span class="math inline">\({\rm Fix}\,V\)</span> of <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are not the same. Then there is alwaysa conjugating map <span class="math inline">\(M\)</span> such that:<span class="math display">\[MUM^{-1} = \begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix}, \quadMVM^{-1} = \begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}.\]</span> This explains why there are so many circles in the gasketgroup, and why you get an identical tiling pattern in each one.</p></div><p>你或许会以为，我们接下来要做的就是重复上一章的研究过程。毕竟，如果我们选取四个相切圆并按照这种新模式进行配对，似乎理所当然会得到一大堆新的拟富克斯群。然而并非如此！事实证明，要求两个生成元及其乘积都是抛物型变换这一刚性条件，实际上”冻结”了群的结构。在<a href="#note-7.1" title="注记 7.1">注记 7.1</a>中，我们甚至无需提及圆链的概念，就证明了这样一个惊人的结论：所有满足这种配对条件的群，在共轭意义下其实都是“相同”的。具体而言，设<span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 是任意两个抛物型莫比乌斯变换，满足<span class="math inline">\(UV\)</span> 仍为抛物型，且两者的不动点 <span class="math inline">\(\mathrm{Fix}\,U\)</span> 与 <span class="math inline">\(\mathrm{Fix}\,V\)</span>互异，那么，总存在一个共轭变换 <span class="math inline">\(M\)</span>，使得： <span class="math display">\[MUM^{-1} = \begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix}, \quadMVM^{-1} = \begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}.\]</span> 这也解释了为何在垫片群（gasketgroup）中会出现那么多的圆，以及为何每个圆内的镶嵌图案都一模一样。</p><div id="note-7.1" class="statement sta_note_7_1__uniqueness_of_the_modular_group definition unnumbered"><p><span class="statement-heading"><span class="statement-label">Note7.1: Uniqueness of the modular group</span>：</span><span class="statement-spah"> </span><br></p><p><strong>注 7.1：模群的唯一性</strong></p><p>Suppose that <span class="math inline">\(U\)</span>, <span class="math inline">\(V\)</span> and <span class="math inline">\(UV\)</span> are all parabolic (and therefore notthe identity!) and the fixed point of <span class="math inline">\(U\)</span> is <span class="math inline">\(z_U\)</span> and the fixed point of <span class="math inline">\(V\)</span> is <span class="math inline">\(z_V\)</span>. We are trying to conjugate <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> to the generators of the modular group.We have seen that we can find a Möbius transformation <span class="math inline">\(M\)</span> that maps <span class="math inline">\(z_U\)</span> to <span class="math inline">\(0\)</span> and <span class="math inline">\(z_V\)</span> to <span class="math inline">\(\infty\)</span>. Conjugating our originaltransformations <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> by <span class="math inline">\(M\)</span> arranges that <span class="math inline">\(MUM^{-1}(0)=0\)</span> and <span class="math inline">\(MVM^{-1}(\infty)=\infty\)</span>, and still thetwo transformations <span class="math inline">\(MUM^{-1}\)</span> and<span class="math inline">\(MVM^{-1}\)</span> are parabolic. Since wecan simultaneously conjugate them in this way, we may just as wellassume the original transformations <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> have fixed points <span class="math inline">\(0\)</span> and <span class="math inline">\(\infty\)</span>, respectively.</p><p>A parabolic transformation that fixes <span class="math inline">\(\infty\)</span> is always conjugate to any other,up to a minus sign. (See Chapter 3.) Let’s arrange by conjugation andpossibly multiplying by -1 that <span class="math inline">\(V\)</span>corresponds to the matrix <span class="math inline">\(\begin{pmatrix} 1&amp; 2 \\ 0 &amp; 1 \end{pmatrix}\)</span>.　Now all that’s left is<span class="math inline">\(U\)</span>. Since <span class="math inline">\(U(0)=0\)</span>, after again possibly multiplyingby -1, we can conclude that the matrix of <span class="math inline">\(U\)</span> is <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix}\]</span> for some number <span class="math inline">\(x\)</span>.</p><p>That brings us to the last hypothesis that <span class="math inline">\(UV\)</span> is parabolic. Let’s multiply thisout:</p><p><span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix} \begin{pmatrix} 1&amp; 2 \\ 0 &amp; 1 \end{pmatrix} = \begin{pmatrix} 1 &amp; 2 \\ x&amp; 1+2x \end{pmatrix}.\]</span></p><p>The trace of <span class="math inline">\(UV\)</span> under theseassumptions is <span class="math inline">\(2 + 2x\)</span>. This is<span class="math inline">\(\pm 2\)</span> for precisely two values of<span class="math inline">\(x\)</span>, namely, <span class="math inline">\(x = -2\)</span> and <span class="math inline">\(x= 0\)</span>. In the latter case, <span class="math inline">\(U\)</span>is the identity, which we are definitely excluding. That means <span class="math inline">\(x = -2\)</span>, and we have shown that <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are simultaneously conjugate to <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix} \text{ and }\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}.\]</span> (We may have to multiply one or both matrices by -1 to arrangethat they both have trace 2.)</p><p>假设 <span class="math inline">\(U\)</span>, <span class="math inline">\(V\)</span> 和 <span class="math inline">\(UV\)</span>均为抛物型变换（因此不是恒等变换！），且 <span class="math inline">\(U\)</span> 的不动点是 <span class="math inline">\(z_U\)</span>，<span class="math inline">\(V\)</span> 的不动点是 <span class="math inline">\(z_V\)</span>。我们的目标是将 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span>共轭变换为模群的生成元。我们已经看到，可以找到一个莫比乌斯变换 <span class="math inline">\(M\)</span>，它将 <span class="math inline">\(z_U\)</span> 映射到 <span class="math inline">\(0\)</span>，<span class="math inline">\(z_V\)</span> 映射到 <span class="math inline">\(\infty\)</span>。通过 <span class="math inline">\(M\)</span> 对原变换 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 进行共轭后，新变换 <span class="math inline">\(MUM^{-1}\)</span> 将保持 0 不变，<span class="math inline">\(MVM^{-1}\)</span> 将保持 <span class="math inline">\(\infty\)</span>不变，且两者仍为抛物型变换。既然这种共轭可同步完成，我们不妨直接假设原变换<span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 的不动点分别是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>。</p><p>固定 <span class="math inline">\(\infty\)</span>的抛物型变换在相差一个符号的意义下彼此共轭（参见第 3章）。通过适当共轭及可能的符号调整，可以使 <span class="math inline">\(V\)</span> 对应于矩阵 <span class="math inline">\(\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1\end{pmatrix}\)</span>。此时仅需确定 <span class="math inline">\(U\)</span> 的形式。由于 <span class="math inline">\(U(0) = 0\)</span>，经可能的符号调整后，<span class="math inline">\(U\)</span> 的矩阵必为： <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix}\quad(x\in\mathbb{C}).\]</span> 最后利用 <span class="math inline">\(UV\)</span>是抛物型这一条件。计算乘积： <span class="math display">\[UV=\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix} \begin{pmatrix}1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix} = \begin{pmatrix} 1 &amp; 2 \\ x&amp; 1+2x \end{pmatrix}.\]</span> 此时 <span class="math inline">\(UV\)</span> 的迹是 <span class="math inline">\(2 + 2x\)</span>。抛物型变换的迹需满足 <span class="math inline">\(|\mathop{\mathrm{Tr}}|=2\)</span>，这恰好对 <span class="math inline">\(x\)</span> 的两个值成立，即 <span class="math inline">\(x = -2\)</span> 和 <span class="math inline">\(x =0\)</span>。当 <span class="math inline">\(x=0\)</span> 时，<span class="math inline">\(U\)</span> 退化为恒等变换（已排除），因此必有<span class="math inline">\(x=−2\)</span>。由此可知 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 可共轭于矩阵： <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix} \text{ and }\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}\]</span> （必要时可对其中一个或两个矩阵取负，以确保其迹均为 2）</p></div><h1 id="the-modular-group-of-arithmetic">The modular group ofarithmetic</h1><div class="statement simple plain unnumbered"><p>The result just discussed shows that the modular group is conjugateto a very famous group of great importance in number theory. It is madeby arranging the four Schottky circles with their tangency points at<span class="math inline">\(-1,0,1\)</span> and <span class="math inline">\(\infty\)</span>. You can see these, coloured redand green, in the left frame of Figure 7.9. Since one of the tangencypoints is the point at infinity, two of the circles show up as greenvertical lines. These green lines are paired by <span class="math inline">\(b=\begin{pmatrix}1&amp;2\\0&amp;1\end{pmatrix}\)</span>,while the two red circles tangent at 0 are paired by <span class="math inline">\(a=\begin{pmatrix}1&amp;0\\-2&amp;1\end{pmatrix}\)</span>.Notice how <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> match adjacent circles in the chain inexactly the pattern of the red and green arrows in Figure 7.8. In fact,as you can easily calculate, <span class="math inline">\(ab\)</span> isthe parabolic transformation <span class="math inline">\(\begin{pmatrix}1&amp;2\\-2&amp;-3\end{pmatrix}\)</span>.</p></div><p>刚刚讨论的结果表明，模群与一个在数论中极为著名且重要的群是共轭的。这个群是通过排列四个肖特基圆生成的，其切点分别位于<span class="math inline">\(-1, 0, 1\)</span> 和 <span class="math inline">\(\infty\)</span>。在 <a href="#fig-7.9">图 7.9</a>的左图中，这些圆分别以红绿两色呈现。由于其中一个切点是无穷远点，因此有两个圆在图中呈现为绿色的垂直直线。这两条绿色直线由变换<span class="math inline">\(b=\begin{pmatrix}1&amp;2\\0&amp;1\end{pmatrix}\)</span>配对，而在原点 0 处相切的两个红色圆则通过变换 <span class="math inline">\(a=\begin{pmatrix}1&amp;0\\-2&amp;1\end{pmatrix}\)</span>配对。请注意，变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 对相邻圆的配对方式，恰好与 <a href="#fig-7.8">图 7.8</a>中红绿箭头所示的模式完全一致。事实上，通过简单的计算即可验证，<span class="math inline">\(ab\)</span> 是抛物型变换 <span class="math inline">\(\begin{pmatrix}1&amp;2\\-2&amp;-3\end{pmatrix}\)</span>。</p><figure id="fig-7.9"><img src="/images/indra/fig-7.9.jpg" width="600" alt="Figure 7.9. The modular tessellation of the upper half plane. The left frame shows the tiling or tessellation of the upper half plane by ideal triangles belonging to the smaller modular group coming from pairing tangent circles, while the right frame shows the richer tessellation associated to the full modular group with its added symmetries. Each tile on the left is subdivided into twelve tiles on the right. 图 7.9. 上半平面的模群密铺。左图展示了通过配对相切圆生成的子模群对应的理想三角形密铺结构；右图则展示具有完整模群对称性的更加精细的密铺。左侧的每个瓷砖在右侧被细分为十二个小瓷砖。"><figcaption aria-hidden="true">Figure 7.9. The modular tessellation ofthe upper half plane. The left frame shows the tiling or tessellation ofthe upper half plane by ideal triangles belonging to the smaller modulargroup coming from pairing tangent circles, while the right frame showsthe richer tessellation associated to the full modular group with itsadded symmetries. Each tile on the left is subdivided into twelve tileson the right.<br>图 7.9.上半平面的模群密铺。左图展示了通过配对相切圆生成的子模群对应的理想三角形密铺结构；右图则展示具有完整模群对称性的更加精细的密铺。左侧的每个瓷砖在右侧被细分为十二个小瓷砖。</figcaption></figure><div class="statement simple plain unnumbered"><p>It is no coincidence that the entries of these three matrices areintegers. The right frame of Figure 7.9 is a more complicated picturewhich shows all the symmetries of the tiling on the left. Each idealtriangle has been subdivided into three hatched and three unhatchedsub-triangles. (The sub-triangles are not quite ideal, because only oneof their angles is 0 .) The group of symmetries of this more complicatedtiling is, from the point of view of Möbius maps, the simplest group ofall: just the set of all <span class="math inline">\(2\times 2\)</span>matrices <span class="math inline">\(\begin{pmatrix}p&amp;q\\r&amp;s\end{pmatrix}\)</span>with integer entries <span class="math inline">\(p,q,r\)</span> and<span class="math inline">\(s\)</span> and determinant <span class="math inline">\(ps-qr\)</span> equal to 1. To distinguish from thegroup of the left frame, we sometimes call it the full modular group.The matrices in the (smaller) modular group of the left picture are justthose matrices with integer entries for which <span class="math inline">\(q\)</span> and <span class="math inline">\(r\)</span> are even and <span class="math inline">\(p\)</span> and <span class="math inline">\(s\)</span> are odd.</p></div><p>这三个矩阵的元素都是整数，此现象绝非偶然。<a href="#fig-7.9">图7.9</a>右侧的复杂图像完整呈现了左侧密铺图案的所有对称性。每个理想三角形都被剖分为三个阴影子三角形和三个非阴影子三角形。（这些子三角形并不完全是理想的，因为它们只有一个角为0）。从莫比乌斯变换的角度来看，这个更复杂的密铺结构的对称群是最简单的：即所有元素为整数且行列式<span class="math inline">\(ps-qr\)</span> 等于 1 的 <span class="math inline">\(2\times2\)</span> 矩阵 <span class="math inline">\(\begin{pmatrix}p&amp;q\\r&amp;s\end{pmatrix}\)</span>构成的集合。为了与左图的对称群区分开来，该群常被称为全模群。而左侧密铺对应的（较小）模群则由满足特殊同余条件的整数矩阵构成——其<span class="math inline">\(q\)</span> 与 <span class="math inline">\(r\)</span> 元素都是偶数，<span class="math inline">\(p\)</span> 与 <span class="math inline">\(s\)</span> 元素都是奇数。</p><div class="statement simple plain unnumbered"><p>There is a very beautiful connection between the modular tessellationand fractions: the points where the ideal triangles meet the real axisare exactly the rational numbers. Although it is something of adigression here, we want to take the time to explain the pattern, whichturns out to be indispensible when we come to map making in Chapter9.</p></div><p>模镶嵌与有理数之间有着极其美妙的联系：理想三角形与实轴交点恰恰是有理数。虽然这一内容在此略显偏离主题，但我们希望花些时间来阐明这个规律，因为它在第9 章的制图过程中将变得至关重要。</p><figure id="fig-7.10"><img src="/images/indra/fig-7.10.jpg" width="600" alt="Figure 7.10. The modular tiling from our ancestral home. The tessellation generated by the full modular group, conjugated over to the unit disk. This beautiful rendition is Figure 35 in Vol. 1 of Vorlesungen äber elliptischen Modulfunctionen by Klein and Fricke. 图 7.10. 来自我们老家的模密铺。这是一个由完整模群生成的镶嵌图案，经过共轭变换映射到单位圆盘上。这幅精美的图像出自克莱因与弗里克合著的《椭圆模函数讲义》第一卷中的第 35 图。"><figcaption aria-hidden="true">Figure 7.10. The modular tiling from ourancestral home. The tessellation generated by the full modular group,conjugated over to the unit disk. This beautiful rendition is Figure 35in Vol. 1 of Vorlesungen äber elliptischen Modulfunctionen by Klein andFricke.<br>图 7.10.来自我们老家的模密铺。这是一个由完整模群生成的镶嵌图案，经过共轭变换映射到单位圆盘上。这幅精美的图像出自克莱因与弗里克合著的《椭圆模函数讲义》第一卷中的第35 图。</figcaption></figure><div class="statement simple plain unnumbered"><p>Figure 7.11 shows the first few levels in the modular tessellation.The basic tile is the four-sided region, called an ideal quadrilateral,which was bounded by the coloured lines in Figure 7.9. Images of thisideal quadrilateral are shown bounded by solid arcs. The dotted arcsdivide them into the two ideal triangles which we saw, half hatched andhalf white, on the left in Figure 7.9. As the group acts on the basictile, we get more and more smaller and smaller tiles nesting down to thereal axis. The vertices of all these tiles meet the real axis in pointswhich are all fractions. Several things can be read off from a carefulexamination of this intricate pattern:</p><ul><li>All vertices of the tiles are rational numbers <span class="math inline">\(p/q\)</span>.</li><li>If <span class="math inline">\(r/s\)</span> and <span class="math inline">\(p/q\)</span> are two vertices of the same tile,then <span class="math inline">\(ps - rq = \pm 1\)</span>.</li><li>If <span class="math inline">\(r/s &lt; p/q\)</span> are the outertwo vertices of a tile, then the third vertex between them is <span class="math inline">\((r + p)/(s + q)\)</span>.</li></ul><p>Check this out! For instance, between <span class="math inline">\(2/3\)</span> and <span class="math inline">\(1/2\)</span>, we get <span class="math inline">\((2 + 1)/(3 + 2)\)</span>, that is <span class="math inline">\(3/5\)</span>.</p></div><p><a href="#fig-7.11">图 7.11</a>展示了模镶嵌的前几个层级。基本瓷砖是一个四边形，称为理想四边形，它由 <a href="#fig-7.9">图 7.9</a>中的彩色线条围成。实线弧显示了这个理想四边形的图像，而虚线弧将其分割成两个理想三角形，这两个三角形可以在<a href="#fig-7.9">图 7.9</a>的左侧看到，一半是阴影，一半是空白。随着群对基本瓷砖的作用，我们得到越来越多、越来越小的瓷砖，逐层嵌套，直至延伸到实轴。所有这些瓷砖的顶点都与实轴相交，这些交点都是分数。仔细观察这个复杂的图案，我们可以得出以下几个结论：</p><ul><li>所有瓷砖的顶点都是有理数 <span class="math inline">\(p/q\)</span>。</li><li>如果 <span class="math inline">\(r/s\)</span> 和 <span class="math inline">\(p/q\)</span> 是同一瓷砖的两个顶点，则 <span class="math inline">\(ps - rq = \pm 1\)</span>。</li><li>如果 <span class="math inline">\(r/s &lt; p/q\)</span>是同一瓷砖的两个外顶点，那么它们之间的第三个顶点是 <span class="math inline">\((r + p)/(s + q)\)</span>。</li></ul><p>验证一下吧！比如，在 <span class="math inline">\(2/3\)</span> 和<span class="math inline">\(1/2\)</span> 之间，我们得到 <span class="math inline">\((2 + 1)/(3 + 2)\)</span>，即 <span class="math inline">\(3/5\)</span>。</p><div class="statement simple plain unnumbered"><p>It’s easy to see why this happens. As we have seen, a typical matrixin the modular group will look like</p><p><span class="math display">\[M = \begin{pmatrix} p &amp; q \\ r &amp;s \end{pmatrix}\]</span></p><p>where <span class="math inline">\(p, q, r\)</span> and <span class="math inline">\(s\)</span> are integers and <span class="math inline">\(ps - rq = 1\)</span>. If <span class="math inline">\(M\)</span> acts on the vertices of the initialtriangle with vertices <span class="math inline">\(0 = 0/1, 1 =1/1\)</span> and <span class="math inline">\(\infty = 1/0\)</span>, thenwe get the new triangle with vertices <span class="math inline">\(M(0) =r/s, M(\infty) = p/q\)</span> and <span class="math inline">\(M(1) = (p+ r)/(q + s)\)</span>. Assuming all four entries are positive, we have<span class="math inline">\(r/s &lt; (p + r)/(q + s) &lt; p/q\)</span>(you can see this by multiplying out). This is just what we found inFigure 7.11. If <span class="math inline">\(p, q, r, s\)</span> are notall positive, there are half a dozen other cases in which the order ofthe points <span class="math inline">\(M(0), M(1)\)</span> and <span class="math inline">\(M(\infty)\)</span> is different but we get thesame result. The same thing happens if we start from the other triangle<span class="math inline">\(M(-1), M(0), M(\infty)\)</span>.</p></div><p>这个现象不难理解。我们知道，模群中的一个典型矩阵可以表示为 <span class="math display">\[M = \begin{pmatrix} p &amp; q \\ r &amp; s\end{pmatrix},\]</span> 其中 <span class="math inline">\(p, q,r\)</span> 和 <span class="math inline">\(s\)</span> 是整数，且满足<span class="math inline">\(ps - rq = 1\)</span>。如果矩阵 <span class="math inline">\(M\)</span>作用于初始三角形的顶点，该初始三角形的顶点分别是 <span class="math inline">\(0 = 0/1, 1 = 1/1\)</span> 和 <span class="math inline">\(\infty =1/0\)</span>，那么变换后的新三角形的顶点将变成 <span class="math inline">\(M(0) = r/s, M(\infty) = p/q\)</span> 和 <span class="math inline">\(M(1) = (p + r)/(q + s)\)</span>。假设 <span class="math inline">\(p,q,r,s\)</span> 都是正数，我们可以验证不等式<span class="math inline">\(r/s &lt; (p + r)/(q + s) &lt; p/q\)</span>成立（通过乘法可轻松验证）。这正是 <a href="#fig-7.11">图 7.11</a>所示的情况。如果 <span class="math inline">\(p, q, r, s\)</span>并非全为正数，还有几种不同的情形，此时点 <span class="math inline">\(M(0), M(1), M(\infty)\)</span>的顺序可能会改变，但结果仍然一致。类似地，若从另一个三角形 <span class="math inline">\(M(-1), M(0), M(\infty)\)</span>出发，也会得到相同的结论。</p><div class="statement simple plain unnumbered"><p>Any two fractions <span class="math inline">\(r/s\)</span> and <span class="math inline">\(p/q\)</span> such that <span class="math inline">\(ps - qr = \pm 1\)</span> are called neighbours.Thus any two vertices of an ideal triangle in the modular tessellationare neighbours. If <span class="math inline">\(p/q\)</span> is afraction, then, as we explain in Project 7.5, the process of finding itsneighbours is essentially Euclid’s two thousand year old algorithm forfinding the highest common factor of two numbers, surely one of the mostuseful and clever algorithms of all time. The rule for finding the‘next’ point <span class="math inline">\(\frac{p+r}{q+s}\)</span>between two neighbours is every student’s dream of what addition offractions should be. This simple form of fraction ‘addition’ issometimes called Farey addition’, which one might want to symbolise witha funny symbol like:</p><p><span class="math display">\[\frac{p}{q} \oplus \frac{r}{s} = \frac{p + r}{q + s}\]</span></p><p>Farey addition gives a neat way of organising the rational numbers.Instead of the usual way of arranging them in increasing order (which isdifficult, because you never know which one should come ‘next’),fractions can be described by a sequence of left or right moves,reflecting the choice at each stage of whether we choose the new pair ofneighbours to the right, or the pair of neighbours to the left.</p></div><p>任何两个分数 <span class="math inline">\(r/s\)</span> 和 <span class="math inline">\(p/q\)</span>，若满足 <span class="math inline">\(ps - qr = \pm1\)</span>，则称它们为邻居。因此，模群镶嵌中的理想三角形的任意两个顶点都是邻居。如果<span class="math inline">\(p/q\)</span> 是一个分数，那么正如我们在项目7.5中所解释的那样，寻找其邻居的过程，本质上就是欧几里得两千年前发明的最大公约数算法——这无疑是人类历史上最实用、最巧妙的算法之一。计算两个邻居之间“下一个”点<span class="math inline">\(\frac{p+r}{q+s}\)</span>的规则，正是每个学生心目中理想的分数加法方式。这种简单的分数“加法”有时被称为“法雷加法”（Fareyaddition），人们或许会用一个有趣的符号来表示它，比如： <span class="math display">\[\frac{p}{q} \oplus \frac{r}{s} = \frac{p + r}{q + s}\]</span></p><p>法雷加法提供了一种巧妙的方式来组织有理数。不像按递增顺序排列那样麻烦（毕竟你很难确定下一个该是谁），分数可以通过一系列左移或右移的操作来描述，这正对应了我们在每一步中选择将新的邻居对放置在左边还是右边的决定。</p><div class="statement simple plain unnumbered"><p>For positive fractions, the starting point are the two fractions<span class="math inline">\(0/1\)</span> and <span class="math inline">\(1/0\)</span>, which we can regard as specialhonourary neighbours because they are connected by a side of our initialtriangle, the vertical imaginary axis. Farey addition gives thein-between fraction <span class="math inline">\(0/1\oplus1/0=1/1\)</span>.</p><p>Now we have a choice: go to the ‘left’ and look in the intervalbetween 0 and 1, or go to the ‘right’ and look in the interval between 1and <span class="math inline">\(\infty\)</span>. Suppose we are aimingfor the fraction <span class="math inline">\(3/5\)</span>. Then we turnto the left and apply the Farey addition <span class="math inline">\(0/1\oplus 1/1 = 1/2\)</span>. At the next stage, we choose the rightinterval and Farey add to get <span class="math inline">\(1/2 \oplus 1/1= 2/3\)</span>. Finally, we choose the left interval and Farey add <span class="math inline">\(1/2 \oplus 2/3 = 3/5\)</span>. An exactly similarprocedure could be applied to home in on any fraction <span class="math inline">\(p/q\)</span>. Our choice of left-right turns is adriving map: <span class="math inline">\(3/5\)</span> is given by theinstructions ‘left, right, left’. This arrangement of fractions andsequence of right-left moves is closely related to a way of writingfractions as what are called continued fractions, explained in Note7.2.</p></div><p>对于正分数，我们的起点是两个特殊的分数：<span class="math inline">\(0/1\)</span> 和 <span class="math inline">\(1/0\)</span>。我们不妨将它们视作“荣誉邻居”，因为它们由初始三角形的一条边——垂直的虚轴——连接在一起。利用Farey 加法，我们可以在它们之间找到一个中间分数：<span class="math inline">\(0/1 \oplus 1/0 = 1/1\)</span>。</p><p>接下来，我们需要做出选择：向“左”走，查看 0 到 1之间的区间；还是向“右”走，查看 1 到 <span class="math inline">\(\infty\)</span> 之间的区间。假设我们的目标是分数<span class="math inline">\(3/5\)</span>。那么我们选择向左，执行 Farey加法：<span class="math inline">\(0/1 \oplus 1/1 =1/2\)</span>。在下一步，我们转向右侧区间，并执行 Farey 加法得到：<span class="math inline">\(1/2 \oplus 1/1 =2/3\)</span>。最后，我们再次选择左侧区间，进行 Farey 加法：<span class="math inline">\(1/2 \oplus 2/3 = 3/5\)</span>。</p><p>通过完全相同的步骤，我们可以找到任意分数 <span class="math inline">\(p/q\)</span>。我们每次选择向左或向右的决策就像一张“导航图”：例如，分数<span class="math inline">\(3/5\)</span>对应的指令是“左、右、左”。这种分数的排列方式和左右转向的序列，与将分数表示为连分数的写法密切相关，详见<a href="#note-7.2" title="注记 7.2">注记 7.2</a>。</p><div id="note-7.2" class="statement sta_note_7_2__continued_fractions definition unnumbered"><p><span class="statement-heading"><span class="statement-label">Note7.2: Continued fractions</span>：</span><span class="statement-spah"></span><strong>注记 7.2 连分数</strong></p><p>Expressions like <span class="math display">\[\frac{3}{10} =\frac{1}{3 + \frac{1}{3}}\]</span> and <span class="math display">\[\frac{2}{19} = \frac{1}{2 + \frac{1}{9}}\]</span>are called continued fractions. It turns out that every fraction <span class="math inline">\(p/q\)</span> can be written in a similar way.Assuming <span class="math inline">\(p/q\)</span> is between 0 and 1,then you can always write it in the form <span class="math display">\[\frac{p}{q} = \frac{1}{a + \frac{1}{b +\frac{1}{c + \frac{1}{\cdots}}}}\]</span> where <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>and so on are positive integers. Actually you can do the same even foran irrational number. The difference is that if the original number isirrational, then the terms <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>and so on continue without end. The sequence <span class="math inline">\(a, b, c, \ldots\)</span> always describes thenumber of left-right turns in the Farey algorithm we described in thetext.</p><p>If we successively ‘reduce’ a continued fraction by decreasing itsfinal entry by 1, down to the value 1, and then shrinking its length, werecover the Farey process for homing in on the fraction. For example,for the fraction <span class="math inline">\(3/5\)</span>, we get: <span class="math display">\[\begin{aligned}\frac{3}{5} &amp;= \frac{1}{2 + \frac{1}{2 + \frac{1}{2}}}\\\frac{2}{5} &amp;= \frac{1}{2 + \frac{1}{2 + \frac{1}{2}}}\\\frac{1}{3} &amp;= \frac{1}{2 + \frac{1}{1}}\\\frac{1}{2} &amp;= \frac{1}{2}.\end{aligned}\]</span> The process of turning a fraction into a continued fraction isvery closely related to Euclid’s algorithm. We give some hints inProject 7.5.</p><p>像下面这样的表达式 <span class="math display">\[\frac{3}{10} =\frac{1}{3 + \frac{1}{3}}\]</span> 和 <span class="math display">\[\frac{2}{19} = \frac{1}{2 + \frac{1}{9}}\]</span>被称为连分数。事实上，任何分数 <span class="math inline">\(p/q\)</span>都可以以类似的方式表示。假设 <span class="math inline">\(p/q\)</span>介于 0 与 1 之间，那么你总能将其写成如下的形式</p><p><span class="math display">\[\frac{p}{q} = \frac{1}{a + \frac{1}{b +\frac{1}{c + \frac{1}{\cdots}}}}\]</span> 其中 <span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>，<span class="math inline">\(c\)</span>等是正整数。实际上，即使是无理数，你也可以用同样的方式表示。区别在于，如果原始数字是无理数，那么项<span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>，<span class="math inline">\(c\)</span>等将无限延续下去。序列 <span class="math inline">\(a, b, c,\ldots\)</span> 始终对应于我们在正文中提到的 Farey算法中的左右转弯次数。</p><p>如果我们通过将连分数的最后一项逐步减 1，直到其值为1，然后缩短其长度，连续地“简化”一个连分数，我们就能恢复用于逼近该分数的Farey 过程。以分数 <span class="math inline">\(3/5\)</span>为例，经过这一过程，我们得到：</p><p><span class="math display">\[\begin{aligned}\frac{3}{5} &amp;= \frac{1}{2 + \frac{1}{2 + \frac{1}{2}}}\\\frac{2}{5} &amp;= \frac{1}{2 + \frac{1}{2 + \frac{1}{2}}}\\\frac{1}{3} &amp;= \frac{1}{2 + \frac{1}{1}}\\\frac{1}{2} &amp;= \frac{1}{2}.\end{aligned}\]</span></p><p>将一个分数转换成连分数的过程与欧几里得算法密切相关。我们在项目 7.5中提供了一些线索。</p></div><h1 id="the-pairing-pattern-of-the-modular-group">The pairing pattern ofthe modular group</h1><div class="statement simple plain unnumbered"><p>The modular group is a new kind of ‘necklace group’. It is still madeby pairing four tangent circles, and the only difference from thekissing Schottky groups we met in the last chapter is that thegenerators pair not opposite circles but adjacent ones. Whenever we havean arrangement of paired tangent circles like this, something like thenecklace condition on p.&nbsp;168 must still be true, but because we arepairing the circles in a different pattern, we can expect that differentelements must be parabolic to cause the image circles to shrink.</p></div><p>模群是一种新型的“项链群”。它同样由四个相切的圆配对构成，不同之处在于，生成元这次配对的不是相对的圆，而是相邻的圆。每当我们遇到这样的相切圆配对排列时，类似于第168页提到的“项链条件”仍然必须成立。不过，由于这次采用了不同的配对模式，我们可以预见，只有某些不同的元素变成抛物型时，像圆才会缩小。</p><div class="statement simple plain unnumbered"><p>With the notation of the figure beside Box 20, we have <span class="math inline">\(a(P) = R\)</span> and <span class="math inline">\(b(R) = P\)</span>, so that the four tangencypoints of the circles are <span class="math inline">\(S =\text{Fix}(a)\)</span>, <span class="math inline">\(Q =\text{Fix}(b)\)</span>, <span class="math inline">\(P =\text{Fix}(ba)\)</span>, and <span class="math inline">\(R =\text{Fix}(ab)\)</span>. By similar reasoning to that in Chapter 6, inorder for the image circles near <span class="math inline">\(S\)</span>and <span class="math inline">\(Q\)</span> to shrink, the generators<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> must be parabolic. Moreover, <span class="math inline">\(ba\)</span> must also be parabolic, to make thecircles shrink at <span class="math inline">\(P\)</span>. Notice that<span class="math inline">\(ab\)</span> and <span class="math inline">\(ba\)</span> are conjugate (since <span class="math inline">\(b(ab)b^{-1} = ba\)</span>), so saying that <span class="math inline">\(ab\)</span> or <span class="math inline">\(ba\)</span> must be parabolic is really one andthe same thing. The wonderful thing is, that as we proved in Note 7.1,all groups with these three elements parabolic are automaticallyconjugate. This is so important to us that we summarize it in Box20.</p></div><p>根据 <a href="#box20" title="框 20">框 20</a> 旁的图示，我们有 <span class="math inline">\(a(P) = R\)</span> 且 <span class="math inline">\(b(R) = P\)</span>，因此四个切点分别是：<span class="math inline">\(S＝\mathrm{Fix}\,(a)\)</span>, <span class="math inline">\(Q =\mathrm{Fix}\,(b)\)</span>, <span class="math inline">\(P =\mathrm{Fix}\,(ba)\)</span> 和 <span class="math inline">\(R=\mathrm{Fix}\,(ab)\)</span>。类似于第 6章的推理，为使靠近 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(Q\)</span> 的像圆收缩，生成元 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 必须是抛物型变换。而且 <span class="math inline">\(ba\)</span> 也必须是抛物型的，以确保圆在 <span class="math inline">\(P\)</span> 处收缩。需要注意的是，<span class="math inline">\(ab\)</span> 和 <span class="math inline">\(ba\)</span> 是共轭的（因为 <span class="math inline">\(b(ab)b^{-1} = ba\)</span>），所以要求 <span class="math inline">\(ab\)</span> 或 <span class="math inline">\(ba\)</span>是抛物型本质上是一回事。奇妙的是，正如我们在 <a href="#note-7.1" title="注记 7.1">注记 7.1</a>中所证明的，所有包含这三个抛物型元素的群自动共轭。这一点对我们来说非常重要，因此我们在<a href="#box20" title="框 20">框 20</a> 中专门进行了总结。</p><div class="statement simple plain unnumbered"><p>Because the pattern of pairing circles is different, so is thearrangement in which the labelled circles are laid down in the plane.The Schottky circles in Figure 7.11 are labelled according to our usualrules, so for example, <span class="math inline">\(C_{ba}\)</span> stillmeans the image of circle <span class="math inline">\(C_a\)</span> underthe map <span class="math inline">\(b\)</span>. However, if you lookcarefully, you will see that the order of the circles along the line isnot the same as our original order round the boundary of the word treeon p.&nbsp;104. The labels can be read off in their correct order from therevised version in Figure 7.12. (To see this you will have to twiddlethe diagram around so the arrows from the vertex you are interested inare pointing ‘down’ rather than ‘up’.) There is a subtle difference fromour original word tree, because there the cyclic order round a vertexwas <span class="math inline">\(a,B,A,b\)</span> while now it is <span class="math inline">\(a,A,b,B\)</span>. The ramifications of thisseemingly minor change propagate down the tree.</p></div><p>由于圆的配对方式改变，标记圆在平面上的排列方式也随之改变。<a href="#fig-7.11">图 7.11</a> 中的 Schottky圆仍按照我们通常的规则标记，例如，<span class="math inline">\(C_{ba}\)</span> 依然表示圆 <span class="math inline">\(C_a\)</span> 在映射 <span class="math inline">\(b\)</span>下的像。然而，如果你仔细观察，就会发现这些圆沿着直线的排列顺序与第 104页单词树边界上的原始顺序不同。修订后的 <a href="#fig-7.12">图 7.12</a>显示了正确的标签顺序。（为了看清这一点，你需要稍微调整图形，使得你关注的顶点的箭头指向“下方”而非“上方”）。与原单词树相比，这里有一个微妙的差异，源于顶点周围的循环顺序变化：原单词树中的顺序是<span class="math inline">\(a, B, A, b\)</span>，而现在则是 <span class="math inline">\(a, A, b,B\)</span>。这一看似微小的变化将沿树结构逐级向下传播。</p><div id="box20" class="statement sta_box_20__the_modular_necklace plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Box 20.The modular necklace</span>.</span><span class="statement-spah"></span><strong>盒子 20：模群项链</strong></p><p><img src="/images/indra/box20.jpg" class="fig" width="200"></p><p>A modular necklace is a tangent chain of four circles in whichadjacent disks are paired by two transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> as in the figure in the margin. Thetransformations <span class="math inline">\(a, b\)</span> and <span class="math inline">\(ab\)</span> are all parabolic and <span class="math inline">\(S = Fix(a), Q = Fix(fc), a(P) = K, b(R) =P\)</span> so that <span class="math inline">\(P =\mathrm{Fix}\,(ba)\)</span> and <span class="math inline">\(R =\mathrm{Fix}\,(ab)\)</span>. The group generated by <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> is always conjugate to the ‘standard’modular group generated by <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix} \text{ and }\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}\]</span></p><p>The four points <span class="math inline">\(P, Q, R\)</span> and<span class="math inline">\(S\)</span> always lie on a circle (or line)which is the limit set of the group. The limit circle is perpendicularto all circles in the chain. Both inner and outer tiles have their sidesmatched in the same way and the surfaces made by gluing up these tilesare each spheres with three punctures or cusps.</p><p>一个模群项链是由四个相切的圆组成的链条，其中相邻的圆盘通过两种变换<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 配对，正如旁边图中的所示。变换 <span class="math inline">\(a\)</span>、<span class="math inline">\(b\)</span>和 <span class="math inline">\(ab\)</span> 都是抛物型的，且有 <span class="math inline">\(S=\mathrm{Fix}\,(a)\)</span>, <span class="math inline">\(Q = \mathrm{Fix}\,(b)\)</span>, <span class="math inline">\(a(P) = R\)</span>, <span class="math inline">\(b(R) = P\)</span>，从而得到 <span class="math inline">\(P = \mathrm{Fix}\,(ba)\)</span> 和 <span class="math inline">\(R = \mathrm{Fix}\,(ab)\)</span>。由 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 生成的群总是与由 <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix} \text{ and }\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}\]</span> 生成的“标准”模群共轭。</p><p>四个点 <span class="math inline">\(P,Q,R,S\)</span>总是位于一个圆（或直线）上，这个圆（或直线）是该群的极限集。极限圆与链条中的所有圆都垂直。无论是内层还是外层的瓷砖，它们的边缘都以相同的方式匹配，通过将这些瓷砖拼接在一起形成的曲面，都是具有三个孔或尖点的球面。</p></div><figure id="fig-7.12"><img src="/images/indra/fig-7.12.jpg" width="600" alt="Figure 7.12. The tree of words rearranged in the pattern of the modular group. 图 7.12. 以模群模式重新排列的词汇树。"><figcaption aria-hidden="true">Figure 7.12. The tree of words rearrangedin the pattern of the modular group.<br>图 7.12. 以模群模式重新排列的词汇树。</figcaption></figure><div class="statement simple plain unnumbered"><p>Because some elements in the modular group are parabolic, theinfinite endpoints of certain paths down the word tree merge. Forexample, the path which starts at <span class="math inline">\(a\)</span>and heads always as far as possible to the left (from the viewpoint of aperson walking down the branch) is <span class="math inline">\(aaa\cdots\)</span>, ending at the attracting fixedpoint <span class="math inline">\({\rm Fix}^+a\)</span>. On the otherhand, starting from <span class="math inline">\(A\)</span> and alwaysturning right gives the path <span class="math inline">\(AAA\cdots\)</span>, ending at <span class="math inline">\({\rm Fix}^+A\)</span>. Since <span class="math inline">\(a\)</span> is parabolic, the end points of thesetwo paths are the same. In a similar way, other coincidences ofendpoints are caused by the merging of the fixed points of <span class="math inline">\(b\)</span> and <span class="math inline">\(ab\)</span>. You should compare the details withFigure 6.13.</p></div><p>由于模群中存在抛物型元素，这导致单词树中某些路径的无限端点会发生合并。例如，从<span class="math inline">\(a\)</span>出发并始终尽可能向左延伸的路径（从沿分支下行的视角来看）可表示为 <span class="math inline">\(aaa\cdots\)</span>，最终到达 <span class="math inline">\(a\)</span> 的吸引不动点 <span class="math inline">\(\mathrm{Fix}\,^+a\)</span>。反之，从 <span class="math inline">\(A\)</span> 出发始终右转的路径则为 <span class="math inline">\(AAA\cdots\)</span>，终止于 <span class="math inline">\(\mathrm{Fix}\,^+A\)</span>。由于 <span class="math inline">\(a\)</span>是抛物型元素，这两条路径的终点完全重合。类似地，<span class="math inline">\(b\)</span> 与 <span class="math inline">\(ab\)</span>的不动点合并也会导致其他端点重合的现象。建议读者将这些细节与 <a href="#fig-6.13">图 6.13</a> 进行对照分析。</p><div class="statement simple plain unnumbered"><p>A similar phenomenon is repeated at all levels. For example, theextreme left and extreme right paths starting at <span class="math inline">\(aB\)</span> end at <span class="math inline">\(aB\bar{a}=\mathrm{Fix}\,aBabA\)</span>, and <span class="math inline">\(aB\bar{A} = \mathrm{Fix}\,aBAbA\)</span>. Noticethat <span class="math inline">\((aBAbA)^{-1}=aBabA\)</span> and that<span class="math inline">\(aBabA\)</span> must be parabolic because itcan be written <span class="math inline">\((aB)a(aB)^{-1}\)</span>, sothe two endpoints merge. Every tangency point of the many circles inFigure 7.9 comes about because of a similar conjugacy to one of thethree basic parabolics <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> or <span class="math inline">\(ab\)</span>.</p></div><p>类似的现象在各个层次上反复出现。例如，从 <span class="math inline">\(aB\)</span> 出发的极左和极右路径分别终止于 <span class="math inline">\(aB\bar{a} = \mathrm{Fix}\,^+ aBabA\)</span> 和<span class="math inline">\(aB\bar{A} =\mathrm{Fix}\,^+aBAbA\)</span>。注意，<span class="math inline">\((aBAbA)^{-1} = aBabA\)</span>，而且 <span class="math inline">\(aBabA\)</span> 必然是抛物型的，因为它可以写成<span class="math inline">\((aB)a(aB)^{-1}\)</span>，因此这两个端点最终重合。<a href="#fig-7.9">图 7.9</a>中众多圆的切点的出现，本质上都源于群元素与三个基本抛物元 <span class="math inline">\(a\)</span>、<span class="math inline">\(b\)</span>或 <span class="math inline">\(ab\)</span> 之一类似的共轭关系。</p><div class="statement simple plain unnumbered"><p>Let’s mention one final difference from the kissing Schottky groupsin Chapter 6. The chain of four initial circles still divides theRiemann sphere into two four-sided tiles. However, because the pairingis different, so is the result of glueing up the tiles. Dr.&nbsp;Stickler ispuzzling this out in Figure 7.13. In contrast to the pair ofonce-punctured tori we got in Figure 6.16, the outcome is now a pair oftriply-punctured spheres.</p></div><p>让我们提到与第 6 章中亲吻 Schottky群的最后一个不同之处。四个最初的圆依然将黎曼球面划分为两个四边形瓷砖。然而，由于配对方式的不同，拼接后的结果也发生了变化。Stickler博士正在 <a href="#fig-7.13">图 7.13</a> 中对此进行思考。与我们在 <a href="#fig-6.16">图 6.16</a>中得到的那一对单孔环面相比，这次的结果是两个三孔球面。</p><figure id="fig-7.13"><img src="/images/indra/fig-7.13.png" width="600" alt="Figure 7.13. The gluing construction for the modular group. We start from a chain of four kissing circles giving a tile with two pieces, each a rectangle with four cusps. After gluing according to the modular recipe, we get two spheres, each with three cuspidal ‘punctures’ where they are joined. 图 7.13. 模群的粘合构造。我们从一串四个相切的圆开始，得到一个由两块矩形瓷砖组成的图案，每块瓷砖上都有四个尖点。按照模群的粘合法则将这些部分粘合后，最终得到两个球面，每个球面上都有三个尖点状的“穿孔”，它们通过这些穿孔相连。"><figcaption aria-hidden="true">Figure 7.13. The gluing construction forthe modular group. We start from a chain of four kissing circles givinga tile with two pieces, each a rectangle with four cusps. After gluingaccording to the modular recipe, we get two spheres, each with threecuspidal ‘punctures’ where they are joined.<br>图 7.13.模群的粘合构造。我们从一串四个相切的圆开始，得到一个由两块矩形瓷砖组成的图案，每块瓷砖上都有四个尖点。按照模群的粘合法则将这些部分粘合后，最终得到两个球面，每个球面上都有三个尖点状的“穿孔”，它们通过这些穿孔相连。</figcaption></figure><h1 id="the-problem-of-gaps">The problem of gaps</h1><figure id="fig-7.14"><img src="/images/indra/fig-7.14.jpg" width="500" alt="Figure 7.14. The gaps in the gasket. 图 7.14. 垫片中的缝隙。"><figcaption aria-hidden="true">Figure 7.14. The gaps in the gasket. 图7.14. 垫片中的缝隙。</figcaption></figure><div class="statement simple plain unnumbered"><p>We end this chapter by returning to the gasket and programming, withthe confession that we cheated slightly to make pictures like Figures7.1 and 7.4. Figure 7.14 shows the same picture plotted with our currentalgorithm. It contains a slight but thoroughly annoying imperfection ifyou look closely, you will see that at many places where we allege thelimit set is ‘pinched’, it does not actually quite meet itself, butcontains what are in reality quite large gaps.</p></div><p>本章的结尾，我们再次回到垫片和编程的话题，并坦白在绘制 <a href="#fig-7.1">图 7.1</a> 和 <a href="#fig-7.4">图 7.4</a>这类图像时，我们稍微做了一点“取巧”。<a href="#fig-7.14">图 7.14</a>展示的是使用我们当前算法绘制的同一图像。仔细观察的话，你会发现它存在一个微小但颇为恼人的缺陷：在许多地方，我们宣称极限集已经“收缩”的地方，实际上并没有完全闭合，反而留下一些肉眼可见的较大空隙。</p><div class="statement simple plain unnumbered"><p>Gaps and other imperfections in scientific pictures are a commonnuisance, but they sometimes have greater significance. Mandelbrotrecounted that his first detailed pictures of what later came to beknown as the Mandelbrot set seemed to be plagued by specks of dirt. Heand his assistant made a complete inspection of their program, computersystem and printer, only to find that the specks were indeed correct.Investigating the specks led to the discovery of the vast andcomplicated spider web of filaments connecting all the various parts ofthat stunningly beautiful and now famous icon of the fractal world.</p></div><p>科学图像中的空隙和其他瑕疵往往令人烦恼，但有时它们却蕴藏着更深的含义。曼德勃罗回忆道，他第一次绘制的、后来被称为曼德勃罗集的精细图像，总是被一些看似污点的斑点困扰。于是，他和助手对程序、计算机系统和打印机进行了彻底检查，结果发现这些斑点竟然是正确的。深入探究这些斑点，他们最终发现了一个复杂而庞大的蜘蛛网般的细丝结构，连接着曼德勃罗集各个部分，揭示了这个令人震撼、现已声名赫赫的分形世界象征的奇妙之处。</p><div class="statement simple plain unnumbered"><p>What is happening in the present case is that our algorithm developstremendous inertia as it approaches the fixed points of parabolic ornearly parabolic words. It’s as if it starts to run in slow motion,simply not having the energy to go all the way out to the end. For thisparticular picture, the plotting threshold was a reasonably small 0.005and the word length crept up to more than 400 as the plot approached thegaps. Still the visible gaps are substantially larger than 0.005.</p></div><p>在这个例子中，我们的算法在接近抛物型或近似抛物型词的固定点时，表现出极大的惯性。就像是进入了慢动作，似乎完全没有足够的能量继续前进，无法走到最后。对于这幅特定的图像，绘图的阈值被设置得相当小，仅为0.005，而随着绘图接近空隙，词的长度悄然增加到了超过400。然而，尽管如此，空隙的大小依然明显超过了 0.005。</p><div class="statement simple plain unnumbered"><p>We could make better plots if we modified the algorithm to takeaccount of the fact that the words <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are parabolic. The basic idea is thatwe should plot not only points with repetends which are cyclicpermutations of the basic commutator abAB (itself parabolic), but inaddition those whose repetends are any of <span class="math inline">\(a,A, b\)</span> or <span class="math inline">\(B\)</span>. Pictures likeFigure 7.4, plotted with the new algorithm, are the measure of oursuccess.</p></div><p>如果我们修改算法，使其考虑到单词 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>是抛物型的这一特点，就能绘制出更精确的图形。基本思路是，我们不仅要绘制那些循环节为基本换位子<span class="math inline">\(abAB\)</span>（本身是抛物型）及其循环排列的点，还要包括那些循环节为<span class="math inline">\(a, A, b\)</span> 或 <span class="math inline">\(B\)</span> 的点。采用新算法绘制的图像。比如 <a href="#fig-7.4">图 7.4</a>，正是我们取得成功的标志。</p><div class="statement simple plain unnumbered"><p>Here is a more detailed look at the modified algorithm. We start bytelling the program that the three parabolic elements <span class="math inline">\(a, b\)</span> and <span class="math inline">\(abAB\)</span> are ‘special’. For each generator,the program then determines the repetends it must consider whenenumerating the infinite words. They are listed in Note 7.3.</p></div><p>下面是对修改后算法的更详细说明。首先，我们告诉程序，三个抛物型元素<span class="math inline">\(a\)</span>、<span class="math inline">\(b\)</span> 和 <span class="math inline">\(abAB\)</span>是“特殊的”。接下来，程序会为每个生成元确定在枚举无限词时需要考虑的循环节。这些循环节列在<a href="#note-7.3" title="注记 7.3">注记 7.3</a> 中。</p><div class="statement simple plain unnumbered"><p>This chart is used in the following way. Suppose we are considering aword w which ends with the tag <code>gens[l] = a</code>, for example<span class="math inline">\(w = BABaa\)</span>. We are trying to plotthe part of the limit set corresponding to words with prefix <span class="math inline">\(w\)</span>, so we want to look at those placeswhere this segment of the limit curve unexpectedly gets stretched out.This section of limit set, the <span class="math inline">\(w\)</span>-section as we may call it, consists ofpoints corresponding to all the infinite words between <span class="math inline">\(w\overline{bABa}\)</span> and <span class="math inline">\(w\overline{BAba}\)</span>.</p></div><p>该图表的使用方法如下。假设我们正在考虑一个以标签<code>gens[l] = a</code> 结尾的单词，比如 <span class="math inline">\(w= BABaa\)</span>。我们希望绘制极限集中的一部分，这部分对应的是以 <span class="math inline">\(w\)</span>为前缀的所有单词。因此，我们关注的是极限曲线中该段意外被拉伸的位置。这一段极限集，我们可以称之为<span class="math inline">\(w\)</span>-区段，包含了所有介于 <span class="math inline">\(w\overline{bABa}\)</span> 和 <span class="math inline">\(w\overline{BAba}\)</span>之间的无限单词所对应的点。</p><div class="statement simple plain unnumbered"><p>Because <span class="math inline">\(a\)</span> is parabolic, thefixed points <span class="math inline">\(\bar{a}\)</span> and <span class="math inline">\(\bar{A}\)</span> are the same, and therefore,although the infinite words are different, the limit pointscorresponding to <span class="math inline">\(w\bar{a}\)</span> and <span class="math inline">\(w\bar{A}\)</span> are equal. Notice that theinfinite word <span class="math inline">\(w\bar{A}\)</span> reducesslightly to <span class="math display">\[w\bar{A} = BABaaAAAAA\cdots =BABAAA\cdots = BAB\bar{A}.\]</span> These cancellations mean that, onthe boundary of the word tree, <span class="math inline">\(BAB\bar{A}\)</span> is far outside the interval ofinfinite words which correspond to the <span class="math inline">\(w\)</span>-section of the limit set. So thechances are that the point <span class="math inline">\(w\hat{a}\)</span>is going to be stretched way away from its expected position, and we hadbetter check it out when we are making our plot. We explain in Note 7.3why it is only worth checking out the special repetends in the list andnot, for example, words ending in <span class="math inline">\(a\)</span>followed by the repetend <span class="math inline">\(b\)</span>.</p></div><p>由于 <span class="math inline">\(a\)</span> 是抛物元素，<span class="math inline">\(\bar{a}\)</span> 和 <span class="math inline">\(\bar{A}\)</span> 的不动点重合，因此，尽管无限词<span class="math inline">\(w\bar{a}\)</span> 和 <span class="math inline">\(w\bar{A}\)</span>不同，它们对应的极限点却是相同的。请注意，无限词 <span class="math inline">\(w\bar{A}\)</span> 可以简化为： <span class="math display">\[w\bar{A} = BABaaAAAAA\cdots = BABAAA\cdots =BAB\bar{A}.\]</span> 这种简化意味着，在词树的边界上，<span class="math inline">\(BAB\bar{A}\)</span> 超出了与 <span class="math inline">\(w\)</span>-截面极限集对应的无限词区间的范围。因此，点<span class="math inline">\(w\hat{a}\)</span>很可能会被拉伸得远离预期位置，因此我们在绘制图形时需要特别留意这一点。在<a href="#note-7.3" title="注记 7.3">注记 7.3</a>中，我们解释了为何只需检查列表中的特定循环节，而不必关注像以 <span class="math inline">\(a\)</span> 结尾、后接循环节 <span class="math inline">\(b\)</span> 的词。</p><div id="note-7.3" class="statement sta_note_7_3__which_repetends_should_be_considered_ definition unnumbered"><p><span class="statement-heading"><span class="statement-label">Note7.3: Which repetends should be considered?</span>：</span><span class="statement-spah"> </span><br></p><p><strong>注 7.3：应考虑哪些循环节？</strong></p><p>Here is the list of repetends the program must consider whenenumerating infinite words:</p><p><span class="math display">\[\begin{aligned}\text{gens[1]}&amp;=a \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[1,1]=bABa \\\text{repet}[1,2]=a \\\text{repet}[1,3]=BAba\end{array}\right. \\\text{gens[2]}&amp;=b \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[2,1]=ABab \\\text{repet}[2,2]=b \\\text{repet}[2,3]=aBAb\end{array}\right. \\\text{gens[3]}&amp;=A \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[3,1]=BabA \\\text{repet}[3,2]=A \\\text{repet}[3,3]=baBA\end{array}\right. \\\text{gens[4]}&amp;=B \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[4,1]=abAB \\\text{repet}[4,2]=B \\\text{repet}[4,3]=AbaB\end{array}\right.\end{aligned}\]</span></p><p>There are some obvious omissions. For example, the generator <span class="math inline">\(b\)</span> is also parabolic, so that <span class="math inline">\(w\overline{b}\)</span> is the same point as <span class="math inline">\(w\overline{B}\)</span>. Should we perhaps checkout <span class="math inline">\(w\overline{b}\)</span> as well? Well,since <span class="math inline">\(w\)</span> ends in <span class="math inline">\(a\)</span>, neither of the infinite words <span class="math inline">\(w\overline{b}\)</span> and <span class="math inline">\(w\overline{B}\)</span> collapse at all, so both<span class="math inline">\(w\overline{b}\)</span> and <span class="math inline">\(w\overline{B}\)</span> are in the small stretch ofinfinite words which correspond to the wiggly <span class="math inline">\(w\)</span>-section. There seems to be no specialneed to bother with these points, in fact looking at plots we learned byexperience that they don’t stick particularly far out at all. In otherwords, if <span class="math inline">\(w\)</span> ends with <span class="math inline">\(a\)</span>, then there is no need to look atrepetends <span class="math inline">\(b\)</span> or <span class="math inline">\(B\)</span>. Similar reasoning leads to the patternin the chart. The repetends which are important to consider after a word<span class="math inline">\(w\)</span> which ends in the tag <span class="math inline">\(c\)</span> (one of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(A\)</span>or <span class="math inline">\(B\)</span>) are precisely those whichthemselves end in <span class="math inline">\(c\)</span>. This isbecause the inverse of the repetend will begin with <span class="math inline">\(C\)</span> (letters in the inverse word, remember,appear in reverse order) so that there are cancellations in <span class="math inline">\(wC\)</span>. This means that the point <span class="math inline">\(w(\overline{C})\)</span> is not in the part of theboundary of the word tree corresponding to infinite words with theprefix <span class="math inline">\(w\)</span>. You can imagine that itspresence pulls the point <span class="math inline">\(w(\overline{c})\)</span> (which is in the <span class="math inline">\(w\)</span>-section) towards it, causingdistortions which our program needs to check out.</p><p>程序枚举无限字时需考察的循环节列表如下：</p><p><span class="math display">\[\begin{aligned}\text{gens[1]}&amp;=a \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[1,1]=bABa \\\text{repet}[1,2]=a \\\text{repet}[1,3]=BAba\end{array}\right. \\\text{gens[2]}&amp;=b \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[2,1]=ABab \\\text{repet}[2,2]=b \\\text{repet}[2,3]=aBAb\end{array}\right. \\\text{gens[3]}&amp;=A \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[3,1]=BabA \\\text{repet}[3,2]=A \\\text{repet}[3,3]=baBA\end{array}\right. \\\text{gens[4]}&amp;=B \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[4,1]=abAB \\\text{repet}[4,2]=B \\\text{repet}[4,3]=AbaB\end{array}\right.\end{aligned}\]</span></p><p>显然，当前列表存在一些遗漏。例如，生成元 <span class="math inline">\(b\)</span> 同样是抛物型的，因此 <span class="math inline">\(w\overline{b}\)</span> 和 <span class="math inline">\(w\overline{B}\)</span>对应相同的点。那么，我们是否也应该检查 <span class="math inline">\(w\overline{b}\)</span> 呢？实际上，由于 <span class="math inline">\(w\)</span> 以 <span class="math inline">\(a\)</span> 结尾，<span class="math inline">\(w\overline{b}\)</span> 和 <span class="math inline">\(w\overline{B}\)</span>都不会发生任何坍缩，因此二者均位于描述 <span class="math inline">\(w\)</span>-区段波动形态的无限词集合中。根据绘图观察的经验，这类点并不会显著突出边界轮廓。换言之，如果<span class="math inline">\(w\)</span> 以 <span class="math inline">\(a\)</span> 结尾，则无需考察以 <span class="math inline">\(b\)</span> 或 <span class="math inline">\(B\)</span>结尾的循环节。通过类似推理可得图表中的模式规律：对于以标签 <span class="math inline">\(c\)</span>（即 <span class="math inline">\(a,b,A,B\)</span> 之一）结尾的词 <span class="math inline">\(w\)</span>，需重点考察的循环节恰是那些自身以 <span class="math inline">\(c\)</span> 结尾者。这是因为此类循环节的逆元将以<span class="math inline">\(C\)</span>开始（注意逆元中的字母顺序是反转的），从而在组合 <span class="math inline">\(wC\)</span> 时产生抵消效应。这意味着点 <span class="math inline">\(w(\overline{C})\)</span> 并不位于对应前缀 <span class="math inline">\(w\)</span>的无限字所在词树边界区域。可以设想，该点的存在会将 <span class="math inline">\(w(\overline{c})\)</span>（位于 <span class="math inline">\(w\)</span>-区段内）拉向它，从而产生程序需要检查的扭曲效应。</p></div><figure id="fig-7.15"><img src="/images/indra/fig-7.14.jpg" width="500" alt="Figure 7.15. Slow motion gasket. This is a piece of the Apollonian gasket plotted with \epsilon=0.1. The width and height of the frame are 0.4. We have started numbering the limit points at 1 = \overline{bABA} in the upper left corner. One has to run through quite a few limit points after number 20 = b\overline{A}, before we return to that same point labelled by the different infinite word b\overline{a} at number 128. The limit points through which the curve passes twice have repetends a, A, b or B. 图 7.15. 慢动作的阿波罗涡旋。这是一个阿波罗涡旋的片段，使用了 \epsilon = 0.1 进行绘制。框架的宽度和高度都是 0.4。我们从左上角的点 1 = \overline{bABA} 开始为极限点编号。直到编号为 20 = b\overline{A} 的点之后，才需要通过若干个极限点，才能返回到那个用不同无限单词 b\overline{a} 标记的同一点——这个点的编号是 128。曲线经过两次的极限点，其重复部分包括 a、A、b 或 B。"><figcaption aria-hidden="true">Figure 7.15. Slow motion gasket. This isa piece of the Apollonian gasket plotted with <code>\epsilon=0.1</code>.The width and height of the frame are 0.4. We have started numbering thelimit points at <span class="math inline">\(1 = \overline{bABA}\)</span>in the upper left corner. One has to run through quite a few limitpoints after number <span class="math inline">\(20 =b\overline{A}\)</span>, before we return to that same point labelled bythe different infinite word <span class="math inline">\(b\overline{a}\)</span> at number 128. The limitpoints through which the curve passes twice have repetends <span class="math inline">\(a\)</span>, <span class="math inline">\(A\)</span>, <span class="math inline">\(b\)</span>or <span class="math inline">\(B\)</span>.<br>图 7.15. 慢动作的阿波罗涡旋。这是一个阿波罗涡旋的片段，使用了 <span class="math inline">\(\epsilon = 0.1\)</span>进行绘制。框架的宽度和高度都是 0.4。我们从左上角的点 <span class="math inline">\(1 = \overline{bABA}\)</span>开始为极限点编号。直到编号为 <span class="math inline">\(20 =b\overline{A}\)</span>的点之后，才需要通过若干个极限点，才能返回到那个用不同无限单词 <span class="math inline">\(b\overline{a}\)</span>标记的同一点——这个点的编号是 128。曲线经过两次的极限点，其重复部分包括<span class="math inline">\(a\)</span>、<span class="math inline">\(A\)</span>、<span class="math inline">\(b\)</span>或 <span class="math inline">\(B\)</span>。</figcaption></figure><div class="statement simple plain unnumbered"><p>At the beginning of the program, our routine computes the attractivefixed point <span class="math inline">\({\rm fp}[i,j]\)</span> of eachof the repetends <span class="math inline">\({\rm repet[i,j]\}\)</span>listed in the chart. The only parts of the running algorithm which needto be changed are the termination and plotting subroutines. Suppose weare at the finite word ending in the generator <span class="math inline">\(gens[i]\)</span>. Then we compute the threepoints</p><p><span class="math display">\[z_j = \text{word}({\rmfp}[i,j])\]</span></p><p>for <span class="math inline">\(j = 1, 2, 3\)</span>. Given theplotting gap <span class="math inline">\(\epsilon\)</span>, we requireboth <span class="math inline">\(|z_2 - z_1| \leq \epsilon\)</span> and<span class="math inline">\(|z_3 - z_2| \leq \epsilon\)</span> in orderto terminate the forward enumeration along that particular branch of theword tree. If the criterion is met, we draw a line segment from <span class="math inline">\(z_1\)</span> to <span class="math inline">\(z_2\)</span>, and a line segment from <span class="math inline">\(z_2\)</span> to <span class="math inline">\(z_3\)</span>. That is all the modification weneed.</p></div><p>在程序开始时，我们的例行步骤会计算出图表中每个循环节（repetend）<span class="math inline">\({\rm repet[i,j]}\)</span> 的吸引不动点（attractivefixed point）<span class="math inline">\({\rmfp}[i,j]\)</span>。原有算法中，唯一需要修改的部分是终止条件和绘图子程序。假设我们当前位于一个以生成元<span class="math inline">\(gens[i]\)</span> 结尾的有限字（finiteword）。此时，我们计算以下三个点： zj=word(fp[i,j])zj​=word(fp[i,j]) 其中<span class="math inline">\(j = 1, 2, 3\)</span>。</p><p>给定绘图精度 <span class="math inline">\(\epsilon\)</span>，我们要求满足 <span class="math inline">\(|z_2 - z_1| \leq \epsilon\)</span> 且 <span class="math inline">\(|z_3 - z_2| \leq\epsilon\)</span>，才能终止该分支在字树（wordtree）上的正向枚举。若条件满足，我们依次绘制两条线段：一条从 <span class="math inline">\(z_1\)</span> 到 <span class="math inline">\(z_2\)</span>，另一条从 <span class="math inline">\(z_2\)</span> 到 <span class="math inline">\(z_3\)</span>。这就是我们所需的全部修改。</p><div class="statement simple plain unnumbered"><p>Figure 7.15 shows a slow motion execution of this special wordalgorithm for the gasket. As above, <span class="math inline">\(a,b\)</span> and the commutator have been listedas special words. A piece of the gasket has been plotted at the ratherlarge gap size of <code>epsilon=0.1</code>. As you can see, all thecontact points between far away parts of the limit set curve arecompletely filled in and the algorithm produces limit sets with novisible gaps. You will see better how the special word algorithm worksif you follow through the description in Note 7.4.</p></div><p>图 7.15 展示了这种针对垫片的特殊词算法的慢动作执行过程。和上文一样，特殊词中包括 <span class="math inline">\(a,b\)</span>和换位子。图中绘制了垫片的一部分，采用了较大的间隙尺寸<code>epsilon=0.1</code>。正如你所见，极限集曲线中远处部分之间的所有接触点都已被完全填充，算法生成的极限集不再存在可见的间隙。如果你参照<a href="#note-7.4" title="注记 7.4">注记 7.4</a>中的描述，将能更清楚地理解特殊词算法的工作原理。</p><div class="statement simple plain unnumbered"><p>Many fractals are created through a process of iteration which is notterribly sensitive to the order of execution of the program. Seeinglimit sets like the gasket drawn as curves is too wonderful to leave tosuch a procedure. When testing your program it is essential toscrutinize with excruciating care the order of infinite words andcorresponding limit points. For lack of space (it’s already a crowdedpicture), not all the limit points in Figure 7.15 have been labelled. Ifyou really wish to test your understanding of the algorithm, you shouldtry to fill in some missing labels, which can be done given thedictionary ordering and the desired special words.</p></div><p>许多分形图形是通过迭代过程生成的，而这种过程对程序的执行顺序通常并不十分敏感。然而，像垫片（gasket）这样的极限集，如果仅仅以这种方式画成曲线，未免太过可惜——它的美妙远不止于此。</p><p>在测试程序时，务必仔细审查无限词的顺序及其对应的极限点，做到一丝不苟。由于空间有限（图7.15已经非常拥挤），并未对其中的所有极限点标注。如果你真的想检验自己对算法的理解，不妨尝试补全其中缺失的标注。只要参考字典序和那些特殊的目标词，这项工作是完全可行的。</p><div id="note-7.4" class="statement sta_note_7_4__tracing_the_gasket definition unnumbered"><p><span class="statement-heading"><span class="statement-label">Note7.4: Tracing the gasket</span>：</span><span class="statement-spah"></span><strong>注记 7.4：追踪垫片</strong></p><p>To understand the workings of our special word algorithm better, youmay like to try following along segments of the curve in Figure 7.15carefully as we describe here.</p><p>Let’s focus on the segment of limit set between points 1 and 35. Thisis the segment corresponding to all words with prefix <span class="math inline">\(bA\)</span>. As you can see by referring to ourchart of repetends, <span class="math inline">\(1 = bABabA\)</span> and<span class="math inline">\(35 = bAbaBA\)</span>. (In the figure, thesepoints are written slightly differently, simply because we chose adifferent point starting point for cycling the repetend. So for example<span class="math inline">\(bABabA\)</span> is exactly the same sequenceas <span class="math inline">\(\overline{bABA}\)</span>.) As you can seeby following the numbers closely, the segment of limit set betweenpoints <span class="math inline">\(1 = bABabA\)</span> and <span class="math inline">\(35 = bAbaBA\)</span> passes through the bad fixedpoint <span class="math inline">\(20 = bAA\)</span>. At this scale thedistortion is not too bad – in comparison to the distance between 1 and35, the point 20 is not too far away. Things get worse when you go tothe next level and study the subsegment corresponding to infinite wordswith prefix <span class="math inline">\(bAA\)</span>. The initial pointof this section of limit set is <span class="math inline">\(15 =bAABabA\)</span> and the final point is <span class="math inline">\(25 =bAAbaBA\)</span>. The outlier is still 20, which can also be written as<span class="math inline">\(bAAA\)</span>. See how 20 is pulled quitefar out in comparison to the distance between 15 and 25. This ishappening because in fact <span class="math inline">\(20 =b\overline{A}\)</span> is the same point as 128 = <span class="math inline">\(b\overline{a}\)</span>, which is in quite adifferent section of the path round the boundary of the word tree. Ouralgorithm would only stop at this prefix if the distances from 15 to 20and from 20 to 25 were both less than the cut-off value <span class="math inline">\(\epsilon\)</span>. At the next stage, look at theinterval between 17 = <span class="math inline">\(bAAABabA\)</span> and23 = <span class="math inline">\(bAAAbaBA\)</span>. The outlier is still20 = <span class="math inline">\(bAAAA\)</span>. Now the disproportionbetween the distances from 17 to 23, as opposed to the distances from 17to 20 and 20 to 23, is really getting large. As you go further andfurther into the spike, the disproportion gets ever worse, so the fineryou want to plot your pictures the more important it is to check outthese outliers. If we weren’t using the special words algorithm, theplot would terminate far too soon, chopping off the piece of limit setwhich sticks out into the spike.</p><p>为了更好地理解我们的特殊单词算法的工作原理，不妨按照我们在此描述的内容，仔细沿着图7.15 中曲线的某些部分追踪观察。</p><p>让我们聚焦于点 1 和点 35 之间的极限集部分。这一部分对应于所有以 <span class="math inline">\(bA\)</span>为前缀的单词。参照我们的循环节图表，可以看到 <span class="math inline">\(1 = bABabA\)</span>，而 <span class="math inline">\(35 =bAbaBA\)</span>。（图中这些点的表示稍有不同，仅仅是因为我们选择了一个不同的起始点来循环循环节。例如，<span class="math inline">\(bABabA\)</span> 与 <span class="math inline">\(\overline{bABA}\)</span>实际上是完全相同的序列。）</p><p>仔细观察编号，可以发现，从点 <span class="math inline">\(1 =bABabA\)</span> 到点 <span class="math inline">\(35 = bAbaBA\)</span>的极限集部分经过了那个糟糕的不动点 <span class="math inline">\(20 =bAA\)</span>。在这个尺度下，尽管存在一定的畸变，但相较于点 1 和点 35之间的距离，点 20也并不算太远。然而，情况在进一步深入时变得更糟。当研究对应于以 <span class="math inline">\(bAA\)</span>为前缀的无限单词的子区段时，情况就更明显了。这个区段的起始点是 <span class="math inline">\(15 = bAABabA\)</span>，终点是 <span class="math inline">\(25 = bAAbaBA\)</span>。</p><p>异常点依然是 20，它也可以写作 <span class="math inline">\(bAAA\)</span>。注意点 20在图中被拉出了相当远的距离，相较于点 15 到点 25 之间的距离，点 20的偏离尤为显著。这种现象的根本原因在于，实际上 <span class="math inline">\(20 = b\overline{A}\)</span> 与 <span class="math inline">\(128 = b\overline{a}\)</span>是同一个点，而该点在单词树边界路径的完全不同的部分。我们的算法仅在点 15到点 20 以及点 20 到点 25 的距离都小于截断值 <span class="math inline">\(\epsilon\)</span> 时，才会在该前缀处停止。</p><p>再往下一层观察区间时，查看点 17 = <span class="math inline">\(bAAABabA\)</span> 和点 23 = <span class="math inline">\(bAAAbaBA\)</span> 之间的区段。异常点依然是点 20 =<span class="math inline">\(bAAAA\)</span>。此时，点 17 到点 23的距离，与点 17 到点 20 以及点 20 到点 23的距离之间的失衡变得更加明显。随着你在这根尖刺中不断深入，这种失衡愈加严重。因此，越是要精细地绘制图形，检查这些异常点就越重要。如果我们没有使用特殊单词算法，绘图将会过早终止，从而截断伸入尖刺的那一部分极限集。</p></div><h1 id="projects">Projects</h1><div id="proj-7.1" class="statement sta_7_1__uniqueness_of_ideal_triangles plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.1:Uniqueness of ideal triangles</span>.</span><span class="statement-spah"></span><strong>7.1：理想三角形的唯一性</strong></p><p>How many ideal triangles can you draw with given vertices <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>and <span class="math inline">\(R\)</span>? If the vertices are <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span>and <span class="math inline">\(\infty\)</span>, show that the sidesmust be the two ‘vertical’ lines through <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span> and the circle with centre <span class="math inline">\(1/2\)</span>, radius <span class="math inline">\(1/2\)</span>. Thus there are exactly two idealtriangles with these vertices, but only in the ‘upper’ triangle are thevertices <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span> and <span class="math inline">\(\infty\)</span> in anticlockwise order round theedge. Sometimes this is called the standard ideal triangle. Find itsincircle.</p><p>Suppose now you have another ideal triangle with vertices <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>and <span class="math inline">\(R\)</span> in anticlockwise order.Project 3.2 showed there is exactly one Möbius map <span class="math inline">\(M\)</span> which carries <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span>and <span class="math inline">\(\infty\)</span> to <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>, <span class="math inline">\(R\)</span>in that order. What properties of Möbius maps show that <span class="math inline">\(M\)</span> carries the standard ideal triangleinto the new one? If there were another other ideal triangle with thesame vertices in the same order, what would happen when you applied<span class="math inline">\(M^{-1}\)</span>? Why does any ideal trianglehave exactly one incircle?</p><p>给定顶点 <span class="math inline">\(P\)</span>、<span class="math inline">\(Q\)</span> 和 <span class="math inline">\(R\)</span>，可以画出多少个理想三角形？如果顶点是<span class="math inline">\(0\)</span>、<span class="math inline">\(1\)</span> 和 <span class="math inline">\(\infty\)</span>，可以证明它们的边必须是通过 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span> 的两条“垂直”直线，以及以 <span class="math inline">\(1/2\)</span> 为圆心、<span class="math inline">\(1/2\)</span>为半径的圆。因此，具有这些顶点的理想三角形恰好有两个，但只有在“上方”的三角形中，顶点<span class="math inline">\(0\)</span>、<span class="math inline">\(1\)</span> 和 <span class="math inline">\(\infty\)</span>按逆时针顺序排列在边界上。有时这个三角形被称为标准理想三角形。找出它的内切圆。</p><p>假设现在有另一个理想三角形，其顶点 <span class="math inline">\(P\)</span>、<span class="math inline">\(Q\)</span>和 <span class="math inline">\(R\)</span> 按逆时针顺序排列。项目 3.2表明，存在唯一的莫比乌斯变换 <span class="math inline">\(M\)</span>，将<span class="math inline">\(0\)</span>、<span class="math inline">\(1\)</span> 和 <span class="math inline">\(\infty\)</span> 依次映射到 <span class="math inline">\(P\)</span>、<span class="math inline">\(Q\)</span>、<span class="math inline">\(R\)</span>。莫比乌斯变换的哪些性质表明 <span class="math inline">\(M\)</span>将标准理想三角形映射到新的三角形？如果存在另一个具有相同顶点且按相同顺序排列的理想三角形，那么对其应用<span class="math inline">\(M^{-1}\)</span>会发生什么？为什么任何理想三角形都有且仅有一个内切圆？</p></div><div id="proj-7.2" class="statement simple plain unnumbered"><p>7.2: An instance of Soddy’s formula</p><p><strong>7.2：索迪公式的一个实例</strong></p><p>Calculate the radius of the incircle <span class="math inline">\(C_A\)</span> in the right frame of Figure 7.4using Soddy’s formula, and check your answer with a more conventionalcomputation using Pythagoras’ theorem. Be careful: one circle hasinfinite radius! Use your result to show that the points <span class="math inline">\(S\)</span> and <span class="math inline">\(R\)</span> in the figure are at <span class="math inline">\(\pm 0.2 - 0.4i\)</span>, and then check thegenerators pair the tangency points properly.</p><p>使用索迪公式计算图 7.4 右侧框中的内切圆 <span class="math inline">\(C_A\)</span>的半径，并通过应用勾股定理进行常规计算来验证你的结果。请小心：其中一个圆的半径是无限的！利用你的结果，证明图中的点<span class="math inline">\(S\)</span> 和 <span class="math inline">\(R\)</span> 位于 <span class="math inline">\(\pm0.2 - 0.4i\)</span>，然后检查生成器是否正确地配对了切点。</p></div><div id="proj-7.3" class="statement sta_7_3__the_ford_circles plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.3:The Ford circles</span>.</span><span class="statement-spah"></span><strong>7.3: 福特圆</strong></p><p>There is a remarkable pattern for the radii of the circles whichtouch the real axis in Figure 7.5, commonly credited to Lester Ford. Thepattern is easiest to analyze if we shift and scale so that the largestpink circles are tangent to the real axis at integer points, so theyhave diameter <span class="math inline">\(1\)</span>, and the strip is<span class="math inline">\(1\)</span> unit high. Then there is exactlyone circle (pink or white) tangent at every rational point <span class="math inline">\(p/q\)</span>. Find the pattern that describeswhich rationals <span class="math inline">\(p/q\)</span> are tangent toa white circle, and which to a pink one.</p><p>The formula for the radius of the circle tangent at <span class="math inline">\(p/q\)</span> is quite simple. It depends only on<span class="math inline">\(q\)</span>. For example, at each integerpoint <span class="math inline">\(n/1\)</span> the denominator is <span class="math inline">\(1\)</span> and the radius is <span class="math inline">\(1/2\)</span>. At each half-integer, <span class="math inline">\(\pm 1/2, \pm 3/2\)</span>, etc., the denominatoris <span class="math inline">\(2\)</span> and the radius is <span class="math inline">\(1/8\)</span>. Those are all the hints we’llgive.</p><p>如图 7.5 所示，与实轴相切的圆的半径呈现出一个显著的规律，通常归功于LesterFord。最容易分析这个规律的方法是通过平移和缩放，使得最大的粉色圆与实轴在整数点相切，直径为<span class="math inline">\(1\)</span>，并且该条带的高度为 <span class="math inline">\(1\)</span> 单位。这样，恰好每个有理数点 <span class="math inline">\(p/q\)</span>上都会有一个圆（无论是粉色还是白色）与实轴相切。接下来，找出描述哪些有理数<span class="math inline">\(p/q\)</span>与白色圆相切，哪些与粉色圆相切的规律。</p><p>在 <span class="math inline">\(p/q\)</span>处与实轴相切的圆的半径公式非常简单，它只与分母 <span class="math inline">\(q\)</span> 有关。例如，在每个整数点 <span class="math inline">\(n/1\)</span> 处，分母为 <span class="math inline">\(1\)</span>，半径为 <span class="math inline">\(1/2\)</span>；在每个半整数点 <span class="math inline">\(\pm 1/2, \pm 3/2\)</span> 等处，分母为 <span class="math inline">\(2\)</span>，半径为 <span class="math inline">\(1/8\)</span>。这些就是我们给出的所有提示。</p></div><div id="proj-7.4" class="statement sta_7_4__another_modular_group_in_the_gasket_group plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.4:Another modular group in the gasket group</span>.</span><span class="statement-spah"> </span><strong>垫片群中的另一个模群</strong></p><p>In the text (see p.&nbsp;213), we focussed on the modular group acting inwhat were the pink disks in Figure 7.4. (The tiling of these disks isshown in Figure 7.6.) The modular group acts in the white disks too. Inthe right frame of Figure 7.4, look at the lower blue circles <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span>. Their images <span class="math inline">\(a(C_B)\)</span> and <span class="math inline">\(a(C_b)\)</span> are also tangent circles, actuallythe reflections of the first two in the real axis. These four circlesare tangent and cut the white exterior of the unit disk into fourquarters. Twist yourself inside out to see that in this white exteriorwe also have the gluing pattern for the modular group: four tangentcircles with neighbouring circles being paired. Show that the twotangency points correspond to the parabolic elements <span class="math inline">\(b\)</span> and <span class="math inline">\(abA\)</span>, while the other two are the products<span class="math inline">\(abAB\)</span> and <span class="math inline">\(BabA\)</span>, which are parabolic with fixedpoints at <span class="math inline">\(1\)</span> and <span class="math inline">\(-1\)</span> respectively. The limit set for thissubgroup is the unit circle.</p><p>在文本中（见第 213 页），我们集中讨论了模群在图 7.4中粉色圆盘上的作用。（这些圆盘的镶嵌方式见图7.6。）模群同样作用于白色圆盘。在图 7.4 的右侧框架中，观察下方的蓝色圆圈<span class="math inline">\(C_B\)</span> 和 <span class="math inline">\(C_b\)</span>。它们的像 <span class="math inline">\(a(C_B)\)</span> 和 <span class="math inline">\(a(C_b)\)</span>也是相切的圆，实际上是前两个圆关于实轴的对称映像。这四个圆相切，并且将单位圆的白色外部区域切割成四个部分。试着从另一个角度来理解，你会发现，在这片白色外部区域中，模群的拼接模式也显现出来：四个相切的圆，其中相邻的圆形成一对。证明这两个相切点对应于抛物线元<span class="math inline">\(b\)</span> 和 <span class="math inline">\(abA\)</span>，而另外两个则是乘积 <span class="math inline">\(abAB\)</span> 和 <span class="math inline">\(BabA\)</span>，这两个也是抛物线元，分别在 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(-1\)</span>处有不动点。这个子群的极限集是单位圆。</p></div><div id="proj-7.5" class="statement sta_7_5__farey_fractions_and_euclid_s_algorithm plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.5:Farey fractions and Euclid’s algorithm</span>.</span><span class="statement-spah"> </span><strong>7.5:法雷分数与欧几里得算法</strong></p><p>To show that every rational number <span class="math inline">\(p/q\)</span> is a vertex of the modular tiling inFigure 7.9 we need to find two other integers <span class="math inline">\(r\)</span> and <span class="math inline">\(s\)</span> such that <span class="math inline">\(ps - qr = \pm 1\)</span>. Why will this do what wewant?</p><p>The procedure for finding <span class="math inline">\(r\)</span> and<span class="math inline">\(s\)</span> like this is exactly the famousEuclidean algorithm for finding the highest common factor of twonumbers. In this case, we may as well suppose that <span class="math inline">\(p/q\)</span> is in its lowest terms so the highestcommon factor is 1. Let’s suppose <span class="math inline">\(p &gt; q&gt; 0\)</span>. The algorithm says we shall be able to find integers<span class="math inline">\(a_1, r_1, a_2, r_2, \ldots\)</span> and soon such that:</p><p><span class="math display">\[\begin{aligned}&amp; p = a_1 q + r_1, \quad 0 &lt; r_1 &lt; q, \\&amp; q = a_2 r_1 + r_2, \quad 0 &lt; r_2 &lt; r_1, \\&amp; r_1 = a_3 r_2 + r_3, \quad 0 &lt; r_3 &lt; r_2, \\&amp; \vdots \\&amp; r_{n-1} = a_{n+1} r_n + 1.\end{aligned}\]</span></p><p>Using these equations you can work backwards to find <span class="math inline">\(r\)</span> and <span class="math inline">\(s\)</span>. For example, if <span class="math inline">\(p = 14\)</span>, <span class="math inline">\(q =3\)</span> then <span class="math inline">\(14 = 4 \cdot 3 + 2\)</span>,<span class="math inline">\(3 = 2 \cdot 1 + 1\)</span> and so <span class="math inline">\(14 - 4 \cdot 3 = 2 = 3 - 1\)</span> giving <span class="math inline">\(14 - 5 \cdot 3 = -1\)</span>. Now try to spot theconnection with continued fractions:</p><p><span class="math display">\[\frac{14}{3} = 4 + \frac{2}{3} = 4 +\frac{1}{\frac{3}{2}} = 4 + \frac{1}{1 + \frac{1}{2}}.\]</span></p><p>要证明每个有理数 <span class="math inline">\(p/q\)</span> 都是图 7.9中模群镶嵌的一个顶点，我们需要找到两个整数 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(s\)</span>，使得 <span class="math inline">\(ps -qr = \pm 1\)</span>。为什么这能达到我们的目标？</p><p>这种寻找 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(s\)</span>的方法正是著名的欧几里得算法，用于求两个数的最大公因数。在这种情况下，我们可以假设<span class="math inline">\(p/q\)</span>已经化为最简分数，因此它们的最大公因数为 1。假设 <span class="math inline">\(p &gt; q &gt;0\)</span>。算法指出，我们可以找到整数 <span class="math inline">\(a_1,r_1, a_2, r_2, \ldots\)</span> 等，使得：</p><p><span class="math display">\[\begin{aligned}&amp; p = a_1 q + r_1, \quad 0 &lt; r_1 &lt; q, \\&amp; q = a_2 r_1 + r_2, \quad 0 &lt; r_2 &lt; r_1, \\&amp; r_1 = a_3 r_2 + r_3, \quad 0 &lt; r_3 &lt; r_2, \\&amp; \vdots \\&amp; r_{n-1} = a_{n+1} r_n + 1.\end{aligned}\]</span> 利用这些等式可以回溯找到 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(s\)</span>。例如，如果 <span class="math inline">\(p = 14\)</span>，<span class="math inline">\(q =3\)</span>，则 <span class="math inline">\(14 = 4 \cdot 3 +2\)</span>，<span class="math inline">\(3 = 2 \cdot 1 + 1\)</span>，因此<span class="math inline">\(14 - 4 \cdot 3 = 2 = 3 - 1\)</span>，从而<span class="math inline">\(14 - 5 \cdot 3 =-1\)</span>。现在尝试找到与连分数的联系： <span class="math display">\[\frac{14}{3} = 4 + \frac{2}{3} = 4 +\frac{1}{\frac{3}{2}} = 4 + \frac{1}{1 + \frac{1}{2}}.\]</span></p></div><div id="proj-7.6" class="statement sta_7_6__the_modular_group_and_odd_even_fractions plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.6:The modular group and odd-even fractions</span>.</span><span class="statement-spah"> </span><strong>7.6：模群与奇偶分数</strong></p><p>Show that if <span class="math inline">\(\begin{pmatrix} a &amp; b \\c &amp; d \end{pmatrix}\)</span> is in the (small) modular group then<span class="math inline">\(a\)</span> and <span class="math inline">\(d\)</span> are odd and <span class="math inline">\(b\)</span> and <span class="math inline">\(c\)</span> are even. Why is a fraction in theorbit of <span class="math inline">\(0\)</span> under the (small)modular group exactly when it is ‘even/odd’? What can you say aboutodd/odd and odd/even? (Notice that in any triple of Farey neighbours youget one fraction of each kind.)</p><p>证明如果 <span class="math inline">\(\begin{pmatrix} a &amp; b \ c&amp; d \end{pmatrix}\)</span> 属于（小）模群，则 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(d\)</span> 为奇数，<span class="math inline">\(b\)</span> 和 <span class="math inline">\(c\)</span>为偶数。为什么当一个分数在（小）模群作用下的轨道中时，它恰好是“偶/奇”分数？关于奇/奇和奇/偶分数可以说些什么？（请注意，在任何一个Farey 邻居三元组中，总会有一种类型的分数。）</p></div><div id="proj-7.7" class="statement sta_7_7__the_modular_group_or_not_ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.7:The modular group or not?</span>.</span><span class="statement-spah"></span><strong>7.7：模群还是别的？</strong></p><p>It is interesting to compare the group which generated Figure 6.5 inthe last chapter with the modular group. The group in Chapter 6 hasgenerators</p><p><span class="math display">\[a = \begin{pmatrix} \sqrt{2} &amp; i \\-i &amp; \sqrt{2} \end{pmatrix} \text{ and } b = \begin{pmatrix}\sqrt{2} &amp; 1 \\ 1 &amp; \sqrt{2} \end{pmatrix}.\]</span></p><p>The conjugated picture of this group in frame (v) of Figure 6.10looks exactly the same as the basic tile for the modular group in Figure7.9. Are these two groups the same up to conjugation or not?</p><p>将第 6 章中生成 <a href="#fig-6.5">图 6.5</a>的群与模群进行比较很有趣。第 6 章中的群的生成元为： <span class="math display">\[a = \begin{pmatrix} \sqrt{2} &amp; i \\ -i &amp;\sqrt{2} \end{pmatrix} \text{ and } b = \begin{pmatrix} \sqrt{2} &amp; 1\\ 1 &amp; \sqrt{2} \end{pmatrix}.\]</span> 在 <a href="#fig-6.10">图6.10</a> 的第 (v) 帧中，该群的共轭图看起来与 <a href="#fig-7.9">图7.9</a> 中模群的基本镶嵌完全相同。它们是否在共轭意义下相同？</p></div><div id="proj-7.8" class="statement sta_7_8__a_special_schottky_group plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.8: Aspecial Schottky group</span>.</span><span class="statement-spah"></span><strong>7.8：一个特殊的 Schottky 群</strong></p><p>In Project 4.1 we introduced a family of Schottky groups depending on2 real numbers <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> which mapped the real axis to itself.These groups were designed so that the order of the Schottky circlesalong the real axis was the same as for the modular group. In fact, weorganised things so that when <span class="math inline">\(s = 0\)</span>and <span class="math inline">\(t = 1\)</span>, we get the modular groupitself! Just as we did on p.&nbsp;<span class="math inline">\(179ff\)</span>. in the last chapter, we can use this family to seeexplicitly what happens as we bring the four disjoint circles togetheruntil they touch.</p><p>Check that if <span class="math inline">\(s = 0\)</span>, then bothgenerators are parabolic. Which of the four Schottky circles touch? Showthat if <span class="math inline">\(s = 0\)</span> then <span class="math inline">\(\text{Tr } ab = 2 - 4/t^2\)</span> and thedistance between its fixed points is <span class="math inline">\(4\sqrt{1 - t^2}/t^2\)</span>. Hence verifydirectly that as <span class="math inline">\(t\)</span> tends to 1,<span class="math inline">\(ab\)</span> also becomes parabolic withtrace <span class="math inline">\(-2\)</span> and fixed point at <span class="math inline">\(-1\)</span>, the tangency point of <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_b\)</span>. Which group element corresponds tothe tangency point of <span class="math inline">\(C_A\)</span> and <span class="math inline">\(C_b\)</span>? Why does it become parabolic at thesame time as <span class="math inline">\(ab\)</span>?</p><p>在项目 4.1 中，我们介绍了一个取决于两个实数 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 的 Schottky群族，这些群将实轴映射到自身。我们特意设计这些群，使得沿实轴的 Schottky圆的排列顺序与模群相同。事实上，我们特意安排使得当 <span class="math inline">\(s = 0\)</span> 且 <span class="math inline">\(t =1\)</span> 时，该群就是模群本身！正如上一章第 179页及后续部分所讨论的那样，我们可以利用这个群族来直观地观察，当四个互不相交的圆逐渐靠近直至相切时会发生什么。</p><p>验证当 <span class="math inline">\(s = 0\)</span>时，这两个生成元都是抛物变换。此时，哪四个 Schottky 圆相切？证明如果<span class="math inline">\(s = 0\)</span>，则 <span class="math inline">\(\mathop{\mathrm{Tr}}{ab} = 2 -4/t^2\)</span>，且其不动点之间的距离为 <span class="math inline">\(4\sqrt{1 - t^2}/t^2\)</span>。从而可以直接验证，当<span class="math inline">\(t \to 1\)</span> 时，<span class="math inline">\(ab\)</span> 也成为一个抛物变换，其迹为 <span class="math inline">\(-2\)</span>，且不动点为 <span class="math inline">\(-1\)</span>，即圆 <span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_b\)</span> 的切点。哪个群元素与圆 <span class="math inline">\(C_A\)</span> 和 <span class="math inline">\(C_b\)</span> 的切点相关？为什么它会恰好在 <span class="math inline">\(ab\)</span> 变为抛物变换时同时成为抛物变换？</p></div><div id="proj-7.9" class="statement sta_7_9__nesting_circles_which_don_t_shrink_ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.9:Nesting circles which don’t shrink!</span>.</span><span class="statement-spah"></span><strong>7.9：不会收缩的嵌套圆！</strong></p><p>It is not quite easy to find an explicit group whose generators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> pair opposite Schottky circles in atangent chain in such a way that <span class="math inline">\(abAB\)</span> is not parabolic. If instead we usecircles paired according to the modular group pattern, it is muchsimpler. The non-parabolic element will be the product <span class="math inline">\(ab\)</span>.</p><p>We do it with a slight alteration to the modular group which iseasiest to describe in terms of the vertices of the red and green idealquadrilateral in Figure 7.9. Fix the vertices at <span class="math inline">\(0\)</span>, <span class="math inline">\(-1\)</span> and <span class="math inline">\(\infty\)</span> but move the vertex <span class="math inline">\(1\)</span> to a point <span class="math inline">\(r\)</span> on the real axis slightly to its right(so <span class="math inline">\(r &gt; 1\)</span>). Check that</p><p><span class="math display">\[b = \begin{pmatrix} 1 &amp; 1 + r \\ 0&amp; 1 \end{pmatrix} \text{ and } a = \begin{pmatrix} 1 &amp; 0 \\ -1 -1/r &amp; 1 \end{pmatrix}\]</span></p><p>pair the new chain of tangent circles, matching tangency pointscorrectly.</p><p>Verify that <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are parabolic with fixed points at<span class="math inline">\(\infty\)</span> and <span class="math inline">\(0\)</span>. Now calculate <span class="math inline">\(ab\)</span> and show it is hyperbolic whenever<span class="math inline">\(r &gt; 1\)</span>. Where are its fixedpoints? If you have a suitable program up and running, you may wish todraw some pictures to check that the diameters of the nested circles donot shrink properly near <span class="math inline">\(-1\)</span> and<span class="math inline">\(r\)</span>.</p><p>要显式构造一个群，使其生成元 <span class="math inline">\(a\)</span>和 <span class="math inline">\(b\)</span> 能将相切链中相对的 Schottky圆配对，且使得 <span class="math inline">\(abAB\)</span>不是抛物型变换，这并非易事。但若采用模群的圆配对方式，问题便大为简化——此时非抛物元素恰是乘积</p><p>我们通过对模群稍作调整来实现这一点，最简单的方法是借助图 7.9中红色和绿色理想四边形的顶点：将三个顶点固定于 <span class="math inline">\(0,-1,\infty\)</span> 处，并将顶点 <span class="math inline">\(1\)</span> 沿实轴向右侧略微移动至 <span class="math inline">\(r\)</span>（即 <span class="math inline">\(r &gt;1\)</span>）。可验证矩阵 <span class="math display">\[b =\begin{pmatrix} 1 &amp; 1 + r \\ 0 &amp; 1 \end{pmatrix} \text{ and } a= \begin{pmatrix} 1 &amp; 0 \\ -1 - 1/r &amp; 1\end{pmatrix}\]</span></p><p>能正确配对新生成的相切圆链，并精确匹配切点。</p><p>验证这时 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 都是抛物型变换，其不动点分别位于 <span class="math inline">\(\infty\)</span> 和 <span class="math inline">\(0\)</span>。然后计算 <span class="math inline">\(ab\)</span> 并证明当 <span class="math inline">\(r&gt; 1\)</span>时它是双曲变换。它的不动点在哪里？如果你有合适的程序运行，不妨绘制一些图像，检查靠近<span class="math inline">\(-1\)</span> 和 <span class="math inline">\(r\)</span> 处的嵌套圆的直径是否未按预期缩小。</p></div><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>Reproduced from Nature, 137, 1936.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>The refinement has to do with ensuring that circlesappear with the desired visual accuracy.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p>The refinement has to do with ensuring that circlesappear with the desired visual accuracy.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>That would have made high school geometry a lot simpler!Perhaps that’s why triangles like this are called ‘ideal’.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd-Coxeter algorithm and uniform polytopes</title>
      <link href="/polytopes/index.html"/>
      <url>/polytopes/index.html</url>
      
        <content type="html"><![CDATA[<p>This project uses Python and POV-Ray to render 3D/4D uniformpolytopes. The code is hosted on <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/polytopes">GitHub</a>and requires the <code>numpy</code> library and the free raytracer,<code>POV-Ray</code>.</p><h1 id="examples">Examples</h1><p>All the images and videos displayed below are created using thisprogram. The polytope data is computed in Python and then exported toPOV-Ray for rendering.</p><ul><li><p>All Platonic solids and Archimedean solids, prims and antiprisms,for example the <a href="https://en.wikipedia.org/wiki/Snub_dodecahedron">snubdodecahedron</a>:</p><p><video src="/images/polytopes/snub-dodecahedron.mp4" controls=""></video></p></li><li><p>All Kepler-Poinsot solids, for example the <a href="https://en.wikipedia.org/wiki/Great_icosahedron">greaticosahedron</a>:</p><p><video src="/images/polytopes/great-icosahedron.mp4" controls=""></video></p></li><li><p>All uniform 4d polytopes (except the <a href="https://en.wikipedia.org/wiki/Grand_antiprism">grandantiprism</a>, which is non-Wythoffian), for example my github favicon,the <a href="https://en.wikipedia.org/wiki/Runcinated_120-cells">runcinated120-cell</a>:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/github-favicon.png"></p></li><li><p>5-cell:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/5-cell.png"></p></li><li><p>4d cube:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/4-cube.png"></p></li><li><p><a href="https://en.wikipedia.org/wiki/Truncated_tesseract">Truncatedtesseract</a>:</p><p><video src="/images/polytopes/truncated-tesseract.mp4" controls=""></video></p></li><li><p><a href="https://en.wikipedia.org/wiki/600-cell">600-cell</a>:(you can render the bubble faces and choose which of them are shown)</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/600-cell.png"></p></li><li><p><a href="https://en.wikipedia.org/wiki/16-cell">runcinated16-cell</a>:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/runcinated-16-cell.png"></p></li><li><p><a href="https://en.wikipedia.org/wiki/Snub_24-cell">snub24-cell</a>:</p><p><video src="/images/polytopes/snub24-cell.mp4" controls=""></video></p></li><li><p>You can also render uniform star 4d polytopes, for example the <a href="https://en.wikipedia.org/wiki/Grand_stellated_120-cell">grandstellated 120-cell</a>:</p><p><video src="/images/polytopes/grand-stellated-120-cell.mp4" controls=""></video></p><p>and its rectified version (rendered in a curved fashion):</p><p><video src="/images/polytopes/rectified-grand-stellated-120-cell.mp4" controls=""></video></p></li><li><p>And finally, uniform 5D polytopes like 5-cube:</p><p><video src="/images/polytopes/5-cube.mp4" controls=""></video></p></li></ul><h1 id="what-are-these-examples-about">What are these examplesabout?</h1><p>The polytopes showcased above are convex and non-convex uniformpolytopes in 3D or 4D Euclidean spaces. Key terms to note include“convex/non-convex”, “Euclidean”, and “uniform”.</p><p>The term “convex” refers to the property of a polytope such that anyline segment joining two points on the polytope lies entirely within theenclosure of the polytope. Examples of convex polytopes include Platonicsolids, Archimedean solids, and Catalan solids, while non-convex onesinclude Kepler-Poinsot solids and star polychora.</p><p>In 3D Euclidean space, there are 18 different convex uniformpolytopes (excluding the two infinite classes of prisms and antiprisms)and 57 different non-convex uniform polytopes. Currently, my program canonly render the convex ones and a few non-convex ones, but I’m workingon figuring out how to make it work for all of them in the future.</p><p>The term “Euclidean” is emphasized here because we also have uniformpolytopes in other metric spaces, such as the hyperbolic metric, whichbends the space and makes the polytopes look “deformed”. A famousexample of this is the logo “Spikey” of Mathematica, which is based onthe dodecahedron in hyperbolic 3-space.</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/spikey.png"></p><p>The term “uniform” requires some mathematical subtleties. Roughlyspeaking, it means that</p><ol type="1"><li>All vertices are the same.</li><li>All faces are regular polygons.</li><li>All cells are uniform polyhedra (a polyhedron that satisfiesconditions 1 and 2).</li></ol><p>To explain what “the same” means, we need to use terms from grouptheory: it means that the symmetry group <span class="math inline">\(G\)</span> of the polytope acts transitively onthe set of vertices, such that for any pair of vertices <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>, there is some <span class="math inline">\(g\in G\)</span> that transforms <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>: <span class="math inline">\(g \cdot u= v\)</span>.</p><p>In the above examples, the polytopes are colored such that allvertices, edges, and faces that are in the same orbit under the actionof the symmetry group have the same color.</p><h1 id="how-to-compute-the-data-of-a-uniform-polytope">How to computethe data of a uniform polytope</h1><p>Though these polytopes appear quite different from each other, theycan all be constructed using a uniform approach called the <a href="https://en.wikipedia.org/wiki/Wythoff_construction">Wythonffconstruction</a> (also known as the kaleidoscope construction). Inprinciple, this construction works in the same way as a kaleidoscope: weplace reflection planes (mirrors) in space, passing through the originand with carefully chosen angles between them (which must be of the form<span class="math inline">\(\pi-\pi/p\)</span> for some rational <span class="math inline">\(p\)</span>). These mirrors partition space into“rooms”. We choose any room (called the fundamental domain) and aninitial vertex <span class="math inline">\(v_0\)</span> in it, and thenrepeatedly reflect <span class="math inline">\(v_0\)</span> about themirrors to obtain a set of virtual images. All virtual images togetherwith <span class="math inline">\(v_0\)</span> form the vertices of ourpolytope. If <span class="math inline">\(v_1\)</span> is the virtualimage of <span class="math inline">\(v_0\)</span> about the <span class="math inline">\(i\)</span>-th mirror, then <span class="math inline">\((v_0,v_1)\)</span> form an edge of type <span class="math inline">\(i\)</span>. We can use the symmetry group totransform it to other edges in the same orbit. Also, if <span class="math inline">\(v_0\)</span> is firstly reflected about mirror<span class="math inline">\(i\)</span> and then reflected about mirror<span class="math inline">\(j\)</span>, then since the composition oftwo reflections is a rotation, <span class="math inline">\(v_0\)</span>is rotated about the center of some face <span class="math inline">\(f\)</span> by an angle of <span class="math inline">\(2\pi/m\)</span> (assuming the angle between mirror<span class="math inline">\(i\)</span> and mirror <span class="math inline">\(j\)</span> is <span class="math inline">\(\pi-\pi/m\)</span>). We can recover <span class="math inline">\(f\)</span> by applying this rotation <span class="math inline">\(m\)</span> times and using the symmetry group toobtain other faces.</p><p>To implement the above strategy in a practical program, we need toaddress two main issues:</p><ol type="1"><li>How to position the mirrors and select the initial vertex <span class="math inline">\(v_0\)</span> for a given convex uniformpolytope?</li><li>Once the mirrors and <span class="math inline">\(v_0\)</span> aredetermined, how do we compute all the virtual images of <span class="math inline">\(v_0\)</span>?</li></ol><p>The solution to the first problem is known as the <a href="https://en.wikipedia.org/wiki/Coxeter%E2%80%93Dynkin_diagram">Coxeter-Dynkindiagram</a>, which is a labeled undirected graph that encodes all thenecessary information. Each uniform polytope has a correspondingCoxeter-Dynkin diagram that represents it, although different diagramsmay represent the same polytope.</p><p>For example, the Coxeter-Dynkin diagram of the cube is:</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="250"></p><p>Let’s delve deeper into the Coxeter-Dynkin diagram. Each node in thediagram represents a mirror in the kaleidoscope. In the diagram above,there are three nodes, and therefore three mirrors, which we label fromleft to right as <span class="math inline">\(m_0\)</span>, <span class="math inline">\(m_1\)</span>, and <span class="math inline">\(m_2\)</span>. The labelled edge between two nodesencodes the angle between their corresponding mirrors, as follows:</p><ol type="1"><li>Two nodes are connected if and only if the angle between theirmirrors is not equal to <span class="math inline">\(\pi/2\)</span>.</li><li>Two nodes are connected by an unlabelled edge if and only if theangle between their mirrors equals <span class="math inline">\(\pi-\pi/3\)</span>.</li><li>Two nodes are connected by an edge labelled with a rational number<span class="math inline">\(m&gt;2\)</span> and <span class="math inline">\(m\ne3\)</span> if and only if the angle betweentheir mirrors equals <span class="math inline">\(\pi-\pi/m\)</span>.</li></ol><p>Moreover, we use “circled” nodes to indicate which mirrors are“active”, i.e., those that do not contain the initial vertex <span class="math inline">\(v_0\)</span>. In this case, reflecting <span class="math inline">\(v_0\)</span> about an active mirror produces avirtual image.</p><p>In the above example we have <span class="math inline">\(\langlem_0,m_1\rangle=\pi-\pi/4\)</span>, <span class="math inline">\(\langlem_1,m_2\rangle=\pi-\pi/3\)</span>, <span class="math inline">\(\langlem_0,m_2\rangle=\pi/2\)</span>. <span class="math inline">\(m_0\)</span>is active, but <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> are not.</p><p>Therefore, we can place the three mirrors as follows: (<span class="math inline">\(n_i\)</span> is the normalized normal vector ofmirror <span class="math inline">\(m_i\)</span>)</p><ol type="1"><li>The normal of <span class="math inline">\(m_0\)</span> can be chosenarbitrarily, for example <span class="math inline">\(n_0=(1,0,0)\)</span>.</li><li>The angle between <span class="math inline">\(n_1\)</span> and <span class="math inline">\(n_0\)</span> is <span class="math inline">\(3\pi/4\)</span>, so we can choose <span class="math inline">\(n_1\)</span> to be <span class="math inline">\(n_1=(\cos\dfrac{3\pi}{4}, \sin\dfrac{3\pi}{4},0)\)</span>.</li><li>The normal of <span class="math inline">\(m_2\)</span> isperpendicular to <span class="math inline">\(n_0\)</span>, so <span class="math inline">\(n_2\)</span> has the form <span class="math inline">\((0,y_3,z_3)\)</span>. Using <span class="math inline">\(\langle n_1,n_2\rangle=2\pi/3\)</span>, we have<span class="math inline">\(y_3\sin\dfrac{3\pi}{4}=\cos\dfrac{2\pi}{3}\)</span>,and since <span class="math inline">\(z_3\)</span> is a unit vector,<span class="math inline">\(z_3=\sqrt{1−y_3^2}\)</span>. We can solvethese two equations to obtain <span class="math inline">\(y_3,z_3\)</span>.</li></ol><p>To choose an initial vertex <span class="math inline">\(v_0\)</span>that lies on both <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> but not on <span class="math inline">\(m_0\)</span>, we can choose <span class="math inline">\(v_0\)</span> so that its distance to <span class="math inline">\(m_0\)</span> is 1 and its distance to <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> are both 0:</p><p><span class="math display">\[\begin{align*}\langle v_0,n_0\rangle=1,\\\langle v_0, n_1\rangle=0,\\\langle v_0,n_2\rangle=0.\\\end{align*}\]</span></p><p>Then solve this linear system to get <span class="math inline">\(v_0\)</span>.</p><p>As mentioned before the angles between the mirrors must be chosencarefully to ensure <span class="math inline">\(v_0\)</span> and itsvirtual images form the vertices of an uniform polytope, this restrictsus to only finitely many choices of Coxeter diagrams, you can refer tothis <a href="https://en.wikipedia.org/wiki/Uniform_polytope">wikipage</a> for the complete list.</p><p>The answer to the second question is called the Todd-Coxeteralgorithm, I’ll discuss it in the next section.</p><h1 id="finitely-presented-groups-and-todd-coxeter-algorithm">Finitelypresented groups and Todd-Coxeter algorithm</h1><p>How can we obtain all the virtual images of the initial vertex <span class="math inline">\(v_0\)</span> with respect to all mirrors? Anobvious but crude method is to repeatedly reflect <span class="math inline">\(v_0\)</span> about the mirrors and compare theresulting images with the set of virtual images obtained so far (withina predefined rounding error bound) until no new virtual images emerge.This approach is easy to program but it’s unappealing from amathematician’s perspective, as it fails to utilize the abundantsymmetries inherent in the polytope.</p><p>This program takes a “symbolic computation” approach by solving the<a href="https://en.wikipedia.org/wiki/Coset_enumeration">cosetenumeration problem</a> in the symmetry group. It offers the advantageof providing exact information about the polytope without resorting torounding errors or approximation procedures. However, the price we payis that the math involved is somewhat complex (and hence so is thecode), and readers should have some basic knowledge of group theory tounderstand it.</p><p>Firstly, let’s recall the <a href="https://en.wikipedia.org/wiki/Group_action_(mathematics)#Orbit-stabilizer_theorem">orbit-stabilizertheorem</a> from group theory:</p><blockquote><p><strong>Theorem</strong>: Suppose a group <span class="math inline">\(G\)</span> acts transitively on a set <span class="math inline">\(S\)</span>, and let <span class="math inline">\(x\in S\)</span> have stabilizer subgroup <span class="math inline">\(H\leq G\)</span>. Then there exists a one-to-one correspondence between<span class="math inline">\(S\)</span> and the right cosets of <span class="math inline">\(G/H\)</span>: <span class="math inline">\(x \cdotg \mapsto Hg\)</span>.</p></blockquote><p>Note that the action of <span class="math inline">\(G\)</span> on<span class="math inline">\(S\)</span> is written as “applying on theright”, this is mainly for programming convenience and has nosignificant difference from applying on the left.</p><p>The theorem mentioned above tells us that if a group <span class="math inline">\(G\)</span> acts transitively on a set <span class="math inline">\(S\)</span> and we know the stabilizing subgroup ofsome <span class="math inline">\(x\in S\)</span> in <span class="math inline">\(G\)</span> is <span class="math inline">\(H\)</span>, then we can recover the entire orbit<span class="math inline">\(S\)</span> by applying a set of cosetrepresentatives of <span class="math inline">\(G/H\)</span> to <span class="math inline">\(x\)</span>.</p><p>Therefore, to compute all vertices of a given uniform polytope <span class="math inline">\(P\)</span>, we can follow these steps:</p><ol type="1"><li>Obtain a presentation of the symmetry group <span class="math inline">\(G\)</span> and the coordinates of an initialvertex <span class="math inline">\(v_0\)</span> from the Coxeter-Dynkindiagram.</li><li>Obtain a presentation of the stabilizing subgroup <span class="math inline">\(H\)</span> of <span class="math inline">\(v_0\)</span> in <span class="math inline">\(G\)</span> and calculate a set of right cosetrepresentatives of <span class="math inline">\(G/H\)</span>.</li><li>Apply these representatives to <span class="math inline">\(v_0\)</span> to obtain all vertices of <span class="math inline">\(P\)</span>.</li></ol><p>Again we use the cube as an example to show this procedure: recallthe Coxeter-Dynkin diagram of the cube is</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="250"></p><p>The mirrors of the cube are <span class="math inline">\(m_0,m_1,\)</span> and <span class="math inline">\(m_2\)</span>, with normals<span class="math inline">\(n_0, n_1,\)</span> and <span class="math inline">\(n_2\)</span>, respectively, all of which are unitvectors. The reflections about these mirrors are denoted as <span class="math inline">\(\rho_0, \rho_1,\)</span> and <span class="math inline">\(\rho_2\)</span>, and the matrix of <span class="math inline">\(\rho_i\)</span> is <span class="math inline">\(M_i= I - 2n_in_i^T\)</span> (see <a href="https://en.wikipedia.org/wiki/Householder_transformation">Householdertransformation</a>).</p><p>The symmetry group <span class="math inline">\(G\)</span> of the cubeis generated by the three aforementioned “generator reflections”: <span class="math inline">\(\rho_0, \rho_1,\)</span> and <span class="math inline">\(\rho_2\)</span>. A presentation of the groupis:</p><p><span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p>This is because a reflection always has order 2 and since <span class="math inline">\(\rho_0\)</span> and <span class="math inline">\(\rho_1\)</span> are two reflections with an angleof <span class="math inline">\(3\pi/4\)</span> between their mirrors,<span class="math inline">\(\rho_0\rho_1\)</span> is a rotation aboutthe line of intersection of their mirrors with an angle of <span class="math inline">\(3\pi/2\)</span>. Therefore, <span class="math inline">\((\rho_0\rho_1)^4=1\)</span>. Similarly, we havethe relations for <span class="math inline">\(\rho_1\rho_2\)</span> and<span class="math inline">\(\rho_0\rho_2\)</span>.</p><blockquote><p><strong>Note</strong>: It is natural to wonder if we might be missingsome “hidden” relations. For convex polytopes, the answer is no, but forcertain star polytopes, the answer is yes. In these cases, we need toadd extra relations to ensure the procedure works correctly. Asignificant difference is that, in convex cases, the symmetry groupalways maps the interior of the fundamental domain to another disjointone, whereas in star polytopes, the fundamental domain may be coveredmultiple times by other domains. For more information, refer toVinberg’s paper “Discrete linear groups generated by reflections”.</p></blockquote><p>One can employ the Todd-Coxeter algorithm (which will be explainedlater) to calculate a comprehensive list of all 48 elements in <span class="math inline">\(G\)</span>.</p><p><span class="math display">\[\begin{array}{lll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{0}&amp;\rho_{1}&amp;\rho_{0}\rho_{2}\\\rho_{2}&amp;\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\end{array}\]</span></p><p>Since the initial vertex <span class="math inline">\(v_0\)</span> ison <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> but not on <span class="math inline">\(m_0\)</span> in the Coxeter-Dynkin diagram, onlythe mirror <span class="math inline">\(m_0\)</span> is active. Thus,both <span class="math inline">\(\rho_1\)</span> and <span class="math inline">\(\rho_2\)</span> map <span class="math inline">\(v_0\)</span> to itself, while <span class="math inline">\(\rho_0\)</span> maps <span class="math inline">\(v_0\)</span> to its virtual image about <span class="math inline">\(m_0\)</span>. Therefore, the stabilizing subgroupof <span class="math inline">\(v_0\)</span> is given by:</p><p><span class="math display">\[H=\langle \rho_1, \rho_2\ |\\rho_1^2=\rho_2^2=(\rho_1\rho_2)^3=e\rangle.\]</span></p><blockquote><p><strong>Note</strong>: You may wonder if we can only claim that thesubgroup generated by <span class="math inline">\({\rho_0,\rho_1}\)</span> is contained in thestabilizing subgroup of <span class="math inline">\(v_0\)</span> but maynot be exactly equal to it. Indeed, this is a possibility. However, forCoxeter groups, it is a property that in the geometric realization of aCoxeter group <span class="math inline">\(W\)</span> (that is,representing <span class="math inline">\(W\)</span> as a set ofreflections about hyperplanes in <span class="math inline">\(\mathbb{R}^n\)</span>), the stabilizing subgroupof any point <span class="math inline">\(v\)</span> in the fundamentaldomain is a standard parabolic subgroup generated by those simplereflections whose hyperplanes contain <span class="math inline">\(v\)</span>. This may seem like an obviousgeometric intuition, but it requires a quite non-trivial proof, whichcan be found in Humphreys’s book “Reflection Groups and Coxeter Groups”,chapter 1.</p></blockquote><p>It is clear that <span class="math inline">\(H\)</span> is thedihedral group <span class="math inline">\(D_3\)</span>, thus <span class="math inline">\(|H|=6\)</span> and <span class="math inline">\(|G/H|=8\)</span>. Using the Todd-Coxeteralgorithm, we can obtain a complete list of coset representatives for<span class="math inline">\(G/H\)</span>:</p><p><span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span></p><p>Applying these coset representatives to <span class="math inline">\(v_0\)</span> gives us the 8 vertices of the cube.For example, the action of <span class="math inline">\(\rho_0\rho_1\)</span> on <span class="math inline">\(v_0\)</span> is as follows:</p><p><span class="math display">\[v_0(\rho_0\rho_1)=(v_0\rho_0)\rho_1=(v_0M_0)\rho_1=v_0M_0M_1.\]</span></p><p>Here, <span class="math inline">\(v_0\)</span> is represented as arow vector since all <span class="math inline">\(M_i\)</span>’s aresymmetric matrices.</p><p>We can also use the same procedure to find all edges and faces of thecube. To find all edges of type <span class="math inline">\(i\)</span>,we proceed as follows:</p><ol type="1"><li>Check if the initial vertex <span class="math inline">\(v_0\)</span>lies on the mirror <span class="math inline">\(m_i\)</span>. If it does,then the reflection <span class="math inline">\(\rho_i\)</span> fixes<span class="math inline">\(v_0\)</span>, and there are no edges of type<span class="math inline">\(i\)</span>. Otherwise, let <span class="math inline">\(v_1=\rho_i(v_0)\)</span>. Then, the segment <span class="math inline">\((v_0,v_1)\)</span> forms an edge <span class="math inline">\(e\)</span> of type <span class="math inline">\(i\)</span></li><li>To find the stabilizing subgroup of <span class="math inline">\(e\)</span>, we note that a symmetry fixes <span class="math inline">\(e\)</span> if and only if it fixes the midpoint<span class="math inline">\(p\)</span> of <span class="math inline">\(e\)</span>. Thus, the stabilizing subgroup of<span class="math inline">\(e\)</span> is the same as the stabilizingsubgroup of <span class="math inline">\(p\)</span>. From the previouscomment, we know that this subgroup is generated by those simplereflections whose mirrors contain <span class="math inline">\(p\)</span>. These mirrors are either <span class="math inline">\(m_i\)</span> (bisects <span class="math inline">\(e\)</span>), or those containing <span class="math inline">\(v_0\)</span> and orthogonal to <span class="math inline">\(m_i\)</span> (contain <span class="math inline">\(e\)</span>), so the stabilizing subgroup of <span class="math inline">\(e\)</span> is generated by <span class="math inline">\(\rho_i\)</span> and those simple reflections thatfix <span class="math inline">\(v_0\)</span> and commute with <span class="math inline">\(\rho_i\)</span>. In the case of the cube, we have<span class="math inline">\(H=\langle \rho_0,\rho_2\rangle\)</span>, so<span class="math inline">\(|H|=4\)</span> and <span class="math inline">\(|G/H|=12\)</span>, confirming that the cube has 12edges.</li><li>We then find a set of coset representatives of <span class="math inline">\(G/H\)</span> and apply them to <span class="math inline">\(e\)</span> to obtain all edges of type <span class="math inline">\(i\)</span>.</li></ol><p>To find all faces of type <span class="math inline">\((i,j)\)</span>,where <span class="math inline">\(i\neq j\)</span>, we use the sameprocedure. If at least one of <span class="math inline">\(m_i,m_j\)</span> is active, then the rotation<span class="math inline">\(r_{ij}=\rho_i\rho_j\)</span> generates aface <span class="math inline">\(f\)</span> of type <span class="math inline">\((i,j)\)</span>, which is invariant under <span class="math inline">\(\rho_i\)</span> and <span class="math inline">\(\rho_j\)</span>. However, if <span class="math inline">\(v_0\)</span> lies on exactly one of the twomirrors and they are perpendicular, we need to be careful. In this case,the stabilizing subgroup of <span class="math inline">\(f\)</span> isgenerated by <span class="math inline">\(\rho_i\)</span>, <span class="math inline">\(\rho_j\)</span>, and those generators that fix<span class="math inline">\(v_0\)</span> and commute with both <span class="math inline">\(\rho_i\)</span> and <span class="math inline">\(\rho_j\)</span>. We then find a set of cosetrepresentatives of <span class="math inline">\(G/H\)</span> and applythem to <span class="math inline">\(f\)</span> to obtain all faces oftype <span class="math inline">\((i,j)\)</span>.</p><p>Now the key step is to compute a set of coset representatives of<span class="math inline">\(G/H\)</span> for a finitely presented group<span class="math inline">\(G\)</span> and its subgroup <span class="math inline">\(H\)</span>, which is exactly what the Todd-Coxeteralgorithm does.</p><p>The Todd-Coxeter algorithm can be thought of as a Sudoku game wherethe table to complete is a dynamically growing 2D array <span class="math inline">\(T\)</span>. The rows of <span class="math inline">\(T\)</span> are labeled by the right cosets in<span class="math inline">\(G/H\)</span>, and the columns of <span class="math inline">\(T\)</span> are labeled by the generators of <span class="math inline">\(G\)</span>. Each entry <span class="math inline">\(T[i][j]\)</span> records the right coset obtainedby multiplying the <span class="math inline">\(j\)</span>-th generatoron the right of the <span class="math inline">\(i\)</span>-th coset. Thealgorithm uses the defining relations in the presentation of <span class="math inline">\(G\)</span> and <span class="math inline">\(H\)</span> as guidelines to find new cosets andfill their corresponding entries in <span class="math inline">\(T\)</span>. The game ends when all entries in<span class="math inline">\(T\)</span> are filled, and the coset in eachentry has a row in <span class="math inline">\(T\)</span> and satisfiesall relations. The resulting <span class="math inline">\(T\)</span> isthe adjacency matrix of the Schreier graph of <span class="math inline">\(G/H\)</span>, and one can easily obtain a completelist of word representations for all cosets in <span class="math inline">\(G/H\)</span>.</p><p>For a more detailed treatment of the Todd-Coxeter algorithm, pleaserefer to the Handbook of Computational Group Theory (HCGT) or otherrelated literature.</p><blockquote><p>Chapter 5, Handbook of Computational Group Theory, Holt, D., Eick,B., O’Brien, E.</p></blockquote><p>I will demonstrate below how the algorithm works using the cube as anexample:</p><blockquote><p><strong>Example</strong>: let <span class="math inline">\(G\)</span>be the symmetric group of the cube: <span class="math display">\[\begin{align*}G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2&amp;=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3\\&amp;=(\rho_0\rho_2)^2=1\rangle.\end{align*}\]</span>and subgroup <span class="math inline">\(H=\langle \rho_1,\rho_2\rangle\)</span>. Find a set of coset representatives of <span class="math inline">\(G/H\)</span>.</p></blockquote><p><strong>Our known relations</strong>:</p><ol type="1"><li>For each generator word <span class="math inline">\(w\)</span> of<span class="math inline">\(H\)</span>, it holds <span class="math inline">\(Hw=H\)</span>, i.e.&nbsp;<span class="math inline">\(H\rho_1=H\)</span> and <span class="math inline">\(H\rho_2=H\)</span>.</li><li>For any coset <span class="math inline">\(K\)</span> and anygenerator relation <span class="math inline">\(r\)</span> of <span class="math inline">\(G\)</span> it holds <span class="math inline">\(Kr=K\)</span>, i.e.&nbsp;<span class="math inline">\(K\rho_i^2=K,i=0,1,2\)</span>, and <span class="math inline">\(K(\rho_0\rho_1)^4=K(\rho_1\rho_2)^3=K(\rho_0\rho_2)^2=K.\)</span></li></ol><p>These relations can be stored in two lists, one for the relations in<span class="math inline">\(H\)</span> and one for the relations in<span class="math inline">\(G\)</span>, each relation can be furtherstored as an array of int type.</p><p>The first list stores the generator words of <span class="math inline">\(H\)</span>:</p><blockquote><ol start="0" type="1"><li>(1,) // <span class="math inline">\(\rho_1\)</span></li><li>(2,) // <span class="math inline">\(\rho_2\)</span></li></ol></blockquote><p>The second list stores the defining relations of <span class="math inline">\(G\)</span>:</p><blockquote><ol start="2" type="1"><li>(0, 0) // <span class="math inline">\(\rho_0^2=1\)</span></li><li>(1, 1) // <span class="math inline">\(\rho_1^2=1\)</span></li><li>(2, 2) // <span class="math inline">\(\rho_2^2=1\)</span></li><li>(0, 1, 0, 1, 0, 1, 0, 1) // (<span class="math inline">\(\rho_0\rho_1)^4=1\)</span></li><li>(1, 2, 1, 2, 1, 2) // (<span class="math inline">\(\rho_1\rho_2)^3=1\)</span></li><li>(0, 2, 0, 2) // (<span class="math inline">\(\rho_0\rho_2)^2=1\)</span></li></ol></blockquote><p>The relations are numbered from 0 to 7 for easy reference in thefollowing steps.</p><blockquote><p><strong>Note</strong>: When <span class="math inline">\(G\)</span> isnot represented as a Coxeter group, for example in the case of snubpolytopes, we need to consider the inverse of the generators as well,and they also occupy their own columns in <span class="math inline">\(T\)</span>. Therefore, the actual number ofcolumns in <span class="math inline">\(T\)</span> is twice the number ofgenerators. However, for Coxeter groups, all generators are involutions,so there is no need to insert columns for their inverses.</p></blockquote><p>Initially, the table <span class="math inline">\(T\)</span> has onlyone row, corresponding to the coset <span class="math inline">\(H\)</span> (which is the only coset we know atthis point).</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>Here, the algorithm initializes <span class="math inline">\(H_0\)</span> to be the subgroup <span class="math inline">\(H\)</span> and checks if it satisfies allrelations in the first list. Once this check is done, the first list canbe discarded. Then, the algorithm scans all cosets of <span class="math inline">\(T\)</span> from top to bottom and verifies if thecurrent coset satisfies all relations in the second list. During thisprocess, new cosets may be defined and their rows are appended at theend of <span class="math inline">\(T\)</span>. However, it is importantto note that some cosets in the table may actually represent the samecoset, so care must be taken.</p><hr><p>Let’s start by scanning <span class="math inline">\(H_0\)</span> andchecking whether the relations in the first list are satisfied byit:</p><ol type="1"><li>For relation 0, we have <span class="math inline">\(H_0\rho_1=H_0\)</span>, i.e., <span class="math inline">\(T[0][1]=0\)</span>.</li><li>For relation 1, we have <span class="math inline">\(H_0\rho_2=H_0\)</span>, i.e., <span class="math inline">\(T[0][2]=0\)</span>.</li></ol><p><span class="math inline">\(T\)</span> is now updated as follows:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><p><strong>Now that <span class="math inline">\(H_0\)</span> satisfiesall relations in the first list, we can discard it and focus on checkingthe relations in the second list</strong>.</p><p>We move on to check the relations in the second list for <span class="math inline">\(H_0\)</span>:</p><p>(2). Relation 2 says <span class="math inline">\(H_0\rho_0^2=H_0\)</span>. Since we do not know<span class="math inline">\(H_0\rho_0\)</span> yet, we define it to be<span class="math inline">\(H_1\)</span>, fill in 1 in its entry <span class="math inline">\(T[0][0]\)</span>, and append a new row for <span class="math inline">\(H_1\)</span>:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><strong>Note that each time we define or find <span class="math inline">\(H_i\rho_j=H_k\)</span> for some <span class="math inline">\(i,j,k\)</span>, we automatically get the “dual”relation <span class="math inline">\(H_k\rho_j=H_i\)</span>. Therefore,we always fill in a pair of entries <span class="math inline">\(T[i][j]=k\)</span> and <span class="math inline">\(T[k][j]=i\)</span> at a time</strong>.</p><p>(3). Relations 3 and 4 are already satisfied, so we continue.</p><p>(4). Relation 5 says <span class="math inline">\(H_0\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1=H_0\)</span>.We already know <span class="math inline">\(H_0\rho_0=H_1\)</span>, but<span class="math inline">\(H_1\rho_1\)</span> is unknown, so we defineit to be <span class="math inline">\(H_2\)</span>. We fill in the twoentries <span class="math inline">\(T[1][3]=2\)</span> and <span class="math inline">\(T[2][3]=1\)</span> and append a new row for <span class="math inline">\(H_2\)</span>.</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><span class="math inline">\(H_2\rho_0\)</span> is not yet defined, sowe set <span class="math inline">\(H_2\rho_0=H_3\)</span> and update thecorresponding entries in <span class="math inline">\(T\)</span>:</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>Continuing with the scan, we notice that <span class="math inline">\(H_3\rho_1\)</span> is unknown, and we might betempted to define it as a new coset <span class="math inline">\(H_4\)</span> and continue. However, this strategycan create many redundant cosets, leading to a rapid growth of <span class="math inline">\(T\)</span>. Instead, we scan the relation inreverse order, trying to fill the gaps without introducing new cosets.Recall that we scanned from left to right, and we arrived at thefollowing position: <span class="math display">\[H_0\rho_0\rho_1\rho_0(=H_3)\rho_1\rho_0\rho_1\rho_0\rho_1=H_0.\]</span>Now, scanning from right to left, we get <span class="math inline">\(H_0\rho_1\rho_0\rho_1\rho_0=H_3\)</span>, whichmeans that <span class="math display">\[H_0\rho_0\rho_1\rho_0(=H_3)\rho_1=H_0\rho_1\rho_0\rho_1\rho_0=H_3.\]</span> Thus, we have deduced that<span class="math inline">\(H_3\rho_1=H_3\)</span>, instead of definingit as a new coset. This technique is called a<strong>deduction</strong>, as described in the book HCGT. Therefore, weupdate <span class="math inline">\(T\)</span> accordingly:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><strong>So in the actual program we always scan a relation from bothends and define new cosets if necessary until they meet</strong>.</p><p>(5). Relation 6 is already satisfied, continue.</p><p>(6). Relation 7 says <span class="math inline">\(H_0\rho_0\rho_2\rho_0\rho_2=H_0\)</span>, scanningfrom both ends gives <span class="math display">\[H_0\rho_0(=H_1)\rho_2=H_0\rho_2\rho_0=H_1,\]</span>hence <span class="math inline">\(H_1\rho_2=H_1\)</span> and we makeanother deduction. <span class="math inline">\(T\)</span> nowbecomes</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>Now, <span class="math inline">\(H_0\)</span> satisfies all relationsin the two lists and the scanning of the first row is completed. We canmove on to begin scanning of the row for <span class="math inline">\(H_1\)</span>. Note the first list is nowdiscarded, and we will only check relations 2-7.</p><p>(1). Relations 2, 3, 4, and 5 are already satisfied. We can continueto the next relation. (2). Relation 6 says <span class="math inline">\(H_1\rho_1\rho_2\rho_1\rho_2\rho_1\rho_2=H_1\)</span>.We know that <span class="math inline">\(H_1\rho_1=H_2\)</span>, but<span class="math inline">\(H_2\rho_2\)</span> is unknown. Backwardscanning also gets stuck here: <span class="math display">\[H_1\rho_1(=H_2)\rho_2\rho_1=H_1\rho_2\rho_1\rho_2=H_2\rho_2.\]</span>So we define <span class="math inline">\(H_2\rho_2=H_4\)</span>. Then wehave <span class="math inline">\(H_4\rho_1=H_4\)</span>, and <span class="math inline">\(T\)</span> becomes:</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr></tbody></table><ol start="3" type="1"><li>Relation 7 is already satisfied for <span class="math inline">\(H_1\)</span>, so we can move on to scan the rowfor <span class="math inline">\(H_2\)</span>.</li></ol><hr><p>I’ll leave it as an exercise for you to complete the scanning of<span class="math inline">\(H_2\)</span>, <span class="math inline">\(H_3\)</span>, <span class="math inline">\(H_4\)</span>, and <span class="math inline">\(H_5\)</span>. These are relatively easy tasks.Once <span class="math inline">\(H_2\)</span> has been scanned, your<span class="math inline">\(T\)</span> should look like this:</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">3</td></tr></tbody></table><p>After completing the scanning of <span class="math inline">\(H_3\)</span>, your <span class="math inline">\(T\)</span> should be:</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr></tbody></table><p>After completing the scanning for <span class="math inline">\(H_4\)</span>, your <span class="math inline">\(T\)</span> should be:</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>And when we scan <span class="math inline">\(H_6\)</span>, we findthat relations 2-6 are already satisfied. From relation 7, <span class="math inline">\(H_6\rho_0\rho_2\rho_0\rho_2=H_6\)</span>, we get adeduction <span class="math inline">\(H_7\rho_2=H_7\)</span>, and <span class="math inline">\(T\)</span> is updated as follows:</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td></tr></tbody></table><p>One can check that <span class="math inline">\(H_7\)</span> satisfiesall relations in the second list, so no more cosets can be found and thegame is over.</p><p>The multiplication relations between these cosets can be obtainedusing breadth-first search:</p><p><span class="math display">\[\begin{array}{l}H_0 = H_0\cdot e,\\H_1=H_0\cdot\rho_0,\\H_2=H_1\cdot\rho_1=H_0\cdot\rho_0\rho_1,\\H_3=H_2\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0,\\H_4=H_2\cdot\rho_2=H_0\cdot\rho_0\rho_1\rho_2,\\H_5=H_3\cdot\rho_2=H_0\cdot \rho_0\rho_1\rho_0\rho_2,\\H_6=H_5\cdot\rho_1=H_0\cdot \rho_0\rho_1\rho_0\rho_2\rho_1,\\H_7=H_6\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0\rho_2\rho_1\rho_0.\end{array}\]</span></p><p>So a set of representatives can be chosen as</p><p><span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span> This is exactly what we have seen before.</p><blockquote><p><strong>Note</strong>: This example is a bit tedious, but it is stilla simple one because we did not encounter the case where two cosets inthe table are found to be the same (in the book HCGT, this is called a<strong>coincidence</strong>). When this occurs, the scanning must bepaused, and the control flow is jumped to handle this coincidence: a newstack <span class="math inline">\(q\)</span> is opened, and this pair ofcoincidences is pushed into <span class="math inline">\(q\)</span>.Then, one pair of coincidences is popped from <span class="math inline">\(q\)</span> at a time, their rows are merged, andnew coincidences that occur in the merging process are pushed into <span class="math inline">\(q\)</span>.</p></blockquote><h1 id="snub-polytopes">Snub polytopes</h1><p>Snub polytopes can be constructed by applying rotations in the fullsymmetry group to the initial vertex <span class="math inline">\(v_0\)</span>. In the case of the cube, we haveseen the full symmetry group <span class="math inline">\(G\)</span>is</p><p><span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p><span class="math inline">\(G\)</span> consists of 48 elements, halfof which are rotations, so totaling 24 rotations. These rotationsconstitute the symmetry group <span class="math inline">\(\widetilde{G}\)</span> of the snub cube, which canbe generated by three fundamental rotations: <span class="math inline">\(r_0=\rho_0\rho_1\)</span>, <span class="math inline">\(r_1=\rho_1\rho_2\)</span>, and <span class="math inline">\(r_2=\rho_0\rho_2\)</span>. Since <span class="math inline">\(r_0r_1=r_2\)</span>, it follows that <span class="math inline">\(\widetilde{G}\)</span> can be generated by only<span class="math inline">\(r_0\)</span> and <span class="math inline">\(r_1\)</span>.</p><p>A presentation of <span class="math inline">\(\widetilde{G}\)</span>is <span class="math display">\[\widetilde{G}=\langle r_0,r_1\ |\r_0^4=r_1^3=(r_0r_1)^2=1\rangle.\]</span> Using the Todd-Coxeteralgorithm, we can obtain a complete list of word representations of<span class="math inline">\(\widetilde{G}\)</span>:</p><p><span class="math display">\[\begin{array}{lll}e&amp;r_{0}&amp;r_{0}r_{0}\\r_{0}r_{0}r_{0}&amp;r_{1}&amp;r_{1}r_{1}\\r_{0}r_{1}&amp;r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{1}\\r_{0}r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}\\r_{1}r_{0}r_{0}&amp;r_{1}r_{0}r_{0}r_{0}&amp;r_{1}r_{1}r_{0}\\r_{1}r_{1}r_{0}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}\\r_{0}r_{0}r_{1}r_{1}r_{0}&amp;r_{1}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}r_{0}r_{1}r_{1}\\r_{1}r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{1}r_{0}r_{0}r_{1}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}r_{1}\end{array}\]</span></p><p>We choose the initial vertex <span class="math inline">\(v_0\)</span>so that it’s not on any of the three mirrors, and apply the above wordrepresentations of <span class="math inline">\(\widetilde{G}\)</span> to<span class="math inline">\(v_0\)</span>. This gives the 24 vertices ofthe snub cube.</p><p>To obtain the edges of the snub cube, the following steps can betaken:</p><ol type="1"><li>Each rotation <span class="math inline">\(r_i\,(i=0,1,2)\)</span>generates a base edge <span class="math inline">\(e\)</span>. These baseedges are in different orbits under the action of <span class="math inline">\(\widetilde{G}\)</span>.</li><li>The stabilizing subgroup of <span class="math inline">\(e\)</span>is <span class="math inline">\(H=\langle 1\rangle\)</span> if the orderof <span class="math inline">\(r_i\)</span> is greater than 2, or thecyclic group <span class="math inline">\(H=\langle r_i\rangle\)</span>if the order of <span class="math inline">\(r_i\)</span> is 2. The cosetrepresentatives of <span class="math inline">\(G/H\)</span> can becomputed, and applied to <span class="math inline">\(e\)</span> toobtain all other edges of type <span class="math inline">\(i\)</span>.</li></ol><p>The case of faces is slightly more involved:</p><ol type="1"><li><p>Each rotation <span class="math inline">\(r_i\,(i=0,1)\)</span>generates a base face <span class="math inline">\(f={v_0,r_i(v_0),\ldots, r_i^{m-1}(v_0)}\)</span> for <span class="math inline">\(m&gt;2\)</span>, where <span class="math inline">\(m\)</span> is the order of <span class="math inline">\(r_i\)</span>. For <span class="math inline">\(i=2\)</span>, <span class="math inline">\(m=2\)</span>, and <span class="math inline">\(f\)</span> is degenerated to an edge. Thestabilizing subgroup of <span class="math inline">\(f\)</span> is thecyclic group <span class="math inline">\(H=\langle r_i\rangle\)</span>.The coset representatives of <span class="math inline">\(G/H\)</span>can be computed, and applied to <span class="math inline">\(f\)</span>to obtain all other faces of type <span class="math inline">\(i\)</span>. For the snub cube, there are <span class="math inline">\(6\)</span> square faces generated by <span class="math inline">\(r_0\)</span> (since <span class="math inline">\(24/|\langle r_0\rangle|=24/4=6\)</span>), and<span class="math inline">\(8\)</span> triangle faces generated by <span class="math inline">\(r_1\)</span> (since <span class="math inline">\(24/|\langle r_1\rangle|=24/3=8\)</span>).</p></li><li><p>There is another type of triangle faces which comes from therelation <span class="math inline">\(r_0r_1=r_2\)</span>. Let’s considerthe three vertices <span class="math inline">\({v_0,v_0r_1,v_0r_2}\)</span>. We see that <span class="math inline">\((v_0, v_0r_1)\)</span> is an edge of type 1 and<span class="math inline">\((v_0, v_0r_2)\)</span> is an edge of type 2.But we also have <span class="math display">\[(v_0,v_0r_0)\xrightarrow{\ r_1\ }(v_0r_1, v_0r_0r_1) = (v_0r_1,v_0r_2).\]</span> That is, <span class="math inline">\((v_0r_1,v_0r_2)\)</span> is an edge of type 0 obtained by applying <span class="math inline">\(r_1\)</span> to the base edge <span class="math inline">\((v_0, v_0r_0)\)</span>. The stabilizing subgroupof this triangle must be <span class="math inline">\(\langle1\rangle\)</span> since all its three edgesare in different orbits. Thereforre, we have <span class="math inline">\(|\widetilde{G}|/1=24\)</span> triangle faces ofthis “mixed type”, which are not generated by any of the “fundamentalrotations”.</p></li></ol><p>So the snub cube has <span class="math inline">\(6+8+24=38\)</span>faces in total.</p><h1 id="star-polytopes">Star polytopes</h1><p>Most star polytopes can be generated using the Wythoff construction,but generally, it is not enough to use the method described abovedirectly. You also need to add an additional generating relation intothe group’s presentation.</p><p>To illustrate, let’s take the great dodecahedron as an example. ItsCoxeter-Dynkin diagram is shown below:</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/coxeter552.svg" width="250"></p><p>Therefore, the angles between the mirrors are <span class="math inline">\(\pi-2\pi/5, \pi/2, \pi-\pi/5\)</span>. If wecontinue with the previous analysis, we obtain the presentation of thesymmetry group as:</p><p><span class="math display">\[K = \langle\tau_0,\tau_1,\tau_2 \|\  \tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=(\tau_0\tau_2)^2=1\rangle.\]</span></p><p>This group is infinite, and since the quotient group of thestabilizer subgroup of <span class="math inline">\(v_0\)</span> is alsoinfinite, the Todd-Coxeter algorithm will not work here.</p><p>In fact, we just need to add another generating relation to thepresentation, namely <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>. With thisaddition, the presentation of the symmetry group becomes:</p><p><span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>Note that I intentionally used <span class="math inline">\(\tau\)</span> to represent reflections and <span class="math inline">\(K\)</span> to denote the symmetry group of thegreat dodecahedron. What’s happening here? Let’s take a look at thevideo:</p><video src="/images/polytopes/great-dodecahedron.mp4" controls=""></video><p>From the video, we can observe that the great dodecahedron and theicosahedron share the exact same set of vertices. However, it seems thatthe great dodecahedron can be obtained by digging some triangular holeson the surface of the icosahedron. In general, if the hole of astar-shaped polyhedron is a polygon with <span class="math inline">\(h\)</span> sides, the corresponding extra relationis given by <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^h=1\)</span>.</p><p>Let’s take a closer look at the fundamental region of the greatdodecahedron:</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/star.png" width="600"></p><p>The figure above shows <span class="math inline">\(\DeltaABC\)</span> as the fundamental domain of the icosahedron. Its internalangles are <span class="math inline">\(\angle CAB=\pi/5\)</span>，<span class="math inline">\(\angle CBA=\pi/2\)</span>，<span class="math inline">\(\angle ACB=\pi/3\)</span>. Reflections about thearcs <span class="math inline">\(BC\)</span>, <span class="math inline">\(AC\)</span>, and <span class="math inline">\(AB\)</span> are denoted by <span class="math inline">\(\rho_0\)</span>, <span class="math inline">\(\rho_1\)</span>, and <span class="math inline">\(\rho_2\)</span>, respectively. The presentation ofthe symmetry group of icosahedron, <span class="math inline">\(G\)</span>, can be expressed as follows: <span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^3=(\rho_1\rho_2)^5=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p>The great dodecahedron can be constructed as follows: we keep thevertices and edges of the icosahedron untouched, but change its faces.To do this we start a walk from vertex <span class="math inline">\(Q\)</span> and move along edge <span class="math inline">\(QA\)</span> to reach the next vertex <span class="math inline">\(A\)</span>. At <span class="math inline">\(A\)</span>, we skip the first edge on the right(<span class="math inline">\(AO\)</span>) and choose the second one,which is <span class="math inline">\(AK\)</span>, to follow and move tovertex <span class="math inline">\(K\)</span> (sorry for abusing thenotation <span class="math inline">\(K\)</span> here). We continuemoving in this way by always choosing the second edge to the right. Ittakes five steps to return to <span class="math inline">\(Q\)</span>,forming a pentagonal face of the great dodecahedron. By performing thisoperation for all edges of the icosahedron, we can generate all thefaces of the great dodecahedron.</p><p>This operaion is called <strong>faceting</strong>, it changes thefaces of a given polyhedron while preserving its vertices and edges.This is achieved by walking along the edges of the original polyhedronand choosing the <span class="math inline">\(k\)</span>-th edge to theright of the current path, where <span class="math inline">\(k\geq2\)</span> is a fixed integer. By repeating this process until a closedloop is formed, a new face is created. In our project, we use <span class="math inline">\(k=2\)</span>.</p><p>Let’s derive the relations between the symmetry groups <span class="math inline">\(G\)</span> and <span class="math inline">\(K\)</span>:</p><p>Consider the triangle <span class="math inline">\(\DeltaOAB\)</span>, which has internal angles <span class="math inline">\(\angle OAB=2\pi/5\)</span>, <span class="math inline">\(\angle OBA=\pi/2\)</span>, and <span class="math inline">\(\angle AOB=\pi/5\)</span>, and contains threecongruent triangles with the triangle <span class="math inline">\(\DeltaABC\)</span>. The reflections about its three edges <span class="math inline">\(OA\)</span>, <span class="math inline">\(OB\)</span>, and <span class="math inline">\(AB\)</span> are denoted by <span class="math inline">\(\tau_1=\rho_1\rho_2\rho_1\)</span>, <span class="math inline">\(\tau_0=\rho_0\)</span>, and <span class="math inline">\(\tau_2=\rho_2\)</span>.</p><p>In the language of group theory, the faceting operation <span class="math inline">\(\varphi_k\)</span> can be described astransforming the group <span class="math inline">\(G\)</span> intoanother group <span class="math inline">\(K\)</span>:</p><p><span class="math display">\[G=\langle\rho_0,\rho_1,\rho_2\rangle\xrightarrow{\ \varphi_k\}\langle\rho_0,\rho_1(\rho_2\rho_1)^{k-1},\rho_2\rangle=\langle\tau_0,\tau_1,\tau_2\rangle=K.\]</span></p><p>Usually, <span class="math inline">\(K\)</span> is a subgroup of<span class="math inline">\(G\)</span>, but in many cases, including thegreat dodecahedron here, <span class="math inline">\(G\)</span> and<span class="math inline">\(K\)</span> are the same group.</p><p>To see that <span class="math inline">\(K\)</span> is indeed thesymmetry group of the great dodecaheron, we can argue as follows:</p><p>Firstly, <span class="math inline">\(\langle\tau_1,\tau_2\rangle=\langle \rho_1,\rho_2\rangle\)</span> is thestabilizer subgroup of the vertex <span class="math inline">\(A\)</span>, so the great dodecahedron has the sameset of vertices as that of the icosahedron. However, <span class="math inline">\(\tau_1\tau_2\)</span> gives a rotation of <span class="math inline">\(4\pi/5\)</span>, which differs from <span class="math inline">\(\rho_1\rho_2\)</span> that gives a rotation of<span class="math inline">\(2\pi/5\)</span>. Consequently, the vertexconfiguration of the great dodecahedron forms a pentagram, whereas thatof the icosahedron forms a pentagon.</p><p>Secondly, the subgroup <span class="math inline">\(\langle\tau_0,\tau_2\rangle=\langle \rho_0,\rho_2\rangle\)</span> is thestabilizer of the edge <span class="math inline">\(AQ\)</span>. Thus,the great dodecahedron shares its edges with those of theicosahedron.</p><p>Thirdly, <span class="math inline">\(\langle\tau_0,\tau_1\rangle\)</span> is thestabilizer subgroup of one of the faces of the great dodecahedron. Notethat <span class="math inline">\(\tau_0\tau_1\)</span> is a rotation of<span class="math inline">\(2\pi/5\)</span> arounds <span class="math inline">\(O\)</span>. It maps the edge <span class="math inline">\(QA\)</span> to the edge <span class="math inline">\(AK\)</span>, corresponding to the operation ofselecting the <span class="math inline">\(k\)</span>-th edge to walk on.Repeatedly applying <span class="math inline">\(\tau_0\tau_1\)</span> to<span class="math inline">\(QA\)</span> will give the five edges of oneface of the great dodecahedron.</p><p>Let’s find out a hidden relation among <span class="math inline">\(\tau_0,\tau_1\)</span> and <span class="math inline">\(\tau_2\)</span>:</p><p>Note that <span class="math inline">\(\tau_1\tau_2\tau_1=\tau_1\rho_2\tau_1\)</span> isa reflection about <span class="math inline">\(AP\)</span>, and itscomposition with <span class="math inline">\(\tau_0=\rho_0\)</span> is arotation around the vertex <span class="math inline">\(P\)</span> by anangle of <span class="math inline">\(2\pi/3\)</span>, so <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>. Addingthis additional generating relation to the presentation of gives thecorrect presentation of <span class="math inline">\(K\)</span>:</p><p><span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>The remaining steps of the construction are identical to the previousones.</p><p>This extra relation has a geometric explanation: By applying thefaceting operation to the great dodecahedron again, we can restore ouricosahedron. We simply walk from <span class="math inline">\(Q\)</span>to <span class="math inline">\(A\)</span>, and when we reach <span class="math inline">\(A\)</span>, instead of selecting the edge <span class="math inline">\(AK\)</span> to continue moveing, we choose itsprevious one clockwise, which is <span class="math inline">\(AO\)</span>. Continuing to walk gives us back thetriangle face <span class="math inline">\(\Delta OAB\)</span> of theicosahedron. This correspondes to the exponent 3 in the extrarelation.</p><p>In terms of group theory, this can be expressed as <span class="math display">\[K=\langle\tau_0,\tau_1,\tau_2\rangle\xrightarrow{\ \varphi_2\}\langle\tau_0,\tau_1\tau_2\tau_1,\tau_2\rangle=\langle\rho_0,\rho_2\rho_1\rho_2,\rho_2\rangle=G.\]</span></p><p>One might wonder if there are more such relationships we haveoverlooked. However, since we know that <span class="math inline">\(K\)</span> is isomorphic to <span class="math inline">\(G\)</span> (though not proved in this article),there’s no cause for concern.</p><h1 id="appendix">Appendix</h1><p>I also added a script <code>run_coset_enumeration.py</code> forshowing how to compute the coset table of <span class="math inline">\(G/H\)</span> for a given finitely presented group<span class="math inline">\(G\)</span> and its subgroup <span class="math inline">\(H\)</span> (necessarily <span class="math inline">\(|G/H|&lt;\infty\)</span>). It assumes a<code>yaml</code> file as input which describes the presentation of<span class="math inline">\(G\)</span> and <span class="math inline">\(H\)</span>. An example format is</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">G8723</span><br><span class="hljs-attr">relators:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">a^8</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">b^7</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">(ab)^2</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">(Ab)^3</span><br><span class="hljs-attr">subgroup-generators:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">aa</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Ab</span><br></code></pre></td></tr></tbody></table></figure><p>Here we use the convention that uppercase means the inverse oflowercase, i.e.&nbsp;<span class="math inline">\(A=a^{-1},B=b^{-1}\)</span>.</p><p>So the presentation of this group is <span class="math display">\[G =\langle a, b\ |\ a^8=b^7=(ab)^2=(a^{-1}b)^3=1\rangle\]</span> and <span class="math inline">\(H=\langle a^2, a^{-1}b\rangle\)</span>.</p><p>Save this file as <code>G8723.yaml</code> and run </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python run_coset_enumeration.py G8723.yaml<br></code></pre></td></tr></tbody></table></figure> Theoutput should be (with some output omitted)<p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">           a    A    b    B<br>------------------------------<br>    1:     2    2    3    2<br>    2:     1    1    1    4<br>    3:     4    5    6    1<br>    4:     7    3    2    8<br>  ...    ...  ...  ...  ...<br>  ...    ...  ...  ...  ...<br>  ...    ...  ...  ...  ...<br>  446:   444  444  441  430<br>  447:   438  433  432  443<br>  448:   445  445  440  445<br></code></pre></td></tr></tbody></table></figure><p>so <span class="math inline">\(G/H\)</span> has 448 cosets.</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Sporadic Groups</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd Kemp 概率论课程笔记</title>
      <link href="/todd-kemp/bak2.html"/>
      <url>/todd-kemp/bak2.html</url>
      
        <content type="html"><![CDATA[<h1 id="measurable-functions">6.2 Measurable Functions</h1><p>本讲介绍了测度空间上可测映射的概念。</p><blockquote><p><strong>引理</strong>：设 <span class="math inline">\(f:\Omega\to\mathcal{S}\)</span> 是一个映射，<span class="math inline">\(\mathcal{A}\subset2^\mathcal{S}\)</span> 是 <span class="math inline">\(\mathcal{S}\)</span> 中一个集合族，定义 <span class="math display">\[f^{-1}(\mathcal{A}) =\{f^{-1}(E),E\in\mathcal{A}\}.\]</span> 则 <span class="math inline">\(\sigma(f^{-1}(\mathcal{A}))=f^{-1}(\sigma(\mathcal{A}))\)</span>。</p></blockquote><p>引理的证明不难， 只要注意到一个 <span class="math inline">\(\sigma-\)</span> 域在映射下的像 (push forward)和逆映射下的原像 (push back) 都是 <span class="math inline">\(\sigma-\)</span> 域即可。</p><blockquote><p><strong>定义：</strong>若 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 和 <span class="math inline">\((\mathcal{S}, \mathcal{B})\)</span>是两个可测空间，我们称 <span class="math inline">\(f:\Omega\to\mathcal{S}\)</span>是一个可测映射，如果有 <span class="math inline">\(f^{-1}(\mathcal{B})\subseteq\mathcal{F}\)</span>。</p></blockquote><p>要检查一个映射是不是可测的，我们不必对每个 <span class="math inline">\(B\in\mathcal{B}\)</span> 都检查，只要对满足 <span class="math inline">\(\sigma(\mathcal{A})=\mathcal{B}\)</span>的一个子集合族 <span class="math inline">\(\mathcal{A}\)</span> 检查有<span class="math inline">\(f^{-1}(\mathcal{A})\subseteq\mathcal{F}\)</span>即可。这是因为由上面的引理， <span class="math display">\[f^{-1}(\mathcal{B})=f^{-1}(\sigma(\mathcal{A}))=\sigma(f^{-1}(\mathcal{A}))\subseteq\mathcal{F}.\]</span></p><blockquote><p><strong>推论</strong>：如果 <span class="math inline">\(X_1,\ldots,X_n\)</span> 都是测度空间 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 上的可测函数，<span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}\)</span>是一个连续或者 Borel 可测的多元函数，则 <span class="math inline">\(Y=f(X_1,\ldots,X_n)\)</span> 也是可测函数。</p></blockquote><p>证明：记 <span class="math inline">\(X=(X_1,\ldots,X_n)\)</span>，我们要说明复合映射<span class="math display">\[\Omega\xrightarrow{\ X\}\mathbb{R}^n\xrightarrow{\ f\ }\mathbb{R}\]</span> 是可测的。由于 <span class="math inline">\(f\)</span> 显然可测，只要再说明 <span class="math inline">\(X\)</span> 是可测的。根据上面的引理，只要验证<span class="math display">\[X^{-1}\left((-\infty, t_1], (-\infty,t_2],\ldots, (-\infty, t_n]\right)=\bigcap_{i=1}^n \{X_i\leqt_i\}.\]</span> 是可测的，这显然。</p><h1 id="robustness-of-measurability">7.1 Robustness ofMeasurability</h1><p>本讲主要介绍了可测函数集合在通常的运算，以及取极限的操作下得到的仍然是可测函数。</p><p>下面这个结论在整个课程中都会频繁用到：</p><blockquote><p><strong>推论 (Doob-Dynkin 分解)</strong>：设 <span class="math inline">\(X_1,\ldots,X_d, Y\)</span> 都是 <span class="math inline">\((\Omega,\mathcal{F})\to(\mathbb{R},\mathcal{B}(\mathbb{R}))\)</span>的可测函数，而且 <span class="math inline">\(Y\)</span> 还关于 <span class="math inline">\(\sigma(X_1,\ldots,X_d)\)</span> 可测，则存在 Borel可测函数 <span class="math inline">\(f:\mathbb{R}^d\to\mathbb{R}\)</span> 使得 <span class="math inline">\(Y=f(X_1,\ldots,X_d)\)</span>。</p></blockquote><p>记 <span class="math inline">\(X=(X_1,\ldots,X_d)\)</span>，则 <span class="math inline">\(X:\Omega\to\mathbb{R}^d\)</span> 是 <span class="math inline">\(\mathcal{F}/\mathcal{B}(\mathbb{R}^d)\)</span>可测的。</p><p>我们先来说明有 <span class="math inline">\(\sigma(X_1,\ldots,X_n)=X^{-1}(\mathcal{B}(\mathbb{R}^d))\)</span>成立。这个基本就是把之前 6.2 讲的引理证了一遍。为方便记 <span class="math display">\[I^d=\{(-\infty,t_1]\times\cdots\times(-\infty,t_d],\ t_i\in\mathbb{R}\text{ or }t_i=+\infty\}.\]</span> 首先 <span class="math inline">\(\mathcal{B}(\mathbb{R}^d)\)</span> 在 <span class="math inline">\(X^{-1}\)</span> 下的 pull back <span class="math inline">\(X^{-1}(\mathcal{B}(\mathbb{R}^d))\)</span> 是一个<span class="math inline">\(\sigma\)</span>- 域，而且包含 <span class="math inline">\(X^{-1}(I^d)\)</span>，所以包含任何形如 <span class="math inline">\(\{X_i\leq t_i\}\)</span> 的集合，从而包含所有的<span class="math inline">\(\sigma(X_i)\)</span>，即包含 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span>。</p><p>另一方面 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span>在 <span class="math inline">\(X\)</span> 下的 push forward <span class="math inline">\(X(\sigma(X_1,\ldots,X_n))\)</span> 也是一个 <span class="math inline">\(\sigma\)</span>- 域，并且包含 <span class="math inline">\(I^d\)</span>，所以也就包含 <span class="math inline">\(\mathcal{B}(\mathbb{R}^d)\)</span>。</p><p>回到推论证明。我们首先对 <span class="math inline">\(Y=\mathbb{1}_{A},\,A\in\sigma(X_1,\ldots,X_n)\)</span>是指标函数的情形证明。由于 <span class="math inline">\(\sigma(X_1,\ldots,X_n)=X^{-1}(\mathcal{B}(\mathbb{R}^d)\)</span>，所以存在<span class="math inline">\(B\in\mathcal{B}(\mathbb{R}^d)\)</span> 使得<span class="math inline">\(A=X^{-1}(B)\)</span>。于是 <span class="math display">\[\mathbb{1}_{A}=\mathbb{1}_{X^{-1}(B)} =\mathbb{1}_{B}\circ X.\]</span> <span class="math inline">\(\mathbb{1}_B\)</span> 当然是 <span class="math inline">\(\mathcal{B}(\mathbb{R}^d)/\mathcal{B}\)</span>可测函数，所以结论成立。</p><p>由此很容易得出结论对任意简单函数都成立。</p><p>对一般的可测函数 <span class="math inline">\(Y\in\sigma(X_1,\ldots,X_d)\)</span>，取简单函数列<span class="math inline">\(\phi_n\toY,\,\phi_n\in\sigma(X_1,\ldots,X_d)\)</span>。根据上面的结论，存在可测函数<span class="math inline">\(f_n:\mathbb{R}^d\to\mathbb{R}\)</span> 使得<span class="math inline">\(\phi_n=f_n(X)\)</span>。记 <span class="math inline">\(f=\varlimsup f_n\)</span>，则有 <span class="math display">\[f(X)=\varlimsup f_n(X)=\varlimsup \phi_n =\lim\phi_n = Y.\]</span> 结论得证。</p><h1 id="monotone-convergence-theorem">8.2 Monotone convergencetheorem</h1><p>本讲给出了<strong>非负可测函数积分</strong>的定义：设 <span class="math inline">\(f\in L^+\)</span> 为非负可测函数，其积分定义为<span class="math display">\[\int f\,\mathrm{d}\mu=\sup\left\{\int\varphi\,\mathrm{d}\mu:\ \varphi\leq f,\ \varphi \text{simple and measuable}\right\}.\]</span></p><p>这个定义的问题在于不容易直接得出积分的可加性： <span class="math display">\[\int (f+g) \,\mathrm{d}\mu=\int f\,\mathrm{d}\mu+\int g\,\mathrm{d}\mu.\]</span></p><p>为此先证明了单调收敛定理：</p><blockquote><p><strong>单调收敛定理 (MCT)</strong>：若 <span class="math inline">\(\{f_n\}\in L^+\)</span> 且 <span class="math inline">\(f_n\uparrow f\)</span>，则 <span class="math inline">\(\int f_n\,\mathrm{d}\mu\uparrow \intf\,\mathrm{d}\mu\)</span>。</p></blockquote><p><strong>证明概要</strong>：显然 <span class="math inline">\(\lim\limits_{n\to\infty}\intf_n\,\mathrm{d}\mu\)</span> 存在且小于等于 <span class="math inline">\(\intf\,\mathrm{d}\mu\)</span>。为了证明二者相等，只要证明对任何简单函数<span class="math inline">\(\varphi\leq f\)</span> 有 <span class="math display">\[\lim_{n\to\infty} \int f_n\,\mathrm{d}\mu\geq\int \varphi\,\mathrm{d}\mu\]</span> 即可。<strong>不要指望通过分析集合<span class="math inline">\(\{f_n\geq \varphi\}\)</span>来得出结论</strong>，这完全可能对任何 <span class="math inline">\(n\)</span> 都是空集。但是如果可以证明对任何 <span class="math inline">\(0&lt;c&lt;1\)</span> 有 <span class="math display">\[\lim_{n\to\infty} \int f_n\,\mathrm{d}\mu\geq c\int \varphi\,\mathrm{d}\mu\]</span> 成立，那么令 <span class="math inline">\(c\uparrow1\)</span>即得结论（两边都是非负的）。而集合 <span class="math inline">\(E_n=\{f_n\geq c\varphi\}\)</span> 满足 <span class="math inline">\(E_n\uparrow\Omega\)</span>。于是由 <span class="math inline">\(f_n\geq c\varphi\mathbb{1}_{E_n}\)</span>以及积分单调性有 <span class="math display">\[\intf_n\,\mathrm{d}\mu\geqc\int\varphi\mathbb{1}_{E_n}\,\mathrm{d}\mu.\]</span> 由于 <span class="math inline">\(\varphi\)</span> 是简单函数，所以可设 <span class="math inline">\(\varphi = \sum_{k} a_k\mathbb{1}_{A_k}\)</span>并代入上面右边，有 <span class="math display">\[\intf_n\,\mathrm{d}\mu\geq c\int\varphi\mathbb{1}_{E_n}\,\mathrm{d}\mu=c\sum_{k}a_k\mu(A_k\cap E_n).\]</span> 令 <span class="math inline">\(n\to\infty\)</span> 并利用测度连续性 <span class="math inline">\(\mu(A_k\cap E_n)\uparrow\mu(A_k)\)</span> 即得<span class="math display">\[\lim_{n\to\infty} \intf_n\,\mathrm{d}\mu\geq c\sum_ka_k\mu(A_k)= c \int\varphi\,\mathrm{d}\mu.\]</span> 单调收敛定理得证。</p><p><strong>MCT告诉我们总是可以用一个只取有限多个值、每个值都有限的简单函数来逼近 <span class="math inline">\(f\)</span> 的积分</strong>。</p><p>非负可测函数 <span class="math inline">\(f\)</span>可以用简单函数序列 <span class="math display">\[\varphi_n =\sum_{k=1}^{2^{2n}}\frac{k-1}{2^n}\mathbb{1}_{\{\frac{k-1}{2^n}\leqf&lt;\frac{k}{2^n}\}} + 2^n\mathbb{1}_{\{f\geq 2^n\}}\]</span>来逼近。在第 <span class="math inline">\(n\)</span>次切割中，我们将切割范围扩大为原来的 2 倍以逼近 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\infty\)</span>的部分，同时将切割的间隔缩小为原来的 1/2 以保证逼近的误差是减小的。</p><h1 id="integrals-and-null-sets">9.1 Integrals and Null Sets</h1><p>本讲主要是论证积分的基本结论在 <span class="math inline">\(\mathrm{a.e.}\)</span>的情形下也都成立。此外介绍了非负可测函数列积分的 Fatou定理，它是上一讲中单调收敛定理的直接推论：</p><blockquote><p><strong>Fatou 定理</strong>：设 <span class="math inline">\(f_n\inL^+\)</span> 是非负可积函数列，则 <span class="math display">\[\int\liminf f_n\,\mathrm{d}\mu\leq \liminf \intf_n\,\mathrm{d}\mu.\]</span></p></blockquote><p>证明：设 <span class="math inline">\(g_n=\inf_{m\geqn}f_m\)</span>，则 <span class="math inline">\(g_n\leqf_m\)</span>，所以 <span class="math display">\[\intg_n\,\mathrm{d}\mu\leq\int f_m\,\mathrm{d}\mu,\quad n\leq m\]</span>从而 <span class="math inline">\(\int g_n\,\mathrm{d}\mu\leq\liminf\intf_m\,\mathrm{d}\mu\)</span>。 另一方面 <span class="math inline">\(g_n\uparrow\liminf f_n\)</span>，所以利用 MCT 有<span class="math display">\[\int\liminff_n\,\mathrm{d}\mu=\int\lim_{n\to\infty}g_n\,\mathrm{d}\mu=\lim_{n\to\infty}\intg_n\,\mathrm{d}\mu\leq\liminf\int f_m\,\mathrm{d}\mu.\]</span></p><hr><p>另一个重要结论是 Borel-Cantelli 引理：</p><blockquote><p><strong>Borel-Cantelli (Ⅰ)</strong>：如果 <span class="math inline">\(\sum_{n=0}^\infty\mu(A_n)&lt;\infty\)</span>，则<span class="math inline">\(\mu\{A_n,\ \mathrm{i.o.}\}=0\)</span>。</p></blockquote><p>这个用积分很容易看出来： <span class="math display">\[\sum_{n=0}^\infty\mu(A_n)=\int\sum_{n=0}^\infty\mathbb{1}_{A_n}\,\mathrm{d}\mu.\]</span>左边如果有限，那么右边的函数必须几乎处处有限，所以 <span class="math inline">\(\{A_n,\ \mathrm{i.o.}\}\)</span> 是零测集。</p><h1 id="l1-and-the-dct">9.2 L1 and the DCT</h1><p>本讲引入了一般可积函数的定义，并证明了控制收敛定理。</p><blockquote><p><strong>定义</strong>：称 <span class="math inline">\(f\inL^1(\Omega,\mathcal{F},\mathbb{P})\)</span> 为可积函数，如果 <span class="math inline">\(f^+,f^-\)</span> 都是可积的：<span class="math inline">\(\intf^{\pm}\,\mathrm{d}\mu&lt;\infty\)</span>。此时我们定义 <span class="math inline">\(\int f=\int f^+-\intf^-\)</span>。或者等价地，<span class="math inline">\(f\)</span>可积当且仅当 <span class="math inline">\(\int|f|\,\mathrm{d}\mu&lt;\infty\)</span>。</p></blockquote><p>对可积函数，积分是<strong>线性的</strong>、<strong>保持单调性的</strong>。</p><p>如果我们将几乎处处相等的函数看作是同一个函数的话，<span class="math inline">\(\|\cdot\|_{L^1}\)</span>是可积函数空间上的度量。</p><blockquote>  <meta charset="utf-8">  <meta name="generator" content="pandoc">  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">  <title>dummy</title>  <style>    html {      color: #1a1a1a;      background-color: #fdfdfd;    }    body {      margin: 0 auto;      max-width: 36em;      padding-left: 50px;      padding-right: 50px;      padding-top: 50px;      padding-bottom: 50px;      hyphens: auto;      overflow-wrap: break-word;      text-rendering: optimizeLegibility;      font-kerning: normal;    }    @media (max-width: 600px) {      body {        font-size: 0.9em;        padding: 12px;      }      h1 {        font-size: 1.8em;      }    }    @media print {      html {        background-color: white;      }      body {        background-color: transparent;        color: black;        font-size: 12pt;      }      p, h2, h3 {        orphans: 3;        widows: 3;      }      h2, h3, h4 {        page-break-after: avoid;      }    }    p {      margin: 1em 0;    }    a {      color: #1a1a1a;    }    a:visited {      color: #1a1a1a;    }    img {      max-width: 100%;    }    svg {      height: auto;      max-width: 100%;    }    h1, h2, h3, h4, h5, h6 {      margin-top: 1.4em;    }    h5, h6 {      font-size: 1em;      font-style: italic;    }    h6 {      font-weight: normal;    }    ol, ul {      padding-left: 1.7em;      margin-top: 1em;    }    li > ol, li > ul {      margin-top: 0;    }    blockquote {      margin: 1em 0 1em 1.7em;      padding-left: 1em;      border-left: 2px solid #e6e6e6;      color: #606060;    }    code {      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;      font-size: 85%;      margin: 0;      hyphens: manual;    }    pre {      margin: 1em 0;      overflow: auto;    }    pre code {      padding: 0;      overflow: visible;      overflow-wrap: normal;    }    .sourceCode {     background-color: transparent;     overflow: visible;    }    hr {      background-color: #1a1a1a;      border: none;      height: 1px;      margin: 1em 0;    }    table {      margin: 1em 0;      border-collapse: collapse;      width: 100%;      overflow-x: auto;      display: block;      font-variant-numeric: lining-nums tabular-nums;    }    table caption {      margin-bottom: 0.75em;    }    tbody {      margin-top: 0.5em;      border-top: 1px solid #1a1a1a;      border-bottom: 1px solid #1a1a1a;    }    th {      border-top: 1px solid #1a1a1a;      padding: 0.25em 0.5em 0.25em 0.5em;    }    td {      padding: 0.125em 0.5em 0.25em 0.5em;    }    header {      margin-bottom: 4em;      text-align: center;    }    #TOC li {      list-style: none;    }    #TOC ul {      padding-left: 1.3em;    }    #TOC > ul {      padding-left: 0;    }    #TOC a:not(:hover) {      text-decoration: none;    }    code{white-space: pre-wrap;}    span.smallcaps{font-variant: small-caps;}    div.columns{display: flex; gap: min(4vw, 1.5em);}    div.column{flex: auto; overflow-x: auto;}    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}    /* The extra [class] is a hack that increases specificity enough to       override a similar rule in reveal.js */    ul.task-list[class]{list-style: none;}    ul.task-list li input[type="checkbox"] {      font-size: inherit;      width: 0.8em;      margin: 0 0.8em 0.2em -1.6em;      vertical-align: middle;    }  </style>  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>  <!--[if lt IE 9]>    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>  <![endif]--><p><strong>控制收敛定理</strong>：设 <span class="math inline">\(f_n,g\)</span> 都是可积函数并且 <span class="math inline">\(|f_n|\leqg\)</span>，<span class="math inline">\(\lim\limits_{n\to\infty}f_n=f\)</span>。 则 <span class="math inline">\(f\)</span> 也是可积函数并且 <span class="math inline">\(\lim\limits_{n\to\infty}\int f_n=\intf\)</span>。</p></blockquote><p><strong>证明概要</strong>：显然 <span class="math inline">\(|f|\leqg\)</span>，所以 <span class="math inline">\(f\)</span>可积，从而由线性性质 <span class="math inline">\(g\pm f\)</span>都是可积的。对可积函数序列 <span class="math inline">\(g\pm f_n\)</span>使用 Fatou 引理，有 <span class="math display">\[\int (g\pmf)\,\mathrm{d}\mu=\int\varliminf_{n\to\infty} (g\pmf_n)\,\mathrm{d}\mu\leq \varliminf_{n\to\infty}\int (g\pmf_n)\,\mathrm{d}\mu= \int g\,\mathrm{d}\mu\pm\varliminf_{n\to\infty}\intf_n\,\mathrm{d}\mu.\]</span> 比较两边有 <span class="math display">\[\int (g\pm f)\,\mathrm{d}\mu\leq \intg\,\mathrm{d}\mu\pm \varliminf_{n\to\infty}\intf_n\,\mathrm{d}\mu.\]</span> 消去 <span class="math inline">\(g\)</span>的积分，并注意对任何实数列 <span class="math inline">\(\{a_n\}\)</span>有 <span class="math inline">\(\varliminf\limits_{n\to\infty}(-a_n)=-\varlimsup\limits_{n\to\infty}a_n\)</span>，从而 <span class="math display">\[\varlimsup\intf_n\,\mathrm{d}\mu\leq \int f\,\mathrm{d}\mu\leq \varliminf\intf_n\,\mathrm{d}\mu.\]</span> 即得结论。</p><h1 id="probability-laws-revisited">11.2 Probability Laws Revisited</h1><blockquote><p><strong>积分的变量替换定理</strong>：设 <span class="math inline">\(X:\(\Omega,\mathcal{F},\mu)\to(\mathcal{S},\mathcal{B})\)</span>是一个可测映射，<span class="math inline">\((\mathcal{S},\mathcal{B})\)</span> 上的测度 <span class="math inline">\(\nu\)</span> 由 <span class="math inline">\(\nu(E)= \mu(X^{-1}(E))\)</span> 给出，<span class="math inline">\(g:\(\mathcal{S},\mathcal{B},\nu)\to\mathbb{R}\)</span> 是一个可积函数，则<span class="math display">\[\int_{\Omega}g\circX\,\mathrm{d}\mu=\int_{\mathcal{S}}g\,\mathrm{d}\nu.\]</span></p></blockquote><p><strong>证明概要</strong>：首先考察 <span class="math inline">\(g=\mathbb{1}_B,\,B\in\mathcal{B}\)</span>是指标函数的情形。 <span class="math display">\[\int_{\mathcal{S}}g\,\mathrm{d}\nu= \nu(B) =\mu(X^{-1}(B))=\int_{\Omega}\mathbb{1}_{X^{-1}(B)}\,\mathrm{d}\mu.\]</span>由于 <span class="math inline">\(\omega\in X^{-1}(B)\LeftrightarrowX(\omega)\in B\)</span>，所以 <span class="math inline">\(\mathbb{1}_{X^{-1}(B)} = \mathbb{1}_{B}\circX\)</span>，所以上式右边的积分等于 <span class="math display">\[\int_{\Omega}\mathbb{1}_{B}\circX\,\mathrm{d}\nu.\]</span>此时结论成立。根据积分的线性性质结论对简单函数也成立，从而进一步取极限可得对任何可积函数<span class="math inline">\(g\)</span> 都成立。</p><h1 id="convergence-in-measure">13.1 Convergence in measure</h1><p>本讲介绍了可测函数的依测度收敛概念，及其与逐点收敛之间的联系。</p><blockquote>  <meta charset="utf-8">  <meta name="generator" content="pandoc">  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">  <title>dummy</title>  <style>    html {      color: #1a1a1a;      background-color: #fdfdfd;    }    body {      margin: 0 auto;      max-width: 36em;      padding-left: 50px;      padding-right: 50px;      padding-top: 50px;      padding-bottom: 50px;      hyphens: auto;      overflow-wrap: break-word;      text-rendering: optimizeLegibility;      font-kerning: normal;    }    @media (max-width: 600px) {      body {        font-size: 0.9em;        padding: 12px;      }      h1 {        font-size: 1.8em;      }    }    @media print {      html {        background-color: white;      }      body {        background-color: transparent;        color: black;        font-size: 12pt;      }      p, h2, h3 {        orphans: 3;        widows: 3;      }      h2, h3, h4 {        page-break-after: avoid;      }    }    p {      margin: 1em 0;    }    a {      color: #1a1a1a;    }    a:visited {      color: #1a1a1a;    }    img {      max-width: 100%;    }    svg {      height: auto;      max-width: 100%;    }    h1, h2, h3, h4, h5, h6 {      margin-top: 1.4em;    }    h5, h6 {      font-size: 1em;      font-style: italic;    }    h6 {      font-weight: normal;    }    ol, ul {      padding-left: 1.7em;      margin-top: 1em;    }    li > ol, li > ul {      margin-top: 0;    }    blockquote {      margin: 1em 0 1em 1.7em;      padding-left: 1em;      border-left: 2px solid #e6e6e6;      color: #606060;    }    code {      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;      font-size: 85%;      margin: 0;      hyphens: manual;    }    pre {      margin: 1em 0;      overflow: auto;    }    pre code {      padding: 0;      overflow: visible;      overflow-wrap: normal;    }    .sourceCode {     background-color: transparent;     overflow: visible;    }    hr {      background-color: #1a1a1a;      border: none;      height: 1px;      margin: 1em 0;    }    table {      margin: 1em 0;      border-collapse: collapse;      width: 100%;      overflow-x: auto;      display: block;      font-variant-numeric: lining-nums tabular-nums;    }    table caption {      margin-bottom: 0.75em;    }    tbody {      margin-top: 0.5em;      border-top: 1px solid #1a1a1a;      border-bottom: 1px solid #1a1a1a;    }    th {      border-top: 1px solid #1a1a1a;      padding: 0.25em 0.5em 0.25em 0.5em;    }    td {      padding: 0.125em 0.5em 0.25em 0.5em;    }    header {      margin-bottom: 4em;      text-align: center;    }    #TOC li {      list-style: none;    }    #TOC ul {      padding-left: 1.3em;    }    #TOC > ul {      padding-left: 0;    }    #TOC a:not(:hover) {      text-decoration: none;    }    code{white-space: pre-wrap;}    span.smallcaps{font-variant: small-caps;}    div.columns{display: flex; gap: min(4vw, 1.5em);}    div.column{flex: auto; overflow-x: auto;}    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}    /* The extra [class] is a hack that increases specificity enough to       override a similar rule in reveal.js */    ul.task-list[class]{list-style: none;}    ul.task-list li input[type="checkbox"] {      font-size: inherit;      width: 0.8em;      margin: 0 0.8em 0.2em -1.6em;      vertical-align: middle;    }  </style>  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>  <!--[if lt IE 9]>    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>  <![endif]--><p><strong>定义</strong>：称 <span class="math inline">\(f_n\to_{\mu}f\)</span> 为依测度收敛，如果对任意 <span class="math inline">\(\epsilon&gt;0\)</span> 有 <span class="math display">\[\lim_{n\to\infty}\mu\{|f_n-f|\geq0\}=0.\]</span></p></blockquote><p><strong>依测度收敛但不处处收敛的例子</strong>：将区间 <span class="math inline">\([0, 1]\)</span> 等分为 <span class="math inline">\(2^n\)</span>份，将它们的指标函数排成一排，再对所有 <span class="math inline">\(n\)</span> 将这些片段排列起来得到序列 <span class="math inline">\(f_n\)</span>，则 <span class="math inline">\(f_n\)</span> 依测度收敛到 0 但不逐点收敛。</p><p><strong>接下来是一个将测度和逐点收敛联系起来的重要技巧</strong>：根据几乎处处收敛的定义，<span class="math inline">\(f_n\to f,\mathrm{a.e.}\)</span> 收敛即要求对任何<span class="math inline">\(\epsilon&gt;0\)</span> 有 <span class="math display">\[\mu\{|f_n-f|\geq\epsilon,\ \mathrm{i.o.}\} =0.\]</span>这样就可以把逐点收敛和测度联系起来。有时候我们还可以使用更强的条件：<span class="math display">\[\mu\{|f_n-f|\geq 2^{-n},\ \mathrm{i.o.}\} =0.\]</span> 这是因为对任何 <span class="math inline">\(\epsilon\)</span>，<span class="math inline">\(n\)</span> 足够大时 <span class="math inline">\(2^{-n}&lt;\epsilon\)</span>, 从而 <span class="math inline">\(\{|f_n-f|\geq\epsilon\}\subseteq\{|f_n-f|\geq2^{-n}\}\)</span>，前者发生无穷多次自然意味着后者也发生无穷多次。这样就可以和Borel-Cantelli 引理结合起来使用，只要 <span class="math display">\[\sum_{n}\mu\{|f_n - f|\geq 2^{-n}\} &lt;\infty,\]</span> 就可以保证 <span class="math inline">\(\{f_n\}\)</span>是几乎处处收敛的。</p><blockquote>  <meta charset="utf-8">  <meta name="generator" content="pandoc">  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">  <title>dummy</title>  <style>    html {      color: #1a1a1a;      background-color: #fdfdfd;    }    body {      margin: 0 auto;      max-width: 36em;      padding-left: 50px;      padding-right: 50px;      padding-top: 50px;      padding-bottom: 50px;      hyphens: auto;      overflow-wrap: break-word;      text-rendering: optimizeLegibility;      font-kerning: normal;    }    @media (max-width: 600px) {      body {        font-size: 0.9em;        padding: 12px;      }      h1 {        font-size: 1.8em;      }    }    @media print {      html {        background-color: white;      }      body {        background-color: transparent;        color: black;        font-size: 12pt;      }      p, h2, h3 {        orphans: 3;        widows: 3;      }      h2, h3, h4 {        page-break-after: avoid;      }    }    p {      margin: 1em 0;    }    a {      color: #1a1a1a;    }    a:visited {      color: #1a1a1a;    }    img {      max-width: 100%;    }    svg {      height: auto;      max-width: 100%;    }    h1, h2, h3, h4, h5, h6 {      margin-top: 1.4em;    }    h5, h6 {      font-size: 1em;      font-style: italic;    }    h6 {      font-weight: normal;    }    ol, ul {      padding-left: 1.7em;      margin-top: 1em;    }    li > ol, li > ul {      margin-top: 0;    }    blockquote {      margin: 1em 0 1em 1.7em;      padding-left: 1em;      border-left: 2px solid #e6e6e6;      color: #606060;    }    code {      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;      font-size: 85%;      margin: 0;      hyphens: manual;    }    pre {      margin: 1em 0;      overflow: auto;    }    pre code {      padding: 0;      overflow: visible;      overflow-wrap: normal;    }    .sourceCode {     background-color: transparent;     overflow: visible;    }    hr {      background-color: #1a1a1a;      border: none;      height: 1px;      margin: 1em 0;    }    table {      margin: 1em 0;      border-collapse: collapse;      width: 100%;      overflow-x: auto;      display: block;      font-variant-numeric: lining-nums tabular-nums;    }    table caption {      margin-bottom: 0.75em;    }    tbody {      margin-top: 0.5em;      border-top: 1px solid #1a1a1a;      border-bottom: 1px solid #1a1a1a;    }    th {      border-top: 1px solid #1a1a1a;      padding: 0.25em 0.5em 0.25em 0.5em;    }    td {      padding: 0.125em 0.5em 0.25em 0.5em;    }    header {      margin-bottom: 4em;      text-align: center;    }    #TOC li {      list-style: none;    }    #TOC ul {      padding-left: 1.3em;    }    #TOC > ul {      padding-left: 0;    }    #TOC a:not(:hover) {      text-decoration: none;    }    code{white-space: pre-wrap;}    span.smallcaps{font-variant: small-caps;}    div.columns{display: flex; gap: min(4vw, 1.5em);}    div.column{flex: auto; overflow-x: auto;}    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}    /* The extra [class] is a hack that increases specificity enough to       override a similar rule in reveal.js */    ul.task-list[class]{list-style: none;}    ul.task-list li input[type="checkbox"] {      font-size: inherit;      width: 0.8em;      margin: 0 0.8em 0.2em -1.6em;      vertical-align: middle;    }  </style>  <!--[if lt IE 9]>    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>  <![endif]--><p><strong>定理</strong>：逐点收敛可以推出依测度收敛。</p></blockquote><p><strong>简要证明</strong>：对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，记 <span class="math inline">\(A_n=\{|f_n-f|\geq\epsilon\}\)</span>，则 <span class="math display">\[\mu\{A_n,\ \mathrm{i.o.}\} =\lim_{n\to\infty}\mu(\bigcup_{k\geq n}A_k)\geq\lim_{n\to\infty}\mu(A_n).\]</span></p><blockquote>  <meta charset="utf-8">  <meta name="generator" content="pandoc">  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">  <title>dummy</title>  <style>    html {      color: #1a1a1a;      background-color: #fdfdfd;    }    body {      margin: 0 auto;      max-width: 36em;      padding-left: 50px;      padding-right: 50px;      padding-top: 50px;      padding-bottom: 50px;      hyphens: auto;      overflow-wrap: break-word;      text-rendering: optimizeLegibility;      font-kerning: normal;    }    @media (max-width: 600px) {      body {        font-size: 0.9em;        padding: 12px;      }      h1 {        font-size: 1.8em;      }    }    @media print {      html {        background-color: white;      }      body {        background-color: transparent;        color: black;        font-size: 12pt;      }      p, h2, h3 {        orphans: 3;        widows: 3;      }      h2, h3, h4 {        page-break-after: avoid;      }    }    p {      margin: 1em 0;    }    a {      color: #1a1a1a;    }    a:visited {      color: #1a1a1a;    }    img {      max-width: 100%;    }    svg {      height: auto;      max-width: 100%;    }    h1, h2, h3, h4, h5, h6 {      margin-top: 1.4em;    }    h5, h6 {      font-size: 1em;      font-style: italic;    }    h6 {      font-weight: normal;    }    ol, ul {      padding-left: 1.7em;      margin-top: 1em;    }    li > ol, li > ul {      margin-top: 0;    }    blockquote {      margin: 1em 0 1em 1.7em;      padding-left: 1em;      border-left: 2px solid #e6e6e6;      color: #606060;    }    code {      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;      font-size: 85%;      margin: 0;      hyphens: manual;    }    pre {      margin: 1em 0;      overflow: auto;    }    pre code {      padding: 0;      overflow: visible;      overflow-wrap: normal;    }    .sourceCode {     background-color: transparent;     overflow: visible;    }    hr {      background-color: #1a1a1a;      border: none;      height: 1px;      margin: 1em 0;    }    table {      margin: 1em 0;      border-collapse: collapse;      width: 100%;      overflow-x: auto;      display: block;      font-variant-numeric: lining-nums tabular-nums;    }    table caption {      margin-bottom: 0.75em;    }    tbody {      margin-top: 0.5em;      border-top: 1px solid #1a1a1a;      border-bottom: 1px solid #1a1a1a;    }    th {      border-top: 1px solid #1a1a1a;      padding: 0.25em 0.5em 0.25em 0.5em;    }    td {      padding: 0.125em 0.5em 0.25em 0.5em;    }    header {      margin-bottom: 4em;      text-align: center;    }    #TOC li {      list-style: none;    }    #TOC ul {      padding-left: 1.3em;    }    #TOC > ul {      padding-left: 0;    }    #TOC a:not(:hover) {      text-decoration: none;    }    code{white-space: pre-wrap;}    span.smallcaps{font-variant: small-caps;}    div.columns{display: flex; gap: min(4vw, 1.5em);}    div.column{flex: auto; overflow-x: auto;}    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}    /* The extra [class] is a hack that increases specificity enough to       override a similar rule in reveal.js */    ul.task-list[class]{list-style: none;}    ul.task-list li input[type="checkbox"] {      font-size: inherit;      width: 0.8em;      margin: 0 0.8em 0.2em -1.6em;      vertical-align: middle;    }  </style>  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>  <!--[if lt IE 9]>    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>  <![endif]--><p><strong>定理</strong>：设 <span class="math inline">\(\{f_n\}\)</span> 为依测度收敛的 Cauchy 序列：<span class="math display">\[\lim_{n,m\to\infty}\mu\{|f_n-f_m|\geq\epsilon\} =0.\]</span> 则 <span class="math inline">\(f_n\)</span>必有逐点收敛的子序列 <span class="math inline">\(f_{n_k}\to f\\mathrm{a.e.}\)</span>，并且 <span class="math inline">\(f_n\)</span>依测度收敛到 <span class="math inline">\(f\)</span>。</p></blockquote><p><strong>简要证明必有逐点收敛的子序列</strong>：利用上面介绍的技巧，归结为抽取子序列<span class="math inline">\(\{f_{n_k}\}\)</span> 满足 <span class="math display">\[\mu\{|f_{n_{k+1}} - f_{n_k}|\geq2^{-k},\\mathrm{i.o.}\} = 0.\]</span> 利用 Borel-Cantelli 引理这只要让 <span class="math inline">\(\sum_{k=1}^\infty\mu\{|f_{n_{k+1}} - f_{n_k}|\geq2^{-k}\}&lt;\infty\)</span> 即可。为此又只要让 <span class="math inline">\(\mu\{|f_{n_{k+1}} - f_{n_k}|\geq 2^{-k}\}\leq2^{-k}\)</span> 即可。根据 Cauchy 条件这是可以做到的。</p><p><strong>简要证明这个子序列的逐点极限是原序列的依测度极限</strong>：对任何<span class="math inline">\(n\)</span>，取 <span class="math inline">\(n_{k}&gt;n\)</span> 则有 <span class="math display">\[\{|f_n-f|\geq\epsilon\}\subseteq\{|f_n-f_{n_k}|\geq\epsilon/2\}\cup\{|f_{n_k}-f|\geq\epsilon/2\}.\]</span> 显然 <span class="math inline">\(n\)</span> 足够大时右边两个集合测度都趋于 0。</p><h1 id="lp-is-complete">13.2 <span class="math inline">\(L^p\)</span> isComplete</h1><p>首先我们来证明 <span class="math inline">\(L^p\)</span>收敛可以推出依测度收敛。</p><blockquote><p><strong>定理</strong>：<span class="math inline">\(L^p\)</span>度量是完备的，任何 Cauchy 序列必有极限。</p></blockquote><p><strong>证明概要</strong>：<span class="math inline">\(L^p\)</span>Cauchy 列也都是依测度 Cauchy 列，从而有几乎处处收敛的子序列 <span class="math inline">\(f_{n_k}\to f\)</span>。对固定的 <span class="math inline">\(k\)</span>，当 <span class="math inline">\(j&gt;k\)</span> 时有 <span class="math display">\[\begin{align*}\int\|f_{n_k}-f\|^p\,\mathrm{d}\mu&amp;=\int\lim_{j\to\infty}\|f_{n_k}-f_{n_j}\|^p\,\mathrm{d}\mu\leq\liminf_{j\to\infty}\int\|f_{n_k}-f_{n_j}\|^p\,\mathrm{d}\mu\\&amp;\leq\limsup_{j\to\infty}\int\|f_{n_k}-f_{n_j}\|^p\,\mathrm{d}\mu.\end{align*}\]</span>两边令 <span class="math inline">\(k\to\infty\)</span> 并利用 Cauchy条件即得子序列 <span class="math inline">\(f_{n_k}\xrightarrow{L^p}f\)</span>。再利用 Cauchy条件可得原序列 <span class="math inline">\(f_n\xrightarrow{L^p}f\)</span>。</p><blockquote><p><strong>依测度控制收敛定理</strong>：设 <span class="math inline">\(f_n\)</span> 依测度收敛到 <span class="math inline">\(f\)</span>，且 <span class="math inline">\(|f_n|\leq f,\, f\in L^1\)</span>。则 <span class="math inline">\(f_n\xrightarrow{L^1} f\)</span>。</p></blockquote><p><strong>证明概要</strong>：假设 <span class="math inline">\(f_n\)</span> 不 <span class="math inline">\(L^1\)</span> 收敛到 <span class="math inline">\(f\)</span>，则对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，存在子序列 <span class="math inline">\(f_{n_k}\)</span> 满足：</p><ul><li><span class="math inline">\(\|f_{n_k} -f\|_{L^1}\geq\epsilon\)</span>。</li><li><span class="math inline">\(f_{n_k}\)</span> 几乎处处收敛到 <span class="math inline">\(f\)</span>。</li></ul><p>这与控制收敛定理矛盾。</p><h1 id="independence">15.1 Independence</h1><p>本讲介绍了事件和 <span class="math inline">\(\sigma\)</span>-域之间的独立性概念。</p><p>要点总结：</p><ol type="1"><li>若干个事件 <span class="math inline">\(\{A_n\}\)</span>独立不是指它们两两独立，而是其中任何有限多个子事件都独立。</li><li>验证若干 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\{\mathcal{F}_i\}\)</span>独立只需要验证生成它们的 <span class="math inline">\(\pi\)</span>- 系<span class="math inline">\(\{C_i:\ \mathcal{F}_i=\sigma(C_i)\}\)</span>独立。</li></ol><blockquote><p><strong>Borel-Cantelli 引理 II</strong>：设 <span class="math inline">\(\{A_n\}\)</span> 是独立的事件列，则若 <span class="math inline">\(\sum_{n=1}^\infty\mathbb{P}(A_n)=\infty\)</span>，则<span class="math inline">\(\mathbb{P}(\{A_n,\mathrm{i.o.}\})=1\)</span>。</p></blockquote><p>想法还是要用独立性，转到事件的交上去。</p><p><span class="math display">\[\mathbb{P}(\{A_n,\\mathrm{i.o.}\})=\mathbb{P}(\bigcap_{n=1}^\infty\bigcup_{k\geqn}A_k)=\lim_{n\to\infty}\mathbb{P}(\bigcup_{k\geq n}A_k).\]</span>观察两边，要想用上独立性，就得取补： <span class="math display">\[1-\mathbb{P}(\bigcup_{k\geqn}A_k)=\mathbb{P}(\bigcap_{k\geqn}A_k^c)=\lim_{M\to\infty}\prod_{k=n}^M\mathbb{P}(A_k^c)=\lim_{M\to\inftyy}\prod_{k=n}^M(1-\mathbb{P}(A_k)).\]</span> 利用 <span class="math inline">\(1-x\leq e^{-x}\)</span> 有 <span class="math display">\[\lim_{M\to\infty}\prod_{k=n}^M(1-\mathbb{P}(A_k))\leq\lim_{M\to\infty}\prod_{k=n}^Me^{-\mathbb{P}(A_k)}=\lim_{M\to\infty}e^{-\sum_{k=n}^M\mathbb{P}(A_k)}.\]</span>上式右边对任何固定的 <span class="math inline">\(n\)</span> 其极限都是0，从而 <span class="math inline">\(\mathbb{P}(\bigcup_{k\geqn}A_k)\to1\)</span>，结论得证。</p><h1 id="independent-random-variables">15.2 Independent RandomVariables</h1><p>上一讲介绍了独立事件和独立事件域的概念，这一讲介绍了独立随机变量的概念。</p><blockquote><p><strong>定义</strong>：一族随机变量 <span class="math inline">\(\{X_i\}_{i\in I}\)</span> 称作是独立的，如果它们的<span class="math inline">\(\sigma-\)</span> 域 <span class="math inline">\(\{\sigma(X_i)\}_{i\in I}\)</span> 是独立的。</p></blockquote><p>由于 <span class="math inline">\(\sigma(X_i)\)</span> 可以由 <span class="math inline">\(\pi-\)</span> 系 <span class="math inline">\(\{X_i\in(-\infty, t_i]\}\)</span>生成，所以只要验证这个 <span class="math inline">\(\pi-\)</span>系的独立性即可。</p><blockquote><p><strong>定理</strong>：设 <span class="math inline">\(X=(X_1,\ldots,X_n)\)</span>，其中每个 <span class="math inline">\(X_i:(\Omega,\mathcal{F},\mathbb{P})\to(\mathcal{S}_i,\mathcal{B}_i)\)</span>是随机变量，<span class="math inline">\(\mu_X\)</span> 是 <span class="math inline">\(\mathcal{B}_1\otimes\cdots\otimes\mathcal{B}_n\)</span>上的测度: <span class="math inline">\(\mu_X(B)=\mathbb{P}(X\inB)\)</span>。则 <span class="math inline">\(X_1,X_2,\ldots,X_n\)</span>独立当且仅当 <span class="math inline">\(\mu_X=\mu_{X_1}\otimes\cdots\otimes\mu_{X_n}\)</span>。</p></blockquote><p>证明：<span class="math inline">\(\Leftarrow\)</span>:</p><p><span class="math display">\[\begin{align*}\mathbb{P}(X_1\inB_1,\ldots,X_n\in B_n)&amp;=\mu_X(B_1\times \cdots\times B_n)\\&amp;=\mu_{X_1}(B_1)\cdots\mu_{X_n}(B_n)\\&amp;=\mathbb{P}(X_1\in B_1)\cdots\mathbb{P}(X_n\inB_n).\end{align*}\]</span></p><p><span class="math inline">\(\Rightarrow\)</span>: 简单。</p><blockquote><p><strong>推论</strong>：如果 <span class="math inline">\(X_1,X_2,\ldots,X_n\)</span> 都是 <span class="math inline">\(L^1\)</span> 可积的随机变量，则 <span class="math inline">\(X_1X_2\cdots X_n\in L^1\)</span> 且 <span class="math inline">\(\mathbb{E}[X_1\cdotsX_n]=\mathbb{E}[X_1]\cdots\mathbb{E}[X_n]\)</span>。</p></blockquote><p>首先对 <span class="math inline">\(|X_1X_2\cdots X_n|\)</span> 用Tonelli 定理得出 <span class="math inline">\(|X_1X_2\cdots X_n|\)</span>可积，然后再对 <span class="math inline">\(X_1X_2\cdots X_n\)</span> 用Fubini 定理。</p><blockquote><p><strong>推论</strong>：如果 <span class="math inline">\(X_1,\ldots,X_n,Y_1,\ldots,Y_m\)</span>是一组独立的随机变量，则 <span class="math inline">\(f(X_1,\ldots,X_n)\)</span> 和 <span class="math inline">\(g(Y_1,\ldots,Y_m)\)</span> 也是独立的。</p></blockquote><p>这是因为 <span class="math inline">\(\sigma(f(X_1,\ldots,X_n))\subseteq\sigma(X_1,\ldots,X_n)\)</span>，<span class="math inline">\(\sigma(g(Y_1,\ldots,Y_m))\subseteq\sigma(Y_1,\ldots,Y_m)\)</span>，所以也是独立的。</p><h1 id="kolmogorovs-extension-theorem">16.1/16.2 Kolmogorov’s ExtensionTheorem</h1><p>这两讲的目的是介绍 Kolmogorov扩张定理，即构造无穷乘积可测空间使得其有限维分布为给定的、满足相容性条件的有限维分布。</p><p>Kolmogorov扩张定理看起来是一个纯测度论定理，但它本质与空间的拓扑性质有关。</p><p>设 <span class="math inline">\(I\)</span> 是指标集，<span class="math inline">\(\{\mathcal{A}_i,\, i\in I\}\)</span>是某个样本空间 <span class="math inline">\(\Omega\)</span> 的一族子<span class="math inline">\(\sigma-\)</span> 代数（每个 <span class="math inline">\(\mathcal{A}_i\)</span> 都是一个 <span class="math inline">\(\sigma-\)</span> 代数），满足条件：对任何两个<span class="math inline">\(\sigma-\)</span> 代数 <span class="math inline">\(\mathcal{A}_\alpha,\mathcal{A}_\beta\)</span>，都存在<span class="math inline">\(\mathcal{A}_\gamma\)</span> （<span class="math inline">\(\mathcal{A}_\gamma\)</span> 未必唯一）使得 <span class="math inline">\(\mathcal{A}_\alpha\subset\mathcal{A}_\gamma,\,\mathcal{A}_\beta\subset\mathcal{A}_\gamma\)</span>。</p><p>设 <span class="math inline">\(\mathbb{P}_i\)</span> 是 <span class="math inline">\(\mathcal{A}_i\)</span> 上的概率测度，如果对任何<span class="math inline">\(\mathcal{A}_\alpha\subset\mathcal{A}_\gamma\)</span>还有 <span class="math display">\[\mathbb{P}_\gamma \big|_{A_\alpha} =\mathbb{P}_\alpha.\]</span> 这时我们就称概率空间 <span class="math inline">\(\{(\mathcal{A}_i,\mathbb{P}_i)\}\)</span><strong>满足 Kolmogorov 相容性条件</strong>。</p><p>这就自然地引出一个问题：是否存在代数 <span class="math inline">\(\mathcal{A}=\cup_{i\in I}\mathcal{A}_i\)</span>上存在一个可数可加的概率测度 <span class="math inline">\(\mathbb{P}\)</span>，使得它是所有 <span class="math inline">\(\mathbb{P}_i\)</span> 的扩张？即对任何 <span class="math inline">\(\mathcal{A}_i\)</span> 都有 <span class="math inline">\(\mathbb{P}\big|_{\mathcal{A}_i}=\mathbb{P}_i\)</span>？如果有这样的 <span class="math inline">\(\mathbb{P}\)</span>，我们就可以用 Carathéodory定理将 <span class="math inline">\(\mathbb{P}\)</span> 扩张为 <span class="math inline">\(\sigma(\mathcal{A})\)</span>上的可数可加测度。</p><p>基本逻辑是：</p><ol type="1"><li>根据 Carathéodory 测度扩张定，我们只要证明代数 <span class="math inline">\(\mathcal{A}=\cup_{n=1}^\infty\mathcal{B}_n\)</span>上的有限可加测度是可数可加的。这里 <span class="math display">\[\mathcal{B}_n=\mathcal{B}([0,1])^n\times Q,\quadQ=[0,1]^{\infty}.\]</span> 而这只要证明测度的连续性：若 <span class="math inline">\(B_n\in\mathcal{A}, B_n\downarrow\)</span> 且 <span class="math inline">\(\inf_n\mathbb{P}(B_n)=\epsilon&gt;0\)</span>，则<span class="math inline">\(\cap B_n\ne\emptyset\)</span>。</li><li>我们可以不妨假设 <span class="math inline">\(B_n\in\mathcal{B}_n\)</span>。这可以通过拉伸整个序列，在缝隙中塞上<span class="math inline">\(\Omega_k\)</span> 或者 <span class="math inline">\(B_k\)</span> 来得到。</li><li>我们可以取紧集 <span class="math inline">\(K_n\in B_n\)</span> 使得<span class="math inline">\(\mu(B_n\backslashK_n)&lt;\epsilon/2^n\)</span>，然后证明对任何 <span class="math inline">\(N\)</span>，<span class="math inline">\(\cap_{n=1}^NK_n\)</span> 非空，然后利用 <span class="math inline">\(Q\)</span> 的紧性，和紧集的有限交性质，证明 <span class="math inline">\(\cap_{n=1}^\infty K_n\)</span> 非空，从而 <span class="math inline">\(\cap_{n=1}^\infty B_n\)</span> 非空。</li><li>在上一步中，可以取这样的紧集 <span class="math inline">\(K_n\)</span> 要用到 <span class="math inline">\(R^d\)</span> 上的概率测度是 Radon测度这一性质：它们同时被开集从外部逼近和紧集从内部逼近。<span class="math inline">\(Q\)</span> 的紧性是用了 Tychonoff 定理。</li></ol><blockquote><p><strong>引理</strong>：<span class="math inline">\(K\)</span></p></blockquote><h1 id="kolmogorovs-0-1-law">17.1 Kolmogorov’s 0-1 Law</h1><p>本讲介绍了独立随机变量序列的尾事件，以及 Kolmogrov 0-1 律。</p><p>设 <span class="math inline">\(\{X_n\}\)</span> 是独立的随机变量序列(不是两两独立，而是任何有限多个都独立)称 <span class="math inline">\(\mathcal{T}=\cap_{n=1}^\infty\sigma(X_n,X_{n+1},\ldots)\)</span>为尾事件域。</p><blockquote><p><strong>Kolmogrov 0-1 律</strong>：对任何 <span class="math inline">\(A\in\mathcal{T}\)</span> 有 <span class="math inline">\(\mathbb{P}(A)\in\{0,1\}\)</span>。</p></blockquote><p><strong>证明概要</strong>：</p><ul><li><span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span> 和 <span class="math inline">\(\sigma(X_{n+1},X_{n+2},\ldots)\)</span>是独立的。因为考虑如下两个集合族： <span class="math display">\[\{\text{all finite intersections like }\cap A_i,A_i\in\sigma(X_i),i=1,2,\ldots,n\}.\]</span> <span class="math display">\[\{\text{all finite intersections like }\cap A_j,A_j\in\sigma(X_j),j=n+1,n+2,\ldots\}.\]</span> 这俩都是 <span class="math inline">\(\pi\)</span>- 系且互相独立，所以它们生成的 <span class="math inline">\(\sigma\)</span>- 域也独立。前者可以生成 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span>，后者可以生成<span class="math inline">\(\sigma(X_{n+1},X_{n+2},\ldots)\)</span>。</li><li>于是 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span> 和<span class="math inline">\(\mathcal{T}\)</span> 是独立的。</li><li>于是 <span class="math inline">\(\pi\)</span>- 系 <span class="math inline">\(\cup_{n=1}^\infty\sigma(X_1,\ldots,X_n)\)</span>和 <span class="math inline">\(\mathcal{T}\)</span> 是独立的。</li><li>于是 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\sigma(X_1,\ldots,X_n,\ldots)\)</span> 和 <span class="math inline">\(\mathcal{T}\)</span> 独立，从而 <span class="math inline">\(\mathcal{T}\)</span> 和 <span class="math inline">\(\mathcal{T}\)</span> 独立，从而得证。</li></ul><h1 id="uniform-integrability">48.1 Uniform Integrability</h1><p>这一讲介绍了随机变量集合的一致可积性，要点非常多。</p><p>对任何 <span class="math inline">\(L^1\)</span> 的随机变量 <span class="math inline">\(X\)</span>，总是可以找一个紧集 <span class="math inline">\(K\)</span>，使得 <span class="math inline">\(|X|\)</span> 在 <span class="math inline">\(K^c\)</span> 上的积分任意小：对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，存在 <span class="math inline">\(a&gt;0\)</span> 使得 <span class="math inline">\(\mathbb{E}[|X|:\ |X|\geqa]&lt;\epsilon\)</span>。但是如果是一族可积的随机变量的话，这个统一的<span class="math inline">\(a\)</span> 就未必存在了。</p><p>如果这样的 <span class="math inline">\(a\)</span>总是存在的话，我们就称这族随机变量是一致可积的。</p><blockquote><p><strong>定义</strong>：随机变量列 <span class="math inline">\(\{X_n\}\)</span> 称作是一致可积的 (UI)的，如果它们满足以下条件：</p><ol type="1"><li>每个 <span class="math inline">\(X_i\)</span> 都是 <span class="math inline">\(L^1\)</span> 的。</li><li>对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，存在<span class="math inline">\(a&gt;0\)</span> 使得 <span class="math inline">\(\sup_n\mathbb{E}[X_n:\ |X_n|\geq a]&lt;\epsilon\)</span>。</li></ol></blockquote><p>不难验证如果 <span class="math inline">\(\{X_n\}\)</span>被一个可积随机变量控制，则它们是一致可积的：</p><blockquote><p><strong>例子 1</strong>：如果 <span class="math inline">\(|X_n|\leqY,\ Y\in L^1\)</span>，则 <span class="math inline">\(\{X_n\}\)</span>是一致可积的。</p></blockquote><p>这是因为被积函数和积分区域都可以放大：<span class="math inline">\(\mathbb{E}[|X_n|:\ |X_n|\geqa]\leq\mathbb{E}[|Y|:\ |Y|\geq a]\)</span>。</p><blockquote><p><strong>例子 2</strong>：如果 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(L^p,\,p&gt;1\)</span> 一致有界的：<span class="math inline">\(\sup_n\mathbb{E}|X_n|^p&lt;\infty\)</span>，则<span class="math inline">\(\{X_n\}\)</span> 是一致可积的。</p></blockquote><p>这是因为被积函数可以放大： <span class="math display">\[\mathbb{E}[|X|: |X|\geq a]\leq\mathbb{E}[|X|\cdot\frac{|X|^{p-1}}{a^{p-1}}: |X|\geq a] =\frac{1}{a^{p-1}}\mathbb{E}[|X|^p: |X|\geq a]\leq\frac{M}{a^{p-1}}.\]</span></p><p>这个例子中的 <span class="math inline">\(p&gt;1\)</span> 是不能减弱为<span class="math inline">\(p\geq1\)</span> 的。不过我们可以证明 UI的变量族必然是 <span class="math inline">\(L^1\)</span> 一致有界的：</p><blockquote><p><strong>定理</strong>：若 <span class="math inline">\(\{X_n\}\)</span> 一致可积，则 <span class="math inline">\(\sup_n E|X_n| &lt;\infty\)</span>。</p></blockquote><p>取 <span class="math inline">\(a\)</span> 使得 <span class="math inline">\(\sup_n \mathbb{E}[|X_n|: |X_n|\geq a] &lt;1\)</span>，则不难证明 <span class="math inline">\(\mathbb{E}|X_n| &lt;a+1\)</span>。</p><p>现在我们来给出一致绝对连续的概念，并将说明<strong>一致可积 = <span class="math inline">\(L^1\)</span> 一致有界 +一致绝对连续</strong>。</p><blockquote><p><strong>定义</strong>：随机变量序列 <span class="math inline">\(\{X_n\}\)</span> 是一致绝对连续的，如果对任何<span class="math inline">\(\epsilon&gt;0\)</span>，都存在 <span class="math inline">\(\delta&gt;0\)</span>，使得只要集合 <span class="math inline">\(B\)</span> 满足 <span class="math inline">\(\mu(B)&lt;\delta\)</span>，就有 <span class="math inline">\(\sup_n\mathbb{E}[|X_n|:B]&lt;\epsilon\)</span>。</p></blockquote><blockquote><p><strong>定理</strong>：<span class="math inline">\(\{X_n\}\)</span>一致可积当且仅当它们 <span class="math inline">\(L^1\)</span>一致有界且一致绝对连续。</p></blockquote><p><span class="math inline">\(\Rightarrow\)</span>: <span class="math inline">\(L^1\)</span>一致有界已经有了。下证一致绝对连续性质。对任何可测集 <span class="math inline">\(B\)</span>，我们考虑用一个待定的 <span class="math inline">\(a&gt;0\)</span> 把积分 <span class="math inline">\(\mathbb{E}[|X_n|: B]\)</span> 变成 <span class="math display">\[\mathbb{E}[|X_n|: B,\ |X_n|\geq a] +\mathbb{E}[|X_n|: B,\ |X_n|&lt;a].\]</span> 第一项小于等于 <span class="math inline">\(\mathbb{E}[|X_n|: |X_n|\geqa]\)</span>，由一致可积性我们可以取 <span class="math inline">\(a\)</span> 使得它小于 <span class="math inline">\(\epsilon/2\)</span>。第二项小于等于 <span class="math inline">\(a\mu(B)\)</span>。所以只要 <span class="math inline">\(\mu(B)&lt;\delta=\frac{\epsilon}{2a}\)</span>即可。</p><p><span class="math inline">\(\Leftarrow\)</span>: 我们可以料想 <span class="math inline">\(\{|X_n|\geq a\}\)</span>的测度是会一致地越来越小的：</p><p><span class="math display">\[\mathbb{P}(\{|X_n|\geqa\})=\mathbb{E}[1: |X_n|\geq a]\leq \mathbb{E}[\frac{|X_n|}{a}:|X_n|\geq a]\leq \frac{\mathbb{E}|X_n|}{a}=\frac{K}{a}.\]</span> 其中<span class="math inline">\(K\)</span> 是 <span class="math inline">\(\{X_n\}\)</span> 的 <span class="math inline">\(L^1\)</span> 上界。所以确实可以取 <span class="math inline">\(a\)</span> 适当大使得 <span class="math inline">\(\{|X_n|\geq a\}\)</span>的测度一致地小于一致绝对连续性中所需要的那个 <span class="math inline">\(\delta\)</span>。</p><blockquote><p><strong>定理</strong>：一致可积性是平移不变的： <span class="math inline">\(\{X_n\}\)</span> 一致可积且 <span class="math inline">\(Y\in L^1\)</span>，则 <span class="math inline">\(\{X_n+Y\}\)</span> 也是一致可积的。</p></blockquote><p>为此只要证明它们一致 <span class="math inline">\(L^1\)</span>有界且一致绝对连续。其中一致 <span class="math inline">\(L^1\)</span>有界是显然的。</p><p>对于一致绝对连续，我们有 <span class="math display">\[\mathbb{E}[|X_n+Y|: B]\leq\mathbb{E}[|X_n|:B] +\mathbb{E}[|Y|: B].\]</span> 取 <span class="math inline">\(\delta_1\)</span> 使得只要 <span class="math inline">\(\mu(B)&lt;\delta_1\)</span> 就有 <span class="math inline">\(\mathbb{E}[|X_n|:B]&lt;\frac{\epsilon}{2}\)</span>，再取<span class="math inline">\(\delta_2\)</span> 使得只要 <span class="math inline">\(\mu(B)&lt;\delta_2\)</span> 就有 <span class="math inline">\(\mathbb{E}[|Y|:B]&lt;\frac{\epsilon}{2}\)</span>，则<span class="math inline">\(\delta=\min\{\delta_1,\delta_2\}\)</span>符合要求。</p><p>最后一个重要定理是：<strong>依 <span class="math inline">\(L^1\)</span> 范数收敛 = 一致可积 +依测度收敛</strong>。</p><blockquote><p><strong>定理</strong>：随机变量序列 <span class="math inline">\(X_n\xrightarrow{L^1} X\)</span> 当且仅当 <span class="math inline">\(X_n\xrightarrow{\mathbb{P}}X\)</span> 且 <span class="math inline">\(\{X_n\}\)</span> 一致可积。</p></blockquote><p><span class="math inline">\(\Rightarrow\)</span>: <span class="math inline">\(L^1\)</span> 收敛当然可以得出依测度收敛 (Markov不等式一步即得)。要证明一致可积，我们只要根据平移不变性，证明 <span class="math inline">\(Y_n=X_n-X\)</span> 是一致可积的即可。</p><p>考虑取一个待定的正整数 <span class="math inline">\(N\)</span>，则<span class="math display">\[\sup_n\mathbb{E}[|Y_n|: |Y_n|\geq a] \leq\sup_{n&lt; N}\mathbb{E}[|Y_n|: |Y_n|\geq a] \vee \sup_{n\geqN}\mathbb{E}[|Y_n|: |Y_n|\geq a]\]</span>上面右边第一项是有限多个可积随机变量组成的集合，是一致可积的，所以只要<span class="math inline">\(a\)</span>足够大第一项是可以任意小的。第二项小于等于 <span class="math inline">\(\mathbb{E}|Y_n|\)</span> 并且由于 <span class="math inline">\(\mathbb{E}|Y_n|\to 0\)</span> 所以只要 <span class="math inline">\(N\)</span> 足够大也是可以任意小的。所以我们先取<span class="math inline">\(N\)</span> 足够大使得 <span class="math inline">\(\mathbb{E}|Y_n|&lt;\epsilon/2\)</span>，再取 <span class="math inline">\(a\)</span> 足够大使得 <span class="math inline">\(n&lt;N\)</span> 时 <span class="math inline">\(\sup_{n&lt; N}\mathbb{E}[|Y_n|: |Y_n|\geqa]&lt;\epsilon/2\)</span>，就得到了一致可积性。</p><p><span class="math inline">\(\Leftarrow\)</span>: 记 <span class="math inline">\(Y_n = X_n - X\)</span>，则 <span class="math inline">\(Y_n\mathbb{1}_{|Y_n|&lt;a}\)</span> 是一个不大于<span class="math inline">\(a\)</span> 的函数序列，且依测度收敛到0，从而由<strong>依测度的控制收敛定理</strong>有 <span class="math inline">\(Y_n\mathbb{1}_{|Y_n|&lt;a}\xrightarrow{L^1}0\)</span>。从而 <span class="math display">\[\|X_n-X\|_{L^1} =\mathbb{E}[Y_n\mathbb{1}_{\{|Y_n|&lt;a\}}] +\mathbb{E}[Y_n\mathbb{1}_{\{|Y_n|\geq a\}}].\]</span> 第一项取 <span class="math inline">\(n\)</span> 足够大就可以任意小，第二项取 <span class="math inline">\(a\)</span> 足够大也可以任意小，得证。</p><blockquote><p><strong>推论</strong>：正则鞅 <span class="math inline">\(X_n =\mathbb{E}[X|\mathcal{F}_n]\)</span> 是一致可积的。</p></blockquote><p>反过来也是对的：鞅序列如果是一致可积的，则一定是正则鞅。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd Kemp 概率论课程笔记</title>
      <link href="/todd-kemp/index.html"/>
      <url>/todd-kemp/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="banach-tarski">0 Banach Tarski</h1><div id="---------------------" class="statement sta________ definition unnumbered"><p><span class="statement-heading"><span class="statement-label">不可测集的例子</span>：</span><span class="statement-spah"> </span>：记单位圆 <span class="math inline">\(S^1=\{e^{it},\,t\in\mathbb{R}\}\)</span>，子群<span class="math inline">\(H=\{e^{iq},\,q\in\mathbb{Q}\}\)</span>，在每个左陪集<span class="math inline">\(S^1/H\)</span> 中选择一个代表元组成集合<span class="math inline">\(E\)</span>，则 <span class="math inline">\(E\)</span> 是不可测集合。这是因为 <span class="math inline">\(S^1 = \bigcup_{q\in\mathbb{Q}}Ee^{iq}\)</span>是可数多个互不相交的集合的并，这些集合两两之间只差乘以一个单位复数，即差一个旋转，所以测度均相等，于是<span class="math display">\[1 = \sum_{q\in\mathbb{Q}}\mu(E) =\infty\cdot \mu(E)\Rightarrow E\text{ not measuabe.}\]</span></p></div><h1 id="probability-motivation">1.1 Probability Motivation</h1><p>无要点</p><h1 id="sigma--fields">1.2 <span class="math inline">\(\sigma\)</span>-Fields</h1><p>介绍了 <span class="math inline">\(\sigma\)</span>-域的概念，以及最重要的 <span class="math inline">\(\sigma\)</span>-域的例子：拓扑空间中开集生成的 Borel 域。</p><h1 id="measures-definition-and-examples">2.1 Measures Definition andExamples</h1><p>介绍了可测空间，以及测度的定义和基本性质。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(\mathcal{F}\)</span> 是一个 <span class="math inline">\(\sigma\)</span>- 域，称 <span class="math inline">\(\mu:\ \mathcal{F}\to[0,\infty]\)</span>是测度，如果对任何可数多个不交并有 <span class="math inline">\(\mu(\uplus_{n=1}^\inftyE_n)=\sum_{n=1}^\infty\mu(E_n)\)</span> 成立。</p></div><p>测度的三个基本性质：</p><ul><li>单调性：<span class="math inline">\(A\subseteq B\Rightarrow\mu(A)\leq\mu(B)\)</span>。</li><li>加法等式 <span class="math inline">\(\mu(A\cup B) + \mu(A\cap B) =\mu(A) + \mu(B)\)</span>。</li><li>次可数可加：<span class="math inline">\(\mu(\cup_{n=1}^\inftyE_n)\leq\sum_{n=1}^\infty\mu(E_n)\)</span>。</li></ul><p>此外如果 <span class="math inline">\(\{\mu_n\}_{n=1}^\infty\)</span>是一列测度，则它们的和 <span class="math inline">\(\mu=\sum\limits_{n=1}^\infty\mu_n\)</span>也是测度。</p><p>预告了接下来构造测度的过程：有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 预测度 <span class="math inline">\(\Rightarrow\)</span> ·测度。</p><h1 id="finitely-additive-measures">2.2 Finitely Additive Measures</h1><p>这一讲介绍了<strong>有限可加测度</strong>，<strong>预测度(pre-measure，即域上的可数可加测度)</strong>，<strong>半代数(semi-algebra)</strong> 等概念。</p><div class="unnumnered statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.1</span>.</span></p><ol type="1"><li>域上的可数可加测度叫做 <strong>预测度</strong>。</li><li>域上的有限可加测度叫做 <strong>有限可加测度</strong>。</li></ol></div><blockquote><p><strong>核心思想</strong>：半代数 <span class="math inline">\(\mathcal{S}\)</span> 上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数 <span class="math inline">\(\mathcal{A}\)</span> 上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数 <span class="math inline">\(\mathcal{A}\)</span> 上的可数可加测度 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\sigma\)</span>- 域上的可数可加测度。</p></blockquote><p>域 <span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度的基本性质：</p><ul><li>单调性、加法等式同可数可加的情形。</li><li><strong>超可数可加</strong>：如果 <span class="math inline">\(\{E_n\}_{n=1}^{\infty}\)</span>是一列不相交的集合，则 <span class="math inline">\(\mu(\uplus_{n=1}^\inftyE_n)\geq\sum_{n=1}^\infty\mu(E_n)\)</span>。这是由于单调性左边始终是右边部分和的上界。注意这里要求每个<span class="math inline">\(E_n\in\mathcal{A}\)</span> 以及 <span class="math inline">\(\mu(\uplus_{n=1}^\inftyE_n)\in\mathcal{A}\)</span>。</li></ul><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.2</span>.</span><span class="statement-spah"> </span>一个半代数 <span class="math inline">\(\mathcal{S}\)</span>是指满足如下条件的集合族：</p><ol type="1"><li><span class="math inline">\(\emptyset\in\mathcal{S}\)</span>。</li><li>若 <span class="math inline">\(A,\,B\in\mathcal{S}\)</span> 则 <span class="math inline">\(A\cap B\in\mathcal{S}\)</span>。</li><li>若 <span class="math inline">\(A\in\mathcal{S}\)</span> 则 <span class="math inline">\(A^c\)</span> 可以表示为 <span class="math inline">\(\mathcal{S}\)</span> 中有限多个成员的不交并。</li></ol></div><p>半代数 <span class="math inline">\(\mathcal{S}\)</span> 生成一个代数<span class="math inline">\(\mathcal{A}\)</span>： <span class="math display">\[\mathcal{A}=\{\text{all finite disjoint unions ofsets from }\mathcal{S} \}.\]</span></p><p>第一步<strong>半代数 <span class="math inline">\(\mathcal{S}\)</span>上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数<span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度</strong>：这一步是显然的，只需要验证定义不依赖于 <span class="math inline">\(\mathcal{A}\)</span> 作为 <span class="math inline">\(\mathcal{S}\)</span>中集合不交并的表示方式即可。</p><p>第三步<strong>代数 <span class="math inline">\(\mathcal{A}\)</span>上的可数可加测度 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\sigma\)</span>-域上的可数可加测度</strong>：这一步总是可以做到的，由后面的测度扩张定理给出。</p><p>第二步<strong>代数 <span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数<span class="math inline">\(\mathcal{A}\)</span>上的可数可加测度</strong>：这一步并不总是可以做到。举个例子，在是整数集<span class="math inline">\(\mathbb{Z}\)</span> 的所有子集上定义如下测度<span class="math inline">\(\mu\)</span>：若子集 <span class="math inline">\(E\)</span> 或者 <span class="math inline">\(E^c\)</span> 之一是有限集，则规定 <span class="math inline">\(\mu(E)=0\)</span>，否则 <span class="math inline">\(\mu(E)=1\)</span>。此测度有限可加但不是可数可加，所以也不会有可数可加的扩张。</p><p>最重要的半代数 <span class="math inline">\(\mathcal{S}\)</span>的例子：所有形如 <span class="math inline">\(\{(a, b],-\infty\leqa&lt;b\leq \infty\}\)</span> 的半开区间。</p><p>任何单调函数 <span class="math inline">\(F\)</span>都可以给出其上的一个有限可加测度：<span class="math inline">\(F((a, b]))= F(b) - F(a)\)</span>，从而可以扩张为代数 <span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度。<strong>但是要使得这个测度是可数可加的，我们必须限制<span class="math inline">\(F\)</span>是右连续的</strong>，这样的测度叫做 Stieltjes 测度，会在下一讲介绍。</p><h1 id="stieltjes-premeasures">3.1 Stieltjes Premeasures</h1><p>本讲接着上一讲的内容，证明了当 <span class="math inline">\(F\)</span>单调且右连续时，<span class="math inline">\(\mu((a,b])=F(b)-F(a)\)</span> 确实给出 Borel 域<span class="math inline">\(\mathcal{A}\)</span>上的一个可数可加测度。当然 Borel 域还是太复杂了(虽然它们都是有限多个半开区间的不交并)，无法用可数可加的定义来验证。我们还是要回到由半开区间构成的半代数<span class="math inline">\(\mathcal{S}\)</span> 上。</p><p>我们要从有限可加推出可数可加，而有限可加蕴涵了可数<strong>超</strong>可加，所以我们还缺少可数<strong>次</strong>可加。而<span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>上的可数次可加实际上可以由 <span class="math inline">\(\mathcal{S}\)</span> 上的可数次可加给出：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>代数 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span> 上的有限可加测度<span class="math inline">\(\mu\)</span>是可数可加的，<strong>当且仅当它限制在 <span class="math inline">\(\mathcal{S}\)</span>上是次可数可加的</strong>。</p></div><p>这个话需要仔细解释清楚：<span class="math inline">\(\mu\)</span> 在<span class="math inline">\(\mathcal{S}\)</span> 上次可数可加是指如果<span class="math inline">\(\{E_n\}\)</span> 是半代数 <span class="math inline">\(\mathcal{S}\)</span>中互不相交的集合，并且它们的可数并 <span class="math inline">\(\uplus_{n} E_n\)</span> 也在半代数 <span class="math inline">\(\mathcal{S}\)</span> 中，则 <span class="math inline">\(\mu(\uplus_nE_n)\leq\sum_n\mu(E_n)\)</span>。</p><p><strong>证明概要</strong>：<span class="math inline">\(\Rightarrow\)</span>是显然的，可数可加必然蕴含次可数可加。</p><p><span class="math inline">\(\Leftarrow\)</span>：<span class="math inline">\(\mu\)</span> 作为 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>上的有限可加测度自然是超可数可加的，要证明它可数可加，只要再证明它次可数可加：即若<span class="math inline">\(\uplus_n A_n\)</span> 是 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>中的可数不交并，则 <span class="math inline">\(\mu(\uplus_nA_n)\leq\sum_n\mu(A_n)\)</span>。记住 <span class="math inline">\(\uplus_n A_n\)</span> 以及所有 <span class="math inline">\(A_n\)</span> 现在都是 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span> 中的元素，所以<span class="math inline">\(\uplus_n A_n = \uplus_{j=1}^NE_j\)</span>，其中 <span class="math inline">\(E_j\in\mathcal{S}\)</span>。于是 <span class="math display">\[E_j = \uplus_n (A_n\capE_j)=\uplus_n\uplus_{i=1}^{N_n}E_i^n\cap E_j.\]</span> 利用 <span class="math inline">\(\mu\)</span> 在 <span class="math inline">\(\mathcal{S}\)</span> 上的次可数可加性有 <span class="math display">\[\mu(E_j)\leq \sum_n\sum_{i=1}^{N_n}\mu(E_i^n\capE_j).\]</span> 再利用 <span class="math inline">\(\mu\)</span> 在 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span> 上的有限可加性有<span class="math display">\[\sum_{i=1}^{N_n}\mu(E_i^n\capE_j)=\mu(A_n\cap E_j).\]</span> 于是 <span class="math display">\[\mu(\uplus_jE_j)=\sum_{j=1}^N\mu(E_j)\leq\sum_{j=1}^N\sum_{n=1}^\infty\mu(A_n\capE_j)=\sum_{n=1}^\infty\sum_{j=1}^N\mu(A_n\capE_j)=\sum_{n=1}^\infty\mu(A_n).\]</span> 即为所证。</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>由单调右连续的函数 <span class="math inline">\(F\)</span>给出的半代数 <span class="math inline">\(\mathcal{S}=\{(a,b]\-\infty\leq a&lt;b\leq\infty\}\)</span> 上的 Stieltjes测度是次可数可加的，因而由上面引理它给出 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>上的可数可加测度。</p></div><p><strong>Todd-Kemp 的精彩证明讲解</strong>：设 <span class="math inline">\((a,b]=\uplus_{i=1}^\infty (a_i,b_i]\)</span>，我们要证明 <span class="math display">\[F(b)-F(a)=\mu((a,b])\leq\sum_{i=1}^\infty\mu((a_i,b_i])=\sum_{i=1}^\infty(F(b_i)-F(a_i)).\]</span> 我们可以先假设 <span class="math inline">\(a,b\)</span> 都是有限的。</p><p><strong>不要幻想可以给区间 <span class="math inline">\((a_i,b_i]\)</span>之间按照大小排顺序，它们可能有无穷多个聚点</strong>。</p><p><strong>想法是把 <span class="math inline">\((a, b]\)</span>缩小一点变成 <span class="math inline">\([a+\delta, b]\)</span>，把<span class="math inline">\((a_i,b_i]\)</span> 放大一点变成 <span class="math inline">\((a_i,b_i+\delta_i)\)</span>，这样可以使用紧集的有限开覆盖性质</strong>。从而存在<span class="math inline">\(N\)</span> 使得前 <span class="math inline">\(N\)</span> 个开区间就足以覆盖 <span class="math inline">\([a+\delta,b]\)</span>： <span class="math display">\[[a+\delta,b] \subseteq \cup_{j=1}^N (a_j,b_j+\delta_j).\]</span> 现在 <span class="math inline">\(\mu\)</span>作为一个有限可加测度，由于 <span class="math inline">\((a+\delta,b]\)</span> 被 <span class="math inline">\(\cup_{j=1}^N (a_j,b_j+\delta_j]\)</span> 覆盖，因而必然有 <span class="math display">\[\mu((a+\delta, b])\leq \sum_{j=1}^N \mu((a_j,b_j+\delta_j])\leq\sum_{j=1}^\infty \mu((a_j, b_j+\delta_j]).\]</span>上式左边等于 <span class="math inline">\(F(b)-F(a+\delta)\)</span>，<span class="math inline">\(\delta\)</span> 是任意正数，所以令其趋于 0 并利用<span class="math inline">\(F\)</span> 的右连续有 <span class="math inline">\(F(a+\delta)\downarrow F(a)\)</span>，所以上式变为<span class="math display">\[\mu((a, b])\leq\sum_{j=1}^\infty\mu((a_j,b_j+\delta_j])=\sum_{j=1}^\infty \mu((a_j, b_j]) + \sum_{j=1}^\infty\mu((b_j, b_j+\delta_j]).\]</span> 注意到 <span class="math inline">\(\delta_j\)</span> 也是任意的，并且 <span class="math inline">\(F\)</span> 右连续，所以对任何 <span class="math inline">\(\epsilon&gt;0\)</span> 我们可以取 <span class="math inline">\(\delta_j\)</span> 足够小，使得 <span class="math inline">\(F(b_j+\delta_j)- F(b_j) &lt;\epsilon/2^j\)</span>。于是 <span class="math display">\[\mu((a,b])\leq\sum_{j=1}^\infty\mu((a_j, b_j+\delta_j])=\sum_{j=1}^\infty\mu((a_j, b_j]) + \epsilon.\]</span> 由 <span class="math inline">\(\epsilon\)</span> 任意性定理得证。</p><h1 id="outer-measure">3.2 Outer Measure</h1><p>这一节介绍了外测度的概念。</p><p>如果我们有一个集合族 <span class="math inline">\(\mathcal{A}\)</span>(<span class="math inline">\(\mathcal{A}\)</span>一般是个代数)，以及其上的函数 <span class="math inline">\(\mu:\\mathcal{A}\to[0,+\infty]\)</span>，则我们可以定义 <span class="math inline">\(2^{\Omega}\)</span> 上的外测度 <span class="math inline">\(\mu^\ast\)</span> 为 <span class="math display">\[\mu^\ast(E) =\inf\left\{\sum_{n=1}^\infty\mu(E_n),\ E_n\in\mathcal{A},E\subset\bigcup_{n=1}^\infty E_n\right\}.\]</span> 外测度 <span class="math inline">\(\mu^\ast\)</span> 满足：</p><blockquote><ol type="1"><li><span class="math inline">\(\mu^\ast(\emptyset)=0\)</span>。</li><li>单调性。</li><li>次可数可加性。</li></ol></blockquote><p>Todd Kemp 视频里面提到 <span class="math inline">\(\mu^\ast\)</span>可以用来区别有限可加测度和预测度：</p><blockquote><ol type="1"><li>如果 <span class="math inline">\((\mu, \mathcal{A})\)</span>是预测度，则<strong>在 <span class="math inline">\(\sigma(\mathcal{A})\)</span> 上有 <span class="math inline">\(\mu(E)\leq\mu^\ast(E)\)</span>，并且在 <span class="math inline">\(\mathcal{A}\)</span> 上有 <span class="math inline">\(\mu=\mu^\ast\)</span></strong>。</li><li>如果 <span class="math inline">\((\mu, \mathcal{A})\)</span>是有限可加测度，则<strong>在 <span class="math inline">\(\mathcal{A}\)</span> 上有 <span class="math inline">\(\mu(E)\geq\mu^\ast(E)\)</span></strong>。</li></ol></blockquote><h1 id="outer-pseudo-metric">4.1 Outer Pseudo-Metric</h1><p>这一节介绍了 Carathéodory 测度扩张定理。设 <span class="math inline">\((\Omega,\mathcal{A},\mu)\)</span>是一个预测度空间。即 <span class="math inline">\(\mu\)</span>是定义在代数 <span class="math inline">\(\mathcal{A}\)</span>上的可数可加测度。我们将把它扩充为 <span class="math inline">\(\sigma(\mathcal{A})\)</span>上的可数可加测度。</p><p>定义外测度 <span class="math inline">\(\mu^\ast:2^\Omega\to[0,\infty]\)</span> 为 <span class="math display">\[\mu^\ast(E)=\inf\left\{\sum_{n=1}^\infty\mu(A_n):E\subseteq\bigcup_{n=1}^\inftyA_n,A_n\in\mathcal{A}\right\}\]</span></p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>存在 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\mathcal{M}\supset\mathcal{A}\)</span> 使得 <span class="math inline">\(\mu^\ast\mid_{\mathcal{M}}\)</span>是可数可加测度。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>Todd Kemp 评论说，<span class="math inline">\(\mathcal{M}\)</span>最大可以是多大是一个非常深刻的技术问题。</p></div><p>标准的证明途径是规定 <span class="math display">\[\mathcal{M}=\{E\in\Omega\mid\mu^\ast(T)=\mu^\ast(T\cap E)+\mu^\ast(T\cap E^c),\forallT\in\Omega\}.\]</span></p><p>这里介绍了 Driver 的方法。这个方法稍微有一点缺陷，它要求 <span class="math inline">\(\mu:\mathcal{A}\to[0,\infty)\)</span>是一个有限测度。稍后也可以扩展到 <span class="math inline">\(\sigma\)</span>-有限测度。在概率论中这足够了。</p><h1 id="radon-measures">5.1 Radon Measures</h1><p>本讲介绍了实直线上的 Radon 测度等价于 Stieltjes 测度。</p><p>Radon 测度是指对任何紧集 <span class="math inline">\(K\)</span> 有<span class="math inline">\(\mu(K)&lt;\infty\)</span>的测度。这种测度的分布函数必然是单调、右连续的，从而根据之前介绍的预测度和测度扩张定理给出了实直线上的一个可数可加测度。</p><h1 id="random-variables-motivation">6.1 Random VariablesMotivation</h1><p>本节介绍了随机变量，分布函数的概念。样本空间 <span class="math inline">\(\Omega\)</span> (modelling space)是难以接触到的，我们对其的观测是通过随机变量来进行的。</p><p>随机变量 <span class="math inline">\(X\)</span> 的分布函数为 <span class="math inline">\(F(t) = \mathbb{P}(X\leq t),\,t\in\overline{\mathbb{R}}\)</span>。<span class="math inline">\(F(t)\)</span> 是单调递增且右连续的。</p><h1 id="riemann-stieltjes-integration">7.2 Riemann-StieltjesIntegration</h1><p>无要点。</p><h1 id="the-radon-nikodym-theorem">11.1 The Radon-Nikodym Theorem</h1><p>本讲介绍了 Radon-Nikodym 定理，不过没有给出证明。</p><p><strong>Motivation</strong>: 设 <span class="math inline">\(\mu,\nu\)</span> 是两个测度，是否存在非负可测函数<span class="math inline">\(\rho\)</span> 使得 <span class="math inline">\(\nu(A)=\int_A\rho\,\mathrm{d}\mu\)</span>对任何可测集 <span class="math inline">\(A\)</span> 成立？</p><p><strong>必要条件</strong>：<span class="math inline">\(\mu(A)=0\Rightarrow\nu(A)=0\)</span>。这时我们称<span class="math inline">\(\nu\)</span> 关于 <span class="math inline">\(\mu\)</span> <strong>绝对连续</strong>，记作 <span class="math inline">\(\nu\ll\mu\)</span>。</p><p>此条件同样也是充分的：若 <span class="math inline">\(\nu\)</span>关于 <span class="math inline">\(\mu\)</span> 绝对连续，则存在 <span class="math inline">\(\rho\)</span> 使得 <span class="math inline">\(\rho=\dfrac{\mathrm{d}\nu}{\mathrm{d}\mu}\)</span>。</p><p><strong>奇异连续测度的例子</strong>：Cantor 函数 (devilstaircase)。<a href="https://www.youtube.com/watch?v=dQXVn7pFsVI">YouTube科普</a>。此函数没有点质量，也没有密度函数，但是确实给出一个全质量为 1的概率测度。</p><ul><li>此函数是连续递增的，所以是一个分布函数。</li><li>此函数是连续的，所以没有点质量，即单个点的测度是 0。</li><li>此函数是奇异的，因为它在除去 Cantor集对应的点之外几乎处处是常数。</li></ul><h1 id="dynkins-multiplicative-systems-theorem">14.1 Dynkin’sMultiplicative Systems Theorem</h1><p>本讲介绍了 Dynkin <span class="math inline">\(\pi-\lambda\)</span>定理的函数形式的版本。</p><blockquote><p><strong>定义</strong>：设 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 是一个可测空间，称<span class="math inline">\(f\)</span> 是一个关于 <span class="math inline">\(\mathcal{F}\)</span> 可测的有界函数，如果存在<span class="math inline">\(M&gt;0\)</span> 使得 <span class="math inline">\(|f|\leq M\mathrm{a.e.}\)</span> 成立。记 <span class="math inline">\(\mathbb{B}(\Omega,\mathcal{F})\)</span>为全体这样的有界函数构成的向量空间。若 <span class="math inline">\(\{f_n\}\in\mathbb{B}(M,\mathcal{F})\)</span> 满足<span class="math inline">\(|f_n|\leq M\mathrm{a.e.}\)</span> 并且 <span class="math inline">\(f_n\to f\mathrm{a.e.}\)</span>，就称 <span class="math inline">\(f_n\)</span> <strong>一致有界收敛到 <span class="math inline">\(f\)</span></strong>。</p></blockquote><blockquote><p><strong>定理</strong>：设 <span class="math inline">\(\mathcal{I}\subseteq\mathcal{F}\)</span> 是一个<span class="math inline">\(\pi\)</span>- 系，设 <span class="math inline">\(\mathbb{H}(\mathcal{I})\subseteq\mathbb{B}(\Omega,\mathcal{F})\)</span>满足如下条件：</p><ol type="1"><li><span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span>是一个向量空间。</li><li><span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span> 包含<span class="math inline">\(\Omega\)</span> 上的常函数 <span class="math inline">\(\mathbb{1}\)</span>。</li><li>若 <span class="math inline">\(\{f_n\}\)</span> 是 <span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span>中的可测函数序列，且 <span class="math inline">\(f_n\)</span>一致有界收敛到 <span class="math inline">\(f\)</span>，则 <span class="math inline">\(f\in\mathbb{H}(\mathcal{I})\)</span>。</li><li><span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span> 包含<span class="math inline">\(\mathcal{I}\)</span> 中的所有指标函数 <span class="math inline">\(\mathbb{1}_{A},\,A\in\mathcal{I}\)</span>。</li></ol><p><strong>结论</strong>：<span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span> 包含所有关于<span class="math inline">\(\sigma(\mathcal{I})\)</span>-可测的有界函数。</p></blockquote><p><strong>证明概要</strong>：设 <span class="math display">\[\mathcal{A}=\{A\in\mathcal{F}:\\mathbb{1}_A\in\mathbb{H}(\mathcal{I})\}.\]</span></p><ul><li>由 2 <span class="math inline">\(\Omega\in\mathcal{A}\)</span>。</li><li>由 1, 2 结合有若 <span class="math inline">\(A\in\mathcal{A}\)</span> 则 <span class="math inline">\(A^c\in\mathcal{A}\)</span>。</li><li>由 3 有若 <span class="math inline">\(\{A_n\}\in\mathcal{A}\)</span>，<span class="math inline">\(A_n\uparrow\)</span> 则 <span class="math inline">\(\cup_{n}A_n\in\mathcal{A}\)</span>。</li></ul><p>于是 <span class="math inline">\(\mathcal{A}\)</span> 是一个 <span class="math inline">\(\lambda\)</span>- 系，并且由 4 有 <span class="math inline">\(\mathcal{A}\supseteq\mathcal{I}\)</span>，从而<span class="math inline">\(\mathcal{A}\supseteq\sigma(\mathcal{I})\)</span>。于是<span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span>包含所有形如 <span class="math inline">\(\mathbb{1}_A,\,A\in\sigma(\mathcal{I})\)</span>的指标函数，也就包含所有 <span class="math inline">\(\sigma(\mathcal{I})\)</span>上的简单可测函数，从而包含它们的所有一致有界极限，即全体 <span class="math inline">\(\sigma(\mathcal{I})\)</span>- 可测的有界函数。</p><p><strong>补充</strong>：条件 3 其实可以减弱为 <span class="math inline">\(\{f_n\}\)</span> 是非负可测函数序列，且 <span class="math inline">\(f_n\uparrow f\)</span>，<span class="math inline">\(f\)</span> 有界。这样我们首先得到 <span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span> 包含所有 <span class="math inline">\(\sigma(\mathcal{I})\)</span>上的非负简单函数，因而包含所有的非负有界可测函数，而对任何一般的 <span class="math inline">\(\sigma(\mathcal{I})\)</span> 有界可测函数 <span class="math inline">\(f\)</span>，<span class="math inline">\(f^{\pm}\)</span> 都是 <span class="math inline">\(\sigma(\mathcal{I})\)</span>上的非负有界可测函数，因而 <span class="math inline">\(f^{\pm}\)</span>和它们的差 <span class="math inline">\(f=f^+-f^-\)</span> 都属于 <span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span>。</p><h1 id="product-measure">14.2 Product Measure</h1><p>本讲介绍了乘积测度的构造。<strong>记住乘积测度的构造是用到重积分的</strong>。</p><p><strong>可测空间的乘积</strong>：设 <span class="math inline">\((\Omega_1,\mathcal{F_1}),\,(\Omega_2,\mathcal{F_2})\)</span>是两个可测空间，其乘积空间定义为 <span class="math inline">\((\Omega_1\times\Omega_2,\,\sigma(\mathcal{F}_1\times\mathcal{F}_2))\)</span>。其中<span class="math inline">\(\mathcal{F}_1\otimes\mathcal{F}_2=\sigma(\mathcal{F}_1\times\mathcal{F}_2)\)</span>是由所有形如 <span class="math inline">\(\{A_1\times A_2,A_i\in\mathcal{F}_i\}\)</span> 的集合生成的 <span class="math inline">\(\sigma\)</span>- 域。</p><p><span class="math inline">\(\mathcal{F}_1\otimes\mathcal{F}_2\)</span>还有一种等价的刻画：它是使得投影映射 <span class="math inline">\(\pi_i(\omega_1,\omega_2)=\omega_i\)</span>均可测的最小 <span class="math inline">\(\sigma\)</span>- 域。</p><blockquote><p><strong>引理</strong>：随机向量 <span class="math inline">\(f:(\Omega,\mathcal{F})\to(\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>是可测的，当且仅当其每个分量 <span class="math inline">\(f_i\)</span>是可测的。</p></blockquote><p><span class="math inline">\(\Rightarrow\)</span>: 每个 <span class="math inline">\(f_i=\pi_i\circ f\)</span>作为两个可测映射的复合当然是可测的。</p><p><span class="math inline">\(\Leftarrow\)</span>: 本质是证明如果每个<span class="math inline">\(X_i\)</span> 都是随机变量，则 <span class="math inline">\(X=(X_1,\ldots,X_n)\)</span> 是随机向量。对任何形如<span class="math inline">\(E=E_i\times_{j\nei}\mathcal{B}_i(\mathbb{R})\)</span> 的集合，<span class="math inline">\(X^{-1}(E) =\{\omega\in\Omega: X_i(\omega)\inE_i\}\)</span> 是可测集，而这样的 <span class="math inline">\(E\)</span>生成了 <span class="math inline">\(\mathcal{B}(\mathbb{R}^d)\)</span>，所以 <span class="math inline">\(X^{-1}(E)\)</span> 对任何 <span class="math inline">\(E\subset\mathcal{B}(\mathbb{R}^d)\)</span>都可测。结论得证。</p><p>如果每个 <span class="math inline">\((\Omega_i,\mathcal{F}_i)\)</span>还是测度空间，其上的测度为 <span class="math inline">\(\mu_i\)</span>，则我们可以在 <span class="math inline">\((\Omega_1\times\Omega_2,\mathcal{F}_1\otimes\mathcal{F}_2)\)</span>上定义测度 <span class="math inline">\(\mu_1\otimes\mu_2\)</span> 使得<span class="math inline">\((\mu_1\otimes\mu_2)(E_1\timesE_2)=\mu_1(E_1)\mu_2(E_2)\)</span> 对任何 <span class="math inline">\(E_i\in\mathcal{F}_i,\, i=1,2\)</span> 成立。</p><p>实际上我们可以让这个乘积测度满足</p><p><span class="math display">\[\int_{\Omega_1\times\Omega_2}f_1\otimesf_2\mathrm{d}(\mu_1\otimes\mu_2) =\int_{\Omega_1}f_1\mathrm{d}\mu_1\cdot\int_{\Omega_2}f_2\mathrm{d}\mu_2.\]</span></p><p>考虑满足如下条件的乘积空间 <span class="math inline">\(\Omega_1\times\Omega_2\)</span> 上的可测函数 <span class="math inline">\(f\)</span>:</p><blockquote><ol type="1"><li><span class="math inline">\(\omega_1\tof(\omega_1,\omega_2)\)</span> 对任何 <span class="math inline">\(\omega_2\)</span> 都是可测函数。</li><li><span class="math inline">\(\omega_2\tof(\omega_1,\omega_2)\)</span> 对任何 <span class="math inline">\(\omega_1\)</span> 都是可测函数。</li><li><span class="math inline">\(\omega_1\to\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2(\mathrm{d}\omega_2)\)</span> 是<span class="math inline">\(\mathcal{F}_1/\mathcal{B}(\overline{\mathbb{R}})\)</span>可测函数。注意这个积分值可能是无穷。</li><li><span class="math inline">\(\omega_2\to\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1(\mathrm{d}\omega_1)\)</span> 是<span class="math inline">\(\mathcal{F}_2/\mathcal{B}(\overline{\mathbb{R}})\)</span>可测函数。</li><li><span class="math display">\[\int_{\Omega_1}\left(\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2(\mathrm{d}\omega_2)\right)\mu_1(\mathrm{d}\omega_1)=\int_{\Omega_2}\left(\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1(\mathrm{d}\omega_1)\right)\mu_2(\mathrm{d}\omega_2).\]</span></li></ol></blockquote><p>容易验证对所有形如 <span class="math inline">\(f_1\otimesf_2\)</span> 的函数它们满足上面的性质。它们构成一个乘法系，包含所有形如<span class="math inline">\(\mathbb{1}_{E_1}\otimes\mathbb{1}_{E_2}\)</span>的函数，然后上面的条件对函数列的有界极限仍然成立。根据函数版本的 Dynkin定理，上面的条件对所有有界可测函数，或者非负可测函数都成立。</p><p>由此我们可以定义乘积空间中的测度为</p><p><span class="math display">\[\mu(E)=\int_{\Omega_1}\left(\int_{\Omega_2}\mathbb{1}_{E}\mu_2(\mathrm{d}\omega_2)\right)\mu_1(\mathrm{d}\omega_1)=\int_{\Omega_2}\left(\int_{\Omega_1}\mathbb{1}_{E}\mu_1(\mathrm{d}\omega_1)\right)\mu_2(\mathrm{d}\omega_2).\]</span>不难验证这样定义的积分是有限可加的(积分的线性性质)，可以取单调上升的极限，所以是可数可加的，并且当 <span class="math inline">\(E\)</span> 形如 <span class="math inline">\(E_1\times E_2\)</span> 时有 <span class="math inline">\(\mu(E)=\mu_1(E_1)\mu_2(E_2)\)</span>，从而确实给出符合要求的乘积测度。</p><h1 id="kolmogorovs-0-1-law">17.1 Kolmogorov’s 0-1 Law</h1><p>本讲介绍了独立随机变量序列的尾事件，以及 Kolmogrov 0-1 律。</p><p>设 <span class="math inline">\(\{X_n\}\)</span> 是独立的随机变量序列(不是两两独立，而是任何有限多个都独立)称 <span class="math inline">\(\mathcal{T}=\cap_{n=1}^\infty\sigma(X_n,X_{n+1},\ldots)\)</span>为尾事件域。</p><blockquote><p><strong>Kolmogrov 0-1 律</strong>：对任何 <span class="math inline">\(A\in\mathcal{T}\)</span> 有 <span class="math inline">\(\mathbb{P}(A)\in\{0,1\}\)</span>。</p></blockquote><p><strong>证明概要</strong>：</p><ul><li><span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span> 和 <span class="math inline">\(\sigma(X_{n+1},X_{n+2},\ldots)\)</span>是独立的。因为考虑如下两个集合族： <span class="math display">\[\{\text{all finite intersections like }\cap A_i,A_i\in\sigma(X_i),i=1,2,\ldots,n\}.\]</span> <span class="math display">\[\{\text{all finite intersections like }\cap A_j,A_j\in\sigma(X_j),j=n+1,n+2,\ldots\}.\]</span> 这俩都是 <span class="math inline">\(\pi\)</span>- 系且互相独立，所以它们生成的 <span class="math inline">\(\sigma\)</span>- 域也独立。前者可以生成 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span>，后者可以生成<span class="math inline">\(\sigma(X_{n+1},X_{n+2},\ldots)\)</span>。</li><li>于是 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span> 和<span class="math inline">\(\mathcal{T}\)</span> 是独立的。</li><li>于是 <span class="math inline">\(\pi\)</span>- 系 <span class="math inline">\(\cup_{n=1}^\infty\sigma(X_1,\ldots,X_n)\)</span>和 <span class="math inline">\(\mathcal{T}\)</span> 是独立的。</li><li>于是 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\sigma(X_1,\ldots,X_n,\ldots)\)</span> 和 <span class="math inline">\(\mathcal{T}\)</span> 独立，从而 <span class="math inline">\(\mathcal{T}\)</span> 和 <span class="math inline">\(\mathcal{T}\)</span> 独立，从而得证。</li></ul><h1 id="convolution">17.2 Convolution</h1><p>本讲介绍了概率测度之间的卷积。</p><blockquote><p><strong>定义</strong>：两个概率测度 <span class="math inline">\(\mu,\nu\)</span> 之间的卷积定义为 <span class="math display">\[\mu\ast \nu(B) =\int_{\mathbb{R}^d\times\mathbb{R}^d}\mathbb{1}_B(x+y)\mu\otimes\nu(\,\mathrm{d}x\,\mathrm{d}y)=\int_{\mathbb{R}^d}\mu(B-y)\vdx{y}.\]</span></p></blockquote><h1 id="strong-law-of-large-numbers-part-1">18.1 Strong Law of LargeNumbers, Part 1</h1><p>本讲介绍了 Kolmogrov 强大数定理的表述，以及证明思想。</p><p>基本思想是利用截断的序列与原序列是尾等价的，先对截断的序列证明结论，再回到原序列。</p><blockquote><p><strong>强大数定理</strong>：设 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span> 的 <span class="math inline">\(L^1\)</span> 序列且 <span class="math inline">\(\mathbb{E}[X_n]=a\)</span>，则 <span class="math inline">\(\dfrac{S_n}{n}\to a, \mathrm{a.e.}\)</span>。</p></blockquote><p><strong>重要技巧</strong>：同一个概率空间上的两个序列 <span class="math inline">\(\{X_n\},\,\{Y_n\}\)</span> 称作是尾等价的，如果<span class="math inline">\(\sum_{n=1}^\infty\mathbb{P}(X_n\neY_n)&lt;\infty\)</span>。</p><p>这样根据 Borel-Cantelli 引理，<span class="math inline">\(\{X_n\neY_n,\mathrm{i.o.}\}\)</span> 是零测集，从而 <span class="math inline">\(X_n=Y_n\)</span>最终会几乎处处成立，从而二者的极限行为一致。即如果 <span class="math inline">\(b_n\uparrow\infty\)</span>，则 <span class="math display">\[\lim\limits_{n\to\infty}\dfrac{1}{b_n}\sum_{j=1}^nX_n = X \Leftrightarrow\lim\limits_{n\to\infty}\dfrac{1}{b_n}\sum_{j=1}^n Y_n = X.\]</span></p><p><strong>截断的序列和原序列是尾等价的</strong></p><blockquote><p><strong>引理</strong>：若 <span class="math inline">\(X\inL^1,\,\epsilon&gt;0\)</span>，则 <span class="math display">\[\sum_{n=1}^\infty\mathbb{P}(X\geq n\epsilon)\leq\frac{1}{\epsilon}\mathbb{E}|X|.\]</span></p></blockquote><p>值得与 Markov 不等式比较一下，这个不等式更强。</p><p><strong>证明概要</strong>：只要证明结论对 <span class="math inline">\(\epsilon=1\)</span> 成立即可。而这非常显然：</p><p><span class="math display">\[X\geq\lfloor X\rfloor =\sum_{n=1}^\infty \mathbb{1}_{\{n\leq X\}}.\]</span></p><blockquote><p><strong>推论</strong>：若 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span> 的 <span class="math inline">\(L^1\)</span> 序列，令 <span class="math inline">\(Y_n = X_n\mathbb{1}_{\{|X_n|\leq n\}}\)</span>，则<span class="math inline">\(\{Y_n\}\)</span> 与 <span class="math inline">\(\{X_n\}\)</span> 是尾等价的。</p></blockquote><p>于是接下来的任务就是证明 <span class="math inline">\(S_n^Y =\dfrac{Y_1+\cdots+Y_n}{n}\to a,\,\mathrm{a.e.}\)</span>。</p><h1 id="kolmogorovs-convergence-criterion">18.2 Kolmogorov’s ConvergenceCriterion</h1><p>本讲介绍了 Kolmogrov 收敛判定：独立随机变量序列如果是 <span class="math inline">\(L^2\)</span> 意义下的 Cauchy序列，则也是逐点收敛意义下的 Cauchy 序列。</p><p>在上一讲中，我们通过把 <span class="math inline">\(L^1\)</span>的序列 <span class="math inline">\(\{X_n\}\)</span> 取截断得到 <span class="math inline">\(Y_n=X_n\mathbb{1}_{\{|X_n|\leqn\}}\)</span>，这是一个与 <span class="math inline">\(\{X_n\}\)</span>尾等价的序列。从而只要证明 <span class="math inline">\(\frac{\sum_{k=1}^n Y_k}{n}\toa\)</span>。为此我们分两步：</p><ol type="1"><li>证明 <span class="math inline">\(\frac{\sum_{k=1}^n(Y_k-\mathbb{E}Y_k)}{n}\to 0\)</span>。</li><li>证明 <span class="math inline">\(\mathbb{E}Y_n\to a\)</span>，从而<span class="math inline">\(\frac{\sum_{k=1}^n\mathbb{E}Y_k}{n}\toa\)</span>。结合上一点就证明了强大数定理。</li></ol><p>2 用控制收敛定理很容易得出，所以关键是证明 1。</p><p>我们首先证明 <span class="math inline">\(\sum_{k=1}^n\frac{Y_k-\mathbb{E}Y_k}{n}\)</span> 是个收敛的序列，然后用下一讲介绍的Kronecker 引理来得出 <span class="math inline">\(\frac{\sum_{k=1}^n(Y_k-\mathbb{E}Y_k)}{n}\to 0\)</span>。</p><blockquote><p><strong>Kolmogrov 收敛判定</strong>：若 <span class="math inline">\(\mathrm{i.i.d}\)</span> 序列 <span class="math inline">\(Z_n\)</span> 满足 <span class="math inline">\(\sum\mathrm{Var}(Z_n)&lt;\infty\)</span> 则 <span class="math inline">\(\sum(Z_n-\mathbb{E}Z_n)\)</span>几乎处处收敛。</p></blockquote><p><strong>证明概要</strong>：我们可以不妨假设 <span class="math inline">\(\mathbb{E}Z_n=0\)</span>，则问题变为若 <span class="math inline">\(\mathrm{i.i.d}\)</span> 序列 <span class="math inline">\(\sum\mathbb{E}|Z_n|^2\)</span> 收敛，则 <span class="math inline">\(\sum Z_n\)</span> 几乎处处收敛。</p><p>记 <span class="math inline">\(S_n=\sum_{k=1}^nZ_k\)</span>，利用Markov 不等式不难有 <span class="math display">\[\mathbb{P}(|S_n|\geq\epsilon)\leq\frac{1}{\epsilon^2}\mathbb{E}[S_n^2].\]</span>有意思的是，上面的不等式中在左边把 <span class="math inline">\(S_n\)</span> 换成 <span class="math inline">\(S_n^\ast=\max_{1\leq i\leq n}|S_n|\)</span>仍然成立：</p><blockquote><p><strong>Kolmogrov 极大不等式</strong>：对任何正数 <span class="math inline">\(\epsilon&gt;0\)</span> 有 <span class="math display">\[\mathbb{P}(S_n^\ast\geq\epsilon)\leq\frac{1}{\epsilon^2}\mathbb{E}[S_n]^2.\]</span></p></blockquote><p>证明：记 <span class="math inline">\(\tau=\inf\{j\in\mathbb{Z}_{\geq1}:\|S_j|\geq\epsilon\}\)</span>。则 <span class="math inline">\(\mathbb{P}(S_n^\ast\geq\epsilon)=\mathbb{P}(\tau\leqn)\)</span>。 <span class="math display">\[\mathbb{E}[S_n^2:\S_n^\ast\geq\epsilon]=\mathbb{E}[S_n^2:\ \tau\leqn]=\sum_{k=1}^n\mathbb{E}[S_n^2:\ \tau=k].\]</span> 使用技巧 <span class="math inline">\(S_n^2=(S_k + S_n - S_k)^2\)</span> 我们有 <span class="math display">\[\mathbb{E}[S_n^2:\ \tau=k] = \mathbb{E}[S_k^2 +(S_n-S_k)^2:\ \tau=k] + \mathbb{E}[2S_k(S_n-S_k):\ \tau=k].\]</span>注意到第二项 <span class="math display">\[\mathbb{E}[2S_k(S_n-S_k):\\tau=k] =\mathbb{E}[2S_k\mathbb{1}_{\{\tau=k\}}(S_n-S_k)]=2\mathbb{E}[S_k\mathbb{1}_{\{\tau=k\}}]\cdot\mathbb{E}[S_n-S_k]=0.\]</span>所以 <span class="math display">\[\mathbb{E}[S_n^2]\geq\sum_{k=1}^n\mathbb{E}[S_n^2:\\tau=k] \geq \sum_{k=1}^n\mathbb{E}[S_k^2:\\tau=k]\geq\epsilon^2\sum_{k=1}^n\mathbb{E}\mathbb{1}_{\{\tau=k\}}=\epsilon^2\mathbb{P}(\tau\leqn)=\epsilon^2 \mathbb{P}(S_n^\ast\geq\epsilon).\]</span></p><p>回到 Kolmogrov 收敛定理的证明。</p><p>Kolmogrov 极大不等式告诉我们</p><p><span class="math display">\[\mathbb{P}(\max_{n\leq k \leq m}|S_k -S_n|\geq\epsilon)\leq\frac{1}{\epsilon^2}\mathbb{E}|S_m-S_n|^2=\frac{1}{\epsilon^2}\sum_{k=n}^m\mathbb{E}Z_k^2.\]</span> 令 <span class="math inline">\(m\to\infty\)</span> 我们有 <span class="math display">\[\mathbb{P}(\sup_{k\geq n}|S_k -S_n|\geq\epsilon)\leq\frac{1}{\epsilon^2}\sum_{k=n}^\infty\mathbb{E}Z_k^2.\]</span> 于是 <span class="math display">\[\mathbb{P}(\sup_{k,j\geq n}|S_k -S_j|\geq\epsilon)\leq\frac{2}{\epsilon^2}\sum_{k=n}^\infty\mathbb{E}Z_k^2.\]</span> 所以随机变量序列 <span class="math inline">\(\delta_n = \sup_{k,j\geq n}|S_k - S_j|\)</span>依测度收敛到 0。但是 <span class="math inline">\(\delta_n\)</span>是一个单调下降的非负序列，它必然有一个几乎处处收敛的极限 <span class="math inline">\(\delta\)</span>，<span class="math inline">\(\delta\)</span> 也非负。<span class="math inline">\(\delta\)</span> 依测度收敛到 0，又几乎处处收敛到<span class="math inline">\(\delta\)</span>，那必须 <span class="math inline">\(\delta\)</span> 几乎处处为 0，即 <span class="math inline">\(\{S_n\}\)</span> 是 Cauchy 序列。</p><h1 id="strong-law-of-large-numbers-part-2">19.1 Strong Law of LargeNumbers, Part 2</h1><p>介绍了证明强大数定理的第二个工具：Kronecker 引理。</p><blockquote><p><strong>Kronecker 引理</strong>：若 <span class="math inline">\(\{b_k\}\uparrow\infty\)</span> 且 <span class="math inline">\(\lim\limits_{n\to\infty}\sum\limits_{k=1}^n\dfrac{x_k}{b_k}\)</span>存在，则 <span class="math inline">\(\lim\limits_{n\to\infty}\dfrac{1}{b_n}\sum\limits_{k=1}^nx_k=0\)</span>。</p></blockquote><p><strong>证明概要</strong>：记 <span class="math inline">\(u_n=\sum\limits_{k=1}^n\dfrac{x_k}{b_k},\,u_0=0\)</span>，则<span class="math inline">\(\lim\limits_{n\to\infty}u_n=s\)</span>存在。 <span class="math display">\[\begin{align*}\frac{1}{b_n}\sum_{k=1}^nx_k&amp;=\frac{1}{b_n}\sum_{k=1}^n(u_k-u_{k-1})b_k=\frac{1}{b_n}\sum_{k=1}^nu_kb_k-\frac{1}{b_n}\sum_{k=0}^{n-1}u_kb_{k+1}\\&amp;=u_n-\frac{b_n-b_1}{b_n}s-\sum_{k=1}^{n-1}\frac{b_{k+1}-b_k}{b_n}(u_k-s).\end{align*}\]</span>而最后一个余项的绝对值小于等于 <span class="math display">\[\begin{align*}\sum_{k=1}^{n-1}\frac{b_{k+1}-b_k}{b_n}|u_k-s|=\left(\sum_{k=1}^{N}+\sum_{k=N+1}^{n-1}\right)\frac{b_{k+1}-b_k}{b_n}|u_k-s|\end{align*}\]</span>这里对 <span class="math inline">\(n&gt;N\)</span> 有 <span class="math inline">\(|u_n-s|&lt;\epsilon\)</span> 成立。</p><p>当 <span class="math inline">\(n\to\infty\)</span>时第一个和项是一个有界的值除以 <span class="math inline">\(b_n\)</span>从而趋于 0。第二个和项显然不大于 <span class="math inline">\(\dfrac{b_n}{b_n}\epsilon\)</span>，所以这个余项可以任意小。</p><blockquote><p><strong>引理</strong>：<span class="math inline">\(Y_n' =Y_n/n\)</span> 满足 Kolmogrov 收敛判定。</p></blockquote><p><strong>证明概要</strong>： <span class="math display">\[\begin{align*}\sum_{n=1}^\infty\mathrm{Var}(Y_n')&amp;=\sum_{n=1}^\infty\frac{\mathbb{E}Y_n^2- (\mathbb{E}Y_n)^2}{n^2}\leq\sum_{n=1}^\infty\frac{\mathbb{E}Y_n^2}{n^2}\\&amp;=\sum_{n=1}^\infty\frac{\mathbb{E}X_n^2\mathbb{1}_{\{|X_n|\leqn\}}}{n^2}\\&amp;=\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}}\right]\\&amp;\leq\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2},\|X_1|\leq 2\right] +\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}},\|X_1|&gt;2\right]\\&amp;\leq4\sum_{n=1}^\infty\frac{1}{n^2}+\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}},\ |X_1|&gt;2\right] .\end{align*}\]</span> 为什么要用 <span class="math inline">\(|X_1|\)</span> 是否大于 2把它分成两部分？这里其实可以用任何大于等于 2 的数，不过 2已经足够了，这样做的原因下面就会看到。</p><p>现在第一项是有限的，我们只要说明第二项也有限即可。你可能想把 <span class="math inline">\(\mathbb{1}_{\{|X_1|\leq n\}}\)</span>扔掉，但是注意强大数定律中 <span class="math inline">\(|X_1|\)</span> 是<span class="math inline">\(L^1\)</span> 可积的，未必是 <span class="math inline">\(L^2\)</span> 可积的，所以扔掉是不行的。我们得把<span class="math inline">\(\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}}\)</span> 这个东西估计一下。注意到对任何正整数 <span class="math inline">\(k\)</span>，<span class="math inline">\(\sum_{n=k}^\infty\frac{1}{n^2}\)</span> 就是 <span class="math inline">\(\frac{1}{\lfloor t\rfloor^2}\)</span> 在 <span class="math inline">\([k,\infty)\)</span> 上的积分， 所以当 <span class="math inline">\(x&gt;2\)</span> 时 <span class="math display">\[\begin{align*}\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{x\leq n\}}&amp;=\sum_{n\geqx}^\infty\frac{1}{n^2}=\sum_{n= \lceilx\rceil}^\infty\frac{1}{n^2}\\&amp;=\int_{\lceilx\rceil}^\infty\frac{1}{\lfloor t\rfloor^2}\,\mathrm{d}t\\&amp;\leq\int_{\lceilx\rceil}^\infty\frac{1}{(t-1)^2}\,\mathrm{d}t\\&amp;=\frac{1}{\lceilx\rceil -1}\\&amp;\leq\frac{1}{x-1}&lt;\frac{2}{x}.\end{align*}\]</span> 所以取<span class="math inline">\(x&gt;2\)</span> 主要是为了最后一步的 <span class="math inline">\(\frac{1}{x-1}&lt;\frac{2}{x}\)</span>。</p><p>于是我们就证明了在 <span class="math inline">\(|X_1|&gt;2\)</span>上有 <span class="math display">\[\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}}&lt;\frac{2}{|X_1|}.\]</span> 两边乘以 <span class="math inline">\(|X_1|^2\)</span> 并积分，则 <span class="math display">\[\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}},\ |X_1|&gt;2\right] &lt; 2\mathbb{E}|X_1|.\]</span>这就证明了结论。</p><h1 id="renewal-theory">19.2 Renewal Theory</h1><p>本讲以灯泡寿命为例子，介绍了强大数定理在更新理论中的应用。</p><p>设灯泡的寿命互相独立，且服从某个共同的非负随机变量 <span class="math inline">\(X,\ \mathbb{E}X&lt;\infty\)</span>。设长度为 <span class="math inline">\(t\)</span> 的时刻内需要报废的灯泡数最多为 <span class="math inline">\(N_t\)</span>，即 <span class="math inline">\(S_{N_t}\leq t &lt; S_{N_t+1}\)</span>。则 <span class="math display">\[\lim_{t\to\infty}\frac{N_t}{t}\to\frac{1}{\mathbb{E}X},\quad\mathrm{a.e.}\]</span> 实际上由定义有 <span class="math display">\[\frac{S_{N_t}}{N_t}\leq \frac{t}{N_t} &lt;\frac{S_{N_t+1}}{N_t}.\]</span> 如果我们能证明 <span class="math inline">\(t\to\infty\)</span> 时同样有 <span class="math inline">\(N_t\to\infty,\mathrm{a.e.}\)</span>，则利用强大数定理就有<span class="math inline">\(S_{N_t}/N_t\to\mathbb{E}X\)</span>，从而结论得证。</p><p>我们考虑 <span class="math inline">\(\Omega_1=\{\omega\in\Omega\midS_n(\omega)&lt;\infty,\ \forall n\geq1\}\)</span>。<span class="math inline">\(\Omega_1\)</span> 作为一列递减的测度均为 1的集合列的极限，测度显然也是 1。我们只要证明在 <span class="math inline">\(\Omega_1\)</span> 上有 <span class="math inline">\(S_{N_t}/N_t\to\mathbb{E}X\)</span> 成立。</p><p>首先 <span class="math inline">\(N_t\)</span> 随着 <span class="math inline">\(t\)</span> 递增是没有问题的，如果它对某个 <span class="math inline">\(\omega\)</span> 是有界的，则 <span class="math inline">\(N_t(\omega)\leq M\)</span> 对所有 <span class="math inline">\(t\)</span> 成立。即不管 <span class="math inline">\(t\)</span> 是多少都有 <span class="math inline">\(S_M\leq t &lt; S_{M+1}\)</span>，这只能要求 <span class="math inline">\(S_{M+1}(\omega)=\infty\)</span>，从而 <span class="math inline">\(\omega\)</span> 不属于 <span class="math inline">\(\Omega_1\)</span>。</p><p>一个有意思的引理：</p><blockquote><p><strong>引理</strong>：设 <span class="math inline">\(X\inL^1\)</span>，如果 <span class="math inline">\(\{X_n\}\)</span> 是一列<span class="math inline">\(\mathrm{i.i.d}\)</span> 且服从和 <span class="math inline">\(X\)</span> 同样的分布，则 <span class="math inline">\(\dfrac{X_n}{n}\to0,\mathrm{a.e.}\)</span>。</p></blockquote><p>老技巧，只要证明 <span class="math inline">\(\mathbb{P}(\{|X_n|\geqn\epsilon,\ \mathrm{i.o.}\})=0\)</span> 即可。根据 Borel-Cantelli引理，只要证明 <span class="math inline">\(\sum_{n=1}^\infty\mathbb{P}(|X_n|\geqn\epsilon)&lt;\infty\)</span> 即可，而这在 18.1 中已经证明过了。</p><h1 id="complex-integration-and-dynkins-theorem">24.1 ComplexIntegration and Dynkin’s Theorem</h1><p>无要点</p><h1 id="characteristic-function">24.2 Characteristic Function</h1><p>本讲介绍了随机变量的特征函数及其基本性质。整体内容比较基础。</p><h1 id="the-continuity-theorem">25.3 The Continuity Theorem</h1><p>本讲介绍了测度弱收敛的连续性定理。</p><blockquote><p><strong>定理</strong>：如果 <span class="math inline">\(\{\mu_n\}_{n=1}^\infty\)</span> 是一列 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>上的概率测度。假设极限 <span class="math inline">\(\varphi(t) =\lim\limits_{n\to\infty}\hat{\mu_n}\)</span> 存在，并且 <span class="math inline">\(\varphi(t)\)</span> 在 <span class="math inline">\(t=0\)</span> 处连续，则存在概率测度 <span class="math inline">\(\mu\)</span> 使得 <span class="math inline">\(\hat{\mu}=\varphi\)</span>，并且 <span class="math inline">\(\mu_n\rightarrow_{w}\mu\)</span>。</p></blockquote><blockquote><p><strong>引理</strong>：对两个概率测度 <span class="math inline">\(\mu,\nu\)</span> 有 <span class="math display">\[\int_{\mathbb{R}^d}\hat{\mu}(x)\vdx{x}=\int_{\mathbb{R}^d}\hat{\nu}(y)\udx{y}.\]</span></p></blockquote><p>直接 Fubini 即可。</p><blockquote><p><strong>引理</strong>： <span class="math display">\[\int_{\mathbb{R}^d}[1-\mathrm{Re}\,\hat{\mu}(x)]\vdx{x}=\int_{\mathbb{R}^d}[1-\mathrm{Re}\,\hat{\nu}(y)]\udx{x}.\]</span></p></blockquote><p>在前一个引理中两边取实部，然后被 1 减去即可。</p><blockquote><p><strong>推论</strong>：假设 <span class="math inline">\(\rho\)</span>是一个 <span class="math inline">\(\mathbb{R}^d\)</span>上的概率测度，其支集位于闭的单位球 <span class="math inline">\(\bar{B}_1\)</span> 内。设 <span class="math inline">\(M&gt;0\)</span> 使得 <span class="math inline">\(|\hat{\rho}(t)|\leq1/2\)</span> 对任何 <span class="math inline">\(|t|\geq M\)</span> 成立，则对任何 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>上的概率测度 <span class="math inline">\(\mu\)</span> 和正数 <span class="math inline">\(\alpha&gt;0\)</span> 有 <span class="math display">\[\mu\{x\in\mathbb{R}^d:\ |x|\geq\alpha\}\leq2\int_{\bar{B}_1}[1-\mathrm{Re}\,\hat{\mu}(\frac{M}{\alpha}x)]\rho(x)\,\mathrm{d}x.\]</span></p></blockquote><h1 id="orthogonal-projections">31.1 Orthogonal Projections</h1><p>无要点</p><h1 id="probability-kernels-part-1">33.1 Probability Kernels, Part1</h1><p>本讲引入了概率核的概念。</p><p>设 <span class="math inline">\((S_i,\mathcal{B}_i), i=1,2\)</span>是两个可测空间，一个概率核 <span class="math inline">\(Q(x,B):(S_1,\mathcal{B}_2)\to[0,1]\)</span> 是一个二元函数，满足：</p><ol type="1"><li>对任何 <span class="math inline">\(x\in S_1\)</span>，<span class="math inline">\(Q(x,\cdot):\mathcal{B}_2\to[0,1]\)</span> 是 <span class="math inline">\((S_2,\mathcal{B}_2)\)</span> 上的概率测度。</li><li>对任何 <span class="math inline">\(B\in\mathcal{B}_2\)</span>，<span class="math inline">\(Q(\cdot,B):S_1\to[0,1]\)</span> 是 <span class="math inline">\((S_1,\mathcal{B}_1)\)</span> 上的可测函数。</li></ol><blockquote><p><strong>引理</strong>：假设 <span class="math inline">\(f(x,y)\in(S_1\times S_2, \mathcal{B}_1\otimes\mathcal{B}_2)\)</span>是乘积空间上的可测函数，并且是有界的或者非负的，则积分 <span class="math display">\[x\to\int_{S_2}f(x,y)Q(x,\pd{y})\]</span> 是关于<span class="math inline">\(x\)</span> 的可测函数。</p></blockquote><p>此引理不难从简单函数 <span class="math inline">\(\mathbb{1}_{B_1\timesB_2}(x,y)=\mathbb{1}_{B_1}(x)\mathbb{1}_{B_2}(y)\)</span>出发，使用函数形式的 Dynkin 引理得到。</p><p>由此对任何 <span class="math inline">\((S_1,\mathcal{B}_1)\)</span>上的测度 <span class="math inline">\(\mu\)</span>，我们可以定义乘积空间<span class="math inline">\((S_1\times S_2,\mathcal{B}_1\otimes\mathcal{B}_2)\)</span> 上的乘积测度 <span class="math inline">\(\mu\otimes Q\)</span>，这个乘积测度是随 <span class="math inline">\(x\)</span> 变化而变化的： <span class="math display">\[\mu\otimesQ(E)=\int_{S_1}\mu(\pd{x})\int_{S_2}\mathbb{1}_{C}(x,y)Q(x,\pd{y}).\]</span>不过这真的是一个概率测度吗？你可以用积分的线性性质立刻看出它是有限可加的，并且利用积分项有界和控制收敛定理立刻看出它是可数可加的，所以确实是个概率测度。</p><p>有了概率核的乘积测度，我们自然要研究对这种测度的积分。由于这个测度本身就是通过对示性函数积分来定义的，所以其上的积分也具有类似的性质：</p><blockquote><p><strong>引理</strong>：假设 <span class="math inline">\(f(x,y)\)</span>是乘积空间的可测函数，并且是有界或者非负的，则 <span class="math display">\[\int_{S_1\times S_2}f\pd{(\mu\otimes Q)} =\int_{S_1}\mu(\pd{x})\int_{S_2}f(x,y)Q(x,\pd{y}).\]</span></p></blockquote><p>后面花了很大力气证明当 <span class="math inline">\(Q(x,\cdot)=\widetilde{Q}(x,\cdot)\)</span> 对几乎处处的 <span class="math inline">\(x\)</span> 成立时有 <span class="math inline">\(\mu\otimesQ=\mu\otimes\widetilde{Q}\)</span>。没仔细看。</p><h1 id="regular-conditional-distributions">33.2 Regular ConditionalDistributions</h1><p>本讲使用概率核给出了 <span class="math inline">\(\mathbb{E}[f(X,Y)\mid X=x]\)</span> 这种条件期望的严格定义。</p><blockquote><p><strong>定理</strong>：设 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\)</span>是一个概率空间，<span class="math inline">\((S_i,\mathcal{B}_i),\,i=1,2\)</span>是两个可测空间，<span class="math inline">\(X:(\Omega,\mathcal{F})\to(S_1,\mathcal{B}_1),\,Y:(\Omega,\mathcal{F})\to(S_2,\mathcal{B}_2)\)</span>是两个随机变量。于是 <span class="math inline">\((X,Y):(\Omega,\mathcal{F})\to(S_1\timesS_2,\,\mathcal{B}1\otimes\mathcal{B}_2)\)</span> 是随机向量。记 <span class="math inline">\(\mu_{X,Y}\)</span> 为此随机向量在 <span class="math inline">\((S_1\timesS_2,\,\mathcal{B}1\otimes\mathcal{B}_2)\)</span> 上 push forward给出的测度，<span class="math inline">\(\mu_X\)</span> 是 <span class="math inline">\(X\)</span> 在 <span class="math inline">\((S_1,\mathcal{B}_1)\)</span> 上 push forward给出的测度。如果存在概率核 <span class="math inline">\(Q(x,B)\)</span>使得 <span class="math display">\[\mu_{X,Y}=\mu_X\otimes Q.\]</span></p><p>则对任何 <span class="math inline">\(f\in L^1(S_1\timesS_2,\mathcal{B}1\otimes\mathcal{B}_2)\)</span> 有 <span class="math display">\[\mathbb{E}[f(X,Y)\mid X = x] =\int_{S_2}f(x,y)Q(x, \pd{y}).\]</span></p></blockquote><p>这里需要解释 <span class="math inline">\(\mathbb{E}[f(X,Y)\mid X =x]\)</span> 这个记号的含义。这里其实引用了条件期望 (后面才会讲到)的性质：<span class="math inline">\(\mathbb{E}[f(X,Y)\mid X]\)</span>是一个关于 <span class="math inline">\(\sigma(X)\)</span>可测的随机变量，从而由 Doob-Dynkin 表示定理，存在可测函数 <span class="math inline">\(g\)</span> 使得 <span class="math inline">\(\mathbb{E}[f(X,Y)\mid X] = g(X)\)</span>，所以<span class="math inline">\(\mathbb{E}[f(X,Y)\mid X = x] =g(x)\)</span>。这个定理说的就是 <span class="math display">\[\mathbb{E}[f(X,Y)\mid X = x] = g(x) =\int_{S_2}f(x,y)Q(x, \pd{y}).\]</span></p><p><strong>证明</strong>：怎么证明两个关于 <span class="math inline">\(\sigma(X)\)</span> 可测的函数 (几乎处处)相等呢？我们可以给它们同时乘以 <span class="math inline">\(h(x)\)</span>，这里 <span class="math inline">\(h(x)\)</span> 是任何一个关于 <span class="math inline">\(\sigma(X)\)</span> 可测的有界函数，然后证明它们对<span class="math inline">\(\mu_X\)</span>积分以后的值相等，则这两个可测函数必相等。</p><p><span class="math inline">\(g(x)h(x)\)</span> 这个函数对 <span class="math inline">\(\mu_X\)</span> 积分，根据积分变量替换定理，正是<span class="math inline">\(\mathbb{E}[g(X)h(X)]\)</span>。而根据 <span class="math inline">\(g(x)\)</span> 的定义和条件期望的性质， <span class="math display">\[\mathbb{E}[g(X)h(X)]=\mathbb{E}[\mathbb{E}[f(X,Y)|X]h(X)]= \mathbb{E}[\mathbb{E}[f(X,Y)h(X)|X]] = \mathbb{E}[f(X,Y)h(X)].\]</span> 注意右边的期望悄悄地变成了关于 <span class="math inline">\(\mu_X\otimes Q\)</span>的积分。这是因为上式最后的等号使用了条件期望的 telescoping 性质，而<span class="math inline">\(f(X,Y)g(X)\)</span> 是关于 <span class="math inline">\(\mathcal{B}_1\otimes\mathcal{B}_2\)</span>可测的函数。</p><p>另一方面，<span class="math inline">\(h(x)\int_{S_2}f(x,y)Q(x,\pd{y})\)</span>这个函数对 <span class="math inline">\(\mu_X\)</span> 积分，正是 <span class="math display">\[\int_{S_1}\mu(\pd{x})\int_{S_2}f(x,y)h(x)Q(x,\pd{y}).\]</span>所以 <span class="math display">\[\begin{align*}\mathbb{E}[f(X,Y)h(X)] &amp;= \int_{S_1\timesS_2}f(x,y)h(x)\mu_{X,Y}(\pd{x}\pd{y}) \\&amp;= \int_{S_1\times S_2}f(x,y)h(x)\mu_X\otimes Q \\&amp;= \int_{S_1}\mu_X \int_{S_2}f(x,y)h(x)Q(x,\pd{y}) \\&amp;= \int_{S_1}\mu_X h(x)\int_{S_2}f(x,y)Q(x,\pd{y}).\end{align*}\]</span> 正是所要证明的。</p><p>不过在上面的证明中我们都假定了所有的可积性的前提，我们实际上需要假定<span class="math inline">\(f(x,y)\)</span>有界才能确保推导成立。对一般的 <span class="math inline">\(f(x,y)\inL^1(S_1\times S_2,\mathcal{B}_1\otimes\mathcal{B}_2)\)</span>，我们需要用有界函数列 <span class="math inline">\(f_n\to f\)</span> 且此收敛是在 <span class="math inline">\(L^1(\mu_{X,Y})\)</span> 意义下的。由于条件期望是contraction，所以 <span class="math display">\[\mathbb{E}[f_n(X, Y)| X]\xrightarrow{L^1} \mathbb{E}[f(X,Y)|X].\]</span> 此外我们已经证明了<span class="math display">\[\mathbb{E}[f_n(X, Y)| X] =\left.\int_{S_2}f_n(x,y)Q(x,\pd{y})\right|_{x=X}.\]</span> 所以只要证明<span class="math display">\[\left.\int_{S_2}f_n(x,y)Q(x,\pd{y})\right|_{x=X}\xrightarrow{L^1}\left.\int_{S_2}f(x,y)Q(x,\pd{y})\right|_{x=X}.\]</span> 即可。这个<span class="math inline">\(L^1\)</span> 收敛的意思是对 <span class="math inline">\(\mu_X\)</span> 取积分，因此我们要估计 <span class="math display">\[\int_{S_1}\mu(\pd{x})\int_{S_2}|f_n(x,y)-f(x,y)|Q(x,\pd{y}).\]</span>这不正是 <span class="math inline">\(|fn-f|\)</span>对乘积测度的积分嘛，而我们已经知道了它是 <span class="math inline">\(L^1\)</span> 收敛的了。</p><p>所以如果我们能把一个联合分布分解为边际分布和一个概率核的乘积，则我们就得到了条件概率的一个表示。</p><blockquote><p><strong>问题</strong>：<span class="math inline">\(\mu_{X,Y}\)</span>总可以表示为 <span class="math inline">\(\mu_X\otimes Q\)</span>的形式吗？</p></blockquote><blockquote><p><strong>定理</strong>：如果概率核 <span class="math inline">\(Q(x,B)\)</span> 满足 <span class="math display">\[\mathbb{P}(Y\in B | X=x) =Q(x, B)\]</span> (这个条件等价于 <span class="math display">\[\mathbb{E}[h(Y) | X] = \left.\int h(y)Q(x,\pd{y})\right|_{x=X}.\]</span> 对任何有界的可测函数 <span class="math inline">\(h(y)\)</span> 成立) 则对 <span class="math inline">\(f(x,y)\)</span> 同样有 <span class="math display">\[\mathbb{E}[f(X,Y) | X] = \left.\int f(x,y)Q(x,\pd{y})\right|_{x=X}.\]</span> 成立。</p></blockquote><p>这个定理可以先从 <span class="math inline">\(f(x,y)=f(x)\otimesg(y)\)</span> 形式的函数出发，然后用 Dynkin 函数系引理得到。</p><p>总结一下，至此我们讨论了：</p><ol type="1"><li>如果 <span class="math inline">\(\mu_{X,Y}=\mu_X\otimesQ\)</span>，那我们就有了 <span class="math inline">\(\mathbb{E}[f(X,Y)|X]\)</span> 的计算方法：积分<span class="math inline">\(\int_{S_2}f(X,y)Q(X,\pd{y})\)</span>。特别地我们可以算条件概率了。</li><li>反之如果我们有一个概率核给出条件概率：<span class="math inline">\(\mathbb{P}(Y\in B | X=x) = Q(x,B)\)</span>，那么它就给出 <span class="math inline">\(\mu_{X,Y}\)</span>的一个分解：<span class="math inline">\(\mu_{X,Y}=\mu_X\otimesQ\)</span>。</li></ol><p>本讲后面讨论了离散和连续情形概率核是什么样子的。</p><h1 id="probability-kernels-part-2">34.1 Probability Kernels, Part2</h1><p>本讲介绍了概率核的本质是 Markov生成元，即可测函数空间上的非负线性泛函。</p><p>当有一个概率核 <span class="math inline">\(Q: S_1\times\mathcal{B}_2\to[0, 1]\)</span> 时， <span class="math display">\[f\to\int_{S_2}f(y)Q(x,\pd{y}),\quadf\in\mathbb{B}(S_2,\mathcal{B}_2)\]</span> 给出了从 <span class="math inline">\(L^\infty(S_2,\mathcal{B}_2)\)</span> 到 <span class="math inline">\(L^\infty(S_1,\mathcal{B}_1)\)</span> 的线性映射<span class="math inline">\(L_Q\)</span>，<span class="math inline">\(L_Q\)</span> 满足</p><ol type="1"><li><span class="math inline">\(L_Q(1)=1\)</span>。</li><li>若 <span class="math inline">\(f\geq 0\)</span> 非负可测，则 <span class="math inline">\(L_Q(f)\geq 0\)</span> 也非负可测。</li><li>若 <span class="math inline">\(f_n\uparrow f\)</span> 则 <span class="math inline">\(L_Q(f_n)\uparrow L_Q(f)\)</span>。</li><li><span class="math inline">\(\|L_Q(f)\|_{\infty} \leq\|f\|_{\infty}\)</span>。</li></ol><p>所以 <span class="math inline">\(L_Q\)</span>是一个连续的正线性泛函？</p><p>反过来，如果有这样的一个泛函 <span class="math inline">\(L\)</span>，<span class="math inline">\(L\)</span>是否给出一个概率核 <span class="math inline">\(Q\)</span> 呢？</p><p>答案是否定的，一般来说这不成立。但是在 <span class="math inline">\((S_1,\mathcal{B}_1)=(S_2,\mathcal{B}_2)\)</span>的情形，这确实是对的。</p><blockquote><p><strong>定理</strong>：如果 <span class="math inline">\(L:\mathbb{B}(S,\mathcal{B})\to\mathbb{B}(S,B)\)</span>满足以上四个条件，则 <span class="math display">\[Q(x, B) =L(\mathbb{1}_B)(x)\]</span> 给出一个概率核。并且 <span class="math inline">\(L_Q=L\)</span>，即此概率核给出的线性泛函正是 <span class="math inline">\(L\)</span>。</p></blockquote><p>证明：由于 <span class="math inline">\(0\leq \mathbb{1}_B\leq1\)</span> 总是成立的，所以 <span class="math inline">\(L(0)\leqL(\mathbb{1}_B)\leq L(1)=1\)</span>，即 <span class="math inline">\(L(\mathbb{1}_B)(x)\)</span> 对任何 <span class="math inline">\(x\)</span> 都在 <span class="math inline">\([0,1]\)</span> 中，这符合概率的定义约束。</p><p>固定 <span class="math inline">\(x\)</span>，我们需要证明 <span class="math inline">\(L(\mathbb{1}_B)(x) = \sum_{k=1}^\inftyL(\mathbb{1}_{B_k})(x)\)</span> 对可数不交并 <span class="math inline">\(B = \uplus_{k=1}^\infty B_k\)</span> 成立。记<span class="math inline">\(f_n=\sum_{k=1}^n B_k\)</span>，则 <span class="math inline">\(f_n\uparrow \mathbb{1}_B\)</span>，于是 <span class="math inline">\(L(f_n)\uparrow L(f)=L(\mathbb{1}_B)\)</span>，即<span class="math inline">\(\sum_{k=1}^\inftyL(\mathbb{1}_{B_k})\uparrow L(\mathbb{1}_B)\)</span>，成立！</p><p>要证明 <span class="math inline">\(L = L_Q\)</span>，即对任何 <span class="math inline">\(f\in\mathbb{B}(S,\mathcal{B})\)</span> 有 <span class="math display">\[L(f) = \int_S f(y)Q(x,\pd{y})\]</span>成立。这个很容易从示性函数出发取极限得到。</p><p>如果 <span class="math inline">\(Q_1,Q_2\)</span> 是两个 <span class="math inline">\((S,\mathcal{B})\)</span> 到自身的概率核，则 <span class="math inline">\(L_{Q_1}L_{Q_2}\)</span> 也满足性质1-4，因而也是由一个概率核给出：存在概率核 <span class="math inline">\(Q\)</span> 使得 <span class="math inline">\(L_Q =L_{Q_1}L_{Q_2}\)</span>。我们可以把 <span class="math inline">\(Q\)</span> 明确的写出来： <span class="math display">\[L_Q(f) =L_{Q_1}L_{Q_2}(f)=\int_{S}Q_1(x,\pd{y})\left(\int_Sf(z)Q_2(y,\pd{z})\right).\]</span>这看起来很像乘积测度，实际上我们后面会讨论 <span class="math display">\[Q_1(x,dy)Q_2(d, dz)= Q_1\otimes Q_2(x,dz)\]</span> 的具体含义。</p><h1 id="random-dynamics">34.2 Random Dynamics</h1><p>什么是随机动力系统：</p><p>有一个概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\)</span>，一个可测空间<span class="math inline">\((R,\mathcal{G})\)</span>，以及一些 i.i.d随机变量 <span class="math inline">\(\xi_n:(\Omega,\mathcal{F},\mathbb{P})\to(R,\mathcal{G})\)</span>。此外设 <span class="math inline">\((S,\mathbb{R})\)</span> 是一个可测空间。</p><p>如果 <span class="math inline">\(f\)</span> 是一个 <span class="math inline">\((S, R)\to S\)</span> 的可测函数映射满足</p><p><span class="math display">\[X_{n+1} = f(X_n, \xi_{n+1}) =F_n(X_0,\xi_1,\xi_2,\ldots,\xi_n),\quad F_n:S\times R^n\to S.\]</span>即 <span class="math inline">\(f(\cdot,\xi_n)\)</span> 是一个由随机序列<span class="math inline">\(\{\xi_n\}\)</span>驱动的映射，则我们就称这是一个随机动力系统。</p><p>注意 <span class="math inline">\(X_n\)</span> 由 <span class="math inline">\(\xi_1\sim\xi_n\)</span> 决定，所以 <span class="math inline">\(\mathcal{F}_n=\sigma(X_0,X_1,\ldots,X_n)=\sigma(X_0,\xi_1,\ldots,\xi_n)\)</span>。</p><p>记 <span class="math inline">\(Q_n(x,\cdot)=\mathrm{Law}f(x,\xi_n)\)</span>，则 <span class="math inline">\(Q_n\)</span>是一个概率核。设 <span class="math inline">\(L_n\)</span> 是其 Markov生成元。则</p><p><span class="math display">\[\begin{align*}\mathbb{E}[g(X_{n+1})|\mathcal{F}_n]&amp;= \mathbb{E}[g(f(X_n,\xi_{n+1}))|\mathcal{F}_n]\\&amp;=\left.\mathbb{E}[g\circ f(x,\xi_{n+1})]\right|_{x=X_n} \\&amp;=\left.\int g(y)Q_{n+1}(x,\pd{y})\right|_{x=X_n}\\&amp;=L_{n+1}(g)(X_n).\end{align*}\]</span> 但是 <span class="math inline">\(L_{n+1}(g)(X_n)\)</span> 是 <span class="math inline">\(X_n\)</span> 的函数，所以它关于 <span class="math inline">\(\sigma(X_n)\)</span>是可测的，而且是有界可测，从而两边对 <span class="math inline">\(\sigma(X_n)\)</span> 这个子 <span class="math inline">\(\sigma\)</span>- 域取条件期望，并注意到 <span class="math inline">\(\sigma(X_n)\subset\mathcal{F}_n\)</span> 有 <span class="math display">\[\mathbb{E}[g(X_{n+1})|\mathcal{F}_n] =\mathbb{E}[g(X_{n+1})|X_n].\]</span> 这正是 Markov 性质。</p><h1 id="stochastic-processes">35.1 Stochastic Processes</h1><p>本讲介绍了随机过程的定义，以及它们的有限维分布、滤过(filtration)、适应 (adapted) 等概念。</p><h1 id="the-markov-property">36.1 The Markov property</h1><p>我们称随机过程 <span class="math inline">\(X_t:(\Omega,\mathcal{F}_t)\to(S_,\mathcal{B})\)</span>Markov 性质，如果对任何有界可测函数 <span class="math inline">\(f\in\mathbb{B}(S,\mathcal{B})\)</span> 有</p><p><span class="math display">\[\mathbb{E}[f(X_t)|\mathcal{F}_s] =\mathbb{E}[f(X_t)|X_s],\quad \mathrm{a.e.},\ \forall s &lt;t.\]</span></p><p>Markov过程貌似是关于过去和当前的，但实际上它也告诉了我们关于未来的信息：</p><blockquote><p><strong>推论</strong>：<span class="math inline">\(\mathbb{E}[Y|\mathcal{F}_s] = E[Y|X_s],\quad\forall Y\in\mathbb{B}(\Omega, \mathcal{F}_{\geq s})\)</span>。</p></blockquote><p>这个推论的证明很有意思，要用到 Dynkin multiplicative system。</p><p>考虑形如 <span class="math inline">\(Y =g_0(X_{t_0})g_1(X_{t_1})\cdots g_n(X_{t_n})\)</span> 的函数，这里 <span class="math inline">\(s =t_0&lt;t_1&lt;\cdots &lt;t_n\)</span>，且每个<span class="math inline">\(g_i\)</span> 都是有界可测的，从而 <span class="math inline">\(Y\)</span> 也是有界可测的，并且 <span class="math inline">\(Y\in\mathcal{F}_{\geq s}\)</span>。</p><blockquote><p><strong>引理</strong>：设 <span class="math display">\[\mathcal{M} =\{g_0(X_{t_0})g_1(X_{t_1})\cdots g_n(X_{t_n}): n\in\mathbb{Z}_{\geq0},s=t_0&lt;t_1&lt;\cdots&lt;t_n,g_j\in\mathbb{B}(S,\mathcal{B})\},\]</span> 则 <span class="math inline">\(\mathcal{M}\)</span> 是乘法系，且 <span class="math inline">\(\sigma(M) = \mathcal{F}_{\geq s}\)</span>。</p></blockquote><p>回到推论的证明。</p><p>设 <span class="math inline">\(\mathcal{H}\)</span>是所有满足推论要求的函数构成的空间。我们只要证明 <span class="math inline">\(\mathcal{H} \supset\mathcal{M}\)</span>。这样由于<span class="math inline">\(\mathcal{H}\)</span> 是向量空间，包含常数1，在有界收敛下封闭，并且包含乘法系 <span class="math inline">\(\mathcal{M}\)</span>，从而根据 Dynkin函数系引理包含所有关于 <span class="math inline">\(\sigma(\mathcal{M})=\mathcal{F}_{\geq s}\)</span>可测的有界可测函数，这正是所要证明的。</p><p><span class="math display">\[\begin{align*}\mathbb{E}_{\mathcal{F}_s}[Y]&amp;=\mathbb{E}_{\mathcal{F}_s}[E_{\mathcal{F}_{t_{n-1}}}[Y]]\\&amp;=\mathbb{E}_{\mathcal{F}_s}[g_0(X_{t_0})\cdotsg_{n-1}(X_{t_{n-1}})h(X_{t_{n-1}})]\\&amp;=\mathbb{E}_{\mathcal{F}_s}[g_0(X_{t_0})\cdots\widetilde{g_{n-1}}(X_{t_{n-1}})]\\&amp;=\cdots\\&amp;=\mathbb{E}_{\mathcal{F}_s}[F(X_{s})]\\&amp;=F(X_s)\end{align*}\]</span> 再利用 <span class="math inline">\(\mathbb{E}_{X_s}[Y]=\mathbb{E}_{X_s}[\mathbb{E}_{\mathcal{F}_s}[Y]]=\mathbb{E}_{X_s}[F(X_s)]=F(X_s)\)</span>即得所证。</p><p>上面是 Markov性质的第一种刻画：将对未来可测的函数对当前和过去取条件期望，相当于只对当前取条件期望。</p><p>本讲接下来用条件独立给出了 Markov 性质的第二种刻画：</p><blockquote><p><strong>定理</strong>：随机过程 <span class="math inline">\(\{X_t\}\)</span> 满足 Markov 性质当且仅当 <span class="math inline">\(\mathcal{F}_s\)</span> 和 <span class="math inline">\(\mathcal{F}_{\geq s}\)</span> 关于 <span class="math inline">\(\sigma(X_s)\)</span>是条件独立的，即对任何有界可测函数 <span class="math inline">\(Z\in\mathbb{B}(\Omega,\mathcal{F}_s)\)</span>，<span class="math inline">\(Y\in\mathbb{B}(\Omega,\mathcal{F}_{\geqs})\)</span> 有 <span class="math display">\[\mathbb{E}[ZY|X_s] =\mathbb{E}[Z|X_s]\cdot \mathbb{E}[Y|X_s].\]</span></p></blockquote><p>注意到 <span class="math inline">\(\mathcal{F}_s=\sigma(X_t: t\leqs)\)</span> 以及 <span class="math inline">\(\mathcal{F}_{\geqs}=\sigma(X_T:t\geq s)\)</span>，所以这个结论可以概括为：对 Markov过程，给定当下，过去与未来独立。</p><p>这个结论的证明主要使用了 Tower 性质，不算困难。</p><h1 id="probability-kernels-revisited">36.2 Probability KernelsRevisited</h1><p>回顾了之前概率核的概念。没啥新的。</p><h1 id="kolmogorovs-extended-extension-theorem">37.2 Kolmogorov’s(Extended) Extension Theorem</h1><p>本讲介绍了连续情形的 Kolmogrov扩张定理：可以构造一般的有限维分布，只要它们满足相容性条件。</p><h1 id="walds-identity">46.3 Wald’s Identity</h1><p>本讲介绍了 Wald 引理。</p><blockquote><p><strong>Wald 引理</strong>：设 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span> 的随机变量序列，<span class="math inline">\(\tau\)</span> 是一个停时，则在 <span class="math inline">\(\mathbb{E}|X_1|&lt;\infty\)</span> 且 <span class="math inline">\(\mathbb{E}\tau&lt;\infty\)</span> 的条件下有 <span class="math inline">\(\mathbb{E}\sum\limits_{n=1}^\tauX_n=\mathbb{E}X_1\cdot \mathbb{E}\tau\)</span>。</p></blockquote><p>这里的关键在于将上面的求和变成一个二重级数求和，然后交换求和次序。</p><p><span class="math display">\[\begin{align*}\sum_{n=1}^\tau\mathbb{E}X_n&amp;=\sum_{n=1}^\infty\mathbb{E}X_n\cdot\mathbb{1}_{\tau\geqn}=\sum_{n=1}^\infty\mathbb{E}X_n\cdot\sum_{k=n}^\infty\mathbb{1}_{\tau=k}\\&amp;=\sum_{k=1}^\infty\mathbb{1}_{\tau=k}\sum_{n=1}^k\mathbb{E}X_n\\&amp;=\mathbb{E}X_1\sum_{k=1}^\inftyk\cdot\mathbb{1}_{\tau=k}\\&amp;=\mathbb{E}X_1\cdot\mathbb{E}\tau.\end{align*}\]</span></p><p>我们为什么可以在第一行的第二个等号处交换求和次序？这是因为上面的推导对<span class="math inline">\(|X_n|\)</span> 是成立的，并且离散积分值<span class="math inline">\(\mathbb{E}|X_1|\cdot\mathbb{E}\tau&lt;\infty\)</span>，所以由控制收敛定理对原序列<span class="math inline">\(X_n\)</span> 交换求和也是 OK 的。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd Kemp 概率论课程笔记</title>
      <link href="/todd-kemp/new.html"/>
      <url>/todd-kemp/new.html</url>
      
        <content type="html"><![CDATA[<h1 id="optional-stopping-and-sampling">49.1 Optional Stopping andSampling</h1><p>这一节介绍了停时，以及停时鞅序列 <span class="math inline">\(\{X_{n\wedge \tau}\}\)</span> 的性质。</p><p>一个简单的股票市场模型：设 <span class="math inline">\(\{X_n\}_{n=0}^\infty\)</span> 是股票价格，<span class="math inline">\(\{U_n\}_{n=1}^\infty\)</span>是你的投资策略，即在时刻 <span class="math inline">\(n-1\)</span> 买入<span class="math inline">\(U_n\)</span> 并在时刻 <span class="math inline">\(n\)</span> 抛出。或者说，<span class="math inline">\(U_n\)</span> 是你在 <span class="math inline">\((n-1,n]\)</span>这个时间区间内的股票交易数量，那么到时刻 <span class="math inline">\(n\)</span> 时，你的净收益为 <span class="math display">\[I_n(U,X) = \sum_{j=1}^nU_j(X_j-X_{j-1}).\]</span> 这里 <span class="math inline">\(U_n\)</span>必须是关于 <span class="math inline">\(\mathcal{F}_{n-1}=\sigma(X_0,X_1,\ldots,X_{n-1})\)</span>可测。</p><p>第一个重要观察是：</p><div id="martingale-discrete-integration" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.1</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\{X_n\}\)</span> 是鞅/下鞅/上鞅，并且 <span class="math inline">\(U_n\geq0\)</span>，则 <span class="math inline">\(I_n(U,X)\)</span> 也是鞅/下鞅/上鞅。</p></div><p>证明：对下面的恒等式两边关于 <span class="math inline">\(\mathcal{F}_n\)</span> 取条件期望即可。 <span class="math display">\[I_{n+1}(U,X) =\underbrace{I_{n}(U,X)}_{\in\mathcal{F}_n} +\underbrace{U_{n+1}}_{\in\mathcal{F}_n}\underbrace{(X_{n+1}-X_{n})}_{\rm(sub/sup)martingale}.\]</span></p><p>我们可以设定两个随机时间，比如 <span class="math inline">\(\sigma\)</span> 是股票首次低于 1 美元的时刻,这时立刻买入；<span class="math inline">\(\tau\)</span> 是股票首次高于10 美元的时刻，这时立刻抛出；在区间 <span class="math inline">\((\sigma,\tau]\)</span> 中保持持有股票，即 <span class="math inline">\(U_j=\mathbb{1}_{\sigma&lt;j\leq\tau}\)</span>。于是 <span class="math inline">\(U_j\mathbb{1}_{n\geqj}=\mathbb{1}_{(\sigma\wedge n, \tau\wedge n]}(j)\)</span>。</p><p>那么净收益 <span class="math display">\[I_n(U,X) = \sum_{j=1}^n\mathbb{1}_{\sigma\wedge n&lt;j\leq \tau\wedge n}(X_j-X_{j-1})=X_{\tau\wedge n} - X_{\sigma\wedge n}.\]</span></p><p>特别地，取 <span class="math inline">\(\sigma=0\)</span>，则 <span class="math inline">\(U_j=\mathbb{1}_{j\leq\tau}\)</span>，则我们有如下结论：</p><div id="stopping-time-also-martingale" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\{X_n\}\)</span> 是鞅，那么 <span class="math inline">\(\{X_{n\wedge \tau}\}\)</span> 也是鞅。</p></div><p>证明：首先每一项 <span class="math inline">\(X_{n\wedge\tau}\)</span> 可以看成是一个关于 <span class="math inline">\(X_1,\ldots,X_n\)</span> 的部分和：</p><p><span class="math display">\[X_{n\wedge \tau} =\sum_{k=0}^n\mathbb{1}_{\tau=k}X_k.\]</span></p><p>显然 <span class="math inline">\(X_{n\wedge \tau}\)</span>是可积的。</p><p>另一方面在 <a href="#martingale-discrete-integration" title="定理 1.1">定理 1.1</a> 中取 <span class="math inline">\(U_n=\mathbb{1}_{n\leq\tau}\)</span>，则 <span class="math inline">\(X_{n\wedge \tau} - X_0 = I_n(U,X)\)</span>仍然是鞅，那么加上一个 <span class="math inline">\(X_0\)</span> 得到的<span class="math inline">\(X_{n\wedge\tau}\)</span> 当然还是鞅。</p><h1 id="holders-inequality">49.2 Holder’s Inequality</h1><p>无特别内容</p><h1 id="submartingale-maximal-inequalities-未完成">49.3 (Sub)martingaleMaximal Inequalities （未完成）</h1><p>开篇第一句话就是，鞅在一个有限区间上的极大值，可以以多种方式被它在区间终点的值所控制。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>TODO List</title>
      <link href="/todo/index.html"/>
      <url>/todo/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="写作">写作</h1><ul><li>关于 SO3 的表示的文章，与球谐函数、有限群的不变量、Shephard-Todd定理的关系。配一个 shadertoy demo。</li><li>S_n 和 GL(n) 的表示论，Schur-Weyl 对偶。</li><li>六顶点模型，Yang-Baxter 方程和 ASM 的证明。</li><li>对称平面分拆的 Macdonald 猜想，Hall 多项式，SL(n)表示在计数中的应用。</li><li>永不回到原点的二维随机游动，介绍 Doob h-变换、调和测度。</li><li>扭结与动力系统</li><li>Lie 代数的 Minuscule 表示与对称平面分拆</li><li>GTM A course in enumeration 中剩余的 highlight 问题。</li><li>二维码与 Reed-Solomon 编码算法介绍</li><li>图的环空间与割空间，顶点膨胀技巧</li><li>Hilbert 曲线算法与 Golay 码</li><li>Aztec diamond arctic circle 现象的解释</li><li>Random walk, circle packing and conformal mapping.</li><li>Billiard ball，测度论，Poncelet 定理</li><li>Durrett 概率论 Brownian 运动部分改写</li><li>Indra’s pearls 部分内容介绍，附 shadertoy 动画</li><li>Raymarching 中 sdf 函数与各种变换的数学证明</li><li>正的 Hausdoff 维数意味常返性http://www.cmat.edu.uy/~lessa/resource/randomwalknotes.pdf</li><li>准晶，Faraday 驻波。</li><li>连分数，圆堆，Fary。</li><li>Fulton algebraic curves, Poncelet porism 的代数几何证明和 Jacobi椭圆函数证明。</li><li>Mobius gear 和 Quaternion 是啥关系，flockaroo 的 shadertoy</li><li>蜂巢和 Gauss整数的关系：https://twitter.com/roice713/status/1497252225785204738?s=20&amp;t=WN0vB5s3eU_riCbC37nWiA</li><li>stable diffusion 学习</li><li>互锁的折纸 origami 正十二面体 | Interlock 多面体</li><li>局部中心极限定理 | 电流与同调 | 改写随机游动</li><li>quaternions and polytopes</li><li>概率论常用结论？单调类、Dynkin…</li><li>双曲内积</li><li>Thurston 圆堆算法，常返与暂态</li><li>可裂八元数，G2 与复合代数</li><li>多连通空间上群作用怎么给出表现</li><li>John Baez 李群和四元数讲义, G2 and the rolling ball, Kepler问题的四维对称性</li><li>二维随机游动常返，如双曲、Penrose 等的判断。</li><li><a href="http://math.soimeme.org/~arunram/Resources/KacMoodyLieAlgebrasChapterIII.html">Weyl特征公式</a></li></ul><h1 id="shadertoy">Shadertoy</h1><ul><li>3D icosahedral quasicrystal</li><li>Sphere and lattice gears and SO3 representation</li><li>加速到光速演示相对论</li><li>implicit algebraic surfaces</li><li>doyle spiral</li><li>Voronoi + LLoyd</li><li>Stange + sl2c 的 shader 研究实现</li><li>分形反射盒子</li><li>Direc belt trick</li><li>Bruhat - Tits tree</li><li>Escher circle limit</li><li>Klein quartic 曲面上打台球</li><li>seascape 详解</li><li>笛沙格定理</li><li>算术 Coxeter 群</li><li>三维 Kleinian 群</li><li>模群面上的测地流和 horocycle 流</li><li>Thurston 的圆堆算法</li></ul><h1 id="python">Python</h1><ul><li>Python + cairo 实现 hyperbolic tiling 矢量绘图库。</li><li>继续可视化项目系列，可视化复分析 + indra’s pearls，可视化 circlepackings，可视化双曲空间 (Hee Oh)。</li><li>相对论 + 机器猫</li><li>Faraday 驻波模拟</li><li>Conway’s Topograph</li><li>magicavoxel and magicaCSG</li><li>mitsuba</li><li>Voxel Turtle</li><li>纸壳制作多面体?</li><li>sl3 shdertoy?</li><li>epstein 说的扫描线，gifmaze 能画？</li><li>Knuth-Bendix 约化，模群和 indra’s pearls</li><li>shadertoy Jigsaw 版本的 monotile</li></ul><h1 id="indras-pearls-问题">Indra’s pearls 问题</h1><ul><li>为什么 <span class="math inline">\(\mu(p/q)=\pm2\)</span>分别只有一个解使得群离散？</li><li>连分式，Farey word 和 cutting sequence 的关系</li><li>为什么单尖群的普通集，一侧仍然是单穿孔环面，另一侧是一些圆盘，每个圆盘是一个三孔球面？</li><li>怎么从核心圆链里面读出连分式</li><li>为什么 Punctured torus 上只能 pinch 一条曲线 ？(交数 &gt; 0，collar引理导致另一条测地线的长度必然趋于穷)</li><li>单/双退化群怎么构造的？为什么非周期的无理字单侧和双侧对称分别给出单双退化群？通过袜子戏法，把捏紧<span class="math inline">\((1/0,\gamma)\)</span> 曲线变成捏紧 <span class="math inline">\((\gamma,-1/\gamma)\)</span> ？</li><li>为什么一侧的常域塌陷，另一侧没事？</li><li>双尖群总是给出一个circle packing, 这个 circle packing由两部分组成。这是为什么？</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter groups, automata and uniform tilings</title>
      <link href="/uniform-tilings/index.html"/>
      <url>/uniform-tilings/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Since using POV-Ray to render 3D hyperbolic honeycombs was incrediblyslow, I’ve decided to abandon this approach and have removed the codefrom the main branch on GitHub. You can find the code used in thisarticle in the <a href="https://github.com/neozhaoliang/pywonderland/releases/tag/0.1.0">oldrelease version</a>. For how to render hyperbolic honeycombs, readerscan refer to <a href="https://github.com/neozhaoliang/Hyperbolic-Honeycombs/">anotherproject</a>.</p></blockquote><p>This article introduces a <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/uniform-tilings">Pythonprogram</a> I just finished. Although it’s freshly completed, it took upmost of my free time over the last six months. It was quite thechallenge, requiring a lot of effort and dedication. The main reason isthat it involves a few complicated theories, specifically the deepproperties of Coxeter groups, known as the automatic property. Asignificant portion of these months was spent learning from articles byCasselman, Brink &amp; Howlett, and others, which helped me understandthe mathematicas of this project (see references at the end).</p><p>Although finishing this program is a great achievement for me, Idon’t mean to boast about any superiority of this program: thecomputational method it uses for Coxeter groups is not advanced andmight not impress the experts. Moreover, its code is somewhat ugly, andlikely difficult for other people to use.</p><p>The purpose of this program is to use group theory to draw varioustwo-dimensional and three-dimensional <a href="https://en.wikipedia.org/wiki/Uniform_tiling">uniform tilings</a>.You can think of uniform tiling as using some regular polygons to tilethe space so that the vertices of the tiles are transitive under theaction of a symmetry group (forming a single orbit).</p><p>I will first show some examples of what this program can do, and thenexplain how it works.</p><h1 id="examples">Examples</h1><ul><li><p>Below is the 2d Euclidean tiling omnitruncated (4, 2, 4):</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-4-2-4.png" width="600"></p></li><li><p>Below is the 2d hyperbolic tiling regular (2, 3, 13) inPoincaré’s disk model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/2-3-13.png" width="600"></p></li><li><p>Below is the 2d hyperbolic tiling omnitruncated (4, 3, 3) inupper half plane model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/uhp-4-3-3.png" width="600"></p></li><li><p>A hyperbolic weave pattern:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/weave_pattern.png" width="500"></p></li><li><p>Below is the 3d hyperbolic tiling regular (3, 5, 3) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/3-5-3.png" width="600"></p></li><li><p>Below is the 3d hyperbolic tiling regular (5, 3, 5) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/5-3-5.png" width="600"></p></li><li><p>Below is the 3d hyperbolic tiling regular (5, 3, 4) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/5-3-4.png" width="600"></p></li><li><p>Below is the 3d hyperbolic tiling regular (4, 3, 5) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/4-3-5.png" width="600"></p></li><li><p>The above four regular tilings are the only regular ones withcompact cells. If we drop the restriction on compactness and requiresthe cells must have finite volume, then we have ten more regulartilings, with each has a Euclidean vertex configure. For example (6, 3,3)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/6-3-3.png" width="600"></p><p>You can see the cells have ideal vertices, i.e.&nbsp;vertices at theinfinity. These tilings are called “paracompact”.</p></li><li><p>If we drop the restriction on being “regular” then we have lotsmore examples, like rectified (3, 5, 3) and rectified (5, 3, 4)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/rectified-3-5-3.png" width="600"></p><p><img style="margin:0px auto;display:block" src="/images/coxeter/rectified-5-3-4.png" width="600"></p><p>and the <a href="https://en.wikipedia.org/wiki/Uniform_honeycombs_in_hyperbolic_space#%5B5,31,1%5D_family">canticorder-5 cubic</a> tiling from the [5, 3<sup>1,1</sup>] family:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/cantic-order-5-cubic.png" width="600"></p></li><li><p>Below is a 2d spherical tiling rendered in 3d:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-5-2-3.png" width="600"></p></li><li><p>Finally a shader program exported from Matt Zucker’s excellentwork on <a href="https://www.shadertoy.com/view/3tsSzM">shadertoy</a>:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/wythoff_shader.png" width="600"></p></li></ul><h1 id="wythoff-construction">Wythoff construction</h1><p>The main theoretical tool for drawing uniform tilings is theso-called <a href="https://en.wikipedia.org/wiki/Wythoff_construction">Wythoffconstruction</a>, also known as the kaleidoscope method. This involvesplacing several reflecting planes (mirrors) in space, then starting froman initial point, and repeatedly applying reflection transformationsabout these mirrors to obtain all the virtual images, which gives allthe vertices of the tiling.</p><p>The following video demonstrates the effect of the Wythoffconstruction: in the 2D Poincaré hyperbolic disk, the walls around theroom are all mirrors. The scene in the room is repeatedly reflected inthe mirrors, creating infinitely many virtual image rooms, filling theentire hyperbolic space. Note that, there is only one ‘real’ room,namely the room where the observer is standing in; all other rooms arevirtual images of the real one.</p><video src="/images/hyperbolic-honeycombs/lego-hyperbolic-kaleido.mp4" width="600" controls=""></video><p>There are two different approaches to implemente the Wythoffconstruction in a program:</p><ol type="1"><li><p>Inverse Pixel Method. This method involves calculating, for eachpixel in the image, its corresponding point <span class="math inline">\(p\)</span> in the world space. Then, <span class="math inline">\(p\)</span> is repeatedly reflected off mirrorsuntil it falls within the fundamental region, say the final location is<span class="math inline">\(q\)</span>. Essentially, we find thepre-image <span class="math inline">\(q\)</span> of <span class="math inline">\(p\)</span> in the real room (called thefundamental domain). Then, based on <span class="math inline">\(q\)</span>’s position within the fundamentaldomain, the pixel corresponding to <span class="math inline">\(p\)</span> is colored. This method allows forparallel computation on all pixels, and when combined with shaderprogramming, it can produce very stunning effects. Here are two examplesfrom shadertoy:</p><p><iframe width="480" height="270" frameborder="0" src="https://www.shadertoy.com/embed/mlGfzV?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe></p><p><iframe width="480" height="270" frameborder="0" src="https://www.shadertoy.com/embed/Nd3cR2?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe></p><p>The inverse pixel method cares solely about the final pixel color. Itdoesn’t care about the actual coordinates. It produces raster images andcannot output vector graphics. Moreover, exporting data for use inmodeling software is not very convenient with this method.</p></li><li><p>Coordinate Method. This approach starts from a given initialpoint <span class="math inline">\(v_0\)</span> and calculates all itsvirtual images (within some maximum number of vertices) as well as theconnections between edges and faces, then draws them one by one. Thismethod allows for the acquisition of specific vertex coordinateinformation and outputs vector graphics and model files, making it moresuitable for usage in academic papers. However, it cannot beparallelized and is quite slow in computing hyperbolic tilings, as thestructures grows exponentially.</p></li></ol><p>My program uses the coordinate method. It first performs symboliccalculations within the symmetry group of the tiling to determine theword representation corresponding to each vertex in the shortestlexicographical order (a word is a tuple where each element is aninteger), as well as the connections between edges and faces (alsotuples of integers), and then applies the word corresponding to eachvertex to the initial vertex to obtain the floating-point coordinates ofthat vertex. In other words, before computing the final coordinates ofeach vertex, it has already pre-calculated how many vertices there are,how each vertex is obtained through reflections from the initial vertex,which vertices form edges, which form faces, which form cells, etc.These calculations involve only integer operations, completely avoidingissues with floating-point precision loss.</p><p>Sounds amazing? Let me demonstrate the specific steps with anexample.</p><h1 id="example-omnitruncated-7-2-3-tiling">Example: omnitruncated (7,2, 3) tiling</h1><p>The Coxeter-Dynkin diagram for the omnitruncated (7, 2, 3) tilingis:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/coxeter723.svg" width="250"></p><p>This is a hyperbolic tiling, its symmetry group <span class="math inline">\(G\)</span> is the Coxeter group determined byCoxeter matrix</p><p><span class="math display">\[M=\begin{pmatrix} 1 &amp; 7 &amp; 2 \\ 7&amp;1 &amp;3\\ 2 &amp; 3 &amp;1\end{pmatrix}\]</span></p><p>and has presentation</p><p><span class="math display">\[W = \langle s_0,s_1, s_2\ |\s_0^2=s_1^2=s_2^2=(s_0s_1)^7=(s_1s_2)^3=(s_0s_2)^2=1\rangle.\]</span></p><p>The initial vertex <span class="math inline">\(v_0\)</span> is not onany of the three mirrors, so its stabilizing subgroup is <span class="math inline">\(\langle 1\rangle\)</span>, by <a href="https://en.wikipedia.org/wiki/Group_action_(mathematics)#Orbit-stabilizer_theorem">orbit-stabilizertheorem</a> each element <span class="math inline">\(w\)</span> of <span class="math inline">\(W\)</span> maps <span class="math inline">\(v_0\)</span> to a distinct vertex in thetiling.</p><p>Every element <span class="math inline">\(w\)</span> in <span class="math inline">\(W\)</span> can be expressed as a product of thegenerators <span class="math inline">\(s_0,s_1,s_2\)</span>. We call anysuch expression a word representation of <span class="math inline">\(w\)</span>. If <span class="math inline">\(w=s_{i_1}s_{i_2}\cdots s_{i_k}\)</span> is a wordexpression, and there are no other expressions of <span class="math inline">\(w\)</span> with length less than <span class="math inline">\(k\)</span>, we call <span class="math inline">\(s_{i_1}s_{i_2}\cdots s_{i_k}\)</span> a reducedexpression, and define <span class="math inline">\(l(w)=k\)</span> to bethe length of <span class="math inline">\(w\)</span>. The reducedexpression of <span class="math inline">\(w\)</span> is generally notunique. For example, from the defining relations of <span class="math inline">\(W\)</span>, we can see that <span class="math inline">\(s_0s_2=s_2s_0\)</span> and <span class="math inline">\(s_1s_2s_1=s_2s_1s_2\)</span>, etc. However, allreduced expressions of <span class="math inline">\(w\)</span> must havethe same length, so the definition of <span class="math inline">\(l(w)\)</span> is reasonable.</p><p>We can choose a smallest one among all reduced expressions <span class="math inline">\(w\)</span> as the normal form of <span class="math inline">\(w\)</span>. This sorting is called shortlex order.As the name implies, shortlex order is the order used by dictionaries toarrange words.</p><p>First, define the alphabetical order of the generators <span class="math inline">\(s_0,s_1,s_2\)</span> as <span class="math inline">\(s_0&lt;s_1&lt;s_2\)</span>​, then extend this orderto any two reduced expression <span class="math inline">\(w_1\)</span>and <span class="math inline">\(w_2\)</span>:</p><blockquote><p><strong>Shortlex Order</strong>: Let <span class="math inline">\(w_1= s_{i_1}s_{i_2}\ldots s_{i_n}\)</span> and <span class="math inline">\(w_2=s_{j_1}s_{j_2}\cdots s_{j_m}\)</span> be twodifferent reduced expressions, where <span class="math inline">\(w_1,w_2\)</span> can be different group elements. The relationship betweenthem in shortlex order is determined as follows:</p><ol type="1"><li>First, compare the lengths. If the lengths are different, the onewith the shorter length is considered smaller, that is, if <span class="math inline">\(n &lt; m\)</span> then <span class="math inline">\(w_1 &lt; w_2\)</span>, conversely if <span class="math inline">\(n &gt; m\)</span> then <span class="math inline">\(w_1 &gt; w_2\)</span>.</li><li>If the lengths are the same, then compare the alphabetical orderfrom left to right. Let <span class="math inline">\(k\)</span> be thefirst index such that for any <span class="math inline">\(l &lt;k\)</span>, <span class="math inline">\(s_{i_l} = s_{j_l}\)</span> but<span class="math inline">\(s_{i_k} \ne s_{j_k}\)</span>, then therelationship between <span class="math inline">\(w_1, w_2\)</span> isthe same as the relationship between <span class="math inline">\(s_{i_k}\)</span> and <span class="math inline">\(s_{j_k}\)</span>.</li></ol></blockquote><p>Thus, every <span class="math inline">\(w\in W\)</span> has a uniquenormal form under shortlex order.</p><p>Define <span class="math inline">\(\mathcal{SL}(W)\)</span> as theset consisting of the normal forms of all elements in <span class="math inline">\(W\)</span>. Below is a list of all elements in<span class="math inline">\(\mathcal{SL}(W)\)</span> with lengths up to5, totaling 37: (arranged in rows from smallest to largest)</p><p><span class="math display">\[\begin{array}{lllll}e&amp;s_{0}&amp;s_{1}&amp;s_{2}&amp;s_{0}s_{1}\\s_{0}s_{2}&amp;s_{1}s_{0}&amp;s_{1}s_{2}&amp;s_{2}s_{1}&amp;s_{0}s_{1}s_{0}\\s_{0}s_{1}s_{2}&amp;s_{0}s_{2}s_{1}&amp;s_{1}s_{0}s_{1}&amp;s_{1}s_{0}s_{2}&amp;s_{1}s_{2}s_{1}\\s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{1}&amp;s_{0}s_{1}s_{0}s_{2}&amp;s_{0}s_{1}s_{2}s_{1}&amp;s_{0}s_{2}s_{1}s_{0}\\s_{1}s_{0}s_{1}s_{0}&amp;s_{1}s_{0}s_{1}s_{2}&amp;s_{1}s_{0}s_{2}s_{1}&amp;s_{1}s_{2}s_{1}s_{0}&amp;s_{2}s_{1}s_{0}s_{1}\\s_{0}s_{1}s_{0}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{1}s_{2}&amp;s_{0}s_{1}s_{0}s_{2}s_{1}&amp;s_{0}s_{1}s_{2}s_{1}s_{0}&amp;s_{0}s_{2}s_{1}s_{0}s_{1}\\s_{1}s_{0}s_{1}s_{0}s_{1}&amp;s_{1}s_{0}s_{1}s_{0}s_{2}&amp;s_{1}s_{0}s_{1}s_{2}s_{1}&amp;s_{1}s_{0}s_{2}s_{1}s_{0}&amp;s_{1}s_{2}s_{1}s_{0}s_{1}\\s_{2}s_{1}s_{0}s_{1}s_{0}&amp;s_{2}s_{1}s_{0}s_{1}s_{2}&amp;\end{array}\]</span></p><p>Note the number of all words in <span class="math inline">\(s_0,s_1,s_2\)</span> with length less or equalthan five is <span class="math inline">\(1+3+\cdots+3^5=364\)</span>,the list above tells us that they indeed contain only 37 different ones,the remaining 364 - 37 = 327 ones are duplicates. A further computationshows that the number of all words with length no more than six is 1093but they contain only 53 different elements. So we can gain a greatimprovement in efficiency if we only use words in <span class="math inline">\(\mathcal{SL}(W)\)</span> instead of traversing allpossible combinations of the generators.</p><p>How can we generate those words that are precisely in <span class="math inline">\(\mathcal{SL}(W)\)</span>? This leads us to a veryimportant theorem on Coxeter groups:</p><blockquote><p><strong>Theorem [Brigitte Brink &amp; Robert B. Howlett,1993]</strong>: If <span class="math inline">\(G\)</span> is a finitelygenerated Coxeter group then <span class="math inline">\(\mathcal{SL}(W)\)</span> is a regularlanguage.</p></blockquote><p>The term “regular language” comes from computer science, a basic factabout a regular language over a finite alphabetical set is that thislanguage can always be recognized by a definite finite automaton (DFA),such DFA may not be unique but there is a “minimal one” with the leastnumber of states and this minimal one is unique if we don’t distinctrelabellings of the states.</p><p>Below is the automaton recognizes <span class="math inline">\(\mathcal{SL}(W)\)</span> for the (7, 2, 3)group:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/dfa_723.svg" width="600"></p><p>You can see there are 19 nodes (i.e.&nbsp;states) in the automaton. Thelabels of the states are irrevalent because renumbering the states of anautomaton does not change the language it recognizes.</p><p>The red node is the initial state.</p><p>The directed edges in the graph tell us the transition rule betweenthe states. The edges are labelled by the generators of the group,i.e.&nbsp;<span class="math inline">\(i\)</span> for <span class="math inline">\(s_i\)</span>. If we start from the initial stateand keep on moving to a next state along an edge up to a finite numberof steps, then the path we travelled gives a word in <span class="math inline">\(\mathcal{SL}(W)\)</span>. All words in <span class="math inline">\(\mathcal{SL}(W)\)</span> can be generated in thisway.</p><p>For example:</p><ol type="1"><li>The only path of length 0 correspondes to the identidy 1.</li><li>The three paths of length 1 <span class="math display">\[\begin{align*}0&amp;\xrightarrow{\ s_0\ }1,\\0&amp;\xrightarrow{\ s_1\ }2,\\0&amp;\xrightarrow{\ s_2\ }8.\end{align*}\]</span> corresponde to the three generators <span class="math inline">\(s_0,s_1,s_2\)</span> in <span class="math inline">\(\mathcal{SL}(W)\)</span>.</li><li>The five paths <span class="math display">\[\begin{align*}0&amp;\xrightarrow{\ s_0\}1\xrightarrow{\ s_1\ }2\\0&amp;\xrightarrow{\ s_0\ }1\xrightarrow{\ s_2\ }8\\0&amp;\xrightarrow{\ s_1\ }2\xrightarrow{\ s_0\ }3\\0&amp;\xrightarrow{\ s_1\ }2\xrightarrow{\ s_2\ }8\\0&amp;\xrightarrow{\ s_2\ }8\xrightarrow{\ s_1\ }9\end{align*}\]</span> corresponde to the five elements of length 2 in <span class="math inline">\(\mathcal{SL}(W)\)</span>: <span class="math inline">\(s_0s_1,s_0s_2,s_1s_0,s_1s_2,s_2s_1\)</span>.</li></ol><p>Using breadth-first search we can easily generate all words in <span class="math inline">\(\mathcal{SL}(W)\)</span> up to any givendepth.</p><p>Note for an infinite Coxeter group the automaton must have cycles,but for a finite Coxeter group the automaton must be a directed tree,for example the symmetry group <span class="math inline">\(S_4\)</span>of tetrahedron:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/tetrahedron.svg" width="600"></p><p>The 24 different paths corresponde to the 24 group elements of <span class="math inline">\(S_4\)</span>:</p><p><span class="math display">\[\begin{array}{llll}e&amp;s_{0}&amp;s_{1}&amp;s_{2}\\s_{0}s_{1}&amp;s_{0}s_{2}&amp;s_{1}s_{0}&amp;s_{1}s_{2}\\s_{2}s_{1}&amp;s_{0}s_{1}s_{0}&amp;s_{0}s_{1}s_{2}&amp;s_{0}s_{2}s_{1}\\s_{1}s_{0}s_{2}&amp;s_{1}s_{2}s_{1}&amp;s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{2}\\s_{0}s_{1}s_{2}s_{1}&amp;s_{0}s_{2}s_{1}s_{0}&amp;s_{1}s_{0}s_{2}s_{1}&amp;s_{1}s_{2}s_{1}s_{0}\\s_{0}s_{1}s_{0}s_{2}s_{1}&amp;s_{0}s_{1}s_{2}s_{1}s_{0}&amp;s_{1}s_{0}s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{2}s_{1}s_{0}\end{array}\]</span></p><p>Now the big question:</p><blockquote><p><strong>Question 1</strong>: How to compute <span class="math inline">\(\mathcal{SL}(W)\)</span>?</p></blockquote><p>The answer to this question is too complicated to be covered in thisarticle, a simple sketch of the main thread is appended at the end. WhenI was developing this program I mainly referred to Casselman’s notes <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> andthe textbook by Humphreys <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. These should be enoughfor a reader with a solid background in undergradute abstractalgebra.</p><p>Once we have the normal forms of the group elements, we can easilyuse them to map the initial vertex <span class="math inline">\(v_0\)</span> to other vertices in the tiling:</p><p>Let <span class="math inline">\(w=s_{i_0}s_{i_1}\cdotss_{i_n}\)</span>, we adopt the convention that the action of <span class="math inline">\(w\)</span> on <span class="math inline">\(v_0\)</span> is to successively apply eachgenerator in <span class="math inline">\(w\)</span> from right to left:<span class="math display">\[w\cdot v_0 = s_{i_0}(s_{i_1}(\cdotss_{i_n}(v_0))).\]</span> Since <span class="math inline">\(W\)</span> isinfinite we can only generate words up to a given depth. Suppose we havethe 37 words listed above stored in a list <span class="math inline">\(L\)</span>, they map <span class="math inline">\(v_0\)</span> to 37 different vertices in thetiling. To draw the edges between them we need to compute which of themare adjacent. How can we do this?</p><p>Firstly we need a multiplicaiton table <span class="math inline">\(T\)</span> for the words in <span class="math inline">\(L\)</span>. <span class="math inline">\(T\)</span>is a 2d array with its <span class="math inline">\(i\)</span>-th rowcorrespondes to the <span class="math inline">\(i\)</span>-th word <span class="math inline">\(w_i\)</span> in <span class="math inline">\(L\)</span> and its <span class="math inline">\(j\)</span>-th column correspondes to the <span class="math inline">\(j\)</span>-th generator <span class="math inline">\(s_j\)</span>. The entry <span class="math inline">\(T[i][j]\)</span> records the index of <span class="math inline">\(s_jw_j\)</span> in <span class="math inline">\(L\)</span> (note this multiplication may not be anormal form). If <span class="math inline">\(s_jw_i\)</span> does notexist in <span class="math inline">\(L\)</span> we simply return<code>None</code>. The usage of <span class="math inline">\(T\)</span>is, for any given word <span class="math inline">\(w\)</span>, we canquickly find the index of <span class="math inline">\(w\)</span> in<span class="math inline">\(L\)</span> by using <span class="math inline">\(T\)</span> as a lookup table.</p><p>In our example <span class="math inline">\(T\)</span> is listedbelow, the words in <span class="math inline">\(L\)</span> are put intothe second column:</p><details><summary><font color="#D00"><strong>Click to expand <span class="math inline">\(T\)</span></strong></font></summary><div><table><thead><tr class="header"><th style="text-align: center;">V</th><th style="text-align: center;">word</th><th style="text-align: center;"><span class="math inline">\(s_0\)</span></th><th style="text-align: center;"><span class="math inline">\(s_1\)</span></th><th style="text-align: center;"><span class="math inline">\(s_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(e\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(s_{0}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">6</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(s_{1}\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">0</td><td style="text-align: center;">8</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(s_{2}\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">7</td><td style="text-align: center;">0</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">12</td><td style="text-align: center;">11</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">13</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}\)</span></td><td style="text-align: center;">9</td><td style="text-align: center;">1</td><td style="text-align: center;">15</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}\)</span></td><td style="text-align: center;">10</td><td style="text-align: center;">3</td><td style="text-align: center;">14</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}\)</span></td><td style="text-align: center;">11</td><td style="text-align: center;">14</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;">9</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">20</td><td style="text-align: center;">19</td></tr><tr class="odd"><td style="text-align: center;">10</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">21</td><td style="text-align: center;">18</td></tr><tr class="even"><td style="text-align: center;">11</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">8</td><td style="text-align: center;">22</td><td style="text-align: center;">4</td></tr><tr class="odd"><td style="text-align: center;">12</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">16</td><td style="text-align: center;">4</td><td style="text-align: center;">24</td></tr><tr class="even"><td style="text-align: center;">13</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">17</td><td style="text-align: center;">5</td><td style="text-align: center;">23</td></tr><tr class="odd"><td style="text-align: center;">14</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">18</td><td style="text-align: center;">8</td><td style="text-align: center;">7</td></tr><tr class="even"><td style="text-align: center;">15</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">19</td><td style="text-align: center;">23</td><td style="text-align: center;">6</td></tr><tr class="odd"><td style="text-align: center;">16</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">12</td><td style="text-align: center;">30</td><td style="text-align: center;">29</td></tr><tr class="even"><td style="text-align: center;">17</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">13</td><td style="text-align: center;">31</td><td style="text-align: center;">28</td></tr><tr class="odd"><td style="text-align: center;">18</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">14</td><td style="text-align: center;">32</td><td style="text-align: center;">10</td></tr><tr class="even"><td style="text-align: center;">19</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">15</td><td style="text-align: center;">33</td><td style="text-align: center;">9</td></tr><tr class="odd"><td style="text-align: center;">20</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">25</td><td style="text-align: center;">9</td><td style="text-align: center;">35</td></tr><tr class="even"><td style="text-align: center;">21</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">26</td><td style="text-align: center;">10</td><td style="text-align: center;">36</td></tr><tr class="odd"><td style="text-align: center;">22</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">27</td><td style="text-align: center;">11</td><td style="text-align: center;">34</td></tr><tr class="even"><td style="text-align: center;">23</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">28</td><td style="text-align: center;">15</td><td style="text-align: center;">13</td></tr><tr class="odd"><td style="text-align: center;">24</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">29</td><td style="text-align: center;">34</td><td style="text-align: center;">12</td></tr><tr class="even"><td style="text-align: center;">25</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">20</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr class="odd"><td style="text-align: center;">26</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">21</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">27</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">22</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr class="odd"><td style="text-align: center;">28</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">23</td><td style="text-align: center;">None</td><td style="text-align: center;">17</td></tr><tr class="even"><td style="text-align: center;">29</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">24</td><td style="text-align: center;">None</td><td style="text-align: center;">16</td></tr><tr class="odd"><td style="text-align: center;">30</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">16</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">31</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">17</td><td style="text-align: center;">None</td></tr><tr class="odd"><td style="text-align: center;">32</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">18</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">33</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">19</td><td style="text-align: center;">None</td></tr><tr class="odd"><td style="text-align: center;">34</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">24</td><td style="text-align: center;">22</td></tr><tr class="even"><td style="text-align: center;">35</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">None</td><td style="text-align: center;">20</td></tr><tr class="odd"><td style="text-align: center;">36</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">None</td><td style="text-align: center;">21</td></tr></tbody></table></div></details><p>Hence for any word <span class="math inline">\(w=s_{i_0}s_{i_1}\cdotss_{i_n}\)</span>, we can start from the first row of <span class="math inline">\(T\)</span>, find the index of <span class="math inline">\(s_{i_n}\)</span> in <span class="math inline">\(L\)</span>, say <span class="math inline">\(k\)</span>, then jump to the <span class="math inline">\(k\)</span>-th row and find the index of <span class="math inline">\(s_{i_{n-1}}s_{i_n}\)</span> in <span class="math inline">\(L\)</span>, …, and finally get the index of <span class="math inline">\(w\)</span> (or <code>None</code>).</p><p>Suppose the reflection of the initial vertex <span class="math inline">\(v_0\)</span> about the <span class="math inline">\(i\)</span>-th mirror gives a virtual image <span class="math inline">\(v_1=s_i(v_0)\)</span>, then <span class="math inline">\(e=(v_0,v_1)\)</span> is an edge of type <span class="math inline">\(i\)</span>. By the orbit-stabilizer theorem alledges of type <span class="math inline">\(i\)</span> can be obtained byapplying the coset representatives in <span class="math inline">\(G/H\)</span> to <span class="math inline">\(e\)</span>, where <span class="math inline">\(H=\langle i\rangle\)</span> is the stabilizingsubgroup of <span class="math inline">\(e\)</span> (<span class="math inline">\(H\)</span> is called a standard parabolicsubgroup). It’s easy to see the words of the two ends of <span class="math inline">\(e\)</span> are <span class="math inline">\(1\)</span> and <span class="math inline">\(s_i\)</span> respectively. We then compute thecoset representatives of the words in <span class="math inline">\(L\)</span> for the subgroup <span class="math inline">\(H\)</span>, use a set to remove duplicates, applyeach resulting coset representative <span class="math inline">\(w\)</span> to the two ends of <span class="math inline">\(e\)</span>. The words of the two ends of <span class="math inline">\(w\cdot e\)</span> are <span class="math inline">\(w\)</span> and <span class="math inline">\(ws_i\)</span> respectively. We can find theindices of <span class="math inline">\(w\)</span> and <span class="math inline">\(ws_i\)</span> as shown above to get <span class="math inline">\(w\cdot e\)</span>.</p><p>The edges between the 37 vertices in <span class="math inline">\(L\)</span> are drawn below:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/723_edges.png" width="500"></p><p>0 is the initial vertex, the number of white strips in an edgeindices the type of it (no white strips for <span class="math inline">\(s_0\)</span>, one for <span class="math inline">\(s_1\)</span> and two for <span class="math inline">\(s_2\)</span>).</p><p>It’s worth noting that one can easily read the shortlex wordrepresentation of any vertex <span class="math inline">\(v\)</span> fromthe above image, just start from vertex 0, trace a shortest path from 0to <span class="math inline">\(v\)</span> (if there are more than oneshortest path then always choose the smaller vertex at bifurcatonpoints) and record the edges along the way. For example there are twopaths with shortest length from vetex 0 to vertex 33: <span class="math display">\[\begin{align*}&amp;0\xrightarrow{\ s_1\ }2\xrightarrow{\ s_0\}6\xrightarrow{\ s_2\ }13\xrightarrow{\ s_1\ }22\xrightarrow{\ s_0\}33.\\&amp;0\xrightarrow{\ s_1\ }2\xrightarrow{\ s_2\ }7\xrightarrow{\ s_0\}13\xrightarrow{\ s_1\ }22\xrightarrow{\ s_0\ }33.\end{align*}\]</span> By concatenating edge labels from left to right wehave two words that both map vertex 0 to vertex 33: <span class="math inline">\(s_1s_0s_2s_1s_0\)</span> and <span class="math inline">\(s_1s_2s_0s_1s_0\)</span>. The first is theshortlex one.</p><blockquote><p><strong>Question 2</strong>: How to compute the normal form of themultiplicaiton of two words? How to compute the coset representative ofa word for a standard parabolic subgroup?</p></blockquote><p>Again the answer is too long to be included here. A short sketch ofthe procedure is attached below.</p><p>The procedure for computing faces is very similar with the case ofedges. The reflections about the <span class="math inline">\(i\)</span>-th and <span class="math inline">\(j\)</span>-th mirrors generate a polygon <span class="math inline">\(f_0\)</span> centered at a vertex of thefundamental triangle. The stabilizing subgroup of <span class="math inline">\(f_0\)</span> is the standard parabolic subgroup<span class="math inline">\(\langle i,j\rangle\)</span>. Again we find aword representation for each vertex in <span class="math inline">\(f_0\)</span>, apply the words in <span class="math inline">\(L\)</span> to <span class="math inline">\(f_0\)</span>, and use <span class="math inline">\(T\)</span> to get the indices of the transformedface.</p><p>The final image is shown below, it contains 30517 vertices, 42057edges and 11541 polygons.</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-7-2-3.png" width="500"></p><h1 id="about-the-code">About the code</h1><p>The entire code mainly includes the following functionalities:</p><ol type="1"><li>Computation of Coxeter groups. This part is implemented by the<code>CoxeterGroup</code> class in the <code>coxeter</code> module. Thecomputation of Coxeter groups includes the following aspects:<ul><li>Compute the minimal root reflection table of the Coxeter group.</li><li>Compute the multiplication of two words in the Coxeter group, andreturning the result in its normal form.</li><li>Compute the coset representatives of group elements with respect toa given standard parabolic subgroup, and returning the result in itsnormal form.</li><li>Compute of the finite state machine that recognizes <span class="math inline">\(\mathcal{SL}(W)\)</span>, minimizing it, anddrawing the state machine.</li></ul></li><li>Tiling drawing. Mainly implemented in the <code>tiling.py</code>file. It includes the following steps:<ul><li>For a given Coxeter group and specified initial vertex position,calculate the reflection mirrors and fundamental domain.</li><li>Compute the normal forms of all vertices, as well as the connectionsof edges and faces.</li><li>Apply the words of vertices obtained in the previous step to theinitial vertex to obtain the floating-point coordinates of all vertices.These calculations are all performed in one higher dimension, because inthe higher dimension all reflections are linear transformations, whichavoids the use of affine transformations and inversion. Then project totwo dimensions.</li><li>Call the drawing library to draw the tiling.</li></ul></li></ol><p>The drawing of the finite state machine of <span class="math inline">\(\mathcal{SL}(W)\)</span> requires the use of the<code>pygraphviz</code> module, which depends on the<code>graphviz</code> software and <code>libgraphviz-dev</code>.</p><p>The minimization of the finite state machine was referenced from <a href="https://link.springer.com/article/10.1007/BF00264025">Gries’spaper</a>. Gries’s article is excellent, but I think he did not clarifythe property of the list that storing the <span class="math inline">\((B,a)\)</span> pairs.</p><p>The drawing of the hyperbolic case uses a third-party library <a href="https://github.com/cduck/hyperbolic/">hyperbolic</a>. I’m actuallynot very satisfied with this library, but I don’t have the energy towrite another one at the moment, so I’ll make do for now. The biggestadvantage of this library is that it can draw edges with a constanthyperbolic width, namely the so-called <a href="https://en.wikipedia.org/wiki/Hypercycle_(hyperbolic_geometry)">hypercycle</a>.</p><p>The algorithm for calculating minimal roots is the biggestperformance bottleneck in this code. In determining whether a minimalroot <span class="math inline">\(\gamma\)</span> remains a minimal rootafter a single reflection <span class="math inline">\(s_\alpha\)</span>,the method used is to determine whether <span class="math inline">\(s_\gamma\)</span> and <span class="math inline">\(s_\alpha\)</span> generate a finite dihedralgroup, that is, whether the matrix corresponding to <span class="math inline">\(s_\gamma s_\alpha\)</span> under the basis <span class="math inline">\(\Delta\)</span> of simple roots becomes theidentity matrix after a certain power. The elements of the matrix arealgebraic integers in the cyclotomic field, in the form of <span class="math inline">\(p(\xi)\)</span>, where <span class="math inline">\(p(x)\)</span> is an irreducible polynomial withinteger coefficients, and <span class="math inline">\(\xi\)</span> is aprimitive <span class="math inline">\(m\)</span>-th root of unity, where<span class="math inline">\(m\)</span> is twice the least commonmultiple of all elements in the Coxeter matrix. <span class="math inline">\(\xi\)</span> can be described by the cyclotomicpolynomial <span class="math inline">\(\Phi_m(x)\)</span>. Thus, thecomputation of the matrix is reduced to polynomial operations in <span class="math inline">\(\mathbb{Z}[x]/(\Phi_m(x))\)</span>. Thiscomputational complexity heavily depends on the value of <span class="math inline">\(m\)</span>: for example, for a triangle group like(19, 20, 21), the expression of <span class="math inline">\(\Phi_m(x)\)</span> is very complicated, and thecomputation speed is very slow. This is different from the inverse pixelreflection method, whose computational complexity hardly changes withthe group.</p><p>A more reasonable implementation method can be seen <a href="https://github.com/ulthiel/CoxeterGroups.jl">here</a>.</p><h1 id="more-explainations-on-the-math-stuff">More explainations on themath stuff</h1><p>In this section I’ll give a short sketch of the core part of the mathstuff. This requires you know some basic concepts like geometricrealizations of Coxeter groups, Tit’s cone, root systems. These arefairly standard materials and can be found in Humphreys’s book.</p><p>Almost everything relies upon a 2d table called <strong>reflectiontable of minimal roots</strong>. Again we use group (7, 2, 3) asexample:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/roots.png" width="800"></p><p>This image is the same with the last one except that it has 12labelled mirrors, these mirror have particular importance among allroots in the root system: they are the set of minimal roots in the rootsystem.</p><p>You can think the root system of <span class="math inline">\(W\)</span> as all the circular arcs in thediagram, each of which is a reflection mirror. These mirrors are theresult of the action of the group <span class="math inline">\(W\)</span>on the initial mirrors <span class="math inline">\(AB, AC, BC\)</span>that are the edges of <span class="math inline">\(\Delta ABC\)</span>.Each mirror has two sides, where the side where the fundamental domain<span class="math inline">\(\Delta ABC\)</span> is located is consideredthe positive side of the mirror, and the other side is the negativeside. The normal vector of the mirror’s positive side gives a positiveroot, while the normal vector corresponding to the other side is thenegative of that positive root (negative root).</p><p>We always use a mirror’s positive normal vector (positive root) torepresent that mirror.</p><p>Intuitively, a minimal root <span class="math inline">\(\gamma\)</span> is characterized by the followingcondition: suppose a person stands inside <span class="math inline">\(\Delta ABC\)</span> looking outward, there existsno mirror <span class="math inline">\(\beta \neq \gamma\)</span>completely blocking the view of <span class="math inline">\(\gamma\)</span>, preventing the person from seeingany part of <span class="math inline">\(\gamma\)</span>. In other words,this means that if the person wants to walk from the inside of <span class="math inline">\(\Delta ABC\)</span> to the negatve side of <span class="math inline">\(\gamma\)</span>, and he must cross another mirror<span class="math inline">\(\beta \neq \gamma\)</span> first, regardlessof the path he chooses, then <span class="math inline">\(\gamma\)</span>is <strong>not</strong> a minimal root.</p><p>Simple roots are necessarily minimal roots, as they are theboundaries of the fundamental domain <span class="math inline">\(\DeltaABC\)</span>, and it is impossible for there to be another mirrorblocking between them and the basic region.</p><p>The most important fact about minimal root is:</p><blockquote><p><strong>Theorem</strong>: The set of minimal roots is finite.</p></blockquote><p>This theorem is the key step in Brink and Howlett’s proof thatCoxeter groups are automatic groups.</p><p>The reflection table of minimal roots <code>reftable</code> isdefined as follows: it’s a 2d array with its <span class="math inline">\(i\)</span>-th row correspondes to the <span class="math inline">\(i\)</span>-th minimal root <span class="math inline">\(\alpha_i\)</span> and <span class="math inline">\(j\)</span>-th column correspondes to the <span class="math inline">\(j\)</span>-th generator <span class="math inline">\(s_j\)</span>. The <span class="math inline">\((i,j)\)</span>-entry records the action of <span class="math inline">\(s_j\)</span> on <span class="math inline">\(\alpha_i\)</span>. Let <span class="math inline">\(\beta=s_j(\alpha_i)\)</span>:</p><ol type="1"><li>If <span class="math inline">\(\beta=\alpha_k\)</span> is the <span class="math inline">\(k\)</span>-th minimal root then set this entry to<span class="math inline">\(k\)</span>.</li><li>If <span class="math inline">\(\beta\)</span> is a negative rootthen set this entry to <span class="math inline">\(-1\)</span>.</li><li>Else <span class="math inline">\(\beta\)</span> is a positive rootbut not minimal, set this entry to <code>None</code>.</li></ol><p>The <code>reftable</code> of the (7, 2, 3) group is listed below:</p><table><thead><tr class="header"><th style="text-align: center;">root</th><th style="text-align: center;"><span class="math inline">\(s_0\)</span></th><th style="text-align: center;"><span class="math inline">\(s_1\)</span></th><th style="text-align: center;"><span class="math inline">\(s_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">-1</td><td style="text-align: center;">3</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">4</td><td style="text-align: center;">-1</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">5</td><td style="text-align: center;">-1</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">6</td><td style="text-align: center;">0</td><td style="text-align: center;">7</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">1</td><td style="text-align: center;">8</td><td style="text-align: center;">9</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">9</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;">3</td><td style="text-align: center;">10</td><td style="text-align: center;">11</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;">11</td><td style="text-align: center;">7</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;">10</td><td style="text-align: center;">4</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">9</td><td style="text-align: center;">5</td><td style="text-align: center;">None</td><td style="text-align: center;">4</td></tr><tr class="odd"><td style="text-align: center;">10</td><td style="text-align: center;">8</td><td style="text-align: center;">6</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">11</td><td style="text-align: center;">7</td><td style="text-align: center;">None</td><td style="text-align: center;">6</td></tr></tbody></table><p>Let <span class="math inline">\(\Sigma\)</span> be the set of minimalroots of <span class="math inline">\(G\)</span>, all states in theautomaton are subsets of <span class="math inline">\(\Sigma\)</span>,the transition rule between the subsets is:</p><p><span class="math display">\[S\xrightarrow{\ s_i\ } \{s_i\} \cup(s_i(S)\cup\{ s_i(\alpha_j),j&lt;i\})\cap\Sigma.\]</span></p><p>One can use breadth-first search to build this automaton and use <a href="https://en.wikipedia.org/wiki/DFA_minimization#Hopcroft's_algorithm">Hopcroft’salgorithm</a> to get a minimized version of it.</p><p>The image below shows the subsets of minimal roots for each state inthe automaton:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/723_dfa_subsets.png" width="800"></p><p>The code for computing the multiplication of a generator and a wordis given below:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">left_mul_invshortlex</span>(<span class="hljs-params">reftable, s, w</span>):</span><br>    w = <span class="hljs-built_in">tuple</span>(w)<br>    t = s<br>    k = -<span class="hljs-number">1</span><br>    mu = s<br>    <span class="hljs-keyword">for</span> i, s_i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(w):<br>        <span class="hljs-keyword">if</span> mu <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> w[:k+<span class="hljs-number">1</span>] + (t,) + w[k+<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">elif</span> mu &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> w[:i] + w[i+<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">elif</span> mu &lt; s_i:<br>            t = mu<br>            k = i<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">return</span> w[:k+<span class="hljs-number">1</span>] + (t,) + w[k+<span class="hljs-number">1</span>:]<br></code></pre></td></tr></tbody></table></figure><p>Here <span class="math inline">\(s\)</span> is a generator and <span class="math inline">\(w\)</span> is a word in the normal form of the<em>inverse shortlex ordering</em> (invshortlex). The function returnsthe normal form of <span class="math inline">\(s\cdot w\)</span> also inthe invshortlex ordering. The computations in shortlex can be obtainedby doing computations in invshortlex first and then reverse the resultback.</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>The intermedian step of doing computations in invshortlexordering is mainly for keeping consistent with Casselman’s paper.</p></div><p>Finding the coset representative of a given word for a standardparabolic subgroup is quite straight-forward: let <span class="math inline">\(T\)</span> be the set of generators of thisstandard parabolic subgroup, the pseudocode for the procedure is givenbelow:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">x := w<br>u := 1<br>while l(xt) &lt; l(x) for some t in T<br>    x := xt<br>    u := t<br>end<br><br>return x<br></code></pre></td></tr></tbody></table></figure><p>Where <span class="math inline">\(l(\cdot)\)</span> is the lengthfunction.</p><p>For finite Coxeter groups all positive roots are minimal. For affineCoxeter groups the root system consists of families of parallel affinehyperplanes. In each family there is a pair of minimal roots such thatthe fundamental domain lies between them and all other mirrors in thisfamily are completely screened off by them hence are not minimal. Seethe image for (6, 2, 3) (affine <span class="math inline">\(\widetilde{G}_2\)</span>) for an example:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/roots_623.png" width="600"></p><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://www.math.ubc.ca/~cass/research/pdf/banff.pdf">Automata toperform basic calculations in Coxeter groups, by Bill Casselman</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://www.math.ubc.ca/~cass/research/pdf/cm.pdf">Computation inCoxeter groups I. Multiplication, by Bill Casselman</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://www.math.ubc.ca/~cass/research/pdf/roots.pdf">Computationin Coxeter groups II. Constructing minimal roots, by BillCasselman</a>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>Reflection Groups and Coxeter Groups, by James E.Humphreys.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（六）：Boyd-Maxwell 球堆</title>
      <link href="/coxeter-groups/Boyd-Maxwell.html"/>
      <url>/coxeter-groups/Boyd-Maxwell.html</url>
      
        <content type="html"><![CDATA[<p>本文的内容主要来自 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>)</span> 和<span class="citation" data-cites="Maxwell89">(<a href="#ref-Maxwell89" role="doc-biblioref">Maxwell 1989</a>)</span>，并修复了一些错误。Maxwell在 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>, pp81)</span> 中写到：</p><div class="statement simple plain unnumbered"><p>When <span class="math inline">\(\Gamma\)</span> is hyperbolic, thecone</p><p><span class="math display">\[\{v\in V\mid (v,v)\leq0\}\]</span></p><p>has two connected components (after deleting 0), which are also theequivalent classes for the relation <span class="math display">\[u\simv\Leftrightarrow (u,v)\leq0.\]</span></p></div><p>这显然是错误的，因为如果 <span class="math inline">\(u\)</span> 是light-like 的向量，<span class="math inline">\(u\)</span> 和 <span class="math inline">\(-u\)</span> 属于不同的分支。这个错误导致后面 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>, prop 3.1)</span>的证明需要作一些修改。详情见下面的 <a href="#thm-sphere-packing" title="定理 5.6">定理 5.6</a>。</p><span id="more"></span><h1 id="射影模型">射影模型</h1><p>设 <span class="math inline">\(V=\mathbb{R}^{n+1,1}\)</span> 是 <span class="math inline">\(n+2\)</span> 维 Lorentzian 空间，<span class="math inline">\(\{e_1,e_2,\ldots,e_{n+2}\}\)</span>是一组标准正交基，对应的 Gram 矩阵为 <span class="math inline">\(\left(\begin{smallmatrix}I_{n+1} &amp;\\ &amp;-1\end{smallmatrix}\right)\)</span>。令 <span class="math display">\[e_0=\frac{e_{n+2}-e_{n+1}}{2},\quade_\infty=\frac{e_{n+2}+e_{n+1}}{2}.\]</span> 则 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span> 也构成<span class="math inline">\(V\)</span> 的一组基，内积在这组新基下的 Gram矩阵为 <span class="math display">\[\begin{pmatrix}0&amp;&amp;&amp;-\frac{1}{2}\\&amp;I_n&amp;&amp;\\-\frac{1}{2}&amp;&amp;&amp;0\end{pmatrix}.\]</span>任何 <span class="math inline">\(v,w\in V\)</span> 可以表示为： <span class="math display">\[\begin{aligned}v&amp;=ae_0 + \mathbf{x}+ be_\infty,\\w&amp;=ce_0 + \mathbf{y}+ de_\infty.\end{aligned}\]</span> 其中 <span class="math inline">\(\mathbf{x},\mathbf{y}\in\mathrm{span}\{e_1,\ldots,e_n\},\,a,b\in\mathbb{R}\)</span>。则<span class="math inline">\(v,w\)</span> 之间的内积为 <span class="math display">\[(v,w) = (\mathbf{x}, \mathbf{y}) -\frac{ad+bc}{2}.\]</span> 使用 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span>这组基在处理 <span class="math inline">\(\mathbb{R}^n\)</span>中的球时更方便一些。</p><p>记 <span class="math inline">\([v]\)</span> 为向量 <span class="math inline">\(v\in\mathbb{R}^{n+1,1}\)</span> 在射影空间 <span class="math inline">\(\mathrm{P}(\mathbb{R}^{n+1,1})\)</span>中的等价类。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>定义光锥 (lightcone/null cone) 为 <span class="math display">\[\mathbb{L}^{n+1}= \{v\in\mathbb{R}^{n+1,1}\mid(v,v)=0\}.\]</span> 以及 <span class="math display">\[\mathrm{P}(\mathbb{L}^{n+1})=\{[v]\midv\in\mathbb{L}^{n+1}\setminus\{0\}\}.\]</span> <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span> 是 <span class="math inline">\(\mathbb{L}^{n+1}\)</span>中所有直线组成的集合。</p></div><p>熟知 <span class="math inline">\(\overline{\mathbb{R}^n}=\mathbb{R}^n\cup\{\infty\}\)</span>和 <span class="math inline">\(\mathbb{R}^{n+1}\)</span> 中的单位球<span class="math inline">\(S^n=\{x_1^2+x_2^2+\cdots+x_{n+1}^2=1\}\)</span>在球极投影下是一一对应的（北极点为 <span class="math inline">\(e_{n+1}\)</span>）。</p><figure><img src="/images/coxeter/stereo-projection.svg" width="400" alt="S^2 到 \overline{\mathbb{R}^2} 的球极投影，by Keenan Crane"><figcaption aria-hidden="true"><span class="math inline">\(S^2\)</span>到 <span class="math inline">\(\overline{\mathbb{R}^2}\)</span>的球极投影，by Keenan Crane</figcaption></figure><p>我们将看到，<span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span> 同时与 <span class="math inline">\(\overline{\mathbb{R}^n}\)</span> 和 <span class="math inline">\(S^n\)</span> 一一对应，并且当 <span class="math inline">\(\mathbf{x}\in\overline{\mathbb{R}^n}\)</span> 和<span class="math inline">\(\mathbf{y}\in S^n\)</span>在球极投影下对应时，它们在 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>对应中同一个点。</p><div class="statement simple plain unnumbered"><p><span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span><strong>的第一种参数化表示</strong><br></p><p>我们在 <span class="math inline">\(\{e_1,\ldots,e_{n+2}\}\)</span>这组基下计算。</p><p>设 <span class="math inline">\(\mathbf{y}=y_1e_1+\cdots+y_{n+1}e_{n+1}\in\mathbb{R}^{n+1}\)</span>，则<span class="math display">\[\mathbf{y}\in S_n\Leftrightarrow|\mathbf{y}|=1\Leftrightarrow\mathbf{y}+e_{n+2}\in\mathbb{L}^{n+1}.\]</span> 即我们有一一映射： <span class="math display">\[\begin{aligned}S^n&amp;\mapsto S^n_1\\\mathbf{y}&amp;\mapsto \mathbf{y}+e_{n+2}.\end{aligned}\]</span> 其中 <span class="math inline">\(S^n_1\)</span>是平面 <span class="math inline">\(y_{n+2}=1\)</span> 与 <span class="math inline">\(\mathbb{L}^{n+1}\)</span> 相交给出的截线。由于<span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>中每个元素在 <span class="math inline">\(S^n_1\)</span>中有唯一代表元，所以 <span class="math display">\[\jmath\colon\S^n\to\mathrm{P}(\mathbb{L}^{n+1}): \mathbf{y}\to[\mathbf{y}+e_{n+2}],\]</span> 是一一对应，此即为 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>的第一种参数化表示。</p></div><div id="second-param" class="statement simple plain unnumbered"><p><span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span><strong>的第二种参数化表示</strong><br></p><p>我们在 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span>这组基下计算。对 <span class="math inline">\([v]\in\mathrm{P}(\mathbb{L}^{n+1})\)</span>：</p><ul><li>如果 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(e_0\)</span> 分量不为 0，则 <span class="math inline">\(v\)</span> 形如 <span class="math display">\[v=e_0+ \mathbf{x}+ be_\infty,\quad\mathbf{x}\in\mathrm{span}\{e_1,\ldots,e_n\}.\]</span> 由于 <span class="math inline">\(v\in\mathbb{L}^{n+1}\)</span> 所以 <span class="math inline">\(b=|\mathbf{x}|^2\)</span>，即 <span class="math inline">\(v=e_0 + \mathbf{x}+|\mathbf{x}|^2e_\infty\)</span>。</li><li>如果 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(e_0\)</span> 分量等于 0，则 <span class="math inline">\(v\)</span> 形如 <span class="math display">\[v=\mathbf{x}+be_\infty,\quad\mathbf{x}\in\mathrm{span}\{e_1,\ldots,e_n\}.\]</span> <span class="math inline">\(v\in\mathbb{L}^{n+1}\)</span> 说明 <span class="math inline">\(\mathbf{x}=0\)</span>，从而 <span class="math inline">\([v] = [(0,0,b)]=[e_\infty]\)</span>。</li></ul><p>于是我们可以定义如下从 <span class="math inline">\(\overline{\mathbb{R}^n}\)</span> 到 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span> 的一一对应:<span class="math display">\[\imath(\mathbf{x})=\begin{cases}[e_0 + \mathbf{x}+|\mathbf{x}|^2e_\infty] &amp; \mathbf{x}\in\mathbb{R}^n,\\[e_\infty] &amp; \mathbf{x}= \infty.\end{cases}\]</span> 此即为 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>的第二种参数化表示。</p></div><figure><img src="/images/coxeter/Horosphere.svg" class="fig" width="500" alt="红色的圆是超平面 (\cdot, e_{n+2})=1 与光锥的截线，可以通过将 S^n 沿着 e_{n+2} 平移一个单位得到；\overline{\mathbb{R}^n} 对应蓝色的 horosphere，它是超平面 (\cdot, e_0)=\frac{1}{2} 与光锥的截线。e_\infty 不在 horosphere 上"><figcaption aria-hidden="true">红色的圆是超平面 <span class="math inline">\((\cdot, e_{n+2})=1\)</span>与光锥的截线，可以通过将 <span class="math inline">\(S^n\)</span> 沿着<span class="math inline">\(e_{n+2}\)</span> 平移一个单位得到；<span class="math inline">\(\overline{\mathbb{R}^n}\)</span> 对应蓝色的horosphere，它是超平面 <span class="math inline">\((\cdot,e_0)=\frac{1}{2}\)</span> 与光锥的截线。<span class="math inline">\(e_\infty\)</span> 不在 horosphere 上</figcaption></figure><p>设 <span class="math inline">\(\mathbf{y}=y_1e_1+\cdots+y_{n+1}e_{n+1}\inS^n\)</span>，<span class="math inline">\(\mathbf{y}\)</span> 在以 <span class="math inline">\(e_{n+1}\)</span> 为北极的球极投影下对应的点是<span class="math display">\[\mathbf{x}=\begin{cases}\sum\limits_{i=1}^n\dfrac{y_i}{1-y_{n+1}}e_i &amp; y_{n+1}\ne1,\\\infty &amp; y_{n+1}=1.\end{cases}\]</span> 我们来验证 <span class="math inline">\(\jmath(\mathbf{y})=\imath(\mathbf{x})\)</span>，即：<span class="math display">\[[\mathbf{y}+ e_{n+2}] = \begin{cases}[e_0 +\mathbf{x}+ |\mathbf{x}|^2e_\infty] &amp; y_{n+1}\ne1\\[e_\infty] &amp; y_{n+1}=1.\end{cases}.\]</span></p><ul><li><p><span class="math inline">\(y_{n+1}=1\)</span> 时 <span class="math inline">\(\mathbf{y}=e_{n+1}\)</span> 从而 <span class="math inline">\(\mathbf{y}+e_{n+2}=e_{n+1}+e_{n+2}=2e_\infty\)</span>，显然与 <span class="math inline">\(e_\infty\)</span> 射影等价。</p></li><li><p><span class="math inline">\(y_{n+1}\ne 1\)</span> 时，由 <span class="math inline">\(\mathbf{y}\in S^n\)</span> 可得 <span class="math inline">\(\sum_{i=1}^ny_i^2=1-y_{n+1}^2\)</span>，从而 <span class="math display">\[|\mathbf{x}|^2=\frac{\sum_{i=1}^ny_i^2}{(1-y_{n+1})^2}= \frac{1+y_{n+1}}{1-y_{n+1}}.\]</span> 把 <span class="math inline">\(\mathbf{y}+e_{n+2}\)</span> 转化为 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span>这组基下的表示： <span class="math display">\[\mathbf{y}+e_{n+2} =(1-y_{n+1})e_0+\sum_{i=1}^ny_ie_i + (1+y_{n+1})e_\infty.\]</span> 从而<span class="math display">\[[\mathbf{y}+e_{n+2}] =\left[e_0+\sum_{i=1}^n\frac{y_i}{1-y_{n+1}}e_i+\frac{1+y_{n+1}}{1-y_{n+1}}e_\infty\right] = [e_0 + \mathbf{x}+|\mathbf{x}|^2e_\infty].\]</span></p></li></ul><h1 id="球面">球面</h1><p>记 <span class="math inline">\(\mathcal{S}=\{v\in\mathbb{R}^{n+1,1}\mid(v,v)=1\}\)</span> 是所有 space-like 的单位向量组成的集合。我们来建立<span class="math inline">\(\mathbb{R}^n\)</span> 中的球（包括超平面）和<span class="math inline">\(\mathcal{S}\)</span> 之间的一一对应。</p><p>设 <span class="math inline">\(B(\mathbf{a},r)=\{\mathbf{x}\in\mathbb{R}^n\mid|x-\mathbf{a}|=|r|\}\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span> 中以 <span class="math inline">\(\mathbf{a}\)</span> 为中心，半径为 <span class="math inline">\(r\ne 0\)</span> 的球，它将 <span class="math inline">\(\mathbb{R}^n\)</span>分成有界和无界两个连通分支。我们允许 <span class="math inline">\(r\)</span> 是负数以区分 <span class="math inline">\(B\)</span> 的内部和外部：</p><ul><li><span class="math inline">\(r&gt;0\)</span> 时 <span class="math inline">\(B\)</span> 的内部是满足 <span class="math inline">\(|\mathbf{x}-\mathbf{a}|&lt; r\)</span>的有界分支；</li><li><span class="math inline">\(r&lt;0\)</span> 时 <span class="math inline">\(B\)</span> 的内部是满足 <span class="math inline">\(|\mathbf{x}-\mathbf{a}|&gt;|r|\)</span>的无界分支。</li></ul><p>把 <span class="math inline">\(\mathbf{a}\)</span> 看作 <span class="math inline">\(\mathrm{span}\{e_1,\ldots,e_n\}\cong\mathbb{R}^n\)</span>中的点，记 <span class="math display">\[k = \frac{e_0 + \mathbf{a}+(|\mathbf{a}|^2 - r^2)e_\infty}{r}.\]</span> 不难验证 <span class="math inline">\((k,k)=1\)</span>，因此 <span class="math inline">\(k\in\mathcal{S}\)</span>。</p><p>对 <span class="math inline">\(\mathbf{x}\in\mathbb{R}^n\)</span>，根据 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span> 的 <a href="#second-param" title="第二种">第二种</a> 参数化表示，有 <span class="math display">\[(\imath(\mathbf{x}),k)=\frac{r^2-|\mathbf{x}-\mathbf{a}|^2}{2r}.\]</span></p><p>于是：</p><ul><li><span class="math inline">\(\mathbf{x}\in B\)</span> 当且仅当 <span class="math inline">\((\imath(\mathbf{x}),k)=0\)</span>；</li><li><span class="math inline">\(\mathbf{x}\)</span> 落在 <span class="math inline">\(B\)</span> 的内部当且仅当 <span class="math inline">\((\imath(\mathbf{x}),k)&gt;0\)</span>。</li></ul><p>鉴于此，我们也把 <span class="math inline">\(B\)</span> 的内部叫做<span class="math inline">\(B\)</span>的<strong>正半空间</strong>，<span class="math inline">\(k\)</span>是指向 <span class="math inline">\(B\)</span>的正半空间的单位法向量。</p><p>注意到 <span class="math inline">\(\imath(\mathbf{x})\)</span> 和<span class="math inline">\(\jmath(\mathbf{x})\)</span>只差一个正的倍数，所以 <span class="math inline">\(\mathbf{x}\inB\)</span> 等价于 <span class="math inline">\((\jmath(\mathbf{x}),k)=0\)</span>。<span class="math inline">\(V\)</span> 中所有形如 <span class="math inline">\((\jmath(\mathbf{x}),k)=0\,(\mathbf{x}\in\mathbb{R}^n)\)</span>的点构成 <span class="math inline">\(S^n_1\)</span> 与超平面 <span class="math inline">\(k^\bot\)</span> 的截线。</p><p>设 <span class="math inline">\(H(\mathbf{n},d)=\{\mathbf{x}\in\mathbb{R}^n\mid(\mathbf{x},\mathbf{n})=d\}\)</span> 是超平面，<span class="math inline">\(\mathbf{n}\)</span> 是 <span class="math inline">\(B\)</span> 的单位法向量。我们将 <span class="math inline">\(H(\mathbf{n},d)\)</span> 对应到 <span class="math display">\[k=\mathbf{n}+ 2d e_\infty.\]</span>不难验证同样有 <span class="math inline">\(k\in\mathcal{S}\)</span>，并且对 <span class="math inline">\(\mathbf{x}\in\mathbb{R}^n\)</span> 有 <span class="math display">\[(\imath(\mathbf{x}),k)=(\mathbf{x},\mathbf{n})-d.\]</span>于是：</p><ul><li><span class="math inline">\(\mathbf{x}\in B\)</span> 当且仅当 <span class="math inline">\((\imath(\mathbf{x}),k)=0\)</span>；</li><li><span class="math inline">\(\mathbf{x}\)</span> 属于 <span class="math inline">\(B\)</span> 的正半空间当且仅当 <span class="math inline">\((\imath(\mathbf{x}),k)&gt;0\)</span>。</li></ul><p>反过来，任意 <span class="math inline">\(k\in\mathcal{S}\)</span>都唯一对应 <span class="math inline">\(\mathbb{R}^n\)</span>中的某个球或者超平面。具体方法是将 <span class="math inline">\(k\)</span> 表示为 <span class="math display">\[k=be_\infty+\mathbf{a}+ce_\infty\in\mathcal{S},\quadb,c\in\mathbb{R}.\]</span> 并根据 <span class="math inline">\(b\)</span>是否等于 0 将 <span class="math inline">\(k\)</span> 对应为球 <span class="math inline">\(B(\mathbf{a}/b ,1/b)\)</span> 或者超平面 <span class="math inline">\(H(\mathbf{a}, c/2)\)</span> 即可。</p><h1 id="球面的-seperation">球面的 seperation</h1><p>设 <span class="math inline">\(B_1(\mathbf{a}_1,r_1),\,B_2(\mathbf{a}_2,r_2)\)</span>是两个球，它们对应的 <span class="math inline">\(\mathcal{S}\)</span>-向量分别是 <span class="math display">\[\begin{aligned}k_1&amp;=\frac{1}{r_1}e_0 + \frac{\mathbf{a}_1}{r_1} +\frac{|\mathbf{a}_1|^2-r_1^2}{r_1}e_\infty,\\k_2&amp;=\frac{1}{r_2}e_0 + \frac{\mathbf{a}_2}{r_2} +\frac{|\mathbf{a}_2|^2-r_2^2}{r_2}e_\infty.\\\end{aligned}.\]</span> 直接计算验证可以得到 <span class="math display">\[(k_1,k_2)=\frac{r_1^2+r_2^2 -|\mathbf{a}_1-\mathbf{a}_2|^2}{2r_1r_2}.\]</span> 我们称内积 <span class="math inline">\((k_1,k_2)\)</span> 为 <span class="math inline">\(B_1\)</span> 和 <span class="math inline">\(B_2\)</span> 的 <strong>seperation</strong>。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span> <span class="statement-info">(<span class="citation" data-cites="ratcliffe">(见 <a href="#ref-ratcliffe" role="doc-biblioref">Ratcliffe 2006, vol. 149, sec.3.2</a>)</span>)</span>：</span><span class="statement-spah"> </span>在Lorentzinian 内积下，两个 space-like 的单位向量 <span class="math inline">\(k_1,k_2\)</span> 之间的内积有如下解释：</p><ol type="1"><li>若 <span class="math inline">\(|(k_1,k_2)|\leq1\)</span>，则 <span class="math inline">\((k_1,k_2)=\cos\theta\)</span>，其中 <span class="math inline">\(\theta\)</span> 是两条以 <span class="math inline">\(x,y\)</span> 为切向量的测地线之间的夹角；</li><li>若 <span class="math inline">\(|(k_1,k_2)|&gt;1\)</span>，则 <span class="math inline">\((k_1,k_2)=\pm\cosh\eta\)</span>，其中 <span class="math inline">\(\eta\)</span> 是以 <span class="math inline">\(x,y\)</span>为法向量的两个超平面之间的双曲距离。</li></ol></div><p>根据内积 <span class="math inline">\((k_1,k_2)\)</span>的大小，可以判断球体之间的位置关系：</p><ol type="1"><li>当 <span class="math inline">\(|(k_1,k_2)|\leq1\)</span>时两球相交或者相切，这时 <span class="math inline">\((k_1,k_2)=\cos\theta\)</span>，<span class="math inline">\(\theta\)</span>是两个球面交点处的内法向量夹角（用外法向量也可以，因为同时将内法向量变成外法向量，夹角的余弦不变）。特别地，<span class="math inline">\((k_1,k_2)=-1\)</span> 时两球外切，<span class="math inline">\((k_1,k_2)=1\)</span> 时两球内切。</li><li>当 <span class="math inline">\(|(k_1,k_2)|&gt;1\)</span>时两球既不相交也不相切，这时 <span class="math inline">\(|(k_1,k_2)|=\cosh\eta\)</span>，<span class="math inline">\(\eta\)</span> 是 <span class="math inline">\(k_1,k_2\)</span>对应的双曲空间中测地线的距离。两球在 <span class="math inline">\((k_1,k_2)&lt;-1\)</span> 时没有公共的内部，在<span class="math inline">\((k_1,k_2)&gt;1\)</span>时一个完全包含另一个。</li></ol><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=\cos\theta(\ell_1,\ell_2)\)</span></td><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=\cosh d(\ell_1,\ell_2)\)</span></td></tr><tr class="even"><td style="text-align: center;"><img src="/images/coxeter/image0.jpg" width="150"></td><td style="text-align: center;"><img src="/images/coxeter/image1.jpg" width="150"></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=-\cosh d(\ell_1,\ell_2)\)</span></td><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=-\cosh d(\ell_1,\ell_2)\)</span></td></tr><tr class="even"><td style="text-align: center;"><img src="/images/coxeter/image2.jpg" width="150"></td><td style="text-align: center;"><img src="/images/coxeter/image3.jpg" width="150"></td></tr></tbody></table><p>上述结论同样适用于球面和超平面的情形。例如设 <span class="math inline">\(B_1\)</span> 是球面，<span class="math inline">\(B_2\)</span> 是超平面，<span class="math inline">\(k_2=\mathbf{n}+2de_\infty\)</span>，则 <span class="math display">\[(k_1,k_2)=\frac{(\mathbf{a}_1,\mathbf{n})-d}{r_1}.\]</span>此时： + 若 <span class="math inline">\(B_1,B_2\)</span> 相交，则 <span class="math inline">\((k_1,k_2)\)</span> 等于 <span class="math inline">\(B_1\)</span> 在交点处的内法向量和 <span class="math inline">\(B_2\)</span> 的法向量 <span class="math inline">\(\mathbf{n}\)</span> 夹角的余弦； + 若不相交，则<span class="math inline">\((k_1,k_2)\)</span> 是 <span class="math inline">\(B_1\)</span> 的球心到 <span class="math inline">\(B_2\)</span> 的有向距离除以 <span class="math inline">\(r_1\)</span>。</p><p>类似地当 <span class="math inline">\(B_1,B_2\)</span>都是超平面时，<span class="math inline">\((k_1,k_2)=(\mathbf{n}_1,\mathbf{n}_2)\)</span>是它们法向量夹角的余弦。</p><div id="suff-for-disjoint" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(B_1,B_2\)</span> 是两个球，且 <span class="math inline">\(B_1,B_2\)</span> 的内部不相交。设 <span class="math inline">\(k_1,k_2\)</span> 分别是它们对应的 space-like的单位向量，则 <span class="math inline">\((k_1,k_2)\leq-1\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个命题反过来是不对的。</p></div><p><strong>证明</strong>：<span class="math inline">\(B_1\)</span> 和<span class="math inline">\(B_2\)</span> 内部不相交有如下几种可能：</p><ol type="1"><li><span class="math inline">\(B_1,B_2\)</span> 都是球，半径 <span class="math inline">\(r_1,r_2\)</span> 都大于 0，并且 <span class="math inline">\(r_1+r_2 \geq|\mathbf{a}_1-\mathbf{a}_2|\)</span>。</li><li><span class="math inline">\(B_1,B_2\)</span> 都是球，半径 <span class="math inline">\(r_1&gt;0,\, r_2&lt;0\)</span>，且 <span class="math inline">\(B_1\)</span> 位于 <span class="math inline">\(B_2\)</span> 另一侧的有界区域，即 <span class="math inline">\(-r_2-r_1\geq|\mathbf{a}_1-\mathbf{a}_2|\)</span>。</li><li><span class="math inline">\(B_1\)</span> 是球，其半径 <span class="math inline">\(r_1&gt;0\)</span>；<span class="math inline">\(B_2\)</span> 是超平面，且 <span class="math inline">\(B_1\)</span> 位于 <span class="math inline">\(B_2\)</span> 的负半空间，从而其球心 <span class="math inline">\(\mathbf{a}_1\)</span> 到 <span class="math inline">\((\mathbf{n},\mathbf{x})=d\)</span> 的有向距离<span class="math inline">\(\leq-r_1\)</span>，即 <span class="math inline">\((\mathbf{a}_1,\mathbf{n})-d\leq-r_1\)</span>。</li><li><span class="math inline">\(B_1,B_2\)</span>是互相平行的超平面，且法向量相反的，即 <span class="math inline">\((\mathbf{n}_1,\mathbf{n}_2)=-1\)</span>。</li></ol><p>不难验证这些都可以推出 <span class="math inline">\((k_1,k_2)\leq-1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><h1 id="球的反演">球的反演</h1><p>这一节读者可以参考 <span class="citation" data-cites="Iversen_1992">(<a href="#ref-Iversen_1992" role="doc-biblioref">Iversen 1992, sec. I.7</a>)</span>。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义4.1</span>.</span><span class="statement-spah"> </span>关于球 <span class="math inline">\(B(\mathbf{a}, r)\)</span> 的反演定义为 <span class="math display">\[\begin{aligned}\tau\colon\ \overline{\mathbb{R}^n}&amp;\mapsto\overline{\mathbb{R}^n}\\\tau(\mathbf{x})&amp;=\frac{r^2}{|\mathbf{x}-\mathbf{a}|^2}(\mathbf{x}-\mathbf{a})+\mathbf{a}.\end{aligned}\]</span></p></div><p><span class="math inline">\(\tau\)</span> 是 <span class="math inline">\(\overline{\mathbb{R}^n}\)</span> 中关于球面镜<span class="math inline">\(B\)</span> 的反射，它保持 <span class="math inline">\(B\)</span> 的表面不动，将 <span class="math inline">\(B\)</span> 的内部映射为外部（反之亦然），并且<span class="math inline">\(\tau^2=1\)</span>。</p><p><img src="/images/coxeter/sphere-inversion.svg" class="fig" width="400"></p><p>我们来说明 <span class="math inline">\(\tau\)</span> 可以实现为 <span class="math inline">\(\mathrm{P}(\mathbb{R}^{n+1,1})\)</span>中的射影正交变换。</p><p>设 <span class="math inline">\(B(\mathbf{a},r)\)</span> 对应 <span class="math inline">\(k\in\mathcal{S}\)</span>，考察以 <span class="math inline">\(k\)</span> 为法向量的镜面反射 <span class="math display">\[\begin{aligned}\rho\colon\ \mathbb{R}^{n+1,1}&amp;\mapsto\mathbb{R}^{n+1,1}\\\rho(v) &amp;= v - 2(v,k)k.\end{aligned}\]</span> 则 <span class="math inline">\(\rho\)</span> 是<span class="math inline">\(\mathbb{R}^{n+1,1}\)</span>上的正交变换，从而也给出 <span class="math inline">\(\mathrm{P}(\mathbb{R}^{n+1,1})\)</span>上的射影变换。</p><p>注意 <span class="math inline">\(\rho\)</span>保持光锥的两个分支不变，即 <span class="math inline">\(\rho(\mathcal{Q}_\pm)\subset\mathcal{Q}_\pm\)</span>。这是因为，如果<span class="math inline">\(v\in\mathcal{Q}_+\)</span>，则 <span class="math inline">\((v,v)\leq0\)</span>，并且 <span class="math inline">\((v, \rho(v)) = (v,v) -2(v,k)^2\leq0\)</span>。若不等号严格成立，自然有 <span class="math inline">\(v\sim\rho(v)\)</span>。若等号成立，则 <span class="math inline">\((v,v)=(v,k)=0\)</span>，从而 <span class="math inline">\(\rho(v)=v\)</span>。</p><p>我们来计算 <span class="math inline">\(\rho\)</span> 作用在 <span class="math inline">\(\imath(\mathbf{x})\,(\mathbf{x}\in\mathbb{R}^n)\)</span>上的效果：（注意 <span class="math inline">\((\imath(\mathbf{x}),k)=\frac{r^2-|\mathbf{x}-\mathbf{a}|^2}{r}\)</span>）<span class="math display">\[\begin{aligned}\begin{pmatrix}1\\\mathbf{x}\\ |\mathbf{x}|^2\end{pmatrix}&amp;\xrightarrow{\rho}\begin{pmatrix}1\\\mathbf{x}\\ |\mathbf{x}|^2\end{pmatrix}-\frac{r^2-|\mathbf{x}-\mathbf{a}|^2}{r}\begin{pmatrix}\frac{1}{r}\\\frac{\mathbf{a}}{r}\\\frac{|\mathbf{a}|-r^2}{r}\end{pmatrix}\\&amp;=\begin{pmatrix}\frac{|\mathbf{x}-\mathbf{a}|^2}{r^2}\\\mathbf{x}+\left(\frac{|\mathbf{x}-\mathbf{a}|^2-r^2}{r^2}\right)\mathbf{a}\\\ast \end{pmatrix}\\&amp;\stackrel{+}{\sim}\begin{pmatrix}1\\\mathbf{a}+\frac{r^2}{|\mathbf{x}-\mathbf{a}|^2}(\mathbf{x}-\mathbf{a})\\\ast \end{pmatrix}\\&amp;=\begin{pmatrix}1\\\tau(\mathbf{x})\\ |\tau(\mathbf{x})|^2\end{pmatrix}.\end{aligned}\]</span> 这里我们不用关心 <span class="math inline">\(\ast\)</span> 是什么，中间的 <span class="math inline">\(\stackrel{+}{\sim}\)</span>表示两个向量<strong>正</strong>射影等价。</p><p>于是我们有如下的交换图：</p><p><span class="math display">\[\require{amsCd}\begin{CD}\overline{\mathbb{R}^n}@&gt;{\imath}&gt;&gt;\mathrm{P}(\mathbb{L}^{n+1})\\@V{\tau}VV  @VV{\rho}V \\\overline{\mathbb{R}^n}@&gt;{\imath}&gt;&gt;\mathrm{P}(\mathbb{L}^{n+1})\end{CD}\]</span></p><p>进一步，将任意球 <span class="math inline">\(B'\)</span> 关于<span class="math inline">\(B\)</span> 作反演也可以通过 <span class="math inline">\(\rho\)</span> 来计算。设 <span class="math inline">\(k'\)</span> 是 <span class="math inline">\(B'\)</span> 对应的 space-like 的单位向量，则<span class="math inline">\(\rho(k')\)</span> 也是 space-like的单位向量，从而 <span class="math inline">\(\rho(k')\)</span>对应某个球 <span class="math inline">\(B''\)</span>。根据上面的交换图有 <span class="math inline">\(\rho\imath=\imath\tau\)</span>，于是 <span class="math display">\[\mathbf{x}\in B'\Leftrightarrow(\imath(\mathbf{x}), k')=0\Leftrightarrow(\rho\imath(\mathbf{x}), \rho(k'))=0\Leftrightarrow(\imath\tau(\mathbf{x}), \rho(k'))=0\Leftrightarrow \tau(\mathbf{x})\in B''.\]</span> 即关于 <span class="math inline">\(B\)</span> 的反演 <span class="math inline">\(\tau\)</span> 将 <span class="math inline">\(B'\)</span> 映射为 <span class="math inline">\(B''\)</span>。</p><h1 id="双曲球堆">双曲球堆</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.1</span>.</span><span class="statement-spah"> </span>如果非空集合<span class="math inline">\(\mathcal{P}\subset \mathcal{S}\)</span>满足对任意 <span class="math inline">\(k\nek'\in\mathcal{P}\)</span> 有 <span class="math inline">\((k,k')\leq -1\)</span>，则称 <span class="math inline">\(\mathcal{P}\)</span>是一个<strong>球堆</strong>。</p></div><p>如果 <span class="math inline">\(\mathcal{P}\)</span> 形如 <span class="math inline">\(\mathcal{P}=\{k,-k\}\)</span>，就称 <span class="math inline">\(\mathcal{P}\)</span>是平凡的，因为它由一个球的内部和外部组成。否则就称 <span class="math inline">\(\mathcal{P}\)</span> 是非平凡球堆。<span class="math inline">\(-\mathcal{P}=\{-k\mid k\in\mathcal{P}\}\)</span>也是球堆，它是通过翻转 <span class="math inline">\(\mathcal{P}\)</span>中每个球的内部和外部得到的。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.2</span>.</span><span class="statement-spah"> </span>记超平面 <span class="math inline">\(\{v\in V\mid (v,e_{n+2})=1\}\)</span> 与 <span class="math inline">\(\mathcal{Q}_+\)</span> 的“截面”为 <span class="math display">\[\mathcal{H}= \{v\in \mathcal{Q}_+\mid (v,e_{n+2})=1\}.\]</span> 给定 <span class="math inline">\(k\inS\)</span>，定义球帽 <span class="math display">\[C_k =\{v\in\mathcal{H}\mid (v,k)\geq0\}.\]</span></p></div><p>根据定义球帽总是位于同一个分支 <span class="math inline">\(\mathcal{Q}_+\)</span> 中，因此 <span class="math inline">\(u\sim v\)</span> 对所有 <span class="math inline">\(u\in C_k,v\in C_{k'}\)</span> 成立。</p><p>下面的引理告诉我们，如果 <span class="math inline">\(v\)</span>严格落在 <span class="math inline">\(C_k\)</span>的内部，则我们可以稍微“扰动” <span class="math inline">\(v\)</span>，得到无限多个落在 <span class="math inline">\(C_k\)</span> 中的 time-like 的向量。</p><div id="perturb" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span> 是球堆，<span class="math inline">\(k\in\mathcal{P}\)</span>。设 <span class="math inline">\(v\in C_k\)</span> 满足 <span class="math inline">\((v,k)=a&gt;0\)</span>。则对任何 <span class="math inline">\(0&lt;t\leq a\)</span>，<span class="math inline">\(u=v-tk\)</span> 都满足：</p><ol type="1"><li><span class="math inline">\(u\)</span> 是 time-like 的并且 <span class="math inline">\(u\sim v\)</span>；</li><li><span class="math inline">\((u,k)&gt;0\)</span>。</li></ol><p>从而 <span class="math inline">\(u\)</span> 的某个正倍数 <span class="math inline">\(u'\in C_k\)</span>。进一步，如果 <span class="math inline">\(k'\ne k\in\mathcal{P}\)</span> 满足 <span class="math inline">\(v\in C_k\cap C_{k'}\)</span>，则同样有 <span class="math inline">\(u'\in C_k\cap C_{k'}\)</span>。</p></div><p><strong>证明</strong>：直接计算可得：</p><p><span class="math display">\[\begin{aligned}(u,u)&amp;=(v,v)-2at + t^2 \leq -2at+t^2 &lt; 0,\\(u,v)&amp;=(v,v)-at \leq at&lt;0.\end{aligned}\]</span> 即 <span class="math inline">\(u\)</span> 是time-like 的并且 <span class="math inline">\(u\sim v\)</span>，从而<span class="math inline">\(u\)</span> 的某个正倍数 <span class="math inline">\(u'\in \mathcal{H}\)</span>。又因为 <span class="math inline">\((u,k)=a-t\geq0\)</span>，所以也有 <span class="math inline">\((u',k)\geq0\)</span>，从而 <span class="math inline">\(u'\in C_k\)</span>。</p><p>如果存在 <span class="math inline">\(k'\nek\in\mathcal{P}\)</span> 使得 <span class="math inline">\(v\inC_{k'}\)</span>，则 <span class="math inline">\((v,k')\geq0\)</span>，从而 <span class="math display">\[(u,k')=(v,k') - t(k,k')\geqt&gt;0.\]</span> 于是 <span class="math inline">\((u',k')\geq0\)</span>，所以 <span class="math inline">\(u'\)</span> 也属于 <span class="math inline">\(C_{k'}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="contain-time-like" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span> 是球堆且 <span class="math inline">\(k_1\nek_2\in\mathcal{P}\)</span>。则以下三点等价：</p><ol type="1"><li><span class="math inline">\(|C_{k_1}\capC_{k_2}|&gt;1\)</span>；</li><li>存在 <span class="math inline">\(v\in C_{k_1}\cap C_{k_2}\)</span>且 <span class="math inline">\(v\)</span> 是 time-like 的；</li><li>存在 <span class="math inline">\(v\in C_{k_1}\cap C_{k_2}\)</span>使得不等式 <span class="math inline">\((v,k_1)&gt;0\)</span> 和 <span class="math inline">\((v,k_2)&gt;0\)</span> 至少有一个成立。</li></ol></div><p><strong>证明</strong>：首先由 <span class="math inline">\((k_1+k_2,k_1+k_2)=2+2(k_1,k_2)\leq0\)</span> 可知<span class="math inline">\(k_1+k_2\)</span> 是 time/light-like 的。</p><p><span class="math inline">\(1\Rightarrow 2\)</span>：设 <span class="math inline">\(u\ne v\in C_{k_1}\cap C_{k_2}\)</span>，则 <span class="math inline">\(u,v\)</span> 不共线，从而 <span class="math inline">\((u,v)&lt;0\)</span>。记 <span class="math inline">\(z=u+v\)</span>，<span class="math inline">\(z\)</span> 是 time-like 的，并且 <span class="math inline">\(z\)</span> 的某个正倍数 <span class="math inline">\(z'\)</span> 属于 <span class="math inline">\(\mathcal{H}\)</span>。<span class="math inline">\(z'\)</span> 即为所求。</p><p><span class="math inline">\(2\Rightarrow 3\)</span>：设 <span class="math inline">\(v\in C_{k_1}\cap C_{k_2}\)</span> 是 time-like的，则 <span class="math inline">\((v,k_1)\geq0,\,(v,k_2)\geq0\)</span>。我们断言这两个不等式至少有一个是严格的。若不然，则<span class="math inline">\((v,k_1+k_2)=0\)</span>。然而 <span class="math inline">\(k_1+k_2\)</span> 是 time/light-like 的，而 <span class="math inline">\(v\)</span> 是 time-like 的，这不可能。</p><p><span class="math inline">\(3\Rightarrow 1\)</span>：不妨设 <span class="math inline">\(a=(v,k_1)&gt;0\)</span>。根据 <a href="#perturb" title="引理 5.3">引理 5.3</a>，对任何 <span class="math inline">\(t\in(0,a]\)</span> 我们都可以得到对应的 <span class="math inline">\(u'\in C_k\capC_{k'}\)</span>。不难看到不同的 <span class="math inline">\(t\)</span> 给出的 <span class="math inline">\(u'\)</span> 互不相同，于是 <span class="math inline">\(|C_{k_1}\cap C_{k_2}|=\infty &gt; 1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="disjoint-pair" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.5</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span> 是球堆且 <span class="math inline">\(k_1\ne k_2\in\mathcal{P}\)</span>，则集合 <span class="math inline">\(C_{k_1}\cap C_{k_2}\)</span> 和 <span class="math inline">\(C_{-k_1}\cap C_{-k_2}\)</span>中必有一个至多只包含一个点。并且当这两个集合中的某个恰好只含一个点时，此点与<span class="math inline">\(k_1+k_2\)</span> 共线，并且有 <span class="math inline">\((k_1,k_2)=-1\)</span> 成立。</p></div><p><strong>证明</strong>： 若 <span class="math inline">\(C_{k_1}\capC_{k_2}\)</span> 和 <span class="math inline">\(C_{-k_1}\capC_{-k_2}\)</span> 均不为空，取 <span class="math inline">\(u\inC_{k_1}\cap C_{k_2}\)</span>，<span class="math inline">\(v\inC_{-k_1}\cap C_{-k_2}\)</span>，则 <span class="math display">\[(u,k_1+k_2)\geq0,\quad (v,k_1+k_2)\leq0.\]</span>如果上面两个不等号都是严格成立的，则 <span class="math inline">\(u\not\sim k_1+k_2\)</span> 但是 <span class="math inline">\(v\sim k_1+k_2\)</span>，这与 <span class="math inline">\(u\sim v\)</span>矛盾。所以至少有一个等号是成立的，即 <span class="math inline">\(u,v\)</span> 之中必有一个与 <span class="math inline">\(k_1+k_2\)</span> 共线，并且 <span class="math inline">\(k_1+k_2\)</span> 是 light-like 的向量。由此可得<span class="math inline">\((k_1,k_2)=-1\)</span> 并且 <span class="math inline">\(|C_{k_1}\cap C_{k_2}|\leq1\)</span> 和 <span class="math inline">\(|C_{-k_1}\cap C_{-k_2}|\leq1\)</span>中至少有一个成立。</p><p>如果这两个集合，不妨设为 <span class="math inline">\(C_{k_1}\capC_{k_2}\)</span>，恰好只有一个点。记这个点为 <span class="math inline">\(u\)</span>。如果 <span class="math inline">\(u\)</span> 与 <span class="math inline">\(k_1+k_2\)</span> 不共线的话，则必有 <span class="math inline">\((u,k_1+k_2)&gt;0\)</span>，从而 <span class="math inline">\((u,k_1)\)</span> 和 <span class="math inline">\((u,k_2)\)</span> 中至少有一个大于 0。根据 <a href="#contain-time-like" title="引理 5.4">引理 5.4</a> 有 <span class="math inline">\(|C_k\cap C_{k'}|=\infty\)</span>，矛盾。所以<span class="math inline">\(u\)</span> 必然与 <span class="math inline">\(k_1+k_2\)</span> 共线。<span class="math inline">\(\blacksquare\)</span></p><div id="thm-sphere-packing" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.6</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span>是非空集合，则下面两点是等价的：</p><ol type="1"><li><span class="math inline">\(\mathcal{P}\)</span>是一个非平凡的球堆。</li><li>对 <span class="math inline">\(\mathcal{P}\)</span> 或者 <span class="math inline">\(-\mathcal{P}\)</span> 之一，其包含的任何两个球帽<span class="math inline">\(C_k\)</span> 和 <span class="math inline">\(C_{k'}\)</span> 至多有一个公共点。</li></ol></div><p><strong>证明</strong>：</p><p>1 <span class="math inline">\(\Rightarrow\)</span> 2：根据 <a href="#disjoint-pair" title="引理 5.5">引理 5.5</a>，不妨设 <span class="math inline">\(k_1,k_2\in\mathcal{P}\)</span> 使得 <span class="math inline">\(|C_{k_1}\capC_{k_2}|\leq1\)</span>，我们要证明对任何 <span class="math inline">\(k\ne k'\in\mathcal{P}\)</span> 同样有 <span class="math inline">\(|C_k\cap C_{k'}|\leq1\)</span>。如果 <span class="math inline">\(\{k,k'\}=\{k_1,k_2\}\)</span>结论显然成立，所以不妨设 <span class="math inline">\(k\notin\{k_1,k_2\}\)</span>。用反证法，若 <span class="math inline">\(|C_k\cap C_{k'}|&gt;1\)</span>，根据 <a href="#contain-time-like" title="引理 5.4">引理 5.4</a>，存在 time-like的向量 <span class="math inline">\(v\in C_k\cap C_{k'}\)</span>。令<span class="math inline">\(w=k_1-(k_1,k_2)k_2\)</span>，则有 <span class="math display">\[(w,w)=1-(k_1,k_2)^2\leq0,\quad (w, k)&lt;0,\quad(w, k')\leq0.\]</span> 我们来证明 <span class="math inline">\(v\simw\)</span>。若如此，则 <span class="math inline">\(w\)</span>的某个正倍数 <span class="math inline">\(w'\in\mathcal{H}\)</span>，并且 <span class="math display">\[(w',-k)&gt;0,\quad(w',-k')\geq0.\]</span> 从而由 <a href="#contain-time-like" title="引理 5.4">引理 5.4</a> 有 <span class="math inline">\(|C_{-k}\capC_{-k'}|&gt;1\)</span>，与 <a href="#disjoint-pair" title="引理 5.5">引理 5.5</a> 矛盾。由于 <span class="math inline">\(v\)</span> 是 time-like 的，我们只要证明有 <span class="math inline">\((v,w)\leq0\)</span> 成立即可。利用 <span class="math display">\[(v,w)=(v, k_1) - (v,k_2)(k_1,k_2) =(v-(v,k_2)k_2, k_1).\]</span> 并记 <span class="math inline">\(u=v-(v,k_2)k_2\)</span>，问题转化为证明 <span class="math inline">\((u,k_1)\leq0\)</span>。计算可得 <span class="math display">\[\begin{aligned}(u,k_2) &amp;= (v,k_2) - (v,k_2)(k_2,k_2)=0,\\(u,u)&amp;=(u,v)-(v,k_2)(u,k_2) = (u,v),\\(u,v)&amp;=(v,v)-(v,k_2)^2 \leq (v,v)&lt;0.\end{aligned}\]</span> 即 <span class="math inline">\(u\)</span> 是 time-like 的且<span class="math inline">\(u\sim v\)</span>。于是 <span class="math inline">\(u\)</span> 的某个正倍数 <span class="math inline">\(u'\)</span> 属于 <span class="math inline">\(\mathcal{H}\)</span>。如果 <span class="math inline">\((u,k_1)&gt;0\)</span> 的话则 <span class="math inline">\(u'\)</span> 是 time-like 的向量且满足 <span class="math inline">\((u',k_1)&gt;0\)</span> 和 <span class="math inline">\((u',k_2)=0\)</span>，从而 <span class="math inline">\(u'\in C_{k_1}\cap C_{k_2}\)</span>。但根据 <a href="#contain-time-like" title="引理 5.4">引理 5.4</a> 这会导致 <span class="math inline">\(|C_{k_1}\cap C_{k_2}|&gt;1\)</span>，矛盾。因此<span class="math inline">\((u,k_1)\leq0\)</span>。</p><p>2 <span class="math inline">\(\Rightarrow\)</span> 1: 不妨设 <span class="math inline">\(\mathcal{P}\)</span>中任何两个球帽至多只有一个交点。对 <span class="math inline">\(k_1\nek_2\in\mathcal{P}\)</span>，<span class="math inline">\(U=\mathrm{span}\{k_1,k_2\}\)</span> 肯定不是space-like 的，否则 <span class="math inline">\(U^\bot=k_1^\bot\capk_2^\bot\)</span> 是 time-like 的，则存在 time-like 的向量 <span class="math inline">\(v\)</span> 满足 <span class="math inline">\((v,k_1)=(v,k_2)=0\)</span>。给 <span class="math inline">\(v\)</span> 乘以适当实数后可以使得 <span class="math inline">\(v\in\mathcal{H}\)</span>，从而 <span class="math inline">\(v\in C_{k_1}\cap C_{k_2}\)</span>，这与 <a href="#contain-time-like" title="引理 5.4">引理 5.4</a> 矛盾。所以 <span class="math inline">\(U\)</span> 不是 space-like 的，即 <span class="math inline">\(|(k_1,k_2)|\geq1\)</span>。如果 <span class="math inline">\((k_1,k_2)\geq1\)</span>，则 <span class="math inline">\(C_{k_1}\cap C_{-k_2}\)</span> 和 <span class="math inline">\(C_{-k_1}\cap C_{k_2}\)</span>中必有一个至多只包含一个点，不妨设 <span class="math inline">\(|C_{k_1}\cap C_{-k_2}|\leq1\)</span>。但是根据已知<span class="math inline">\(C_{k_1}\cap C_{k_2}\)</span>也至多只包含一个点，从而 <span class="math inline">\(C_{k_1}\)</span>作为二者的并至多只有一个点，矛盾。所以只能是 <span class="math inline">\((k_1,k_2)\leq-1\)</span>，从而 <span class="math inline">\(\mathcal{P}\)</span> 是球堆。 <span class="math inline">\(\blacksquare\)</span></p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.7</span>.</span><span class="statement-spah"> </span>记 <span class="math inline">\(\Omega_r=\{\omega\in\Omega\mid(\omega,\omega)&gt;0\}\)</span> 是所有实权组成的集合，<span class="math inline">\(\mathcal{C}_r=\mathrm{cone}(\Omega_r)\)</span>是由所有实权生成的凸锥。</p></div><div id="real-cone-closure" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.8</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(W\)</span> 是不可约、双曲的，且 level 大于等于2，则 <span class="math inline">\(\overline{\mathcal{C}_r}= \overline{\mathcal{C} }\)</span>。</p></div><p><strong>证明</strong>：只要证明 <span class="math inline">\(\overline{\mathcal{C}_r}\)</span>包含那些非实的基本权 <span class="math inline">\((\omega_s,\omega_s)\leq 0\)</span> 即可。若如此，则 <span class="math inline">\(\overline{\mathcal{C}_r}\)</span> 包含全部基本权<span class="math inline">\(\Delta^\ast\)</span>，从而也包含 <span class="math inline">\(\mathrm{cone}(\Delta^\ast)=\overline{\mathcal{D}}\)</span>，再结合<span class="math inline">\(\overline{\mathcal{C}_r}\)</span> 是 <span class="math inline">\(W\)</span>- 不变的，即得 <span class="math inline">\(\overline{\mathcal{C}_r}\)</span> 包含 <span class="math inline">\(\bigcup\limits_{w\inW}w\overline{\mathcal{D}}=\mathcal{C}\)</span>，从而包含 <span class="math inline">\(\overline{ \mathcal{C} }\)</span>。</p><p>设 <span class="math inline">\(\omega_s\)</span>是任一非实的基本权，记 <span class="math inline">\(I=S-\{s\}\)</span>，<span class="math inline">\(W_I\)</span> 为标准椭圆子群。分情况讨论：</p><p><span class="math inline">\(\color{blue}(\omega_s,\omega_s)&lt;0\)</span></p><p>这时 <span class="math inline">\(\omega_s\)</span> 是 time-like的，其正交补 <span class="math inline">\(V_I=\mathrm{span}\{\alpha_t\midt\ne s\}\)</span> 是 space-like 的，从而 <span class="math inline">\(W_I\)</span> 是有限群。任取一个实的基本权 <span class="math inline">\((\omega_t,\omega_t)&gt;0\,(t\in I)\)</span> 并考虑<span class="math display">\[v = \sum_{w\in W_I}w(\omega_t).\]</span>显然 <span class="math inline">\(v\in\overline{\mathcal{C}_r}\)</span>，并且 <span class="math inline">\(W_I\)</span> 保持 <span class="math inline">\(v\)</span> 不动。特别地对任何 <span class="math inline">\(t\in I\)</span> 都有 <span class="math inline">\(t(v)=v\)</span>。这是 <span class="math inline">\(n-1\)</span>个独立的线性约束，其解空间是一维的，所以 <span class="math inline">\(v\)</span> 和 <span class="math inline">\(\omega_s\)</span> 共线：存在 <span class="math inline">\(a\in\mathbb{R}\)</span> 使得 <span class="math inline">\(v=a\omega_s\)</span>。两边同时与 <span class="math inline">\(\alpha_s\)</span> 作内积得到 <span class="math display">\[a = (\alpha_s,v)=\sum_{w\inW_I}(\alpha_s,w(\omega_t))=\sum_{w\in W_I}(w^{-1}(\alpha_s),\omega_t)=\sum_{w\in W_I}(w(\alpha_s), \omega_t).\]</span> 对任何 <span class="math inline">\(w\in W_I\)</span>，<span class="math inline">\(w\alpha_s=\alpha_s+\sum_{i\inI}c_i\alpha_i\)</span> 仍然是正根，所有的系数 <span class="math inline">\(c_i\)</span> 都非负。所以上式右边的每一项 <span class="math display">\[(w(\alpha_s), \omega_t)=\sum_{i\inI}c_i(\alpha_i, w_t) = c_t\geq0.\]</span> 我们来选择一个特殊的 <span class="math inline">\(w\in W_I\)</span> 使得 <span class="math inline">\(c_t&gt;0\)</span>：由于 <span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(\Gamma\)</span> 中存在一条从 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(t\)</span> 的路径 <span class="math inline">\(s\sim s_1\sim\cdots\sim s_m=t\)</span>，其中每个<span class="math inline">\(s_i\,(i\geq1)\in I\)</span>且互不相同。不难验证对 <span class="math inline">\(w=s_m\cdots s_1\inW_I\)</span>，<span class="math inline">\(w\alpha_s\)</span> 的系数<span class="math inline">\(c_t&gt;0\)</span>，所以 <span class="math inline">\(a\)</span> 严格大于 0，从而 <span class="math inline">\(\omega_s=v/a\in\overline{\mathcal{C}_r}\)</span>。</p><p><span class="math inline">\(\color{blue}(\omega_s,\omega_s)=0\)</span></p><p>这个情形要麻烦一些。这时 <span class="math inline">\(\omega_s\)</span> 的正交补 <span class="math inline">\(\omega_s^\bot\)</span> 是 light-like 的，即子图<span class="math inline">\(\Gamma\setminus\{s\}\)</span> 是仿射的。所以<span class="math inline">\(\Gamma\setminus\{s\}\)</span>由一些仿射或者有限的连通成分组成，由于内积是双曲的，这些连通成分中有且恰有一个是仿射的。任取一个实的基本权<span class="math inline">\((\omega_t,\omega_t)&gt;0\,(t\inI)\)</span>，分两种情况：</p><ol type="1"><li><p>如果 <span class="math inline">\(\omega_t\)</span>属于某个有限型的连通成分 <span class="math inline">\(Y\)</span>，类似上面的讨论，<span class="math inline">\(v\)</span> 是 <span class="math inline">\(\omega_s\)</span> 的某个正倍数，从而 <span class="math inline">\(\omega_s\in\overline{\mathcal{C}_r}\)</span>。</p></li><li><p>如果 <span class="math inline">\(\omega_t\)</span>属于某个仿射型的连通成分 <span class="math inline">\(X\)</span>，记<span class="math inline">\(\Gamma_1=X\cup \{s\}\)</span>，<span class="math inline">\(Y=\Gamma\setminus\Gamma_1\)</span>，则 <span class="math inline">\(Y\)</span> 是有限型，并且 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 互不连通（它们必然通过 <span class="math inline">\(s\)</span> 连在一起），从而 <span class="math display">\[\omega_s = \underbrace{(\omega_s,\omega_s)}_{=0}\alpha_s + \sum_{t\ne s} (\omega_s,\omega_t)\alpha_t=\sum_{t\in X} (\omega_s,\omega_t)\alpha_t + \sum_{t\inY} (\omega_s,\omega_t)\alpha_t=v_1+v_2.\]</span> 这里 <span class="math inline">\(v_1\)</span> 和 <span class="math inline">\(v_2\)</span> 是正交的。于是 <span class="math display">\[(\omega_s, \omega_s)=0\Rightarrow(v_1+v_2,v_1+v_2)=0\Rightarrow (v_1,v_1) + (v_2,v_2) = 0.\]</span> 由于<span class="math inline">\(V_X\)</span> 是不可约仿射的，<span class="math inline">\(V_Y\)</span> 是有限的，所以 <span class="math inline">\(v_2=0\)</span>，并且 <span class="math inline">\(\mathbb{R}v_1=\mathrm{rad}(V_X)\)</span>。从而<span class="math inline">\(\omega_s=v_1\)</span>，并且 <span class="math inline">\(\mathbb{R}\omega_s=\mathrm{rad}(V_X)\)</span>。<span class="math inline">\(\omega_s\)</span> 表示为 <span class="math inline">\(\{\alpha_i\mid i\in X\}\)</span>的线性组合时，所有的系数 <span class="math inline">\((\omega_s,\omega_i)\)</span>系数都是非零且同号的。我们断言它们都小于 0。实际上在 <span class="math display">\[\omega_s=\sum_{i\in X}(\omega_s,\omega_i)\alpha_i\]</span> 两边同时用 <span class="math inline">\(\alpha_s\)</span> 作内积有 <span class="math display">\[1=\sum_{i\in X} (\omega_s,\omega_i)\underbrace{(\alpha_s,\alpha_i)}_{\leq0}.\]</span> 所以必须所有<span class="math inline">\((\omega_s, \omega_i)&lt;0\)</span>。<br>于是 <span class="math inline">\(\Gamma_1\)</span> 满足 <a href="/coxeter-groups/level/#ideal-vertex">这个结论</a> 的条件（取 <span class="math inline">\(I=X,\,p=\omega_t,\,\omega_s=\omega_s\)</span>代入），从而我们得到 <span class="math display">\[\omega_s\in\overline{\mathrm{cone}(\bigcup_{w\in W_X}w(\omega_t))}\subset\overline{\mathcal{C}_r}.\]</span> <span class="math inline">\(\blacksquare\)</span></p></li></ol><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.9</span>.</span><span class="statement-spah"> </span>规定 <span class="math inline">\(\hat{\Omega}_r=\{\hat{\omega}\mid\omega\in\Omega_r\}\)</span>，其中 <span class="math inline">\(\hat{\omega}=\omega/\sqrt{(\omega,\omega)}\)</span>是将 <span class="math inline">\(\omega\)</span>归一化得到的单位向量。</p></div><div id="max-packing" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.10</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(W\)</span> 是双曲的，则 <span class="math inline">\(\hat{\Omega}_r\)</span> 是非平凡的球堆当且仅当<span class="math inline">\(\Gamma\)</span> 的 level 是 2，这时 <span class="math inline">\(\hat{\Omega}_r\)</span> 还是极大球堆。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(\Gamma\)</span>的 level 是 2，则 <a href="/coxeter-groups/level#level-12"><span class="math inline">\(\Omega_r\)</span>中的元素两两分离</a>，将其归一化后得到的 <span class="math inline">\(\hat{\Omega}_r\)</span> 仍然两两分离，所以 <span class="math inline">\(\hat{\Omega}_r\)</span> 的元素两两之间的内积 <span class="math inline">\(\leq -1\)</span>，从而 <span class="math inline">\(\hat{\Omega}_r\)</span>给出一个球堆。由于基本权是线性无关的，<span class="math inline">\(\hat{\Omega}_r\)</span>显然是非平凡的球堆。如果存在某个 space-like 的向量 <span class="math inline">\(k\)</span> 满足 <span class="math inline">\((k,k)=1\)</span> 且 <span class="math inline">\(k\)</span> 对应的 <span class="math inline">\(C_k\)</span> 与 <span class="math inline">\(\hat{\Omega}_r\)</span>中的任何球都没有公共内部的话，则有 <span class="math inline">\((k,\hat{\omega})\leq -1\)</span> 对任何 <span class="math inline">\(\hat{\omega}\in\hat{\Omega}_r\)</span>成立，自然就有 <span class="math inline">\((k,\omega)&lt;0\)</span>对任何 <span class="math inline">\(\omega\in\Omega_r\)</span> 成立，从而<span class="math inline">\((k,y)\leq0\)</span> 对任何 <span class="math inline">\(y\in\overline{\mathcal{C}_r}=\mathrm{cone}(\Omega_r)\)</span>成立。根据 <a href="#real-cone-closure" title="定理 5.8">定理5.8</a>，<span class="math inline">\(\overline{\mathcal{C}_r}=\overline{\mathcal{C} }\)</span>，这意味着 <span class="math inline">\((k,y)\leq0\)</span> 对任何 <span class="math inline">\(y\in\mathcal{C}\)</span> 成立，即 <span class="math inline">\(-k\in\mathcal{C}^\ast\)</span>。由于 <a href="/coxeter-groups/tits-cone/#dual-cone-nonspace">对偶锥 <span class="math inline">\(\mathcal{C}^\ast\)</span> 中的向量范数 <span class="math inline">\(\leq0\)</span></a>，<span class="math inline">\((k,k)=(-k,-k)\leq0\)</span>，这与 <span class="math inline">\((k,k)=1\)</span> 矛盾。这就证明了 level 2 时 <span class="math inline">\(\Omega_r\)</span> 是极大球堆。</p><p>反之若 <span class="math inline">\(\hat{\Omega}_r\)</span>是一个非平凡球堆，则 <span class="math inline">\(W\)</span> 的 level必然大于 1，且所有的实权之间两两分离。于是任何两个基本权生成的二维子空间<span class="math inline">\(\mathrm{span}\{\omega_i,\omega_j\}\)</span>都是 time-like 或者 light-like 的。又由于 <span class="math inline">\(W\)</span> 是双曲的，从而 <span class="math inline">\(\Gamma\setminus\{i,j\}\)</span> 是 space-like 或者light-like 的，所以 <span class="math inline">\(\Gamma\)</span> 的 level只能是 2。<span class="math inline">\(\blacksquare\)</span></p><h1 id="计算例子">计算例子</h1><p>本节我们来介绍怎样用程序实际绘制一个二维的 Boyd-Maxwell 球堆。</p><p>以 <span class="math inline">\(K_4\)</span>完全图为例，每条边的标号是 4：</p><p><img src="/images/coxeter/K4.svg" id="K4" class="fig" width="150"></p><p>这个群的 rank 是 4，level 是 2，所以给出的是 <span class="math inline">\(\mathbb{R}^2\)</span> 上的二维极大球堆。</p><p>单根系 <span class="math inline">\(\Delta=\{\alpha_i\}_{i=1}^4\)</span> 满足 <span class="math inline">\((\alpha_i,\alpha_i)=1\)</span>，它们对应 4个虚球。前面已经介绍了，以 <span class="math inline">\(\alpha_i\)</span>为法向量的单反射 <span class="math inline">\(s_i\)</span> 对应关于 <span class="math inline">\(B_i\)</span> 的反演变换，它们生成了 <span class="math inline">\((W,S)\)</span>。</p><p>由于删掉 <span class="math inline">\(K_4\)</span>的任何顶点后，剩下的是双曲三角群 <span class="math inline">\(\Delta(4,4,4)\)</span>，所以基本权 <span class="math inline">\(\Delta^\ast = \{\omega_i\}_{i=1}^4\)</span>都是实的。归一化以后 <span class="math inline">\(\{\hat{\omega}_i\}_{i=1}^4\)</span> 给出 4个互相分离的实球。由于 <span class="math inline">\(i\ne j\)</span> 时<span class="math inline">\((\alpha_i,\omega_j)=0\)</span>，所以 <span class="math inline">\(\alpha_i\)</span> 和 <span class="math inline">\(\hat{\omega}_j\)</span> 正交。又因为 <span class="math inline">\((\alpha_i,\omega_i)=1\)</span>，以及 <span class="math inline">\(\omega_i\)</span> 满足 <span class="math inline">\(0&lt;(\omega_i,\omega_i)\leq1\)</span>，所以归一化以后<span class="math inline">\((\alpha_i,\hat{\omega}_i)\geq1\)</span>，即球<span class="math inline">\(\alpha_i\)</span> 和 <span class="math inline">\(\hat{\omega}_i\)</span> 有包含关系。我们要求对每个<span class="math inline">\(i\)</span>，实球 <span class="math inline">\(\hat{\omega}_i\)</span> 包含在虚球 <span class="math inline">\(\alpha_i\)</span>的内部（即正半空间）。这是因为在计算时，我们要反复将平面上的点关于 <span class="math inline">\(\{\alpha_i\}\)</span> 作反演，直到它落入基本区域<span class="math inline">\(\overline{\mathcal{D}}\)</span>为止，然后判断这个最终位置属于哪个实球。所以我们一定要让虚球 <span class="math inline">\(\alpha_i\)</span> 包含实球 <span class="math inline">\(\hat{\omega_i}\)</span>。</p><p>将 <span class="math inline">\(W\)</span> 作用在实球 <span class="math inline">\(\{C_i\}\)</span>上，得到的所有球即为所要绘制的球堆 <span class="math inline">\(\mathcal{P}=\bigcup_{w\in W,\,1\leq i\leq4}w(\hat{\omega}_i)\)</span>。</p><p>我们按照如下步骤来分别计算 <span class="math inline">\(\{\alpha_i\}\)</span> 和 <span class="math inline">\(\{\hat{\omega}_j\}\)</span>：</p><ol type="1"><li>第一个实球 <span class="math inline">\(\hat{\omega}_1\)</span>总是可以取为单位球 <span class="math inline">\(B(\mathbf{0},1)\)</span>。<strong>并且 <span class="math inline">\(\hat{\omega}_1\)</span>是无界球</strong>。由于实球之间互不相交，所以 <span class="math inline">\(\hat{\omega}_2,\hat{\omega}_3,\hat{\omega}_4\)</span>都落在单位球内。</li><li>两个虚球 <span class="math inline">\(\alpha_3,\alpha_4\)</span>可以取为过原点的两条直线，法向量分别为 <span class="math display">\[\begin{aligned}\mathbf{n}_3&amp;=(1, 0),\\\mathbf{n}_4&amp;=(-\cos\frac{\pi}{m_{3,4}},\sin\frac{\pi}{m_{3,4}})=(-\cos\frac{\pi}{4},\sin\frac{\pi}{4}).\end{aligned}\]</span></li><li>第二个虚球 <strong><span class="math inline">\(\alpha_2=B(\mathbf{a}_2,r_2)\)</span>是一个无界球</strong>，即 <span class="math inline">\(r_2&lt;0\)</span>。我们可以认为 <span class="math inline">\(r_2&gt;0\)</span>，但是在列方程时将 <span class="math inline">\(B\)</span> 与其它球的内积取负：<ul><li>由 <span class="math inline">\(\alpha_2\)</span> 与 <span class="math inline">\(\hat{\omega}_1\)</span> 正交可得 <span class="math inline">\(|\mathbf{a}_2|^2=r_2^2+1\)</span>；</li><li>计算 <span class="math inline">\(\alpha_2\)</span> 与 <span class="math inline">\(\alpha_3,\alpha_4\)</span> 的夹角可得（注意 <span class="math inline">\(\cos\)</span> 前面没有负号了） <span class="math display">\[\begin{aligned}\frac{(\mathbf{a}_2,\mathbf{n}_3)}{r_2}&amp;=\cos\frac{\pi}{m_{23}}=\cos\frac{\pi}{4},\\\frac{(\mathbf{a}_2,\mathbf{n}_4)}{r_2}&amp;=\cos\frac{\pi}{m_{24}}=\cos\frac{\pi}{4}.\end{aligned}\]</span></li></ul>由这三个方程可以解出 <span class="math inline">\(\mathbf{a}_2\)</span>和 <span class="math inline">\(r_2\)</span>。</li><li>第一个虚球 <strong><span class="math inline">\(\alpha_1=B(\mathbf{a}_1,r_1)\)</span>也是一个无界球</strong>，即 <span class="math inline">\(r_1&lt;0\)</span>。我们同样认为 <span class="math inline">\(r_1&gt;0\)</span>，并在列方程时将它与其它球的内积取负：<ul><li>计算 <span class="math inline">\(\alpha_1\)</span> 与 <span class="math inline">\(\alpha_3,\alpha_4\)</span> 夹角可得 <span class="math display">\[\begin{aligned}\frac{(\mathbf{a}_1,\mathbf{n}_3)}{r_1}&amp;=\cos\frac{\pi}{m_{13}}=\cos\frac{\pi}{4},\\\frac{(\mathbf{a}_1,\mathbf{n}_4)}{r_1}&amp;=\cos\frac{\pi}{m_{14}}=\cos\frac{\pi}{4}.\end{aligned}\]</span></li><li>计算 <span class="math inline">\(\alpha_1\)</span> 与 <span class="math inline">\(\alpha_2\)</span> 夹角可得 <span class="math display">\[\frac{r_1^2+r_2^2-|\mathbf{a}_1-\mathbf{a}_2|^2}{2r_1r_2}=-\cos\frac{\pi}{m_{12}}=-\cos\frac{\pi}{4}.\]</span>注意由于 <span class="math inline">\(\alpha_1,\alpha_2\)</span>都是无界球，所以负号又回来了。</li></ul>由这三个方程可以得到一个二次方程，解出的 <span class="math inline">\(r_1\)</span>有两个值，我们取较小的那一个。（原因在后面解释）</li><li>我们还剩下三个实球 <span class="math inline">\(\hat{\omega}_2,\hat{\omega}_3,\hat{\omega}_4\)</span>需要解出。<span class="math inline">\(\hat{\omega}_2\)</span> 需要和<span class="math inline">\(\alpha_3,\alpha_4\)</span>正交，所以它是一个以原点为中心的球，而它又要和 <span class="math inline">\(\alpha_1\)</span> 正交，所以 <span class="math inline">\(\hat{\omega}_2\)</span> 的半径为 <span class="math inline">\(\sqrt{|\mathbf{a}_1|^2-r_1^2}\)</span>。</li><li><span class="math inline">\(\hat{\omega}_3\)</span> 与 <span class="math inline">\(\alpha_1,\alpha_2,\alpha_4\)</span>正交，这可以得到三个方程。联立解出 <span class="math inline">\(\hat{\omega}_3\)</span>。</li><li><span class="math inline">\(\hat{\omega}_4\)</span> 与 <span class="math inline">\(\alpha_1,\alpha_2,\alpha_3\)</span>正交，也可以得到三个方程，联立解出 <span class="math inline">\(\hat{\omega}_4\)</span>。</li></ol><p>结果如下图所示，单根 <span class="math inline">\(\alpha_i\)</span>对应的虚球用虚线绘制，<span class="math inline">\(\hat{\omega}_i\)</span>对应的实球用实线绘制，同样的 <span class="math inline">\(i\)</span>使用同样的颜色。上标 <span class="math inline">\(\ast\)</span>表示该球以无界区域为内部。所以我们有三个无界的球 <span class="math inline">\(\alpha_1,\alpha_2,\omega_1\)</span>。</p><p><img src="/images/coxeter/compute_example_K4.svg" class="fig" width="500"></p><p>注意到关于 <span class="math inline">\(\hat{\omega}_1\)</span>的反演保持虚球 <span class="math inline">\(\alpha_2,\alpha_3,\alpha_4\)</span>不变，因为它们都与 <span class="math inline">\(\hat{\omega}_1\)</span>正交；同时将 <span class="math inline">\(\alpha_1\)</span>变成另一个关于 <span class="math inline">\(\hat{\omega}_1\)</span>对称的球 <span class="math inline">\(\gamma_1\)</span>。反演变换是保角的，所以 <span class="math inline">\(\{\gamma_1,\alpha_2,\alpha_3,\alpha_4\}\)</span>也是一组夹角符合要求的镜面球，但是包含关系发生了改变，变成了 <span class="math inline">\(\gamma_1\)</span> 包含在 <span class="math inline">\(\hat{\omega}_1\)</span>的内部。这是错误的。这就是为什么前面求解 <span class="math inline">\(\alpha_1\)</span>的半径时我们要取那个较小的解（这两个解给出的球心形如 <span class="math inline">\(r_1\mathbf{x}\)</span> 和 <span class="math inline">\(r_2\mathbf{x}\,(\mathbf{x}\in\mathbb{R}^2)\)</span>，所以半径较小者一定在单位球内部）。</p><p>我们再举一个只有一个实权的例子：</p><p><img src="/images/coxeter/337.svg" id="337" class="fig" width="250"></p><p>这个群只有第一个顶点是实的，所以整个球堆完全由一个实球 <span class="math inline">\(\hat{\omega}_1\)</span> 生成：</p><p><img src="/images/coxeter/compute_example_337.svg" class="fig" width="500"></p><p>具体的计算步骤可以参考 shadertoy 动画代码中的注释：</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/WdGBz3?gui=true&amp;t=0&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><p>可以看到，每个实球都呈现一个二维的 Poincaré密铺图案。这很好理解，因为如果 <span class="math inline">\(\omega_i\)</span> 是实权，记 <span class="math inline">\(I=S\setminus\{i\}\)</span>，则实球 <span class="math inline">\(\hat{\omega}_i\)</span> 与虚球 <span class="math inline">\(\{\alpha_j\mid j\in I \}\)</span>都正交，这些虚球在 <span class="math inline">\(\hat{\omega}_1\)</span>中围成一个测地三角形，关于这个三角形三条边的反射生成的群是标准椭圆子群<span class="math inline">\(W_I\)</span>。<span class="math inline">\(W_I\)</span> 保持 <span class="math inline">\(\hat{\omega}_i\)</span>不动，同时将测地三角形映射为 <span class="math inline">\(\hat{\omega}_i\)</span> 中的双曲密铺。在前面 <a href="#K4"><span class="math inline">\(K_4\)</span> 的例子</a> 中，有 4个初始实球，它们每一个都呈现 <span class="math inline">\(\Delta(4,4,4)\)</span> 的双曲密铺；在 <a href="#337"><span class="math inline">\({\rm\color{red}o\color{red}}-{\rm o}-{\rmo}\overset{7}{-}{\rm o}\)</span> 的例子</a> 中，只有一个初始实球，它呈现<span class="math inline">\(\Delta(2,3,7)\)</span> 的双曲密铺。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Iversen_1992" class="csl-entry" role="listitem">Iversen, Birger. 1992. <span>“Hyperbolic Geometry.”</span> In. LondonMathematical Society Student Texts. Cambridge University Press.</div><div id="ref-Maxwell82" class="csl-entry" role="listitem">Maxwell, George. 1982. <span>“Sphere Packings and Hyperbolic ReflectionGroups.”</span> <em>Journal of Algebra</em> 79 (1): 78–97. <a href="https://doi.org/10.1016/0021-8693(82)90318-0">https://doi.org/10.1016/0021-8693(82)90318-0</a>.</div><div id="ref-Maxwell89" class="csl-entry" role="listitem">———. 1989. <span>“Wythoff’s Construction for Coxeter Groups.”</span><em>Journal of Algebra</em> 123 (2): 351–77. <a href="https://doi.org/10.1016/0021-8693(89)90051-3">https://doi.org/10.1016/0021-8693(89)90051-3</a>.</div><div id="ref-ratcliffe" class="csl-entry" role="listitem">Ratcliffe, John G. 2006. <em>Foundations of Hyperbolic Manifolds</em>.Second. Vol. 149. Graduate Texts in Mathematics. Springer.</div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记</title>
      <link href="/coxeter-groups/index.html"/>
      <url>/coxeter-groups/index.html</url>
      
        <content type="html"><![CDATA[<ol type="1"><li><a href="geometric-realization">几何实现</a></li><li><a href="root-system">根系</a></li><li><a href="tits-cone">Tits 锥及其对偶</a></li><li><a href="three-geometries">有限、仿射、双曲三种情形的 Tits锥</a></li><li><a href="level">Coxeter 群的 level</a></li><li><a href="Boyd-Maxwell">Boyd-Maxwell 球堆</a></li></ol>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（一）：抽象 Coxeter 群与几何实现</title>
      <link href="/coxeter-groups/geometric-realization.html"/>
      <url>/coxeter-groups/geometric-realization.html</url>
      
        <content type="html"><![CDATA[<h1 id="抽象-coxeter-群">抽象 Coxeter 群</h1><p>设 <span class="math inline">\(S\)</span> 是一个集合，一个基于 <span class="math inline">\(S\)</span> 的 Coxeter 矩阵 <span class="math inline">\(M=(m_{s,t})_{s,t\in S}\)</span>是一个对称矩阵，其对角线上都是 1，非对角线元素取值于 <span class="math inline">\(\{2,3,\ldots,\infty\}\)</span>。<span class="math inline">\(|S|\)</span> 叫做 <span class="math inline">\(M\)</span> 的秩 (rank)。在这个系列中我们只考虑<span class="math inline">\(|S|&lt;\infty\)</span> 的情形。</p><p>矩阵 <span class="math inline">\(M\)</span> 确定了一个有限表现群<span class="math inline">\(W\)</span>，其生成元为集合 <span class="math inline">\(S\)</span>，群表现如下： <span class="math display">\[W = \langle s\in S\ |\ (st)^{m_{s,t}}=1\ {\rmif}\ m_{s,t}&lt;\infty\rangle.\]</span></p><p>也就是说，<span class="math inline">\(S\)</span>满足以下的生成关系：</p><ol type="1"><li>对任何 <span class="math inline">\(s\in S\)</span> 有 <span class="math inline">\(s^2=1\)</span>。</li><li>对任何 <span class="math inline">\(s\ne t\)</span> 且 <span class="math inline">\(m_{s,t}&lt;\infty\)</span>有<strong>辫关系</strong> (braid relation) <span class="math display">\[\overbrace{sts\cdots}^{m_{s,t}}=\overbrace{tst\cdots}^{m_{s,t}}\]</span>成立。（当 <span class="math inline">\(m_{s,t}=\infty\)</span>时不引入任何关系）</li></ol><p>我们称 <span class="math inline">\((W, S)\)</span> 是一个<strong>Coxeter 系</strong>，<span class="math inline">\(W\)</span>是一个<strong>有限生成 Coxeter 群</strong>。</p><span id="more"></span><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>我们总是用 <span class="math inline">\((W,S)\)</span> 来表示一个Coxeter 群。即在提到一个 Coxeter 群 <span class="math inline">\(W\)</span> 时，需要同时指明其生成元集合 <span class="math inline">\(S\)</span>。这是因为，可能存在不同的集合 <span class="math inline">\(S\)</span>，它们给出同一个 <span class="math inline">\(W\)</span>。但是像长度函数 <span class="math inline">\(l(w)\)</span>、根系、Bruhat序这些重要的概念，只有在指定生成元集 <span class="math inline">\(S\)</span> 的前提下才有意义。</p></div><p>用 Coxeter 矩阵或者群表现来描述 Coxeter群还是太不方便了。我们可以用一个有限图 <span class="math inline">\(\Gamma\)</span> 更直观地表示 <span class="math inline">\((W,S)\)</span>，<span class="math inline">\(\Gamma\)</span> 叫做 <span class="math inline">\((W,S)\)</span> 的 <strong>Coxeter图</strong>：</p><ul><li><span class="math inline">\(\Gamma\)</span> 的顶点集是 <span class="math inline">\(S\)</span>。</li><li>如果 <span class="math inline">\(m_{s,t}\ne 2\)</span>，就在顶点<span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 之间连一条边，并且给这条边标上记号<span class="math inline">\(m_{s,t}\)</span>。</li><li>但是如果 <span class="math inline">\(m_{s,t}=3\)</span>的话，就省略这个记号不写。</li></ul><p>此外如果 <span class="math inline">\(\Gamma\)</span> 是连通的，就称<span class="math inline">\((W,S)\)</span>是<strong>不可约的</strong>。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>Coxeter 矩阵 <span class="math display">\[\begin{pmatrix}1 &amp;4 &amp; 2\\4&amp;1&amp;3\\2&amp;3&amp;1\end{pmatrix}\]</span> 对应的Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是</p><figure><img src="/images/coxeter/cube43.svg" class="fig" width="120" alt="正方体对称群 (4,3) 的 Coxeter 图，注意标号 3 省略了"><figcaption aria-hidden="true">正方体对称群 <span class="math inline">\((4,3)\)</span> 的 Coxeter 图，注意标号 3省略了</figcaption></figure><p><span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(W\)</span>是不可约的。这个群是三维正方体的对称群：</p><video src="/images/coxeter/cube.mp4" width="300" controls=""></video><p>去掉最后一个顶点，前两个顶点构成二面体群 <span class="math inline">\(D_4\)</span>，<span class="math inline">\(D_4\)</span>是正四边形的对称群，对应正方体的每个面是正四边形；去掉第一个顶点，后两个顶点构成二面体群<span class="math inline">\(D_3\)</span>，<span class="math inline">\(D_3\)</span> 是正三角形的对称群，对应每个顶点处有3 个面相遇。</p></div><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>设 <span class="math inline">\(m\geq4\)</span> 是正整数，Coxeter矩阵 <span class="math display">\[\begin{pmatrix}1 &amp; m &amp;2\\m&amp;1&amp;2\\2&amp;2&amp;1\end{pmatrix}\]</span> 对应的 Coxeter 图<span class="math inline">\(\Gamma\)</span> 是</p><p><img src="/images/coxeter/prism.svg" class="fig" width="120"></p><p><span class="math inline">\(\Gamma\)</span> 有两个连通分支，所以<span class="math inline">\(W\)</span>是可约的。这个群是三维空间中棱柱的对称群，前两个相邻的顶点给出二面体群<span class="math inline">\(D_m\)</span>，它负责在 <span class="math inline">\(xy\)</span> 平面内生成正 <span class="math inline">\(m\)</span> 边形；最后的孤立顶点在 <span class="math inline">\(z\)</span>轴方向上将多边形作反射形成棱柱结构：</p><video src="/images/coxeter/prism-6.mp4" width="300" controls=""></video></div><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>Coxeter 矩阵 <span class="math display">\[\begin{pmatrix}1 &amp;3 &amp; 4\\3&amp;1&amp;\infty\\4&amp;\infty&amp;1\end{pmatrix}\]</span>对应的 Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是</p><figure id="3-4-inf"><img src="/images/coxeter/3-4-inf.svg" width="120" alt="三角形群 \Delta(3,4,\infty) 的 Coxeter 图 \Gamma，注意标号 3 被省略了"><figcaption aria-hidden="true">三角形群 <span class="math inline">\(\Delta(3,4,\infty)\)</span> 的 Coxeter 图 <span class="math inline">\(\Gamma\)</span>，注意标号 <span class="math inline">\(3\)</span> 被省略了</figcaption></figure><p><span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(W\)</span>是不可约的。这个群给出的是双曲空间中的密铺：</p><p><img src="/images/coxeter/parallel.png" class="fig" width="250"></p></div><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>Coxeter 矩阵 <span class="math display">\[\begin{pmatrix}1 &amp;5 &amp; 2 &amp;2\\5&amp;1&amp;3&amp;2\\2&amp;3&amp;1&amp;4\\2&amp;2&amp;4&amp;1\end{pmatrix}\]</span>对应的 Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是</p><p><img src="/images/coxeter/534.svg" id="534" class="fig" width="180"></p><p><span class="math inline">\(W\)</span>是不可约的。这个群给出的是三维双曲空间中的密铺：</p><p><img src="/images/coxeter/534-1000.jpg" class="fig" width="500"></p><p>去掉最后一个顶点，前三个顶点给出正十二面体的对称群 <span class="math inline">\((5,3)\)</span>，说明这个密铺由正十二面体组成；去掉第一个顶点，剩下三个顶点给出正方体的对称群<span class="math inline">\((3,4)\cong(4,3)\)</span>，说明每个顶点处有 8个正十二面体相遇。</p></div><p>我们主要关心 <span class="math inline">\(\Gamma\)</span>不可约的情形。因为如果 <span class="math inline">\(\Gamma=\Gamma_1\cup\cdots\cup\Gamma_k\,(k&gt;1)\)</span>包含多个连通分支的话，那么对任何 <span class="math inline">\(s\in\Gamma_i\)</span> 和 <span class="math inline">\(t\in\Gamma_j\)</span> 有 <span class="math inline">\(m_{s,t}=2\)</span>，即 <span class="math inline">\(st=ts\)</span>，于是 <span class="math inline">\(\Gamma_i\)</span> 中的生成元与 <span class="math inline">\(\Gamma_j\)</span> 中的生成元两两交换，这时 <span class="math inline">\(W\)</span> 有直积分解 <span class="math display">\[W=W_1\times\cdots\times W_k.\]</span> 其中 <span class="math inline">\(W_1,\ldots,W_k\)</span> 分别是子图 <span class="math inline">\(\Gamma_1,\ldots,\Gamma_k\)</span> 对应的 Coxeter群。所以我们只要研究 <span class="math inline">\(\Gamma\)</span>不可约的情形即可。</p><p>还有一种给 <span class="math inline">\(\Gamma\)</span>的边标号的方式，叫做 Vinberg 记号，它允许给 <span class="math inline">\(m_{s,t}=\infty\)</span> 的边用 <span class="math inline">\(\leq-1\)</span>的实数作为标号。比如像下面这样：</p><p><img src="/images/coxeter/level2.svg" id="level2" class="fig" width="120"></p><p>该图表示的抽象 Coxeter 群和前面的 <a href="#3-4-inf"><span class="math inline">\(\Delta(3,4,\infty)\)</span></a> 相同，但其中 <span class="math inline">\(\infty\)</span> 边的标号变成了 <span class="math inline">\(-1.1\)</span>。我后面会解释，这种标号方式其实是指定了几何实现中两个镜面的「双曲距离」。我们在后文介绍Boyd-Maxwell 球堆时也会采用这种记号。</p><p>Coxeter 图除了直观上的好处外，还能传达更多信息。比如，当 <span class="math inline">\(\Gamma\)</span> 包含回路，或者包含某个度数 <span class="math inline">\(\geq4\)</span> 的顶点时，我们可以立刻知道 <span class="math inline">\((W,S)\)</span> 一定是无限群 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.2.7</a>)</span>。更进一步，一个 Coxeter 群是否能够产生 Boyd-Maxwell球堆，也完全可以从其 Coxeter 图中读出来。</p><h1 id="长度函数">长度函数</h1><p>对 <span class="math inline">\(W\)</span> 中的任一元素 <span class="math inline">\(w\)</span>，存在许多种不同的方式将 <span class="math inline">\(w\)</span> 表示为 <span class="math inline">\(S\)</span>中生成元的乘积。在所有这些表示中，长度最短者叫做 <span class="math inline">\(w\)</span> 的<strong>既约表示</strong>：即，如果<span class="math inline">\(w=s_1s_2\cdots s_k\)</span> 是一个长度为<span class="math inline">\(k\)</span> 的表示，且 <span class="math inline">\(w\)</span> 不存在任何长度小于 <span class="math inline">\(k\)</span> 的表示，就称该表示是 <span class="math inline">\(w\)</span>的既约表示。既约表示未必唯一，但它们都具有相同的长度。定义 <span class="math inline">\(l(w)\)</span> 为 <span class="math inline">\(w\)</span> 的任意一个既约表示的长度。</p><p><span class="math inline">\(l(w)\)</span> 具有如下的性质：</p><ol type="1"><li><span class="math inline">\(l(xy)\leq l(x) + l(y)\)</span>。</li><li><span class="math inline">\(l(w) = l(w^{-1})\)</span>。</li><li><span class="math inline">\(l(w)=0\)</span> 当且仅当 <span class="math inline">\(w=1\)</span>。</li><li><span class="math inline">\(l(ws)=l(w)\pm 1\)</span>，其中 <span class="math inline">\(w\in W, s\in S\)</span>。</li></ol><p>前三点都是显然的，只有 4 需要证明。显然 <span class="math inline">\(|l(ws)-l(w)|\leq 1\)</span>，所以只要说明 <span class="math inline">\(l(ws)\)</span> 和 <span class="math inline">\(l(s)\)</span>不相等即可。这一步需要用到自由群的泛性质：</p><p>设 <span class="math inline">\(F\)</span> 是由集合 <span class="math inline">\(S\)</span> 生成的 <a href="https://en.wikipedia.org/wiki/Free_group">自由群</a>，定义群同态<span class="math inline">\({\rm sgn}: F\to{\pm1}\)</span> 如下：对<span class="math inline">\(F\)</span> 的每个生成元 <span class="math inline">\(s\in S\)</span> 规定 <span class="math inline">\({\rm sgn}(s)=-1\)</span>，然后将此映射扩充为 <span class="math inline">\(F\)</span> 到 <span class="math inline">\({\pm1}\)</span> 的群同态。容易验证 <span class="math inline">\((W,S)\)</span>的所有生成关系都属于这个同态的核，因此根据 <a href="https://en.wikipedia.org/wiki/Free_group#Universal_property">自由群的泛性质</a>，<span class="math inline">\({\rm sgn}\)</span> 诱导了一个从 <span class="math inline">\((W,S)\)</span> 到 <span class="math inline">\({\pm1}\)</span> 的群同态。若 <span class="math inline">\(w=s_1s_2\cdots s_k\)</span> 是 <span class="math inline">\(w\)</span> 的任一既约表示，则 <span class="math display">\[{\rm sgn}(w)={\rm sgn}(s_1){\rmsgn}(s_2)\cdots{\rm sgn}(s_k)=(-1)^k=(-1)^{l(w)}.\]</span> 从而 <span class="math inline">\({\rm sgn}(ws)={\rm sgn}(w){\rm sgn}(s)=-{\rmsgn}(w)\)</span>，这说明 <span class="math inline">\(l(ws)\nel(w)\)</span>，从而第 4 条成立。</p><h1 id="几何实现">几何实现</h1><p>抽象 Coxeter群是通过生成元和生成关系定义的，直接从这种定义出发研究群结构是非常困难的。本节将介绍如何将一个抽象的Coxeter群实现为内积空间中的正交反射群，从而可以使用几何、线性代数等多种工具来研究它。</p><p>设 <span class="math inline">\((W,S)\)</span> 是一个 Coxeter系，<span class="math inline">\(M=(m_{s,t})_{s,t\in S}\)</span> 是Coxeter 矩阵。令 <span class="math inline">\(V\)</span> 是一个维数为<span class="math inline">\(n=|S|\)</span> 的实向量空间，其一组基为<span class="math inline">\(\{\alpha_s \mid s\in S\}\)</span>。我们规定<span class="math inline">\(V\)</span> 上的内积 <span class="math inline">\((\cdot,\cdot)\)</span> 如下：</p><p><span class="math display">\[(\alpha_s,\alpha_t)=\begin{cases}1 &amp; s=t,\\-\cos(\pi/m_{s,t}) &amp; m_{s,t}&lt;\infty,\\-a_{s,t} &amp; m_{s,t}=\infty.\end{cases}\]</span> 这里 <span class="math inline">\(a_{s,t}=a_{t,s}\geq1\)</span> 是实数，它对应的是<span class="math inline">\(\infty\)</span> 边的 Vinberg 记号。不同的<span class="math inline">\(s,t\)</span> 对可以使用不同的 <span class="math inline">\(a_{s,t}\)</span>。</p><p>根据定义 <span class="math inline">\((\alpha_s,\alpha_s)=1\)</span>，即每个 <span class="math inline">\(\alpha_s\)</span> 都是单位向量。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span><span class="math inline">\(a_{s,t}=1\)</span> 表示 Euclidean空间中两个平行的镜面（或者双曲空间中两个平行的镜面）；<span class="math inline">\(a_{s,t}&gt;1\)</span>表示双曲空间中两个超平行的镜面；<span class="math inline">\(2\leqm_{s,t}&lt;\infty\)</span> 表示两个相交的镜面。</p><p>下图显示了对前面的 <a href="#3-4-inf"><span class="math inline">\(\Delta(3,4,\infty)\)</span></a> 群，对标号为 <span class="math inline">\(\infty\)</span> 的边取 <span class="math inline">\(a_{s,t}=1.15\)</span> 时给出的效果：</p><p><img src="/images/coxeter/hypparallel.png" class="fig" width="250"></p><p>你可以看到每个三角形都不再是封闭的，它们的墙壁中有两条「超平行」的测地线，这两条测地线交点落在双曲空间的外面。</p></div><p>内积 <span class="math inline">\((\cdot,\cdot)\)</span> 未必是通常的Euclidean 内积，即它未必是正定的。但我们最关心的情形有三种：</p><ol type="1"><li>如果 <span class="math inline">\((\cdot,\cdot)\)</span>是正定的，就称 <span class="math inline">\((\cdot,\cdot)\)</span>是<strong>有限</strong>型的；</li><li>如果 <span class="math inline">\((\cdot,\cdot)\)</span>是半正定的，但不是正定的，就称 <span class="math inline">\((\cdot,\cdot)\)</span>是<strong>仿射</strong>型的；</li><li>如果 <span class="math inline">\((\cdot,\cdot)\)</span> 的符号是<span class="math inline">\((n-1, 1)\)</span>，就称 <span class="math inline">\((\cdot,\cdot)\)</span>是<strong>双曲</strong>型的。</li></ol><p>除此之外的情况，统称为<strong>不定</strong>型。</p><p>给定 <span class="math inline">\(s\in S\)</span>，定义 <span class="math inline">\(V\)</span> 上的反射 <span class="math inline">\(\rho_s\)</span> 为 <span class="math display">\[\rho_s(v) = v -2(v,\alpha_s)\alpha_s ,\quad v\inV.\]</span> 容易验证，<span class="math inline">\(\rho_s\)</span>满足以下性质：</p><ol type="1"><li><span class="math inline">\(\rho_s(\alpha_s)=-\alpha_s\)</span>；</li><li><span class="math inline">\(\rho_s\)</span> 保持超平面 <span class="math inline">\(\{v\in V\mid (v,\alpha_s)=0\}\)</span>上的点不动；</li><li><span class="math inline">\(\rho_s\)</span> 保持 <span class="math inline">\((\cdot,\cdot)\)</span> 不变：<span class="math inline">\((\rho_s(u),\rho_s(v)) = (u,v),\,\forall u,v\inV\)</span>。</li></ol><p>因此 <span class="math inline">\(\rho_s\in \mathrm{O}(V)\)</span>是以 <span class="math inline">\(\alpha\)</span>为法向量的镜面反射。</p><p>我们来证明 <span class="math inline">\(s\to\rho_s\)</span>实际上给出了 <span class="math inline">\((W,S)\)</span> 到 <span class="math inline">\(\mathrm{O}(V)\)</span>的群同态，从而得到了一个线性表示 <span class="math display">\[\rho:W\to\rho(W)\leqslant\mathrm{O}(V)\]</span> 为此，只需验证 <span class="math inline">\(\{\rho_s\mid s\in S\}\)</span> 满足与 <span class="math inline">\((W,S)\)</span>相同的生成关系即可，这样根据商群的泛性质，即得存在群同态 <span class="math inline">\(W\to\mathrm{O}(V)\)</span> 将每个 <span class="math inline">\(s\)</span> 映射到 <span class="math inline">\(\rho_s\)</span>。即我们只要证明：</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\((\rho_s\rho_t)^{m_{s,t}}=1\)</span> 对任何 <span class="math inline">\(s,t\in S\)</span> 成立。</p></div><p>这个结论的证明在 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.5.3</a>)</span> 和 <span class="citation" data-cites="Howlett-note">(<a href="#ref-Howlett-note" role="doc-biblioref">Howlett 1996</a>)</span>中都可以找到，但我更喜欢 Howlett 的做法，把 rank 2情形的根系具体的算出来。这是最简单，但又非平凡的根系的例子，熟悉它的重要性怎么强调也不为过。</p><p><strong>证明</strong>：当 <span class="math inline">\(s=t\)</span>时所证即为 <span class="math inline">\(\rho_s^2=1\)</span>，由于 <span class="math inline">\(\rho_s\)</span> 是反射这当然是成立的。</p><p>下设 <span class="math inline">\(s\ne t\)</span>，记 <span class="math inline">\(V_{s,t}={\rmspan}\{\alpha_s,\alpha_t\}\)</span>，并记 <span class="math inline">\(V_{s,t}^\perp\)</span> 是 <span class="math inline">\(V_{s,t}\)</span> 在 <span class="math inline">\((\cdot,\cdot)\)</span> 下的正交补。不难验证 <span class="math inline">\(\rho_s\)</span> 和 <span class="math inline">\(\rho_t\)</span> 限制在 <span class="math inline">\(V_{s,t}^\perp\)</span> 上都是恒等变换。</p><p>注意，未必有 <span class="math inline">\(V=V_{s,t}\oplusV_{s,t}^\perp\)</span> 成立，因为 <span class="math inline">\((\cdot,\cdot)\)</span> 可能是退化的。但是如果<span class="math inline">\((\cdot,\cdot)\)</span> 限制在 <span class="math inline">\(\mid_{V_{s,t}}\)</span> 是非退化的，那么就有 <span class="math inline">\(V=V_{s,t}\oplus V_{s,t}^\perp\)</span>就成立。这是双线性型的基本结论。</p><p>我们来计算 <span class="math inline">\(\sigma=\rho_s\rho_t\)</span>的阶。记 <span class="math inline">\(m=m_{s,t}\)</span>，分情况讨论：</p><div id="rank2-roots" class="plain"></div><p><strong>1. <span class="math inline">\(m&lt;\infty\)</span></strong></p><p>这时 <span class="math inline">\((\cdot,\cdot)\)</span> 限制在 <span class="math inline">\(V_{s,t}\)</span> 上的 Gram 矩阵是 <span class="math display">\[\begin{pmatrix}1&amp;-\cos\theta\\-\cos\theta&amp;1\end{pmatrix},\quad\theta=\frac{\pi}{m}.\]</span> 这个矩阵是正定的，从而 <span class="math inline">\((\cdot,\cdot)\mid_{V_{s,t}}\)</span> 非退化，从而<span class="math inline">\(V=V_{s,t}\oplus V_{s,t}^\perp\)</span>成立，而 <span class="math inline">\(\sigma\)</span> 限制在正交补 <span class="math inline">\(V_{s,t}^\perp\)</span> 上是恒等变换，因此 <span class="math inline">\(\sigma\)</span> 在 <span class="math inline">\(V\)</span> 上的阶就等于它在 <span class="math inline">\(V_{s,t}\)</span> 上的阶。</p><p>为了简化记号，令 <span class="math inline">\(a_k=\sin(k\theta)/\sin\theta\)</span>，直接计算如下： <span class="math display">\[\begin{aligned}&amp;\alpha_s\xrightarrow{\ \rho_t\}a_1\alpha_s+a_2\alpha_t\xrightarrow{\ \rho_s\}a_3\alpha_s+a_2\alpha_t\xrightarrow{\ \rho_t\}a_3\alpha_s+a_4\alpha_t\xrightarrow{\ \rho_s\ }\cdots\\&amp;\alpha_t\xrightarrow{\ \rho_s\}a_2\alpha_s+a_1\alpha_t\xrightarrow{\ \rho_t\}a_2\alpha_s+a_3\alpha_t\xrightarrow{\ \rho_s\}a_4\alpha_s+a_3\alpha_t\xrightarrow{\ \rho_t\ }\cdots\end{aligned}\]</span> 这两个链的周期都是 <span class="math inline">\(2m\)</span>，因为它们的第 <span class="math inline">\(2m+1\)</span> 项各自回到了初始状态： <span class="math display">\[\begin{aligned}a_{2m+1}\alpha_s+a_{2m}\alpha_t&amp;=\dfrac{\sin(2m+1)\theta}{\sin\theta}\alpha_s+\dfrac{\sin(2m)\theta}{\sin\theta}\alpha_t=\alpha_s,\\a_{2m}\alpha_s+a_{2m+1}\alpha_t&amp;=\dfrac{\sin(2m)\theta}{\sin\theta}\alpha_s+\dfrac{\sin(2m+1)\theta}{\sin\theta}\alpha_t=\alpha_t.\end{aligned}\]</span> 因此 <span class="math inline">\(\sigma\)</span>的阶等于 <span class="math inline">\(m\)</span>。</p><p><strong>2. <span class="math inline">\(m=\infty\)</span></strong></p><p>这时未必有 <span class="math inline">\(V=V_{s,t}\oplusV_{s,t}^\perp\)</span>。但我们可以证明 <span class="math inline">\(\sigma\)</span> 在 <span class="math inline">\(V_{s,t}\)</span> 上的阶是无穷，那么自然它在 <span class="math inline">\(V\)</span> 上的阶也是无穷。</p><p>设 <span class="math inline">\(\theta\geq0\)</span> 使得 <span class="math inline">\(a_{s,t}=\cosh\theta\)</span>。记 <span class="math inline">\(b_k=\sinh(k\theta)/\sinh\theta\)</span>，直接计算：<span class="math display">\[\begin{aligned}&amp;\alpha_s\xrightarrow{\ \rho_t\}b_1\alpha_s+b_2\alpha_t\xrightarrow{\ \rho_s\}b_3\alpha_s+b_2\alpha_t\xrightarrow{\ \rho_t\}b_3\alpha_s+b_4\alpha_t\xrightarrow{\ \rho_s\ }\cdots\\&amp;\alpha_t\xrightarrow{\ \rho_s\}b_2\alpha_s+b_1\alpha_t\xrightarrow{\ \rho_t\}b_2\alpha_s+b_3\alpha_t\xrightarrow{\ \rho_s\}b_4\alpha_s+b_3\alpha_t\xrightarrow{\ \rho_t\ }\cdots\end{aligned}\]</span> 当 <span class="math inline">\(a_{s,t}=1\)</span> 时 <span class="math inline">\(\theta=0\)</span>，<span class="math inline">\(b_k\)</span> 应当理解为 <span class="math inline">\(\lim_{\theta\to0}\sinh(k\theta)/\sinh(\theta)=k\)</span>。</p><p>这两个链条永不重复，所以 <span class="math inline">\(\sigma\)</span>的阶是无穷。</p><p>至此命题得证。<span class="math inline">\(\blacksquare\)</span></p><p>后面我们会看到，<span class="math inline">\(W\xrightarrow{\rho}\rho(W)\)</span>实际上是群同构，这样就把抽象的 Coxeter 群 <span class="math inline">\(W\)</span> 实现为具体的反射群 <span class="math inline">\(\rho(W)\)</span>。研究 <span class="math inline">\(\rho(W)\)</span> 并不会丢失 <span class="math inline">\(W\)</span> 的信息。</p><p>最后是一个记号的简化：把 <span class="math inline">\(w\in W\)</span>在 <span class="math inline">\(V\)</span> 上的作用记为 <span class="math inline">\(wv\,\colon=\rho(w)(v)\)</span>。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Howlett-note" class="csl-entry" role="listitem">Howlett, Robert B. 1996. <span>“Introduction to Coxeter Groups.”</span><a href="https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html">https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html</a>.</div><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（五）：Coxeter 群的 level</title>
      <link href="/coxeter-groups/level.html"/>
      <url>/coxeter-groups/level.html</url>
      
        <content type="html"><![CDATA[<p>本文主要改写自 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>)</span>和<span class="citation" data-cites="Maxwell89">(<a href="#ref-Maxwell89" role="doc-biblioref">Maxwell1989</a>)</span>，介绍 Coxeter 群的 level 的概念，并证明 level 等于 1 或2 的群都是双曲的。</p><p>在本文中，我们总假定 <span class="math inline">\((\cdot,\cdot)\)</span> 是非退化的，从而我们可以将<span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 等同起来。在这种情况下，根系、<a href="/coxeter-groups/tits-cone/#fundamental-weights">基本权</a> <span class="math inline">\(\Delta^\ast\)</span>、Tits 锥 <span class="math inline">\(\mathcal{C}\)</span> 都在 <span class="math inline">\(V\)</span> 中。<span class="math inline">\(\Delta^\ast\)</span> 满足 <span class="math inline">\((\alpha_s,\omega_t)=\delta_{st}\,(\forall s,t\inS)\)</span>。</p><p>我先介绍两个关于 <span class="math inline">\(\Delta=\{\alpha_s\mids\in S\}\)</span> 和 <span class="math inline">\(\Delta^\ast=\{\omega_s\mid s\in S\}\)</span>之间关系的显然等式，这样下文用到它们时就不必再重复说明。</p><p>固定 <span class="math inline">\(s\in S\)</span>，设 <span class="math display">\[\omega_s = \sum_{t\in S}c_t\alpha_t,\quadc_t\in\mathbb{R}.\]</span> 两边同时与 <span class="math inline">\(\omega_t\)</span> 作内积，可得 <span class="math inline">\(c_t=(\omega_s,\omega_t)\)</span>，于是 <span class="math display">\[\omega_s = \sum_{t\inS}(\omega_s,\omega_t)\alpha_t=(\omega_s,\omega_s)\alpha_s + \sum_{t\nes} (\omega_s,\omega_t)\alpha_t.\tag{I}\label{eq:idI}\]</span>这是第一个恒等式。</p><p>进一步，在 <span class="math inline">\((\ref{eq:idI})\)</span> 两边与<span class="math inline">\(\alpha_s\)</span> 作内积，可得 <span class="math display">\[1=\sum_{t\inS}(\omega_s,\omega_t)\cdot(\alpha_s,\alpha_t)=(\omega_s,\omega_s)+\sum_{t\nes}(\omega_s,\omega_t)\cdot(\alpha_s,\alpha_t).\tag{II}\label{eq:idII}\]</span>这是第二个恒等式。</p><h1 id="level-的定义">level 的定义</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span> <span class="statement-info">(<span class="citation" data-cites="Maxwell82">Maxwell (<a href="#ref-Maxwell82" role="doc-biblioref">1982</a>)</span>)</span>.</span><span class="statement-spah"> </span><span class="math inline">\((W,S)\)</span> 的 level 定义为最小的非负整数 <span class="math inline">\(l\)</span>，使得在 <span class="math inline">\(\Gamma\)</span> 中删去任何 <span class="math inline">\(l\)</span>个顶点后，剩下的每个连通分支都是有限或者仿射的。</p></div><span id="more"></span><p>根据定义，有限和仿射 Coxeter 群的 level 都是0（因为不需要删去任何顶点）。</p><p>下面是几个 level 大于 0 的例子：</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span></p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr class="odd"><td style="text-align: center;">level=1</td><td style="text-align: center;">level=2</td><td style="text-align: center;">level=3</td></tr><tr class="even"><td style="text-align: center;"><img src="/images/coxeter/level1.svg" class="fig" width="120"></td><td style="text-align: center;"><img src="/images/coxeter/level2.svg" class="fig" width="120"></td><td style="text-align: center;"><img src="/images/coxeter/level3.svg" class="fig" width="120"></td></tr></tbody></table><ul><li>左图：三条边标号是 <span class="math inline">\((3,3,7)\)</span>，是双曲的；删去任何一个顶点后，剩下的是一个有限二面体群，因此level = 1。</li><li>中图：三条边标号（采用了 Vinberg 记号）是 <span class="math inline">\((3, 4,-1.1)\)</span>，删去红色顶点后，剩下的两个顶点构成一个双曲群，说明 level&gt; 1；删去任何两个顶点的话只剩一个顶点，当然是有限的，因此 level =2。</li><li>右图：删去两个红色顶点以后，剩下的两个顶点构成一个 Vinberg记号下的双曲群，说明 level &gt;2；删去任何三个顶点以后只剩一个顶点，当然是有限的，所以 level = 3。</li></ul></div><div id="level-l" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\Gamma\)</span> 是连通的，且 level 等于 <span class="math inline">\(l\)</span>，则在 <span class="math inline">\(\Gamma\)</span> 中删去任何 <span class="math inline">\(l+1\)</span>个顶点后，剩下的每个连通成分都是有限的。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(l\)</span>归纳。当 <span class="math inline">\(l=0\)</span>时，由于在一个有限或者仿射的连通图中删去任何一个顶点后剩下的一定是有限子图<span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.2.6</a>)</span>，所以结论成立。设结论对所有小于 <span class="math inline">\(l\)</span> 的正整数成立，考虑 <span class="math inline">\(l\)</span> 的情形。用反证法。</p><p>假设从 <span class="math inline">\(\Gamma\)</span> 中删去 <span class="math inline">\(|U|=l+1\)</span>个顶点后，剩下的部分包含一个仿射的连通分支 <span class="math inline">\(Y\)</span>。由于 <span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(Y\)</span> 必然和某个 <span class="math inline">\(u\in U\)</span> 有边相连。</p><p>考虑从 <span class="math inline">\(\Gamma\)</span> 中，删去 <span class="math inline">\(U\setminus\{u\}\)</span> 这 <span class="math inline">\(l\)</span> 个顶点后得到的子图。由于 <span class="math inline">\(\Gamma\)</span> 的 level 是 <span class="math inline">\(l\)</span>，所以这个子图每个分支都是有限或者仿射的。令<span class="math inline">\(C\)</span> 是包含 <span class="math inline">\(Y\cup\{u\}\)</span> 的连通分支，则 <span class="math inline">\(C\)</span> 是不可约仿射的。但是从 <span class="math inline">\(C\)</span> 中删除 <span class="math inline">\(u\)</span> 后仍然包含仿射子图 <span class="math inline">\(Y\)</span>，这与 <span class="math inline">\(l=0\)</span> 的情形矛盾，所以结论得证。<span class="math inline">\(\blacksquare\)</span></p><h1 id="level-1-是双曲的">Level 1 是双曲的</h1><p>本节来证明 level 等于 1 的群都是双曲的。</p><p>首先是一个定义：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.1</span>.</span></p><ul><li>如果 <span class="math inline">\(v\in V\)</span> 满足 <span class="math inline">\((v, v)&gt;0\)</span>，我们就称 <span class="math inline">\(v\)</span> 是<strong>实的</strong>。</li><li>如果 <span class="math inline">\(u,v\in V\)</span> 满足 <span class="math inline">\((u,v)\leq 0\)</span> 且 <span class="math inline">\(u,v\)</span> 张成的二维子空间 <span class="math inline">\(\mathrm{span}\{u,v\}\)</span><strong>不是正定</strong>的，就称 <span class="math inline">\(u,v\)</span> 是<strong>分离</strong>的(disjoint)。</li></ul></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在 <span class="math inline">\((\cdot,\cdot)\)</span> 是Lorentzian 内积时，<span class="math inline">\(v\)</span> 是实的等价于<span class="math inline">\(v\)</span> 是 space-like 的。</p></div><div id="lemma-uv" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理2.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\Gamma\)</span> 的 level 大于等于1，并且不是双曲的，则 <span class="math inline">\(V\)</span>中存在两个互相正交的向量 <span class="math inline">\(u,v\)</span> 满足<span class="math inline">\((u,u)&lt;0\)</span> 和 <span class="math inline">\((v,v)=0\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(\Gamma\)</span> 的 level 大于等于 1，所以 <span class="math inline">\((\cdot,\cdot)\)</span>不可能是正定或者半正定的，显然也不可能是负定/半负定的（因为所有根的范数都是1），所以 <span class="math inline">\((\cdot,\cdot)\)</span>的正负惯性指数都非 0。如果 <span class="math inline">\(W\)</span>不是双曲的，那么有两种可能：</p><ol type="1"><li><span class="math inline">\((\cdot,\cdot)\)</span> 的负惯性指数是 1且 <span class="math inline">\(\mathrm{rad}(V)\ne\{0\}\)</span>。</li><li><span class="math inline">\((\cdot,\cdot)\)</span>的负惯性指数至少是 2。</li></ol><p>情形 1 可以取 <span class="math inline">\(V\)</span>的一组正交基包含两个向量 <span class="math inline">\(u,v\)</span> 满足<span class="math inline">\((u, u)=-1\)</span> 和 <span class="math inline">\((v,v)=0\)</span>。情形 2 可以取 <span class="math inline">\(V\)</span> 的一组正交基包含三个向量 <span class="math inline">\(x,y,z\)</span> 满足 <span class="math inline">\((x,x)=1\)</span> 和 <span class="math inline">\((y, y)=(z,z)=-1\)</span>，然后取 <span class="math inline">\(u=z\)</span> 和 <span class="math inline">\(v=x+y\)</span>，则 <span class="math inline">\(u,v\)</span> 正交且 <span class="math inline">\((u,u)=-1,\,(v,v)=0\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="level-1" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.3</span> <span class="statement-info">(<span class="citation" data-cites="Maxwell82">Maxwell (<a href="#ref-Maxwell82" role="doc-biblioref">1982</a>)</span>)</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\Gamma\)</span> 的 level 是 1，则 <span class="math inline">\(\Gamma\)</span> 是双曲的。所有的 <a href="/coxeter-groups/tits-cone#fundamental-weights">基本权</a>都不是实的并且两两分离。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>当 <span class="math inline">\(|S|=4\)</span> 时，level 1 的Coxeter 群给出了三维双曲空间中的<strong>紧</strong> (compact)和<strong>仿紧</strong> (paracompact)的蜂巢结构。基本权不是实的意味着所有的权都不是实的，即蜂巢的顶点全部位于双曲空间的内部或者边界上。维基百科的<a href="https://en.wikipedia.org/wiki/Uniform_honeycombs_in_hyperbolic_space">这个页面</a>上列出了所有紧和仿紧的蜂巢。</p></div><p><strong>证明</strong>：首先注意到 <span class="math inline">\(\Gamma\)</span> 的 level 是 1 蕴含了 <span class="math inline">\(\Gamma\)</span> 是连通的，若不然，设 <span class="math inline">\(\Gamma=\Gamma_1\cup\cdots\cup\Gamma_k\)</span>有多个连通分支，则每个 <span class="math inline">\(\Gamma_i\)</span>作为删去其它分支后剩下的子图，都应该是有限或者仿射的，但这导致 <span class="math inline">\(\Gamma\)</span> 的 level 是 0，矛盾。</p><p>我们需要证明三件事情：</p><ol type="1"><li>内积 <span class="math inline">\((\cdot,\cdot)\)</span> 的惯性指数是<span class="math inline">\((n-1, 1)\)</span>；</li><li>任何基本权 <span class="math inline">\(\omega_s\)</span> 满足 <span class="math inline">\((\omega_s,\omega_s)\leq0\)</span>；</li><li>任何两个基本权 <span class="math inline">\(\omega_s,\omega_t\)</span> 满足 <span class="math inline">\((\omega_s,\omega_t)\leq0\)</span>并且它们生成的二维子空间 <span class="math inline">\(\mathrm{span}\{\omega_i,\omega_j\}\)</span>不是正定的。</li></ol><p><strong>1. 证明 <span class="math inline">\((\cdot,\cdot)\)</span>是双曲的</strong>。</p><p>用反证法，如果 <span class="math inline">\(\Gamma\)</span> 的 level是 1 但不是双曲的，则根据 <a href="#lemma-uv" title="引理 2.2">引理2.2</a> 我们可以取两个正交的非零向量 <span class="math inline">\(u,v\)</span> 满足 <span class="math inline">\((u,u)&lt;0,\, (v,v)=0\)</span>。</p><p>我们有如下两个断言（证明见 <a href="#appendixA">附录 A</a>）：</p><div id="assetA" class="statement sta___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">断言</span>.</span><span class="statement-spah"></span><br></p><ol type="1"><li>若向量 <span class="math inline">\(u=\sum_{s\in S} u_s\alpha_s\)</span> 满足 <span class="math inline">\((u,u)&lt;0\)</span>，则所有 <span class="math inline">\(u_s\)</span> 非零且同号。</li><li>若向量 <span class="math inline">\(v=\sum_{s\in S} v_s\alpha_s\)</span> 满足 <span class="math inline">\((v,v)=0\)</span>，则至多一个 <span class="math inline">\(v_s\)</span> 为零，其余同号。</li></ol></div><p>取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(v_s\ne 0\)</span>，则 <span class="math inline">\(u'=v_su-u_sv\)</span> 满足 <span class="math inline">\((u',u')=v_s^2(u,u)&lt;0\)</span>，且 <span class="math inline">\(u'\)</span> 的 <span class="math inline">\(\alpha_s\)</span> 项系数 <span class="math inline">\(u'_s=0\)</span>，这与断言 1 矛盾。所以 <span class="math inline">\(\Gamma\)</span> 是双曲的。</p><p><strong>2. 证明 <span class="math inline">\((\omega_s,\omega_s)\leq0\)</span></strong></p><p>由 <span class="math inline">\(\Gamma\)</span> 的 level 是 1可得删除任意一个顶点 <span class="math inline">\(s\)</span> 后的子图<span class="math inline">\(\Gamma \setminus\{s\}\)</span>是有限或仿射的，即子空间 <span class="math inline">\(\omega_s^\perp =\mathrm{span}\{\alpha_t \mid t \ne s\}\)</span>是正定或者半正定的。由于刚刚已经证明了 <span class="math inline">\((\cdot,\cdot)\)</span> 是双曲的，所以 <span class="math inline">\(\omega_s\)</span> 不是 space-like 的，即 <span class="math inline">\((\omega_s, \omega_s) \leq 0\)</span>。于是任何<span class="math inline">\(\omega_s\,(s\in S)\)</span> 都不是实的。</p><p><strong>3. 证明 <span class="math inline">\((\omega_s,\omega_t)\leq0\)</span> 且 <span class="math inline">\(\mathrm{span}\{\omega_i,\omega_j\}\)</span>非正定</strong></p><p>由于 <span class="math inline">\((\omega_s,\omega_s)\leq0\)</span>，结合恒等式<span class="math inline">\((\ref{eq:idI})\)</span> 和 <a href="#assetA" title="断言">断言</a> 我们有：</p><ol type="1"><li>如果 <span class="math inline">\((\omega_s,\omega_s)&lt;0\)</span>，则所有的 <span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span> 都小于0。</li><li>如果 <span class="math inline">\((\omega_s,\omega_s)=0\)</span>，则所有的 <span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span> 都不为 0且同号。根据恒等式 <span class="math inline">\((\ref{eq:idII})\)</span>不难确定它们都小于 0。</li></ol><p>总之对任何 <span class="math inline">\(s\ne t\)</span> 都有 <span class="math inline">\((\omega_s,\omega_t)&lt;0\)</span>。进一步，考虑二维子空间<span class="math inline">\(U_{s,t}={\rmspan}\{\omega_s,\omega_t\}\)</span>，其正交补是 <span class="math inline">\(U_{s,t}^\bot=\mathrm{span}\{\alpha_{k}\mid k\nes,t\}\)</span>，根据 <a href="#level-l" title="定理 1.2">定理 1.2</a><span class="math inline">\(U_{s,t}^\bot\)</span> 是 space-like 的，说明<span class="math inline">\(U_{s,t}\)</span> 是 time-like 的，从而 <span class="math inline">\(\{\omega_s,\omega_t\}\)</span> 是分离的。</p><p>综上，三点均得证，定理成立。<span class="math inline">\(\blacksquare\)</span></p><div id="level-1-tits" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.4</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(W\)</span> 的 level 为 1，则 Tits 锥的闭包 <span class="math inline">\(\overline{ \mathcal{C} }\)</span> 等于 <span class="math inline">\(\mathcal{Q}_+\)</span> 或者 <span class="math inline">\(\mathcal{Q}_-\)</span> 之一。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个结论告诉我们在 level 1 时空间的边界上没有球堆。</p></div><p><strong>证明</strong>：由于 level 1 是双曲的，根据 <a href="/coxeter-groups/three-geometries#tits-closure">双曲情形 Tits锥的结论</a>，<span class="math inline">\(\mathcal{C}\)</span> 包含<span class="math inline">\(\mathcal{N}_+,\mathcal{N}_-\)</span>之一，不妨设 <span class="math inline">\(\mathcal{C}\supset\mathcal{N}_+\)</span>，则 <span class="math inline">\(\overline{ \mathcal{C} }\supset\overline{\mathcal{N}_+ }=\mathcal{Q}_+\)</span>。为了证明反向包含关系，只要证<span class="math inline">\(\overline{ \mathcal{C}}\subset\mathcal{Q}\)</span> 和 <span class="math inline">\(\overline{\mathcal{C} }\cap\mathcal{Q}_-=\{0\}\)</span>。</p><p>根据 <a href="#level-1" title="定理 2.3">定理 2.3</a>，所有的基本权<span class="math inline">\(\{\omega_s\}\)</span>都不是实的且两两分离。设 <span class="math inline">\(x=\sum_{s\inS}c_s\omega_s\,(c_s\geq0)\)</span> 是 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 中任意一点，则<span class="math display">\[(x,x)=\sum_{s,t\inS}c_sc_t\underbrace{(\omega_s,\omega_t)}_{\leq0}\leq0.\]</span> 即 <span class="math inline">\(\overline{\mathcal{D}}\subset\mathcal{Q}\)</span>。<span class="math inline">\(W\)</span> 作为正交变换群保持 <span class="math inline">\(\mathcal{Q}\)</span> 不变，所以 <span class="math inline">\(\mathcal{C}=\bigcup\limits_{w\inW}w\overline{\mathcal{D}}\subset\mathcal{Q}\)</span>，从而 <span class="math inline">\(\overline{ \mathcal{C}}\subset\mathcal{Q}\)</span>。</p><p>再来说明 <span class="math inline">\(\overline{ \mathcal{C}}\cap\mathcal{Q}_-=\{0\}\)</span>。若存在 <span class="math inline">\(v\in\overline{ \mathcal{C}}\cap\mathcal{Q}_-\)</span> 且 <span class="math inline">\(v\ne0\)</span>，取某个 <span class="math inline">\(u\in\mathcal{N}_+\)</span> 使得 <span class="math inline">\(u,v\)</span> 线性无关，<a href="/coxeter-groups/three-geometries/#connected-component-dot">则<span class="math inline">\(u,v\)</span> 的某个正线性组合是 space-like的</a>，此向量仍在 <span class="math inline">\(\overline{ \mathcal{C}}\)</span> 中，这与 <span class="math inline">\(\overline{ \mathcal{C}}\subset\mathcal{Q}\)</span> 矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 id="处理-level-2-的基本技巧">处理 level 2 的基本技巧</h1><p>在上一节的基础上，我们进一步讨论 level 2 的 Coxeter群，并证明它们同样是双曲的。由于接下来的证明较为复杂，细节较多，读者阅读时可能会感到吃力。因此，我借鉴编程中的“模块化”思路，先解释一下接下来的核心思想。</p><p>我们处理 level 2 的情形的基本策略是转化为 level 1 的情形。设 <span class="math inline">\(\Gamma\)</span> 是 level 为 2 的 Coxeter图，取一个实的基本权 <span class="math inline">\((\omega_s,\omega_s)&gt;0\)</span>，则子图 <span class="math inline">\(\Gamma\setminus\{s\}\)</span> 的 level 是 1。记<span class="math inline">\(I = S\setminus\{s\}\)</span>，<span class="math inline">\(W_I\)</span> 是标准椭圆子群，此时有 <span class="math display">\[V_I=\omega_s^\bot=\mathrm{span}\{\alpha_t\midt\ne s\}.\]</span> <span class="math inline">\(W_I\)</span> 在 <span class="math inline">\(V_I\)</span> 上作用的基本区域的闭包是 <span class="math display">\[\overline{\mathcal{D}}_I= \{v\in V_I\mid (v,\alpha_t)&gt;0,\, \forall t\in I\}=\mathrm{cone}(\{\omega_t\mid t\inI\}).\]</span></p><p>根据 <a href="#level-1-tits" title="推论 2.4">推论 2.4</a>，<span class="math inline">\(\overline{\mathcal{D}}_I\)</span> 包含在 <span class="math inline">\(\mathcal{Q}_I=\{v\in V_I\mid (v,v)\leq0\}\)</span>的上下两个分支之一中，所以任何 <span class="math inline">\(x,y\in\overline{\mathcal{D}}_I\)</span>之间的内积小于等于 0： <span class="math display">\[(x,y)\leq0, \quad\forall x,y\in \overline{\mathcal{D}}_I.\]</span> 特别地，对任何 <span class="math inline">\(x\in\overline{\mathcal{D}}_I\)</span> 有 <span class="math display">\[(x,x)\leq0 \text{ and } (x,\omega_t)\leq0\text{for all }t\in I.\]</span> 于是对 <span class="math inline">\(v\inV\)</span>，如果它在 <span class="math inline">\(V_I\)</span> 上的投影<span class="math inline">\(v_I\)</span> 满足 <span class="math inline">\(v_I\in\overline{\mathcal{D}}_I\)</span>，那么我们就可以利用上面的关系得出关于<span class="math inline">\(v\)</span> 的信息来。</p><div id="observeA" class="statement sta____a definition unnumbered"><p><span class="statement-heading"><span class="statement-label">观察A</span>：</span><span class="statement-spah"> </span>取 <span class="math inline">\(v=\alpha_s\)</span>，<span class="math inline">\(\alpha_s'=\alpha_s-\omega_s/(\omega_s,\omega_s)\)</span>是 <span class="math inline">\(\alpha_s\)</span> 在 <span class="math inline">\(\omega_s^\bot=V_I\)</span> 上的投影，则对任何<span class="math inline">\(t\in I\)</span> 有 <span class="math display">\[(\alpha_s',\alpha_t)=(\alpha_s,\alpha_t)\leq0.\]</span> 这说明 <span class="math inline">\(-\alpha_s'\in\overline{\mathcal{D}}_I\)</span>，于是我们有<span class="math display">\[\begin{aligned}&amp;(\alpha_s',\alpha_s')=1-\frac{1}{(\omega_s,\omega_s)}\leq0,\\&amp;(-\alpha_s',\omega_t)=\frac{(\omega_s,\omega_t)}{(\omega_s,\omega_s)}\leq0\text{ for all }t\in I.\end{aligned}\]</span> 整理即得 <span class="math inline">\(0&lt;(\omega_s,\omega_s)\leq1\)</span>，以及 <span class="math inline">\((\omega_s,\omega_t)\leq0\)</span> 对任何 <span class="math inline">\(t\in I\)</span> 成立。</p></div><p>真不错！我们轻松得到了一个关于 level 2 情形实的基本权 <span class="math inline">\(\omega_s\)</span> 的重要结论。</p><div id="observeB" class="statement sta____b definition unnumbered"><p><span class="statement-heading"><span class="statement-label">观察B</span>：</span><span class="statement-spah"> </span>设 <span class="math inline">\(v\in\mathcal{C}\)</span> 是 Tits 锥中一点，则<span class="math inline">\(v\)</span> 可以写成 <span class="math inline">\(v=wx\,(w\inW,x\in\overline{\mathcal{D}})\)</span>。其在 <span class="math inline">\(V_I\)</span> 上的投影为 <span class="math display">\[v_I = v -\frac{(v,\omega_s)}{(\omega_s,\omega_s)}\omega_s.\]</span> 由于 <span class="math inline">\((v-v_I)\perp V_I\)</span>，所以对任何 <span class="math inline">\(\alpha_k\,(k\ne i)\)</span> 有 <span class="math display">\[(v_I,\alpha_k)=(v,\alpha_k)=(wx,\alpha_k)=(x,w^{-1}\alpha_k).\]</span> 为了保证让 <span class="math inline">\(v_I\)</span> 落在 <span class="math inline">\(\overline{\mathcal{D}}_I\)</span>中，我们需要让这些 <span class="math inline">\((x,w^{-1}\alpha_k)\geq0\)</span>。由于 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，所以只要让每个<span class="math inline">\(w^{-1}\alpha_k\,(k\in I)\)</span>都是负根，也就是让 <span class="math inline">\(l(s_kw)&lt;l(w)\)</span>即可。</p><p>总结起来就是，如果对任何 <span class="math inline">\(k\in I\)</span>有 <span class="math inline">\(l(s_kw)&lt;l(w)\)</span>，那么就有 <span class="math inline">\(v_I\in\overline{\mathcal{D}}_I\)</span> 成立。</p></div><p>这个例子看起来附加了比较强的条件，但是它确实会在后面用到。</p><h1 id="level-2-也是双曲的">Level 2 也是双曲的</h1><div id="level-2" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.1</span>.</span><span class="statement-spah"> </span>level 等于 2的群都是双曲的，所有的基本权 <span class="math inline">\(\{\omega_s\mids\in S\}\)</span> 两两分离。<span class="math inline">\(\omega_s\)</span> 是实的当且仅当 <span class="math inline">\(T\setminus\{s\}\)</span> 的 level 等于1，且对这样的 <span class="math inline">\(\omega_s\)</span> 有 <span class="math inline">\(0&lt;(\omega_s,\omega_s)\leq 1\)</span>。</p></div><p><strong>证明</strong>：我们先来证明 <span class="math inline">\(\Gamma\)</span> 是双曲的。</p><p>如果 <span class="math inline">\(|\Gamma|=3\)</span>，<span class="math inline">\(\Gamma\)</span> 的 level 是 2 说明其必然有一条边的Vinberg 标号小于 -1。不妨设 <span class="math inline">\((\cdot,\cdot)\)</span> 的 Gram 矩阵形如 <span class="math display">\[\begin{pmatrix}1&amp;a&amp;b\\a&amp;1&amp;c\\b&amp;c&amp;1\end{pmatrix}.\]</span>其中 <span class="math inline">\(a,\,b,\,c\leq0\)</span> 且 <span class="math inline">\(a &lt; -1\)</span>。这个矩阵的行列式是 <span class="math display">\[1-a^2 + 2bc(a+1)-(b+c)^2&lt;0.\]</span>由于矩阵的迹等于 3，所以其符号必然是 <span class="math inline">\((2,1)\)</span>，从而是双曲的。</p><p>再处理 <span class="math inline">\(|\Gamma|\geq4\)</span>的情形。仍然根据 <a href="#lemma-uv" title="引理 2.2">引理 2.2</a>，如果<span class="math inline">\(\Gamma\)</span>不是双曲的，则可以取两个非零且正交的向量 <span class="math inline">\(u,v\)</span> 满足 <span class="math inline">\((u,u)&lt;0,\,(v, v)=0\)</span>。</p><p>我们也有如下两个断言（证明见 <a href="#appendixB">附录 B</a> ）：</p><div id="assetB" class="statement sta___-1 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">断言</span>.</span><span class="statement-spah"></span><br></p><ol type="1"><li>若向量 <span class="math inline">\(u=\sum_{s\in S} u_s\alpha_s\)</span> 满足 <span class="math inline">\((u,u)&lt;0\)</span>，则除去至多一个系数 <span class="math inline">\(u_j\)</span> 之外，其它的 <span class="math inline">\(u_s\,(s\ne j)\)</span> 都非零且同号。</li><li>若向量 <span class="math inline">\(v=\sum_{s\in S} v_s\alpha_s\)</span> 满足 <span class="math inline">\((v,v)=0\)</span>，则除了断言 1的情形之外，还有一种情形是 <span class="math inline">\(v_s\)</span>中有两个是 0，其余的非零且同号。</li></ol></div><p>由于 <span class="math inline">\((u,u)&lt;0\)</span> 和 <span class="math inline">\((v,v)=0\)</span>，所以 <span class="math inline">\(\{u_s\}\)</span> 中至多一个是 0，<span class="math inline">\(\{v_s\}\)</span> 中至多两个是 0，而 <span class="math inline">\(|\Gamma|\geq4\)</span>，所以存在下标 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(u_i,\,v_i\)</span> 均不为 0。通过适当取 <span class="math inline">\(\pm v\)</span> 可以不妨设 <span class="math inline">\(v_i&lt;0\)</span>。<span class="math inline">\(u'=v_iu-u_iv\)</span> 仍然满足 <span class="math inline">\(u'\perp v\)</span> 和 <span class="math inline">\((u',u')&lt;0\)</span>，但是系数 <span class="math inline">\(u'_i=0\)</span>，用 <span class="math inline">\(u'\)</span> 作为 <span class="math inline">\(u\)</span> 可以不妨设 <span class="math inline">\(u\)</span> 的系数 <span class="math inline">\(u_i=0\)</span>。再进一步调整 <span class="math inline">\(\pm u\)</span> 可以使得其它 <span class="math inline">\(u_s&gt;0\,(s\ne i)\)</span>。</p><p>记 <span class="math inline">\(J=\{j\in S\mid u_j\ne0 \text{ and}v_j\ne 0\}\)</span>。分情况讨论：</p><ul><li><p><span class="math inline">\(|J|\geq 2\)</span>：</p><p>这时必然存在 <span class="math inline">\(j,k\in J\)</span> 使得 <span class="math inline">\(a=v_j/u_j &lt; v_k/u_k\)</span>。<span class="math inline">\(u'=au-v\)</span> 是 time-like 的，其系数 <span class="math inline">\(u'_i=-v_i&gt;0\)</span>，<span class="math inline">\(u'_j=0\)</span>，<span class="math inline">\(u'_k\leq 0\)</span>，与断言 1 矛盾。</p></li><li><p><span class="math inline">\(|J|\leq1\)</span>：</p><p>这时必有 <span class="math inline">\(|\Gamma|=4\)</span> 且 <span class="math inline">\(v\)</span> 形如 <span class="math inline">\(v=v_i\alpha_i +v_j\alpha_j\)</span>。如下表所示：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(i\)</span></th><th style="text-align: center;"><span class="math inline">\(j\)</span></th><th style="text-align: center;"><span class="math inline">\(k\)</span></th><th style="text-align: center;"><span class="math inline">\(m\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(u\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(&lt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(\ne0\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td></tr></tbody></table><p><span class="math inline">\(\mathrm{span}\{\alpha_i,\alpha_j\}\)</span>是仿射的（它包含 <span class="math inline">\(v\)</span>，不可能是有限的），从而 <span class="math inline">\((\alpha_i,\alpha_j)=-1\)</span> 且 <span class="math inline">\(v_i=v_j\)</span>。不妨将 <span class="math inline">\(v\)</span> 缩放为 <span class="math inline">\(v=\alpha_i+\alpha_j\)</span>。</p><p>设 <span class="math inline">\(u=u_j\alpha_j+u_k\alpha_k+u_m\alpha_m\)</span>，由<span class="math inline">\((u,v)=0\)</span> 可得 <span class="math display">\[(u_j\alpha_j+u_k\alpha_k+u_m\alpha_m,v)=(u_k\alpha_k+u_m\alpha_m, \alpha_i+\alpha_j)=0,\]</span> 由于 <span class="math inline">\(\{\alpha_k,\alpha_m\}\)</span> 和 <span class="math inline">\(\{\alpha_i,\alpha_j\}\)</span>之间的内积都小于等于 0，而 <span class="math inline">\(u_k,u_m\)</span>大于 0，这说明 <span class="math display">\[(\alpha_k,\alpha_i) =(\alpha_k,\alpha_j) =(\alpha_m, \alpha_i)=(\alpha_m,\alpha_j)=0.\]</span> 即 <span class="math inline">\(\{i,j\}\)</span> 与 <span class="math inline">\(\{k,m\}\)</span>是不连通的，与 <span class="math inline">\(\Gamma\)</span>连通矛盾。</p></li></ul><p>至此我们证明了当 <span class="math inline">\(\Gamma\)</span> 的 level等于 2 时是双曲的。</p><p>我们接下来证明所有的基本权 <span class="math inline">\(\{\omega_s\}\)</span>是两两分离的。我们先来说明不论 <span class="math inline">\((\omega_s,\omega_s)\)</span>的符号如何，它与其它的基本权 <span class="math inline">\(\omega_t\,(t\nes)\)</span> 的内积满足 <span class="math inline">\((\omega_s,\omega_t)\leq0\)</span>。</p><p>分情况讨论：</p><ul><li>如果 <span class="math inline">\((\omega_s,\omega_s)&gt;0\)</span>，由 <a href="#observeA" title="观察 A">观察 A</a> 的讨论即得。</li><li>如果 <span class="math inline">\((\omega_s,\omega_s)\leq0\)</span>，则根据 <span class="math inline">\((\ref{eq:idII})\)</span>，<span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span>中必须至少有一个严格小于 0，从而根据 <a href="#assetB" title="断言">断言</a>，在 <span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span>中至多有一个为正。但我们将证明这不可能。否则不妨设 <span class="math inline">\(k\ne s\)</span> 使得 <span class="math inline">\((\omega_s,\omega_k)&gt;0\)</span>。在 <span class="math inline">\((\ref{eq:idI})\)</span> 两边用 <span class="math inline">\(\alpha_k\)</span> 内积得到 <span class="math display">\[0=(\omega_s,\omega_s)(\alpha_s,\alpha_k)+\sum_{t\ne s,k} (\omega_s,\omega_t)(\alpha_t,\alpha_k) +(\omega_s,\omega_k).\]</span> 上面的和项前两个都非负，最后一个大于0，矛盾。所以所有的 <span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span>都非正。</li></ul><p>又因为对任何 <span class="math inline">\(s,t\)</span>，<span class="math inline">\(\Gamma\setminus\{s,t\}\)</span>是有限或者仿射的，所以其正交补，即 <span class="math inline">\(\{\omega_s,\omega_t\}\)</span>张成的二维子空间不是正定的，从而 <span class="math inline">\(\{\omega_s\}\)</span> 之间是两两分离的。<span class="math inline">\(\blacksquare\)</span></p><h1 id="level-1-2-等价于双曲和分离">level = 1, 2 等价于双曲和分离</h1><div id="level-12" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.1</span>.</span><span class="statement-spah"></span>下面两点是等价的：</p><ol type="1"><li><span class="math inline">\(\Gamma\)</span> 的 level 等于 1 或2；</li><li><span class="math inline">\(\Gamma\)</span>是双曲的，且任何两个权都互相分离。</li></ol></div><p><strong>证明</strong>：</p><p><span class="math inline">\(1\Rightarrow 2\)</span>：只要再证明对任何<span class="math inline">\(w\in W\)</span>，以及两个基本权 <span class="math inline">\(\omega_i,\,\omega_j\)</span>，如果有 <span class="math inline">\(\omega_i\ne w(\omega_j)\)</span>，则 <span class="math inline">\((\omega_i,w(\omega_j))\leq0\)</span>，并且二维子空间<span class="math inline">\(\{\omega_i,w(\omega_j)\}\)</span>不是正定的。</p><p>对 <span class="math inline">\(l(w)\)</span> 归纳：<span class="math inline">\(l(w)=0\)</span> 的情形在 <a href="#level-1" title="定理 2.3">定理 2.3</a> 和 <a href="#level-2" title="定理 4.1">定理 4.1</a> 中已经证明。下面假设 <span class="math inline">\(l(w)&gt;0\)</span>，且结论对所有长度 <span class="math inline">\(&lt;l(w)\)</span> 的元素成立。</p><ol type="1"><li><p>如果存在 <span class="math inline">\(k\ne i\)</span> 使得 <span class="math inline">\(l(s_kw)&lt;l(w)\)</span>，则由于反射 <span class="math inline">\(s_k\)</span> 是正交变换，并且保持 <span class="math inline">\(\omega_i\)</span> 不动，有 <span class="math display">\[(\omega_i,s_kw(\omega_j))\xrightarrow{\ s_k\ }(\omega_i,w(\omega_j)).\]</span>由归纳假设左边是分离的，从而右边也是分离的。</p></li><li><p>如果对任何 <span class="math inline">\(k\ne i\)</span> 都有 <span class="math inline">\(l(s_kw)&gt;l(w)\)</span>，则 <span class="math inline">\(w\)</span> 的任一既约表示必然以 <span class="math inline">\(s_i\)</span> 开头，即 <span class="math inline">\(w\)</span> 形如 <span class="math inline">\(w=s_iw'\)</span> 且 <span class="math inline">\(l(w)&gt;l(w')\)</span>。从而 <span class="math display">\[(\omega_i,w(\omega_j))\xrightarrow{\ s_i\}(\omega_i-2\alpha_i, w'(\omega_j)) =(\omega_i,w'(\omega_j))-2(\alpha_i,w'(\omega_j)).\]</span></p><ul><li>如果 <span class="math inline">\(\omega_i\new'(\omega_j)\)</span>，则由归纳假设上面第一项 <span class="math inline">\((\omega_i,w'(\omega_j))\leq0\)</span>。第二项由于 <span class="math display">\[l(s_iw')&gt;l(w')\Rightarroww'^{-1}\alpha_i\in\Phi^+\Rightarrow (w'^{-1}\alpha_i,\omega_j)\geq0 \Rightarrow (\alpha_i, w'(\omega_j))\geq0.\]</span>所以 <span class="math inline">\((\omega_i,w(\omega_j))\leq0\)</span>成立。</li><li>如果 <span class="math inline">\(\omega_i=w'(\omega_j)\)</span>，则 <span class="math inline">\(w(\omega_j)=s_iw'(\omega_j)=s_i(\omega_i)\)</span>，于是<span class="math display">\[(\omega_i, w(\omega_j))=(\omega_i,s_i(\omega_i))\xrightarrow{\ s_i\}(\omega_i-2\alpha_i,\omega_i)=(\omega_i, \omega_i)-2 &lt;0.\]</span>其中最后一个不等号是利用了 <a href="#level-1" title="定理 2.3">定理2.3</a> 和 <a href="#level-2" title="定理 4.1">定理 4.1</a> 的结论：若<span class="math inline">\(\Gamma\)</span> 的 level 是 1 则 <span class="math inline">\((\omega_i, \omega_i)\leq0\)</span>，若 <span class="math inline">\(\Gamma\)</span> 的 level 是 2 则 <span class="math inline">\((\omega_i,\omega_i)\leq 1\)</span>。</li></ul><p>我们已经证明了 <span class="math inline">\((\omega_i,w(\omega_j))\)</span> 总是 <span class="math inline">\(\leq0\)</span> 的。还需要说明 <span class="math inline">\(\mathrm{span}\{\omega_i,w(\omega_j)\}\)</span>不是正定的。记 <span class="math inline">\(U=\mathrm{span}\{\omega_i,w(\omega_j)\}\)</span>。用反证法，如果<span class="math inline">\(U\)</span> 是正定的，则 <span class="math inline">\((\omega_i,\omega_i)&gt;0\)</span> 是实的。记 <span class="math display">\[v_I = w(\omega_j) -\frac{(\omega_i,w(\omega_j))}{(\omega_i,\omega_i)} \omega_i\]</span> 是<span class="math inline">\(w(\omega_j)\)</span> 在 <span class="math inline">\(\omega_i^\bot\)</span> 上的投影，则 <span class="math inline">\(v_I\in U\)</span> 是 space-like 的向量。但是根据<a href="#observeB" title="观察 B">观察 B</a> 中的讨论，<span class="math inline">\(v_I\in\overline{\mathcal{D}}_I\)</span>，从而<span class="math inline">\((v_I, v_I)\leq0\)</span>，矛盾。</p></li></ol><p><span class="math inline">\(2\Rightarrow 1\)</span>：由于内积 <span class="math inline">\((\cdot,\cdot)\)</span> 是双曲的，而子空间 <span class="math inline">\(\mathrm{span}\{\omega_i,\omega_j\}\)</span>不是正定的，所以其正交补是正定或者半正定的。于是 <span class="math inline">\(\Gamma\setminus\{i,j\}\)</span>是有限或者仿射的，从而 <span class="math inline">\(\Gamma\)</span> 的level 等于 1 或 2。</p><h1 id="一个技术性命题">一个技术性命题</h1><p>下面这个命题仅会在后面 Boyd-Maxwell球堆的一个细分情形中使用一次，但是它的论证颇为不易，所以我把它放在这里。</p><div id="ideal-vertex" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题6.1</span> <span class="statement-info">(<span class="citation" data-cites="Maxwell89">(<a href="#ref-Maxwell89" role="doc-biblioref">Maxwell 1989</a>, proposition5.15)</span>)</span>.</span><span class="statement-spah"> </span><br></p><p>设 <span class="math inline">\((W,S)\)</span> 是不可约 Coxeter群，<span class="math inline">\(s\in S\)</span>，<span class="math inline">\(I=S\setminus\{s\}\)</span>，并且有如下条件成立：</p><ol type="1"><li><span class="math inline">\((\omega_s,\omega_s)=0\)</span>。</li><li>标准椭圆子群 <span class="math inline">\(W_I\)</span>是不可约、仿射的。</li><li>对任何 <span class="math inline">\(i\in I\)</span> 有 <span class="math inline">\((\omega_s,\omega_i)&lt;0\)</span>。</li></ol><p>则对任意 <span class="math inline">\(p\in\overline{\mathcal{D}}\)</span> 都有 <span class="math inline">\(\omega_s\in\overline{ \mathrm{cone}(\bigcup_{w\inW_I}wp) }\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>由于 <span class="math inline">\(\bigcup_{w\in W_I}wp\)</span>是无限集，<span class="math inline">\(\mathrm{cone}(\bigcup_{w\inW_I}wp)\)</span> 未必是闭集，因此闭包记号不可少。</p><p>当 <span class="math inline">\(W\)</span> 的 level 是 1 时，若 <span class="math inline">\(\omega_s\)</span>是一个位于双曲空间边界上的理想顶点，则命题的条件都满足。这时 <span class="math inline">\(W_I\)</span> 是经过 <span class="math inline">\(\omega_s\)</span>的那些镜面生成的标准椭圆子群，<span class="math inline">\(W_I\)</span>会把基本区域无限压缩到 <span class="math inline">\(\omega_s\)</span>附近，如下图所示：</p><p><img src="/images/coxeter/ideal-vertex.jpg" class="fig" width="350"></p></div><p><strong>证明</strong>：由已知 <span class="math inline">\(V_I=\mathrm{span}\{\alpha_i\mid i\in I\}\)</span>是仿射的，并且 <span class="math inline">\(\mathrm{rad}(V_I)\)</span>是一维的。由恒等式 <span class="math inline">\((\ref{eq:idI})\)</span>：<span class="math display">\[\omega_s = \sum_{i\inI}(\omega_s,\omega_i)\,\alpha_i\in V_I.\]</span> 因此 <span class="math inline">\(\mathrm{rad}(V_I)=\mathbb{R}\omega_s\)</span>。于是<span class="math inline">\(W_I\)</span> 固定 <span class="math inline">\(\omega_s\)</span>，即 <span class="math display">\[\mathbb{R}\omega_s\xrightarrow{\ W_I\, -\, 1\ }0.\]</span> <span class="math inline">\(W_I\)</span> 同样作用在商空间<span class="math inline">\(V_I/\mathbb{R}\omega_s\)</span>上，此作用给出了一个同态 <span class="math inline">\(W_I\to\mathrm{GL}(V_I/\mathbb{R}\omega_s)\)</span>。令<span class="math inline">\(K\)</span> 为此同态的核，则对任何 <span class="math inline">\(w\in K\)</span>， <span class="math display">\[w(v+ \mathbb{R}\omega_s) = v + \mathbb{R}\omega_s,\quad v\in V_I.\]</span>即 <span class="math inline">\(wv-v\in\mathbb{R}\omega_s\)</span>，从而<span class="math display">\[V_I\xrightarrow{\ K - 1\}\mathbb{R}\omega_s\xrightarrow{\ W_I\, -\, 1\ } 0.\]</span> 由于 <span class="math inline">\(K\leqslant W_I\)</span>，所以 <span class="math display">\[V_I\xrightarrow{\ K - 1\}\mathbb{R}\omega_s\xrightarrow{\ K-1\ }0.\]</span> 即 <span class="math inline">\((K-1)^2V_I\equiv0\)</span>。</p><p>进一步，对 <span class="math inline">\(w\in K\)</span>，<span class="math inline">\(w\)</span> 是一些 <span class="math inline">\(I\)</span> 中生成元的乘积，所以 <span class="math inline">\(w\alpha_s\)</span> 形如 <span class="math inline">\(w\alpha_s=\alpha_s+\sum\limits_{i\inI}c_i\alpha_i\)</span>，所以 <span class="math inline">\((w-1)\alpha_s\in V_I\)</span>，从而 <span class="math inline">\(w-1\)</span> 将整个 <span class="math inline">\(V\)</span> 也映入 <span class="math inline">\(V_I\)</span>，于是 <span class="math display">\[V\xrightarrow{\ K-1\ } V_I\xrightarrow{\ K - 1\}\mathbb{R}\omega_s\xrightarrow{\ K-1\ }0.\]</span> 即 <span class="math inline">\((K-1)^2V\subset\mathbb{R}\omega_s\)</span>，<span class="math inline">\((K-1)^3V\equiv0\)</span>。</p><p>取 <span class="math inline">\(w\in K\)</span> 且 <span class="math inline">\(w\ne 1\)</span> <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，并记 <span class="math inline">\(A=w-1\)</span>，由 <span class="math inline">\(V_I\xrightarrow{A}\mathbb{R}\omega_s\)</span> 可知<span class="math display">\[A\alpha_i = \lambda_i\omega_s,\quad i\inI,\,\lambda_i\in\mathbb{R}.\]</span> 由于 <span class="math inline">\(w\)</span> 不是 <span class="math inline">\(V_I\)</span> 上的恒等变换，所以至少对一个 <span class="math inline">\(i\in I\)</span> 有 <span class="math inline">\(\lambda_i\ne0\)</span>。</p><p>对 <span class="math inline">\(p\in V\)</span>，设 <span class="math inline">\(Ap=u\in V_I\)</span>。利用 <span class="math display">\[(p,\alpha_i)=(wp,w\alpha_i)=(p+Ap,\alpha_i+A\alpha_i).\]</span>代入 <span class="math inline">\(Ap=u\)</span> 和 <span class="math inline">\(A\alpha_i=\lambda_i\omega_s\)</span>，化简可得<span class="math display">\[(u,\alpha_i)+\lambda_i(p,\omega_s)=0,\qquad\forall i\in I.\]</span> 记 <span class="math inline">\(u=\sum_{j\in I}x_j\alpha_j\,(x_j\in\mathbb{R})\)</span>，<span class="math inline">\(x=(x_i)_{i\in I}\)</span>，<span class="math inline">\(\lambda=(\lambda_i)_{i\in I}\)</span>，则 <span class="math display">\[G x = -(p,\omega_s)\lambda.\]</span> 其中 <span class="math inline">\(G=(\alpha_i,\alpha_j)_{i,j\in I}\)</span> 是 <span class="math inline">\(V_I\)</span> 上的 Gram 矩阵。这是一个关于 <span class="math inline">\(x\)</span> 的线性方程组，由于 <span class="math inline">\(G\)</span>是半正定但不是正定的，所以我们不能直接把 <span class="math inline">\(G\)</span> 的逆矩阵写在右边。但是我们可以用 <span class="math inline">\(G\)</span> 的 Moore-Penrose 将 <span class="math inline">\(x\)</span> 表示为： <span class="math display">\[x= -(p,\omega_s)G^+\lambda.\]</span> 于是 <span class="math display">\[A^2p=A(u)=\sum_{j\in I} x_jA(\alpha_j)=\sum_{j\inI}x_j\lambda_j\omega_s = -(p,\omega_s)\,\lambda^\top G^+\lambda\\omega_s.\]</span> 我们断言有 <span class="math inline">\(a=\lambda^\topG^+\lambda&gt; 0\)</span> 成立。不过这个断言的证明我们放在后面。</p><p>至此我们证明了 <span class="math inline">\(A^2p = -a(p,\omega_s)\omega_s\)</span> 且 <span class="math inline">\(a&gt;0\)</span>。我们来确定 <span class="math inline">\((p,\omega_s)\)</span> 的符号。这里要用到 <span class="math inline">\(p\in\overline{\mathcal{D}}=\mathrm{cone}(\Delta^\ast)\)</span>的条件。如果 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(\omega_s\)</span> 的正倍数，显然 <span class="math inline">\(\omega_s\in\overline{ \mathrm{cone}(\bigcup_{w\inW_I}wp) }\)</span>，命题自然成立。所以我们可以假设 <span class="math inline">\(p\)</span> 与 <span class="math inline">\(\omega_s\)</span> 不共线。设 <span class="math inline">\(p=\sum_{t\in S}c_t\omega_t\,(c_t\geq0)\)</span>，则至少有一个 <span class="math inline">\(t\ne s\)</span> 满足 <span class="math inline">\(c_t&gt;0\)</span>。于是 <span class="math display">\[(\omega_s,p)=\sum_{t\ne s}\underbrace{c_t}_{\geq0\text{ 且至少有一个 } &gt;0}\ \cdot\\underbrace{(\omega_s,\omega_t)}_{\text{已知 }&lt;0}&lt;0.\]</span> 从而<span class="math inline">\(b=-a(\omega_s,p)&gt;0\)</span>。由 <span class="math inline">\(A^3=0\)</span> 与二项式展开： <span class="math display">\[w^N p=(1+A)^N p=p+N Ap+\binom{N}{2}A^2p.\]</span>代入 <span class="math inline">\(A^2p = b\omega_s\)</span> 有 <span class="math display">\[\lim_{N\to\infty}\frac{w^Np}{\binom{N}{2}b}=\omega_s.\]</span>即得所证。</p><p>最后我们来补上 <span class="math inline">\(\lambda^\topG^+\lambda&gt;0\)</span> 的证明。为此我们只要说明有 <span class="math inline">\(\lambda\in\mathrm{im}G\)</span> 即可。由于 <span class="math inline">\(\ker G\)</span> 是一维的。设 <span class="math inline">\(\omega_s = \sum_{i\in I}z_i\alpha_i\)</span>，则易见 <span class="math inline">\(\ker G\)</span>由单个向量 <span class="math inline">\(z=(z_i)_{i\in I}\)</span>生成。</p><p>另一方面在 <span class="math inline">\(\omega_s = \sum_{i\in I}z_i\alpha_i\)</span> 两边用 <span class="math inline">\(A\)</span>作用，有 <span class="math display">\[0=A\omega_s = \sum_{i\inI}z_iA\alpha_i=\sum_{i\in I}z_i\lambda_i\omega_s=(\lambda^\topz)\omega_s.\]</span> 于是 <span class="math inline">\(\lambda^\topz=0\)</span>，即 <span class="math inline">\(\lambda\perp z = \kerG\)</span>，从而 <span class="math inline">\(\lambda\in{\rmim}(G)\)</span>。</p><p><span class="math inline">\(\blacksquare\)</span></p><h1 id="附录">附录</h1><h2 id="appendixA">level 1 情形断言的证明</h2><p>首先是断言 1 的证明。记</p><p><span class="math display">\[I_+=\{s\in S\mid u_s&gt;0\},\quadI_-=\{s\in S\mid u_s&lt;0\},\quad I_0=\{s\in S\mid u_s=0\}.\]</span>并记 <span class="math inline">\(u_+=\sum_{s\inI_+}u_s\alpha_s\)</span>，<span class="math inline">\(u_-=\sum_{t\inI_-}u_t\alpha_t\)</span>，则 <span class="math inline">\(u=u_++u_-\)</span> 且 <span class="math display">\[(u,u)=(u_+,u_+) + (u_-,u_-) +2(u_+,u_-)&lt;0.\]</span> 但是注意到 <span class="math display">\[(u_+,u_-)=\sum_{s\in I_+}\sum_{t\inI_-}\underbrace{u_s}_{&gt;0}\underbrace{u_t}_{&lt;0}\underbrace{(\alpha_s,\alpha_t)}_{\leq0}\geq0.\]</span> 所以 <span class="math inline">\((u_+, u_+) &lt; 0\)</span>和 <span class="math inline">\((u_-, u_-)&lt;0\)</span>至少有一个成立，不妨设 <span class="math inline">\((u_+,u_+)&lt;0\)</span>。如果 <span class="math inline">\(I_-\cupI_0\ne\emptyset\)</span>，那么 <span class="math inline">\(I_+\)</span>作为从 <span class="math inline">\(\Gamma\)</span> 中删去 <span class="math inline">\(I_-\cup I_0\)</span> 后得到的真子图包含 time-like的向量 <span class="math inline">\(u_+\)</span>，这与 <span class="math inline">\(\Gamma\)</span> 的 level 等于 1 矛盾。所以 <span class="math inline">\(I=I_+\)</span>，即所有系数 <span class="math inline">\(u_s\)</span> 都大于 0。相应地如果是 <span class="math inline">\((u_-,u_-)&lt;0\)</span> 的话则所有 <span class="math inline">\(u_s\)</span> 都小于 0。</p><p>对断言 2 我们仍然采用类似的记号，记 <span class="math inline">\(v_+=\sum_{s\in I_+}v_s\alpha_s\)</span>，<span class="math inline">\(v_-=\sum_{t\in I_-}v_t\alpha_t\)</span>，则同样有<span class="math inline">\((v_+,v_-)\geq0\)</span>。</p><p>我们想证明 <span class="math inline">\(|I_0|\leq1\)</span>，并且<span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 中必有一个是空集。</p><p>如果 <span class="math inline">\(|I_0|\geq2\)</span>，那么 <span class="math inline">\((v, v)=0\)</span> 说明删除 <span class="math inline">\(I_0\)</span> 以后得到的子图不是有限的，这与 <span class="math inline">\(\Gamma\)</span> 的 level 是 1 和 <a href="#level-l" title="定理 1.2">定理 1.2</a> 矛盾。所以 <span class="math inline">\(|I_0|\leq 1\)</span>。</p><p>如果 <span class="math inline">\(I_+,\,I_-\)</span>都不是空集的话，则 <span class="math inline">\(v_+,v_-\)</span>都非零，并且必然有 <span class="math inline">\((v_+, v_+)\geq0\)</span>和 <span class="math inline">\((v_-, v_-)\geq0\)</span> 成立，否则删掉<span class="math inline">\(I_+\)</span> 或者 <span class="math inline">\(I_-\)</span> 以后剩下的子图不是有限或者仿射的，与<span class="math inline">\(\Gamma\)</span> 的 level 是 1 矛盾。然而<span class="math display">\[0=(v, v) = (v_+,v_+) + (v_-,v_-) +2(v_+,v_-).\]</span> 三个非负数的和等于 0，只能是 <span class="math inline">\((v_+,v_+) = (v_-,v_-) =(v_+,v_-)=0\)</span>。现在分情况讨论：</p><ol type="1"><li>如果 <span class="math inline">\(|I_0|=1\)</span>，那么删掉 <span class="math inline">\(I_-\cup I_0\)</span> 会至少删掉两个顶点，但 <span class="math inline">\((v_+,v_+)=0\)</span> 说明 <span class="math inline">\(I_+\)</span> 不是有限的，与 <span class="math inline">\(\Gamma\)</span> 的 level 是 1 和 <a href="#level-l" title="定理 1.2">定理 1.2</a> 矛盾。</li><li>如果 <span class="math inline">\(I_0=\emptyset\)</span>，则 <span class="math inline">\(S=I_+\cup I_-\)</span>。然而 <span class="math inline">\((v_+,v_-)=\sum_{s\in I_+,\,t\inI_-}v_sv_t(\alpha_s,\alpha_t)=0\)</span> 说明对任何 <span class="math inline">\(s\in I_+,\,t\in I_-\)</span> 有 <span class="math inline">\((\alpha_s,\alpha_t)=0\)</span>，从而 <span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 互不连通，这与 <span class="math inline">\(\Gamma\)</span> 连通矛盾。</li></ol><p>总之 <span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 必有一个是空集，断言 2 得证。</p><h2 id="appendixB">level 2 情形断言的证明</h2><p>首先是断言 1 的证明。记 <span class="math inline">\(I_+,I_-,I_0\)</span> 如前，并记 <span class="math inline">\(u_+=\sum_{s\in I_+}u_s\alpha_s\)</span>，<span class="math inline">\(u_-=\sum_{t\in I_-}u_t\alpha_t\)</span>。则 <span class="math inline">\((u,u)&lt;0\)</span> 和 <span class="math inline">\((u_+,u_-)\geq0\)</span> 说明 <span class="math inline">\((u_+, u_+) &lt; 0\)</span> 和 <span class="math inline">\((u_-, u_-)&lt;0\)</span> 中至少有一个成立。</p><p>如果 <span class="math inline">\(|I_0|\geq2\)</span>，则 <span class="math inline">\((u,u)&lt;0\)</span> 与 <span class="math inline">\(\Gamma\)</span> 的 level 是 2 矛盾。所以 <span class="math inline">\(|I_0|\leq 1\)</span>。</p><ol type="1"><li>如果 <span class="math inline">\(I_+,I_-\)</span> 都不是空集，则<span class="math inline">\(u_+,\,u_-\)</span> 均不为 0。由于 <span class="math inline">\((u_+, u_+) &lt; 0\)</span> 和 <span class="math inline">\((u_-, u_-)&lt;0\)</span> 中至少有一个成立，不妨设<span class="math inline">\((u_+,u_+)&lt;0\)</span>，结合 <span class="math inline">\(\Gamma\)</span> 的 level 是 2，这要求 <span class="math inline">\(|I_-\cup I_0|\leq 1\)</span>，从而只能是 <span class="math inline">\(|I_-|=1,\, I_0=\emptyset\)</span>。即系数全部非 0且恰好有一个异号。</li><li>如果 <span class="math inline">\(I_+,I_-\)</span>中有一个是空集，不妨设 <span class="math inline">\(I_-=\emptyset\)</span>，我们仍然有 <span class="math inline">\(|I_-\cupI_0|=|I_0|\leq1\)</span>。即系数至多有一个为 0 且其它的均同号。</li></ol><p>总之我们证明了除去至多一个系数之外，其它的系数均非 0 且同号。断言 1得证。</p><p>对断言 2，类似地，我们记 <span class="math inline">\(v_+=\sum_{s\inI_+}v_s\alpha_s\)</span>，<span class="math inline">\(v_-=\sum_{t\inI_-}v_t\alpha_t\)</span>。</p><p>首先 <span class="math inline">\(|I_0|\leq2\)</span> 是显然的，否则<span class="math inline">\((v,v)=0\)</span> 与 <span class="math inline">\(\Gamma\)</span> 的 level 是 2 和 <a href="#level-l" title="定理 1.2">定理 1.2</a> 矛盾。</p><ol type="1"><li>如果 <span class="math inline">\(I_0\ne\emptyset\)</span>，则 <span class="math inline">\(I_+,I_-\)</span> 中必有一个为空。否则 <span class="math inline">\(|I_+\cup I_0|\geq2,\,|I_-\cupI_0|\geq2\)</span>。level 2 要求 <span class="math inline">\((v_+,v_+)\geq0,\,(v_-,v_-)\geq0\)</span>，从而<span class="math inline">\((v,v)=0\)</span> 和 <span class="math inline">\((v_+,v_-)\geq0\)</span> 导致 <span class="math inline">\((v_+,v_+)=(v_-, v_-)=(v_+,v_-)=0\)</span>。由于<span class="math inline">\(\Gamma\)</span> 至少包含 4 个顶点，所以<span class="math inline">\(I_+,\,I_-\)</span>中必有一个包含两个或者更多的顶点。不妨设 <span class="math inline">\(|I_+|\geq2\)</span>，则删除 <span class="math inline">\(I_+\cup I_0\)</span> 会至少删掉 3个顶点，但得到的子图不是正定的，与 <span class="math inline">\(\Gamma\)</span> 的 level 等于 2 矛盾。所以系数<span class="math inline">\(\{v_s\}\)</span> 中如果有 0的话，则至多只有两个 0，且剩下的都同号。</li><li>如果 <span class="math inline">\(I_0=\emptyset\)</span>是空集，则要么 <span class="math inline">\(I_+,I_-\)</span>中有一个也是空集，从而所有的系数都非 0 且同号；要么 <span class="math inline">\(v_+,\,v_-\)</span> 均不为 0。这时 <span class="math inline">\(\Gamma\)</span> 连通说明 <span class="math inline">\((v_+,v_-)&gt;0\)</span>，结合 <span class="math inline">\((v,v)=0\)</span> 可以得出 <span class="math inline">\((v_+,v_+) &lt; 0\)</span> 和 <span class="math inline">\((v_-, v_-)&lt;0\)</span> 中至少有一个成立。不妨设<span class="math inline">\((v_+,v_+)&lt;0\)</span>，则 level 2 要求<span class="math inline">\(|I_-|\leq1\)</span>，即 <span class="math inline">\(\{v_s\}\)</span>均非零且恰有一个元素与其它元素异号。</li></ol><p>至此断言 2 得证，从而定理得证。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div><div id="ref-Maxwell82" class="csl-entry" role="listitem">Maxwell, George. 1982. <span>“Sphere Packings and Hyperbolic ReflectionGroups.”</span> <em>Journal of Algebra</em> 79 (1): 78–97. <a href="https://doi.org/10.1016/0021-8693(82)90318-0">https://doi.org/10.1016/0021-8693(82)90318-0</a>.</div><div id="ref-Maxwell89" class="csl-entry" role="listitem">———. 1989. <span>“Wythoff’s Construction for Coxeter Groups.”</span><em>Journal of Algebra</em> 123 (2): 351–77. <a href="https://doi.org/10.1016/0021-8693(89)90051-3">https://doi.org/10.1016/0021-8693(89)90051-3</a>.</div></div><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>解释下为什么在 <span class="math inline">\(K\)</span>中一定可以找到一个非平凡的元素。由于 <span class="math inline">\(W_I\)</span> 是不可约仿射的，<span class="math inline">\(\mathrm{rad}(V_I)=\mathbb{R}\omega_s\)</span>，<span class="math inline">\((\cdot,\cdot)\)</span> 在 <span class="math inline">\(V_I/\mathbb{R}\omega_s\)</span>上诱导的内积是正定的。商群 <span class="math inline">\(W_I/K\)</span> 是<span class="math inline">\(V_I/\mathbb{R}\omega_s\)</span>中的反射群，并且保持这个正定内积不变，所以根据 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec. 6.4</a>)</span> 的结论，<span class="math inline">\(W_I/K\)</span> 是有限群。由于 <span class="math inline">\(W_I\)</span> 是无限群，所以 <span class="math inline">\(K\)</span> 也是无限群。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（三）：Tits 锥</title>
      <link href="/coxeter-groups/tits-cone.html"/>
      <url>/coxeter-groups/tits-cone.html</url>
      
        <content type="html"><![CDATA[<p>本文主要参考了 Bob Howlett 教授的讲义 <span class="citation" data-cites="Howlett-note">(<a href="#ref-Howlett-note" role="doc-biblioref">Howlett 1996</a>)</span>。</p><h1 id="tits-锥">Tits 锥</h1><p>在获得了 <span class="math inline">\(V\)</span>中关于根系的一些知识后，我们下面转移到 <span class="math inline">\(V\)</span> 的对偶空间 <span class="math inline">\(V^\ast\)</span> 中讨论万花筒的结构。</p><span id="more"></span><p>设 <span class="math inline">\(V^\ast\)</span> 是 <span class="math inline">\(V\)</span> 的对偶空间，<span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 之间存在自然的双线性映射 <span class="math display">\[V\times V^\ast\to\mathbb{R}: \langlev,\,f\rangle= f(v).\]</span> 注意 <span class="math inline">\(\langle\,,\,\rangle\)</span> 和内积 <span class="math inline">\((\cdot,\cdot)\)</span> 的区别：<span class="math inline">\(\langle \,,\,\rangle\)</span> 是 <span class="math inline">\(V\times V^\ast\)</span>的自然配对，用尖括号表示；<span class="math inline">\((\cdot,\cdot)\)</span> 是 <span class="math inline">\(V\)</span> 上的内积。</p><p><span class="math inline">\(V\)</span> 上的可逆线性变换 <span class="math inline">\(g\in\mathrm{GL}(V)\)</span> 同样作用在 <span class="math inline">\(V^\ast\)</span> 上：对 <span class="math inline">\(f\in V^\ast\)</span>，线性泛函 <span class="math inline">\(g\cdot f\)</span> 定义为 <span class="math display">\[(g\cdot f)(v) = f(g^{-1} v).\]</span>为了简便我们省略 <span class="math inline">\(g\cdot f\)</span> 中的<span class="math inline">\(\cdot\)</span>，把它写作 <span class="math inline">\(gf\)</span>。</p><p>这样定义的目的是为了让 <span class="math inline">\(g\)</span>保持双线性映射 <span class="math inline">\(\langle \,,\,\rangle\)</span>不变： <span class="math display">\[\langle gv,\,gf\rangle = \langlev,\,f\rangle.\]</span> 用 <span class="math inline">\(g^{-1}f\)</span>代替 <span class="math inline">\(f\)</span>，我们得到 <span class="math display">\[\langle gv,\,f\rangle = \langlev,\,g^{-1}f\rangle.\]</span> 特别当 <span class="math inline">\(g=s\)</span> 是一个反射时，由于 <span class="math inline">\(s=s^{-1}\)</span> 所以 <span class="math display">\[\langle sv,\,f\rangle = \langlev,\,sf\rangle.\]</span> 这种将单个反射在 <span class="math inline">\((\cdot,\cdot){\,}{}\)</span>两边「跳来跳去」的技巧后面会经常用到。</p><p>由于 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 互为对偶空间，所以 <span class="math inline">\(\Delta=\{\alpha_s\}\)</span> 是 <span class="math inline">\(V^\ast\)</span>上的一组线性无关的泛函，定义它们的正半空间的交为 <span class="math display">\[\mathcal{D}= \bigcap_{s\in S}\{x\in V^\ast\mid\langle \alpha_s,\,x\rangle &gt; 0\}.\]</span> <span class="math inline">\(\mathcal{D}\)</span> 总是 <span class="math inline">\(V^\ast\)</span> 中的非空开集，其闭包记作 <span class="math inline">\(\overline{\mathcal{D}}\)</span>。你可以把 <span class="math inline">\(\mathcal{D}\)</span>理解为万花筒中被镜子围起来的原像房间，超平面的集合 <span class="math inline">\(\{\alpha_s=0\}\)</span> 是房间的墙壁。<span class="math inline">\(\overline{\mathcal{D}}\)</span> 就是 <span class="math inline">\(\mathcal{D}\)</span> 加上了房间四周的墙壁。</p><p><span class="math inline">\(W\)</span> 也作用在 <span class="math inline">\(V^\ast\)</span> 上： <span class="math display">\[\langle v,\,w f\rangle = \langlew^{-1}v,\,f\rangle.\quad v\in V,\,f\in V^\ast.\]</span> 在 <a href="/coxeter-groups/root-system/#faithful">上文</a> 中我们已经证明了<span class="math inline">\(W\)</span> 忠实地作用在 <span class="math inline">\(V\)</span> 上。不难验证在此定义下，<span class="math inline">\(W\)</span> 也忠实地作用在 <span class="math inline">\(V^\ast\)</span> 上，即若 <span class="math inline">\(wf=f\)</span> 对任何 <span class="math inline">\(f\in V^\ast\)</span> 成立，则 <span class="math inline">\(w=1\)</span>。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>Tits 锥定义为<span class="math display">\[\mathcal{C}= \bigcup_{w\in W}w\overline{\mathcal{D}}.\]</span></p></div><p>显然 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(W\)</span>- 不变的。<span class="math inline">\(\mathcal{C}\)</span>可以理解为万花筒，它由原像房间 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 在 <span class="math inline">\(W\)</span> 下的所有虚像构成。</p><p>读者可能有疑问为什么 Tits 锥位于对偶空间 <span class="math inline">\(V^\ast\)</span> 中。看起来更自然的做法是，直接取以<span class="math inline">\(\Delta\)</span>为法向量的正半空间之交作为基本区域： <span class="math display">\[\mathcal{D}=\bigcap_{s\in S}\{v\inV\mid(\alpha_s, v)&gt;0\}\]</span> 在内积 <span class="math inline">\((\cdot,\cdot)\)</span>非退化时，这样做是可以的；但是在 <span class="math inline">\((\cdot,\cdot)\)</span> 退化时，这样定义可能导致<span class="math inline">\(\mathcal{D}\)</span> 是空集。以仿射 <span class="math inline">\(\widetilde{A_1}\)</span> 为例，它的 Coxeter 矩阵是<span class="math display">\[\begin{pmatrix}1 &amp;\infty\\\infty&amp;1\end{pmatrix}.\]</span> 在 <span class="math inline">\(a_{s,t}=1\)</span> 时对应的 Gram 矩阵是 <span class="math display">\[\begin{pmatrix}1&amp;-1\\-1&amp;1\end{pmatrix}.\]</span>设 <span class="math inline">\(v=a\alpha_s+b\alpha_t\)</span> 满足 <span class="math inline">\((v,\alpha_s)&gt;0\)</span> 且 <span class="math inline">\((v,\alpha_t)&gt;0\)</span>，你会发现这要求 <span class="math inline">\(a&gt;b\)</span> 且 <span class="math inline">\(b&gt;a\)</span>，即 <span class="math inline">\(\mathcal{D}\)</span> 是空集！但是通过区分 <span class="math inline">\(W\)</span> 在 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 上的作用就可以避免这个问题。因为<span class="math inline">\(\Delta\)</span> 作为 <span class="math inline">\(V\)</span> 的一组基构成 <span class="math inline">\(V^\ast\)</span> 上一组线性无关的泛函，它们在 <span class="math inline">\(V^\ast\)</span>中正半空间的交是非空的拓扑开集。</p><p>读者可能注意到了：我们使用了 Tits 锥这个称呼，但 <span class="math inline">\(\mathcal{C}\)</span>真的是一个锥吗？这可不显然。要证明 <span class="math inline">\(\mathcal{C}\)</span>确实是锥，我们需要它的另一种等价刻画。</p><p>我们回顾锥的定义：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(C\)</span> 是某实向量空间的子集。如果对任何实数<span class="math inline">\(\alpha\geq0\)</span> 都有 <span class="math inline">\(\alpha C\subset C\)</span>，就称 <span class="math inline">\(C\)</span> 是一个<strong>锥</strong>。如果 <span class="math inline">\(C\)</span> 还是凸集，就称 <span class="math inline">\(C\)</span> 是<strong>凸锥</strong>。凸锥满足对任何<span class="math inline">\(x,y\in C\)</span> 和非负实数 <span class="math inline">\(\alpha,\beta\geq0\)</span>，<span class="math inline">\(\alpha x + \beta y\)</span> 仍然属于 <span class="math inline">\(C\)</span>。</p></div><p>设 <span class="math inline">\(X\)</span>是某实向量空间的子集，定义其生成的凸锥为： <span class="math display">\[\mathrm{cone}(X) = \left\{\sum_{i=1}^n c_ix_i\midx_1,\ldots,x_n\in X,\, c_i\geq0.\right\}.\]</span> 显然 <span class="math inline">\(\mathrm{cone}(X)\)</span> 是包含 <span class="math inline">\(X\)</span> 的最小凸锥。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>当 <span class="math inline">\(X\)</span> 是有限集时，<span class="math inline">\(\mathrm{cone}(X)\)</span> 总是闭集；但是当 <span class="math inline">\(X\)</span> 是无限集时则未必。例如当 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(\mathbb{R}^2\)</span> 中直线 <span class="math inline">\(y=1\)</span> 上的全体整点时，<span class="math inline">\(\mathrm{cone}(X)=\{y&gt;0\}\cup\{0\}\)</span>不是闭集。</p></div><div id="fundamental-weights" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\Delta^\ast=\{\omega_t\}\subset V^\ast\)</span> 是<span class="math inline">\(\Delta\)</span> 的一组对偶基，满足 <span class="math inline">\(\langle\alpha_s,\,\omega_t\rangle=\delta_{st}\)</span>，<span class="math inline">\(\Delta^\ast\)</span>叫做<strong>基本权</strong>。记 <span class="math display">\[\Omega=\bigcup_{w\in W}w\Delta^\ast.\]</span><span class="math inline">\(\Omega\)</span>中的元素叫做<strong>权</strong>。</p></div><div id="fund-cone" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题1.4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\overline{\mathcal{D}}=\mathrm{cone}(\Delta^\ast)\)</span>。</p></div><p><strong>证明</strong>：任何 <span class="math inline">\(x\inV^\ast\)</span> 可以表示为 <span class="math inline">\(x=\sum_{s\inS}c_s\omega_s\)</span>，其中 <span class="math inline">\(c_s=\langle\alpha_s,\,x\rangle\)</span>，于是 <span class="math display">\[x\in\mathrm{cone}(\Delta^\ast)\Leftrightarrowc_s\geq0,\ \forall s \in S \Leftrightarrow \langle\alpha_s,\,x\rangle\geq 0,\ \forall s\in S \Leftrightarrowx\in\overline{\mathcal{D}}.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.5</span>.</span><span class="statement-spah"> </span>对任意 <span class="math inline">\(x\in V^\ast\)</span>，定义 <span class="math display">\[\mathrm{Neg}(x)= \{\lambda\in \Phi^+\mid \langle\lambda,\,x\rangle&lt;0\}.\]</span> <span class="math inline">\(\mathrm{Neg}(x)\)</span> 是正根 <span class="math inline">\(\Phi^+\)</span> 的子集，表示 <span class="math inline">\(x\)</span> 位于哪些镜子的「背面」。即这些镜子挡在<span class="math inline">\(x\)</span> 和基本区域 <span class="math inline">\(\mathcal{D}\)</span> 之间。</p></div><p>显然 <span class="math inline">\(\overline{\mathcal{D}}=\{x\inV^\ast\mid\mathrm{Neg}(x)=\emptyset\}\)</span>。</p><div id="tits-neg-finite" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.6</span>.</span><span class="statement-spah"> </span>Tits 锥 <span class="math inline">\(\mathcal{C}= \{x\in V^\ast \mid |\mathrm{Neg}(x)|&lt; \infty\}\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个定理的几何意义是，Tits 锥恰好由那些和基本区域 <span class="math inline">\(\overline{\mathcal{D}}\)</span>之间只隔着有限多个镜子的点组成，这样的点一定可以通过有限次单反射变换到<span class="math inline">\(\overline{\mathcal{D}}\)</span> 中，即下面的<code>while</code> 循环可以在有限次后结束：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> dot(x, alpha_s) &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> some s <span class="hljs-keyword">in</span> S:<br>    x = reflect(x, alpha_s)<br></code></pre></td></tr></tbody></table></figure><p>下面的动画展示了双曲 Coxeter 群 <span class="math inline">\(\Delta(3,3,7)\)</span> 的 Tits 锥中那些反射次数<span class="math inline">\(\leq10\)</span> 的点：</p><p><img src="/images/coxeter/337-anim.gif" class="fig" width="400"></p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>：设 <span class="math inline">\(x\in\mathcal{C}\)</span>，则 <span class="math inline">\(x\)</span> 可以表示为 <span class="math inline">\(x=wv\)</span>，其中 <span class="math inline">\(w\in W,v\in\overline{\mathcal{D}}\)</span>。设<span class="math inline">\(\lambda\in\mathrm{Neg}(x)\)</span>，则 <span class="math display">\[0&gt;\langle \lambda,\,x\rangle=\langle\lambda,\,wv\rangle=\langle w^{-1}\lambda,\,v\rangle.\]</span> 然而<span class="math inline">\(v\in\overline{\mathcal{D}}\)</span>，这说明<span class="math inline">\(w^{-1}\lambda\in\Phi^-\)</span>，从而 <span class="math inline">\(\mathrm{Neg}(x)\subseteq N(w^{-1})\)</span>，从而<span class="math display">\[|\mathrm{Neg}(x)|\leq|N(w^{-1})|=l(w)&lt;\infty.\]</span></p><p><span class="math inline">\(\Leftarrow\)</span>：反之若 <span class="math inline">\(|\mathrm{Neg}(x)|&lt;\infty\)</span>，我们来论证存在<span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(wx\in\overline{\mathcal{D}}\)</span>。这里的想法是，每次选择一个单根<span class="math inline">\(\alpha_s\)</span> 对应的镜面，使得 <span class="math inline">\(x\)</span> 落在这个镜子的背面，然后将 <span class="math inline">\(x\)</span> 关于 <span class="math inline">\(\alpha_s\)</span> 反射过去变到 <span class="math inline">\(\alpha_s\)</span> 的正面，这个操作会将遮挡在 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(\overline{\mathcal{D}}\)</span>之间的镜子个数严格减少 1。如此这般直到 <span class="math inline">\(x\)</span> 落入 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 为止。</p><p>具体论证如下：</p><p>若 <span class="math inline">\(\mathrm{Neg}(x)=\emptyset\)</span>，则<span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，结论显然成立。</p><p>若 <span class="math inline">\(\mathrm{Neg}(x)\ne\emptyset\)</span>，<span class="math inline">\(\mathrm{Neg}(x)\)</span> 中一定包含某个单根 <span class="math inline">\(\alpha_s\)</span>。考虑 <span class="math inline">\(x\)</span> 关于 <span class="math inline">\(\alpha_s\)</span> 的镜像 <span class="math inline">\(sx\)</span>，<span class="math inline">\(sx\)</span> 位于 <span class="math inline">\(\alpha_s\)</span> 的正面，所以 <span class="math inline">\(\alpha_s\notin\mathrm{Neg}(sx)\)</span>。于是对任何正根<span class="math inline">\(\lambda\in\mathrm{Neg}(sx)\)</span>，<a href="/coxeter-groups/root-system/#simple-ref"><span class="math inline">\(s\lambda\)</span> 仍然是正根且 <span class="math inline">\(s\lambda\ne\alpha_s\)</span></a>。对这样的 <span class="math inline">\(\lambda\)</span>，我们有 <span class="math display">\[0&gt;\langle \lambda,\,sx\rangle=\langles\lambda,\,x\rangle\Rightarrow s\lambda\in\mathrm{Neg}(x).\]</span>这说明 <span class="math display">\[s\cdot\mathrm{Neg}(sx)\subseteq\mathrm{Neg}(x)\setminus\{\alpha_s\}.\]</span>从而 <span class="math inline">\(\mathrm{Neg}(sx)\)</span>的元素个数严格小于 <span class="math inline">\(\mathrm{Neg}(x)\)</span>。</p><p>记 <span class="math inline">\(y=sx\)</span>，对 <span class="math inline">\(y\)</span> 重复此过程，我们可以逐步将 <span class="math inline">\(\mathrm{Neg}(y)\)</span> 减少为空集，即最终 <span class="math inline">\(y\)</span> 落在 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 中。于是存在 <span class="math inline">\(s_1,\ldots,s_k\)</span> 使得 <span class="math inline">\(y=(s_1\cdots s_k)\cdotx\in\overline{\mathcal{D}}\)</span>。取 <span class="math inline">\(w=s_1\cdots s_k\)</span>，则 <span class="math inline">\(x=w^{-1}y\in\mathcal{C}\)</span>。这就证明了结论。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-convex" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.7</span>.</span><span class="statement-spah"> </span>Tits 锥 <span class="math inline">\(\mathcal{C}\)</span> 是凸锥。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(x,y\in\mathcal{C}\)</span> 和 <span class="math inline">\(\alpha,\beta\geq0\)</span>，我们要证明 <span class="math inline">\(z=\alpha x+\beta y\in\mathcal{C}\)</span>。由于<span class="math display">\[\mathrm{Neg}(z)\subseteq\mathrm{Neg}(x)\cup\mathrm{Neg}(y),\]</span>根据 <a href="#tits-neg-finite" title="定理 1.6">定理 1.6</a>，<span class="math inline">\(\mathrm{Neg}(x),\,\mathrm{Neg}(y)\)</span>都是有限集，所以 <span class="math inline">\(\mathrm{Neg}(z)\)</span>也有限，从而 <span class="math inline">\(z\in\mathcal{C}\)</span>，即<span class="math inline">\(\mathcal{C}\)</span> 是凸锥。<span class="math inline">\(\blacksquare\)</span></p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.8</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathcal{C}=\mathrm{cone}(\Omega)\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(\Omega\supset\Delta^\ast\)</span>，以及根据 <a href="#fund-cone" title="命题 1.4">命题 1.4</a> 有 <span class="math inline">\(\mathrm{cone}(\Delta^\ast)=\overline{\mathcal{D}}\)</span>，所以<span class="math display">\[\mathrm{cone}(\Omega)\supset\mathrm{cone}(\Delta^\ast)=\overline{\mathcal{D}}.\]</span>又因为 <span class="math inline">\(\mathrm{cone}(\Omega)\)</span> 是<span class="math inline">\(W\)</span>- 不变的，所以它包含 <span class="math inline">\(\bigcup_{w\inW}w\overline{\mathcal{D}}=\mathcal{C}\)</span>。</p><p>另一方面 <span class="math inline">\(\mathcal{C}\supset\overline{\mathcal{D}}\supset\Delta^\ast\)</span>，并且<span class="math inline">\(\mathcal{C}\)</span> 也是 <span class="math inline">\(W\)</span>- 不变的，所以 <span class="math display">\[\mathcal{C}\supset\bigcup_{w\inW}w\Delta^\ast=\Omega.\]</span> 而 <a href="#tits-convex" title="推论 1.7">推论 1.7</a> 证明了 <span class="math inline">\(\mathcal{C}\)</span> 是凸锥，所以 <span class="math inline">\(\mathcal{C}\supset\mathrm{cone}(\Omega)\)</span>。<span class="math inline">\(\blacksquare\)</span></p><h1 id="tits-锥的内点">Tits 锥的内点</h1><p>接下来我们来讨论 <span class="math inline">\(\mathcal{C}\)</span>的内点集 <span class="math inline">\(\mathcal{C}^\circ\)</span>。我们将证明 <span class="math inline">\(\mathcal{C}^\circ\)</span>由那些稳定化子群是有限群的点组成： <span class="math display">\[\mathcal{C}^\circ = \{x\in V^\ast \mid|\mathrm{Stab}(x)| &lt; \infty\}.\]</span></p><div id="stabilizer-parabolic-subgroup" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span>对任何 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，记 <span class="math inline">\(J=\{s\in S \mid \langle\alpha_s,\,x\rangle=0\}\)</span>，则 <span class="math inline">\(\mathrm{Stab}(x) = W_J\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个定理的含义是，在原像房间 <span class="math inline">\(\overline{\mathcal{D}}\)</span>中，每个点的稳定化子群是一个标准椭圆子群，由包含该点的那些镜子生成。</p></div><p><strong>证明</strong>：</p><p>任取 <span class="math inline">\(s\in J\)</span> 和 <span class="math inline">\(v\in V\)</span>，我们有 <span class="math display">\[\langle v,\,sx\rangle = \langlesv,\,x\rangle=\langle v-2(v,\alpha_s)\alpha_s,\,x\rangle=\langlev,\,x\rangle.\]</span> 由 <span class="math inline">\(v\)</span>的任意性可得 <span class="math inline">\(sx=x\)</span>，从而 <span class="math inline">\(W_J\subseteq\mathrm{Stab}(x)\)</span>。</p><p>再证明反向包含关系。设 <span class="math inline">\(w=s_1\cdotss_k\in\mathrm{Stab}(x)\)</span> 是一个既约表示，我们从最末一个元素 <span class="math inline">\(s_k\)</span> 开始，向左逐个验证它们属于 <span class="math inline">\(J\)</span>。</p><p>记 <span class="math inline">\(w'=s_1\cdots s_{k-1}\)</span>，则<span class="math inline">\(l(ws_k)=l(w')&lt;l(w)\)</span>，于是<span class="math inline">\(w\alpha_k\in\Phi^-\)</span>。由于 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，我们有 <span class="math display">\[0\geq \langle w\alpha_k,\,x\rangle = \langle\alpha_k,\,w^{-1}x\rangle = \langle \alpha_k,\,x\rangle\geq0.\]</span>于是上面的不等式中等号都成立，从而 <span class="math inline">\(\langle\alpha_k,\,x\rangle=0\)</span>，即 <span class="math inline">\(s_k\inJ\)</span> 且 <span class="math inline">\(s_kx=x\)</span>。进一步 <span class="math inline">\(w'\)</span> 也满足 <span class="math inline">\(w'x=x\)</span>。对 <span class="math inline">\(w'\)</span> 重复此论证，便得到 <span class="math inline">\(s_1,\ldots,s_k\)</span> 都属于 <span class="math inline">\(J\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="fd-finite-stabilizer" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题2.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，则 <span class="math inline">\(x\in\mathcal{C}^\circ\)</span> 当且仅当 <span class="math inline">\(\mathrm{Stab}(x)\)</span> 是有限群。</p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>：思路：如果 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(\mathcal{C}\)</span> 的内点，并且经过 <span class="math inline">\(x\)</span> 的镜面有无穷多个，那么可以在 <span class="math inline">\(x\)</span> 的附近取一点 <span class="math inline">\(z\)</span>，<span class="math inline">\(z\)</span>仍然是 <span class="math inline">\(\mathcal{C}\)</span>的内点，使得这无穷多个镜子都挡在基本区域和 <span class="math inline">\(z\)</span> 之间，从而 <span class="math inline">\(\mathrm{Neg}(z)\)</span> 是无限集，从而 <span class="math inline">\(z\notin\mathcal{C}\)</span>，导致矛盾。</p><p>具体论证如下：</p><p>记 <span class="math inline">\(J\)</span> 和 <span class="math inline">\(W_J\)</span> 如 <a href="#stabilizer-parabolic-subgroup" title="定理 2.1">定理 2.1</a>，则<span class="math inline">\(\mathrm{Stab}(x)=W_J\)</span>。</p><figure><img src="/images/coxeter/WJ.svg" width="300" alt="一个示意图，z 落在所有 \Phi_J 中镜子的背面"><figcaption aria-hidden="true">一个示意图，<span class="math inline">\(z\)</span> 落在所有 <span class="math inline">\(\Phi_J\)</span> 中镜子的背面</figcaption></figure><p>任取 <span class="math inline">\(y\in\mathcal{D}\)</span>。由于 <span class="math inline">\(x\in\mathcal{C}^\circ\)</span>，所以在线段 <span class="math inline">\(\overline{[y, x]}\)</span> 上我们可以朝着 <span class="math inline">\(x\)</span> 的方向延伸一点点，得到点 <span class="math inline">\(z\)</span>，使得 <span class="math inline">\(z\)</span> 仍然位于 <span class="math inline">\(\mathcal{C}^\circ\)</span> 中。<span class="math inline">\(z\)</span> 可以表示为 <span class="math display">\[z=(1-t)x+ty,\quad t&lt;0.\]</span></p><p>于是对所有 <span class="math inline">\(s\in J\)</span> 都有 <span class="math inline">\(\langle \alpha_s,\,z\rangle=t\langle\alpha_s,\,y\rangle &lt; 0\)</span>，从而 <span class="math inline">\(\Phi_J^+\subset\mathrm{Neg}(z)\)</span>。如果<span class="math inline">\(W_J\)</span> 是无限群，那么 <span class="math inline">\(\Phi_J^+\)</span> 也无限，从而 <span class="math inline">\(\mathrm{Neg}(z)\)</span> 无限，这与 <span class="math inline">\(z\in\mathcal{C}\)</span> 矛盾！</p><p><span class="math inline">\(\Leftarrow\)</span>：反之若 <span class="math inline">\(W_J\)</span> 是有限群，仍然任取 <span class="math inline">\(y\in\mathcal{D}\)</span>。</p><figure><img src="/images/coxeter/WJ2.svg" width="300" alt="y 在 W_J 下的像全部位于镜面 \alpha_s=0 的正侧，故 \langle \alpha_s,\,wy\rangle 对 w\in W_J 总为正"><figcaption aria-hidden="true"><span class="math inline">\(y\)</span> 在<span class="math inline">\(W_J\)</span> 下的像全部位于镜面 <span class="math inline">\(\alpha_s=0\)</span> 的正侧，故 <span class="math inline">\(\langle \alpha_s,\,wy\rangle\)</span> 对 <span class="math inline">\(w\in W_J\)</span> 总为正</figcaption></figure><p>设 <span class="math inline">\(s\in S\setminus J\)</span>，则 <span class="math inline">\(\langle \alpha_s,\,x\rangle&gt;0\)</span>。对任何<span class="math inline">\(w\in W_J\)</span>，<a href="/coxeter-groups/root-system#remain-positive-root"><span class="math inline">\(w^{-1}\alpha_s\)</span> 仍然是正根</a>，所以 <span class="math display">\[\langle \alpha_s,\,wy\rangle=\langlew^{-1}\alpha_s,\,y\rangle&gt;0.\]</span> 于是 <span class="math display">\[\delta = \min\left\{\frac{\langle\alpha_s,\,x\rangle}{\langle \alpha_s,\,wy\rangle}\,\middle|\,\alpha_s\in S\setminus J,\, w\in W_J\right\}&gt;0.\]</span>将上面的分母乘到左边然后对 <span class="math inline">\(w\in W_J\)</span>求和，我们有 <span class="math display">\[\delta\cdot\langle\alpha_s,\,\sum_{w\in W_J}wy\rangle\leq \langle \alpha_s,\,x\rangle\cdot|W_J| &lt; 2\langle \alpha_s,\,x\rangle\cdot |W_J|,\quad s\in S\setminusJ.\tag{1}\label{eq:strict}\]</span> 注意这个不等式两边关于 <span class="math inline">\(\alpha_s\)</span> 都是线性的。</p><p>既然对 <span class="math inline">\(s\in S\setminus J\)</span>上面的不等式是严格的，那么对 <span class="math inline">\(s\in J\)</span>又如何呢？这时右边 <span class="math inline">\(\langle\alpha_s,\,x\rangle=0\)</span>。又因为 <span class="math inline">\(\sum_{w\in W_J}wy\)</span> 在 <span class="math inline">\(W_J\)</span> 下保持不动，所以根据 <a href="#stabilizer-parabolic-subgroup" title="定理 2.1">定理 2.1</a> 可得<span class="math inline">\(\langle \alpha_{s},\,\sum_{w\inW_J}wy\rangle=0\)</span>，从而上面的不等式变成了等式（两边都是 0）：<span class="math display">\[0=\delta\cdot\langle \alpha_s,\,\sum_{w\inW_J}wy\rangle= 2\langle \alpha_s,\,x\rangle\cdot |W_J|,\quad s\inJ.\tag{2}\label{eq:equal}\]</span> 对任何 <span class="math inline">\(\lambda\in\Phi^+\setminus\Phi_J^+\)</span>，设<span class="math display">\[\lambda=\sum_{s\in S\setminus J}c_s\alpha_s+ \sum_{t\in J}d_t\alpha_t,\quad c_s,\,d_t\geq0.\]</span> 其中至少有一项<span class="math inline">\(c_s\)</span> 严格大于 0。将 <span class="math inline">\(\lambda\)</span> 代入 <span class="math inline">\((\ref{eq:strict})\)</span> 中 <span class="math inline">\(\alpha_s\)</span> 的位置，严格不等式仍然成立。即<span class="math display">\[\delta\cdot\langle \lambda,\,\sum_{w\inW_J}wy\rangle&lt; 2\langle \lambda,\,x\rangle\cdot |W_J|.\]</span>注意对 <span class="math inline">\(w\in W_J\)</span>，<span class="math inline">\(w^{-1}\lambda\)</span> 作为 <span class="math inline">\(\lambda\)</span> 和 <span class="math inline">\(\{\alpha_s\mid s\in J\}\)</span>的线性组合仍然是正根，并且不在 <span class="math inline">\(\Phi_J^+\)</span> 中，所以上面的求和中每一项 <span class="math inline">\(\langle \lambda,\,wy\rangle=\langlew^{-1}\lambda,\,y\rangle&gt;0\)</span>，我们可以只取 <span class="math inline">\(w=1\)</span> 对应的项，其余全扔掉，得到 <span class="math display">\[\delta\cdot\langle \lambda,\,y\rangle&lt;2\langle \lambda,\,x\rangle\cdot |W_J|.\]</span> 记 <span class="math inline">\(z = 2|W_J|x - \delta y\)</span>，我们得到 <span class="math inline">\(\langle \lambda,\,z\rangle&gt;0\)</span> 对任何<span class="math inline">\(\lambda\in\Phi^+\setminus\Phi_J^+\)</span>成立。</p><p>另一方面对任何 <span class="math inline">\(\mu\in\Phi_J^+\)</span>，由于 <span class="math inline">\(\langle \mu,\,x\rangle=0\)</span>，所以 <span class="math inline">\(\langle \mu,\,z\rangle=-\delta\langle\mu,\,y\rangle&lt;0\)</span>，于是 <span class="math inline">\(\mathrm{Neg}(z)=\Phi_J^+\)</span> 是有限集，从而<span class="math inline">\(z\in\mathcal{C}\)</span>。</p><p>实际上我们有 <span class="math inline">\(z\in\mathcal{C}^\circ\)</span>，这是因为对任何<span class="math inline">\(\lambda\in\Phi\)</span>，<span class="math inline">\(\lambda\)</span> 必然属于 <span class="math inline">\(\pm\Phi^+_J,\pm(\Phi^+\setminus\Phi^+_J)\)</span>之一，而我们已经看到 <span class="math inline">\(\langle\lambda,\,z\rangle\)</span> 总不是 0，所以 <span class="math inline">\(z\)</span> 不落在任何镜面上。设 <span class="math inline">\(z=wv,\,v\in\overline{\mathcal{D}}\)</span>，那么<span class="math display">\[\langle \alpha_s,\,v\rangle=\langlew\alpha_s,\,wv\rangle=\langle w\alpha_s,\,z\rangle\ne0\]</span> 对任何<span class="math inline">\(\alpha_s\in\Delta\)</span> 成立，所以 <span class="math inline">\(v\in\mathcal{D}\subset\mathcal{C}^\circ\)</span>，从而<span class="math inline">\(z=wv\inw\mathcal{D}\subset\mathcal{C}^\circ\)</span>。</p><figure><img src="/images/coxeter/WJ3.svg" width="300" alt="我们证明 z 只落在 \Phi_J 中镜面的背面，从而 z\in\mathcal{C}；并证明 z 不属于任何镜面，从而 z\in\mathcal{C}^\circ"><figcaption aria-hidden="true">我们证明 <span class="math inline">\(z\)</span> 只落在 <span class="math inline">\(\Phi_J\)</span> 中镜面的背面，从而 <span class="math inline">\(z\in\mathcal{C}\)</span>；并证明 <span class="math inline">\(z\)</span> 不属于任何镜面，从而 <span class="math inline">\(z\in\mathcal{C}^\circ\)</span></figcaption></figure><p>现在 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(z\)</span> 和 <span class="math inline">\(y\)</span> 的线性组合 <span class="math inline">\(x = \frac{1}{2|W_J|}(z + \delta y)\)</span>。由于<span class="math inline">\(z,y\in\mathcal{C}^\circ\)</span> 而 <span class="math inline">\(\mathcal{C}\)</span> 是凸锥，所以 <span class="math inline">\(\frac{1}{2|W_J|}z,\frac{\delta}{2|W_J|}y\in\mathcal{C}^\circ\)</span>，即存在开集 <span class="math inline">\(A,B\)</span> 满足 <span class="math inline">\(\frac{1}{2|W_J|}z\inA\subset\mathcal{C}^\circ\)</span>，<span class="math inline">\(\frac{\delta}{2|W_J|}y\in B\subset\mathcal{C}^\circ\)</span>。于是 <span class="math inline">\(x\inA+B=\cup_{p\in B}(A+p)\)</span>，这是一组开集的并，每个 <span class="math inline">\(A+p\)</span> 都在 <span class="math inline">\(\mathcal{C}\)</span> 中，所以 <span class="math inline">\(x\in\mathcal{C}^\circ\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-int-finite-stabilizer" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(y\in\mathcal{C}\)</span>，则 <span class="math inline">\(y\in\mathcal{C}^\circ\)</span> 当且仅当 <span class="math inline">\(\mathrm{Stab}(y)\)</span> 是有限群。</p></div><p><strong>证明</strong>：<span class="math inline">\(y\)</span>可以写成 <span class="math inline">\(y=wx\,(w\inW,\,x\in\overline{\mathcal{D}})\)</span> 的形式，从而 <span class="math inline">\({\rm Stab}(y)=w{\rmStab}(x)w^{-1}\)</span>，二者同为有限群或者无限群；而且 <span class="math inline">\(x,y\)</span> 同时属于或者同时不属于 <span class="math inline">\(\mathcal{C}^\circ\)</span>。由 <a href="#fd-finite-stabilizer" title="命题 2.2">命题 2.2</a>即得结论。<span class="math inline">\(\blacksquare\)</span></p><h1 id="tits-锥的对偶锥">Tits 锥的对偶锥</h1><p>这一节来讨论 Tits 锥的对偶锥。研究对偶锥对理解 Tits锥本身的结构也很有帮助。</p><div id="dual-cone" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(C\)</span> 是 <span class="math inline">\(V\)</span> 中的一个锥，定义 <span class="math inline">\(C\)</span> 的对偶锥 <span class="math inline">\(C^\ast\in V^\ast\)</span> 为 <span class="math display">\[C^\ast = \{f\in V^\ast\mid f(v)\geq0,\ \forallv\in C\}.\]</span> 即 <span class="math inline">\(C^\ast\)</span>是对偶空间中那些在 <span class="math inline">\(C\)</span>上取值均非负的线性泛函组成的集合。</p></div><p>不难看出 <span class="math inline">\(C^\ast\)</span> 也构成 <span class="math inline">\(V^\ast\)</span>中的一个锥，所以我们又可以取其对偶锥 <span class="math inline">\(C^{\ast\ast}\subset V\)</span>。</p><div id="dual-dual-cone" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(C^{\ast\ast} = \overline{C}\)</span>。其中 <span class="math inline">\(\overline{C}\)</span> 是 <span class="math inline">\(C\)</span> 的拓扑闭包。</p></div><p><strong>证明</strong>：显然 <span class="math inline">\(\overline{C}\subseteqC^{\ast\ast}\)</span>，只要论证 <span class="math inline">\(C^{\ast\ast}\subseteq \overline{C}\)</span> 即可。</p><p>对任何 <span class="math inline">\(x\notin\overline{C}\)</span>，根据凸集分离定理，存在超平面<span class="math inline">\(H\)</span>，其法向量 <span class="math inline">\(n\)</span> 满足 <span class="math inline">\((n,C)\geq 0\)</span> 但是 <span class="math inline">\((n,x) &lt; 0\)</span>。于是线性泛函 <span class="math inline">\((n,\cdot)\in C^\ast\)</span> 且由于 <span class="math inline">\((n,x)&lt;0\)</span> 从而 <span class="math inline">\(x\notin C^{\ast\ast}\)</span>。反向包含得证。<span class="math inline">\(\blacksquare\)</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>对不熟悉凸集分离定理的读者，下面是一点细节补充：设 <span class="math inline">\(u\in\overline{C}\)</span> 是 <span class="math inline">\(\overline{C}\)</span> 中与 <span class="math inline">\(x\)</span> 距离最近的点：<span class="math inline">\(|x-u|=\inf_{z\in\overline{C}}|x-z|\)</span>。对任何 <span class="math inline">\(z\in\overline{C}\)</span>，考虑线段 <span class="math inline">\([u,z]\)</span> 上的点与 <span class="math inline">\(x\)</span> 的距离 <span class="math display">\[f(t) = |u + t(z-u) - x|,\quad 0\leqt\leq1.\]</span> <span class="math inline">\(f\)</span> 在 <span class="math inline">\(t=0\)</span> 时取得最小值： <span class="math display">\[ |u-x|^2 \leq |u-x|^2 + 2t(u-x, z-u) +t^2|z-u|^2.\]</span> 即 <span class="math display">\[0\leqt\cdot\left(2(u-x,z-u) + t|z-u|^2\right)\leq 2(u-x,z-u) +t|z-u|^2.\]</span> 令 <span class="math inline">\(t\to0^+\)</span> 可得<span class="math inline">\((u-x,z-u)\geq 0\)</span>。 这个式子对任何<span class="math inline">\(z\in\overline{C}\)</span> 成立，特别地取<span class="math inline">\(z=tu\)</span> 代入有 <span class="math display">\[(1-t)\cdot(u-x, u)\geq0.\]</span> 上式对任何<span class="math inline">\(t\geq0\)</span> 成立必须只能是 <span class="math inline">\((u-x, u)=0\)</span>。于是不等式 <span class="math display">\[(u-x,z-u)\geq 0\]</span> 可以改写为 <span class="math display">\[(u-x,z)\geq0\]</span> 对任何 <span class="math inline">\(z\in\overline{C}\)</span> 成立。而 <span class="math inline">\((u-x,x)=-(u-x,u-x)&lt;0\)</span>。所以 <span class="math inline">\(u-x\)</span> 即为所求的法向量 <span class="math inline">\(n\)</span>。</p></div><p>回到 Tits 锥 <span class="math inline">\(\mathcal{C}\)</span>的讨论上来。记 <span class="math inline">\(\mathcal{C}^\ast\)</span> 是<span class="math inline">\(\mathcal{C}\)</span> 的对偶锥，则 <span class="math inline">\(\mathcal{C}^\ast\inV\)</span>。我们有如下定理：</p><div id="tits-cone-dual" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathcal{C}^\ast=\bigcap\limits_{w\inW}w(\mathrm{cone}(\Delta))\)</span>。</p></div><p>可见 <span class="math inline">\(\mathcal{C}^\ast\)</span> 也是 <span class="math inline">\(W\)</span>- 不变的。</p><p><strong>证明</strong>：显然 <span class="math inline">\(\mathrm{cone}(\Delta)\)</span> 是 <span class="math inline">\(V\)</span> 中的一个闭凸锥，它在 <span class="math inline">\(V^\ast\)</span> 中的对偶锥是 <span class="math inline">\(\overline{\mathcal{D}}\)</span>： <span class="math display">\[\overline{\mathcal{D}}= \{x\in V^\ast\mid \langle\lambda,\,x\rangle\geq0,\ \forall\lambda\in\mathrm{cone}(\Delta)\}.\]</span> 我们有 <span class="math display">\[\begin{align}\mathcal{C}^\ast &amp;=\{v\in V \mid \langle v,\,x\rangle\geq 0 \text{for all } x \in \mathcal{C}\}\\&amp;= \{v\in V \mid \langle v,\,wz\rangle\geq0 \text{ for all }z\in\overline{\mathcal{D}}\text{ and } w \in W\}\\&amp;= \{v\in V \mid \langle w^{-1}v,\,z\rangle\geq0 \text{ for all}z\in\overline{\mathcal{D}}\text{ and } w \in W\}\\&amp;= \{v\in V \mid w^{-1}v\in (\overline{\mathcal{D}})^\ast \text{ forall } w \in W\}\\&amp;\stackrel{(\ast)}{=} \{v\in V \mid w^{-1}v\in \mathrm{cone}(\Delta)\text{ for all } w \in W\}\\&amp;= \{v\in V \mid v\in w(\mathrm{cone}(\Delta)) \text{ for all } w\in W\}.\end{align}\]</span></p><p>其中 <span class="math inline">\((\ast)\)</span> 一步正是将 <a href="#dual-dual-cone" title="定理 3.2">定理 3.2</a> 应用在 <span class="math inline">\(C=\mathrm{cone}(\Delta),\,C^\ast=\overline{\mathcal{D}}\)</span>上得到的。注意我们使用了 <span class="math inline">\(\mathrm{cone}(\Delta)\)</span> 是闭集这一点：<span class="math inline">\(\mathrm{cone}(\Delta)=\overline{\mathrm{cone}(\Delta)}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-cone-dual-pointed" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论3.4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathcal{C}^\ast\)</span> 是点锥：<span class="math inline">\(\mathcal{C}^\ast\cap-\mathcal{C}^\ast=\{0\}\)</span>。</p></div><p><strong>证明</strong>：根据 <a href="#tits-cone-dual" title="定理 3.3">定理 3.3</a> 有 <span class="math inline">\(\mathcal{C}^\ast\subset\mathrm{cone}(\Delta)\)</span>，但显然<span class="math inline">\(\mathrm{cone}(\Delta)\cap-\mathrm{cone}(\Delta)=\{0\}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>虽然我们得到了上面关于 <span class="math inline">\(\mathcal{C}^\ast\)</span>的刻画，但是它并不好用。我们下面用内积的形式给出 <span class="math inline">\(\mathcal{C}^\ast\)</span> 的一个更好的刻画。</p><div id="dual-cone-dot-neg" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.5</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(v\in\mathrm{cone}(\Delta)\)</span> 满足对任何<span class="math inline">\(\alpha_s\in\Delta\)</span> 有 <span class="math inline">\((v,\alpha_s)\leq0\)</span>，则 <span class="math inline">\(v\in\mathcal{C}^\ast\)</span>。</p></div><p><strong>证明</strong>：根据 <a href="#tits-cone-dual" title="定理 3.3">定理 3.3</a>，只要证明对任何 <span class="math inline">\(w\)</span> 都有 <span class="math inline">\(wv\in\mathrm{cone}(\Delta)\)</span> 即可。</p><p>对 <span class="math inline">\(l(w)\)</span> 归纳：<span class="math inline">\(l(w)=0\)</span> 的情形是已知。当 <span class="math inline">\(l(w)&gt;0\)</span> 时，设 <span class="math inline">\(w=w's\)</span>，其中 <span class="math inline">\(l(w')&lt;l(w)\)</span>，则 <span class="math inline">\(w'\alpha_s\in\Phi^+\subset\mathrm{cone}(\Delta)\)</span>。于是</p><p><span class="math display">\[\begin{align}wv &amp;= w'sv\\&amp;=w'(v - 2(v,\alpha_s)\alpha_s)\\&amp;=w'v - 2(v,\alpha_s)w'\alpha_s.\end{align}\]</span></p><p>根据归纳假设 <span class="math inline">\(w'v\in\mathrm{cone}(\Delta)\)</span>，所以<span class="math inline">\(wv\)</span> 是 <span class="math inline">\(\mathrm{cone}(\Delta)\)</span>中两个向量的非负线性组合，从而 <span class="math inline">\(wv\in\mathrm{cone}(\Delta)\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="dual-cone-nonspace" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.6</span>.</span><span class="statement-spah"> </span>对任何 <span class="math inline">\(u,v\in\mathcal{C}^\ast\)</span> 有 <span class="math inline">\((u,v)\leq 0\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>我是在与 <a href="https://www.maths.usyd.edu.au/u/bobh/">BobHowlett</a> 教授的邮件交流中学到这个结论的。这个证明我相信改进自 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>)</span>。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(v = \sum_{s\inS}c_s\alpha_s\in V\)</span>，定义 <span class="math inline">\(S(v)=\sum_{s\in S}c_s\)</span>为所有系数的和。注意当 <span class="math inline">\(v\in\mathcal{C}^\ast\subset\mathrm{cone}(\Delta)\)</span>时，每个 <span class="math inline">\(c_s\)</span> 都是非负的，所以 <span class="math inline">\(S(v)\geq0\)</span>。</p><p>用反证法，设 <span class="math inline">\(u,v\in\mathcal{C}^\ast\)</span> 满足 <span class="math inline">\((u,v)&gt;0\)</span>，不妨设 <span class="math inline">\((u,v)=1\)</span>。记 <span class="math inline">\(n=|S|\)</span> 和 <span class="math inline">\(M=S(u)\)</span>。定义</p><p><span class="math display">\[X=\{x\in\mathcal{C}^\ast\mid S(x)\leqS(v) \text{ and $(z,x)\geq1$ for some $z\in\mathcal{C}^\ast$ with$S(z)\leq M$}\}.\]</span></p><p>显然 <span class="math inline">\(v\in X\)</span>。</p><p>记 <span class="math inline">\(\epsilon=2/(nM)\)</span>，我们将证明对任何 <span class="math inline">\(x\in X\)</span>，都存在 <span class="math inline">\(y\in X\)</span> 使得 <span class="math inline">\(S(y)\leq S(x)-\epsilon\)</span>。</p><p>对 <span class="math inline">\(x\in X\)</span>，设 <span class="math inline">\(z=\sum_{s\inS}z_s\alpha_s\in\mathcal{C}^\ast\)</span> 满足 <span class="math inline">\(S(z)\leq M\)</span> 和 <span class="math inline">\((z,x)\geq1\)</span>，则 <span class="math display">\[(z,x)=\sum_{s\in S}z_s(\alpha_s,x)\geq1.\]</span> 所以必有某个 <span class="math inline">\(\alpha_s\)</span> 使得 <span class="math inline">\(z_s(\alpha_s,x)\geq 1/n\)</span>。由于 <span class="math inline">\(z_s\leq S(z)\leq M\)</span>，我们有 <span class="math display">\[(\alpha_s,x)\geq 1/(nz_s)\geq1/(nM)=\epsilon/2.\]</span></p><p>考察 <span class="math display">\[y=sx=x-2(x,\alpha_s)\alpha_s.\]</span> 由于 <span class="math inline">\(x\in\mathcal{C}^\ast\)</span> 以及 <span class="math inline">\(\mathcal{C}^\ast\)</span> 是 <span class="math inline">\(W-\)</span> 不变的所以 <span class="math inline">\(y\in\mathcal{C}^\ast\)</span>。又注意到 <span class="math display">\[S(y)=S(x)-2(x,\alpha_s)\leqS(x)-\epsilon.\]</span> 所以要证明 <span class="math inline">\(y\)</span> 符合要求，只要再找到某个 <span class="math inline">\(z'\in\mathcal{C}^\ast\)</span> 满足 <span class="math inline">\(S(z')\leq M\)</span> 和 <span class="math inline">\((z',y)\geq1\)</span> 即可。</p><p>如果 <span class="math inline">\((z,\alpha_s)&lt;0\)</span>，那么<span class="math inline">\(z'=z\)</span> 就满足要求，因为这时 <span class="math display">\[(z,y)=(z,x-2(x,\alpha_s)\alpha_s)=(z,x)-2\underbrace{(x,\alpha_s)}_{\geq\epsilon/2}\underbrace{(z,\alpha_s)}_{&lt;0}&gt;(z,x)\geq1.\]</span></p><p>反之如果 <span class="math inline">\((z,\alpha_s)&gt;0\)</span>，我们来验证 <span class="math inline">\(z'=sz=z-2(z,\alpha_s)\alpha_s\)</span>满足要求：由于 <span class="math inline">\(z\in\mathcal{C}^\ast\)</span>所以 <span class="math inline">\(z'\in\mathcal{C}^\ast\)</span>，并且 <span class="math inline">\(S(z')=S(z)-2(z,\alpha_s)&lt;S(z)\)</span>，以及<span class="math display">\[(z', y)=(sz,sx)=(z,x)\geq1.\]</span></p><p>于是从 <span class="math inline">\(v\)</span>出发，我们可以经过有限次取 <span class="math inline">\(y\in X\)</span>的操作使得 <span class="math inline">\(S(y)\)</span> 是负数，但这与<span class="math inline">\(y\in X\subset\mathcal{C}^\ast\)</span>矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Howlett-note" class="csl-entry" role="listitem">Howlett, Robert B. 1996. <span>“Introduction to Coxeter Groups.”</span><a href="https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html">https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html</a>.</div><div id="ref-Maxwell82" class="csl-entry" role="listitem">Maxwell, George. 1982. <span>“Sphere Packings and Hyperbolic ReflectionGroups.”</span> <em>Journal of Algebra</em> 79 (1): 78–97. <a href="https://doi.org/10.1016/0021-8693(82)90318-0">https://doi.org/10.1016/0021-8693(82)90318-0</a>.</div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（二）：根系</title>
      <link href="/coxeter-groups/root-system.html"/>
      <url>/coxeter-groups/root-system.html</url>
      
        <content type="html"><![CDATA[<p>我们先简要回顾 <a href="/coxeter-groups/geometric-realization/">第一篇笔记</a>的核心内容。</p><p>设 <span class="math inline">\((W,S)\)</span> 是一个 Coxeter系。我们在该文中将其实现为一个实向量空间 <span class="math inline">\(V\)</span> 上的正交反射群，方式如下：</p><ol type="1"><li>取 <span class="math inline">\(n=|S|\)</span> 维实向量空间 <span class="math inline">\(V\)</span>，并设其一组基为 <span class="math inline">\(\{\alpha_s\mid s\in S\}\)</span>；</li><li>定义 <span class="math inline">\(V\)</span> 上的内积 <span class="math inline">\((\cdot,\cdot)\)</span>；</li><li>对每个生成元 <span class="math inline">\(s\in S\)</span> 在 <span class="math inline">\(V\)</span> 上的作用是以 <span class="math inline">\(\alpha_s\)</span> 为法向量的反射 <span class="math inline">\(\rho_s\)</span>；</li><li>最后，我们证明了 <span class="math inline">\(\rho\,\colon\W\to\mathrm{O}(V)\)</span> 是群同态。</li></ol><p>但是我们还有一个未完成的工作：证明 <span class="math inline">\(\rho\)</span>是同构。本文会完成它。此外我还会介绍一些关于根系的知识。如果你直接翻到本文后面，会看到我罗列了很多关于根系的推论。这并不是我在故意掉书袋，这些推论每一条后面都会用到。不过读者初次阅读时只要大致浏览它们即可，等后面用到时再跳转过来查看细节。</p><span id="more"></span><h1 id="根系">根系</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>我们称集合 <span class="math display">\[\Phi=W\cdot\Delta=\{w\alpha_s\mid w\in W, \,\alpha_s\in\Delta\}\]</span> 为 <span class="math inline">\((W,S)\)</span> 的<strong>根系</strong>，任何 <span class="math inline">\(\lambda\in\Phi\)</span>叫做根向量，简称为<strong>根</strong>。<span class="math inline">\(\Delta\)</span> 叫做<strong>单根系</strong>，<span class="math inline">\(\Delta\)</span>中的元素叫做<strong>单根</strong>。</p></div><p>我们可以立刻观察到以下几点：</p><ul><li>每个根 <span class="math inline">\(\lambda=w\alpha_s\)</span>都是内积 <span class="math inline">\((\cdot,\cdot)\)</span>下的单位向量，因为群 <span class="math inline">\(W\)</span>的作用保持内积；</li><li>若 <span class="math inline">\(\alpha, \beta \in \Phi\)</span>共线，则 <span class="math inline">\(\alpha = \pm\beta\)</span>。这是因为它们都是单位向量，<span class="math inline">\(\alpha = k\beta\Rightarrow k^2 = 1\)</span>。</li></ul><p>由于 <span class="math inline">\(\Delta\)</span> 构成 <span class="math inline">\(V\)</span> 的一组基，所以每个根 <span class="math inline">\(\Phi\in\lambda\)</span> 都是单根的线性组合： <span class="math display">\[\lambda = \sum_{s\in S}c_s\alpha_s,\quadc_s\in\mathbb{R}.\]</span> 如果上面的所有系数 <span class="math inline">\(c_s\)</span> 都非负，就称 <span class="math inline">\(\lambda\)</span>是<strong>正根</strong>；若所有系数 <span class="math inline">\(c_s\)</span> 都非正，就称 <span class="math inline">\(\lambda\)</span>是<strong>负根</strong>。正根和负根组成的集合分别记作 <span class="math inline">\(\Phi^+\)</span> 和 <span class="math inline">\(\Phi^-\)</span>。显然 <span class="math inline">\(\Phi^+\cap\Phi^-=\emptyset\)</span>。</p><p>这就引出了一个问题：每个根都必然是正根或者负根吗？即是否有 <span class="math inline">\(\Phi=\Phi^+\cup\Phi^-\)</span>成立？虽然答案是肯定的，但这并不显然。为此我们需要一个关键引理。这个引理的证明有点长，但是它非常重要，Coxeter群的几乎所有性质的证明多少都会用到它。在引入它之前，我们需要做一点小小的准备。</p><p>设 <span class="math inline">\(I\subseteq S\)</span>，<span class="math inline">\(I\)</span> 中的生成元在 <span class="math inline">\((W,S)\)</span> 中生成一个子群 <span class="math inline">\(W_I \leqslant (W,S)\)</span>，<span class="math inline">\(W_I\)</span> 叫做<strong>标准椭圆子群</strong>。记<span class="math inline">\(l_I(\cdot)\)</span> 是 <span class="math inline">\(W_I\)</span> 上的长度函数，则显然对任何 <span class="math inline">\(w\in W_I\)</span> 有 <span class="math inline">\(l(w)\leq l_I(w)\)</span> 成立（因为 <span class="math inline">\(W_I\)</span> 中的既约表示放到 <span class="math inline">\(W\)</span>中可能不是既约的）。我们后面会证明其实有 <span class="math inline">\(l_I=l\mid_{W_I}\)</span>。</p><p>现在请出我们的重要引理：</p><div id="key-lemma" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(s\in S,\, w\in W\)</span>，则</p><ol type="1"><li><span class="math inline">\(l(ws) &gt; l(w)\)</span> 当且仅当 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>。</li><li><span class="math inline">\(l(ws) &lt; l(w)\)</span> 当且仅当 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>。</li></ol></div><p><strong>证明</strong>：这里 1 和 2 是等价的：如果 1 成立，则</p><p><span class="math display">\[\begin{align*}l(ws)&lt;l(w)&amp;\Leftrightarrow l((ws)s) &gt; l(ws)\\&amp;\Leftrightarrow ws(\alpha_s)\in\Phi^+\\&amp;\Leftrightarrow w(-\alpha_s)\in\Phi^+\\&amp;\Leftrightarrow w\alpha_s\in\Phi^-.\end{align*}\]</span></p><p>所以只需要证明 1 即可。</p><p>我们先证明充分性：若 <span class="math inline">\(l(ws)&gt;l(w)\)</span> 则 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>。</p><p>对 <span class="math inline">\(l(w)\)</span> 归纳：<span class="math inline">\(l(w)=0\)</span> 时 <span class="math inline">\(w=1\)</span>，结论显然成立。下面设结论对所有长度小于<span class="math inline">\(l(w)\)</span> 的元素成立。</p><p>我们总是可以取 <span class="math inline">\(t\in S\)</span> 使得 <span class="math inline">\(l(wt)&lt;l(w)\)</span>，比如 <span class="math inline">\(t\)</span> 取为 <span class="math inline">\(w\)</span> 的某个既约表达式的最后一项。由于 <span class="math inline">\(l(ws)&gt;l(w)\)</span>，故 <span class="math inline">\(t\ne s\)</span>。令 <span class="math inline">\(I=\{s,t\}\)</span>，定义集合 <span class="math display">\[A = \{(x,x_I)\in W\times W_I\midw=xx_I,\,l(w)=l(x)+l_I(x_I)\}.\]</span> 由于 <span class="math inline">\((wt,t)\in A\)</span> 所以 <span class="math inline">\(A\)</span> 非空。取 <span class="math inline">\((v,v_I)\in A\)</span> 使得 <span class="math inline">\(l(v)\)</span> 是最小的，则 <span class="math display">\[l(v)\leq l(wt)=l(w)-1.\]</span> 我们断言对任何<span class="math inline">\(u\in I\)</span> 都有 <span class="math inline">\(l(vu)&gt;l(v)\)</span>。若不然，则 <span class="math inline">\(l(vu)=l(v)-1\)</span>，于是 <span class="math display">\[\begin{align*}l(w)&amp;=l(vu\cdot uv_I)\leq l(vu) + l(uv_I) = (l(v) -1) + l(uv_I)\\&amp;\leq (l(v) -1) + l_I(uv_I)\\&amp;\leq (l(v) -1) + (l_I(v_I) + 1)\\&amp; = l(v) + l_I(v_I)=l(w).\end{align*}\]</span> 于是所有的不等号都是等式，从而 <span class="math inline">\((vu,uv_I)\in A\)</span>，但这与 <span class="math inline">\((v,v_I)\)</span> 的选择矛盾。所以不论 <span class="math inline">\(u=s\)</span> 或是 <span class="math inline">\(u=t\)</span> 都有 <span class="math inline">\(l(vu)&gt;l(v)\)</span>。</p><p>由于 <span class="math inline">\(l(v)\leq l(w)-1\)</span>所以根据归纳假设 <span class="math inline">\(v\alpha_s,\,v\alpha_t\)</span>都是正根。如果我们能够证明 <span class="math inline">\(v_I\alpha_s\)</span> 是 <span class="math inline">\(\alpha_s\)</span> 和 <span class="math inline">\(\alpha_t\)</span> 的非负线性组合：<span class="math display">\[v_I\alpha_s = a\alpha_s + b\alpha_t,\quada,\,b\geq0.\]</span> 则 <span class="math display">\[w\alpha_s=vv_I\alpha_s=v(a\alpha_s +b\alpha_t)=av\alpha_s + bv\alpha_t\in\Phi^+.\]</span>这就证明了结论。</p><p>注意到 <span class="math inline">\(v_I\in W_I\)</span>的任何既约表示都是 <span class="math inline">\(s,t\)</span>的交错乘积，而且不能以 <span class="math inline">\(s\)</span> 结尾，否则<span class="math inline">\(l_I(v_Is)=l_I(v_I)-1\)</span>，从而 <span class="math display">\[l(ws)=l(vv_Is)\leq l(v) + l(v_Is)\leql(v)+l_I(v_Is)=l(v)+l_I(v_I)-1=l(w)-1.\]</span> 这与 <span class="math inline">\(l(ws) &gt; l(w)\)</span> 矛盾！</p><p>于是 <span class="math inline">\(v_I\)</span> 形如 <span class="math inline">\(v_I=st\cdots t\)</span> 或者 <span class="math inline">\(v_I=ts\cdots t\)</span>，问题归结为分析这样的<span class="math inline">\(v_I\)</span> 在 <span class="math inline">\(\alpha_s\)</span> 上的作用。我们在 <a href="/coxeter-groups/geometric-realization#rank2-roots">前文</a>中已经有过计算：</p><ol type="1"><li><span class="math inline">\(m=m_{s,t}&lt;\infty\)</span> 时，<span class="math inline">\(W_I\)</span> 是有限二面体群 <span class="math inline">\(D_m\)</span>。<span class="math inline">\(W_I\)</span> 中所有长度 <span class="math inline">\(\leq m-1\)</span> 且以 <span class="math inline">\(t\)</span> 结尾的元素罗列如下（包含恒等元）：<span class="math display">\[1,\ t,\ st,\ \ldots,\ \overbrace{\ast\cdotsst}^{m-1}.\]</span> 它们作用在 <span class="math inline">\(\alpha_s\)</span> 上给出如下链条的前 <span class="math inline">\(m\)</span> 项： <span class="math display">\[\alpha_s\xrightarrow{\ t\ }\dfrac{\sin\theta}{\sin\theta}\alpha_s+\dfrac{\sin2\theta}{\sin\theta}\alpha_t\xrightarrow{\ s\ }\dfrac{\sin3\theta}{\sin\theta}\alpha_s+\dfrac{\sin2\theta}{\sin\theta}\alpha_t\xrightarrow{\ t\ }\cdots\]</span> 其中<span class="math inline">\(\theta=\pi/m\)</span>。这 <span class="math inline">\(m\)</span> 项都是 <span class="math inline">\(\alpha_s,\alpha_t\)</span> 的非负线性组合。</li></ol><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>以 <span class="math inline">\(m=5\)</span> 为例，所有 <span class="math inline">\(m\)</span> 个正根都位于 <span class="math inline">\(\alpha_s,\alpha_t\)</span> 张成的楔形区域内：</p><figure><img src="/images/coxeter/finite2d.svg" width="400" alt="m=5 的例子"><figcaption aria-hidden="true"><span class="math inline">\(m=5\)</span>的例子</figcaption></figure><p>从 <span class="math inline">\(\alpha_s\)</span>一侧开始，这些正根形如 <span class="math display">\[\dfrac{\sink\theta}{\sin\theta}\alpha_s+\dfrac{\sin(k-1)\theta}{\sin\theta}\alpha_t,\quad k=1,2,\ldots,m.\]</span> 从 <span class="math inline">\(\alpha_t\)</span> 一侧开始，它们形如 <span class="math display">\[\dfrac{\sin(k-1)\theta}{\sin\theta}\alpha_s+\dfrac{\sink\theta}{\sin\theta}\alpha_t,\quad k=1,2,\ldots,m.\]</span> 当 <span class="math inline">\(k\)</span> 跑遍 <span class="math inline">\(1,\ldots,m\)</span> 时，第一个序列从 <span class="math inline">\(\alpha_s\)</span> 开始过渡到 <span class="math inline">\(\alpha_t\)</span>，第二个序列从 <span class="math inline">\(\alpha_t\)</span> 开始过渡到 <span class="math inline">\(\alpha_s\)</span>。它们最接近的位置是在 <span class="math inline">\(k=\lfloor(m+1)/2\rfloor\)</span> 处（<span class="math inline">\(m\)</span> 为奇数时重合）。这两个序列的前 <span class="math inline">\(\lfloor(m+1)/2\rfloor\)</span>项合起来正好给出全部 <span class="math inline">\(m\)</span> 个正根。这<span class="math inline">\(m\)</span> 个正根可以通过将 <span class="math inline">\(1,t,st,\ldots,\overbrace{\ast\cdotsst}^{m-1}\)</span> 这 <span class="math inline">\(m\)</span>个元素作用在 <span class="math inline">\(\alpha_s\)</span> 上得到。</p></div><ol start="2" type="1"><li><span class="math inline">\(m=m_{s,t}=\infty\)</span> 时，记 <span class="math inline">\(\cosh\theta=a_{s,t}\,(\theta\geq0)\)</span>，则<span class="math display">\[\alpha_s\xrightarrow{\ t\ }\dfrac{\sinh\theta}{\sinh\theta}\alpha_s+\dfrac{\sinh2\theta}{\sinh\theta}\alpha_t\xrightarrow{\ s\ }\dfrac{\sinh3\theta}{\sinh\theta}\alpha_s+\dfrac{\sinh2\theta}{\sinh\theta}\alpha_t\xrightarrow{\ t\ }\cdots\]</span>每一项都是 <span class="math inline">\(\alpha_s,\alpha_t\)</span>的非负线性组合。</li></ol><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>当 <span class="math inline">\(\theta=0\)</span> 时，<span class="math inline">\(W_I\)</span>是一维直线上两个平行镜面生成的（仿射）反射群（包含了平移），它可以处理成二维平面上的线性反射群：</p><p><img src="/images/coxeter/affine2d.svg" class="fig" width="500"></p><p>当 <span class="math inline">\(\theta&gt;0\)</span> 时，<span class="math inline">\(W_I\)</span>是双曲空间中两个超平行的镜面生成的双曲反射群，它也可以处理成二维平面上的线性反射群：</p><p><img src="/images/coxeter/hyperbolic2d.svg" class="fig" width="400"></p></div><p>必要性的证明：</p><p>我们要证明若 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>则 <span class="math inline">\(l(ws)&gt;l(w)\)</span>。若不然，则 <span class="math inline">\(l(w)=l(wss)&gt;l(ws)\)</span>，从而由充分性的证明知道<span class="math inline">\(ws\alpha_s\in\Phi^+\)</span>，即 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>，矛盾！至此关键引理得证。<span class="math inline">\(\blacksquare\)</span></p><p>从 <a href="#key-lemma" title="引理 1.2">引理 1.2</a>出发我们可以得到许多重要推论：</p><div id="faithful" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(w\in W\)</span> 满足对任何 <span class="math inline">\(v\in V\)</span> 都有 <span class="math inline">\(wv=v\)</span>，则 <span class="math inline">\(w\)</span> 必然是恒等元。换言之，表示 <span class="math inline">\(\rho: W\to{\rm O}(V)\)</span> 是忠实的。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(w\ne1\)</span>，则存在 <span class="math inline">\(s\in S\)</span> 使得<span class="math inline">\(l(ws)&lt;l(w)\)</span>，从而 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>，这与 <span class="math inline">\(w\alpha_s=\alpha_s\)</span> 矛盾。<span class="math inline">\(\blacksquare\)</span></p><div id="pos-neg" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.4</span>.</span><span class="statement-spah"></span>每个根不是正根就是负根，即 <span class="math inline">\(\Phi=\Phi^+\cup\Phi^-\)</span>。</p></div><p><strong>证明</strong>：任取 <span class="math inline">\(\lambda \in\Phi\)</span>，则存在 <span class="math inline">\(w \in W\)</span> 与<span class="math inline">\(s \in S\)</span> 使得 <span class="math inline">\(\lambda = w\alpha_s\)</span>。若 <span class="math inline">\(l(ws) &gt; l(w)\)</span>，则 <span class="math inline">\(\lambda \in \Phi^+\)</span>，否则 <span class="math inline">\(\lambda \in \Phi^-\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="simple-ref" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.5</span>.</span><span class="statement-spah"> </span>任何单反射 <span class="math inline">\(s\)</span> 置换 <span class="math inline">\(\Phi^+\setminus\{\alpha_s\}\)</span>中的正根，同时将 <span class="math inline">\(\alpha_s\)</span> 变为<span class="math inline">\(-\alpha_s\)</span>。</p></div><p><strong>证明</strong>：对任一正根 <span class="math inline">\(\lambda\ne\alpha_s\in\Phi^+\)</span>，<span class="math inline">\(\lambda\)</span> 不可能与 <span class="math inline">\(\alpha_s\)</span> 共线，所以其作为单根的线性组合<span class="math inline">\(\lambda=\sum_{t\in S}c_t\alpha_t\)</span>中必有某个 <span class="math inline">\(t\ne s\)</span> 使得 <span class="math inline">\(c_t&gt;0\)</span>，于是 <span class="math inline">\(s\lambda=\lambda-2(\lambda,\alpha_s)\alpha_s\)</span>的 <span class="math inline">\(\alpha_t\)</span>分量保持不动仍然为正，于是根据 <a href="#pos-neg" title="推论 1.4">推论1.4</a> <span class="math inline">\(s\lambda\)</span> 仍然是正根。<span class="math inline">\(\blacksquare\)</span></p><div id="lw-nw" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.6</span>.</span><span class="statement-spah"> </span>对 <span class="math inline">\(w\in W\)</span>，定义 <span class="math inline">\(N(w)\)</span> 为被 <span class="math inline">\(w\)</span> 变成负根的那些正根组成的集合： <span class="math display">\[N(w)=\{\lambda\in\Phi^+\midw\lambda\in\Phi^-\}.\]</span> 则 <span class="math inline">\(|N(w)|=l(w)\)</span>。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(l(w)\)</span>归纳。<span class="math inline">\(l(w)=0\)</span> 时 <span class="math inline">\(w=1\)</span>，结论成立。若 <span class="math inline">\(l(w)&gt;0\)</span>，取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(w=w's\)</span> 且 <span class="math inline">\(l(w')&lt;l(w)\)</span>。由 <a href="#key-lemma" title="引理 1.2">引理 1.2</a>，<span class="math inline">\(\alpha_s\in N(w)\)</span> 但是 <span class="math inline">\(\alpha_s\notin N(w')\)</span>。</p><p>对任何正根 <span class="math inline">\(\lambda\ne\alpha_s\)</span>，<span class="math inline">\(s\lambda\)</span> 仍然是正根。由恒等式 <span class="math display">\[w'\lambda\in\Phi^- \Leftrightarroww(s\lambda)\in\Phi^-\]</span> 可得 <span class="math inline">\(\lambda\leftrightarrow s\lambda\)</span> 给出了<span class="math inline">\(N(w')\)</span> 和 <span class="math inline">\(N(w)\setminus\{\alpha_s\}\)</span>之间的一一对应，即 <span class="math display">\[N(w)=s\cdotN(w')\cup\{\alpha_s\}.\]</span> 从而由归纳假设 <span class="math display">\[|N(w)|=|N(w')|+1=l(w')+1=l(w).\]</span><span class="math inline">\(\blacksquare\)</span></p><div id="nw-zero-means-identity" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.7</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(w(\Phi^+)\subseteq\Phi^+\)</span>，则 <span class="math inline">\(w=1\)</span>。</p></div><p><strong>证明</strong>：根据 <a href="#lw-nw" title="推论 1.6">推论1.6</a> 有 <span class="math inline">\(l(w)=|N(w)|=0\)</span>，从而<span class="math inline">\(w=1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="w-phi-both-finite-infinite" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.8</span>.</span><span class="statement-spah"> </span><span class="math inline">\(|W|&lt;\infty\)</span> 当且仅当 <span class="math inline">\(|\Phi|&lt;\infty\)</span>。</p></div><p><strong>证明</strong>：如果 <span class="math inline">\(W\)</span>是有限群，由于 <span class="math inline">\(\Phi=W\cdot\Delta\)</span>，<span class="math inline">\(|\Phi|\leq |W|\cdot|\Delta|\)</span> 也是有限的。</p><p>反之若 <span class="math inline">\(|\Phi|&lt;\infty\)</span>，由于<span class="math inline">\(W\)</span> 保持 <span class="math inline">\(\Phi\)</span> 不变，所以 <span class="math inline">\(W\)</span> 置换地作用在 <span class="math inline">\(\Phi\)</span> 上，即有 <span class="math inline">\(W\)</span> 到置换群 <span class="math inline">\(S_{|\Phi|}\)</span> 的同态 <span class="math inline">\(W\xrightarrow{\varphi} S_{|\Phi|}\)</span>。<a href="#nw-zero-means-identity" title="推论 1.7">推论 1.7</a> 说明 <span class="math inline">\(\varphi\)</span> 是嵌入，从而 <span class="math inline">\(W\)</span> 也是有限的。<span class="math inline">\(\blacksquare\)</span></p><div id="longest" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.9</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(W\)</span> 是一个有限群，则存在唯一的元素 <span class="math inline">\(w_0\)</span>，<span class="math inline">\(w_0\)</span> 是 <span class="math inline">\(W\)</span> 中长度最大者，它交换 <span class="math inline">\(\Phi^+\)</span> 和 <span class="math inline">\(\Phi^-\)</span>：<span class="math inline">\(w_0(\Phi^+)=\Phi^-\)</span>，且 <span class="math inline">\(w_0\)</span> 是一个对合：<span class="math inline">\(w_0^2=1\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(W\)</span>有限所以存在一个长度最大的元素 <span class="math inline">\(w_0\)</span>，对任何 <span class="math inline">\(s\in S\)</span> 只能有 <span class="math inline">\(l(w_0s)&lt;l(w)\)</span>，从而 <span class="math inline">\(w_0\alpha_s\in\Phi^-\)</span>，从而 <span class="math inline">\(w_0\)</span> 把 <span class="math inline">\(\Phi^+\)</span> 变为 <span class="math inline">\(\Phi^-\)</span>。</p><p>进一步 <span class="math inline">\(w_0^2\)</span> 仍然把 <span class="math inline">\(\Phi^+\)</span> 映射为 <span class="math inline">\(\Phi^+\)</span>，所以由 <a href="#nw-zero-means-identity" title="推论 1.7">推论 1.7</a> <span class="math inline">\(w_0^2=1\)</span>，因此 <span class="math inline">\(w_0\)</span> 是一个对合。</p><p>如果存在 <span class="math inline">\(w_1\ne w_0\)</span> 使得 <span class="math inline">\(l(w_1)=l(w_0)\)</span> 的话，则 <span class="math inline">\(w_1\)</span> 也满足 <span class="math inline">\(w_1(\Phi^+)=\Phi^-\)</span>，从而 <span class="math inline">\(w_0^{-1}w_1\)</span> 保持 <span class="math inline">\(\Phi^+\)</span> 不变，根据 <a href="#nw-zero-means-identity" title="推论 1.7">推论 1.7</a> 有 <span class="math inline">\(w_0^{-1}w_1=1\)</span>，即 <span class="math inline">\(w_0=w_1\)</span>。所以这样的 <span class="math inline">\(w_0\)</span> 是唯一的。<span class="math inline">\(\blacksquare\)</span></p><div id="remain-positive-root" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.10</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(I\subsetneqq S\)</span> 是真子集，<span class="math inline">\(\lambda\in \Phi^+\setminus\Phi^+_I\)</span>是正根，则对任何 <span class="math inline">\(w\in W_I\)</span>，<span class="math inline">\(w\lambda\)</span> 仍然是正根。</p></div><p><strong>证明</strong>：<span class="math inline">\(w\lambda\)</span>是 <span class="math inline">\(\lambda\)</span> 和 <span class="math inline">\(\{\alpha_t\mid t\in I\}\)</span>中向量的线性组合： <span class="math display">\[w\lambda=\lambda +\sum_{t\in I}c_t\alpha_t.\]</span> <span class="math inline">\(\lambda\in\Phi^+\setminus\Phi^+_I\)</span> 说明将<span class="math inline">\(\lambda\)</span>表示为单根的线性组合时，其至少有一项 <span class="math inline">\(\alpha_s\,(s\notin I)\)</span> 的系数大于 0，从而<span class="math inline">\(w\lambda\)</span> 的 <span class="math inline">\(\alpha_s\)</span> 项的系数也大于 0，所以 <span class="math inline">\(w\lambda\)</span> 必然是正根。<span class="math inline">\(\blacksquare\)</span></p><div id="lI-equals-l" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.11</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(w\in W_I\)</span>，则其任何既约表示 <span class="math inline">\(w=s_1\cdots s_k\)</span> 中，每个 <span class="math inline">\(s_i\in I\)</span>，特别地 <span class="math inline">\(l_I(w)=l(w)\)</span>。</p></div><p><strong>证明</strong>：从右到左依次验证 <span class="math inline">\(s_k,\ldots,s_1\in I\)</span>。记 <span class="math inline">\(s=s_k\)</span>。由于 <span class="math inline">\(w\in W_I\)</span> 所以 <span class="math inline">\(w\alpha_s\)</span> 是 <span class="math inline">\(\alpha_s\)</span> 和一些 <span class="math inline">\(\{\alpha_t\mid t\in I\}\)</span> 的线性组合：<span class="math display">\[w\alpha_s=\alpha_s+\sum_{t\in I}c_t\alpha_t.\]</span> 由于 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span> 所以必然有某个 <span class="math inline">\(t\in I\)</span> 使得 <span class="math inline">\(s=t\)</span>，即 <span class="math inline">\(s\inI\)</span>。对 <span class="math inline">\(ws=s_1\cdots s_{k-1}\inW_I\)</span> 重复此论证即得每个 <span class="math inline">\(s_i\inI\)</span>。<span class="math inline">\(\blacksquare\)</span></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（四）：有限、仿射、双曲三种情形的 Tits 锥</title>
      <link href="/coxeter-groups/three-geometries.html"/>
      <url>/coxeter-groups/three-geometries.html</url>
      
        <content type="html"><![CDATA[<p>本文主要参考了 <span class="citation" data-cites="Howlett1997">(<a href="#ref-Howlett1997" role="doc-biblioref">Howlett, Rowley, and Taylor1997</a>)</span>。</p><p>书接 <a href="coxeter-groups-tits-cone">上回</a>，我们来研究内积<span class="math inline">\((\cdot,\cdot)\)</span>分别是有限、仿射和双曲三种情形时，Tits 锥 <span class="math inline">\(\mathcal{C}\)</span> 和对偶锥 <span class="math inline">\(\mathcal{C}^\ast\)</span> 的结构。</p><span id="more"></span><h1 id="有限">有限</h1><p>一个熟知的结论是，内积 <span class="math inline">\((\cdot,\cdot)\)</span> 是正定的当且仅当 <span class="math inline">\((W,S)\)</span> 是有限群 <span class="citation" data-cites="Humphreys90">(见 <a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.6.4</a>)</span>。我这里略过对此结论的证明（否则篇幅会拉的太长）。我们来证明这还等价于：</p><div id="finite-tits-V" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 是有限群当且仅当 Tits 锥 <span class="math inline">\(\mathcal{C}=V^\ast\)</span>。</p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>: 由 <span class="math inline">\(\mathcal{C}=V^\ast\)</span> 可得 <span class="math inline">\(-\mathcal{D}\in\mathcal{C}\)</span>。对任何 <span class="math inline">\(x\in-\mathcal{D}\)</span>，我们都有 <span class="math inline">\(\Phi^+\subseteq \mathrm{Neg}(x)\)</span>，根据 <a href="/coxeter-groups/tits-cone/#tits-neg-finite">Tits锥的刻画</a>，<span class="math inline">\(|\Phi^+|=|\mathrm{Neg}(x)|&lt;\infty\)</span>，<a href="/coxeter-groups/root-system/#w-phi-both-finite-infinite">从而<span class="math inline">\(W\)</span> 是有限群</a>。</p><p><span class="math inline">\(\Leftarrow\)</span>: <span class="math inline">\(W\)</span> 是有限群说明 <span class="math inline">\(\Phi\)</span> 也是有限的，从而对任何 <span class="math inline">\(x\in V^\ast\)</span> 都有 <span class="math inline">\(|\mathrm{Neg}(x)|\leq|\Phi^+|&lt;\infty\)</span>，从而 <span class="math inline">\(x\in\mathcal{C}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>在下图中，<span class="math inline">\(W\)</span> 是正二十面体群<span class="math inline">\(H_3\)</span>，红色的锥是基本区域，它在 <span class="math inline">\(W\)</span> 的作用下铺满了整个空间，所以 <span class="math inline">\(\mathcal{C}=\mathbb{R}^3\)</span>。<span class="math inline">\(\mathcal{C}\)</span>与球面的交给出球面上的密铺。如果用直线而不是球面上的弧连接顶点的话，得到的是正二十面体。</p><p><img src="/images/coxeter/Tits_finite.png" class="fig" width="350"></p></div><h1 id="无限群的-tits-锥">无限群的 Tits 锥</h1><p>在仿射和双曲的情形，Coxeter 群都是无限群。我们来介绍一点关于无限Coxeter 群 Tits 锥的一般结论。</p><div id="phi-J-finite" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题2.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(W\)</span> 是不可约 Coxeter 群。如果存在 <span class="math inline">\(J\subsetneqq S\)</span> 使得 <span class="math inline">\(\Phi\setminus\Phi_J\)</span> 是有限集，则 <span class="math inline">\(W\)</span> 必然是有限群。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(J\subsetneqqS\)</span>，所以可以设 <span class="math inline">\(S\setminusJ=\{s_1,\ldots,s_r\}\,(r\geq1)\)</span>。由于 <span class="math inline">\(W\)</span> 不可约，<span class="math inline">\(W\)</span> 的 Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是连通的，<span class="math inline">\(J\)</span> 中的任何顶点都可以通过某条路径与 <span class="math inline">\(S\setminus J\)</span> 中的顶点相连。记 <span class="math inline">\(d(s)\)</span> 是顶点 <span class="math inline">\(s\)</span> 与 <span class="math inline">\(S\setminus J\)</span> 之间的最短距离，将 <span class="math inline">\(S\)</span> 按如下方式重新排序为 <span class="math inline">\(S=\{s_1,\ldots,s_n\}\)</span>： <span class="math display">\[S =\underbrace{\overbrace{\{s_1,\ldots,s_r\}}^{d(s)=0}}_{S\setminusJ}\cup\underbrace{\overbrace{\{s_{r+1},\ldots,s_{r+k}\}}^{d(s)=1},\overbrace{\{s_{r+k+1},\ldots\}}^{d(s)=2},\cdots}_{J}\,.\]</span></p><p>即 <span class="math inline">\(S\setminus J\)</span>中的顶点排在最前面，接下来是 <span class="math inline">\(J\)</span>中的顶点，按照距离从小到大排序。</p><p>记 <span class="math inline">\(\Phi_i^+\)</span> 是所有可以由 <span class="math inline">\(\{\alpha_i,\ldots,\alpha_n\}\)</span> 张成，且<span class="math inline">\(\alpha_i\)</span> 项系数不为 0的正根组成的集合： <span class="math display">\[\Phi_i^+=\{\lambda\in\Phi^+\mid\lambda=\sum_{j=i}^nc_j\alpha_j,\c_i\ne 0\}.\]</span> 不难看出有 <span class="math inline">\(\Phi^+=\Phi_1^+\sqcup\cdots\sqcup\Phi^+_n\)</span>，以及<span class="math inline">\(\Phi^+\setminus\Phi_J^+=\Phi_1^+\cup\cdots\cup\Phi^+_r\)</span>。由已知<span class="math inline">\(\Phi\setminus\Phi_J\)</span> 是有限的，所以<span class="math inline">\(\Phi_1^+,\ldots,\Phi^+_r\)</span>都是有限的。</p><p>我们用归纳法依次论证 <span class="math inline">\(\Phi^+_{r+1},\ldots,\Phi^+_{n}\)</span>也都是有限集：设 <span class="math inline">\(r+1\leq i\leq n\)</span>且已知对所有 <span class="math inline">\(j&lt;i\)</span>，<span class="math inline">\(\Phi_1^+,\ldots,\Phi^+_j\)</span> 都是有限集，现在考察 <span class="math inline">\(\Phi^+_i\)</span>，注意必然有 <span class="math inline">\(d(s_i)\geq1\)</span>，所以存在 <span class="math inline">\(j&lt;i\)</span> 使得 <span class="math inline">\(d(s_j)&lt;d(s_i)\)</span> 且 <span class="math inline">\(s_j\sim s_i\)</span>。</p><p>我们发现：</p><ol type="1"><li><span class="math inline">\(s_j\Phi_i^+\)</span>的元素都是正根。这是因为用 <span class="math inline">\(s_j\)</span>作用不改变 <span class="math inline">\(\Phi^+_i\)</span> 中元素的 <span class="math inline">\(\alpha_i\)</span> 项系数；</li><li><span class="math inline">\(s_j\Phi_i^+\subset\Phi^+_j\)</span>。这是因为若<span class="math inline">\(\lambda=\sum_{k\geqi}c_k\alpha_k\in\Phi^+_i\)</span>，则 <span class="math display">\[s_j\lambda=\lambda-2\left(\sum_{k\geqi}c_k(\alpha_k,\alpha_j)\right)\alpha_j.\]</span> 上面每一项 <span class="math inline">\(c_k(\alpha_k,\alpha_j)\)</span> 都非正，且由于顶点<span class="math inline">\(s_i,s_j\)</span> 相邻所以 <span class="math inline">\(c_i(\alpha_i,\alpha_j)&lt;0\)</span>。所以 <span class="math inline">\(s_j\lambda\)</span> 的 <span class="math inline">\(\alpha_j\)</span> 项系数严格大于 0。</li></ol><p>于是 <span class="math inline">\(|\Phi_i^+|\leq |\Phi^+_j|\)</span>也是有限集。从而所有 <span class="math inline">\(\Phi^+_1,\ldots,\Phi^+_n\)</span> 都是有限集，从而<span class="math inline">\(\Phi\)</span> 也是有限的。所以 <span class="math inline">\(W\)</span> 是有限群，命题得证。<span class="math inline">\(\blacksquare\)</span></p><p><a href="#phi-J-finite" title="命题 2.1">命题 2.1</a>有如下的推论：</p><div id="tits-cone-pointed" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(W\)</span> 不可约且无限，则 <span class="math inline">\(\mathcal{C}\cap-\mathcal{C}=\{0\}\)</span>，即<span class="math inline">\(\mathcal{C}\)</span> 是点锥 (pointedcone)。</p></div><p><strong>证明</strong>：根据 <span class="math display">\[\mathcal{C}\cap-\mathcal{C}=\bigcup_{w_1,w_2\inW}w_1\overline{\mathcal{D}}\cap w_2(-\overline{\mathcal{D}}).\]</span>若 <span class="math inline">\(\mathcal{C}\cap-\mathcal{C}\ne\{0\}\)</span>则存在 <span class="math inline">\(x\ne0\in\overline{\mathcal{D}}\)</span> 和 <span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(-wx\in\overline{\mathcal{D}}\)</span>。令 <span class="math display">\[J=\{s\in S\mid \langle\alpha_s,\,x\rangle=0\}.\]</span> 由于 <span class="math inline">\(x\ne0\)</span>，所以 <span class="math inline">\(J\subsetneqq S\)</span>是真子集。</p><p>对任何 <span class="math inline">\(\lambda\in\Phi^+\setminus\Phi^+_J\)</span>，显然<span class="math inline">\(\langle\lambda,\,x\rangle&gt;0\)</span>，并且对这样的 <span class="math inline">\(\lambda\)</span> 有 <span class="math display">\[\langle w\lambda,\,-wx\rangle = \langle\lambda,\,-x\rangle&lt;0.\]</span> 而 <span class="math inline">\(-wx\in\overline{\mathcal{D}}\)</span>，所以 <span class="math inline">\(w\lambda\)</span> 是负根，即 <span class="math inline">\(\Phi^+\setminus\Phi^+_J\subset\mathrm{Neg}(w)\)</span>。于是<span class="math display">\[|\Phi^+\setminus\Phi^+_J|\leq|\mathrm{Neg}(w)|=l(w)&lt;\infty.\]</span> 由 <a href="#phi-J-finite" title="命题 2.1">命题 2.1</a>，<span class="math inline">\(W\)</span>是有限群，这与已知矛盾。<span class="math inline">\(\blacksquare\)</span></p><div id="dual-cone-non-trivial" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(W\)</span> 不可约且无限，则对偶锥 <span class="math inline">\(\mathcal{C}^\ast\ne\{0\}\)</span>。</p></div><p><strong>证明</strong>：用反证法，若不然，则 <span class="math inline">\(\overline{\mathcal{C}}=\mathcal{C}^{\ast\ast}=V^\ast\)</span>是全空间。由于一个凸集的内点和它的闭包的内点集相同（证明见这个 <a href="/papers/sCONVs.pdf">附件</a>），所以 <span class="math inline">\(\mathcal{C}=V\)</span>，这与 <a href="#tits-cone-pointed" title="推论 2.2">推论 2.2</a> 的结论 <span class="math inline">\(\mathcal{C}\)</span> 是点锥矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 id="仿射">仿射</h1><p>在本节中，我们需要用到不可约仿射 Coxeter 群的一些基本事实 <span class="citation" data-cites="Humphreys90">(见 <a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, secs. 2.6, 6.5</a>)</span>。</p><div id="affine-facts" class="statement simple plain unnumbered"><p>设 <span class="math inline">\(W\)</span> 是不可约、仿射 Coxeter群，则：</p><ol type="1"><li><span class="math inline">\(\mathrm{rad}(V)\)</span> 的维数是1，它由一个向量 <span class="math inline">\(\delta=\sum_{s\inS}z_s\alpha_s\)</span> 生成，其中每个 <span class="math inline">\(z_s&gt;0\)</span>。</li><li><span class="math inline">\(\delta\)</span> 的坐标 <span class="math inline">\(z=(z_1,\ldots,z_s)^T\)</span> 满足 <span class="math inline">\(Az=z^TAz=0\)</span>，其中 <span class="math inline">\(A=((\alpha_s, \alpha_t))_{s,t\in S}\)</span>是内积 <span class="math inline">\((\cdot,\cdot)\)</span> 的 Gram矩阵。</li><li>对所有 <span class="math inline">\(w\in W\)</span> 有 <span class="math inline">\(w\delta=\delta\)</span>。</li><li><span class="math inline">\(A\)</span> 的任何 <span class="math inline">\(\leq n-1\)</span> 阶主子式都是正定的。</li></ol></div><p>我们花点笔墨解释下这几个性质的含义。回忆 <span class="math inline">\(W\)</span> 称作仿射是指内积 <span class="math inline">\((\cdot,\cdot)\)</span>是半正定但不是正定的。这个定义中似乎没有要求 <span class="math inline">\((\cdot,\cdot)\)</span> 的惯性指数中有几个0，但是上面的 1, 2 告诉我们，在 <span class="math inline">\(W\)</span>不可约的前提下，<span class="math inline">\((\cdot,\cdot)\)</span>的符号中有且只有一个 0，并且 <span class="math inline">\(\mathrm{rad}(V)\)</span> 可以由一个向量 <span class="math inline">\(\delta\)</span> 生成，并且 <span class="math inline">\(\delta\)</span> 的所有系数都大于 0。</p><p>4 说的是对任何 <span class="math inline">\(I\subsetneqqS\)</span>，标准椭圆子群 <span class="math inline">\(W_I\)</span>都是有限群；或者等价地，从 <span class="math inline">\(W\)</span> 的Coxeter 图 <span class="math inline">\(\Gamma\)</span>中删去至少一个顶点以后，剩下的子图是有限的。</p><div id="tits-cone-affine" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.1</span>.</span><span class="statement-spah"></span>在仿射的情形，<span class="math inline">\(\mathcal{C}^\ast\)</span> 是一条射线：<span class="math inline">\(\mathcal{C}^\ast=\mathbb{R}_{\geq0}\delta\)</span>。<span class="math inline">\(\mathcal{C}\)</span> 是以 <span class="math inline">\(\delta\)</span> 为法向量的半空间加上原点：<span class="math inline">\(\mathcal{C}=\{0\}\cup\{\delta &gt;0\}\)</span>。</p></div><p><strong>证明</strong>：根据 <a href="#dual-cone-non-trivial" title="推论 2.3">推论 2.3</a> 可知 <span class="math inline">\(\mathcal{C}^\ast\ne\{0\}\)</span>。结合 <a href="/coxeter-groups/tits-cone/#dual-cone-nonspace"><span class="math inline">\(\mathcal{C}^\ast\)</span> 中的向量范数 <span class="math inline">\(\leq0\)</span></a> 以及 <span class="math inline">\((\cdot,\cdot)\)</span> 半正定可得 <span class="math inline">\(\mathcal{C}^\ast\subseteq\mathbb{R}\delta\)</span>。又因为<a href="/coxeter-groups/tits-cone/#tits-cone-dual-pointed"><span class="math inline">\(\mathcal{C}^\ast\)</span> 是点锥</a>，所以 <span class="math inline">\(\mathcal{C}^\ast\)</span> 等于 <span class="math inline">\(\mathbb{R}_{\geq0}\delta\)</span> 或者 <span class="math inline">\(\mathbb{R}_{\leq0}\delta\)</span> 之一。由于 <a href="/coxeter-groups/tits-cone/#tits-cone-dual"><span class="math inline">\(\mathcal{C}^\ast\subset\mathrm{cone}(\Delta)\)</span></a>，以及<span class="math inline">\(\delta\)</span> 是 <span class="math inline">\(\Delta\)</span> 的正线性组合，所以只能是 <span class="math inline">\(\mathcal{C}^\ast=\mathbb{R}_{\geq0}\delta\)</span>。</p><p>再来分析 <span class="math inline">\(\mathcal{C}\)</span>。取对偶得到<span class="math inline">\(\overline{\mathcal{C}}=\mathcal{C}^{\ast\ast}=\{\delta\geq0\}\)</span>。由于一个凸集的内点和它的闭包的内点集相同，所以<span class="math inline">\(\mathcal{C}^\circ=\{\delta&gt;0\}\)</span>，于是<span class="math display">\[\{\delta&gt;0\}\subset\mathcal{C}\subset\overline{\mathcal{C} }=\{\delta\geq0\}.\]</span></p><p>对任何 <span class="math inline">\(x\in\{\delta=0\}\)</span>，若<span class="math inline">\(x\in\mathcal{C}\)</span>，则存在 <span class="math inline">\(w\in W\)</span> 和 <span class="math inline">\(y\in\overline{\mathcal{D}}\)</span> 使得 <span class="math inline">\(x=wy\)</span>。于是 <span class="math display">\[0= \langle \delta,\,x\rangle=\langle \delta,\,wy\rangle=\langlew^{-1}\delta,\,y\rangle=\langle \delta,\,y\rangle=\sum_{s\inS}z_s\langle \alpha_s,\,y\rangle.\]</span> 然而每个 <span class="math inline">\(z_s&gt;0\)</span>，并且由于 <span class="math inline">\(y\in\overline{\mathcal{D}}\)</span> 所以每个 <span class="math inline">\(\langle\alpha_s,\,y\rangle\geq0\)</span>，这只能是 <span class="math inline">\(\langle \alpha_s,\,y\rangle=0\)</span> 对所有<span class="math inline">\(\alpha_s\in\Delta\)</span> 成立，这导致<span class="math inline">\(y=0\)</span>，从而 <span class="math inline">\(x=0\)</span>，所以超平面 <span class="math inline">\(\{\delta=0\}\)</span> 中属于 <span class="math inline">\(\mathcal{C}\)</span> 的只有 0。这就证明了 <span class="math inline">\(\mathcal{C}=\{0\}\cup\{\delta&gt;0\}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>在下图中，<span class="math inline">\(W\)</span> 是仿射 <span class="math inline">\(\widetilde{A}_2\)</span>，红色的锥是基本区域，它在<span class="math inline">\(W\)</span> 的作用下铺满了整个上半空间，所以<span class="math inline">\(\mathcal{C}=\{z&gt;0\}\cup\{0\}\)</span>。<span class="math inline">\(\mathcal{C}\)</span> 与平面 <span class="math inline">\(z=1\)</span> 的交给出二维的 Euclidean 密铺。</p><p><img src="/images/coxeter/Tits_affine.png" class="fig" width="350"></p></div><h1 id="双曲">双曲</h1><p>双曲的情形 Tits 锥的结构较为复杂，通常难以完整刻画。</p><p>我们先介绍一些关于 Lorentzian 内积的基础知识，详见 <span class="citation" data-cites="ratcliffe">(<a href="#ref-ratcliffe" role="doc-biblioref">Ratcliffe 2006, vol. 149, chap. 3</a>)</span>。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义4.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(V\)</span> 是一个 Lorentzian 空间。我们称 <span class="math inline">\(v\in V\)</span> 是</p><ol type="1"><li>space-like 的，如果 <span class="math inline">\((v,v)&gt;0\)</span>；</li><li>light-like 的，如果 <span class="math inline">\((v,v)=0\)</span>；</li><li>time-like 的，如果 <span class="math inline">\((v,v)&lt;0\)</span>。</li></ol></div><p>这个定义也可以推广到 <span class="math inline">\(V\)</span>的子空间中：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义4.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(U\subset V\)</span> 是一个子空间，我们称 <span class="math inline">\(U\)</span> 是</p><ol type="1"><li>space-like 的，如果 <span class="math inline">\((\cdot,\cdot)\mid_U\)</span> 是正定的；</li><li>light-like 的，如果 <span class="math inline">\((\cdot,\cdot)\mid_U\)</span>是半正定的，但不是正定的；</li><li>time-like 的，如果 <span class="math inline">\(U\)</span> 包含time-like 的向量。</li></ol></div><p>由于 Lorentzian 内积是非退化的，所以对任何子空间 <span class="math inline">\(U\)</span> 都有 <span class="math inline">\(\dim U+ \dim U^\bot=n\)</span> 成立。</p><p>下面的命题是关于二次型知识的简单练习，我省略它们的证明。</p><div id="orth-complement-lorentzian" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.3</span>.</span></p><ol type="1"><li><span class="math inline">\(U\)</span> 是 space-like 的当且仅当<span class="math inline">\(U^\bot\)</span> 是 time-like 的；</li><li><span class="math inline">\(U\)</span> 是 light-like 的当且仅当<span class="math inline">\(U^\bot\)</span> 是 light-like 的。</li></ol></div><div id="lorentzinian-decomposition"></div><p>取 <span class="math inline">\(z\)</span> 是任一满足 <span class="math inline">\((z,z)=-1\)</span> 的 time-like的向量，则正交补空间 <span class="math inline">\(z^\perp\)</span> 是space-like 的，并且 <span class="math inline">\(V=\mathbb{R}z\oplusz^\perp\)</span>。任何 <span class="math inline">\(v\in V\)</span>可以写成 <span class="math inline">\(v = x + cz\,(x\inz^\perp,c\in\mathbb{R})\)</span> 的形式。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义4.4</span>.</span><span class="statement-spah"> </span>定义 <span class="math inline">\(\mathcal{Q}=\{v\in V\mid (v,v)\leq 0\}\)</span>是所有非 space-like 的向量组成的集合。</p></div><p><span class="math inline">\(\mathcal{Q}\)</span> 包含上、下两个分支<span class="math inline">\(\mathcal{Q}_+,\,\mathcal{Q}_-\)</span>，它们分别由<span class="math inline">\(\mathcal{Q}\)</span> 中满足 <span class="math inline">\(c\geq0\)</span> 和 <span class="math inline">\(c\leq0\)</span> 的点组成。<span class="math inline">\(\mathcal{Q}_+=-\mathcal{Q}_-\)</span> 并且 <span class="math inline">\(\mathcal{Q}_+\cap\mathcal{Q}_-=\{0\}\)</span>。</p><p><img src="/images/coxeter/hyperboloid.svg" class="fig" width="350"></p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义4.5</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(u,v\in\mathcal{Q}\)</span> 是两个非零向量，用记号<span class="math inline">\(u\sim v\)</span> 表示 <span class="math inline">\(u,v\)</span> 属于同一个分支，即同时属于 <span class="math inline">\(\mathcal{Q}_+\)</span> 或者 <span class="math inline">\(\mathcal{Q}_-\)</span>；用 <span class="math inline">\(u\not\sim v\)</span> 表示它们属于不同的分支。</p></div><div id="connected-component-dot" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.6</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(u,v\in \mathcal{Q}-\{0\}\)</span>。</p><ol type="1"><li>如果 <span class="math inline">\(u\sim v\)</span> 则 <span class="math inline">\((u,v)\leq0\)</span>。</li><li><span class="math inline">\((u,v)=0\)</span> 当且仅当 <span class="math inline">\(u,v\)</span> 是共线的 light-like 的向量。</li><li>如果 <span class="math inline">\(u,v\)</span> 中至少有一个是time-like 的向量，则 <span class="math inline">\(u\sim v\)</span>当且仅当 <span class="math inline">\((u,v)&lt;0\)</span>。</li><li>若 <span class="math inline">\(u\in\mathcal{Q}_+,\,v\in\mathcal{Q}_-\)</span>线性无关，则存在 <span class="math inline">\(a,b&gt;0\)</span> 使得<span class="math inline">\(au + bv\)</span> 是 space-like 的。</li></ol></div><p><strong>证明</strong>：</p><p>设 <span class="math inline">\(u=x+cz,\, v=y+dz\)</span>，其中 <span class="math inline">\(x,y\in z^\perp\)</span>。则 <span class="math inline">\((x,x)\leq c^2\)</span>，<span class="math inline">\((y,y)\leq d^2\)</span>。</p><ol type="1"><li>若 <span class="math inline">\(u\sim v\)</span>，则 <span class="math inline">\(c,d\)</span> 同正或者同负。由于 <span class="math inline">\(z^\bot\)</span> 是正定子空间，由 Cauchy-Schwartz不等式有 <span class="math display">\[(u,v)=(x,y)-cd\leq\sqrt{(x,x)\cdot (y,y)}-cd \leq\sqrt{c^2d^2}-cd=|cd|-cd=0.\]</span></li><li>若 <span class="math inline">\((u,v)=0\)</span> 且 <span class="math inline">\(u,v\)</span> 不共线，令 <span class="math inline">\(U=\mathrm{span}\{u,v\}\)</span>，则对 <span class="math inline">\(U\)</span> 中的任何向量 <span class="math inline">\(w=au+bv\,(a,b\in\mathbb{R})\)</span> 有 <span class="math display">\[(w,w)=a^2(u,u) + b^2(v,v)\leq0.\]</span> 即 <span class="math inline">\(U\)</span> 不包含 space-like 的向量。这与 <span class="math inline">\(\dim U=2\)</span> 和 Lorentzian 空间的 Sylvester符号是 <span class="math inline">\((n-1,1)\)</span> 矛盾，所以 <span class="math inline">\(u,v\)</span> 必须共线且都是 light-like的。反方向是显然的。</li><li><span class="math inline">\(\Rightarrow\)</span>：结合 1, 2两点即得。<span class="math inline">\(\Leftarrow\)</span>：如果 <span class="math inline">\(u\not\sim v\)</span> 则 <span class="math inline">\(u\sim -v\)</span>，由 1 有 <span class="math inline">\((u,-v)\leq0\)</span>，从而 <span class="math inline">\((u,v)\geq0\)</span>，矛盾。</li><li>由已知 <span class="math inline">\(c&gt;0,\,d&lt;0\)</span>。取<span class="math inline">\((-d)u + cv\in z^\perp\)</span> 即可。<span class="math inline">\(\blacksquare\)</span></li></ol><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义4.7</span>.</span><span class="statement-spah"> </span>记 <span class="math inline">\(\mathcal{N}_+\)</span> 和 <span class="math inline">\(\mathcal{N}_-\)</span> 为 <span class="math inline">\(\mathcal{N}=\{v\in V\mid (v,v)&lt;0\}\)</span>的两个连通分支。<span class="math inline">\(\mathcal{N}_+\)</span> 和<span class="math inline">\(\mathcal{N}_-\)</span> 分别是 <span class="math inline">\(\mathcal{Q}_+\)</span> 和 <span class="math inline">\(\mathcal{Q}_-\)</span> 的内部。</p></div><p>由于 Lorentzinian 内积是非退化的，所以我们可以把 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 等同起来，这样 <span class="math inline">\(\mathcal{C}\)</span> 和 <span class="math inline">\(\mathcal{C}^\ast\)</span> 都是 <span class="math inline">\(V\)</span> 的子集。我们将证明，这时 Tits 锥的闭包<span class="math inline">\(\overline{ \mathcal{C} }\)</span> 必然包含<span class="math inline">\(\mathcal{Q}_+,\,\mathcal{Q}_-\)</span>中的一个，同时与另一个的交仅为 <span class="math inline">\(\{0\}\)</span>。</p><p>首先根据 <a href="/coxeter-groups/tits-cone/#dual-cone-nonspace">前文结论</a>，<span class="math inline">\(\mathcal{C}^\ast\)</span>中任意两个向量之间的内积都非正，特别地对任何 <span class="math inline">\(v\in\mathcal{C}^\ast\)</span> 有 <span class="math inline">\((v,v)\leq0\)</span>，所以 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}\)</span>。</p><div id="dual-cone-trivial-intersection" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.8</span>.</span><span class="statement-spah"> </span>在 <span class="math inline">\(W\)</span> 不可约且双曲的情形，<span class="math inline">\(\mathcal{C}^\ast\cap\mathcal{Q}_+,\,\mathcal{C}^\ast\cap\mathcal{Q}_-\)</span> 中必有一个是<span class="math inline">\(\{0\}\)</span>。</p></div><p>这个结论应该是很直观的，如果 <span class="math inline">\(\mathcal{C}^\ast\)</span> 同时包含 <span class="math inline">\(\mathcal{Q}_+,\mathcal{Q}_-\)</span>中的非零向量的话，由于 <span class="math inline">\(\mathcal{C}^\ast\)</span>是点锥，这两个向量必然不共线，从而它们的非负线性组合可以给出 space-like的向量，这与 <span class="math inline">\(\mathcal{C}^\ast\)</span> 不含space-like 的向量矛盾。</p><p><strong>证明</strong>：若不然，设 <span class="math inline">\(u\in\mathcal{C}^\ast\cap\mathcal{Q}_+,\,v\in\mathcal{C}^\ast\cap\mathcal{Q}_-\)</span> 是非零向量，由于 <span class="math inline">\(\mathcal{C}^\ast\)</span> 是点锥，所以 <span class="math inline">\(u,v\)</span> 线性无关。根据 <a href="#connected-component-dot" title="命题 4.6">命题 4.6</a>，<span class="math inline">\(u,v\)</span> 的正线性组合中包含 space-like的向量，这与 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}\)</span>矛盾。<span class="math inline">\(\blacksquare\)</span></p><div id="dual-cone-belongs-branch" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论4.9</span>.</span><span class="statement-spah"></span>在双曲的情形，必有 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_+\)</span> 或者<span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_-\)</span>之一成立。</p></div><p><strong>证明</strong>：结合 <a href="#dual-cone-trivial-intersection" title="命题 4.8">命题 4.8</a> 和 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}=\mathcal{Q}_+\cup\mathcal{Q}_-\)</span>即得。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-closure" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论4.10</span>.</span><span class="statement-spah"></span>在双曲的情形，如果 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_+\)</span> 则<span class="math inline">\(\mathcal{C}\supset\mathcal{N}_-\)</span>。反之若 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_-\)</span> 则<span class="math inline">\(\mathcal{C}\supset\mathcal{N}_+\)</span>。</p></div><p><strong>证明</strong>：首先注意到对任何 <span class="math inline">\(x\in\mathcal{Q}_+\)</span> 和 <span class="math inline">\(y\in\mathcal{Q}_-\)</span> 有 <span class="math inline">\((x,y)\geq0\)</span>，所以 <span class="math inline">\(\mathcal{Q}_+\)</span> 和 <span class="math inline">\(\mathcal{Q}_-\)</span>互相包含在对方的对偶锥中。</p><p>由 <a href="#dual-cone-belongs-branch" title="推论 4.9">推论4.9</a>，不妨设 <span class="math inline">\(\mathcal{C}^\ast\subseteq\mathcal{Q}_+\)</span>，<a href="/coxeter-groups/tits-cone/#dual-dual-cone">取对偶以后有</a> <span class="math display">\[\overline{\mathcal{C}}=\mathcal{C}^{\ast\ast}\supseteq\mathcal{Q}_+^\ast\supseteq\mathcal{Q}_-.\]</span>由于凸集的内点等于其闭包的内点，所以 <span class="math display">\[\mathcal{C}^\circ=(\overline{ \mathcal{C}})^\circ\supset\mathcal{Q}_-^\circ=\mathcal{N}_-.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>以双曲群 <span class="math inline">\((7,3)\)</span>为例，红色的锥是 <span class="math inline">\(\overline{\mathcal{D}}\)</span>，Tits 锥 <span class="math inline">\(\mathcal{C}=\mathcal{N}_+\)</span>。取 <span class="math inline">\(\mathcal{C}\)</span> 与 hyperboloid的交给出双曲密铺。</p><p><img src="/images/coxeter/Tits_hyperbolic.png" class="fig" width="350"></p><p>注意这里光锥是理想边界，光锥上的点（除 <span class="math inline">\(0\)</span>以外）无法经过有限次反射变换到基本区域中，所以理想边界不属于 <span class="math inline">\(\mathcal{C}\)</span>。即 <span class="math inline">\(\mathcal{C}\subsetneqq\mathcal{Q}_+\)</span>。</p></div><h1 id="总结">总结</h1><p>下面的表格总结了有限、仿射、双曲三种情形 <span class="math inline">\(\mathcal{C}\)</span> 和 <span class="math inline">\(\mathcal{C}^\ast\)</span> 的结论：</p><table><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\mathcal{C}\)</span></td><td style="text-align: center;"><span class="math inline">\(\mathcal{C}^\ast\)</span></td></tr><tr class="even"><td style="text-align: center;">有限</td><td style="text-align: center;"><span class="math inline">\(V^\ast\)</span></td><td style="text-align: center;"><span class="math inline">\(\{0\}\)</span></td></tr><tr class="odd"><td style="text-align: center;">仿射</td><td style="text-align: center;"><span class="math inline">\(\{\delta&gt;0\}\cup\{0\}\)</span></td><td style="text-align: center;"><span class="math inline">\(\mathbb{R}_{\geq0}\delta\)</span></td></tr><tr class="even"><td style="text-align: center;">双曲</td><td style="text-align: center;">点锥，包含 <span class="math inline">\(\mathcal{N}_+,\mathcal{N}_-\)</span> 之一</td><td style="text-align: center;">点锥，属于 <span class="math inline">\(\mathcal{Q}_+,\mathcal{Q}_-\)</span> 之一</td></tr></tbody></table><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Howlett1997" class="csl-entry" role="listitem">Howlett, Robert B., Peter Rowley, and D. E. Taylor. 1997. <span>“OnOuter Automorphism Groups of Coxeter Groups.”</span> <em>ManuscriptaMathematica</em> 93: 499–513. <a href="https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/HowRowTay/1996-26.html">https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/HowRowTay/1996-26.html</a>.</div><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div><div id="ref-ratcliffe" class="csl-entry" role="listitem">Ratcliffe, John G. 2006. <em>Foundations of Hyperbolic Manifolds</em>.Second. Vol. 149. Graduate Texts in Mathematics. Springer.</div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/todo/card.html"/>
      <url>/todo/card.html</url>
      
        <content type="html"><![CDATA[<ol type="1"><li><del>Aztec 钻石图</del></li><li><del>Beauty of roots</del></li><li><del>112 阶完美正方形</del></li><li><del>Fano 平面</del></li><li>Hilbert 曲线</li><li>Weierstrass 函数</li><li>Platonic solids</li><li>Apollonian 圆堆</li><li>Monotile</li><li>模群</li><li>Lorentz 吸引子</li><li><del>三体周期解</del></li><li><del>Mandelbrot</del></li><li>焦散</li><li>Bruhat-Tits 树</li><li>双曲空间随机游动</li><li>The beauty of Schottky groups</li><li>龙曲线和 Cantor 集合 (complex bases)</li><li>电场线和 Marden 定理</li><li>五点共圆问题</li><li>Klein 自守函数</li><li>E8 根系图</li><li>复半单李代数的 Coxeter-Dynkin 图</li><li>卡门涡街</li><li>复变函数和 airy flow? 或者 rreusser 的 potential flow?</li><li>黎曼曲面</li><li>Voronoi?</li><li>Hexagon lloyd 算法？</li><li>Thurston circle packing</li><li>Bianchi and polyhedra circle packing</li><li>Mcmullen’s gallery</li></ol>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群语言正则的证明</title>
      <link href="/coxeter-automatic/bak.html"/>
      <url>/coxeter-automatic/bak.html</url>
      
        <content type="html"><![CDATA[<div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.1</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha,\beta\in\Phi\)</span> 满足 <span class="math inline">\(|(\alpha,\beta)|&lt;1\)</span>，则必然有 <span class="math inline">\((\alpha,\beta)=\cos(p\pi/q)\)</span>，其中 <span class="math inline">\(p,q\)</span> 是互素的正整数，而且反射 <span class="math inline">\(r_\alpha,r_\beta\)</span> 生成的子群是有限群。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(|(\alpha,\beta)|&lt;1\)</span>，则内积 <span class="math inline">\((\,,)\)</span> 限制在 <span class="math inline">\(\alpha,\beta\)</span> 张成的二维子空间 <span class="math inline">\(U=\mathop{\mathrm{span}}{\{\alpha,\beta\}}\)</span>上是正定的。</p><p>我们可以不妨假定 <span class="math inline">\(\alpha\)</span>是正根，以及 <span class="math inline">\(\beta=\alpha_s\)</span>是单根。设 <span class="math display">\[\alpha = c_s\alpha_s +\sum_{t\ne s }c_t\alpha_t.\]</span> 由于 <span class="math inline">\(\alpha\)</span> 不可能是 <span class="math inline">\(\alpha_s\)</span> 的正倍数，所以 <span class="math inline">\(\gamma=\alpha - c_s\alpha_s\ne0\)</span>。</p><p>注意到如果 <span class="math inline">\(a,b\in\mathbb{R}\)</span> 使得<span class="math inline">\(a\gamma+b\alpha_s\in\Phi\)</span>，则 <span class="math inline">\(a,b\)</span> 必须同时非负，或者同时非正。如果<span class="math inline">\(\alpha,\beta\)</span> 所夹的角度是 <span class="math inline">\(\pi\)</span> 的无理数倍，那么 <span class="math inline">\((r_\alpha s)\)</span> 是 <span class="math inline">\(U\)</span> 上角度为 <span class="math inline">\(\pi\)</span> 的无理数倍的旋转，它的各次幂 <span class="math inline">\(\{(r_\alpha s)^n,n=0,1,\ldots,\}\)</span> 会将<span class="math inline">\(\alpha\)</span> 映射为 <span class="math inline">\(U\)</span>中单位圆周上稠密的集合，特别地必然有某个 <span class="math inline">\(k\)</span> 使得 <span class="math inline">\((r_\alpha s)^k\alpha\)</span> 位于区域 <span class="math inline">\(\{a\gamma+b\alpha_s\mid a &gt; 0,b&lt;0\}\)</span> 中，这与此区域不包含任何根矛盾。所以 <span class="math inline">\(\alpha,\beta\)</span> 所夹的角度必须是 <span class="math inline">\(\pi\)</span> 的有理数倍，形如 <span class="math inline">\(p\pi/q\)</span>，从而 <span class="math inline">\(r_\alpha,r_\beta\)</span> 生成的子群 <span class="math inline">\(D\)</span> 在 <span class="math inline">\(U\)</span> 上的作用是一个二面体群。另一方面 <span class="math inline">\((\,,)\)</span> 限制在 <span class="math inline">\(U\)</span> 上是正定的，所以 <span class="math inline">\(V=U\oplus U^\bot\)</span>。而 <span class="math inline">\(D\)</span> 作用在 <span class="math inline">\(U^\bot\)</span> 上是平凡的，所以 <span class="math inline">\(D\)</span> 在全空间上的作用也是二面体群。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义0.2</span>.</span><span class="statement-spah"> </span>对任何正根 <span class="math inline">\(\alpha\in\Phi^+\)</span>，定义其深度为 <span class="math display">\[\mathrm{dp}(\alpha)=\min\{\,l(w) \midw\alpha\in\Phi^-\,\}.\]</span> 对两个正根 <span class="math inline">\(\alpha,\beta\)</span>，定义 <span class="math inline">\(\alpha\preceq\beta\)</span> 当且仅当存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(\beta=w\alpha\)</span> 并且 <span class="math display">\[\mathrm{dp}(\beta)=\mathrm{dp}(\alpha)+l(w).\]</span>如果 <span class="math inline">\(\alpha\preceq\beta\)</span> 且 <span class="math inline">\(\alpha\ne\beta\)</span> 我们记为 <span class="math inline">\(\alpha\prec\beta\)</span>。</p></div><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\preceq\)</span> 是 <span class="math inline">\(\Phi^+\)</span> 上的偏序。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span> 使得 <span class="math inline">\(\alpha\prec\beta\)</span>，则必然有 <span class="math inline">\(\mathrm{dp}(\beta)&gt;\mathrm{dp}(\alpha)\)</span>，即<span class="math inline">\(\preceq\)</span> 是反对称的。我们只要再证明<span class="math inline">\(\preceq\)</span> 是传递的。</p><p>设 <span class="math inline">\(\alpha,\beta,\gamma\in\Phi^+\)</span>满足 <span class="math inline">\(\alpha\preceq\beta\)</span> 和 <span class="math inline">\(\beta\preceq\gamma\)</span>，我们来证明 <span class="math inline">\(\alpha\preceq\gamma\)</span>。为此我们设 <span class="math display">\[\begin{aligned}\beta &amp;= u\alpha, &amp;\mathrm{dp}(\beta) - \mathrm{dp}(\alpha) =l(u).\\\gamma &amp;= v\beta, &amp;\mathrm{dp}(\gamma) - \mathrm{dp}(\beta) =l(v).\\\end{aligned}\]</span> 显然 <span class="math inline">\(\gamma=vu\alpha\)</span> 且<span class="math inline">\(\mathrm{dp}(\gamma)-\mathrm{dp}(\alpha)=l(u)+l(v)\)</span>。只要再证明 <span class="math inline">\(l(uv)=l(u)+l(v)\)</span> 即可。</p><p>设 <span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(w\alpha\in\Phi^-\)</span> 且 <span class="math inline">\(l(w)=\mathrm{dp}(\alpha)\)</span>。于是 <span class="math display">\[\gamma=vu\alpha\Rightarrowu^{-1}v^{-1}\gamma=\alpha \Rightarrowwu^{-1}v^{-1}\gamma\in\Phi^-.\]</span> 从而 <span class="math inline">\(l(wu^{-1}v^{-1})\geq\mathrm{dp}(\gamma)\)</span>。</p><p>另一方面 <span class="math display">\[l(wu^{-1}v^{-1})\leql(w)+(l(u)+l(v))=\mathrm{dp}(\alpha)+(\mathrm{dp}(\gamma)-\mathrm{dp}(\alpha))=\mathrm{dp}(\gamma).\]</span>所以 <span class="math inline">\(l(wu^{-1}v^{-1})=\mathrm{dp}(\gamma)\)</span>，特别地上式中所有的不等号都是等号，于是<span class="math inline">\(l(wu^{-1}v^{-1})=l(w)+l(u)+l(v)\)</span>，从而必然有 <span class="math inline">\(l(uv)=l(u)+l(v)\)</span>。<span class="math inline">\(\blacksquare\)</span>。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha_s\)</span> 是单根，<span class="math inline">\(\alpha\ne\alpha_s\)</span> 是正根，则 <span class="math display">\[\mathrm{dp}(s\alpha)=\begin{cases}\mathrm{dp}(\alpha)-1&amp; \text{if } (\alpha,\alpha_s)&gt;0,\\\mathrm{dp}(\alpha) &amp;\text{if } (\alpha,\alpha_s)=0.\\\mathrm{dp}(\alpha)+1 &amp; \text{if }(\alpha,\alpha_s)&lt;0.\end{cases}\]</span></p></div><p>第二条是显然的，而第三条可以由第一条得出：只要对 <span class="math inline">\(s\alpha\)</span>应用第一条的结论即可。所以我们只需要证明第一条。</p><p>首先取 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(l(w)=\mathrm{dp}(\alpha)\)</span> 且 <span class="math inline">\(w\alpha\in\Phi^-\)</span>。</p><ol type="1"><li><p>如果 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>，则<span class="math inline">\(l(ws)&lt;l(w)\)</span>，并且 <span class="math inline">\(ws\)</span> 满足 <span class="math inline">\((ws)(s\alpha)&lt;0\)</span>，所以 <span class="math inline">\(\mathrm{dp}(s\alpha)\leql(ws)=l(w)-1\)</span>，从而 <span class="math inline">\(\mathrm{dp}(s\alpha)=l(w)-1\)</span>。</p></li><li><p>如果 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>，则<span class="math inline">\(w(s\alpha)\)</span> 是负根，并且 <span class="math display">\[\begin{align*}w(s\alpha)&amp;=w(\alpha - 2(\alpha,\alpha_s)\alpha_s)\\&amp;=w\alpha-cw\alpha_s (c&gt;0)\end{align*}\]</span> 由于 <span class="math inline">\(\alpha\ne\alpha_s\)</span>是不同的正根，所以它们不共线，从而 <span class="math inline">\(w\alpha\)</span> 和 <span class="math inline">\(w\alpha_s\)</span>也不共线，于是上式是两个不共线的负根的和，所以任何单反射不能将 <span class="math inline">\(w(s\alpha)\)</span> 变成正根。取 <span class="math inline">\(t\in S\)</span> 使得 <span class="math inline">\(l(tw)&lt;l(w)\)</span>，则 <span class="math inline">\((tw)(s\alpha)\)</span> 仍然是负根，所以 <span class="math inline">\(\mathrm{dp}(s\alpha)\leql(tw)=l(w)-1\)</span>，结论仍然得证。</p></li></ol><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.5</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha\preceq\beta\)</span>，则存在序列 <span class="math display">\[\alpha=\alpha_0\preceq\alpha_1\preceq\cdots\preceq\alpha_k=\beta\]</span>使得对每个 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(\mathrm{dp}(\alpha_{i+1})=\mathrm{dp}(\alpha_i)+1\)</span>。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(w=s_k\cdotss_1\)</span> 满足 <span class="math inline">\(\beta=w\alpha\)</span> 且<span class="math inline">\(l(w)=\mathrm{dp}(\beta)-\mathrm{dp}(\alpha)\)</span>，考虑<span class="math inline">\(\alpha_i=s_i\cdots s_1\alpha\)</span>，其中<span class="math inline">\(\alpha_0=\alpha\)</span>，<span class="math inline">\(\alpha_k=\beta\)</span>。从 <span class="math inline">\(\alpha_0\)</span> 到 <span class="math inline">\(\alpha_k\)</span> 经过了 <span class="math inline">\(k=l(w)\)</span> 次单反射，depth 增加了 <span class="math inline">\(l(w)\)</span>，但上面的引理告诉我们每次单反射depth 至多增加 1，所以只能是每一项的 depth 都比前一项增加了1，即得结论。</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.6</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha\preceq\beta\)</span>，且 <span class="math inline">\(\alpha=\sum c_s\alpha_s,\, \beta=\sumd_s\alpha_s\)</span>，则对每个 <span class="math inline">\(s\)</span> 有<span class="math inline">\(c_s\leq d_s\)</span>。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(\beta=s\alpha\)</span> 则 <span class="math inline">\(\alpha,\beta\)</span> 只有在 <span class="math inline">\(\alpha_s\)</span> 项的系数不同。又 <span class="math inline">\((\alpha,\alpha_s)&lt;0\)</span> 所以 <span class="math inline">\(d_s&gt;c_s\)</span> 得证。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义0.7</span>.</span><span class="statement-spah"> </span>对 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span>，如果对任何 <span class="math inline">\(w\in W\)</span> 都有 <span class="math inline">\(w\alpha\in\Phi^-\Rightarroww\beta\in\Phi^-\)</span>，我们就称 <span class="math inline">\(\alpha\)</span> 支配 <span class="math inline">\(\beta\)</span>，记作 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>。</p></div><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.8</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span> 且 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>，则：</p><ol type="1"><li><span class="math inline">\((\alpha,\beta)&gt;0\)</span>。</li><li>若 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\beta\)</span> 是正根，则 <span class="math inline">\(w\alpha\,\mathrm{dom}\,w\beta\)</span>。</li><li>若 <span class="math inline">\(\alpha\prec\alpha'\)</span> 则<span class="math inline">\(\alpha'\)</span>不是极小根。换句话说，若一个根是极小根，则在偏序 <span class="math inline">\(\preceq\)</span> 下小于它的根也都是极小根。</li><li><span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>，等号当且仅当<span class="math inline">\(\alpha=\beta\)</span> 时成立。</li></ol></div><p><strong>证明</strong>：</p><ol type="1"><li><p><span class="math inline">\(r_\alpha\)</span> 满足 <span class="math inline">\(r_\alpha\alpha=-\alpha\in\Phi^-\)</span>，所以<span class="math inline">\(r_\alpha\beta=\beta-2(\alpha,\beta)\alpha&lt;0\)</span>，这必须<span class="math inline">\((\alpha,\beta)&gt;0\)</span> 才行。</p></li><li><p>显然。</p></li><li><p>只要对 <span class="math inline">\(\mathrm{dp}(\alpha')=\mathrm{dp}(\alpha)+1\)</span>进行证明即可。这时存在单反射 <span class="math inline">\(s\)</span> 使得<span class="math inline">\(\alpha'=s\alpha\)</span>，并且 <span class="math inline">\((\alpha_s,\alpha)&lt;0\)</span>。根据 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span> 和 <span class="math inline">\((\alpha,\beta)&gt;0\)</span> 说明 <span class="math inline">\(\beta\ne\alpha_s\)</span>，从而 <span class="math inline">\(s\beta\)</span> 是正根，从而 <span class="math inline">\(\alpha'=s\alpha\,\mathrm{dom}\,s\beta\)</span>不是极小根。</p></li><li><p><span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>显然意味着 <span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>。设<span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\alpha=-\alpha_s\)</span> 是某个负的单根，则<span class="math inline">\(w\beta\in\Phi^-\)</span>。注意这时 <span class="math inline">\(w^{-1}\alpha_s=-\alpha&lt;0\)</span>，所以 <span class="math inline">\(l(sw)&lt;l(w)\)</span>。</p><ul><li><p>若 <span class="math inline">\(sw\beta\in\Phi^+\)</span>，则由<span class="math inline">\(w\beta&lt;0\)</span> 可知 <span class="math inline">\(w\beta=-\alpha_s\)</span>，再结合 <span class="math inline">\(w\alpha=-\alpha_s\)</span> 可得 <span class="math inline">\(\alpha=\beta\)</span>。</p></li><li><p>若 <span class="math inline">\(sw\beta\in\Phi^-\)</span>，则<span class="math inline">\(\mathrm{dp}(\beta)\leql(sw)&lt;\mathrm{dp}(\alpha)\)</span>。</p></li></ul></li></ol><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.9</span>.</span><span class="statement-spah"> </span>在有限 Coxeter群中，所有根都是极小根。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(w_0\)</span>是最长元，则 <span class="math inline">\(\alpha\to -w_0(\alpha)\)</span>置换 <span class="math inline">\(\Phi^+\)</span>。我们来验证这个置换保持每个正根的深度不变：若<span class="math inline">\(w\alpha&lt;0\)</span>，则 <span class="math inline">\(w_0w\alpha&gt;0\)</span>，从而 <span class="math inline">\((w_0ww_0)-w_0\alpha&lt;0\)</span>，这说明 <span class="math inline">\(\mathrm{dp}(-w_0\alpha)\geql(w_0ww_0)=l(w)\)</span>。对 <span class="math inline">\(-w_0\alpha\)</span> 应用此结论可得 <span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(-w_0\alpha)\)</span>。从而二者相等。</p><p>另一方面我们来验证它翻转 <span class="math inline">\(\,\mathrm{dom}\,\)</span> 这个偏序：若 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>，则 <span class="math display">\[\begin{align*}w\alpha&lt;0&amp;\Rightarrow w\beta&lt;0\\&amp;\Downarrow\\w\beta &gt; 0&amp;\Rightarrow w\alpha&gt;0\\&amp;\Downarrow\\ww_0\beta &gt; 0&amp;\Rightarrow ww_0\alpha&gt;0\\&amp;\Downarrow\\w(-w_0\beta) &lt; 0&amp;\Rightarrow w(-w_0\alpha)&lt;0\\\end{align*}\]</span> 即确实有 <span class="math inline">\(-w_0\beta\,\mathrm{dom}\,-w_0\alpha\)</span>。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.10</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span> 的充要条件是<span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>且 <span class="math inline">\((\alpha,\beta)\geq1\)</span>。</p></div><p><strong>证明</strong>：我们只考虑 <span class="math inline">\(\alpha\ne\beta\)</span> 的情形即可。</p><p><span class="math inline">\(\Rightarrow\)</span>：只要再证明 <span class="math inline">\((\alpha,\beta)\geq1\)</span>。用反证法，若不然，则<span class="math inline">\(0&lt;(\alpha,\beta)&lt;1\)</span>，从而<span class="math inline">\(r_\alpha,r_\beta\)</span>生成一个有限二面体群 <span class="math inline">\(D\)</span>。由于在有限群中没有支配关系，所以存在<span class="math inline">\(w\in D\)</span> 使得 <span class="math inline">\(w\alpha\in\Phi^-,\,w\beta\in\Phi^+\)</span>。这与<span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>矛盾。</p><p><span class="math inline">\(\Leftarrow\)</span>：我们先考虑 <span class="math inline">\(\beta=\alpha_s\)</span> 是一个单根的情形。由于<span class="math inline">\(\alpha\ne\beta\)</span> 所以 <span class="math inline">\(s\alpha\)</span> 仍然是正根。我们发现 <span class="math display">\[(\alpha,s\alpha)=(\alpha,\alpha-2(\alpha,\alpha_s)\alpha_s)=1-2(\alpha,\alpha_s)^2\leq-1.\]</span> 所以有无穷多个形如 <span class="math inline">\(a\alpha+b\alpha_s\)</span> 的正根，其中 <span class="math inline">\(a,b&gt;0\)</span>。</p><p>用反证法，如果 <span class="math inline">\(\alpha\)</span> 不支配<span class="math inline">\(\beta=\alpha_s\)</span>，则存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\alpha\in\Phi^-\)</span> 但 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>。由于 <span class="math display">\[w(s\alpha)=w\alpha -2(\alpha,\alpha_s)w\alpha_s\]</span> 是负根 <span class="math inline">\(w\alpha\)</span> 减去正根 <span class="math inline">\(w\alpha_s\)</span>的一个正倍数，必然仍然是负根。于是 <span class="math inline">\(\{\alpha,s\alpha\}\subsetN(w)\)</span>，从而所有形如 <span class="math inline">\(\{a\alpha+bs\alpha\mid a,b&gt;0\}\)</span>的根都在 <span class="math inline">\(N(w)\)</span> 中，这与 <span class="math inline">\(|N(w)|=l(w)&lt;\infty\)</span> 矛盾。</p><p>对 <span class="math inline">\(\beta\)</span> 是一般正根的情形，取<span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\beta\in\Delta\)</span>，<span class="math inline">\(l(w)=\mathrm{dp}(\beta)-1\)</span>。由于 <span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>所以 <span class="math inline">\(w\alpha\)</span> 仍然是正根，当然就有<span class="math inline">\(\mathrm{dp}(w\alpha)\geq\mathrm{dp}(w\beta)=1\)</span>和 <span class="math inline">\((w\alpha,w\beta)=(\alpha,\beta)\geq1\)</span>。根据上面的证明，<span class="math inline">\(w\alpha\,\mathrm{dom}\,w\beta\)</span>，所以 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.11</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\lambda,\mu\)</span> 是正根，且 <span class="math inline">\(s_\lambda,s_\mu\)</span>生成一个无限群，则下面三种情况必居其一：</p><ol type="1"><li><span class="math inline">\(\lambda\,\mathrm{dom}\,\mu\)</span>.</li><li><span class="math inline">\(\mu\,\mathrm{dom}\,\lambda\)</span>.</li><li><span class="math inline">\(s_\mu\lambda\,\mathrm{dom}\,\mu\)</span>且 <span class="math inline">\(s_\lambda\mu\,\mathrm{dom}\,\lambda\)</span>.</li></ol></div><p><strong>证明</strong>：<span class="math inline">\(s_\lambda,s_\mu\)</span> 生成一个无限群说明 <span class="math inline">\(|(\lambda,\mu)|\geq1\)</span>。如果 <span class="math inline">\((\lambda,\mu)\geq1\)</span> 那么 <span class="math inline">\(\lambda,\mu\)</span> 中 depth更大的那一个支配另一个。</p><p>如果 <span class="math inline">\((\lambda,\mu)\leq-1\)</span>我们来证明 <span class="math inline">\(s_\mu\lambda\,\mathrm{dom}\,\mu\)</span>，<span class="math inline">\(s_\lambda\mu\,\mathrm{dom}\,\lambda\)</span>的论证是一样的。注意到这时 <span class="math inline">\((s_\mu\lambda,\mu)=-(\lambda,\mu)\geq1\)</span>，所以只要再证明 <span class="math inline">\(\mathrm{dp}(s_\mu\lambda)\geq\mathrm{dp}(\mu)\)</span> 即可。</p><p>设 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w(s_\mu\lambda)&lt;0\)</span> 且 <span class="math inline">\(l(w)=\mathrm{dp}(s_\mu\lambda)\)</span>，我们来证明必有一个长度<span class="math inline">\(l(w')\leq l(w)\)</span> 的元素 <span class="math inline">\(w'\)</span> 使得 <span class="math inline">\(w'\mu&lt;0\)</span>，从而 <span class="math inline">\(\mathrm{dp}(s_\mu\lambda)\geq\mathrm{dp}(\mu)\)</span>。</p><p>首先若 <span class="math inline">\(w\mu&lt;0\)</span> 则可以取 <span class="math inline">\(w'=w\)</span>。否则若 <span class="math inline">\(w\mu&gt;0\)</span>，我们来计算 <span class="math display">\[w(s_\mu\lambda)=w\lambda-2(\mu,\lambda)w\mu.\]</span>我们知道这是一个负根，而且它是 <span class="math inline">\(w\lambda\)</span> 加上正根 <span class="math inline">\(w\mu\)</span> 的正倍数，所以必须 <span class="math inline">\(w\lambda&lt;0\)</span>，从而 <span class="math inline">\(l(ws_\lambda)&lt;l(w)\)</span>。</p><p>进一步我们计算 <span class="math display">\[(ws_\lambda)\mu=w\mu-2(\mu,\lambda)w\lambda.\]</span>我们来证明 <span class="math inline">\((ws_\lambda)\mu\)</span>是一个负根，从而 <span class="math inline">\(\mathrm{dp}(\mu)\leql(ws_\lambda)&lt;l(w)=\mathrm{dp}(s_\mu\lambda)\)</span>。</p><p>若不然，记 <span class="math inline">\(c=-2(\mu,\lambda)\geq2\)</span>，若 <span class="math inline">\((ws_\lambda)\mu=w\mu+cw\lambda&gt;0\)</span>，乘以<span class="math inline">\(c\)</span> 得到 <span class="math inline">\(cw\mu+c^2w\lambda\)</span>是正根的非负线性组合（未必还是根），根据上面 <span class="math inline">\(w\lambda+cw\mu&lt;0\)</span>，减去后者得到 <span class="math inline">\((c^2-1)w\lambda\)</span> 是正根的非负线性组合，但<span class="math inline">\(c^2-1\geq 3\)</span>，这与 <span class="math inline">\(w\lambda&lt;0\)</span> 矛盾。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.12</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span> 满足 <span class="math inline">\(\beta\preceq\alpha\)</span>，并且 <span class="math inline">\(\alpha\)</span> 是极小根。进一步设 <span class="math inline">\(\alpha_s\in\Delta\)</span> 满足 <span class="math inline">\((\beta,\alpha_s)\leq-1\)</span>，则 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> 的 <span class="math inline">\(\alpha_s\)</span> 项的系数相等。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(\beta\preceq\gamma\preceq\alpha\)</span> 使得<span class="math inline">\(\gamma\)</span> 是偏序 <span class="math inline">\(\preceq\)</span> 下最大的与 <span class="math inline">\(\beta\)</span> 有相同的 <span class="math inline">\(\alpha_s\)</span> 项系数。如果 <span class="math inline">\(\gamma\ne\alpha\)</span>，则存在 <span class="math inline">\(t\)</span> 使得 <span class="math inline">\(\gamma\prec t\gamma\preceq\alpha\)</span>。由<span class="math inline">\(\gamma\)</span> 的极大性可得 <span class="math inline">\(s=t\)</span>。</p><p>但是 <span class="math inline">\(\gamma-\beta=\sum_{t\nes}c_t\alpha_t\)</span>，且每个 <span class="math inline">\(c_t\geq0\)</span>。因此 <span class="math display">\[(s\gamma,\alpha_s)=(\gamma,-\alpha_s)=-(\beta,\alpha_s)-\sum_{t\ner}c_t(\alpha_t,\alpha_s)\geq1.\]</span> 于是 <span class="math inline">\(s\gamma\,\mathrm{dom}\,\alpha_s\)</span>不是极小根，从而 <span class="math inline">\(\alpha\succeqs\gamma\)</span> 也不是极小根。矛盾！所以 <span class="math inline">\(\gamma=\alpha\)</span>，从而命题得证。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.13</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi\)</span> 满足 <span class="math inline">\(|(\alpha,\beta)|\leq 1\)</span>，则这样的 <span class="math inline">\((\alpha,\beta)\)</span> 只有有限多个值。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(|(\alpha,\beta)|&lt;1\)</span> 则 <span class="math inline">\(r_\alpha,r_\beta\)</span> 生成的子群 <span class="math inline">\(D\)</span> 是有限的，所以存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(wDw^{-1}\)</span> 属于某个有限的标准椭圆子群 <span class="math inline">\(W_J\)</span>，特别地，<span class="math inline">\(r_\alpha r_\beta\)</span> 的阶 <span class="math inline">\(m\)</span> 应该整除 <span class="math inline">\(W_J\)</span> 的阶，从而 <span class="math inline">\((\alpha,\beta)\)</span> 形如 <span class="math inline">\(\cos(a\pi/m)\)</span>，其中 <span class="math inline">\(0\leq a\leq 2m\)</span> 而且 <span class="math inline">\(m\)</span>是某个有限标准椭圆子群的阶的因子。由于这样的子群是有限的，所以这样的<span class="math inline">\(\cos\)</span> 值也是有限的。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.14</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha=\sum a_s\alpha_s\)</span> 和 <span class="math inline">\(\beta=\sum b_s\alpha_s\)</span> 都是正根。进一步设<span class="math inline">\(S=I\cup J\)</span> 使得</p><ol type="1"><li>对任何 <span class="math inline">\(t\in I\)</span> 有 <span class="math inline">\((\alpha,\alpha_t)=(\beta,\beta_t)\)</span>。</li><li><span class="math inline">\(c_t=b_t\)</span> 对任何 <span class="math inline">\(t\in J\)</span> 成立。</li></ol><p>则 <span class="math inline">\((\alpha,\beta)=1\)</span>。</p></div><p>注意这里 <span class="math inline">\(I\)</span> 或者 <span class="math inline">\(J\)</span> 允许有一个是空集。</p><p><strong>证明</strong>：我们有 <span class="math inline">\(\alpha-\beta=\sum_{s\inI}(a_s-b_s)\alpha_s\)</span>，所以 <span class="math display">\[(\alpha,\alpha-\beta)=\sum_{s\inI}(a_s-b_s)(\alpha,\alpha_s)=\sum_{s\inI}(a_s-b_s)(\beta,\alpha_s)=(\beta,\alpha-\beta).\]</span> 即 <span class="math inline">\((\alpha,\beta)=1\)</span>。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理0.15</span>.</span><span class="statement-spah"></span>极小根集合是有限的。</p></div><p><strong>证明</strong>：我们来证明极小根的深度是有上界的。设 <span class="math inline">\(\beta\)</span> 是一个深度为 <span class="math inline">\(d\)</span> 的极小根，<span class="math inline">\(\beta_1\prec\cdots\prec\beta_d=\beta\)</span>是一个序列满足 <span class="math inline">\(\mathrm{dp}(\beta_i)=i\)</span>，则每个 <span class="math inline">\(\beta_i\)</span> 都是极小根。</p><p>记 <span class="math inline">\(J_i=\{\gamma\in\Delta \mid (\gamma,\beta_i)\geq-1\}\)</span>。我们来证明 <span class="math inline">\(\{J_i,1\leq i\leq d\}\)</span>是递降的，并且最终会降为空集。</p><p>对 <span class="math inline">\(1\leq i\leq d\)</span>，若 <span class="math inline">\(\gamma\notin J_i\)</span>，则 <span class="math inline">\(\gamma\)</span> 在所有 <span class="math inline">\(\beta_j(j\geq i)\)</span> 中的系数都相同。</p><p>设 <span class="math inline">\(\beta_i=\sum c_s\alpha_s,\,\beta_j=\sum d_s\alpha_s\)</span>，则 <span class="math inline">\(0\leqc_s\leq d_s\)</span> 且 <span class="math inline">\(c_\gamma=d_\gamma\)</span>。注意到 <span class="math inline">\((\beta_j,\gamma)=\sum_{s\in\Delta}d_s(\alpha_s,\gamma)\leq \sum_{s\in\Delta}c_s(\alpha_s, \gamma)=(\beta_i,\gamma)&lt;-1\)</span>。所以 <span class="math inline">\(\gamma\not\inJ_j\)</span>。即 <span class="math inline">\(\{J_i\}\)</span>确实是递降的。</p><p>设 <span class="math inline">\(J_i=\cdots=J_i=J\)</span> 对某个 <span class="math inline">\(i&lt;j\)</span> 成立。对任何 <span class="math inline">\(\gamma\in J\)</span> 和 <span class="math inline">\(i\leq k\leq j\)</span>，由于 <span class="math inline">\(\beta_k\)</span> 不能支配 <span class="math inline">\(\gamma\)</span>，所以 <span class="math inline">\(-1\leq (\beta,\gamma)\leq 1\)</span>，等于 1当且仅当 <span class="math inline">\(\beta=\gamma\)</span>。于是 <span class="math inline">\((\beta_k,\gamma)\in\mathcal{C}(S)\)</span>。于是如果<span class="math inline">\(j-i&gt;|\mathcal{C}(S)|^{|S|}\)</span>那么必然存在 <span class="math inline">\(i\leq m &lt; n\leq j\)</span>使得 <span class="math inline">\((\beta_m, J)=(\beta_n,J)\)</span>。（鸽笼原理，<span class="math inline">\(\beta\)</span>和一个单根的内积有 <span class="math inline">\(|c|\)</span>种不同的可能值，和所有单根的内积共有 <span class="math inline">\(c^{|S|}\)</span> 种不同的可能值）。</p><p>但是如果 <span class="math inline">\(\gamma\not\in J\)</span>，则<span class="math inline">\(\gamma\)</span> 在 <span class="math inline">\(\beta_m,\beta_n\)</span>中的系数相同，所以根据前面的引理 <span class="math inline">\((\beta_m,\beta_n)=1\)</span>，但这导致 <span class="math inline">\(\beta_n \,\mathrm{dom}\,\beta_m\)</span>，所以如果<span class="math inline">\(j-i&gt;c^{|S|}\)</span> 时 <span class="math inline">\(J_j\)</span> 必须比 <span class="math inline">\(J_i\)</span> 严格地小，所以整个链的长度有限，即<span class="math inline">\(d\)</span> 有限。</p><blockquote><p><strong>引理</strong>：设 <span class="math inline">\(\gamma\)</span>不是极小根，<span class="math inline">\(u,v\in W\)</span> 使得 <span class="math inline">\(u\gamma, v^{-1}\gamma\)</span> 都是单根，则 <span class="math inline">\(l(uv)\ne l(u)+l(v)\)</span>。</p></blockquote><p>证明：设 <span class="math inline">\(u\gamma=\alpha_s,v^{-1}\gamma=\alpha_t\)</span>，则<span class="math inline">\(\gamma\in N(su)\capN(tv^{-1})\)</span>。又设 <span class="math inline">\(\gamma\,\mathrm{dom}\,\beta\)</span>，则 <span class="math inline">\(\beta\in N(su)\cap N(tv^{-1})\)</span>。但是 <span class="math inline">\(u\beta\ne u\gamma=\alpha_s\)</span>，所以 <span class="math inline">\(su\beta\in\Phi^-\)</span> 说明 <span class="math inline">\(u\beta\in\Phi^-\)</span>。同理 <span class="math inline">\(v^{-1}\beta\in\Phi^-\)</span>，所以 <span class="math inline">\(N(u)\cap N(v^{-1})\)</span>非空，所以引理得证。</p><hr><p>设 <span class="math inline">\(\Sigma\)</span>是所有极小根组成的集合，则 <span class="math inline">\(|\Sigma|&lt;\infty\)</span> 是有限集。</p><p>定义状态机如下：</p><p>一个状态 <span class="math inline">\(S_i\subset\Sigma\)</span>是极小根的子集。转移 <span class="math inline">\(S_i\xrightarrow{s}S_{i+1}\)</span> 为：</p><ol type="1"><li>如果 <span class="math inline">\(s\in S_i\)</span> 则 <span class="math inline">\(S_i\xrightarrow{s}\mathrm{NO}\)</span>。</li><li>如果 <span class="math inline">\(s\notin S_i\)</span> 则 <span class="math inline">\(S_i\xrightarrow{s} (sS_i\cup \{\alpha_s\}\cup\{s\alpha_t,t&lt;s\})\cap\Sigma\)</span>。</li></ol><p>我们来证明这个状态机识别语言 <span class="math inline">\(\mathcal{L}\)</span>。</p><p>为方便我们记 <span class="math inline">\(\mathcal{R}_i=\{\alpha_s\in\Delta,s&lt;i\}\)</span> 是那些字典序下小于 <span class="math inline">\(\alpha_i\)</span> 的单根组成的集合。</p><p>假设 <span class="math inline">\(s_1\cdots s_l\in\mathcal{L}\)</span>，但是 <span class="math inline">\(s_1\cdotss_{l+1}\notin \mathcal{L}\)</span> 当且仅当 <span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。其中 <span class="math inline">\(S_i\subset\Sigma\)</span> 是状态机读入 <span class="math inline">\(s_i\)</span> 以后的状态。</p><p>我们来证明对任何 <span class="math inline">\(k\leq l\)</span> 有<span class="math display">\[S_k\subset\{(s_k\cdots s_{i+1})\alpha_i\mid1\leq i\leq l\}\cup\cup_{i=1}^{k}(s_k\cdotss_i)\cdot\mathcal{R}_i.\]</span> 首先 <span class="math inline">\(k=1\)</span> 时 <span class="math inline">\(S_1=\{\alpha_1\}\)</span>，</p><p>由于下一步读入 <span class="math inline">\(s_{l+1}\)</span>的时候是拒绝态，所以 <span class="math inline">\(\alpha_{l+1}\)</span>也属于上面的集合。</p><ul><li><p>如果 <span class="math inline">\(\alpha_{l+1}\in \{(s_l\cdotss_{i+1})\alpha_i\mid 1\leq i\leq l\}\)</span>，则 <span class="math inline">\(s_1\cdots s_ls_{l+1}\)</span> 不是既约的，所以不在<span class="math inline">\(\mathcal{L}\)</span> 中。</p></li><li><p>如果 <span class="math inline">\(\alpha_{l+1}\notin \{(s_l\cdotss_{i+1})\alpha_i\mid 1\leq i\leq l\}\)</span>，则 <span class="math inline">\(s_1\cdots s_ls_{l+1}\)</span> 是既约的，但是 <span class="math inline">\(\alpha_{l+1}\)</span> 形如 <span class="math inline">\(s_l\cdots s_{i}\alpha_r(r&lt;i)\)</span>，所以<span class="math inline">\(s_1\cdotss_{l+1}\notin\mathcal{L}\)</span>。</p></li></ul><p>反之，我们要证明如果 <span class="math inline">\(\mathcal{L}\)</span>拒绝一个字 <span class="math inline">\(w=s_1\cdots s_n\)</span>，设<span class="math inline">\(l\)</span> 是使得 <span class="math inline">\(\mathcal{L}\)</span> 接受 <span class="math inline">\(w\)</span> 的最大位置，则必有 <span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。用反证法，设 <span class="math inline">\(\alpha_{l+1}\notin S_l\)</span>。</p><ul><li><p>如果 <span class="math inline">\(s_1\cdots s_{l+1}\)</span>不是既约的，则存在 <span class="math inline">\(1\leq i\leq l\)</span>使得 <span class="math inline">\(\alpha_{l+1}=s_l\cdotss_{i+1}\alpha_i\)</span>。于是 <span class="math inline">\(l\)</span>在集合 <span class="math inline">\(\{i\leq k\leq l \mid (s_k\cdotss_{i+1})\alpha_i\notin S_k\}\)</span> 中。设 <span class="math inline">\(j\)</span> 是此集合的最小元素，<span class="math inline">\(\beta=s_j\cdots s_{i+1}\alpha_i\)</span>。由于<span class="math inline">\(\alpha_i\in S_i\)</span>，所以 <span class="math inline">\(j&gt;i\)</span>。于是 <span class="math inline">\(s_{j-1}\cdots s_{i+1}\alpha_i\inS_{j-1}\)</span>，<span class="math inline">\(\beta\ins_jS_{j-1}\)</span>。由于 <span class="math inline">\(s_j\cdotS_{j-1}\cap\Sigma\subset S_j\)</span> 这说明 <span class="math inline">\(\beta\)</span> 不是极小根。注意到 <span class="math inline">\((s_{i+1}\cdots s_j)\beta=\alpha_i\)</span> 和<span class="math inline">\((s_{j+1}\cdotss_l)^{-1}\beta=\alpha_{l+1}\)</span>，根据上面的引理 <span class="math inline">\(l(s_{r+1}\cdots s_l)\ne l-i\)</span>，这与 <span class="math inline">\(s_1\cdots s_l\in\mathcal{L}\)</span> 矛盾，所以<span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。</p></li><li><p>如果 <span class="math inline">\(s_1\cdots s_{l+1}\)</span>既约但不属于 <span class="math inline">\(\mathcal{L}\)</span>，则 <span class="math inline">\(\alpha_{l+1}=(s_l\cdotss_{i+1})\alpha_s(s&lt;i)\)</span>。设 <span class="math inline">\(i\leqj\leq l\)</span> 使得 <span class="math inline">\(\beta=(s_js_{j-1}\cdots s_i)\alpha_s\notinS_j\)</span>。如果 <span class="math inline">\(j\ne i\)</span>，则由于<span class="math inline">\(\{s_i\alpha_r\mid r&lt;i\}\cap\Sigma\subsetS_i\)</span> 这说明 <span class="math inline">\(\beta\)</span>不是极小根。若 <span class="math inline">\(j&gt;i\)</span> 同样可得<span class="math inline">\(\beta\)</span>不是极小根。于是根据上面同样的论证得出矛盾。</p></li></ul>]]></content>
      
    </entry>
    
    
  
</search>
