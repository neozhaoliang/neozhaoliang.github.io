<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IFS 分形揭秘</title>
      <link href="/ifs-demystified/"/>
      <url>/ifs-demystified/</url>
      
        <content type="html"><![CDATA[<p>几天前，我在上海科技大学数学所做了一个小报告，标题叫「GPU涂鸦与数学可视化」。这个报告是我和上科大数学所的陈浩老师、Abdelaziz NaitMerzouk合作的双曲反射群画展期间的一个助兴小节目。画展由陈浩老师一手操办，他不仅把展览办得漂亮，还带我去外滩逛了一圈。我在画展现场拍摄了一些照片，但是由于光线和拍摄技术的原因，照片质量不是很好，就不放在这里献丑了。你可以在<a href="https://github.com/neozhaoliang/Hyperbolic-Honeycombs">项目主页</a>看到原汁原味的渲染图。</p><p>以下是报告的技术部分内容。我略去了关于 demoscene和分形文化的部分。</p><span id="more"></span><hr><p>在 Shadertoy上有很多效果酷炫，但是代码非常短的分形作品。乍看起来，你会觉得作者在施展某种黑魔法。我挑选了其中三个优秀的例子展示如下：</p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr><td style="text-align: center;"><a href="https://www.shadertoy.com/view/ltB3DG">Ethereal</a> by Kali</td><td style="text-align: center;"><a href="https://www.shadertoy.com/view/NsVyRz">Apollonian fractal</a> byXor</td><td style="text-align: center;"><a href="https://www.shadertoy.com/view/mdG3Wy">Radiosity</a> by Xor</td></tr><tr><td style="text-align: center;"><img src="/images/ifs/kali.png" class="fig"></td><td style="text-align: center;"><img src="/images/ifs/xor_apollo.png" class="fig"></td><td style="text-align: center;"><img src="/images/ifs/xor_radio.png" class="fig"></td></tr></tbody></table><p>然而代码短可不代表它们容易看懂。尤其是很多作者还喜欢故弄玄虚，把代码作了混淆处理以增加神秘感。对我来说，这种被人秀了一脸却没搞明白对面是怎么装的逼的感觉让人很不爽。当然我不是在抱怨，这种炫技行为本身就是黑客文化的一部分，可以理解。</p><p>后来分形玩的多了，我也慢慢明白了其中的奥妙，他们是在玩一种很特别的“折纸游戏”——只是这个纸是空间本身。我们将要揭秘的，就是这种空间折纸术背后的数学原理。这些分形作品别看场景千变万化，其实都是用同一个套路制作出来的。这个套路可以简述为三步：</p><div class="statement simple plain unnumbered"><ol type="1"><li>将像素的 2D 坐标映射为空间中的某个 3D 点 <code>p</code>；</li><li>用一个 <code>fold</code> 函数反复作用在 <code>p</code>上，将<code>p</code> 变换到空间中另一个位置。这个 <code>fold</code>的作用就是折纸。每次迭代结束后，生成一个颜色并累加到当前的颜色<code>color</code> 上。</li><li>经过若干次迭代后，终止迭代，返回 <code>color</code>的值作为像素最终的颜色。</li></ol></div><p><code>fold</code> 函数背后的原理是所谓的 IFS（Iterated FunctionSystem，迭代函数系统），更准确的说，它是 IFS 的逆函数。使用 IFS的逆函数而不是 IFS 本身的原因是，正向的 IFS是「一对多」的，一个点会分裂成多个点，这在 GPU上无法并行处理。而逆函数则是「多对一」的，正好适合在 GPU上并行计算。</p><p>像 Menger Sponge、Koch 曲线、Sierpinski carpet那些耳熟能详的分形，它们都属于IFS。它们从原理上和上面那些酷炫的分形没有什么不同，区别只在于使用的<code>fold</code> 函数。</p><p>总之，要理解这一切，我们既要了解怎样通过 IFS 构建分形，还要了解怎样在GPU 上编程实现它。我们先从 IFS 开始说起。</p><h1 id="ifs-方法">IFS 方法</h1><div id="------------" class="unnumbered statement sta_____ plain"><p><span class="statement-heading"><span class="statement-label">压缩映射</span>.</span><span class="statement-spah"> </span><br></p><p>设 <span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}^n\)</span>是一个映射，如果存在 <span class="math inline">\(0&lt;r&lt;1\)</span>使得对任何 <span class="math inline">\(x,y\in\mathbb{R}^n\)</span> 有<span class="math display">\[d(f(x),f(y))\leq r\cdot d(x,y)\]</span>成立，我们就称 <span class="math inline">\(f\)</span>是一个压缩映射，<span class="math inline">\(r\)</span> 是压缩比例。这里<span class="math inline">\(d\)</span> 是通常的 Euclidean 距离。</p></div><p>记 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span>中所有紧集组成的集合，可以证明 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 在 <a href="https://en.wikipedia.org/wiki/Hausdorff_distance">Hausdorff度量</a> 下构成一个完备度量空间。你现在不必关心 Hausdoff度量的具体细节！你只要知道它是一个度量，可以衡量两个紧集的接近程度即可。</p><p>设 <span class="math inline">\(\{f_i\}_{i=1}^N\)</span> 是 <span class="math inline">\(N\)</span> 个不同的压缩映射，<span class="math inline">\(f_i\)</span> 的压缩比例是 <span class="math inline">\(0&lt;r_i&lt;1\)</span>。定义映射 <span class="math display">\[F:K(\mathbb{R}^n)\to K(\mathbb{R}^n),\quad F(X) =f_1(X)\cup f_2(X)\cup\cdots\cup f_N(X),\quad X\inK(\mathbb{R}^n).\]</span> 也就是说，对给定的紧集 <span class="math inline">\(X\)</span>，我们将它变形成 <span class="math inline">\(N\)</span>个版本，每个版本分别应用一个压缩变换、再把所有版本合起来，得到新的集合<span class="math inline">\(F(X)\)</span>。</p><p>把 <span class="math inline">\(X\)</span>想象成孙悟空，他拔出一把毫毛，变出一些小孙悟空 <span class="math inline">\(\{f_i(X)\}_{i=1}^N\)</span>，这些小孙悟空构成的集合就是<span class="math inline">\(F(X)\)</span>。</p><p>可以证明 <span class="math inline">\(F\)</span> 是空间 <span class="math inline">\(K(\mathbb{R}^n)\)</span>上的压缩映射，其压缩比例不超过 <span class="math inline">\(r=\max\{r_1,\ldots,r_N\}\)</span>。于是根据 <a href="https://en.wikipedia.org/wiki/Banach_fixed-point_theorem">Banach不动点定理</a>，存在唯一的紧集 <span class="math inline">\(A\subset\mathbb{R}^n\)</span> 使得 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(F\)</span> 的不动点： <span class="math display">\[F(A) = A.\]</span> 紧集 <span class="math inline">\(A\)</span> 叫做 <span class="math inline">\(F\)</span> 的极限集。<span class="math inline">\(A\)</span> 是一个分形，它具有自相似的特征。</p><p>不仅如此，Banach 不动点定理还告诉我们，对 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 中的任何一点 <span class="math inline">\(K\)</span>（记住 <span class="math inline">\(K\)</span> 是紧集），都有 <span class="math display">\[\lim_{n\to\infty} F^n(K) =A.\]</span> 即初始紧集<span class="math inline">\(K\)</span>的形状根本不重要——压缩的力量会抹去一切“个性”，只留下结构，那就是 <span class="math inline">\(A\)</span>！</p><p>以 <a href="https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle">Sierpiński三角形</a> 为例，只需三个压缩映射：</p><p><span class="math display">\[\begin{aligned}f_1(x,y) &amp;= (x/2, y/2),\\f_2(x,y) &amp;= (x/2, y/2) + (0, 1/2),\\f_3(x,y) &amp;= (x/2, y/2) + (1/2, 0).\\\end{aligned}\]</span></p><p>这三个压缩映射的压缩比都是 1/2。初始的紧集 <span class="math inline">\(K_0\)</span> 可以随便选，比如就取为一个圆：</p><p><span class="math display">\[K_0 =\img{/images/ifs/dot0.svg}{-1.75em}{}{4em}.\]</span></p><p>在第 1次迭代后，它被压缩成三个更小的版本，分别放到三角形的三个角落上：</p><p><span class="math display">\[K_1 = f_1(K_0)\cup f_2(K_0)\cup f_3(K_0)= \img{/images/ifs/dot1.svg}{-1.75em}{}{4em}.\]</span></p><p>在第 2 次迭代后，结果是</p><p><span class="math display">\[K_2 = f_1(K_1)\cup f_2(K_1)\cup f_3(K_1)= \img{/images/ifs/dot2.svg}{-1.75em}{}{4em}.\]</span></p><p>第 3 次迭代：</p><p><span class="math display">\[K_3 = f_1(K_2)\cup f_2(K_2)\cup f_3(K_2)= \img{/images/ifs/dot3.svg}{-1.75em}{}{4em}.\]</span></p><p>不断重复这个分裂并压缩的过程，当迭代次数趋于无穷，就得到了 Sierpiński分形：</p><p><span class="math display">\[\lim_{n\to\infty} K_n = A = f_1(A)\cupf_2(A)\cup f_3(A) =\img{/images/ifs/dot6.svg}{-1.75em}{}{4em}.\]</span></p><p>你可以很容易看出来为什么初始紧集的选择是不重要的：因为在压缩的过程中，任何紧集都会逐渐缩小到一个单点，所以<span class="math inline">\(K_0\)</span> 甚至取成一个点也是可以的。</p><p>压缩映射是无穷无尽的，所以 IFS分形也是无穷无尽的。为了避免选择困难，我们一般只使用仿射和球反演这两种变换，通过组合它们来实现空间压缩。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这里的球反演变换是指将单位球的外部反演到内部，单位球内部保持不动的变换。虽然在单位球内部它并不压缩距离，但是只要和其它变换适当组合，使得最终的复合变换是压缩的，就仍然可以得到分形。</p></div><p>然而，上面的构造方式在编程中是非常麻烦的：每次迭代时我们都需要维护当前已经生成的集合<span class="math inline">\(f_1(K_n),\ldots,f_N(K_n)\)</span>，随着<span class="math inline">\(n\)</span> 的增加这个集合是指数增长的，在CPU 上对不太大的 <span class="math inline">\(n\)</span>或许勉强可以处理，但是在 GPU上就不现实了。我们后面会介绍，在着色器中绘制 IFS 是通过 <span class="math inline">\(F\)</span> 的逆映射 <span class="math inline">\(F^{-1}\)</span> 来实现的，<span class="math inline">\(F^{-1}\)</span>就是本文开头提到的「折纸」操作，它是一种「空间折叠」操作，可以通过”串联”若干折叠函数来实现。就像古代的炼丹师会通过反复调整原料配方来寻找效果最佳的丹药一样，设计分形也可以通过调整<span class="math inline">\(F^{-1}\)</span>中的折叠函数，并观察屏幕上显示的效果来实现。所以你根本无需关心 <span class="math inline">\(f_i\)</span> 是什么！</p><h1 id="轨道着色">轨道着色</h1><p>虽然分形背后的原理不过是IFS，但是要想把分形画得惊艳，还少不了一个秘密配方，这就是轨道着色。绝大多数惊艳的分形作品都是通过轨道着色技巧来上色的。</p><p>我们希望给分形染上漂亮的颜色，这个染色应该满足如下的条件：</p><ol type="1"><li>在分形上颜色是连续变化的；</li><li>在分形和非分形的交界处（即 <span class="math inline">\(A\)</span> 和<span class="math inline">\(A^c\)</span>的边界上）颜色应该是不连续的，从而产生泾渭分明的效果。</li></ol><p>做到这一点并不难，但是需要在每一次迭代时考虑当前点的位置信息，这就是所谓的轨道着色。</p><p>我们首先取一个底色，比如说<code>color=vec3(0)</code>，在每一次迭代中，根据当前位置 <code>p</code>生成一个颜色，并以一定的权重与 <code>color</code> 混合。理论上颜色的 rgb的取值范围应该是 <span class="math inline">\([0,1]\)</span>，但是多数情况下我们要放宽到 <span class="math inline">\([-1,1]\)</span>之间，即颜色可以增加也可以减少。否则如果颜色只增不减的话，那么多次迭代以后rgb 值很可能会溢出，变成白色。此外，随着迭代次数 <span class="math inline">\(n\)</span> 的增加，<span class="math inline">\(F^n(K)\)</span> 越来越接近真实的分形 <span class="math inline">\(A\)</span>，后面加入的颜色的权重应该单调下降，以保证突出分形的细节。这也符合我们的生活直觉：想象一下，当一位画家作画时，在开始的时候他可以浓墨重彩地画一个轮廓，但是越到后面描绘更加精细的部分时，他就会换用更细的画笔，小心地蘸一点颜料。</p><p>根据 <code>p</code>生成颜色的着色方案无穷无尽，请随便发挥你的创造力。一般来说你需要反复试验各种不同的方案才能找到最合适的。下面的例子使用了一种非常流行的染色方案，它以<code>cos(vec3(0,1,2))</code> 作为底色，并根据当前时间<code>iTime</code> 以及坐标 <code>uv</code> 进行调整：</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 uv = fragCoord / iResolution.xy;    vec3 col = 0.5 + 0.45 * cos(vec3(0, 1, 2) + iTime + uv.yxy);    fragColor = vec4(col, 1.0);}"></div><h1 id="着色器编程基础">着色器编程基础</h1><p>我简单介绍一下着色器编程的基本概念。打开 shadertoy网站，点击右上角的<code>新建</code>按钮，你会看到一个 <a href="https://www.shadertoy.com/new">最简单的动画</a>：</p><p><img src="/images/ifs/shadertoy.png" class="fig" width="600"></p><p>左边的窗口是画布，显示渲染的结果；右边窗口是代码编辑器，你在这里书写着色器代码。写完以后，点击编辑器界面左下角的三角形（或者按下<code>Alt + Enter</code>）查看编译后的效果。</p><p>画布是由若干像素组成的，你需要根据每个像素的位置，即它的<code>fragCoord</code> 值指定一个颜色。这个过程是在<code>mainImage</code> 函数中实现的：</p><figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> mainImage(<span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> fragColor, <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> fragCoord);<br></code></pre></td></tr></tbody></table></figure><p>其中 <code>fragCoord</code> 是像素的位置，<code>fragColor</code>是需要设置的像素颜色。</p><p>现实生活中有一个很形象的例子可以帮你理解着色器编程：假设你是一场方阵表演的导演，所有演员排成一个方阵，每个演员可以改变自己衣服的颜色。你的任务是发出合适的指令让每个演员根据自己的位置计算出正确的颜色，使得整个方阵呈现出漂亮的图案。</p><p><img src="/images/ifs/array.png" class="fig" width="600"></p><p>如果你挨个对每个演员下指令，张三你应该显示红色，李四你应该显示蓝色，等等…对成千上万个演员，还不得把人累死？正确的做法是，你应该同时对所有演员发出相同的指令，比如：“每个人，计算自己和方阵中心的距离，小于10 米的显示红色，大于等于 10 米的显示黑色”。由于每个演员都是一个单独的GPU计算单元，他们可以根据你发出的同一条指令，在极短的时间内（毫秒级）分别计算出各自的颜色。计算完毕后，观众应该会看到一个红色的圆。这种基于相同指令并行计算的工作方式就是GPU 流水线的机制。</p><p>我们来试试在着色器中实际编程绘制这个圆的例子。为了方便起见，我们假设方阵的中心是原点，并尝试绘制一个以原点为中心，半径是0.5 的圆。这只需要三行代码：</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;    float d = length(p) - 0.5;    fragColor = d > 0.0 ? vec4(0, 0, 0, 1) : vec4(1, 0, 0, 1);}"></div><ul><li>首先，每个演员会根据自己在方阵中的位置<code>fragCoord</code>，计算自己的归一化坐标 <code>p</code>，使得<code>p</code> 的纵坐标 <code>p.y</code> 位于 <span class="math inline">\([-1,1]\)</span> 中；</li><li>然后，每个演员计算自己到以原点为中心、半径为 0.5 的圆的距离<code>d</code>。位于圆内部的演员得出的 <code>d</code>是负数，圆外部的演员得出的 <code>d</code> 是正数；</li><li>最终每个人根据 <code>d</code> 的符号来确定自己的颜色。</li></ul><p>你可以修改上面代码中的半径，颜色等参数，观察左边画布的变化来体会效果。</p><p>这个例子其实蕴含了 shader编程的一个非常核心的概念，即<strong>距离场</strong> (distancefield)。当我们想绘制某个图案时，我们通过计算像素到这个图案的距离来对像素进行着色。在绘制IFS分形时，我们同样需要计算像素到分形的距离，并根据距离值来确定像素的颜色。这一点在下节会详细介绍。</p><h1 id="空间折叠">空间折叠</h1><p>现在，我们已经介绍了所有必要的预备知识，可以正式介绍怎样在 GPU上实现折纸操作了。</p><p>上面讲到，在着色器里面画 IFS就是给每个像素指定一个颜色，这个颜色应该由像素对应的点到分形的距离来决定。假设像素对应空间中的点<span class="math inline">\(p\)</span>，初始紧集是 <span class="math inline">\(K\)</span>，我们用迭代 <span class="math inline">\(n\)</span> 次的结果 <span class="math inline">\(F^n(K)\)</span> 作为分形的近似，这里 <span class="math inline">\(n\)</span> 是某个常数，在绝大多数场景下 <span class="math inline">\(n=30\)</span> 就足够了。于是我们需要计算距离 <span class="math inline">\(d(p,F^n(K))\)</span>并根据这个距离值对像素染色。然而我们已经讲过，直接计算 <span class="math inline">\(d(p,F^n(K))\)</span> 是不可行的，因为如果有 <span class="math inline">\(N\)</span> 个不同的压缩映射 <span class="math inline">\(f_1,\ldots,f_N\)</span>，那么每次迭代后集合的数目会乘以<span class="math inline">\(N\)</span>，这是指数增长的，10次迭代后就会产生多达 <span class="math inline">\(N^{10}\)</span>个不同的集合。维护如此数量的集合会轻易耗尽内存，更不用说还要计算 <span class="math inline">\(p\)</span> 到每个集合的距离了。这该怎么办呢？</p><p>有个巧妙的做法可以绕过这个困难：我们把 <span class="math inline">\(d(p,F^n(K))\)</span> 中的 <span class="math inline">\(F^n\)</span> 挪到 <span class="math inline">\(p\)</span> 所在的一侧并取逆，转而计算 <span class="math inline">\(d(F^{-n}(p), K)\)</span>！实际上，如果 <span class="math inline">\(F\)</span>只包含旋转、平移、反射、缩放、球反演这些变换的话，<span class="math inline">\(d(p,F^n(K))\)</span> 和 <span class="math inline">\(d(F^{-n}(p), K)\)</span>之间存在非常简单的关系，我们可以通过计算后者来得到前者！这个关系的推导我放在<a href="#note-F" title="注释">注释</a>中介绍。现在，你暂时可以认为它俩是差不多的。</p><p>于是，在着色器编程时，我们需要将压缩迭代映射的步骤倒过来，采取相反的操作：即将逆映射<span class="math inline">\(F^{-1}\)</span> 迭代作用在 <span class="math inline">\(p\)</span> 上，执行足够的迭代次数后，通过计算距离<span class="math inline">\(d(F^{-n}(p), K)\)</span> 来给 <span class="math inline">\(p\)</span> 对应的像素上色。由于 <span class="math inline">\(F\)</span> 是“一对多” 的映射，所以 <span class="math inline">\(F^{-1}\)</span> 是 “多对一”的，反复迭代应用 <span class="math inline">\(F^{-1}\)</span>会把空间“折叠”。我们实际上是在这个折叠后的空间上作画。</p><p>总而言之，在着色器编程中我们真正需要的函数不是 <span class="math inline">\(F\)</span>，而是 <span class="math inline">\(F^{-1}\)</span>！</p><p>这个先折叠后画图的操作，和剪纸艺术是一模一样的：</p><figure><img src="/images/ifs/papercut.jpg" width="480" alt="在剪纸过程中，首先把纸张反复折叠，然后在折叠后的纸张上画出某个特定的图形，沿着这个图形裁剪，再将纸张展开得到的就是美丽的图案。展开纸张的操作对应迭代映射 F，它把一个初始的紧集铺开到空间中变成分形；折叠纸张的操作对应 F^{-1}，它把分形折叠回最初的紧集。"><figcaption aria-hidden="true">在剪纸过程中，首先把纸张反复折叠，然后在折叠后的纸张上画出某个特定的图形，沿着这个图形裁剪，再将纸张展开得到的就是美丽的图案。<strong>展开</strong>纸张的操作对应迭代映射<span class="math inline">\(F\)</span>，它把一个初始的紧集铺开到空间中变成分形；<strong>折叠</strong>纸张的操作对应<span class="math inline">\(F^{-1}\)</span>，它把分形折叠回最初的紧集。</figcaption></figure><p>在设置 <span class="math inline">\(F^{-1}\)</span>的时候，我们完全不必关心每个 <span class="math inline">\(f_i\)</span>是什么，我们需要的只是准备一些折叠函数，然后将它们组合起来得到 <span class="math inline">\(F^{-1}\)</span>。</p><p>如果你去看那些分形作品的代码的话，会发现它们几乎都在 <span class="math inline">\(F^{-1}\)</span> 中使用了 <code>abs</code>函数。这个函数是最简单的空间折叠函数，它会把整个空间折叠到第一象限。进一步，再叠加关于平面/球面的反射可以产生出更复杂的折叠。</p><p>在下面的例子中，我们首先用 <code>p = abs(p)</code>将整个空间折叠到第一象限，这相当于折纸的时候将纸对折两次；然后只要在第一象限中剪出一个圆，就可以同时在其它象限自动得到另外三个圆：</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;    p = abs(p); //折叠    float d = length(p - vec2(0.5)) - 0.3; // 中心在 (0.5, 0.5), 半径为 0.3 的圆    d = smoothstep(-0.005, 0.005, d); // 平滑一下边缘    vec3 col = mix(vec3(0), vec3(0.9), d); //染色    fragColor = vec4(col, 1);}"></div><p>或者还用方阵的例子作比喻，相当于你对方阵下的指令是：“每个人，首先把自己的y 坐标归一化到 [-1, 1] 区间，然后计算自己坐标的绝对值，再计算到以 (0.5,0.5)，半径为 0.3 的圆的距离，最后根据距离值显示颜色”。如果把整个方阵记作<span class="math inline">\(A\)</span> 的话，取绝对值操作以后，<span class="math inline">\(A\)</span> 变成了 2x2 分块矩阵： <span class="math display">\[A = \begin{pmatrix}B&amp;B\\B&amp;B\end{pmatrix}.\]</span> 之后的计算对这 4 个 子方阵 <span class="math inline">\(B\)</span> 都是一样的，所以你会同时看到 4个圆。</p><p>这就体现出空间折叠操作的优势来了：你不需要在每个象限分别画一个圆，相反，你可以通过折叠象限，只画一个圆！</p><hr><div id="note-F" class="statement sta_d_p_f_n_k_____d_f___n__p___k_______ definition unnumbered"><p><span class="statement-heading"><span class="statement-label"><span class="math inline">\(d(p,F^n(K))\)</span> 和 <span class="math inline">\(d(F^{-n}(p), K)\)</span>之间的关系</span>：</span><span class="statement-spah"> </span><br></p><p>如果 <span class="math inline">\(F\)</span>是平移、旋转、反射这样的保持 Euclidean 距离不变的刚体运动，那么自然有<span class="math display">\[d(p, F(K)) = d(F^{-1}(p), K).\]</span></p><p>如果 <span class="math inline">\(F\)</span> 是一个缩放变换，比如<span class="math inline">\(F(x) = x/s\,(s&gt;1)\)</span>，那么 <span class="math display">\[d(p, F(K)) = d(p, 1/s\cdot K) = 1/s\cdot d(s\cdotp, K) = 1/s\cdot d(F^{-1}(p), K).\]</span>即我们要对折叠以后算出来的距离值再除以 <span class="math inline">\(s\)</span>。</p><p>既然每次迭代 <span class="math inline">\(F\)</span> 以比例 <span class="math inline">\(1/s\)</span> 缩小，所以用 <span class="math inline">\(F^{-1}\)</span> 迭代 <span class="math inline">\(n\)</span> 次以后累积放大的比例就是 <span class="math inline">\(s^n\)</span>，我们要将 <span class="math inline">\(d(F^{-n}(p), K)\)</span> 再除以 <span class="math inline">\(s^n\)</span> 才是最终正确的距离值。</p><p>对球的反演变换，甚至更一般的变换，我们可以通过计算 <span class="math inline">\(F^{-1}\)</span> 在 <span class="math inline">\(p\)</span> 处 Jacobian 矩阵的行列式的绝对值，作为<span class="math inline">\(p\)</span>处缩放的近似。把迭代过程中所有这些行列式的绝对值相乘，并对最后得到的<span class="math inline">\(d(F^{-n}(p), K)\)</span>再除以这个乘积，就可以作为 <span class="math inline">\(d(p,F(K))\)</span> 的近似。</p></div><h1 id="实战演示">实战演示</h1><p>我以 Shadertoy 上一个混淆过的 <a href="https://www.shadertoy.com/view/WlGyWK">作品</a>为例子来完整展示上面的理论。下面是重新改写后的 <a href="https://www.shadertoy.com/view/l3cXR7">版本</a>，我在注释中解释了每一步的含义：</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/l3cXR7?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe>]]></content>
      
      
      <categories>
          
          <category> Shadertoy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>咖啡杯中的焦散线</title>
      <link href="/envelope-and-caustics/"/>
      <url>/envelope-and-caustics/</url>
      
        <content type="html"><![CDATA[<p>春节的晚上，外面鞭炮喧天，家人在看电视，我躲在屋里看数学，还是挺惬意的。</p><p>我最近一直在翻 <a href="https://johncarlosbaez.wordpress.com">JohnBaez</a> 和 <a href="https://www.gregegan.net">Greg Egan</a>的博客。John Baez是一位在科普方面非常高产的数学家，写过不计其数的科普文章。读他的文章非常让人享受，因为他总是从直观的例子入手，一步步启发读者，展开到更高级的数学。GregEgan是澳大利亚的一位非常高产的科幻小说作家，有不少作品已经被国内引入。他的小说属于硬科幻风格，而且是非常硬的那种。他也有不少有趣的<a href="https://www.gregegan.net/SCIENCE/Science.html">博客文章</a>。不过与John Baez 不同的是，Greg Egan的文章不太会去兼顾不同水平的读者，对我来说，要看懂他在说什么经常不是一件容易的事情。</p><p>John Baez 博客上有一个系列 <a href="https://johncarlosbaez.wordpress.com/2012/08/31/rolling-circles-and-balls-part-1/">Rollingcircles and balls</a> 讨论了圆的外摆线和焦散，Greg Egan 也有一篇 <a href="https://www.gregegan.net/SCIENCE/Catacaustics/Catacaustics.html">文章</a>更深入的讨论了曲线的焦散。这个话题非常有意思，我也一时手痒写代码实验了一番并记录在此。</p><span id="more"></span><h1 id="pov-ray-光学实验">POV-Ray 光学实验</h1><p>你肯定见过这个物理现象：当光线照在咖啡杯的内壁上时，会在杯子底部形成一道明亮的曲线，术语叫做焦散(caustic)。</p><p><img src="/images/caustics/cup.jpg" class="fig" width="400"></p><p>形成焦散的原因是，光线在杯子内壁反射以后，光子的分布是不均匀的，某些区域经过的光子特别密集，所以亮度就更高。</p><p>焦散是一条曲线，它和所有的反射光线相切。用数学的术语，焦散是所有反射光线的<a href="https://en.wikipedia.org/wiki/Envelope_(mathematics)">包络</a>(envelope)。焦散的具体形状和杯子的形状、光源的位置都有关。如果杯子是圆形的，则当光源是点光源且恰好位于杯子边缘上某一点时，焦散是<a href="https://en.wikipedia.org/wiki/Cardioid">心脏线</a>(cardioid)；当光源位于无穷远时（这时可以视作平行光源），焦散是 <a href="https://en.wikipedia.org/wiki/Nephroid">肾形线</a>(nephroid)。一般情况下焦散的形状介于心脏线和肾形线之间。</p><p>最令人称奇的是下面这个事实：如果我们进一步，用一个心脏线形状的杯子，并把光源放在它的尖点上，你猜我们会得到什么？</p><p>没错，是一条肾形线！</p><p>我写了一个 <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/catacaustic">POV-Ray脚本</a> 模拟来验证这一现象：</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr><td style="text-align: center;">圆形杯子给出心脏线</td><td style="text-align: center;">心脏线杯子给出肾形线</td></tr><tr><td style="text-align: center;"><img src="/images/caustics/caustics_cardioid.png" class="fig" width="400"></td><td style="text-align: center;"><img src="/images/caustics/caustics_nephroid.png" class="fig" width="400"></td></tr></tbody></table><p>这太奇妙了！圆、心脏线、肾形线之间似乎存在着某种深刻的联系。事实上，心脏线和肾形线都属于一个优美的几何曲线家族，叫做<a href="https://en.wikipedia.org/wiki/Epicycloid">外摆线</a>。它们都是由一个小圆沿着一个大圆外侧滚动时，小圆上某一点的运动轨迹。它们的区别仅仅在于两圆的半径之比不同：</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr><td style="text-align: center;">心脏线</td><td style="text-align: center;">肾形线</td></tr><tr><td style="text-align: center;"><video src="/images/caustics/cardioid.mp4" controls=""></video></td><td style="text-align: center;"><video src="/images/caustics/nephroid.mp4" controls=""></video></td></tr></tbody></table><p>这就引出了一个很自然的问题：既然圆生成了心脏线，心脏线又生成了肾形线，那我们用肾形线杯子在它的尖点放一个光源，是不是会得到下一个外摆线呢？</p><p>唉，根据 Greg Egan的实验，这个漂亮的猜想似乎并不成立。看来数学的规律有时并不像我们希望的那样无限延伸。</p><h1 id="求解参数曲线的焦散">求解参数曲线的焦散</h1><p>好了，欣赏完这些漂亮的图片，你可能会好奇，我们能用数学精确地证明这一切吗？</p><p>当然可以！这一节我们来介绍怎样计算一般的参数曲线 <span class="math inline">\(\mathbf{c}(t)=(x(t),y(t))\)</span> 的焦散。</p><p>设点光源的位置是 <span class="math inline">\((a,b)\)</span>，对于曲线上的一点 <span class="math inline">\((x,y)\)</span>，该点处入射光线的方向是 <span class="math display">\[\mathbf{l}=(x-a,y-b).\]</span> 这里不需要把 <span class="math inline">\(\mathbf{l}\)</span>单位化，因为我们列方程的时候只需要光线的方向，并不在乎长度。</p><p>接着，我们需要曲线在该点的法向量。如果你还记得微积分，法向量可以这样计算：<span class="math display">\[\mathbf{n}=\frac{(-y',x')}{\sqrt{(x')^2+(y')^2}}=\frac{(-y',x')}{|\mathbf{c}'|}.\]</span> 这里我们用 <span class="math inline">\(x',y'\)</span> 表示 <span class="math inline">\(x,y\)</span> 关于 <span class="math inline">\(t\)</span> 的导数。</p><p>根据反射定律，反射光线的方向 <span class="math inline">\(\mathbf{r}\)</span> 由下面的公式给出： <span class="math display">\[\mathbf{r}= \mathbf{l}- 2(\mathbf{l}\cdot\mathbf{n})\mathbf{n}.\]</span>现在，焦散是所有这些反射光线的包络。求解包络线是一个经典的微积分问题。</p><p>设 <span class="math inline">\((X,Y)\)</span>是反射光线上的任一点，由于 <span class="math inline">\((x,y)\)</span>是反射光线的起点，所以 <span class="math inline">\((X-x,Y-y)\)</span> 与<span class="math inline">\(\mathbf{r}\)</span> 平行。记 <span class="math inline">\(\mathbf{r}=(r_x,r_y)\)</span>，则 <span class="math inline">\((X-x,Y-y)\)</span> 与 <span class="math inline">\((-r_y, r_x)\)</span> 垂直，即 <span class="math display">\[(X-x, Y-y)\cdot(-r_y, r_x)=0.\]</span>不要急着把这个式子展开！保持它的矩阵形式会更方便。记 <span class="math display">\[F(X,Y,t)=(X-x, Y-y)\cdot(-r_y, r_x),\]</span>则我们得到了反射光线 <span class="math inline">\((X(t), Y(t))\)</span>满足的曲线族方程 <span class="math inline">\(F(X,Y,t)=0\)</span>。要求这族曲线的包络，我们需要解下面这个方程组：<span class="math display">\[\begin{align}F(X,Y,t)=0,\\\frac{\partialF}{\partial t}F(X,Y,t)=0.\end{align}\]</span> 也就是 <span class="math display">\[\begin{align}(X-x, Y-y)\cdot(-r_y,r_x)&amp;=0,\\-(x',y')\cdot(-r_y, r_x) +(X-x,Y-y)\cdot(-r_y', r_x') &amp;=0.\end{align}\]</span>然后解出 <span class="math inline">\(X,Y\)</span> 得到。</p><p>如果你还记得 2x2矩阵的逆公式的话，这个方程组其实可以目视写出解来。我们把它写成</p><p><span class="math display">\[\begin{pmatrix}-r_y &amp; r_x\\-r_y'&amp;r_x'\end{pmatrix}\cdot\begin{pmatrix}X-x\\Y-y\end{pmatrix}=\begin{pmatrix}0\\r_xy'-r_yx'\end{pmatrix}.\]</span> 于是不难解出 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix} +\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span></p><p>让我们请出值得信赖的计算伙伴 <code>sympy</code>来验证一下。假设圆心是原点，半径为 1，光源在 <span class="math inline">\((1,0)\)</span> 处。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>t, X, Y = symbols(<span class="hljs-string">"t X Y"</span>)<br>C = Matrix([cos(t), sin(t)]) <span class="hljs-comment"># curve</span><br>light = Matrix([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]) <span class="hljs-comment"># light source</span><br>l = C - light <span class="hljs-comment"># incident ray</span><br>dx, dy = diff(C, t)<br>n = Matrix([dy, -dx]) <span class="hljs-comment"># normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n)) <span class="hljs-comment"># reflected ray</span><br>F = (Y - y) * r[<span class="hljs-number">0</span>] - (X - x) * r[<span class="hljs-number">1</span>]<br>dF = diff(F, t)<br>result = solve((F, dF), X, Y) <span class="hljs-comment"># solve the envelope</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f"X(t)=<span class="hljs-subst">{trigsimp(result[X], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f"Y(t)=<span class="hljs-subst">{trigsimp(result[Y], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 给出的结果正是我们期待的心脏线参数方程：</p><p><span class="math display">\[\left\{\begin{align}x(t)&amp;=\frac{\cos(2t) +2\cos(t)}{3},\\ y(t)&amp;=\frac{\sin(2t) +2\sin(t)}{3}.\end{align}\right.\]</span></p><p>使用这个参数表示，我们继续计算当光源放在心脏线的尖点，即 <span class="math inline">\(t=\pi\)</span> 对应的点 <span class="math inline">\((-\frac{1}{3},0)\)</span> 时得到的焦散：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>t, X, Y = symbols(<span class="hljs-string">"t X Y"</span>)<br>C = Matrix([(<span class="hljs-number">2</span>*cos(t) + cos(<span class="hljs-number">2</span>*t)) / <span class="hljs-number">3</span>, (<span class="hljs-number">2</span>*sin(t) + sin(<span class="hljs-number">2</span>*t)) / <span class="hljs-number">3</span>])<br>light = Matrix([S(<span class="hljs-string">'-1/3'</span>, evaluate=<span class="hljs-literal">False</span>), <span class="hljs-number">0</span>])<br>l = C - light <span class="hljs-comment"># incident ray</span><br>dx, dy = diff(C, t)<br>n = Matrix([dy, -dx]) <span class="hljs-comment"># normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n)) <span class="hljs-comment"># reflected ray</span><br>F = (Y - y) * r[<span class="hljs-number">0</span>] - (X - x) * r[<span class="hljs-number">1</span>]<br>dF = diff(F, t)<br>result = solve((F, dF), X, Y) <span class="hljs-comment"># solve the envelope</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f"X(t)=<span class="hljs-subst">{trigsimp(result[X], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f"Y(t)=<span class="hljs-subst">{trigsimp(result[Y], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 很快算出了正确的结果：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X(t)=sin(t)*sin(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span> + cos(t)/<span class="hljs-number">3</span><br>Y(t)=-sin(t)*cos(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span> + sin(t)/<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>不难验证</p><p><span class="math display">\[\begin{align}\frac{\sin(t)\sin(2t) +\cos(t)}{3}&amp;=\frac{3\cos(t) - \cos(3t)}{6},\\ \frac{-\sin(t)\cos(2t)+ \sin(t)}{3}&amp;=\frac{3\sin(t) -\sin(3t)}{6}.\end{align}\]</span></p><p>这正是 <a href="https://en.wikipedia.org/wiki/Nephroid#Parametric">维基百科</a>中所列的肾形线的参数方程中取 <span class="math inline">\(a=1/6\)</span>的结果。</p><p>把上面的曲线画出来是这样的：</p><p><img src="/images/caustics/caustics_matplotlib.svg" class="fig" width="400"></p><h1 id="求解多项式曲线的焦散">求解多项式曲线的焦散</h1><p>很多时候曲线的方程是通过隐函数 <span class="math inline">\(P(x,y)=0\)</span> 的形式给出的，其中 <span class="math inline">\(P(x,y)\)</span> 是关于两个变元 <span class="math inline">\(x,y\)</span>的多项式。这样的曲线叫做平面代数曲线。这时求解焦散要用到 Gröbner基的工具。</p><p>在参数方程的情形，我们已经推导出了焦散的显式解</p><p><span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix} +\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span></p><p>其中 <span class="math inline">\(x,y,r_x,r_y\)</span> 都是关于 <span class="math inline">\(t\)</span>的函数，它们的导数也是可计算的，所以可以算出 <span class="math inline">\((X,Y)\)</span> 来。</p><p>但是在隐函数的情形，我们没有 <span class="math inline">\(x,y\)</span>的某种关于 <span class="math inline">\(t\)</span>的表达式。不过没关系，我们先假设有这样的参数表达式，看看能得到什么结论。设<span class="math inline">\(x=x(t),y=y(t)\)</span> 是某个参变元 <span class="math inline">\(t\)</span> 的函数，在 <span class="math inline">\(P(x,y)=0\)</span> 两边对 <span class="math inline">\(t\)</span> 求导可得 <span class="math display">\[\frac{\partial P}{\partial t}=\frac{\partialP}{\partial x}x'(t) + \frac{\partial P}{\partialy}y'(t)=0.\]</span> 记 <span class="math inline">\(k=-\frac{\partialP}{\partial x}/\frac{\partial P}{\partial y}\)</span>，则 <span class="math inline">\(y'(t)=kx'(t)\)</span>。</p><p>对反射光线 <span class="math inline">\(\mathbf{r}\)</span> 的两个分量<span class="math inline">\(r_x,r_y\)</span> 也分别使用链式求导，我们有<span class="math display">\[\begin{align}\frac{\partial r_x}{\partialt}&amp;=\frac{\partial r_x}{\partial x}x'(t) + \frac{\partialr_x}{\partial y}y'(t),\\\frac{\partial r_y}{\partial t}&amp;=\frac{\partial r_y}{\partialx}x'(t) + \frac{\partial r_y}{\partialy}y'(t).\end{align}\]</span> 于是我们发现比值 <span class="math display">\[\begin{align}\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}&amp;=\frac{r_xk-r_y}{r_y(\frac{\partialr_x}{\partial x}+\frac{\partial r_x}{\partial y}k)-r_x(\frac{\partialr_y}{\partial x} + \frac{\partial r_y}{\partial y}k)}\\&amp;=-\frac{r_x\frac{\partial P}{\partial x}+r_y\frac{\partialP}{\partial y}}{r_y(\frac{\partial r_x}{\partial x}\frac{\partialP}{\partial y}-\frac{\partial r_x}{\partial y}\frac{\partial P}{\partialx})-r_x(\frac{\partial r_y}{\partial x}\frac{\partial P}{\partial y} -\frac{\partial r_y}{\partial y}\frac{\partial P}{\partial x})}.\end{align}\]</span> 变成了一个不需要显式用到 <span class="math inline">\(t\)</span> 的量，即变量 <span class="math inline">\(t\)</span> “消掉”了。代入上面焦散的表达式中，我们得到 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix}-\frac{r_x\frac{\partialP}{\partial x}+r_y\frac{\partial P}{\partial y}}{r_y(\frac{\partialr_x}{\partial x}\frac{\partial P}{\partial y}-\frac{\partialr_x}{\partial y}\frac{\partial P}{\partial x})-r_x(\frac{\partialr_y}{\partial x}\frac{\partial P}{\partial y} - \frac{\partialr_y}{\partial y}\frac{\partial P}{\partial x})}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span> 这个式子还可以再简化一点：注意到曲线在 <span class="math inline">\((x,y)\)</span> 处的法向量由 <span class="math inline">\(\mathbf{n}=\frac{\nabla P}{|\nabla P|}\)</span>给出，其中 <span class="math inline">\(\nabla P=(\frac{\partialP}{\partial x},\frac{\partial P}{\partial y})\)</span>。于是由 <span class="math display">\[\mathbf{r}= \mathbf{l}- 2(\mathbf{l}\cdot\mathbf{n})\mathbf{n}\]</span> 两边与 <span class="math inline">\(\nablaP\)</span> 作内积，可得 <span class="math display">\[\mathbf{r}\cdot\nabla P=-\mathbf{l}\cdot \nabla P.\]</span> 从而 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix}+\frac{\mathbf{l}\cdot\nablaP}{r_y(\frac{\partial r_x}{\partial x}\frac{\partial P}{\partialy}-\frac{\partial r_x}{\partial y}\frac{\partial P}{\partialx})-r_x(\frac{\partial r_y}{\partial x}\frac{\partial P}{\partial y} -\frac{\partial r_y}{\partial y}\frac{\partial P}{\partialx})}\begin{pmatrix}r_x\\ r_y\end{pmatrix}.\]</span></p><p>这是四个变量 <span class="math inline">\(x,y,X,Y\)</span>满足的两个方程，形如 <span class="math inline">\(F(X,x,y)=0\)</span> 和<span class="math inline">\(G(Y,x,y)=0\)</span>。记住我们还有已知的方程<span class="math inline">\(P(x,y)=0\)</span>。为了从这三个方程中消掉<span class="math inline">\(x,y\)</span>，得到一个仅包含 <span class="math inline">\((X,Y)\)</span> 的表达式，我们可以尝试用 <a href="https://en.wikipedia.org/wiki/Gr%C3%B6bner_basis">Gröbnerbasis</a> 方法。Gröbner 基方法会把多项式方程组 <span class="math display">\[F=G=P=0\]</span> 转化为一组等价的新方程组 <span class="math display">\[g_1=g_2=\cdots=g_m=0.\]</span>即它们有完全相同的解集。</p><p><span class="math inline">\(\{g_1,\ldots,g_m\}\)</span> 是 <span class="math inline">\(F,G,P\)</span> 在多项式环 <span class="math inline">\(\mathbb{R}[x,y,X,Y]\)</span> 中生成的理想 <span class="math inline">\(I=\langle F,G,P\rangle\)</span>的一组生成元，<span class="math inline">\(\{g_1,\ldots,g_m\}\)</span>叫做 <span class="math inline">\(I\)</span> 的约化的 Gröbner基。在字典序 <span class="math inline">\(x\succ y\succ X\succ Y\)</span>下，约化的 Gröbner 基会有一个好的属性，即从 <span class="math inline">\(g_1\)</span> 到 <span class="math inline">\(g_m\)</span>，其中的变元会按照从 <span class="math inline">\(x\to y\to X\to Y\)</span>的先后顺序被消除掉。注意这是个不太严格的说法，我们并不是总能消掉顺序靠前的变元，但是如果消除发生的话，它就会按照这个顺序来。这样我们就可以执行类似高斯消元法中的回代操作，从而新方程组的求解会更加简单。</p><p>我们来用 <code>sympy</code> 实验一下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>x, y, X, Y = symbols(<span class="hljs-string">"x y X Y"</span>)<br>P = x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>dx = diff(P, x)  <span class="hljs-comment"># gradient of P</span><br>dy = diff(P, y)<br>curve = Matrix([x, y])<br>light_source = Matrix([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>l = curve - light_source  <span class="hljs-comment"># the incident ray</span><br>n = Matrix([dx, dy])  <span class="hljs-comment"># the normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n))  <span class="hljs-comment"># the reflected ray</span><br>rx, ry = r<br>dxrx = diff(rx, x)<br>dyrx = diff(rx, y)<br>dxry = diff(ry, x)<br>dyry = diff(ry, y)<br>denominator = ry * (dxrx * dy - dyrx * dx) - rx * (dxry * dy - dyry * dx)<br>nominator = dx * l[<span class="hljs-number">0</span>] + dy * l[<span class="hljs-number">1</span>]<br>F = (X - x) * denominator - nominator * rx<br>G = (Y - y) * denominator - nominator * ry<br>eqs = [eq.as_numer_denom()[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> eq <span class="hljs-keyword">in</span> [F, G, P]]<br>gb = groebner(eqs, [x, y, X, Y])<br><span class="hljs-built_in">print</span>(gb)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 给出的结果的最后一项是</p><p><span class="math display">\[27 X^{4} y^{2} + 54 X^{2} Y^{2} y^{2} -18 X^{2} y^{2} - 8 X y^{2} + 27 Y^{4} y^{2} - 18 Y^{2} y^{2} -y^{2}.\]</span></p><p><span class="math inline">\(x\)</span> 被消掉了！原方程组 <span class="math inline">\(F=G=P\)</span>的解必然是上面这个方程的解的子集。观察它的每一项都带有一个 <span class="math inline">\(y^2\)</span>，这显然不是我们要的解。把 <span class="math inline">\(y^2\)</span> 去掉，剩下的因子</p><p><span class="math display">\[27X^{4}+54X^{2}Y^{2}-18X^{2} -8X +27Y^{4}-18Y^{2}-1=0.\]</span></p><p>就是心脏线的隐函数表示。不信？在 <a href="https://www.desmos.com/geometry/vtjbq3ete1">Desmos</a>里面画出来看看！</p><p><img src="/images/caustics/desmos_cardioid.png" class="fig" width="300"></p><h1 id="后记">后记</h1><p>这篇文章主要覆盖了 Greg Egan博文的前半部分，他的后半部分内容我觉得有点放飞自我，也没怎么仔细看。</p><p>虽然我们用 <code>sympy</code>的实验很成功，但注意并不是所有情况下都能得到焦散曲线（比如光源位于抛物线的焦点时，反射光线都是平行的），而且对复杂的曲线<code>sympy</code> 算起来非常慢。</p><p>我研究生的时候上过计算机代数的课程，当时用的教学软件是 Maple。Maple编程是很不方便的，所以我其实没有多少计算机代数的编程经验。我之前一直觉得<code>sympy</code>运行又慢，输出的表达式也不够简化，所以不太愿意用它。这次实验有点刷新我对<code>sympy</code>的认知。我还记得当时课程要求每人提交一份读书报告，我写的是 <a href="https://link.springer.com/book/10.1007/978-3-319-16721-3">Ideals,Varieties, and Algorithms</a> 的笔记，但毕业多年以来这还是我第一次用到Gröbner 基！</p><p>我写这篇文章的时候正好临近情人节，所以我在想有没有什么曲线的焦散能给出<a href="https://www.desmos.com/geometry/ngdpq0zrei">爱心曲线</a>：</p><p><img src="/images/caustics/heart.png" class="fig" width="300"></p><p>于是我找到了 <a href="https://www.tandfonline.com/doi/full/10.1080/00029890.2020.1722019">这篇文章</a>。不过看起来里面给出的结论计算量很大，很难用在爱心线上（也许是我错了）。</p>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Möbius 变换与球的刚体运动</title>
      <link href="/mobius-ball-rigid-motion/"/>
      <url>/mobius-ball-rigid-motion/</url>
      
        <content type="html"><![CDATA[<p>五一期间我写了一个 <a href="https://www.shadertoy.com/view/fljfRm">shadertoy 小动画</a>，演示Möbius 变换与球的刚体运动之间的关系：</p><span id="more"></span><div style="display:flex; justify-content:center;"><p><object data="/code/mobius_ball.svg" type="image/svg+xml" style="width:100%; aspect-ratio: 600/360;"></object></p></div><p>动画的名字叫做 Möbius transformation revealed，源自 Douglas N. Arnold和 Jonathan Rogness 于 2007 年发布的 <a href="https://www-users.cse.umn.edu/~arnold/moebius/">同名视频</a>。这是一个很有名的视频，它表达的核心思想是，扩充复平面<span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的 Möbius变换可以由球在三维空间中的刚体运动给出：</p><ol type="1"><li>我们称一个球 <span class="math inline">\(S\)</span>是<strong>容许</strong>的，如果 <span class="math inline">\(S\)</span>的最高点，也就是北极点位于半空间 <span class="math inline">\(\{z&gt;0\}\)</span> 中。</li><li>取任何一个可容许的球 <span class="math inline">\(S\)</span>，将<span class="math inline">\(\overline{\mathbb{C}}\)</span>在逆球极投影下对应到 <span class="math inline">\(S\)</span>的球面上。</li><li>对 <span class="math inline">\(S\)</span> 作刚体变换 （平移和旋转）<span class="math inline">\(S\to T(S)\)</span>，使得 <span class="math inline">\(T(S)\)</span> 也是一个容许的球，即 <span class="math inline">\(T(S)\)</span> 的最高点也在半空间 <span class="math inline">\(\{z&gt;0\}\)</span> 中。</li><li>将 <span class="math inline">\(T(S)\)</span>的表面通过球极投影再映射回 <span class="math inline">\(\overline{\mathbb{C}}\)</span>，我们就得到了一个<span class="math inline">\(\overline{\mathbb{C}}\to\overline{\mathbb{C}}\)</span>的变换，此变换是一个 Möbius 变换，且所有 Möbius变换都可以通过此种方式得到。</li></ol><p>整个过程如下所示：</p><p><span class="math display">\[\underbrace{\overline{\mathbb{C}}\xrightarrow{\text{inversestereographic projection}} S\xrightarrow{\text{rigid motion}}T(S)\xrightarrow{\text{stereographicprojection}}\overline{\mathbb{C}}}_{\text{Möbiustransformation}}.\]</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>球极投影使用的北极点始终是球面的最高点。</p></div><p>详细的解释可以见原视频的解释 <a href="https://www-users.cse.umn.edu/~arnold/papers/moebius.pdf">文章</a>。但是从直观上理解也不难：</p><ul><li><p><span class="math inline">\(S\)</span> 在 <span class="math inline">\(xy\)</span> 平面内的平移给出的是 <span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的平移。<video src="/images/mobius/translation.mp4" height="300" controls=""></video></p></li><li><p><span class="math inline">\(S\)</span> 在 <span class="math inline">\(z\)</span> 方向上的平移给出的是 <span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的缩放。<video src="/images/mobius/scale.mp4" height="300" controls=""></video></p></li><li><p>保持 <span class="math inline">\(S\)</span>的北极点不动的旋转给出的是 <span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的旋转。<video src="/images/mobius/rotation.mp4" height="300" controls=""></video></p></li><li><p>绕 <span class="math inline">\(x\)</span> 轴旋转 180 度给出的是<span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的逆变换<span class="math inline">\(z\to 1/z\)</span>。<video src="/images/mobius/inversion.mp4" height="300" controls=""></video></p></li></ul><p>以上几种运动方式的复合可以给出可容许球的任何刚体运动，而任何 Möbius变换都是平移、缩放、旋转、逆变换的复合，所以 Möbius变换确实与可容许球体的刚体运动是对应的。</p><p>反过来对给定的 Möbius 变换 <span class="math inline">\(M\)</span>和容许的球 <span class="math inline">\(S\)</span>，当 <span class="math inline">\(S\)</span> 的初始位置确定以后，给出 <span class="math inline">\(M\)</span> 的刚体运动 <span class="math inline">\(T\)</span> 也是唯一确定的。证明见 <a href="https://scholar.rose-hulman.edu/cgi/viewcontent.cgi?article=1218&amp;context=rhumj">这个论文</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>遛狗中的数学：曲线的环绕数、Rouché 定理和开映射定理</title>
      <link href="/Rouche-theorem-winding-number/"/>
      <url>/Rouche-theorem-winding-number/</url>
      
        <content type="html"><![CDATA[<p>我写了一个 <a href="https://www.shadertoy.com/view/fdK3RD">shadertoy小动画</a>，演示 <span class="citation" data-cites="Needham1997">(<a href="#ref-Needham1997" role="doc-biblioref">Needham 1997</a>)</span>书中第 7 章 “Winding numbers and topology” 中的结论：</p><span id="more"></span><div class="statement simple plain unnumbered"><p>一个人和他的狗在公园里绕着一棵树散步，人和狗各自走的路径都是闭曲线，即经过一段时间后都会回到起点。如果人把狗绳抓的紧一些，使得整个过程中狗<strong>无法接触</strong>到树，则结束后人和狗绕着树走的圈数是一样的，这就是下面这个动画演示的：（树的位置是原点，用一个表盘标记）</p><div style="display:flex; justify-content:center;"><p><object data="/code/rouche.svg" type="image/svg+xml" style="width:90%; aspect-ratio: 600/360;"></object></p></div></div><p>对应的数学结论是：</p><blockquote><p>如果两条闭曲线 <span class="math inline">\(\gamma_1,\gamma_2\)</span>都不经过原点，且 <span class="math inline">\(\gamma_1\)</span>可以在不碰触到原点的前提下通过连续的形变变为 <span class="math inline">\(\gamma_2\)</span>（同伦），则 <span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点的环绕数相等。</p></blockquote><p>注意这个结论只要求 <span class="math inline">\(\gamma_1,\gamma_2\colon\[0,1]\to\mathbb{R}^2\)</span>是两条连续曲线，并不涉及解析性。因为环绕数和同伦都是拓扑概念，只涉及连续性。</p><p>但如果我们考虑 <span class="math inline">\(\gamma_1,\gamma_2\)</span>分别是单位圆 <span class="math inline">\(S^1\colon\\{z\in\mathbb{C}:|z|=1\}\)</span> 在两个解析函数 <span class="math inline">\(f,g\)</span>映射下的像，那事情就变得有趣多了。</p><p>首先 <a href="https://en.wikipedia.org/wiki/Argument_principle">幅角原理</a>给出了环绕数的另一种解释：</p><blockquote><p><span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点的环绕数分别等于 <span class="math inline">\(f,g\)</span> 在<span class="math inline">\(S^1\)</span> 内部的零点个数。</p></blockquote><p>进一步 <a href="https://en.wikipedia.org/wiki/Rouch%C3%A9%27s_theorem">Rouché定理</a> 给出了 <span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点有相同环绕数的充分条件：</p><blockquote><p>如果对任何 <span class="math inline">\(z\in S^1\)</span> 都有 <span class="math inline">\(|f(z)|&gt;|f(z)-g(z)|\)</span> 成立，则 <span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点有相同的环绕数。于是 <span class="math inline">\(f,g\)</span> 在<span class="math inline">\(S^1\)</span> 内部的零点个数也相等。</p></blockquote><p>想象人的位置是 <span class="math inline">\(f(z)\)</span>，狗的位置是<span class="math inline">\(g(z)\)</span>，由于绳子 <span class="math inline">\(l(z)=f(z)-g(z)\)</span> 的长度 <span class="math inline">\(|l(z)|\)</span> 始终小于人到原点的距离 <span class="math inline">\(|f(z)|\)</span>，所以狗始终够不到原点。</p><p>在动画中，左下角的圆周是 <span class="math inline">\(S^1\)</span>，右边红、绿两条路径分别是 <span class="math inline">\(f(S^1)\)</span> 和 <span class="math inline">\(g(S^1)\)</span>。这里的 <span class="math inline">\(f\)</span> 我取的形如 <span class="math display">\[f(z)=\frac{z-a}{1-\overline{a}z}\frac{z-b}{1-\overline{b}z}\frac{z-c}{1-\overline{c}z}(z-2-2i),\quad |a|,|b|,|c|&lt;1.\]</span> <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(S^1\)</span> 的内部有 3 个根（我用红点标出来了），在 <span class="math inline">\(S^1\)</span> 上不为0，在 <span class="math inline">\(S^1\)</span>外部有一个根（图中没有画）。<span class="math inline">\(f(z)\)</span>的前三个因子构成一个 Blaschke 乘积，它把 <span class="math inline">\(S^1\)</span> 的内部仍然映射为内部，把 <span class="math inline">\(S^1\)</span> 仍然映射为 <span class="math inline">\(S^1\)</span>，于是对任何 <span class="math inline">\(z\in S^1\)</span> 有 <span class="math display">\[|f(z)| = |z - 2 - 2i| \geq 2\sqrt{2} - 1,\quadz\in S^1.\]</span> 所以只要绳子 <span class="math inline">\(l(z)\)</span> 满足 <span class="math inline">\(|l(S^1)| &lt; 2\sqrt{2}-1\)</span>，则狗走的路径<span class="math inline">\(g(S^1)=f(S^1)+l(S^1)\)</span>就不可能接触到原点。我这里取了 <span class="math inline">\(l(z) =cz\)</span>，其中 <span class="math inline">\(c\)</span> 是一个小于<span class="math inline">\(2\sqrt{2}-1\)</span> 的正实数。</p><p>Needham 的书中还介绍了一个有意思的事实：</p><blockquote><p><span class="math inline">\(\gamma\)</span> 的环绕数在 <span class="math inline">\(\mathbb{C}\setminus\gamma\)</span>的每个连通分支上都是常数。也就是说，对不在 <span class="math inline">\(\gamma\)</span> 上的一点 <span class="math inline">\(z\)</span>，我们可以稍稍移动 <span class="math inline">\(z\)</span> 到另一个点 <span class="math inline">\(z'\)</span>，只要保持 <span class="math inline">\(z'\)</span> 仍然位于 <span class="math inline">\(z\)</span> 所在的连通分支内，<span class="math inline">\(\gamma\)</span> 关于 <span class="math inline">\(z\)</span> 和 <span class="math inline">\(z'\)</span> 的环绕数就一定相同。</p></blockquote><p>利用这个事实并结合幅角原理不难得出下面的结论：</p><div id="connected-component" class="unnumbered statement sta___ plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(\gamma\)</span>是一条简单闭曲线，内部围的区域为 <span class="math inline">\(\Omega\)</span>，<span class="math inline">\(f(z)\)</span> 是一个非常数的解析函数，<span class="math inline">\(f\)</span> 在包含 <span class="math inline">\(\gamma\)</span>的某个区域内解析。假设有两棵树分别位于 <span class="math inline">\(w_0,\,w_1\)</span> 两点，且人行走的路线 <span class="math inline">\(f(\gamma)\)</span> 到 <span class="math inline">\(w_0\)</span> 的距离始终大于两棵树之间的距离：<span class="math display">\[|f(z)-w_0| &gt; |w_0-w_1|,\quad\forallz\in\gamma.\]</span></p><figure><img src="/images/rouche/winding_number.svg" width="250" alt="注意两棵树位于 \mathbb{C}\setminus f(\gamma) 的同一个连通分支中"><figcaption aria-hidden="true">注意两棵树位于 <span class="math inline">\(\mathbb{C}\setminus f(\gamma)\)</span>的同一个连通分支中</figcaption></figure><p>则 <span class="math inline">\(f(\gamma)\)</span> 关于 <span class="math inline">\(w_0,w_1\)</span> 的环绕数相等，从而 <span class="math inline">\(w_0,w_1\)</span> 在 <span class="math inline">\(\gamma\)</span> 内部的原像个数相同： <span class="math display">\[\sharp\{z\in \Omega: f(z)=w_0\} = \sharp\{z\in\Omega: f(z)=w_1\}.\]</span></p></div><p><strong>证明</strong>：根据条件，从 <span class="math inline">\(w_0\)</span> 沿着线段 <span class="math inline">\([w_0,w_1]\)</span> 移动到 <span class="math inline">\(w_1\)</span> 的过程中始终不会碰触到曲线 <span class="math inline">\(f(\gamma)\)</span>，所以 <span class="math inline">\(w_0,w_1\)</span> 必然位于同一连通分支内。<span class="math inline">\(\blacksquare\)</span></p><p>利用此推论我们不难得出复分析中的 <a href="https://en.wikipedia.org/wiki/Open_mapping_theorem_(complex_analysis)">开映射定理</a>：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>如果 <span class="math inline">\(U\subseteq\mathbb{C}\)</span>是开集，<span class="math inline">\(f\colon\ U\to\mathbb{C}\)</span>是非常数的解析函数，则 <span class="math inline">\(f(U)\)</span>也是开集。</p></div><p><strong>证明</strong>：任取 <span class="math inline">\(z_0\inU\)</span>，记 <span class="math inline">\(w_0=f(z_0)\)</span>。由于<span class="math inline">\(f\)</span> 不是常数，所以 <span class="math inline">\(f(z)-w_0\)</span> 的零点都是孤立的。我们可以取<span class="math inline">\(z_0\)</span> 的一个充分小的闭圆盘 <span class="math inline">\(B_\delta=\{z\in U\mid |z-z_0|\leq\delta\}\)</span>使得 <span class="math inline">\(f(z)-w_0\)</span> 在 <span class="math inline">\(B_\delta\)</span> 中除了 <span class="math inline">\(z_0\)</span> 以外没有其它零点。特别地，<span class="math inline">\(f(z)-w_0\)</span> 在 <span class="math inline">\(B_\delta\)</span> 的边界 <span class="math inline">\(\gamma =\{|z-z_0|=\delta\}\)</span> 上恒不为0，从而 <span class="math inline">\(|f(z)-w_0|\)</span> 在 <span class="math inline">\(\gamma\)</span> 上有正的极小值 <span class="math inline">\(e\)</span>，即对任何 <span class="math inline">\(z\in\gamma\)</span> 有 <span class="math inline">\(|f(z)-w_0|\geq e\)</span>。</p><p>现在我们考虑 <span class="math inline">\(w_0\)</span> 的邻域 <span class="math inline">\(V_e=\{|w-w_0|&lt;e\}\)</span>。则任何 <span class="math inline">\(w_1\in V_e\)</span> 都满足 <a href="#connected-component" title="推论">推论</a> 中的条件：</p><p><span class="math display">\[|f(z)- w_0| \geq e &gt; |w_1-w_0|,\quadz\in \gamma.\]</span></p><p>所以 <span class="math inline">\(w_1\)</span> 在 <span class="math inline">\(\gamma\)</span> 内部至少有一个原像。由 <span class="math inline">\(w_1\)</span> 的任意性可得 <span class="math inline">\(V_e\subset f(U)\)</span> 是 <span class="math inline">\(w_0\)</span> 在 <span class="math inline">\(f(U)\)</span> 中的开邻域，从而 <span class="math inline">\(f(U)\)</span> 是开集。<span class="math inline">\(\blacksquare\)</span></p><p>怎么样？一次简单的遛狗，帮助我们回顾了拓扑和复分析中几个核心的定理。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Needham1997" class="csl-entry" role="listitem">Needham, Tristan. 1997. <em>Visual Complex Analysis</em>. The ClarendonPress, Oxford University Press, New York.</div></div>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静电场与 Marden 定理</title>
      <link href="/Marden-theorem/"/>
      <url>/Marden-theorem/</url>
      
        <content type="html"><![CDATA[<p>我昨晚刚完成了一个 <a href="https://www.shadertoy.com/view/7lf3Wn">shadertoy小动画</a>，演示平面几何中的 <a href="https://en.wikipedia.org/wiki/Marden%27s_theorem">Marden定理</a>、复分析中的 <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Lucas_theorem">Gauss-Lucas定理</a> 和静电场之间的关系：</p><span id="more"></span><div style="display:flex; justify-content:center;"><p><object data="/code/marden.svg" type="image/svg+xml" style="width:90%; aspect-ratio: 600/360;"></object></p></div><p>这个动画的含义如下：</p><ol type="1"><li><p>在复平面上三角形 <span class="math inline">\(\Delta ABC\)</span>的三个顶点处各自放置一个单位正电荷，则平面上电场强度为 0的点有两个（这两个点可能重合），它们位于 <span class="math inline">\(\Delta ABC\)</span> 的内部，并且是三次复多项式<span class="math inline">\(P(z) = (z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span> 的零点。</p></li><li><p>不仅如此，这两个零点还是一个内切于 <span class="math inline">\(\Delta ABC\)</span>的椭圆的两个焦点，此椭圆是所有内切于 <span class="math inline">\(\DeltaABC\)</span> 的椭圆中面积最大者，其与 <span class="math inline">\(\DeltaABC\)</span> 三边的切点均为各边中点。这个椭圆叫做 <a href="https://en.wikipedia.org/wiki/Steiner_inellipse">Steiner内切椭圆</a>。</p></li></ol><p>这个动画是受几天前 Albert Chern 的 <a href="https://twitter.com/theAlbertChern/status/1395468792788967428?s=20">一篇推文</a>启发所作，John Baez 也写了一篇关于这个话题的 <a href="https://johncarlosbaez.wordpress.com/2021/05/24/electrostatics-and-the-gauss-lucas-theorem/">文章</a>。我是由此才了解到Marden 定理还有如此有趣的物理学解释，的确大开眼界！</p><hr><p>在平面上不全共线的 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(a_1,\ldots,a_n\)</span>处放置若干单位正电荷，这规定了一个平面上的电势函数 <span class="math inline">\(V(z)\)</span> （标量） 和一个电场 <span class="math inline">\(\mathbf{E}(z)\)</span>（二维向量场）。电学知识告诉我们，在忽略物理常数意义下有 <span class="math display">\[V(z)=\sum_{i=1}^n\ln|z-a_i|=\ln\prod_{i=1}^n|z-a_i|=\ln|P(z)|.\]</span> 其中<span class="math inline">\(P(z)=(z-a_1)(z-a_2)\cdots(z-a_n)\)</span>是以 <span class="math inline">\(a_1,\ldots,a_n\)</span>为根的多项式。</p><p>此外 <span class="math inline">\(\mathbf{E} = -\nabla V\)</span>为电势的梯度向量取负。</p><blockquote><p><strong>问题</strong>：怎样确定平面上场强为 0 的点呢？</p></blockquote><p>场强为 0的点也叫做<strong>平衡点</strong>、<strong>鞍点</strong>，因为在这一点处的电荷不受电场的库仑力。</p><p>答案有点出人意料：平衡点必然是 <span class="math inline">\(P'(z)\)</span> 的零点，而且这些点都属于 <span class="math inline">\(a_1,\ldots,a_n\)</span> 的凸包！</p><p>注意 <span class="math inline">\(V(z)\)</span> 是 <span class="math inline">\(\ln P(z) = \ln |P(z)| + i\arg{P(z)}\)</span>的实部，由 Cauchy-Riemann 方程不难看出满足 <span class="math inline">\(\nabla V=0\)</span> 的点都是 <span class="math inline">\((\ln P(z))'=P'(z)/P(z)\)</span>的零点，所以平衡点都是 <span class="math inline">\(P'(z)\)</span>的零点。平衡点属于 <span class="math inline">\(\{a_1,\ldots,a_n\}\)</span> 的凸包是根据 <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Lucas_theorem">Gauss-Lucas定理</a>：任何复多项式 <span class="math inline">\(f\)</span>的导数的零点都属于 <span class="math inline">\(f\)</span>的零点构成的凸包！</p><p>John Baez 的文章中利用凸集分离定理给出了 Gauss-Lucas定理的一个简洁证明。</p><p>需要注意的是，反过来 <span class="math inline">\(P'(z)\)</span>的零点未必都是电场的平衡点，当 <span class="math inline">\(P(z)\)</span>有重根时，重根是 <span class="math inline">\(P'(z)\)</span>的零点但不是 <span class="math inline">\(P'(z)/P(z)\)</span>的零点，所以不是平衡点。</p><p>平衡点是鞍点 (saddle point) 是由于 <span class="math inline">\(V(z)\)</span>的调和性质，其不存在局部的极大极小值，所以使得 <span class="math inline">\(\nabla V=0\)</span> 的点都是鞍点。</p><p>在三个点电荷 <span class="math inline">\(A,B,C\)</span>的情形，平衡点有两个，它们位于 <span class="math inline">\(\DeltaABC\)</span> 的内部，且是多项式 <span class="math inline">\(P(z) =(z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span>的零点。那关于这两个点的具体位置我们可以说什么吗？这就是优美的 Marden定理，要表述这个定理，我们需要先介绍 Steiner 内切椭圆的概念：</p><div id="steiner-inellipse" class="unnumbered statement sta_steiner_inellipse plain"><p><span class="statement-heading"><span class="statement-label">Steinerinellipse</span>.</span><span class="statement-spah"></span>在所有内切于 <span class="math inline">\(\Delta ABC\)</span>的椭圆中，存在唯一的一个面积最大者，叫做 Steiner inellipse，此椭圆与<span class="math inline">\(\Delta ABC\)</span>三边的切点为各边的中点。</p></div><p>Marden 定理断言 <span class="math inline">\(P'(z)\)</span>的两个根正是 Steiner 内切椭圆的两个焦点：</p><div id="marden-------" class="unnumbered statement sta_marden___ plain"><p><span class="statement-heading"><span class="statement-label">Marden定理</span>.</span><span class="statement-spah"> </span>复多项式 <span class="math inline">\(P(z)=(z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span> 的两个零点正是 <span class="math inline">\(\Delta ABC\)</span> 的 Steiner inellipse的两个焦点。</p></div><p>Steiner inellipse 和 Marden定理的证明并不复杂，美国数学月刊上出现过两篇介绍其证明的文章，都非常值得一读：</p><ol type="1"><li><p><a href="https://www.researchgate.net/publication/228698127_Triangles_Ellipses_and_Cubic_Polynomials">Triangles,Ellipses, and Cubic Polynomials</a>.</p></li><li><p><a href="https://www.researchgate.net/publication/263136028_An_Elementary_Proof_of_Marden%27s_Theorem">AnElementary Proof of Marden’s Theorem</a>.</p></li></ol><p>其中第一篇文章采用了复数和仿射变换的途径，第二篇使用了椭圆的光学性质。</p>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Escher 风格的非周期密铺</title>
      <link href="/debruijn-rhombus-tiling/"/>
      <url>/debruijn-rhombus-tiling/</url>
      
        <content type="html"><![CDATA[<p>周末刚完成了一个有点烧脑的 <a href="https://www.shadertoy.com/view/wsKBW1">Shadertoy 项目</a>，Escher风格的 <a href="https://en.wikipedia.org/wiki/Aperiodic_tiling">非周期密铺</a>：</p><span id="more"></span><object data="/code/debruijn.svg" type="image/svg+xml"></object><p>你能看出这个动画的奥妙之处在哪里吗？</p><p>直观上看，这个动画由一些错落有致，但又无缝拼接在一起的房间（立方体）组成，每个房间的外面绘制了一些“窗户”，窗户的开闭、朝向是变化的。但是仔细一看，诶，好像一些房间的窗口的朝向是“矛盾”的哎？这种整体布局和谐但是局部细节与真实世界矛盾的艺术风格由<a href="https://en.wikipedia.org/wiki/M._C._Escher">Escher</a>(1898-1972) 所创立，所以这个作品也可以叫做 Escher 风格的不可能密铺。</p><p>这个动画里面使用的几何元素只有菱形，这些菱形分为两种：胖菱形和瘦菱形。在代码中我是对每一个像素，首先确定其所属的菱形，然后计算它到各个装饰元素（菱形边界、窗户、窗台） 的 signed distance field 函数 <span class="math inline">\(d\)</span>，根据 <span class="math inline">\(d\)</span> 的值来混合颜色。</p><p>计算菱形位置的算法非常奇妙，它来自 de Bruijn 1981年的论文，是构造准晶的网格法 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>；添加窗户的点缀是受到了Greg Egan 的 <a href="http://gregegan.net/APPLETS/02/02.html">Javascript动画</a> 启发。我很久之前就知道 de Bruijn 的方法，但是看到 Greg Egan的动画以后还是萌发了在 shader里面做一个更漂亮的效果的想法。这个念头憋了好久，终于前几天利用晚上业余时间动手折腾了一番，捣鼓出了上面的效果。我的动画与Greg Egan 不同的地方在于，Greg Egan 是用 Javascript 在 canvas上动画，可以直接计算出菱形的坐标然后绘制，思路比较直接；但是在 shader里面则需要对每一个像素，先计算它变换后的点，再搜索确定该点所在的菱形，所以实现起来要麻烦一些。此外Greg Egan是精心选择了每一个窗户的开口方向，使得所有的房间的窗户看起来都是矛盾的；我这里为了简单起见只随机设置了开口的方向，所以只有部分房间的窗户是矛盾的。</p><p>把代码中的 <code>N</code> 改成 4 可以得到 Ammann-Beenker密铺，读者不妨一试（改完记得按下 Alt + Enter 编译！）</p><p>代码中窗户的绘制方法参考了 Greg Egan 的代码和注释，特别致谢。</p><p>de Bruijn 的网格方法也可以用于绘制 3D 的准晶，例如 <a href="/demos/icosa_qc.html">Icosahedral Quasicrystal</a>。</p><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>N.G. de Bruijn. Algebraic theory of Penrose’snon-periodic tilings of the plane.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Shadertoy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>刺客 vs 保镖</title>
      <link href="/assassin-vs-bodyguards/"/>
      <url>/assassin-vs-bodyguards/</url>
      
        <content type="html"><![CDATA[<p>Maryam Mirzakhani 在 2014 年的报告中提出了如下的问题（视频的 25 分 50秒处）：</p><iframe width="560" height="315" src="https://www.youtube.com/embed/tprlQMClSYQ?si=WTY5EAbK2GTigsrv" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"></span>假设平面上有一个正方形的房间，房间的四面墙壁都是光滑的反射镜子。子弹在碰到墙壁时会遵循入射角等于出射角的规律无限反射下去。房间中有一位政要和一个刺客，他们的位置是固定的，但可能是房间中任何两点。能否在房间中放置有限数量的保镖，使得这些保镖可以封锁刺客的所有射击角度，从而确保政要不被子弹击中？</p></div><p>根据 <a href="http://www.numdam.org/item/10.5802/aif.2124.pdf">这篇论文</a>的考据，这个问题曾经在 1989 年列宁格勒的数学竞赛中出现过。最近，通过 <a href="https://www.youtube.com/watch?v=a7gp9c2p0UQ">PBS</a> 和 <a href="https://www.math3ma.com/blog/is-the-square-a-secure-polygon">math3ma的博客</a>的科普推广，这个问题又引起了不少人的兴趣。我强烈建议读者在深入阅读本文之前，先观看这些视频和博客。它们的讲解通俗易懂，即便对于普通读者来说也非常友好。</p><p>Greg Egan 在 <a href="https://gregegan.net/SCIENCE/Lattices/Lattices.html">他的博客中</a>进一步讨论了房间是正三角形和正六边形的情况。虽然他给出的答案是正确的，但是他对正六边形情形的解释有点让人难以理解（GregEgan 的一贯风格）。</p><p>正三角形、正方形和正六边形房间是仅有的三种可以用有限多个保镖保护目标的情形，对其它正<span class="math inline">\(N\)</span> 边形房间（<span class="math inline">\(N\notin\{3,4,6\}\)</span>），有限数量的保镖是不行的。</p><p>本文是对 math3ma 和 Greg Egan博客文章的补充，我将主要针对正六边形的情况进行详细解释。我觉得从仿射Weyl群的角度来看这个问题会更清晰，不过这一概念可能对大多数读者来说较为陌生。本文将假定读者已具备群的相关基础知识，并尽可能结合直观图形加以说明。如果读者希望进一步了解仿射Weyl 群，可以参考 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, chap.4</a>)</span>。</p><p>本文的代码在 <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/assassin_vs_bodyguards">Github上</a>。这个项目包含了一个交互式脚本，你可以在窗口中点击并拖拽鼠标来查看刺客射击的轨迹以及保镖的位置：</p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr><td style="text-align: center;">正方形</td><td style="text-align: center;">正三角形</td><td style="text-align: center;">正六边形</td></tr><tr><td style="text-align: center;"><img src="/images/polygon-billiard/square_guards.svg" height="200"></td><td style="text-align: center;"><img src="/images/polygon-billiard/triangle_guards.svg" height="200"></td><td style="text-align: center;"><img src="/images/polygon-billiard/hexagon_guards.svg" height="200"></td></tr></tbody></table><span id="more"></span><h1 id="反射和平移">反射和平移</h1><p>在照镜子的时候，你和自己在镜子中的像的左右是相反的，即镜面反射会改变“手性”。无论你如何移动或旋转身体，都无法与镜中的像完全重合。</p><figure><img src="/images/polygon-billiard/inception.jpg" class="fig" width="500" alt="电影《盗梦空间》剧照。据说摄影师经过后处理被 P 掉了"><figcaption aria-hidden="true">电影《盗梦空间》剧照。据说摄影师经过后处理被 P掉了</figcaption></figure><p>但是如果把镜子中的虚像通过另一面镜子再作一次反射，得到一个二次虚像，那么通过适当的平移或者旋转，你是可以和这个二次虚像完全重合的。这是因为偶数次反射等效于若干次旋转和平移的叠加，手性不变；奇数次反射则会改变手性。</p><p>观察上面盗梦空间的剧照，小李子位于两个平行的镜子中间，他有无穷多个虚像。这些虚像的手性是交错改变的：</p><ul><li>面对他的虚像（集合 <span class="math inline">\(L_1\)</span>）由奇数次反射生成，手性与本体相反；</li><li>背对他的虚像（集合 <span class="math inline">\(L_2\)</span>）由偶数次反射生成（本体视为 0次反射），手性与本体相同。</li></ul><p>假设两个镜子的距离为 <span class="math inline">\(d\)</span>，则每个<span class="math inline">\(L_i\)</span> 中的虚像以 <span class="math inline">\(2d\)</span> 为间隔均匀分布在一条直线上。</p><p>如果我们想在两个镜子中间放置若干保镖，以防止摄影师从任何角度拍摄到小李子，则我们恰好需要4 名保镖。他们的位置是摄影师和以下 4个虚像的连线中点：小李子本人、第一次反射生成的两个虚像，任意一个二次反射生成的虚像。</p><figure><img src="/images/polygon-billiard/parallel.svg" width="400" alt="红色圆点表示刺客，绿色圆点表示目标，它们之间有四个保镖"><figcaption aria-hidden="true">红色圆点表示刺客，绿色圆点表示目标，它们之间有四个保镖</figcaption></figure><p>为什么需要 4名保镖呢？假设某个保镖位于刺客和小李子本人的连线中点。他的偶数次虚像以<span class="math inline">\(2d\)</span>为间隔均匀排列，这些虚像在小李子的偶数次虚像格点 <span class="math inline">\(L_2\)</span> 上的投影间隔是 <span class="math inline">\(4d\)</span>，所以这些投影覆盖了 <span class="math inline">\(L_2\)</span>一半的格点。而该保镖的奇数次虚像一般来说是无用的。所以一名保镖只能挡住小李子的所有虚像的1/4。</p><h1 id="正方形-正三角形-正六边形">正方形 | 正三角形 | 正六边形</h1><p>理解正多边形房间情形的关键在于掌握“展开—折叠”原理：刺客的任何射击轨迹都可以展开为平面上的一条射线，当且仅当这条射线经过目标的某个虚像时刺客才能击中目标。这个操作叫做展开(unfolding)。其逆操作是折叠 (folding)，从刺客发出的任何射线都能通过折叠操作还原为房间内的射击轨迹。</p><p>以正方形房间为例：</p><ul><li><p>目标的虚像由 4 个不同的二维格点组成：</p><figure><img src="/images/polygon-billiard/square_lattice.svg" width="350" alt="假设左下角的单位正方形是真实房间，在房间中摆放一个 L 形的记号，那么平面上每个正方形中都会出现一个 L 的虚像，这些虚像有四种不同的定向，具有相同定向的那些 L 之间互相只差一个平移，它们构成一个二维格点。总共有 4 个不同的格点。"><figcaption aria-hidden="true">假设左下角的单位正方形是真实房间，在房间中摆放一个 L形的记号，那么平面上每个正方形中都会出现一个 L的虚像，这些虚像有四种不同的定向，具有相同定向的那些 L之间互相只差一个平移，它们构成一个二维格点。总共有 4个不同的格点。</figcaption></figure></li><li><p>刺客只要朝着目标的任何一个虚像开枪就能击中目标，因为他和任何虚像之间的连线都可以通过折叠操作变成一条子弹的反射路径：</p><figure><img src="/images/polygon-billiard/square_lattice_with_targets.svg" width="350" alt="左下角是真实房间，红色圆点是刺客，空心圆圈是目标，灰色圆点是保镖。目标在每个房间中都有一个虚像，刺客和任何一个虚像之间的连线都对应一条可以击中目标的反射路径"><figcaption aria-hidden="true">左下角是真实房间，红色圆点是刺客，空心圆圈是目标，灰色圆点是保镖。目标在每个房间中都有一个虚像，刺客和任何一个虚像之间的连线都对应一条可以击中目标的反射路径</figcaption></figure></li><li><p>在 math3ma 的博客中已经证明了封锁一个二维格点需要 4名保镖，所以一共需要 4 x 4=16 名保镖。</p></li></ul><p>当房间是正三角形时：</p><ul><li><p>目标的虚像由 6 个不同的二维格点组成：</p><p><img src="/images/polygon-billiard/triangle_lattice.svg" class="fig" width="350"></p></li><li><p>同样刺客与目标的任何虚像之间的连线都对应一条房间内的射击路径：</p><p><img src="/images/polygon-billiard/triangle_lattice_with_targets.svg" class="fig" width="350"></p></li><li><p>因此总共需要 4 x 6 = 24 名保镖。</p></li></ul><p>正六边形是一个容易产生迷惑的情形。这时目标的虚像仍然由 6个不同的二维格点构成：</p><p><img src="/images/polygon-billiard/hexagon_lattice.svg" class="fig" width="350"></p><p>封锁一个二维格点当然还是需要 4 名保镖。但是，如果你仍然认为需要 4 x 6= 24 名保镖，那对不起，事情不是这样的。真正的答案是：总共需要 <span class="math inline">\(4 \times 6 \times 6 = 144\)</span> 名保镖。</p><p>多出来的那个因子 <span class="math inline">\(6\)</span>，到底从哪儿来的？</p><p>核心现象是这样的：</p><ul><li>在正方形和正三角形中，虚像格点里的每一个点，都来自房间内唯一的一个原像；</li><li>但在正六边形中，同一个格点里的不同点，可能分别来自房间内 6个不同的位置；</li></ul><p>于是：即便你在平面上的某个格点中点位置安排好了“保镖的虚像”，在折叠回真实房间时，可能会落在多达6个不同的位置上。要想“所有可能位置都有人值守”，你就得为每种可能都准备一名保镖，于是多出一个因子6。</p><p>下图也验证了这一结论：</p><figure><img src="/images/polygon-billiard/24_guards_each_lattice.svg" class="fig" height="350" alt="我选择了明星的 6 个虚像格点中的一个，用黄色的点标记；刺客与每个虚像连线的中点有一个保镖的虚像，这个虚像来自房间中某个真实的保镖（用青色的点标记）。把射线折叠回房间我们可以得到真实保镖的位置。然而即便对同一个保镖，随着他的虚像变化，这个位置也可能不同，有 6 种可能，所以封锁一个格点就需要 4 x 6 = 24 个保镖，封锁全部 6 个格点需要 144 个保镖！"><figcaption aria-hidden="true">我选择了明星的 6个虚像格点中的一个，用黄色的点标记；刺客与每个虚像连线的中点有一个保镖的虚像，这个虚像来自房间中某个真实的保镖（用青色的点标记）。把射线折叠回房间我们可以得到真实保镖的位置。然而即便对同一个保镖，随着他的虚像变化，这个位置也可能不同，有6 种可能，所以封锁一个格点就需要 4 x 6 = 24 个保镖，封锁全部 6个格点需要 144 个保镖！</figcaption></figure><p>下图更清楚的展示了这一现象：两个灰色的点来自同一个保镖的虚像格点（它们在同一种颜色的三角形的相同位置），折叠回房间后，最终的真实位置（青色）不同。这两个真实位置相差一个绕房间中心的120 度旋转。</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr><td style="text-align: center;"><img src="/images/polygon-billiard/2-2.svg" class="fig" width="350"></td><td style="text-align: center;"><img src="/images/polygon-billiard/-4-2.svg" class="fig" width="350"></td></tr></tbody></table><h1 id="仿射-weyl-群">仿射 Weyl 群</h1><p>从群论的角度可以更好的解释上面的现象。</p><p>首先介绍一个记号：设 <span class="math inline">\(\alpha\in\mathbb{R}^2\)</span>是一个单位向量，我们用 <span class="math inline">\(H_{\alpha,k}\)</span>表示仿射直线 <span class="math display">\[H_{\alpha,k}=\{x\in\mathbb{R}^2\mid (x,\alpha)=k\},\quad k\in\mathbb{Z}.\]</span>并用 <span class="math inline">\(s_{\alpha,k}\)</span> 表示关于 <span class="math inline">\(H_{\alpha,k}\)</span> 的反射。当 <span class="math inline">\(k=0\)</span> 时我们把 <span class="math inline">\(H_{\alpha,0}\)</span> 简写为 <span class="math inline">\(H_\alpha\)</span>，把 <span class="math inline">\(s_{\alpha,0}\)</span> 简写为 <span class="math inline">\(s_{\alpha}\)</span>。</p><p>正三角形、正方形、正六边形房间的共同之处，是房间的所有虚像可以密铺整个二维平面。而且它们是仅有的具有此性质的正多边形。这背后的原因是，这三种情形下，关于房间墙壁的反射生成的群<span class="math inline">\(W\)</span> 都是 <a href="https://en.wikipedia.org/wiki/Coxeter_group#Affine_Coxeter_groups">仿射Weyl 群</a>。仿射 Weyl群总是无限群，每个虚像房间都是通过将群元素作用在真实房间上得到的。</p><ol type="1"><li>在正方形的情形，<span class="math inline">\(W=\widetilde{A}_1\times\widetilde{A}_1\)</span>。</li><li>在正三角形和正六边形的情形，<span class="math inline">\(W=\widetilde{A}_2\)</span>。</li><li>在两个平行镜面的情形，尽管房间是无界的，<span class="math inline">\(W\)</span> 同样是仿射 Weyl 群 <span class="math inline">\(\widetilde{A}_1\)</span>。</li></ol><p>仿射 Weyl 群总可以分解为一个有限 Weyl 群 <span class="math inline">\(W_{\rm fin}\)</span> 和一个格点群 <span class="math inline">\(L\)</span> 的半直积，其中 <span class="math inline">\(L\)</span> 是 <span class="math inline">\(W_{\rmfin}\)</span> 的根系 <span class="math inline">\(\Phi\)</span>的余根格点。 <span class="math display">\[W = W_{\rm fin}\ltimesL.\]</span></p><p>我们分别来考察它们：</p><p><strong>正方形情形</strong></p><p>设房间 <span class="math inline">\(C=[0,1]\times[0,1]\)</span>是单位正方形。</p><ul><li>记 <span class="math inline">\(\alpha_1=(1,0),\alpha_2=(0,1)\)</span>是过原点的两个墙壁的法向量。</li><li>定义余根 <span class="math inline">\(\alpha_1^\vee=2\alpha_1,\alpha_2^\vee=2\alpha_2\)</span>。</li><li><span class="math inline">\(s=s_{\alpha_1},t=s_{\alpha_2}\)</span>是关于两面墙壁的反射。</li><li><span class="math inline">\(W_{\rm fin}=\{1,s,t,st\}\)</span> 是Klein 四元群。</li><li>格点群 <span class="math inline">\(L=\mathbb{Z}\alpha_1^\vee +\mathbb{Z}\alpha_2^\vee=2\mathbb{Z}\)</span>。</li><li><span class="math inline">\(W\)</span> 在 <span class="math inline">\(C\)</span> 上的作用可以分成两步：首先将 <span class="math inline">\(W_{\rm fin}\)</span> 中的某个元素作用在 <span class="math inline">\(C\)</span> 上，得到 <span class="math inline">\(\{C,sC,tC,stC\}\)</span> 之一，然后分别在 <span class="math inline">\(x,y\)</span> 方向上平移偶数的距离。</li></ul><p><img src="/images/polygon-billiard/a1xa1.svg" class="fig" height="500"></p><p><strong>正三角形情形</strong></p><p>设真实房间 <span class="math inline">\(C\)</span>的一个顶点位于原点，经过原点的两面墙的法向量是 <span class="math inline">\(\alpha_1\)</span> 和 <span class="math inline">\(\alpha_2\)</span>，它们的夹角是 <span class="math inline">\(-\pi/3\)</span>。</p><ul><li>余根 <span class="math inline">\(\alpha_1^\vee=2\alpha_1,\alpha_2^\vee=2\alpha_2\)</span>。</li><li>生成元 <span class="math inline">\(s=s_{\alpha_1},t=s_{\alpha_2}\)</span>。</li><li><span class="math inline">\(W_{\rm fin}=\langle s,t\rangle\congD_3\)</span> （二面体群，阶为 6）。</li><li>格点群 <span class="math inline">\(L=\mathbb{Z}\alpha_1^\vee +\mathbb{Z}\alpha_2^\vee\)</span>。</li><li><span class="math inline">\(W\)</span> 在 <span class="math inline">\(C\)</span> 上的作用也分成两步，首先用 <span class="math inline">\(D_3\)</span> 中的某个元素作用在 <span class="math inline">\(C\)</span> 上，得到环绕原点的 6 个房间 <span class="math inline">\(\{C,sC,tC,stC,tsC,stsC\}\)</span>之一，然后再将其沿着 <span class="math inline">\(L\)</span>中的一个格点进行平移。</li></ul><p><img src="/images/polygon-billiard/a2.svg" id="regular-triangle" class="fig" width="600"></p><p>在正方形和正三角形的情形，群元素和房间都是一一对应的：对任何虚像房间<span class="math inline">\(C'\)</span>，有且仅有唯一的群元素 <span class="math inline">\(w\in W\)</span> 将真实房间 <span class="math inline">\(C\)</span> 映射为 <span class="math inline">\(C'\)</span>。但是在正六边形的情形，情况变得非常不同，群元素和房间是6 对 1 的关系！</p><p><strong>正六边形情形</strong></p><p>我们可以继续使用 <a href="#regular-triangle">正三角形图</a>来分析。因为正六边形房间给出的反射群和正三角形的情形一样，都是 <span class="math inline">\(\widetilde{A}_2\)</span>，目标虚像也由 6个不同的格点组成。任何虚像房间也可以分两步得到：先用 <span class="math inline">\(D_3\)</span>中的某个元素作用在真实房间上，再沿着余根格点中的一个向量平移过去。但是<span class="math inline">\(D_3\)</span>保持正六边形不变，只是置换其内部的 6 个正三角形，所以最终的房间是由<span class="math inline">\(L\)</span> 唯一决定的。</p><p>这会导致什么后果呢？我们作如下分析：设 <span class="math inline">\(p\)</span> 是真实房间内的一点，<span class="math inline">\(q\)</span> 是 <span class="math inline">\(p\)</span> 的某个虚像，从而存在 <span class="math inline">\(x\in D_3\)</span> 和 <span class="math inline">\(t\in L\)</span> 使得 <span class="math inline">\(q=x\cdot p + t\)</span>。<span class="math inline">\(q\)</span> 所在的格点是 <span class="math display">\[q+L=q+\mathbb{Z}\alpha_1^\vee+\mathbb{Z}\alpha_2^\vee.\]</span>然而 <span class="math inline">\(p\)</span> 并不是真实房间中唯一可以生成<span class="math inline">\(q+L\)</span> 的点。记 <span class="math inline">\(S=\{y\cdot p\mid y\in D_3\}\)</span>，<span class="math inline">\(S\)</span> 都是真实房间中的点，并且最多包含 6个不同的点。对 <span class="math inline">\(y\cdot p\in S\)</span>，用<span class="math inline">\(xy^{-1}\in D_3\)</span> 作用在 <span class="math inline">\(y\cdot p\)</span> 上，得到 <span class="math inline">\(x\cdot p\)</span>，然后按照 <span class="math inline">\(L\)</span> 进行平移，就可以得到格点 <span class="math inline">\(q+L\)</span>。<span class="math inline">\(q\)</span>与刺客的连线给出的“反射序列”决定了一个群元素 <span class="math inline">\((x,t)\)</span>。当 <span class="math inline">\(q\)</span> 跑遍整个 <span class="math inline">\(q+L\)</span> 时，<span class="math inline">\(x\)</span> 可以跑遍整个 <span class="math inline">\(D_3\)</span>。所以我们需要在所有 6个位置布置保镖，所以最终保镖的数目要乘以 6。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div></div>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Todd-Coxeter 算法和 3D/4D 均匀多胞体</title>
      <link href="/Todd-Coxeter-and-uniform-polytopes/"/>
      <url>/Todd-Coxeter-and-uniform-polytopes/</url>
      
        <content type="html"><![CDATA[<p>本文介绍我写的一个高颜值的、脱离了低级趣味的小程序：用 Python 和POV-Ray 绘制各种三维多面体和四维多胞体，代码在 <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/polytopes">Github</a>上。</p><p>以下是用这个程序渲染的一些例子，其中不同颜色的顶点/边/面表示它们在对称群的作用下位于不同的轨道中，具体解释见后。</p><span id="more"></span><h1 id="例子">例子</h1><ul><li><p>所有的 Platonic 多面体，Archimedean 多面体，比如 snubdodecahedron:</p><p><video src="/images/polytopes/snub-dodecahedron.mp4" controls=""></video></p></li><li><p>所有的 Kepler-Poinsot 多面体，比如 great icosahedron:</p><p><video src="/images/polytopes/great-icosahedron.mp4" controls=""></video></p></li><li><p>所有的四维均匀多胞体 （除去一个特例 <a href="https://en.wikipedia.org/wiki/Grand_antiprism">The grandantiprism</a>），比如我的 Github 头像 (runcinated 120-cell)：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/github-favicon.png"></p></li><li><p>截断的四维正方体 truncated tesseract:</p><p><video src="/images/polytopes/truncated-tesseract.mp4" controls=""></video></p></li><li><p>4d cube:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/4-cube.png"></p></li><li><p>也可以是非凸的，比如星状正多胞体中的 grand stellated120-cell:</p><p><video src="/images/polytopes/grand-stellated-120-cell.mp4" controls=""></video></p></li><li><p>甚至是 5 维欧氏空间中的均匀多胞体，如 5-cube:</p><p><video src="/images/polytopes/5-cube.mp4" controls=""></video></p></li></ul><p>等等，可玩的效果是非常多的。</p><p>以上这些都是在 Python 中做好计算以后，将多胞体的数据导出到 POV-Ray中渲染得到的。你完全可以通过改写代码中的 POV-Ray的部分来渲染得出不同的效果，当然前提是需要掌握 POV-Ray的场景描述语言，不过这属于另一段故事，就不在本文的讨论范围内了。</p><p>下面介绍程序背后的数学原理。</p><h1 id="这些图画的都是什么">这些图画的都是什么？</h1><p>这些图都是三维或者四维<strong>欧氏空间</strong>中<strong>凸/非凸</strong>的<strong>均匀</strong>多胞体(polytope)，三维的情形更常用的称呼是多面体。这里有几个关键词需要注意：凸/非凸、均匀。</p><p>凸比较好理解，就是指多胞体上任意两点间的连线仍然属于此多胞体，否则就是非凸。上面的例子中Platonic 多面体、Archimedean 多面体都是凸的；但 Kepler-Poinsot多面体、星状正多胞体都是非凸的。</p><p>均匀这个词就不太好理解了。简单说就是：多胞体的所有顶点都一样，且每个二维的面都是正多边形，每个三维的胞腔都是均匀多面体（这是个递归的定义）。</p><p>要准确解释什么叫所有顶点都一样，就要用到群论的语言：一个多胞体 <span class="math inline">\(P\)</span> 的对称群 <span class="math inline">\(G\)</span>是欧氏空间中一组正交变换构成的有限群，<span class="math inline">\(G\)</span> 作用在 <span class="math inline">\(P\)</span> 上保持 <span class="math inline">\(P\)</span> 不变。所有顶点都一样的严格说法是 <span class="math inline">\(G\)</span> “传递地”作用在 <span class="math inline">\(P\)</span> 的顶点集上，即对 <span class="math inline">\(P\)</span> 的任何两个顶点 <span class="math inline">\(u,v\)</span>，都存在 <span class="math inline">\(g\in G\)</span>，<span class="math inline">\(g\)</span> 把 <span class="math inline">\(u\)</span> 映射为 <span class="math inline">\(v\)</span>。</p><h1 id="这些图是怎么画出来的">这些图是怎么画出来的？</h1><p>这些多胞体看起来样子大不相同，但它们都可以用同一种方法计算出来，叫做<a href="https://en.wikipedia.org/wiki/Wythoff_construction">Wythoff构造法</a>，也称万花筒构造法。它的原理跟我们小时候玩的万花筒的原理是一样的：在空间中放置若干过原点的反射平面（镜子），镜面之间的夹角是精心设计好的，都形如 <span class="math inline">\(\pi-\pi/p\)</span>，其中 <span class="math inline">\(p\)</span> 为有理数。在空间中选定一个初始顶点<span class="math inline">\(v_0\)</span>，将 <span class="math inline">\(v_0\)</span>关于这些镜子反复作反射变换，得到的全部镜像就是多胞体的顶点。如果 <span class="math inline">\(v_0\)</span> 关于第 <span class="math inline">\(i\)</span> 面镜子反射后得到的镜像是 <span class="math inline">\(v_1\)</span>，则 <span class="math inline">\((v_0,v_1)\)</span> 构成一条类型为 <span class="math inline">\(i\)</span>的边，我们把它以及在对称群作用下同轨道的所有边都染成 <span class="math inline">\(i\)</span> 号色。如果 <span class="math inline">\(v_0\)</span> 先关于镜面 <span class="math inline">\(i\)</span> 作反射，再关于镜面 <span class="math inline">\(j\)</span>作反射，则由于两个反射变换的复合是一个旋转变换，<span class="math inline">\(v_0\)</span>实际上是绕着某个面的中心和原点的连线作了一次旋转，旋转的角度为 <span class="math inline">\(2\pi/m\)</span> （假设镜面 <span class="math inline">\(i\)</span> 和镜面 <span class="math inline">\(j\)</span> 的法向量夹角是 <span class="math inline">\(\pi-\pi/m\)</span>），重复此旋转 <span class="math inline">\(m\)</span> 次即可得到多胞体的一个类型为 <span class="math inline">\((i,j)\)</span>的面，我们把它在对称群作用下同轨道的所有面都染成同一颜色。</p><p>这里的关键问题有两个：</p><ol type="1"><li>对于不同的均匀多胞体，应该如何放置这些镜面，并选择初始顶点？</li><li>摆好镜面和初始顶点以后，怎样不重复不遗漏地计算初始顶点的所有镜像？</li></ol><p>第一个问题的答案叫做 <a href="https://en.wikipedia.org/wiki/Coxeter%E2%80%93Dynkin_diagram">Coxeter-Dynkin图</a>，Coxeter-Dynkin图是一个带标记信息的无向图，它编码了多胞体的全部信息，即只要知道了多胞体对应的Coxeter-Dynkin 图，就可以求出该多胞体的所有数据（仅缩放大小和在空间中的摆放位置除外）。每个均匀多胞体都有一个Coxeter-Dynkin 图与之对应，但是不同的 Coxeter-Dynkin图可能描述的是相同的多胞体。</p><p>比如正方体的 Coxeter-Dynkin 图为：</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="200"></p><p>我们来解释这个图的含义：</p><p>在一个 Coxeter-Dynkin图中，每个顶点代表一面镜子，在上图中有三个顶点，所以有三面镜子。将这三面镜子从左到右依次记作<span class="math inline">\(m_0, m_1,m_2\)</span>，顶点之间的边记录了镜子间的夹角：</p><ol type="1"><li>若两个镜面之间的夹角为 <span class="math inline">\(\pi/2\)</span>则它们之间没有边相连。</li><li>若两个镜面之间的夹角为 <span class="math inline">\(\pi-\pi/3\)</span>则它们之间用一条无标记的边相连。</li><li>若两个镜面之间的夹角为 <span class="math inline">\(\pi-\pi/m\)</span> (<span class="math inline">\(m\)</span> 为有理数且 <span class="math inline">\(m&gt;2, m\ne3\)</span>)，则它们之间用一条标号为<span class="math inline">\(m\)</span> 的边相连。</li></ol><p>此外用圈出的镜面来标记初始顶点的位置，<strong>一个镜面被圈出当且仅当初始顶点不在这个镜面上</strong>。</p><p>从而在正方形的情形 <span class="math inline">\(\langlem_0,m_1\rangle=\pi-\pi/4\)</span>，<span class="math inline">\(\langlem_1,m_2\rangle=\pi-\pi/3\)</span>，<span class="math inline">\(\langlem_0,m_2\rangle=\pi/2\)</span>。初始顶点落在 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 上但是不属于 <span class="math inline">\(m_0\)</span>。</p><p>于是这三面镜子可以这样摆放：</p><ol type="1"><li>镜子 <span class="math inline">\(m_0\)</span> 的法向量可以随意，比如<span class="math inline">\(n_0=(1, 0, 0)\)</span>。</li><li>镜子 <span class="math inline">\(m_1\)</span> 的法向量 <span class="math inline">\(n_1\)</span> 与 <span class="math inline">\(n_0\)</span> 夹角为 <span class="math inline">\(3\pi/4\)</span>，于是 <span class="math inline">\(n_1\)</span> 可以取为 <span class="math inline">\((\cos\dfrac{3\pi}{4}, \sin\dfrac{3\pi}{4},0)\)</span>。</li><li>镜子 <span class="math inline">\(m_2\)</span> 的法向量 <span class="math inline">\(n_2\)</span> 与 <span class="math inline">\(n_0\)</span> 垂直，所以 <span class="math inline">\(n_2\)</span> 形如 <span class="math inline">\((0,y_3,z_3)\)</span>，它与 <span class="math inline">\(n_1\)</span> 夹角是 <span class="math inline">\(2\pi/3\)</span>，所以 <span class="math inline">\(y_3\sin\dfrac{3\pi}{4}=\cos\dfrac{2\pi}{3}\)</span>，再结合 <span class="math inline">\(n_2\)</span> 是单位向量，<span class="math inline">\(z_3=\sqrt{1-y_3^2}\)</span>，解出 <span class="math inline">\(y_3, z_3\)</span> 即可。</li></ol><p>要选择一个落在 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 上但是不落在 <span class="math inline">\(m_0\)</span> 上的初始点 <span class="math inline">\(v_0\)</span>，我们可以让 <span class="math inline">\(v_0\)</span> 到平面 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 的距离为 0，到平面 <span class="math inline">\(m_0\)</span> 的距离为 1，即</p><p><span class="math display">\[\langle v_0, n_0\rangle=1,\quad \langlev_0, n_1\rangle=0,\quad\langle v_0, n_2\rangle=0.\]</span></p><p>求解这个线性方程组即可。</p><p>我们前面提到过，要使得初始顶点的所有镜像恰好构成一个均匀多胞体，镜子之间的夹角必须精心设置，这实际上只有有限种可能。换句话说，只有有限个Coxeter-Dynkin 图可以给出 3D/4D 的均匀多胞体。在 <a href="https://en.wikipedia.org/wiki/Uniform_polytope">维基百科</a>上完整的列出了每种均匀多胞体对应的 Coxeter-Dynkin图，这里就不再专门列举了，但是特别指出两点：</p><ol type="1"><li>Coxeter-Dynkin图的标号完全决定了多胞体的对称性，而初始顶点的位置则决定了多胞体的截断类型。</li><li>对偶的多胞体具有相同的 Coxeter-Dynkin图，只不过要把边的标号从右到左反过来。比如正八面体和正方体的Coxeter-Dynkin 图是一样的，但是边的标号是 (3, 4)。</li></ol><p>第二个问题的答案叫做 Todd-Coxeter算法，展开讲的话比较复杂，我们单列一节专门谈谈。</p><h1 id="有限表现群和-todd-coxeter-算法">有限表现群和 Todd-Coxeter算法</h1><p>怎样求出初始顶点在所有镜子中的镜像？有个简单的办法：只要反复地将初始顶点关于每个镜面作反射，算出得到的镜像点的坐标，并与之前得到的点的坐标相比较（浮点数比较需要在一定的误差范围内考虑），直到不再有新的镜像点出现为止，不就得到全部顶点集吗？这个方法确实可行，但是既笨又丑陋：它完全没有用到多胞体具有对称性这一事实！</p><p>这个程序采用的是基于符号计算的途径，这个方法可以精准地得出所有顶点/边/面的信息，代价就是涉及的数学略复杂。我们先回忆一下群在集合上的作用的轨道—稳定化子定理：</p><div id="-----------------------------" class="unnumbered statement sta____________ plain"><p><span class="statement-heading"><span class="statement-label">轨道 —稳定化子定理</span>.</span><span class="statement-spah"> </span>设群<span class="math inline">\(G\)</span> 传递地作用在集合 <span class="math inline">\(S\)</span> 上，设 <span class="math inline">\(x\inS\)</span> 的稳定化子群是 <span class="math inline">\(H\)</span>，则集合<span class="math inline">\(S\)</span> 与 <span class="math inline">\(G/H\)</span> 中的右陪集之间有一一对应：<span class="math inline">\(x\cdot g\leftrightarrow Hg\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>和一般的约定不同，这里群在集合上的作用为作用在右边，主要是为了编程方便，实际上左边右边都一样。</p></div><p>这个定理告诉我们，如果群 <span class="math inline">\(G\)</span>传递地作用在一个集合 <span class="math inline">\(S\)</span> 上，而且对<span class="math inline">\(S\)</span> 中某个元素 <span class="math inline">\(x\)</span> 我们知道了它的稳定化子群 <span class="math inline">\(H\)</span>，则只要对 <span class="math inline">\(G/H\)</span> 的每个陪集代表元 <span class="math inline">\(g\)</span>，将 <span class="math inline">\(g\)</span> 作用在 <span class="math inline">\(x\)</span> 上就可以得到整个 <span class="math inline">\(S\)</span>。</p><p>于是给定一个均匀多胞体 <span class="math inline">\(P\)</span>，要求出其全部顶点集合，我们只要：</p><ol type="1"><li>根据 <span class="math inline">\(P\)</span> 的 Coxeter-Dynkin图确定其对称群 <span class="math inline">\(G\)</span> 和初始顶点 <span class="math inline">\(v_0\)</span>。</li><li>定出 <span class="math inline">\(v_0\)</span> 的稳定化子群 <span class="math inline">\(H\)</span> 并求出 <span class="math inline">\(G/H\)</span> 的一组陪集代表元。</li><li>将 <span class="math inline">\(G/H\)</span> 中的每个陪集代表元作用在<span class="math inline">\(v_0\)</span> 上即得 <span class="math inline">\(P\)</span> 的全部顶点。</li></ol><p>我们仍然以正方体为例来讲解：正方体的 Coxeter-Dynkin 图是</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="200"></p><p>仍然记三个镜面为 <span class="math inline">\(m_0,m_1,m_2\)</span>，其法向量分别为 <span class="math inline">\(n_0,n_1,n_2\)</span>，设 <span class="math inline">\(\rho_0,\rho_1,\rho_2\)</span>分别是关于它们的反射变换，<span class="math inline">\(\rho_i\)</span>对应的矩阵为 <span class="math inline">\(M_i=I-2n_in_i^T\)</span>（见 <a href="https://en.wikipedia.org/wiki/Householder_transformation">Householder变换</a>）。</p><p>正方体的对称群 <span class="math inline">\(G\)</span> 由 <span class="math inline">\(\rho_0,\rho_1,\rho_2\)</span>这三个基本反射生成，其表现为： <span class="math display">\[G =\langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span>这是因为反射的平方总是恒等变换，所以 <span class="math inline">\(\rho_i^2=1\)</span>。<span class="math inline">\(\rho_0,\rho_1\)</span> 是两个夹角为 <span class="math inline">\(3\pi/4\)</span> 的反射，所以 <span class="math inline">\(\rho_0\rho_1\)</span> 是一个角度为 <span class="math inline">\(3\pi/2\)</span> 的旋转，旋转轴为 <span class="math inline">\(m_0\)</span> 和 <span class="math inline">\(m_1\)</span> 的交线，从而 <span class="math inline">\((\rho_0\rho_1)^4=1\)</span>。<span class="math inline">\(\rho_1\rho_2,\rho_0\rho_2\)</span>的情形是类似的。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>利用 Todd-Coxeter 算法 （后面有解释） 不难求出这个群包含 48个元素，罗列如下： <span class="math display">\[\begin{array}{lll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{0}&amp;\rho_{1}&amp;\rho_{0}\rho_{2}\\\rho_{2}&amp;\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\end{array}\]</span> 由于在正方形的 Coxeter-Dynkin 图中只有镜面 <span class="math inline">\(m_0\)</span> 是被圈出的，即初始顶点 <span class="math inline">\(v_0\)</span> 落在 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 上，但不属于 <span class="math inline">\(m_0\)</span>，所以反射 <span class="math inline">\(\rho_1,\rho_2\)</span> 保持 <span class="math inline">\(v_0\)</span> 不动，<span class="math inline">\(\rho_0\)</span> 将 <span class="math inline">\(v_0\)</span> 映射为其关于 <span class="math inline">\(m_0\)</span> 的镜像，于是 <span class="math inline">\(v_0\)</span> 的稳定化子群是 <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a><span class="math display">\[H=\langle \rho_1, \rho_2\ |\\rho_1^2=\rho_2^2=(\rho_1\rho_2)^3=e\rangle.\]</span> 显然 <span class="math inline">\(H\)</span> 就是二面体群 <span class="math inline">\(D_3\)</span>，所以 <span class="math inline">\(|H|=6\)</span>，从而 <span class="math inline">\(|G/H|=8\)</span>。利用 Todd-Coxeter算法可得其一组右陪集代表元为 <span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span> 将它们作用在 <span class="math inline">\(v_0\)</span>上即可得到正方体的 8 个顶点。例如 <span class="math inline">\(\rho_0\rho_1\)</span> 作用在 <span class="math inline">\(v_0\)</span> 上为 <span class="math display">\[v_0(\rho_0\rho_1)=(v_0\rho_0)\rho_1=(v_0M_0)\rho_1=v_0M_0M_1.\]</span>其中 <span class="math inline">\(v_0\)</span> 写成行向量的形式，每个<span class="math inline">\(M_i\)</span> 是对称矩阵。</p><p>计算边/面/胞腔的原理是类似的，但考虑的细节要多一些。比如我们想求出所有关于第<span class="math inline">\(i\,(i=0,1,2)\)</span> 个镜面 <span class="math inline">\(m_i\)</span> 反射生成的类型为 <span class="math inline">\(i\)</span> 的边，可以这样做：</p><ol type="1"><li>检查初始顶点 <span class="math inline">\(v_0\)</span> 是否落在 <span class="math inline">\(m_i\)</span>上。如果答案为是，那么关于此镜面的反射保持 <span class="math inline">\(v_0\)</span> 不变，此多面体不含类型 <span class="math inline">\(i\)</span> 的边。否则设 <span class="math inline">\(v_0\)</span> 关于 <span class="math inline">\(m_i\)</span> 的镜像为 <span class="math inline">\(v_1\)</span>，则 <span class="math inline">\((v_0,v_1)\)</span> 构成一条类型为 <span class="math inline">\(i\)</span> 的边<span class="math inline">\(e\)</span>。</li><li>关于 <span class="math inline">\(m_i\)</span> 的反射 <span class="math inline">\(\rho_i\)</span> 把 <span class="math inline">\(v_0\)</span> 和 <span class="math inline">\(v_1\)</span> 互换，从而保持 <span class="math inline">\(e\)</span> 不变。<strong>注意其它任何与 <span class="math inline">\(m_i\)</span> 垂直并且包含初始点 <span class="math inline">\(v_0\)</span> 的镜面反射也会保持 <span class="math inline">\(e\)</span> 不变</strong>。在正方形的情形中，反射<span class="math inline">\(\rho_0\)</span> 互换 <span class="math inline">\(e\)</span> 的两端因而保持 <span class="math inline">\(e\)</span> 不变，此外镜面 <span class="math inline">\(m_0\)</span> 和 <span class="math inline">\(m_2\)</span> 是垂直的，且 <span class="math inline">\(v_0\)</span> 包含在 <span class="math inline">\(m_2\)</span> 中，所以反射 <span class="math inline">\(\rho_2\)</span> 保持 <span class="math inline">\(e\)</span> 上的每个点不变，于是 <span class="math inline">\(e\)</span> 的稳定化子群为 <span class="math inline">\(H=\langle \rho_0,\rho_2 \rangle\)</span>。显然<span class="math inline">\(H\)</span> 同构于 <span class="math inline">\(\mathbb{Z}_2\times\mathbb{Z}_2\)</span>，所以<span class="math inline">\(|H|=4\)</span>，从而 <span class="math inline">\(|G/H|=12\)</span>，即正方体有 12 条边 <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>。</li><li>求出 <span class="math inline">\(G/H\)</span>的一组陪集代表元并作用在 <span class="math inline">\(e\)</span>上得出全部类型为 <span class="math inline">\(i\)</span> 的边。</li></ol><p>求面的情形复杂一些，基本原理是这样的：</p><ol type="1"><li>对 <span class="math inline">\(i\ne j\)</span>，如果初始顶点 <span class="math inline">\(v_0\)</span> 不同时属于镜面 <span class="math inline">\(i\)</span> 和镜面 <span class="math inline">\(j\)</span>，则旋转 <span class="math inline">\(\rho_i\rho_j\)</span> 就可以生成一个面 <span class="math inline">\(f\)</span>。需要注意的是，如果这两个镜面恰好垂直，则必须二者均不包含<span class="math inline">\(v_0\)</span>才能得到一个非退化的面，这个面是个正方形。在正方体的情形，<span class="math inline">\(\rho_0\rho_1\)</span> 可以生成一个面，<span class="math inline">\(\rho_0\rho_2\)</span>（两镜面垂直但只有一个镜面包含<span class="math inline">\(v_0\)</span>）和 <span class="math inline">\(\rho_1\rho_2\)</span>（两镜面均包含 <span class="math inline">\(v_0\)</span>）都不能给出面。</li><li><span class="math inline">\(f\)</span> 的稳定化子群是由 <span class="math inline">\(\rho_i,\rho_j\)</span> 和那些包含 <span class="math inline">\(v_0\)</span> 且与 <span class="math inline">\(m_i,m_j\)</span>均垂直的镜面反射生成。在正方形的情形是 <span class="math inline">\(H=\langle \rho_0,\rho_1 \rangle\)</span> <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>，显然 <span class="math inline">\(H\)</span> 同构于二面体群 <span class="math inline">\(D_8\)</span>，因此 <span class="math inline">\(|H|=8\)</span>，<span class="math inline">\(|G/H|=6\)</span>，即正方体有 6 个面。</li></ol><p>总之关键的步骤都是给定群 <span class="math inline">\(G\)</span>和某个子群 <span class="math inline">\(H\)</span>，求 <span class="math inline">\(G/H\)</span> 的一组陪集代表元。</p><p>这里用到的算法叫做 <a href="https://en.wikipedia.org/wiki/Todd%E2%80%93Coxeter_algorithm">Todd-Coxeter算法</a>。</p><p>Todd-Coxeter算法在许多抽象代数或者群论的教材都有，用到的数学知识并不复杂。但完整描述并证明一份程序实现的细节还是很费功夫的，恐怕要好几页纸才能说清楚。限于篇幅，我这里仅用正方体的情形为例说明算法的步骤，具体的证明和更多的细节读者请参考</p><blockquote><p>Handbook of Computational Group Theory, Holt, D., Eick, B., O’Brien,E.</p></blockquote><p>中的 coset enumeration 一章。我个人认为这是讲解 Todd-Coxeter算法最棒的文献。</p><p>Todd-Coxeter 算法非常类似玩数独游戏，这里要填的表是一个变化的二维数组<span class="math inline">\(T\)</span>，<span class="math inline">\(T\)</span> 的行 <span class="math inline">\(i\)</span> 代表第 <span class="math inline">\(i\)</span> 个右陪集，<span class="math inline">\(T\)</span> 的列 <span class="math inline">\(j\)</span> 代表第 <span class="math inline">\(j\)</span> 个生成元 <span class="math inline">\(\rho_j\)</span>，<span class="math inline">\(T[i][j]\)</span> 的值等于 <span class="math inline">\(\rho_j\)</span> 右乘以第 <span class="math inline">\(i\)</span>个陪集后得到的陪集。初始时，我们知道肯定有一个陪集，就是 <span class="math inline">\(H\)</span>自身，还有没有其它的陪集我们不清楚。算法的主要流程就是根据 <span class="math inline">\(G\)</span> 和 <span class="math inline">\(H\)</span>的表现中包含的关系来发现新的陪集并填入表中，直到无法找到新的陪集为止。最终得到的<span class="math inline">\(T\)</span> 实际上是 <span class="math inline">\(G/H\)</span> 的 schreier 图的邻接矩阵，它记录了<span class="math inline">\(G/H\)</span> 的陪集间的乘法关系，由 <span class="math inline">\(T\)</span> 出发我们很容易求出这些陪集的 word表示。</p><div class="unnumbered statement example definition"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>设 <span class="math inline">\(G\)</span>是正方体的对称群，其表现为 <span class="math display">\[G =\langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span>子群 <span class="math inline">\(H=\langle \rho_1,\rho_2\rangle\)</span> 是初始顶点的稳定化子群，求 <span class="math inline">\(G/H\)</span> 的一组右陪集代表元。</p></div><p>我们先罗列一下这个数独游戏已知的关系：</p><p><strong>已知关系</strong>：</p><ol type="1"><li>对 <span class="math inline">\(H\)</span> 的任何生成字 <span class="math inline">\(w\)</span> 有 <span class="math inline">\(H\cdotw=H\)</span>，即 <span class="math inline">\(H\rho_1=H\rho_2=H\)</span>。注意此关系仅要求对<span class="math inline">\(H\)</span> 成立。</li><li>对任何陪集 <span class="math inline">\(K\)</span> 和 <span class="math inline">\(G\)</span> 的任何生成关系 <span class="math inline">\(r\)</span> 有 <span class="math inline">\(K\cdotr=K\)</span>，即 <span class="math inline">\(K\rho_i^2=K,i=0,1,2\)</span> 以及 <span class="math inline">\(K(\rho_0\rho_1)^4=K(\rho_1\rho_2)^3=K(\rho_0\rho_2)^2=K\)</span>。注意此关系要求对所有陪集成立。</li></ol><p>这些关系可以存储在两个列表里面，每个关系用一个数组表示。</p><p>第一个列表存储的是 <span class="math inline">\(H\)</span>的生成字，即</p><blockquote><p><strong><span class="math inline">\(H\)</span>的生成字列表</strong>：</p><ol start="0" type="1"><li>(1,)</li><li>(2,)</li></ol></blockquote><p>第二个列表存储的是 <span class="math inline">\(G\)</span>的生成关系，即</p><blockquote><p><strong><span class="math inline">\(G\)</span>的生成关系列表</strong>：</p><ol start="2" type="1"><li>(0, 0)</li><li>(1, 1)</li><li>(2, 2)</li><li>(0, 1, 0, 1, 0, 1, 0, 1)</li><li>(1, 2, 1, 2, 1, 2)</li><li>(0, 2, 0, 2)</li></ol></blockquote><p>其中每条关系前面的数字是我们加上的编号以便于称呼。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在非 Coxeter 群的情形还要把每个生成元的逆也作为生成元加入，其在<span class="math inline">\(T\)</span> 中也占据一列，所以实际上 <span class="math inline">\(T\)</span> 的列的个数要 <span class="math inline">\(\times2\)</span>。但是在 Coxeter群的情形每个生成元是 2阶的，其逆元素等于自身，所以不需要额外考虑逆元素。</p></div><p>初始时刻表格 <span class="math inline">\(T\)</span> 是这样的：</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>其中 <span class="math inline">\(H_0\)</span> 代表 <span class="math inline">\(H\)</span> 对应的陪集。程序首先验证 <span class="math inline">\(H_0\)</span> 所在的行满足第一个关系列表 （<span class="math inline">\(H\)</span>的生成字列表，随后此列表可以被丢弃），然后依次从上到下扫描 <span class="math inline">\(T\)</span> 的每一行，假设当前扫描的是第 <span class="math inline">\(i\)</span> 行，对应的陪集为 <span class="math inline">\(H_i\)</span>，程序验证确保对第二个列表 （<span class="math inline">\(G\)</span> 的生成关系列表） 中的每条关系 <span class="math inline">\(w\)</span>，<span class="math inline">\(H_i\)</span> 满足 <span class="math inline">\(H_iw=H_i\)</span>，这个过程中可能发现新的陪集，也可能发现已有的某些陪集是重复的，也有可能需要强行定义新的陪集来使得这个验证能够完成。</p><hr><p>我们来开始扫描 <span class="math inline">\(H_0\)</span>所在的行：首先检查第一个列表中的关系，<strong>这个列表仅在扫描 <span class="math inline">\(H_0\)</span>时使用一次，扫描完就可以丢弃</strong>。</p><p>(1). 对第 0 条关系 <span class="math inline">\(H_0\rho_1=H_0\)</span>，即 <span class="math inline">\(T[0][1]=0\)</span>。对第 1 条关系 <span class="math inline">\(H_0\rho_2=H_0\)</span>，即 <span class="math inline">\(T[0][2]=0\)</span>，这时 <span class="math inline">\(T\)</span> 变成了</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><p>第一个列表扫描完毕，接下来扫描第二个列表。</p><p>(2). 对第 2 条关系 <span class="math inline">\(H_0\rho_0^2=H_0\)</span>，由于 <span class="math inline">\(H_0\rho_0\)</span> 还不知道，我们将其定义为新陪集<span class="math inline">\(H_1\)</span> 并将 1 填入 <span class="math inline">\(T[0][0]\)</span> 位置，此外还要为 <span class="math inline">\(H_1\)</span> 开辟新的一行：</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>每次定义新陪集时，比如定义 <span class="math inline">\(H_i\rho_j=H_k\)</span>，我们同时自动得到了与之对称的关系<span class="math inline">\(H_k\rho_j=H_i\rho_j^2=H_i\)</span>，因此每次填表时我们都填写一对数字而不是一个，这样可以保证表格<span class="math inline">\(T\)</span> 的 “对称性”。</p></div><p>(3). 第 3 条和第 4 条关系已经满足，继续。</p><p>(4). 第 5 条关系，<span class="math inline">\(H_0\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1=H_0\)</span>，我们已经知道<span class="math inline">\(H_0\rho_0=H_1\)</span> 但是 <span class="math inline">\(H_1\rho_1\)</span> 还不知道，将其定义为 <span class="math inline">\(H_2\)</span>，于是 <span class="math inline">\(T\)</span> 中又添两项，并开辟新的一行给 <span class="math inline">\(H_2\)</span>：</p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>但是 <span class="math inline">\(H_2\rho_0\)</span>还是不知道，所以继续定义 <span class="math inline">\(H_2\rho_0=H_3\)</span>，于是 <span class="math inline">\(T\)</span> 变成</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>于是现在关系变成了</p><p><span class="math display">\[\underbrace{\overbrace{\underbrace{H_0\rho_0}_{=H_1}\,\rho_1}^{=H_2}\,\rho_0}_{=H_3}\,\rho_1\rho_0\rho_1\rho_0\rho_1=H_0.\]</span></p><p>但是 <span class="math inline">\(H_3\rho_1\)</span>还是不知道，你可能会想把它继续定义为新的陪集 <span class="math inline">\(H_4\)</span>，然后继续扫描。<strong>这样做不是不可以，但是每次都定义新陪集会生成大量重复的陪集，导致<span class="math inline">\(T\)</span>增长的非常快，对更复杂的群非常耗费计算资源</strong>。我们采用更聪明的办法：倒着扫描整个关系，即从右到左扫描<span class="math inline">\(H_0\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1=H_0\)</span>这条关系。记住我们现在已经正向 （从左到右） 扫描到了下面的位置： <span class="math display">\[\underbrace{H_0\rho_0\rho_1\rho_0}_{=H_3}\,\rho_1|\rho_0\rho_1\rho_0\rho_1=H_0.\]</span>反向扫描意味着我们把上式左边末尾的 <span class="math inline">\(\rho_0\rho_1\rho_0\rho_1\)</span>挪到右边去，变形为 <span class="math display">\[\underbrace{H_0\rho_0\rho_1\rho_0}_{=H_3}\,\rho_1=\underbrace{H_0\rho_1}_{=H_0}\rho_0\rho_1\rho_0=H_0\rho_0\rho_1\rho_0=H_3.\]</span> 从而 <span class="math inline">\(H_3\rho_1=H_3\)</span>。这样通过反向扫描我们就推断出了<span class="math inline">\(H_3\rho_1\)</span>的值，避免了定义冗余的陪集。按照 Holt 书中的说法这叫做一个deduction。这时 <span class="math inline">\(T\)</span> 为</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在实际的程序实现中，我们总是从关系的两头同时开始扫描，直到它们相遇为止。</p></div><p>(5). 关系 6 已经满足，继续。</p><p>(6). 对关系 7 <span class="math inline">\(H_0\rho_0\rho_2\rho_0\rho_2=H_0\)</span>，从两头扫描我们得到<span class="math display">\[\underbrace{H_0\rho_0}_{=H_1}\,\rho_2=\underbrace{\overbrace{H_0\rho_2}^{=H_0}\rho_0}_{=H_1}.\]</span>即 <span class="math inline">\(H_1\rho_2=H_1\)</span>，我们又得到了一个deduction，从而 <span class="math inline">\(T\)</span> 变成</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>至此对 <span class="math inline">\(H_0\)</span>的扫描全部完成，我们转入扫描 <span class="math inline">\(H_1\)</span>所在的行。</p><hr><p><strong>注意：从现在起至程序结束，我们不再使用第一个列表</strong>。</p><p>下面开始扫描 <span class="math inline">\(H_1\)</span> 所在的行。</p><p>(1). 经检查关系 2, 3, 4, 5 已经满足，继续。</p><p>(2). 对关系 6 有 <span class="math inline">\(H_1\rho_1\rho_2\rho_1\rho_2\rho_1\rho_2=H_1\)</span>，其中<span class="math inline">\(H_1\rho_1=H_2\)</span> 已知但 <span class="math inline">\(H_2\rho_2\)</span> 未知。反向的扫描也会卡在这里：<span class="math display">\[\underbrace{H_1\rho_1}_{=H_2}\rho_2\rho_1=H_1\rho_2\rho_1\rho_2=H_2\rho_2.\]</span>所以我们定义新陪集 <span class="math inline">\(H_2\rho_2=H_4\)</span>，于是 <span class="math inline">\(H_4\rho_1=H_4\)</span>，从而此时 <span class="math inline">\(T\)</span> 为</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr></tbody></table><p>(3). 关系 7 已经满足，从而 <span class="math inline">\(H_1\)</span>检查完毕，接下来开始扫描 <span class="math inline">\(H_2\)</span>的行。</p><hr><p>下面开始扫描 <span class="math inline">\(H_2\)</span> 的行。</p><p>(1). 经检查关系 2, 3, 4, 5, 6 都已经满足，继续。</p><p>(2). 对关系 7 有 <span class="math inline">\(H_2\rho_0\rho_2\rho_0\rho_2=H_2\)</span>，两边同时扫描的结果为：<span class="math display">\[\underbrace{H_2\rho_0}_{=H_3}\rho_2\rho_0=H_2\rho_2=H_4.\]</span>即 <span class="math inline">\(H_3\rho_2\rho_0=H_4\)</span>，但是继续正向扫描<span class="math inline">\(H_3\rho_2\)</span> 不知道，继续反向扫描<span class="math inline">\(H_4\rho_0\)</span> 不知道。定义新陪集 <span class="math inline">\(H_3\rho_2=H_5\)</span>，于是 <span class="math inline">\(H_5\rho_0=H_4\)</span>，我们又可以填入两对 4个数字，此时 <span class="math inline">\(T\)</span> 为：</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">3</td></tr></tbody></table><p><span class="math inline">\(H_2\)</span> 扫描完毕，下面扫描 <span class="math inline">\(H_3\)</span> 的行。</p><hr><p>我把 <span class="math inline">\(H_3, H_4, H_5\)</span>的扫描过程留给你作为练习，<span class="math inline">\(H_3\)</span>扫描结束后你得到的 <span class="math inline">\(T\)</span>应该如下图：</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr></tbody></table><p><span class="math inline">\(H_4\)</span> 扫描结束后你得到的 <span class="math inline">\(T\)</span> 应该如下图：</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><span class="math inline">\(H_5\)</span> 的扫描给不出新的信息。</p><p>扫描 <span class="math inline">\(H_6\)</span> 时，关系 2, 3, 4, 5, 6都已经满足，由关系 7 <span class="math inline">\(H_6\rho_0\rho_2\rho_0\rho_2=H_6\)</span> 可得deduction <span class="math inline">\(H_7\rho_2=H_7\)</span>，于是 <span class="math inline">\(T\)</span> 可以补全为</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td></tr></tbody></table><p>扫描 <span class="math inline">\(H_7\)</span>发现所有关系都已经满足。</p><p>至此 <span class="math inline">\(T\)</span>的空白位置都已经填满，没有新的陪集可以发现，数独游戏结束，这时得到的<span class="math inline">\(T\)</span> 就是 <span class="math inline">\(G/H\)</span> 的最终乘法表。</p><p>由此利用宽度优先搜索不难得出陪集间的关系为： <span class="math display">\[\begin{array}{l}H_0 = H_0\cdot e,\\H_1=H_0\cdot\rho_0,\\H_2=H_1\cdot\rho_1=H_0\cdot\rho_0\rho_1,\\H_3=H_2\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0,\\H_4=H_2\cdot\rho_2=H_0\cdot\rho_0\rho_1\rho_2,\\H_5=H_3\cdot\rho_2=H_0\cdot \rho_0\rho_1\rho_0\rho_2,\\H_6=H_5\cdot\rho_1=H_0\cdot \rho_0\rho_1\rho_0\rho_2\rho_1,\\H_7=H_6\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0\rho_2\rho_1\rho_0.\end{array}\]</span></p><p>从而其一组陪集代表元可以选为 <span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span></p><p>这正是我们前面看到过的。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个例子看似有点长，但还是一个比较简单的例子，其中并没有出现已知陪集重复的情形（Holt的书中称之为coincidence）。这种情形的处理麻烦一些，因为一旦出现重复的陪集，就有可能顺藤摸瓜找到更多重复的陪集。这时就要立刻暂停扫描，流程跳转到处理coincidence：开辟一个栈来存放已知的coincidence，每次弹出一对，将它们合并，然后把新发现的 coincidence压入栈中。</p></div><h1 id="星状多胞体的计算">星状多胞体的计算</h1><p>星状多胞体也可以使用 Wythoff构造法来生成，但是直接套用上面的方法一般是行不通的，我们需要在生成元中加入额外的生成关系。</p><p>这里以 <a href="https://en.wikipedia.org/wiki/Great_dodecahedron">Greatdodecahedron</a> 为例来说明：其 Coxeter-Dynkin 图为</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/coxeter552.svg" width="200"></p><p>于是三面镜子的法向量夹角分别为 <span class="math inline">\(\pi-2\pi/5, \pi/2,\pi-\pi/5\)</span>。如果我们仍然沿用以前的分析，会得出其对称群的表现为<span class="math display">\[K=\langle\tau_0,\tau_1,\tau_2 \|\  \tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=(\tau_0\tau_2)^2=1\rangle.\]</span></p><p>这是一个无限群，而且顶点的稳定化子的商群也是无限的，所以还想按以前的方法计算就行不通了。</p><p>实际上我们只要在生成关系中再加上一条 <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>即可，即对称群的表现为</p><p><span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>注意到我使用了字母 <span class="math inline">\(\tau\)</span>来表示反射，<span class="math inline">\(K\)</span> 表示 Greatdodecahedron的对称群，这个记号选择是有意的。这是怎么回事呢？先看视频：</p><video src="/images/polytopes/great-dodecahedron.mp4" width="480" controls=""></video><p>（请忽略左边错误的 Coxeter 图，这个 ui 界面我改不动）</p><p>由视频可见，Great dodecahedron 与正二十面体 (icosahedron)共用相同的顶点，并且看起来 Great dodecahedron 可以通过在 icosahedron表面挖一些三角形的洞得到。这个结论也可以推广：一般地如果星状多面体的洞是一个有<span class="math inline">\(h\)</span>条边的多边形，则对应的额外生成关系就是 <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^h=1\)</span>。</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/star.png" width="600"></p><p>在上图中，<span class="math inline">\(\Delta ABC\)</span>是正二十面体的基本区域，三个内角分别是 <span class="math inline">\(\angle CAB=\pi/5\)</span>，<span class="math inline">\(\angle CBA=\pi/2\)</span>，<span class="math inline">\(\angle ACB=\pi/3\)</span>，<span class="math inline">\(\rho_0,\rho_1,\rho_2\)</span> 分别是关于弧 <span class="math inline">\(BC, AC, AB\)</span>的反射。正二十面体的对称群的表现为 <span class="math display">\[G =\langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^3=(\rho_1\rho_2)^5=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p>Great dodecahedron 可以这样得到：沿着正二十面体的边从顶点 <span class="math inline">\(Q\)</span> 走到 <span class="math inline">\(A\)</span>，右手边的面是三角形 <span class="math inline">\(\Delta OAQ\)</span>，接下来的第一条边应该是 <span class="math inline">\(AO\)</span>，我们跳过这条边，选择第二条边 <span class="math inline">\(AK\)</span>，到达 <span class="math inline">\(K\)</span> 后继续选择右手边的第二条边，这样绕着<span class="math inline">\(O\)</span> 一圈下来共经过 5条边，它们正好围成 Great dodecahedron的一个面。对正二十面体的其它边也如此操作会得到 Great dodecahedron其它的面。</p><p>像这样对一个多面体，保持它的顶点和边的集合不变，但是每次选择右手边的第<span class="math inline">\(k\)</span>个边走下去绕一圈获得一个面，这样构造新多面体的方法叫做 <strong>Facetting手术</strong>。在我们这个项目中 <span class="math inline">\(k\)</span>总是等于 2。</p><p>我们来导出正二十面体的对称群 <span class="math inline">\(G\)</span>和 Great dodecahedron 的对称群 <span class="math inline">\(K\)</span>之间的关系。</p><p>来看三角形 <span class="math inline">\(\DeltaOAB\)</span>，它的三个内角分别是 <span class="math inline">\(\angleOAB=2\pi/5\)</span>，<span class="math inline">\(\angleOBA=\pi/2\)</span>，<span class="math inline">\(\angleAOB=\pi/5\)</span>，它包含三个与 <span class="math inline">\(\DeltaABC\)</span> 全等的三角形，关于其三条边 <span class="math inline">\(OA,OB,AB\)</span> 的反射分别是 <span class="math inline">\(\tau_1=\rho_1\rho_2\rho_1,\tau_0=\rho_0,\tau_2=\rho_2\)</span><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>。</p><p>Facetting 操作 <span class="math inline">\(\varphi_k\)</span>用群的语言来描述就是（记住 <span class="math inline">\(k=2\)</span>）<span class="math display">\[G=\langle\rho_0,\rho_1,\rho_2\rangle\xrightarrow{\ \varphi_k\}\langle\rho_0,\rho_1(\rho_2\rho_1)^{k-1},\rho_2\rangle=\langle\tau_0,\tau_1,\tau_2\rangle=K.\]</span>一般来说 <span class="math inline">\(K\)</span> 是 <span class="math inline">\(G\)</span> 的子群，但在这里 <span class="math inline">\(G\)</span> 和 <span class="math inline">\(K\)</span> 就是同一个群。我们不解释为什么 <span class="math inline">\(G=K\)</span>，这里只承认这一点，然后借助这个事实来说明<span class="math inline">\(K\)</span> 就是 Great dodecahedron的对称群。</p><p>首先 <span class="math inline">\(\langle \tau_1,\tau_2\rangle=\langle\rho_1,\rho_2\rangle\)</span> 是顶点 <span class="math inline">\(A\)</span> 的稳定化子群，所以 Great dodecahedron和正二十面体的顶点集是一样的。但 <span class="math inline">\(\tau_1\tau_2\)</span> 是一个角度为 144度的旋转，这一点和 <span class="math inline">\(\rho_1\rho_2\)</span>是一个 72 度的旋转不同，所以 Great dodecahedron 的 vertex configure是一个五角星，而不像正二十面体那样是一个五边形。</p><p>其次 <span class="math inline">\(\langle\tau_0,\tau_2\rangle=\langle\rho_0,\rho_2\rangle\)</span>为边 <span class="math inline">\(AQ\)</span> 的稳定化子群，所以 Greatdodecahedron 的边集和正二十面体也是一样的。</p><p>它俩的区别在于边组成面的方式不一样。<span class="math inline">\(\langle\tau_0,\tau_1\rangle\)</span> 是 Greatdodecahedron 面的稳定化子群，注意到 <span class="math inline">\(\tau_1\)</span> 是关于 <span class="math inline">\(AO\)</span> 的反射，它会把 <span class="math inline">\(AQ\)</span> 映射为 <span class="math inline">\(AK\)</span>，这正对应选择第 <span class="math inline">\(k\)</span> 条边的操作。<span class="math inline">\(\tau_0\tau_1\)</span> 是一个绕着顶点 <span class="math inline">\(O\)</span> 的角度为 <span class="math inline">\(2\pi/5\)</span> 的旋转，所以 <span class="math inline">\(AQ\)</span> 在子群 <span class="math inline">\(\langle \tau_0,\tau_1\rangle\)</span> 作用下会绕<span class="math inline">\(O\)</span> 转一圈，正对应 Facetting操作得到的一个面。</p><p>我们来找出 <span class="math inline">\(\tau_0,\tau_1,\tau_2\)</span>之间隐藏的一条生成关系：</p><p>注意到 <span class="math inline">\(\tau_1\tau_2\tau_1=\tau_1\rho_2\tau_1\)</span>是关于 <span class="math inline">\(AP\)</span> 的反射，它和 <span class="math inline">\(\tau_0=\rho_0\)</span> 的复合是绕着 <span class="math inline">\(P\)</span> 点角度为 <span class="math inline">\(2\pi/3\)</span> 的旋转，所以 <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>。加入这个额外的生成关系得到的就是<span class="math inline">\(K\)</span> 的正确的表现： <span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>所以我们就可以对 <span class="math inline">\(K\)</span>照搬之前的绘制步骤了。</p><p>这个额外的生成关系其实也有背后的解释：对 Faceting手术得到的新多面体再进行一次 Faceting 手术是可以回到原来的多面体的。对great dodecahedron每次沿着它的边，选择当前离开的边的右手第二个边走下去，即从 <span class="math inline">\(Q\)</span> 走到 <span class="math inline">\(A\)</span> 时，不是选择 <span class="math inline">\(AK\)</span> 继续走下去，而是选择 <span class="math inline">\(AO\)</span>，这样走下去又会得到正二十面体的三角形的面，这对应的就是额外的生成关系中的指数3。</p><p>这一点从群上也可以得到验证。</p><p><span class="math display">\[K=\langle\tau_0,\tau_1,\tau_2\rangle\xrightarrow{\ \varphi_2\}\langle\tau_0,\tau_1\tau_2\tau_1,\tau_2\rangle=\langle\rho_0,\rho_2\rho_1\rho_2,\rho_2\rangle=G.\]</span></p><blockquote><p>关于 Faceting 手术可以在 McMullen 和 Schulte 所著的 <a href="https://doi.org/10.1017/CBO9780511546686">Abstract RegularPolytopes</a> 一书中找到。</p></blockquote><h1 id="snub-cube-的计算">Snub cube 的计算</h1><p>如果你理解了上面的内容，snub 多面体的情形也是不难理解的。我以 snubcube 来说明：</p><p>Snub cube 和 cube 的区别在于它的对称群只包含旋转，我们已经看到 cube的对称群 <span class="math inline">\(G\)</span> 的表现为 <span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span>它有 48 个元素，其中 24 个是旋转。这些旋转可以由 <span class="math inline">\(r_0=\rho_0\rho_1,r_1=\rho_1\rho_2,r_2=\rho_0\rho_2\)</span> 生成 （由于 <span class="math inline">\(r_0r_1=r_2\)</span> 因此实际上可以由 <span class="math inline">\(r_0\)</span> 和 <span class="math inline">\(r_1\)</span> 生成）。这 24 个旋转就构成了 Snubcube 的对称群 <span class="math inline">\(\widetilde{G}\)</span>。</p><p>不难写出 <span class="math inline">\(\widetilde{G}\)</span> 的表现为<span class="math display">\[\widetilde{G}=\langle r_0,r_1\ |\r_0^4=r_1^3=(r_0r_1)^2=1\rangle.\]</span></p><p>利用 Todd-Coxeter 算法不难求出这个群的所有 24 个元素：</p><p><span class="math display">\[\begin{array}{lll}e&amp;r_{0}&amp;r_{0}r_{0}\\r_{0}r_{0}r_{0}&amp;r_{1}&amp;r_{1}r_{1}\\r_{0}r_{1}&amp;r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{1}\\r_{0}r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}\\r_{1}r_{0}r_{0}&amp;r_{1}r_{0}r_{0}r_{0}&amp;r_{1}r_{1}r_{0}\\r_{1}r_{1}r_{0}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}\\r_{0}r_{0}r_{1}r_{1}r_{0}&amp;r_{1}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}r_{0}r_{1}r_{1}\\r_{1}r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{1}r_{0}r_{0}r_{1}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}r_{1}\end{array}\]</span></p><p>注意在 snub 的情形初始顶点 <span class="math inline">\(v_0\)</span>不属于任何镜面，所以其稳定化子群只有单位元 1，即每个 <span class="math inline">\(g\in\widetilde{G}\)</span> 把 <span class="math inline">\(v_0\)</span> 变换为不同的顶点。将它们作用在 <span class="math inline">\(v_0\)</span> 上即得 snub cube 的所有顶点。</p><p>我们现在利用轨道—稳定化子的理论来求 snub cube 的边。snub cube的边也是分类型的，每个 <span class="math inline">\(r_i(i=0,1,2)\)</span>作用在 <span class="math inline">\(v_0\)</span> 上可得一个类型为 <span class="math inline">\(i\)</span> 的边 <span class="math inline">\(e_i=(v_0, v_0\cdot r_i)\)</span> <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>，我们来定出 <span class="math inline">\(e_i\)</span> 的稳定化子群 <span class="math inline">\(H\)</span>。</p><p>首先注意到任何 <span class="math inline">\(g\in G\)</span> 如果保持<span class="math inline">\(e_i\)</span>不变，则只有两种可能，要么它保持 <span class="math inline">\(e_i\)</span> 上每个点不变，要么它将 <span class="math inline">\(e_i\)</span> 关于其中点进行翻转。这一点对 <span class="math inline">\(g\in\widetilde{G}\)</span> 自然也成立。所以若<span class="math inline">\(g\in\widetilde{G}\)</span> 保持 <span class="math inline">\(e_i\)</span> 不变，则要么 <span class="math inline">\(v_0g = v_0, v_0r_i=v_0r_ig\)</span>，要么 <span class="math inline">\(v_0g = v_0r_i,v_0r_ig=v_0\)</span>。前一种情形说明<span class="math inline">\(g\)</span> 属于 <span class="math inline">\(v_0\)</span>的稳定化子群从而只能是单位元；后一种情形说明 <span class="math inline">\(r_ig\)</span> 和 <span class="math inline">\(r_ig^{-1}\)</span> 都属于 <span class="math inline">\(v_0\)</span> 的稳定化子群从而 <span class="math inline">\(r_ig=r_ig^{-1}=1\)</span>，即 <span class="math inline">\(g=r_i\)</span> 且 <span class="math inline">\(r_i^2=1\)</span>。总之我们证明了只有在 <span class="math inline">\(r_i^2=1\)</span> 时 <span class="math inline">\(e_i\)</span>才有非平凡的稳定化子群，这时稳定化子群是二阶循环群 <span class="math inline">\(\langle r_i\rangle\)</span>。</p><p>于是 snub cube 的类型为 <span class="math inline">\(r_0\)</span> 和<span class="math inline">\(r_1\)</span> 的边的个数都是 24/1=24个；类型为 <span class="math inline">\(r_2\)</span> 的边的个数为 24/2=12个，从而 snub cube 总共有 24+24+12=60 条边。</p><p>snub cube 的面可以这样求：由于 <span class="math inline">\(r_0^4=1\)</span> 所以 <span class="math inline">\(r_0\)</span> 可以生成一个正四边形的面，类似地由于<span class="math inline">\(r_1^3=1\)</span> 所以 <span class="math inline">\(r_1\)</span> 可以生成一个正三角形的面，而由于<span class="math inline">\(r_2^2=1\)</span> 所以 <span class="math inline">\(r_2\)</span>生成的面是退化的。这种由单个旋转生成的面的稳定化子群是很好求的：若 <span class="math inline">\(g\)</span> 保持 <span class="math inline">\(r_i\)</span> 生成的面不变，则其必然把某个形如<span class="math inline">\(v_0r_i^k\)</span> 的顶点变换为 <span class="math inline">\(v_0\)</span>，即 <span class="math inline">\(g=r_i^{-k}\)</span> 是 <span class="math inline">\(r_i\)</span> 的某次幂，反之易见 <span class="math inline">\(r_i\)</span>的任何幂都保持此面不变，所以其稳定化子群即为循环群 <span class="math inline">\(\langle r_i\rangle\)</span>。</p><p>于是 <span class="math inline">\(r_0\)</span> 生成的面的个数为24/4=6，<span class="math inline">\(r_1\)</span> 生成的面的个数为24/3=8，<span class="math inline">\(r_2\)</span>生成的面都退化因而个数是 0，总计 14 个面。</p><p>小心！我们还漏掉了一种三角面，它源自 <span class="math inline">\(r_0r_1=r_2\)</span> 这个关系。考虑 <span class="math inline">\(\{v_0, v_0r_1, v_0r_2\}\)</span>这三个顶点，这三个顶点中 <span class="math inline">\((v_0,v_0r_1)\)</span> 构成一条类型为 <span class="math inline">\(r_1\)</span> 的边， <span class="math inline">\((v_0,v_0r_2)\)</span> 构成一条类型为 <span class="math inline">\(r_2\)</span> 的边，而 <span class="math inline">\(r_0r_1=r_2\)</span> 这个关系告诉我们 <span class="math display">\[(v_0, v_0r_0)\xrightarrow{\ r_1\ }(v_0r_1,v_0r_0r_1) = (v_0r_1, v_0r_2).\]</span> 即 <span class="math inline">\((v_0r_1, v_0r_2)\)</span> 是一条类型为 <span class="math inline">\(r_0\)</span> 的边，它是由将 <span class="math inline">\(r_1\)</span> 作用在类型为 <span class="math inline">\(r_0\)</span> 的初始边 <span class="math inline">\((v_0, v_0r_0)\)</span> 上得到的，于是 <span class="math inline">\(\{v_0, v_0r_1, v_0r_2\}\)</span>构成一个三角形的三个顶点，其三条边在对称群作用下属于不同的轨道，所以这个三角形的稳定化子必然保持每条边不变，从而只能是恒等元，从而这样的面有24/1=24 个。</p><p>于是 snub cube 一共有 14+24=38 个不同的面。</p><p>这里介绍的方法也适用于其它的 snub 多面体以及 snub 24-cell。</p><h1 id="多面体的顶点投影到-coxeter-平面">多面体的顶点投影到 Coxeter平面</h1><p>项目中还实现了一个<code>draw_on_coxeter_plane(*args, **kwargs)</code>方法，用于绘制将多面体的顶点投影到其 Coxeter平面上后得到的图案，例如下图显示的是将 600-cell 的 120 个顶点投影到其Coxeter 平面上的结果：</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/600-cell.svg" width="350"></p><p>你可以和 <a href="https://en.wikipedia.org/wiki/600-cell#2D_projections">wikipedia上的效果</a> 比较一下。</p><h1 id="附录手算-todd-coxeter">附录：手算 Todd-Coxeter</h1><p>对简单的群，Todd-Coxeter 算法完全可以用手算快速得出结果。我非常推荐Borcherds 的视频，他的演示非常精彩：</p><iframe width="560" height="315" src="https://www.youtube.com/embed/BHezLvEH1DU?si=fw7X2z37wZEYcIG-" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe><p>仿照 Borcherds 的方法，前面正方形的例子可以很快写出来：</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/todd-coxeter.svg" width="600"></p><p>我来解释一下步骤：我们将画出一个有限图，图的每个顶点代表 <span class="math inline">\(H=\langle s_0,s_1\rangle\)</span>的一个陪集，每个顶点有三条不同颜色的边，表示此陪集在生成元 <span class="math inline">\(s_i\)</span> 作用下的结果。</p><ol type="1"><li>首先我们在空白纸上画出第一个顶点，它对应的陪集是 <span class="math inline">\(H=H_0\)</span> 自身。<span class="math inline">\(H\)</span> 包含 <span class="math inline">\(s_0,s_1\)</span>，所以红、绿边是自边。<span class="math inline">\(s_2\)</span>，即蓝色的边，会把它映射为一个新顶点<span class="math inline">\(H_1\)</span>。</li><li>从 <span class="math inline">\(H_0\)</span>出发，利用红蓝交换，可得红色保持 <span class="math inline">\(H_1\)</span> 不动。但是绿蓝不交换，所以绿色将<span class="math inline">\(H_1\)</span> 映射为新顶点 <span class="math inline">\(H_2\)</span>。</li><li><span class="math inline">\((\text{绿蓝})^3=1\)</span>，即 <span class="math inline">\(H_2\xrightarrow{(\text{绿蓝})^3}H_2\)</span>，所以<span class="math display">\[H_2\xrightarrow{\text{绿}}H_1\xrightarrow{\text{蓝}} H_0\xrightarrow{\text{绿}}H_0\xrightarrow{\text{蓝}} H_1\xrightarrow{\text{绿}}H_2\xrightarrow{\text{蓝}} H_2.\]</span> 所以蓝色保持 <span class="math inline">\(H_2\)</span> 不动。红绿不交换，所以红色将 <span class="math inline">\(H_2\)</span> 映射为新顶点 <span class="math inline">\(H_3\)</span>。</li><li>仿照上面的分析继续下去，可以发现到 <span class="math inline">\(H_5\)</span> 时，三种颜色的边不会给出新顶点。所以<span class="math inline">\(\{H_0,\ldots,H_5\}\)</span> 就是 <span class="math inline">\(G/H\)</span> 的全部陪集。</li></ol><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>你可能要问了，你怎么就敢肯定这个群的表现恰好就包含这些生成关系，而不会包含其它什么隐藏的生成关系呢？这是个好问题，回答起来并不容易，答案是对凸的多胞体而言这些生成关系确实给出了其对称群的一个表现，但是对星状多面体而言则未必。事实上星状多面体都和某个凸多面体有相同的对称群，但是群表现是不一样的（需要补上额外的生成关系）。这其中的根本原因是凸多面体的镜面法向量之间的夹角都形如<span class="math inline">\(\pi-\pi/m\)</span>，这里 <span class="math inline">\(m\)</span>是整数，这保证了所有镜面围成的凸锥构成一个基本区域。而星状多面体的镜面所夹的二面角至少有一个形如<span class="math inline">\(\pi-\pi/p\)</span>，其中 <span class="math inline">\(p\)</span>是一个非整数的有理数，这时所有镜面围成的凸锥并不是基本区域，在对称群的作用下这个凸锥会被覆盖若干次。见Vinberg 的文章 “Discrete linear groups generated by reflections” 和Coxeter 的著作 “The beauty of geometry: twelve essays”.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>以本文介绍的知识，这里似乎应该说 <span class="math inline">\(H\)</span> 保持 <span class="math inline">\(v_0\)</span> 不变，从而 <span class="math inline">\(v_0\)</span> 的稳定化子群包含 <span class="math inline">\(H\)</span>，怎么能断言 <span class="math inline">\(v_0\)</span> 的稳定化子群就等于 <span class="math inline">\(H\)</span> 呢？这实际上是 Coxeter 群的一个性质：在Coxeter 群 <span class="math inline">\(W\)</span>的标准几何实现中，对其基本区域闭包中的任何一点 <span class="math inline">\(v\)</span>，<span class="math inline">\(v\)</span>的稳定化子群是一个标准椭圆子群，其生成元恰好由超平面包含 <span class="math inline">\(v\)</span> 的那些单反射组成。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p>道理与注解 2 类似。易见边 <span class="math inline">\(e\)</span> 的稳定化子群 <span class="math inline">\(H\)</span> 就是 <span class="math inline">\(e\)</span>的中点的稳定化子群，这也是一个标准椭圆子群，由那些包含 <span class="math inline">\(e\)</span>的中点的镜面对应的单反射生成。这样的镜面只能是 <span class="math inline">\(\rho_i\)</span> 和那些与 <span class="math inline">\(m_i\)</span> 垂直且包含 <span class="math inline">\(v_0\)</span> 的镜面。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>解释与注解 2, 3 类似。<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p>有这么一个结论：如果 <span class="math inline">\(s_\alpha\)</span> 是关于镜面 <span class="math inline">\(\alpha\)</span> 的反射，镜面 <span class="math inline">\(\beta=g\alpha\)</span>，这里 <span class="math inline">\(g\)</span> 是空间中的可逆线性变换，则关于 <span class="math inline">\(\beta\)</span> 的反射 <span class="math inline">\(s_\beta=gs_\alpha g^{-1}\)</span>。令 <span class="math inline">\(\alpha=AB\)</span>，<span class="math inline">\(g=\rho_1\)</span>，<span class="math inline">\(\beta=AD\)</span> 即为结论。<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p>注意本文没有解释为什么这些边确实是不同类型的，即它们在对称群的作用下处于不同的轨道。严格说明这一点也要用到Coxeter 群的几何实现。<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Möbius 变换的分类与上半双曲空间的等距</title>
      <link href="/mobius-h3space/"/>
      <url>/mobius-h3space/</url>
      
        <content type="html"><![CDATA[<p>本文的想法源自 Roice Nelson 的 <a href="https://www.shadertoy.com/view/MstcWr">shadertoy项目</a>，我觉得他的创意很棒，就是效果有点糙，于是 <a href="https://www.shadertoy.com/view/4scfR2">动手改进了一番</a>。乍一看，这个动画的场景很简单，其实它背后的数学并不平凡。</p><p>这个动画从三个角度了演示 Möbius 变换，这三个角度是密切相关的：</p><ol type="1"><li>Möbius 变换作为扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 到自身的全纯函数。</li><li>Möbius 变换作为 Riemann 球面 <span class="math inline">\(S^2\)</span> 到自身的全纯函数。</li><li>Möbius 变换作为上半双曲空间中的等距变换。</li></ol><p>本文只作概括性的介绍，并不展开详细的数学证明。读者可以参考下面的资料：</p><blockquote><ol type="1"><li><a href="https://en.wikipedia.org/wiki/M%C3%B6bius_transformation">维基百科</a>.</li><li><span class="citation" data-cites="Needham1997">Needham (<a href="#ref-Needham1997" role="doc-biblioref">1997</a>)</span> .</li><li><span class="citation" data-cites="indra">Mumford, Series, andWright (<a href="#ref-indra" role="doc-biblioref">2002</a>)</span>,chapter 3.</li><li><span class="citation" data-cites="palka1991">Palka (<a href="#ref-palka1991" role="doc-biblioref">1991</a>)</span>, chapter IX,section 2.</li></ol></blockquote><p>本文的动画应该可以帮助你更好地理解这些资料中的内容。</p><span id="more"></span><h1 id="预备知识之正交圆族">预备知识之正交圆族</h1><p>设 <span class="math inline">\(z_1,z_2\)</span>是复平面上的两点，我们考虑两个不同的圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span>：</p><ol type="1"><li><span class="math inline">\(\mathcal{C}_1\)</span> 由所有同时过<span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 的圆组成（包含过 <span class="math inline">\(z_1,z_2\)</span> 的直线）。</li><li><span class="math inline">\(\mathcal{C}_2\)</span> 由所有使得 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 关于 <span class="math inline">\(C\)</span> 互为反演点的圆 <span class="math inline">\(C\)</span> 组成（包含线段 <span class="math inline">\([z_1,z_2]\)</span> 的垂直平分线）。</li></ol><p>则圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 中的任何圆<span class="math inline">\(C_1\)</span> 与 <span class="math inline">\(\mathcal{C}_2\)</span> 中的任何圆 <span class="math inline">\(C_2\)</span> 正交（交点处的切线互相垂直）。</p><p>我们将考察当 <span class="math inline">\(z_1,z_2\)</span> 是一个Möbius 变换 <span class="math inline">\(M\)</span> 的两个不动点时，<span class="math inline">\(M\)</span> 作用在 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span> 上的效果。</p><h1 id="möbius-变换的共轭分类">Möbius 变换的共轭分类</h1><p>一个 Möbius 变换 <span class="math inline">\(M\)</span>是一个分式线性变换，它将扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 一对一地映射为自身：<span class="math display">\[M(z) = \frac{az+b}{cz+d},\quada,b,c,d\in\mathbb{C},ad-bc\ne0, z\in \hat{\mathbb{C}}.\]</span> 所有的Möbius 变换构成一个群 <span class="math inline">\({\rmPSL}_2(\mathbb{C})\)</span>。</p><p>我们称两个 Möbius 变换 <span class="math inline">\(M_1,M_2\)</span>是共轭的，当且仅当存在 <span class="math inline">\(g\in{\rmPSL}_2(\mathbb{C})\)</span> 使得 <span class="math display">\[M_1=gM_2g^{-1}.\]</span></p><p>可以证明，在共轭的意义下，任何非恒等元的 Möbius变换都属于下面四种类型之一：</p><ol type="1"><li><span class="math inline">\(M\)</span> 称作是抛物型的(parabolic)，如果它共轭于平移：<span class="math inline">\(z\toz+1\)</span>。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上仅有一个不动点。</li><li><span class="math inline">\(M\)</span> 称作是椭圆型的(elliptic)，如果它共轭于旋转：<span class="math inline">\(z\toe^{i\theta}z\)</span>，其中 <span class="math inline">\(\theta\in\mathbb{R}\)</span> 且 <span class="math inline">\(\theta\ne0\)</span>。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li><li><span class="math inline">\(M\)</span> 称作是双曲型的(hyperbolic)，如果它共轭于缩放：<span class="math inline">\(z\to\lambdaz\)</span>，其中 <span class="math inline">\(\lambda&gt;0\)</span>是实数且不为 1。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li><li><span class="math inline">\(M\)</span> 称作是斜航型的(loxodromic)，如果它共轭于一个缩放和一个旋转的复合：<span class="math inline">\(z\to cz\)</span>，其中 <span class="math inline">\(c\in\mathbb{C}\setminus \mathbb{R}\)</span>。这时<span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li></ol><p>我们把形如 <span class="math inline">\(z\to z+a\)</span> 和 <span class="math inline">\(z\to\lambda z\)</span>的变换称作<strong>特殊位置</strong>的变换，前者是抛物型的，以 <span class="math inline">\(\infty\)</span>为唯一不动点，后者包含了所有非抛物型的变换，它的两个不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>。这两种 Möbius变换具有简单的表现形式，并且它们在两个圆族上的作用也很容易分析，所以在研究每种类型的变换时，我们都先考虑这种简单的形式，然后再通过取共轭扩展到一般的情形。</p><h2 id="抛物型">1. 抛物型</h2><p>我们先考察最简单的抛物型变换 <span class="math inline">\(z\toz+1\)</span>。</p><p>这时唯一的不动点是 <span class="math inline">\(\infty\)</span>，<span class="math inline">\(\mathcal{C}_1\)</span> 是直线族 <span class="math inline">\(\{y=k\mid k\in\mathbb{R}\}\)</span>，<span class="math inline">\(\mathcal{C}_2\)</span> 是直线族 <span class="math inline">\(\{x=l\mid l\in\mathbb{R}\}\)</span>。<span class="math inline">\(M\)</span> 保持 <span class="math inline">\(\mathcal{C}_1\)</span> 中的每条直线不变，把 <span class="math inline">\(\mathcal{C}_2\)</span>中的每条直线变成同族中的另一条直线：</p><object data="/images/mobius/parabolic-plane.svg"></object><p>由动画可见所有点都向着不动点 <span class="math inline">\(\infty\)</span> 的方向「前进」。</p><p>对一般的抛物型变换 <span class="math inline">\(M\)</span> 且 <span class="math inline">\(M\)</span> 的唯一不动点 <span class="math inline">\(z_0\)</span> 有限的情形，结论仍然类似：圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 中的圆都在 <span class="math inline">\(z_0\)</span> 处相切且共用同一条切线 <span class="math inline">\(\ell_1\)</span>，圆族 <span class="math inline">\(\mathcal{C}_2\)</span> 也都在 <span class="math inline">\(z_0\)</span> 处相切且共用同一条切线 <span class="math inline">\(\ell_2\)</span>，<span class="math inline">\(\ell_1\)</span> 和 <span class="math inline">\(\ell_2\)</span> 互相垂直：</p><object data="/images/mobius/parabolic-plane2.svg"></object><p>由动画可见左右两侧的圆在旋转，但是圆本身保持不变，它们是圆族 <span class="math inline">\(\mathcal{C}_1\)</span>；上下两侧的圆在「扩散」，它们是圆族<span class="math inline">\(\mathcal{C}_2\)</span>。可以证明对任何 <span class="math inline">\(z\in\mathbb{C}\)</span> 都有 <span class="math inline">\(\lim\limits_{n\to\infty}M^n(z)=z_0\)</span>，即任何点在<span class="math inline">\(M\)</span> 反复作用下的轨迹都朝着 <span class="math inline">\(z_0\)</span> 的位置移动。</p><p>在 <a href="http://klein.math.okstate.edu/IndrasPearls/">Indra’spearls</a> 一书中，把 <span class="math inline">\(\mathcal{C}_1\)</span>和 <span class="math inline">\(\mathcal{C_2}\)</span>形象地比喻为两组「扇贝壳」：</p><figure><img src="/images/mobius/seashell.jpeg" width="200" alt="我从网上找了一张扇贝壳的图片"><figcaption aria-hidden="true">我从网上找了一张扇贝壳的图片</figcaption></figure><h2 id="椭圆型">2. 椭圆型</h2><p>我们先考察最简单的椭圆型变换 <span class="math inline">\(z\toe^{i\theta}z\)</span>。</p><p>这时两个不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>。圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 由所有过 <span class="math inline">\(0\)</span> 的直线组成，<span class="math inline">\(\mathcal{C}_2\)</span> 由所有以 <span class="math inline">\(0\)</span> 为中心的同心圆组成。<span class="math inline">\(M\)</span> 是个旋转，所以会把 <span class="math inline">\(\mathcal{C}_1\)</span>中的直线变成同族的另一条直线，同时保持 <span class="math inline">\(\mathcal{C}_2\)</span> 中的每个圆不变：</p><object data="/images/mobius/elliptic-plane.svg"></object><p>对两个不动点 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 都有限的情形，结论同样成立，<span class="math inline">\(M\)</span> 保持 <span class="math inline">\(\mathcal{C}_2\)</span> 中的每个圆不变，把 <span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆变为同族中的另一个圆：</p><object data="/images/mobius/elliptic-plane2.svg"></object><h2 id="双曲型">3. 双曲型</h2><p>与椭圆变换 <span class="math inline">\(z\to e^{i\theta}z\)</span>的情形类似，<span class="math inline">\(z\to\lambda z\)</span> 也以<span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span> 为不动点，但是圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span> 的运动方式发生了互换：这次<span class="math inline">\(\mathcal{C}_1\)</span>中的每条直线在放缩下保持不变，<span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆在放缩下变成同族的另一个圆：</p><object data="/images/mobius/hyperbolic-plane.svg"></object><p>对两个不动点 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 都有限的双曲变换，结论仍然成立，圆族<span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆保持不变，<span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆被变成同族的另一个：</p><object data="/images/mobius/hyperbolic-plane2.svg"></object><p>这时在 <span class="math inline">\(M\)</span> 的作用下 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span>一个是「源点」，另一个是「汇点」，轨迹从源点源源不竭地发出，汇聚到汇点中。</p><h2 id="斜航型">4. 斜航型</h2><p>仍然先看 <span class="math inline">\(z\to cz\)</span> 的情形。</p><p>这时不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>，<span class="math inline">\(M\)</span> 把圆族 <span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆变为同族中的另一个圆，同样地也把圆族 <span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆变为同族中的另一个圆，<strong>所以斜航型的变换没有不变圆</strong>：</p><object data="/images/mobius/loxodromic-plane.svg"></object><p>这时平面上一点 <span class="math inline">\(z\)</span> 在 <span class="math inline">\(M\)</span>的反复作用下的轨迹是一条形如「旋臂」的曲线，方程为 <span class="math inline">\(\gamma(t)=c^tz\)</span>，这是一条对数螺线(spiral)，其与 <span class="math inline">\(\mathcal{C}_1\)</span> 和<span class="math inline">\(\mathcal{C}_2\)</span> 的夹角都是常数。</p><p>这个结论对一般的斜航型变换也成立：</p><object data="/images/mobius/loxodromic-plane2.svg"></object><p>由于斜航型变换包含双曲变换作为组成成分，因此看起来它也有一个源点和一个汇点。这时任意一点<span class="math inline">\(z\)</span> 在 <span class="math inline">\(M\)</span> 的反复作用下的轨迹是一条双螺线 (doublespiral)，其与 <span class="math inline">\(\mathcal{C}_1\)</span> 和<span class="math inline">\(\mathcal{C}_2\)</span> 的夹角仍然都是常数（Möbius 变换是保角的）。</p><p>判断 Möbius 变换 <span class="math inline">\(M\)</span>具体属于哪一类可以根据其迹的平方 <span class="math inline">\(\mu=(a+d)^2\)</span> 来判断（当然，需要把 <span class="math inline">\(M\)</span> 归一化使得 <span class="math inline">\(ad-bc=1\)</span>）：</p><ol type="1"><li><span class="math inline">\(M\)</span> 是抛物型的当且仅当 <span class="math inline">\(\mu=4\)</span>。</li><li><span class="math inline">\(M\)</span> 是椭圆型的当且仅当 <span class="math inline">\(0\leq\mu&lt;4\)</span>。</li><li><span class="math inline">\(M\)</span> 是双曲型的当且仅当 <span class="math inline">\(\mu&gt;4\)</span>。</li><li><span class="math inline">\(M\)</span> 是斜航型的当且仅当 <span class="math inline">\(\mu&lt;0\)</span> 或者 <span class="math inline">\(\mu\notin\mathbb{R}\)</span>。</li></ol><h2 id="斜航-loxodromic-是什么意思">斜航 (loxodromic) 是什么意思？</h2><p>斜航这个词听起来好像和船的航行有关，怎么就用来给 Möbius变换分类了呢？这里面肯定有故事，值得扒一扒。</p><p>斜航线 (loxodrome)指的是地球上的一条航行路径，其在每个点处的切线与过该点的经线的夹角为定值。比如说，如果船始终朝着东北方向30 度行驶，走过的轨迹就是一条斜航线。Loxodrome 最初是一个希腊词，loxos的意思是 oblique，即倾斜的，dromos 意为bearing，方位的意思，后来拉丁化以后成为现在的样子。葡萄牙数学家 PedroNunes (1492-1577)第一个认识到斜航线并非两点之间最短路径，而且它无限接近但永不可能到达极点。</p><p><img style="margin:0px auto;display:block" width="300" src="/images/mobius/loxodrome.png"></p><p>在大航海的时代，没有卫星导航，只能靠罗盘或者星座来标识船的航向，而星座的方法在遇到恶劣天气的时候又不能使用，只有罗盘是最可靠的方法。理论上地球表面两点之间的最短路径是过球心的大圆，但罗盘只能定出经线的方向（原理是地球的磁极和南北极近似重合），这二者的夹角不是固定的，要保持沿着大圆的弧走就必须不停调整船的航向，但现实中的船不可能一直有人守在船舵处调整方向，一般是事先定好航向以后接下来的若干天都沿着这个方向走，所以在一定路程内船实际上走的是斜航线。</p><p>荷兰地图学家墨卡托 (Mercator) 据此于 1569年提出了墨卡托地图，将地球投影至墨卡托地图是一个保角变换，即曲线的夹角保持不变。不仅如此，球面上的斜航线在墨卡托地图中成为一条直线：</p><figure><img src="/images/mobius/mercator.jpg" width="500" alt="网上找了一张墨卡托地图"><figcaption aria-hidden="true">网上找了一张墨卡托地图</figcaption></figure><p>所以要从地球上的 <span class="math inline">\(A\)</span> 点航向到<span class="math inline">\(B\)</span>点，只要找到它们在墨卡托地图上的对应点 <span class="math inline">\(A',B'\)</span>，算出地图上的直线 <span class="math inline">\(A'B'\)</span> 与经线的夹角 <span class="math inline">\(\theta\)</span>，航行时只要让罗盘与经线一直保持角度为<span class="math inline">\(\theta\)</span> 就可以按照斜航线从 <span class="math inline">\(A\)</span> 航行到 <span class="math inline">\(B\)</span>了。这个路径虽不是最短，但是好在不容易迷失航向。</p><p>那这和 Möbius 变换有什么关系呢？</p><h1 id="möbius-变换作用在-riemann-球面上">Möbius 变换作用在 Riemann球面上</h1><p>由于 Möbius 变换都是扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 到 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 的自同构，而 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 在球极投影下等同于Riemann 球面 <span class="math inline">\(S^2\)</span>，所以 Möbius变换也都是 Riemann 球面的自同构。我们来看看 Möbius 变换作用在 Riemann球面上是什么样子的。</p><p>这是一个作用在 Riemann 球上的斜航型变换：</p><object data="/images/mobius/loxodromic-sphere.svg"></object><p>从动画可见 Riemann球面上有一对源点和汇点，这对源点和汇点可以理解为球面的「北极」和「南极」，它们在球极投影下对应于<span class="math inline">\(M\)</span>在扩充复平面上的两个不动点。当这两个不动点分别是原点和无穷远点时，这两个极点就是通常意义下的北极和南极。这时球面上的「经线」是所有过两个极点的大圆，在球极投影下它们对应于同时过两个不动点的圆族<span class="math inline">\(\mathcal{C}_1\)</span>；球面上的「纬线」是所有与经线正交的圆，在球极投影下它们对应于反演圆族<span class="math inline">\(\mathcal{C}_2\)</span>，球面上每个点的轨迹是对数螺线轨迹在逆球极投影下在球面上的对应曲线，这条曲线与经线纬线的夹角都是常数（因为球极投影是保角的），从而是一条斜航线！</p><h1 id="möbius-变换作为上半双曲空间的等距">Möbius变换作为上半双曲空间的等距</h1><p>上半双曲空间 <span class="math inline">\(\mathbb{H}_3\)</span>的定义为 <span class="math display">\[\mathbb{H}_3 =\{(x,y,t)\in\mathbb{R}^3\ |\ t&gt;0\}.\]</span>这个空间中的度量是双曲度量：</p><p><span class="math display">\[\mathrm{d}s=\frac{(\mathrm{d}x)^2+(\mathrm{d}y)^2+(\mathrm{d}t)^2}{t}.\]</span></p><p>注意 <span class="math inline">\(xy\)</span> 平面，即复平面不属于<span class="math inline">\(\mathbb{H}_3\)</span>，它是 <span class="math inline">\(\mathbb{H}_3\)</span> 的无穷远边界，<span class="math inline">\(\mathbb{H}_3\)</span> 中任何一点到 <span class="math inline">\(xy\)</span> 平面的距离是无穷大。</p><p>一个复分析教材中不太常讲到的事实是：<strong>任何 Möbius变换都可以唯一地扩展为 <span class="math inline">\(\mathbb{H}_3\)</span>的一个等距变换 <span class="math inline">\(\overline{M}\)</span></strong>，此即所谓的Poincaré Extension。这个扩展用四元数来描述的话很简单：设 <span class="math display">\[M\colon\ z\to\frac{az+b}{cz+d},\quadad-bc=1.\]</span> 是任一 Möbius 变换。注意我们这里要求 <span class="math inline">\(ad-bc\)</span> 的值是1，其实任何非零实数都可以。这是可以做到的，因为给 Möbius 变换中的 <span class="math inline">\(a,b,c,d\)</span>同时乘以一个非零复数并不改变这个变换，所以同时乘以 <span class="math inline">\(1/\sqrt{ad-bc}\)</span> 就可以使得 <span class="math inline">\(ad-bc=1\)</span>。</p><p>对 <span class="math inline">\(p=(x,y,t)\in\mathbb{H}^3\)</span>，令<span class="math inline">\(q=x+yi+tj\)</span> 为与 <span class="math inline">\(p\)</span> 对应的四元数，定义 <span class="math display">\[\overline{M}(p) = (aq+b)(cq+d)^{-1}.\]</span>这里的运算都是在四元数体中进行。则 <span class="math inline">\(\overline{M}(p)\)</span> 是 <span class="math inline">\(\mathbb{H}_3\)</span> 到自身的等距，并且它限制在<span class="math inline">\(xy\)</span> 平面上与 <span class="math inline">\(M\)</span> 的作用一致。</p><p>关于 Poincaré Extension 读者可以参考 <span class="citation" data-cites="Bea95">(<a href="#ref-Bea95" role="doc-biblioref">Beardon1995, vol. 91, secs. 3.3, 4.1</a>)</span>。</p><p>我们还能像上面那样用动画演示 Möbius 变换 <span class="math inline">\(\overline{M}\)</span> 在 <span class="math inline">\(\mathbb{H}_3\)</span>上的作用吗？可以！比如下图是一个形如 <span class="math inline">\(z\tocz\)</span> 的斜航型变换扩展到 <span class="math inline">\(\mathbb{H}_3\)</span>后作用在一个<strong>圆柱</strong>体上的效果：</p><object data="/images/mobius/loxodromic-cone.svg"></object><p>你可能要问了：这明明是个圆锥体，你怎么说它是圆柱体呢？是不是笔误了啊？</p><p>其实是因为我们现在是在双曲空间里看待它，在双曲度量下，锥面上所有点到<span class="math inline">\(t\)</span>轴的距离都是一样的，实际上如果设锥的顶角为 <span class="math inline">\(2\alpha\)</span>，则锥面上任何一点到 <span class="math inline">\(t\)</span> 轴的双曲距离 <span class="math inline">\(d\)</span> 满足（见 <span class="citation" data-cites="Bea95">(<a href="#ref-Bea95" role="doc-biblioref">Beardon1995, vol. 91, sec. 7.9.1</a>)</span>） <span class="math display">\[\sinh d\cdot \cot\alpha = 1.\]</span> 即 <span class="math inline">\(d\)</span> 是定值。所以虽然在 <span class="math inline">\(\mathbb{R}^3\)</span> 中它是一个锥体，但是在 <span class="math inline">\(\mathbb{H}_3\)</span> 中它其实是圆柱体。</p><p>你可以看到这时 <span class="math inline">\(\overline{M}\)</span>有两个不动点，都位于无穷远边界上，这样的点叫做「理想点」。两个不动点之间的连线构成圆柱的轴。两个不动点一个是源点，一个是汇点，空间中的点在变换的作用下远离源点，趋向汇点。</p><p>对于一般的斜航型变换 <span class="math inline">\(M\)</span>，且其两个不动点都是扩充复平面上的有限点时，<span class="math inline">\(M\)</span> 在 <span class="math inline">\(\mathbb{H}_3\)</span> 上的扩展 <span class="math inline">\(\overline{M}\)</span> 仍然保持一个 <span class="math inline">\(\mathbb{H}_3\)</span> 中的圆柱体不变：</p><object data="/images/mobius/loxodromic-dupin.svg"></object><p>这个曲面叫做 <a href="https://www.maths.ox.ac.uk/about-us/departmental-art/dupin-cyclides">Dupincyclide</a>，它的两个端点恰好是 <span class="math inline">\(M\)</span>的两个不动点。但在双曲空间中它其实是一个圆柱体，由于其两端落在无穷远平面上，因此也是无限长的。圆柱体的轴是连接两个端点的测地线。如果<span class="math inline">\(M\)</span> 是椭圆型的话，那么 <span class="math inline">\(\overline{M}\)</span> 将该圆柱绕着轴旋转：</p><object data="/images/mobius/elliptic-dupin.svg"></object><h1 id="这些动画是怎么生成的">这些动画是怎么生成的？</h1><p>我以 Dupin cyclide 的动画为例子来说明动画的绘制过程。</p><p>一个非抛物型的变换 <span class="math inline">\(M\)</span>总是可以表示为 <span class="math inline">\(M = gM_\lambdag^{-1}\)</span> 的形式，其中 <span class="math inline">\(M_\lambda=z\to\lambda z\)</span>。我这里的 <span class="math inline">\(g\)</span> 取的是 <span class="math display">\[g^{-1}(z)=\frac{z-1}{z+1}.\]</span>注意我这里写的是 <span class="math inline">\(g^{-1}\)</span>，原因是我们不需要 <span class="math inline">\(g\)</span> 的显式表达式，相反我们只需要 <span class="math inline">\(g^{-1}\)</span>。</p><p>不难验证 <span class="math inline">\(g^{-1}(1)=0\)</span> 和 <span class="math inline">\(g^{-1}(-1)=\infty\)</span>，从而 <span class="math inline">\(g(0)=1\)</span> 和 <span class="math inline">\(g(\infty)=-1\)</span>，即 <span class="math inline">\(g\)</span> 将 <span class="math inline">\(M_\lambda\)</span> 的不动点 <span class="math inline">\(\{0,\infty\}\)</span> 分别映射为 <span class="math inline">\(M\)</span> 的不动点 <span class="math inline">\(\{1,-1\}\)</span>。<span class="math inline">\(g\)</span> 同时将 <span class="math inline">\(M_\lambda\)</span> 对应的圆族 <span class="math inline">\(\{\mathcal{C}_i,i=1,2\}\)</span> 映射为 <span class="math inline">\(M\)</span> 的圆族 <span class="math inline">\(\{g(\mathcal{C}_i),i=1,2\}\)</span>。</p><p><span class="math inline">\(g\)</span> 当然也可以扩展为 <span class="math inline">\(\mathbb{H}_3\)</span> 的等距，我们把扩展以后的<span class="math inline">\(g\)</span> 仍然记作 <span class="math inline">\(g\)</span>。</p><p>由 <span class="math inline">\(M = gM_\lambda g^{-1}\)</span> 可得<span class="math display">\[Mg(\mathcal{C}_i) = gM_\lambda(\mathcal{C}_i),\quad i=1,2.\]</span> 左边的 <span class="math inline">\(Mg(\mathcal{C}_i)\)</span> 是我们真正想绘制的<span class="math inline">\(M\)</span> 在其自己的圆族 <span class="math inline">\(g(\mathcal{C}_i)\)</span>上的作用，这等价于绘制右边的 <span class="math inline">\(gM_\lambda(\mathcal{C})_i\)</span>。<span class="math inline">\(M_\lambda(\mathcal{C}_i)\)</span>很好画，就是把一些同心圆和过原点的直线旋转或者放缩一下；但是它前面加了一个畸变<span class="math inline">\(g\)</span>。为此我们只要用 <span class="math inline">\(g^{-1}\)</span>作用在当前场景的物体上，把它们「去畸变」即可。所以在动画中，我其实根本没有计算Dupin cyclide 的任何显式或者隐式的曲面方程，而是直接用 <span class="math inline">\(g^{-1}\)</span> 作用在场景上。由于 <span class="math inline">\(g^{-1}\)</span> 是 <span class="math inline">\(\mathbb{H}_3\)</span> 上的等距，它一定会把连接<span class="math inline">\(\{\pm1\}\)</span> 的测地线映射为连接 <span class="math inline">\(\{0,\infty\}\)</span>的测地线，即锥面。换言之，判断场景中的一个点 <span class="math inline">\(p\)</span> 是不是落在 Dupin cyclide 上，只要判断<span class="math inline">\(g^{-1}(p)\)</span>是不是落在锥面上。这就好办了。</p><p>抛物的情形更简单一些，可以用 <span class="math inline">\(g(z)=1/z\)</span>把位于无穷远的不动点变到原点。</p><p>动画使用的是 GLSL 语言和 raymarching 的技术。我在 Roice的代码基础上作了许多优化，但肯定还可以更精炼。限于我写 shader的能力不足，做出更美轮美奂的效果就不指望了 …</p><p>严格讲，这些动画其实还是尝试在 Euclidean空间中去观察双曲空间中的对象，因为 raymarching技术假定的是光走直线，但在双曲空间中光一般不走直线，所以我们这里看到的效果与真实的生活在双曲空间中的“外星人”所看到的还是有差别的。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Bea95" class="csl-entry" role="listitem">Beardon, Alan F. 1995. <em>The Geometry of Discrete Groups</em>. Vol.91. Graduate Texts in Mathematics. Springer-Verlag, New York.</div><div id="ref-indra" class="csl-entry" role="listitem">Mumford, David, Caroline Series, and David J. Wright. 2002. <em>Indra’sPearls: An Atlas of Kleinian Groups</em>. Cambridge University Press.</div><div id="ref-Needham1997" class="csl-entry" role="listitem">Needham, Tristan. 1997. <em>Visual Complex Analysis</em>. The ClarendonPress, Oxford University Press, New York.</div><div id="ref-palka1991" class="csl-entry" role="listitem">Palka, B. P. 1991. <em>An Introduction to Complex Function Theory</em>.An Introduction to Complex Function Theory. World PublishingCorporation.</div></div>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>碉堡的小程序：用 Python 制作演示各种算法的 GIF 动画</title>
      <link href="/gifmaze-cn/"/>
      <url>/gifmaze-cn/</url>
      
        <content type="html"><![CDATA[<p>本文要介绍的是我写的一个有趣的 Python小程序，一个脱离了低级趣味的程序，一个有益于广大人民了解算法的程序。代码在<a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/gifmaze">Github</a>上。</p><p>这个程序可以用来制作各种各样的算法动画，包含但不限于：</p><span id="more"></span><ul><li><p>Wilson 均匀生成树算法：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/wilson-bfs.gif"></p></li><li><p>Prim 算法：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/prim.gif"></p></li><li><p>Kruskal 算法：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/kruskal.gif"></p></li><li><p>Langton 蚂蚁：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/langton-ant.gif"></p></li><li><p>Hilbert 曲线：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/hilbert.gif"></p></li><li><p>Conway 的生命游戏 (gosper glider gun)：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/gosperglidergun.gif"></p></li></ul><p>以上这些动画有一个共同特点：它们都位于二维的网格图上，这也是这个程序的一个限制。</p><p>这个程序有如下特点：</p><ol type="1"><li><p>所有代码全部由纯 Python写成，没有用到任何第三方库或者外部软件，也不包含任何 <code>draw</code>,<code>fill</code> 之类的函数调用，仅使用了内置的 <code>struct</code>,<code>random</code> 模块和一些内置函数。后来的版本中为了显示进度条引入了<code>tqdm</code>；为了把整个动画嵌入一张背景图片引入了<code>pillow</code>，这些都属于特效，本质不需要。</p></li><li><p>实现了一个小型但高效的 GIF编码器，<strong>通过直接将动画过程编码为字节流</strong>，可以在数秒之内生成高度优化的动态图。比如前面那张Langton ant 的动图，它包含 2300 帧，但是大小只有158KB，而且只需要一秒多一点就可以生成。这是这个程序最让人意外的一点：Python生成图像的慢是出了名的，它居然能在几秒内生成一张包含几千帧的 GIF动图？这是个大新闻啊！</p></li><li><p>严格遵循 GIF89a 协议，生成的图片在 chrome, firefox, IE 和 Eog中都可以正常显示。</p></li></ol><p>程序运行的相当快，生成一副 600x400 像素，演示 Wilson算法的动图只要数秒，得到的文件包含 1000~3000 帧，但大小不超过 1M左右。没想到吧？<span class="emoji" data-alias="astonished" style="" data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f632.png?v8">😲</span></p><p>这个程序是怎么来的呢？许多年前我在网上闲逛的时候，偶然发现了 d3.js <a href="https://bl.ocks.org/mbostock">作者的网站</a>（原链接已重定向，作者现在已经创业搞<a href="https://observablehq.com/">observablehq</a>去了），当时我对上面展示的各种丰富炫酷的动态效果惊羡不已，尤其是其中 <a href="https://bl.ocks.org/mbostock/11357811">Wilson算法的演示</a>，让我对此算法有了更直观和深入的理解。我立刻萌发了用Python 制作一个 GIF版本动画演示的想法，但是思考了许久也不知道从何入手。这里困难的地方在于Wilson算法是一个随机算法，其运行时间是不确定的，一个动画里面可能包含数千帧，如果采用把每一帧保存为图像再合并到一起的话，最终得到的文件会非常庞大。而且这种纯暴力的做法逼格不高，我实在不屑于采用。限于能力不足，这个想法只好被暂时压在心底，但是一直念念不忘。过了几年后，一个偶然的机会我接触到了GIF图像的编码协议，豁然开朗：为什么不直接把动画过程编码为字节流呢？通过精确定位每一帧的位置，控制LZW压缩过程的编码长度，文件过大的问题是可以解决的！前后捣鼓了半个月，反复研究协议细节，debug了无数次后，这才作出了上面的效果。后来慢慢又加上了其它迷宫算法和元胞自动机的演示。</p><p>关键的地方有这么几个：</p><ol type="1"><li><p>由于 GIF图像的每一帧占据的是整个图像窗口的一个矩形子区域，在一个包含很多帧的动图中，相邻的两帧之间的变动可能很小，没有必要每次都将整个图像全部编码。我们只需要记录帧和帧之间的变化情况，得出每一帧所占的矩形子区域，每次编码时只针对这个子区域编码即可，这样就大大减小了生成的文件体积。</p></li><li><p>采用变长的 LZW 压缩算法。GIF89a协议允许每个打包的数据块指明其所使用的最小码字的长度，如果你事先知道这一帧图像用到的颜色数目，比如4 种颜色，那么 2 个比特就足以表示这 4 种颜色，从而最小编码长度可以设置为2。这样根据具体情况采用不同的编码长度能有效减少文件体积。</p></li><li><p>因为要频繁的进行字节流的操作，所以每次将编码后的数据先写入一个<code>BytesIO</code> 对象中，放在内存里，最后一次性输出到硬盘。</p></li></ol><p>代码的组织结构是简单的三层论：顶层是抽象的 <code>Maze</code>类，其本质就是一个 2D网格图，用来跑各种图算法，它不关心动图的任何细节。底层是<code>GIFSurface</code> 类，负责维护 GIF图片的全局信息，比如图片宽高，循环次数，背景颜色，全局调色板等。中间层是<code>Animation</code>类，用来控制帧的信息，在算法运行过程中它按照一定的频率将<code>Maze</code> 染色并编码写入 <code>GIFSurface</code>。</p><p>目前程序的核心代码加起来大约在 1000行左右，但是如果牺牲一些可读性和功能的话，是可以压缩到 500行以内的。我曾经把这个项目投稿到 Github 上的 <a href="https://github.com/aosabook/500lines">500lines</a>上，可惜未能入选。但是我始终觉得它的优雅、奇妙并不逊色于那些大神们的作品。</p>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模任何素数都可约的整系数不可约多项式</title>
      <link href="/reducible-mod-p/"/>
      <url>/reducible-mod-p/</url>
      
        <content type="html"><![CDATA[<p>几年前在知乎上有这么 <a href="https://www.zhihu.com/question/38156113/answer/139354565">一个问题</a>：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>有哪些 <span class="math inline">\(\mathbb{Z}[x]\)</span> 中的多项式，它们在有理数域<span class="math inline">\(\mathbb{Q}\)</span>上是不可约的，而对任意素数 <span class="math inline">\(p\)</span>，模<span class="math inline">\(p\)</span> 以后在 <span class="math inline">\(\mathbb{Z}_p[x]\)</span> 上都是可约的？</p></div><p>当时我给了回答，后来账号注销了，答案也一并删除了。现在把我的原答案贴在这里：</p><span id="more"></span><p>我所知道的有两大类多项式：</p><p>第一类是所有的 Swinnerdon-Dyer 多项式，它们形如 <span class="math display">\[f(x)=\prod(x\pm\sqrt{p_1}\pm\sqrt{p_2}\cdots\pm\sqrt{p_n}),\]</span>其中 <span class="math inline">\(p_1,\ldots,p_n\)</span>是互不相同的素数，乘积跑遍所有 <span class="math inline">\(2^n\)</span>种不同的组合。这种多项式都是不可约的整系数多项式，但是模任何素数 <span class="math inline">\(p\)</span>以后都分解为一次或者二次因式的乘积。</p><p>第二类来自分圆多项式，分圆多项式 <span class="math inline">\(\Phi_n(x)\)</span> 是本原 <span class="math inline">\(n\)</span> 次单位根在 <span class="math inline">\(\mathbb{Q}\)</span> 上的首 1 极小多项式，其次数为<span class="math inline">\(\phi(n)\)</span>，这里 <span class="math inline">\(\phi(\cdot)\)</span> 是 Euler totient函数。绝大多数分圆多项式模任何素数 <span class="math inline">\(p\)</span> 都是可约的！实际上我们有如下结论：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>分圆多项式 <span class="math inline">\(\Phi_n(x)\)</span>模任何素数 <span class="math inline">\(p\)</span> 都可约当且仅当 <span class="math inline">\(n\ne1,2,p,2p^k\)</span>，其中 <span class="math inline">\(p\)</span> 是奇素数，<span class="math inline">\(k\)</span> 是正整数。</p></div><p>你可以看到那个知乎问题下的回答中举的例子都是最简单的 Swinnerdon-Dyer多项式或者分圆多项式。</p><p>我知道这个结论还是研究生时上夏壁灿老师的符号计算课程，讲到分解整系数多项式的Zassenhaus算法，这两类多项式被用来分析算法的最差复杂度。我还在校园书摊上淘到了一本破损的<a href="https://www.cambridge.org/core/books/modern-computer-algebra/DB3563D4013401734851CF683D2F03F0">ModernComputer Algebra</a>，在 15.3 节 “Frobenius’ and Chebotarev’s densitytheorems” 中有介绍。</p><p>这两类多项式属于比较容易分析的，还有别的例子吗？也是有的，<a href="https://projecteuclid.org/euclid.rmjm/1289916905">这篇文章</a>给出了更多不那么显然的构造。</p>]]></content>
      
      
      <categories>
          
          <category> 代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二维随机游动 （一）：逃出太阳系可没有你想象的那么难！</title>
      <link href="/random-walk-potential-kernel/"/>
      <url>/random-walk-potential-kernel/</url>
      
        <content type="html"><![CDATA[<p>这是一个关于二维随机游动的小系列，整理自我研究生时的读书笔记，每篇文章会从一个有趣直观的问题出发，介绍随机游动理论中的一个相关知识。这些问题是我精心挑选的，总体上都比较基础，并不涉及多么复杂的知识。但是请你也不要期待很快就可以看完问题的解答，因为它们不是那种用个什么巧办法三两下就能搞定的急转弯！</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"></span>假设某醉汉以太阳系的中心为原点出发，在一个固定的平面内，以恒为 1米的步长作随机行走。每次醉汉等概率地在东、南、西、北四个方向中任选一个，然后向此方向移动1 米的距离。如果某个时刻醉汉回到了原点，或者离开了太阳系则过程结束。</p><p>现在有 A, B 两个旁观者打赌哪一种情形先发生，A 认为醉汉会先回到原点，B认为醉汉会先离开太阳系。请问 A 和 B 获胜的概率分别是多少？</p><p>作为参考，太阳系半径约为 45亿千米，看作一个中心在原点的圆形区域。</p></div><span id="more"></span><p>题目其实是在说，醉汉的行为是 <span class="math inline">\(\mathbb{Z}^2\)</span> 上的简单随机游动，而我们熟知<span class="math inline">\(\mathbb{Z}^d\)</span> 上的随机游动在 <span class="math inline">\(d=1,2\)</span> 时是常返的，所以醉汉以概率 1会走遍平面上的所有角落，即 A, B 这场赌局是以概率 1可以分出胜负的。从直观上，<span class="math inline">\(A\)</span>的获胜概率应该更大，因为醉汉回到原点显然是个更容易发生的事件：醉汉的路径可能是选择一个方向一步迈出去再一步迈回来，或者干脆绕一个圈子，而走出太阳系那么远的距离则困难得多。事实也是如此，实际上A, B 获胜概率的“分水岭”大约在 <span class="math inline">\(R\approx4.2\)</span> 米处 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，随着逃逸半径 <span class="math inline">\(R\)</span> 的增大，A获胜的概率也随之增大，常返性保证了当 <span class="math inline">\(R\to+\infty\)</span> 时 A 获胜的概率趋于1。这里有趣的地方在于，A 的获胜概率随逃逸半径 <span class="math inline">\(R\)</span>的增加而增长的速度相当缓慢，其近似值约为 <span class="math display">\[1-\left(\frac{2}{\pi}\ln R +1.0293737\right)^{-1},\]</span> 所以当 <span class="math inline">\(R\)</span> 取为太阳系半径时，B 的获胜概率大约为1/20，这不是个可以忽略的值。甚至当 <span class="math inline">\(R\)</span> 扩大为银河系的半径（5 万光年） 时，B仍然有大约 1/30 的概率获胜！是不是很反直觉呢？</p><p>本文下面就来介绍怎样得出上面获胜概率的渐进公式。这里的讲述主要参考了<span class="citation" data-cites="spitzergtm">(<a href="#ref-spitzergtm" role="doc-biblioref">Spitzer1976</a>)</span>，好处是比较简单易懂，缺点是没有给出势核误差项的渐进估计。使用局部中心极限定理的话可以给出势核误差项的渐进估计<span class="citation" data-cites="lawler2010random">(<a href="#ref-lawler2010random" role="doc-biblioref">Lawler and Limic2010</a>)</span>，但是我想本文还是克制一点，尽量保持在初等的范围内比较好。</p><p>我们把问题分解为以下步骤来解决：</p><ol type="1"><li>构造一个叫做势核 (potential kernel) 的调和函数。</li><li>通过估计积分获得势核的渐进阶。</li><li>使用势核的调和性质构造对应的随机游动的鞅。</li><li>使用鞅的可料停时定理给出逃逸概率的估计。</li></ol><h1 id="二维随机游动的特征函数">二维随机游动的特征函数</h1><p>我们把醉汉在 <span class="math inline">\(n\)</span> 时刻的位置 <span class="math inline">\(S_n\)</span> 记作 <span class="math display">\[S_n=X_1+\cdots+X_n.\]</span> 其中 <span class="math inline">\(X_i\)</span>表示单步移动的随机向量，它们独立且与随机向量 <span class="math inline">\(X\)</span> 同分布： <span class="math display">\[\mathbb{P}(X=e_1)=\mathbb{P}(X=e_2)=\mathbb{P}(X=-e_1)=\mathbb{P}(X=-e_2)=\frac{1}{4}.\]</span>这里 <span class="math inline">\(e_1=(1, 0), e_2=(0, 1)\)</span>为平面上的正交单位向量。 记 <span class="math inline">\(\phi(\theta)=\mathop{\mathrm{\mathbb{E}}}{\mathrm{e}^{i\theta\cdotX}}\)</span> 为 <span class="math inline">\(X\)</span> 的特征函数，其中<span class="math inline">\(\theta=(\theta_1,\theta_2)\)</span>，则<span class="math display">\[\phi(\theta)=\frac{1}{4}\sum_{x\in\{\pm e_1,\pme_2\}}\mathrm{e}^{i(\theta_1x_1+\theta_2x_2)}=\frac{1}{2}(\cos\theta_1 +\cos\theta_2).\]</span> 于是 <span class="math inline">\(S_n\)</span> 的特征函数为<span class="math inline">\(\phi^n(\theta)\)</span>。</p><p>用特征函数我们可以非常方便地表示 <span class="math inline">\(n\)</span> 步以后醉汉位于任意 <span class="math inline">\(y\in\mathbb{Z}^2\)</span> 的概率 <span class="math inline">\(\mathbb{P}(S_n=y)\)</span>： <span class="math display">\[\mathbb{P}(S_n=y) =\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\mathrm{e}^{-i\theta\cdoty}\phi^n(\theta)\,\mathrm{d}\theta.\label{eq:sn}\tag{1}\]</span> 其中 <span class="math inline">\(\mathbb{T}=[-\pi,\pi]\times[-\pi,\pi]\)</span>。这是因为根据特征函数定义有 <span class="math display">\[\phi^n(\theta)=\mathop{\mathrm{\mathbb{E}}}{\mathrm{e}^{i\theta\cdotS_n}}=\sum_{x\in\mathbb{Z}^2}\mathbb{P}(S_n=x)\mathrm{e}^{i\theta\cdotx}.\]</span> 两边同时乘以 <span class="math inline">\(\mathrm{e}^{-i\theta\cdot y}\)</span> 并在 <span class="math inline">\(\mathbb{T}\)</span> 上积分即得 <span class="math display">\[\begin{aligned}\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\mathrm{e}^{-i\theta\cdoty}\phi^n(\theta)\,\mathrm{d}\theta&amp;=\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\sum_{x\in\mathbb{Z}^2}\mathbb{P}(S_n=x)\mathrm{e}^{i\theta\cdot(x-y)}\,\mathrm{d}\theta\\&amp;=\sum_{x\in\mathbb{Z}^2}\mathbb{P}(S_n=x)\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\mathrm{e}^{i\theta\cdot(x-y)}\,\mathrm{d}\theta\\&amp;=\sum_{x\in\mathbb{Z}^2}\mathbb{P}(S_n=x)\cdot\delta_{x,y}\\&amp;=\mathbb{P}(S_n=y).\end{aligned}\]</span> 这里我们利用了级数 <span class="math inline">\(\sum_{x\in\mathbb{Z}^2}\mathbb{P}(S_n=x)\mathrm{e}^{i\theta\cdot(x-y)}\)</span>绝对收敛（从而可以交换求和顺序），以及对 <span class="math inline">\(z\in\mathbb{Z}^2\)</span> 的积分 <span class="math display">\[\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\mathrm{e}^{i\theta\cdotz}\,\mathrm{d}\theta\]</span> 在 <span class="math inline">\(z=(0, 0)\)</span> 处为1，在其它位置均为 0 的简单事实。</p><blockquote><p>上面的讨论对任意维数都适用，<span class="math inline">\(\mathbb{Z}^d\)</span> 上的简单随机游动其特征函数为<span class="math inline">\(\frac{1}{2}\sum_{i=1}^d\cos\theta_i\)</span>，关于<span class="math inline">\(\mathbb{P}(S_n=y)\)</span>的类似表达式仍然成立。</p></blockquote><h1 id="二维随机游动的势核">二维随机游动的势核</h1><p>势核可以看作是 Green 函数在二维情形的替代物：在 <span class="math inline">\(d\geq3\)</span> 时，<span class="math inline">\(\mathbb{Z}^d\)</span> 上的简单随机游动的 Green函数 <span class="math inline">\(G(x,y)\)</span> 定义为从 <span class="math inline">\(x\)</span> 出发的随机游动访问 <span class="math inline">\(y\)</span> 的期望次数： <span class="math display">\[G(x, y) =\mathbb{E}_x\left(\sum_{k=1}^\infty\mathbb{1}_{\{S_k=y\}}\right)=\sum_{k=1}^\infty\mathbb{P}_x(S_k=y).\]</span> 由于二维随机游动是常返的，上面的级数在<span class="math inline">\(d=2\)</span> 时发散，所以上述 Green函数的定义失效，但是我们还是想定义一个类似 Green函数的调和函数，结果发现 Green函数的差对应的级数是收敛的，这就引出了下面势核的定义。</p><p>记 <span class="math inline">\(\mathbb{P}_n(x, y)\)</span> 为从 <span class="math inline">\(x\)</span> 出发的简单随机游动经过 <span class="math inline">\(n\)</span> 步以后到达 <span class="math inline">\(y\)</span>的概率。显然此概率满足如下两条性质：</p><ol type="1"><li><span class="math inline">\(\mathbb{P}_n(x, y)=\mathbb{P}_n(0,y-x)=\mathbb{P}_n(x-y,0)\)</span>.</li><li><span class="math inline">\(\lim_{n\to\infty}\mathbb{P}_n(x,y)=0\)</span>.</li></ol><p>定义二维随机游动的势核 (potential kernel) 为 <span class="math display">\[a(x)=\sum_{k=0}^\infty\left[\mathbb{P}_k(0,0)-\mathbb{P}_k(x, 0)\right].\]</span> 即 <span class="math inline">\(a(x)\)</span> 是极限 <span class="math display">\[a(x)=\lim_{n\to\infty}\sum_{k=0}^n\left[\mathbb{P}_k(0, 0) -\mathbb{P}_k(x, 0)\right]=\lim_{n\to\infty}a_n(x).\]</span> 由定义可见 <span class="math inline">\(a(0)=0\)</span>。我们还得说明这个级数对任何 <span class="math inline">\(x\in\mathbb{Z}^2\)</span> 确实是收敛的。为此注意到<span class="math display">\[\mathbb{P}_k(0,0)=\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\phi^k(\theta)\,\mathrm{d}\theta.\]</span> 以及根据 <span class="math inline">\((\ref{eq:sn})\)</span><span class="math display">\[\mathbb{P}_k(x, 0)=\mathbb{P}_k(0,-x)=\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\mathrm{e}^{i\theta\cdotx}\phi^k(\theta)\,\mathrm{d}\theta.\]</span> 于是 <span class="math display">\[a_n(x)=\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\frac{1-\mathrm{e}^{i\theta\cdotx}}{1-\phi(\theta)}(1-\phi^{n+1}(\theta))\,\mathrm{d}\theta.\label{eq:an}\tag{2}\]</span> 由于 <span class="math inline">\(|1-\phi^{n+1}(\theta)|\leq2\)</span> 对任何 <span class="math inline">\(n\geq0\)</span> 和 <span class="math inline">\(\theta\in\mathbb{T}\)</span>成立，所以如果我们能证明 <span class="math inline">\(\dfrac{1-\mathrm{e}^{i\theta\cdotx}}{1-\phi(\theta)}\)</span> 在 <span class="math inline">\(\mathbb{T}\)</span> 上可积，并且 <span class="math inline">\(\phi^{n+1}(\theta)\to0,\mathrm{a.e.}\)</span>的话，就可以使用控制收敛定理对 <span class="math inline">\((\ref{eq:an})\)</span> 两边取极限，即得 <span class="math display">\[a(x)=\lim_{n\to\infty}a_n(x) =\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\frac{1-\mathrm{e}^{i\theta\cdotx}}{1-\phi(\theta)}\,\mathrm{d}\theta &lt;\infty.\]</span> 由于 <span class="math inline">\(\phi(\theta)=\frac{1}{2}(\cos\theta_1+\cos\theta_2)\)</span>只在 <span class="math inline">\(\mathbb{T}\)</span> 上有限个点处满足<span class="math inline">\(|\phi(\theta)|=1\)</span>，其余均为 <span class="math inline">\(|\phi(\theta)|&lt;1\)</span>，所以 <span class="math inline">\(\phi^n(\theta)\to0\)</span> 在 <span class="math inline">\(\mathbb{T}\)</span> 上几乎处处成立。</p><p>为了证明 <span class="math inline">\(\dfrac{1-\mathrm{e}^{i\theta\cdotx}}{1-\phi(\theta)}\)</span> 在 <span class="math inline">\(\mathbb{T}\)</span> 上可积，我们注意到不等式 <span class="math inline">\(|1-\mathrm{e}^{i\theta\cdot x}|\leq|x||\theta|\)</span> 总是成立的，并且存在正数 <span class="math inline">\(\lambda&gt;0\)</span> 使得 <span class="math display">\[1-\phi(\theta)=1-\frac{1}{2}(\cos\theta_1+\cos\theta_2)\geq\lambda(\theta_1^2+\theta_2^2)=\lambda|\theta|^2\]</span> 对任何 <span class="math inline">\(\theta\in\mathbb{T}\)</span> 成立 （函数 <span class="math inline">\((1-\cos t)/t^2\)</span> 在 <span class="math inline">\([-\pi, \pi]\)</span> 上具有正的最小值 <span class="math inline">\(c\)</span>，取 <span class="math inline">\(\lambda=c/2\)</span> 即可），所以 <span class="math display">\[\frac{1-\mathrm{e}^{i\theta\cdotx}}{1-\phi(\theta)}\leq\frac{|x|}{\lambda|\theta|}.\]</span> 而 <span class="math inline">\(1/|\theta|\)</span>在二维的情形是 <span class="math inline">\(\mathbb{T}\)</span> 上Lebesgue 可积的：将积分区域 <span class="math inline">\(\mathbb{T}=[-\pi,\pi]\times[-\pi,\pi]\)</span>放大为圆形区域 <span class="math inline">\(|\theta|\leq\sqrt{2}\pi\)</span>，并用极坐标换元<span class="math inline">\(\theta\to(r,\alpha)\)</span> 得到 <span class="math display">\[\int_T\frac{1}{|\theta|}\,\mathrm{d}\theta  \leq\int_{|\theta|\leq\sqrt{2}\pi}\frac{1}{|\theta|}\,\mathrm{d}\theta=\int_0^{2\pi}\,\mathrm{d}\alpha \int_0^{\sqrt{2}\pi}\frac{1}{r}\cdot r\,\mathrm{d}r =2\sqrt{2}\pi^2&lt;\infty.\]</span></p><p>所以 <span class="math inline">\(\dfrac{1-\mathrm{e}^{i\theta\cdotx}}{1-\phi(\theta)}\)</span> 是 Lebesgue 可积的，这就证明了 <span class="math inline">\(a(x)\)</span> 对任何 <span class="math inline">\(x\in\mathbb{Z}^2\)</span> 都有定义。</p><div id="potential-kernel-integ" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span>势核 <span class="math inline">\(a(x)=\sum\limits_{k=0}^\infty\left[\mathbb{P}_k(0,0)-\mathbb{P}_k(x, 0)\right]\)</span> 几乎处处有限且等于 <span class="math display">\[a(x)=\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\frac{1-\mathrm{e}^{i\theta\cdotx}}{1-\phi(\theta)}\,\mathrm{d}\theta.\]</span></p></div><h1 id="势核在除去原点之外是调和的">势核在除去原点之外是调和的</h1><p>我们接下来证明势核 <span class="math inline">\(a(x)\)</span>在除去原点之外都是调和的： <span class="math display">\[a(x)=\frac{1}{4}\sum_{y\sim x}a(y),\quad \forallx\in\mathbb{Z}^2\setminus\{0\}.\]</span> 为此记 <span class="math inline">\(N_x^n\)</span> 为从 <span class="math inline">\(x\)</span> 出发的随机游动在前 <span class="math inline">\(n\)</span> 步到访原点的次数，即 <span class="math inline">\(N_x^{n}=\sum\limits_{k=0}^n\mathbb{1}_{\{S_k=0\}}\)</span>，则<span class="math display">\[a(x)=\lim_{n\to\infty}(\mathop{\mathrm{\mathbb{E}}}{N_0^n}-\mathop{\mathrm{\mathbb{E}}}{N_x^n}).\]</span> 对任何从 <span class="math inline">\(x\in\mathbb{Z}^2\setminus\{0\}\)</span>出发的随机游动，使用单步转移概率，我们有 <span class="math display">\[N_x^n=\frac{1}{4}\sum_{y\simx}N_y^{n-1}.\]</span> 此外 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}{N_0^n}=\mathop{\mathrm{\mathbb{E}}}{N_0^{n-1}}+\mathop{\mathrm{\mathbb{E}}}{\mathbb{1}_{\{S_n=0\}}}=\mathop{\mathrm{\mathbb{E}}}{N_0^{n-1}}+\mathbb{P}_0(S_n=0),\]</span>所以当 <span class="math inline">\(x\ne0\)</span> 时， <span class="math display">\[\begin{aligned}\mathop{\mathrm{\mathbb{E}}}{N_0^n}-\mathop{\mathrm{\mathbb{E}}}{N_x^n}&amp;=\mathbb{P}_0(S_n=0)+\mathop{\mathrm{\mathbb{E}}}{N_0^{n-1}}-\frac{1}{4}\sum_{y\simx}\mathop{\mathrm{\mathbb{E}}}{N_y^{n-1}}\\&amp;=\mathbb{P}_0(S_n=0)+\frac{1}{4}\sum_{y\simx}[\mathop{\mathrm{\mathbb{E}}}{N_0^{n-1}}-\mathop{\mathrm{\mathbb{E}}}{N_y^{n-1}}].\end{aligned}\]</span> 两边令 <span class="math inline">\(n\to\infty\)</span> 并注意<span class="math inline">\(\mathbb{P}_0(S_n=0)\to 0\)</span> 即得 <span class="math display">\[a(x)=0+\frac{1}{4}\sum_{y\sim x}a(y)=\frac{1}{4}\sum_{y\sim x}a(y).\]</span> 即 <span class="math inline">\(a(x)\)</span> 在任何 <span class="math inline">\(x\ne 0\)</span> 处是调和的。</p><p>由定义我们已经知道 <span class="math inline">\(a(0)=0\)</span>，其实稍微花点力气也不难得出 <span class="math inline">\(a(\pm e_i)=1\)</span> 来：根据对称性 <span class="math inline">\(a(x)\)</span> 在原点的四个邻居 <span class="math inline">\(\{\pm e_1,\pm e_2\}\)</span>处的值应该相等，这次我们对 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}{N_0^n}\)</span>进行分解并注意初始时刻 <span class="math inline">\(S_0=0\)</span>也算一次，所以有 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}{N_0^n} = 1 + \frac{1}{4}\sum_{y\sim0}\mathop{\mathrm{\mathbb{E}}}{N_y^{n-1}} = 1 +\mathop{\mathrm{\mathbb{E}}}{N_{e_1}^{n-1}}.\]</span> 把 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}{N_{e_1}^n}\)</span>拆成 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}{N_{e_1}^{n-1}}+\mathbb{P}_{e_1}(S_n=0)\)</span>，得到<span class="math display">\[\mathop{\mathrm{\mathbb{E}}}{N_0^n}-\mathop{\mathrm{\mathbb{E}}}{N_{e_1}^n}=1-\mathbb{P}_{e_1}(S_n=0).\]</span>两边令 <span class="math inline">\(n\to\infty\)</span> 即得 <span class="math inline">\(a(e_1)=1\)</span>。</p><p>采用下一节的方法，我们可以通过计算积分得出 <span class="math inline">\(a(e_1+e_2)=\frac{4}{\pi}\)</span>，<span class="math inline">\(a(2e_1)=4-\frac{8}{\pi}\)</span>，等等，其示意图如下：</p><p><img src="/images/electric-network/greenfunction.svg" class="fig" width="400"></p><h1 id="势核的渐进估计">势核的渐进估计</h1><p>我们关心的是势核 <span class="math inline">\(a(x)\)</span> 当 <span class="math inline">\(|x|\to\infty\)</span>时的渐进大小，为此我们有如下定理：</p><div id="ax-asy" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.1</span>.</span><span class="statement-spah"> </span><span class="math display">\[\lim_{|x|\to\infty} a(x) - \frac{2}{\pi}\ln |x| =\frac{2}{\pi}\gamma+\frac{\ln 8}{\pi}\approx 1.0293737.\]</span> 其中<span class="math inline">\(\gamma\approx 0.5772156649\)</span> 是 Euler常数。</p></div><p>当你看到这个定理的时候，是不是感觉已经快要接近证明文章开头的结论了呢？那可太抱歉了，真正麻烦的地方才刚开始。这个定理的证明非常棘手，我们需要首先论证<span class="math inline">\(a(x)\)</span> 的渐进行为只与 <span class="math inline">\(x\)</span> 的长度有关，与 <span class="math inline">\(x\)</span> 方向无关，然后用一个特殊的方向 <span class="math inline">\(x=(n, n)\)</span> 代入 <span class="math inline">\(a(x)\)</span> 的表达式计算积分值。</p><p><strong>证明</strong>： 我们先来论证 <span class="math inline">\(a(x)\)</span> 的渐进行为不依赖于 <span class="math inline">\(x\)</span> 的方向。我们的思路是取一个函数 <span class="math inline">\(g(\theta)\)</span>，使得积分 <span class="math display">\[\begin{equation}0 &lt;\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\left[\frac{1}{1-\phi(\theta)}-\frac{1}{g(\theta)}\right]\,\mathrm{d}\theta=c&lt; \infty,\label{eq:decompose}\end{equation}\]</span> 然后把 <span class="math inline">\(a(x)\)</span> 的积分表示<span class="math display">\[a(x)=\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\frac{1-\mathrm{e}^{i\theta\cdotx}}{1-\phi(\theta)}\,\mathrm{d}\theta\]</span> 拆成两项的和： <span class="math display">\[a(x)=\underbrace{\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\frac{1-\mathrm{e}^{i\theta\cdotx}}{g(\theta)}\,\mathrm{d}\theta}_{I(x)}+\underbrace{\frac{1}{(2\pi)^2}\int_{\mathbb{T}}(1-\mathrm{e}^{i\theta\cdotx})\left[\frac{1}{1-\phi(\theta)}-\frac{1}{g(\theta)}\right]\,\mathrm{d}\theta}_{J(x)}.\]</span> 根据 <a href="en.wikipedia.org/wiki/Riemann%E2%80%93Lebesgue_lemma">Riemann-Lebesgue引理</a>，<span class="math inline">\(\lim\limits_{|x|\to\infty}J(x)=c\)</span>，即<span class="math inline">\(J(x)\)</span> 与 <span class="math inline">\(x\)</span> 的方向是无关的。</p><p><span class="math inline">\(g(\theta)\)</span> 可以取为 <span class="math inline">\(|\theta|^2/4\)</span>，我们来验证这一点： <span class="math display">\[\frac{1}{1-\phi(\theta)}-\frac{1}{g(\theta)}=\frac{1}{1-\phi(\theta)}-\frac{4}{|\theta|^2} =\underbrace{\frac{4|\theta|^2}{1-\phi(\theta)}}_{\chi(\theta)}\cdot\underbrace{\frac{1}{|\theta|^4}\left[\phi(\theta)-1+\frac{|\theta|^2}{4}\right]}_{\psi(\theta)}.\]</span> 我们要证明乘积 <span class="math inline">\(\chi(\theta)\psi(\theta)\)</span> 在 <span class="math inline">\(\mathbb{T}\)</span>上可积。注意到我们之前已经证明了存在 <span class="math inline">\(\lambda&gt;0\)</span> 使得在 <span class="math inline">\(\mathbb{T}\)</span> 上有 <span class="math inline">\(1-\phi(\theta)\geq\lambda|\theta|^2\)</span>，所以 <span class="math inline">\(\chi(\theta)\leq 4/\lambda\)</span> 在 <span class="math inline">\(\mathbb{T}\)</span> 上是有界的，只要再证明 <span class="math inline">\(\psi(\theta)\)</span> 在 <span class="math inline">\(\mathbb{T}\)</span> 上可积即可。而 <span class="math display">\[\begin{equation}\phi(\theta)-1+\frac{|\theta|^2}{4}=\mathop{\mathrm{\mathbb{E}}}{\left[\mathrm{e}^{i\theta\cdotX} - 1 - i\theta\cdot X - \frac{1}{2}(i\theta\cdot X)^2\right]}.\end{equation}\]</span> 这里我们利用了 <span class="math inline">\(\mathbb{T}\)</span>是关于原点对称的区域，以及 <span class="math inline">\(X^2\equiv(1,1)\)</span>，所以 <span class="math display">\[\begin{aligned}\mathop{\mathrm{\mathbb{E}}}{(\theta\cdotX)}&amp;=\mathop{\mathrm{\mathbb{E}}}{(x_1\theta_1 + x_2\theta)}=0,\\\mathop{\mathrm{\mathbb{E}}}{(\theta\cdotX)^2}&amp;=\mathop{\mathrm{\mathbb{E}}}{(x_1\theta_1+x_2\theta_2)^2}=\mathop{\mathrm{\mathbb{E}}}{(\theta_1^2+\theta_2^2)}=\mathop{\mathrm{\mathbb{E}}}{|\theta|^2}.\end{aligned}\]</span> 由于对任何实数 <span class="math inline">\(z\)</span> 都有不等式 <span class="citation" data-cites="Durrett2019">(<a href="#ref-Durrett2019" role="doc-biblioref">Durrett 2019</a>, lemma. 3.3.19)</span> <span class="math display">\[\left|\mathrm{e}^{iz} - 1 - iz -\frac{(iz)^2}{2}\right|\leq\frac{|z|^3}{6},\]</span> 所以 <span class="math display">\[\phi(\theta)-1+\frac{|\theta|^2}{4}\leq\frac{1}{6}\mathop{\mathrm{\mathbb{E}}}{|\theta\cdotX|^3}\leq\frac{1}{6}\mathop{\mathrm{\mathbb{E}}}{|\theta|^3|X|^3}=\frac{|\theta|^3}{6}\mathop{\mathrm{\mathbb{E}}}{|X|^3},\]</span> 从而 <span class="math display">\[\psi(\theta)=|\theta|^{-4}\left[\phi(\theta)-1+\frac{|\theta|^2}{4}\right]\leq|\theta|^{-4}\cdot\frac{|\theta|^3}{6}\mathop{\mathrm{\mathbb{E}}}{|X|^3}=\frac{M}{|\theta|}.\]</span> 这里 <span class="math inline">\(0&lt;M=\frac{\mathop{\mathrm{\mathbb{E}}}{|X|^3}}{6} &lt;\infty\)</span>是正数。而前面已经看到 <span class="math inline">\(1/|\theta|\)</span>在 <span class="math inline">\(\mathbb{T}\)</span> 上是可积的，所以<span class="math inline">\(\psi(\theta)\)</span> 也是可积的，这就说明了<span class="math inline">\(\lim\limits_{|x|\to\infty}J(x)=c\)</span>确实成立。</p><p>我们还需要说明 <span class="math inline">\(I(x)\)</span> 的极限也是与<span class="math inline">\(x\)</span> 的方向无关的。把 <span class="math inline">\(I(x)\)</span> 分解成两部分： <span class="math display">\[I(x)=\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\frac{1-\mathrm{e}^{i\theta\cdotx}}{|\theta|^2/4}\,\mathrm{d}\theta =\frac{1}{\pi^2}\int_{\mathbb{T}}\frac{1-\cos(\theta\cdotx)}{|\theta|^2}\,\mathrm{d}\theta=I_1+I_2.\]</span> 其中 <span class="math inline">\(I_1\)</span> 为在圆形区域<span class="math inline">\(|\theta|\leq\pi\)</span> 上的积分，<span class="math inline">\(I_2\)</span> 为在剩下的 <span class="math inline">\(\{\theta\in\mathbb{T},\,|\theta|&gt;\pi\}\)</span> 区域上的积分。</p><p><span class="math inline">\(I_2\)</span>是比较好处理的，这是因为在其区域上 <span class="math inline">\(1/|\theta|^2\)</span> 可积，所以根据Riemann-Lebesgue 引理， <span class="math display">\[\lim_{|x|\to\infty}\frac{1}{\pi^2}\int_{\theta\in\mathbb{T},\,|\theta|&gt;\pi}\frac{1-\cos(\theta\cdotx)}{|\theta|^2}\,\mathrm{d}\theta=\frac{1}{\pi^2}\int_{\theta\in\mathbb{T},\,|\theta|&gt;\pi}\frac{1}{|\theta|^2}\,\mathrm{d}\theta&lt; \infty.\]</span> 所以 <span class="math inline">\(I_2(x)\)</span>有一个不依赖于 <span class="math inline">\(x\)</span> 方向的极限值。</p><p>至此我们把 <span class="math inline">\(a(x)\)</span> 的积分表示为了<span class="math inline">\(I_1+I_2+J\)</span> 的形式，并且论证了 <span class="math inline">\(x\to\infty\)</span> 时后两者的值有限，所以 <span class="math inline">\(a(x)\)</span> 的渐进主项藏在 <span class="math inline">\(I_1(x)\)</span> 当中。</p><p>而 <span class="math inline">\(I_1(x)\)</span> 从表达式明显可见它是与<span class="math inline">\(x\)</span> 方向无关的： <span class="math display">\[I_1(x)=\frac{1}{\pi^2}\int_{|\theta|\leq\pi}\frac{1-\cos(\theta\cdotx)}{|\theta|^2}\,\mathrm{d}\theta.\]</span> 事实上用一个旋转矩阵 <span class="math inline">\(A\)</span>乘以 <span class="math inline">\(x\)</span> 等同于对 <span class="math inline">\(\theta\)</span> 作变元代换 <span class="math inline">\(\theta'=A^{-1}\theta\)</span>，由于 <span class="math inline">\(A\)</span> 是正交矩阵所以 <span class="math inline">\(|\theta'|=|\theta|\)</span> 并且变换的Jacobian 值是 +1，所以积分不变。于是我们可以取 <span class="math inline">\(x=(R,0)\)</span> 为实轴正向，则 <span class="math inline">\(\theta\cdot x = R\theta_1\)</span>。进一步作代换<span class="math inline">\(u=R\theta\)</span> 可得 <span class="math display">\[I_1 = \frac{1}{\pi^2}\int_{|u|\leR\pi}\frac{1-\cos u_1}{|u|^2}\,\mathrm{d}u.\]</span> 其中 <span class="math inline">\(u_1\)</span> 是 <span class="math inline">\(u\)</span> 的 <span class="math inline">\(x\)</span> 分量。</p><p>将积分拆成 <span class="math inline">\(|u|\le 1\)</span> 和 <span class="math inline">\(1&lt;|u|\le R\pi\)</span> 两部分：</p><ul><li>在 <span class="math inline">\(|u|\le1\)</span> 时，由于在 0 附近，<span class="math display">\[\frac{1-\cosu_1}{|u|^2}\sim\frac{u_1^2/2}{|u|^2}\le\frac{1}{2}.\]</span>所以被积函数在单位圆内连续有界，这部分积分是个有限的常数，可以不用管。</li><li><span class="math inline">\(1&lt;|u|\le R\pi\)</span> 对应的积分等于<span class="math display">\[\frac{1}{\pi^2}\int_{1&lt;|u|\leR\pi}\frac{1}{|u|^2}\,\mathrm{d}u - \int_{1&lt;|u|\le R\pi}\frac{\cosu_1}{|u|^2}\,\mathrm{d}u.\]</span> 极坐标代换以后第一项等于 <span class="math display">\[\frac{2}{\pi}\int_1^R\frac{1}{r}\,\mathrm{d}r =\frac{2}{\pi}\ln R + O(1).\]</span> 这一项贡献了 <span class="math inline">\(I_1\)</span> 的主项。<br>同样使用极坐标代换，第二项等于 <span class="math display">\[\frac{1}{\pi^2}\int_{1}^{\pi R} \frac{1}{r}\left( \int_{0}^{2\pi} \cos(r \cos\alpha)\, \mathrm{d}\alpha \right)\,\mathrm{d}r.\]</span> 括号里面等于 <span class="math inline">\(J_0(r)\)</span>，是零阶第一类贝塞尔函数。而熟知<span class="math inline">\(J_0(r)\)</span> 在 <span class="math inline">\(r\to\infty\)</span> 时的渐进阶是 <span class="math inline">\(O(r^{-1/2})\)</span>，所以这部分的积分收敛。</li></ul><p>至此我们证明了在分解 <span class="math display">\[a(x)=I(x)+J(x)=I_1(x)+I_2(x)+J(x)\]</span> 中，当<span class="math inline">\(|x|\to\infty\)</span> 时，<span class="math inline">\(I_1-\frac{2}{\pi}\ln|x|\)</span>，<span class="math inline">\(I_2\)</span> 和 <span class="math inline">\(J\)</span> 都趋近于有限的极限值，于是极限 <span class="math display">\[\lim_{|x|\to\infty}\left(a(x)-\frac{2}{\pi}\ln|x|\right)\]</span>也存在且有限。为了计算这个极限，我们选择对角线方向 <span class="math inline">\(x=(n,n)\)</span> 代入 <span class="math inline">\(a(x)\)</span> 的表达式中： <span class="math display">\[a(n,n)=\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\frac{1-\cosn(\theta_1+\theta_2)}{1-\frac{1}{2}(\cos\theta_1+\cos\theta_2)}\,\mathrm{d}\theta=\frac{1}{(2\pi)^2}\int_{\mathbb{T}}\frac{1-\cosn(\theta_1+\theta_2)}{1-\cos\frac{\theta_1+\theta_2}{2}\cos\frac{\theta_1-\theta_2}{2}}\,\mathrm{d}\theta.\]</span> 作变元代换 <span class="math inline">\(u=\frac{\theta_1+\theta_2}{2},v=\frac{\theta_1-\theta_2}{2}\)</span>，此变换的Jacobian 为 <span class="math inline">\(1/2\)</span>，于是 <span class="math display">\[a(n,n)=\frac{2}{(2\pi)^2}\int_{|u|+|v|\leq\pi}\frac{1-\cos(2nu)}{1-\cosu\cos v}\,\mathrm{d}u\mathrm{d}v.\]</span> 此积分的区域是 <span class="math inline">\(\mathbb{T}\)</span>中满足 <span class="math inline">\(|u|+|v|\leq \pi\)</span>的部分，它等于整个 <span class="math inline">\(\mathbb{T}\)</span>上积分的一半，如图所示：</p><p><img src="/images/random-walk/region.svg" class="fig" width="300"></p><p>所以 <span class="math display">\[a(n,n)=\frac{1}{4\pi^2}\int_{-\pi}^\pi\mathrm{d}u\int_{-\pi}^\pi\frac{1-\cos(2nu)}{1-\cosu\cos v}\,\mathrm{d}v.\]</span> 我们用留数来计算上面的积分。首先计算内层关于 <span class="math inline">\(v\)</span> 的积分。设 <span class="math inline">\(k=\cos u\)</span>，</p><p><span class="math display">\[\begin{aligned}\int_{-\pi}^{\pi}\frac{1}{1-k\cosv}\,\mathrm{d}v&amp;=\oint_{|z|=1}\frac{1}{1-\frac{k}{2}\left(z+\frac{1}{z}\right)} \frac{\mathrm{d} z}{iz}\quad(z=e^{iv})\\ &amp;=\oint_{|z|=1} \frac{2i}{kz^2-2z+k}\mathrm{d}z\\ &amp;=\oint_{|z|=1} \frac{2i}{k(z-z_1)(z-z_2)}\mathrm{d}z\quad\left(z_{1,2}=\frac{1\pm\sqrt{1-k^2}}{k}\right)\\&amp;=2\pi i\cdot\frac{2i}{k}\;\mathrm{Res}_{z=z_2}\left(\frac{1}{(z-z_1)(z-z_2)}\right)\\&amp;=-\frac{4\pi}{k}\frac{1}{z_2-z_1}\\&amp;=\frac{2\pi}{\sqrt{1-k^2}}. \end{aligned}\]</span></p><p>外层同样使用围道积分：</p><p><span class="math display">\[\begin{aligned}&amp;\frac{1}{4\pi^2}\int_{-\pi}^{\pi}(1-\cos(2nu))\int_{-\pi}^{\pi}\frac{1}{1-\cosu\cos v}\,\mathrm{d}u\,\mathrm{d}v\\&amp;=\frac{1}{2\pi}\int_{-\pi}^{\pi}\frac{1-\cos(2nu)}{|\sin\left(u\right)|}\,\mathrm{d}u\\&amp;=\frac{1}{\pi}\mathrm{Re}\int_{0}^{\pi}\frac{1-e^{2inu}}{\sinu}\,\mathrm{d}u\quad(z=e^{iu})\\&amp;=\frac{1}{\pi}\mathrm{Re}\int_{C}\frac{1-z^{2n}}{\frac{1}{2i}\left(z-z^{-1}\right)}\,\frac{\mathrm{d} z}{i z}\qquad \qquad C \colon= \{ |z| = 1\mid \argz\in[0,\pi]\}\\&amp;=\frac{2}{\pi}\mathrm{Re}\int_{1}^{-1}\frac{1-z^{2n}}{z^2-1}\,\mathrm{d} z\\ &amp;=\frac{2}{\pi}\int_{-1}^1\sum_{k=0}^{n-1}x^{2k}\,\mathrm{d}x\\ &amp;=\frac{4}{\pi}\sum_{k=1}^{n}\frac{1}{2k-1}.\end{aligned}\]</span> 从而 <span class="math display">\[\begin{aligned}&amp;\lim_{n\to\infty}\left[a(n,n)-\frac{2}{\pi}\ln\sqrt{2}n\right]=\lim_{n\to\infty}\left[\frac{4}{\pi}\sum_{k=1}^n\frac{1}{2k-1}-\frac{2}{\pi}\ln\sqrt{2}n\right]\\&amp;=\lim_{n\to\infty}\left[\frac{4}{\pi}\sum_{k=1}^{2n}\frac{1}{k}-\frac{4}{\pi}\ln2n\right]+\lim_{n\to\infty}\left[\frac{2}{\pi}\sum_{k=1}^{n}\frac{1}{k}-\frac{2}{\pi}\lnn\right]+\frac{\ln8}{\pi}\\&amp;=\frac{4}{\pi}\gamma-\frac{2}{\pi}\gamma+\frac{\ln 8}{\pi}\\&amp;=\frac{2}{\pi}\gamma+\frac{\ln 8}{\pi}\\&amp;\approx 1.0293737056545709.\end{aligned}\]</span> <a href="#ax-asy" title="定理 4.1">定理 4.1</a>得证。<span class="math inline">\(\blacksquare\)</span></p><p>上面这些讨论基本上是我对 Spitzer著作中内容的重新表述，利用局部中心极限定理可以证明极限的误差项大约是<span class="math inline">\(O(|x|^{-2})\)</span> 量级的，即</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.2</span>.</span><span class="statement-spah"> </span><span class="math display">\[a(x) = \frac{2}{\pi}\ln|x| +\frac{2\gamma+\ln8}{\pi} + O(|x|^{-2}).\]</span></p></div><p>证明见 <span class="citation" data-cites="lawler2010random">(<a href="#ref-lawler2010random" role="doc-biblioref">Lawler and Limic 2010,vol. 123, sec. 4.4</a>)</span>。下文要用到这个渐进估计的一个推论：</p><div id="axorder" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论4.3</span>.</span><span class="statement-spah"> </span>对任何 <span class="math inline">\(x\in\mathbb{Z}^2\setminus\{0\}\)</span> 和单位向量<span class="math inline">\(|e|=1\)</span> 有 <span class="math display">\[a(x + e) - a(x) = O(|x|^{-1}).\]</span>特别地存在常数 <span class="math inline">\(M&gt;0\)</span> 使得 <span class="math inline">\(|a(x+e)-a(x)|\leq M\)</span> 对任何 <span class="math inline">\(x\)</span> 恒成立。</p></div><p><strong>证明</strong>：</p><p><span class="math display">\[\begin{aligned}a(x+e)-a(x)&amp;=\frac{1}{\pi}\ln\frac{\langlex+e, x+e\rangle}{|x|^2}+O(|x|^{-2})\\&amp;=\frac{1}{\pi}\ln\left(1+\frac{2\langlex,e\rangle+1}{|x|^2}\right)+O(|x|^{-2})\\&amp;\leq\frac{1}{\pi}\ln\left(1+\frac{2}{|x|}+\frac{1}{|x|^2}\right)+O(|x|^{-2})\\&amp;=O(|x|^{-1}).\end{aligned}\]</span></p><h1 id="最后一击">最后一击</h1><p>到目前为止我们已经完成了所有的准备工作，只要再用一点点离散鞅的知识（可料停时定理） 就可以得出 A, B获胜概率的渐进表达式。虽然剩下的部分已经没有什么难点，但这个时候要更加耐心点。</p><p>先做一些记号的约定。</p><ol type="1"><li>记 <span class="math inline">\(B(r)\)</span> 是平面上半径为 <span class="math inline">\(r\)</span> 的圆盘，<span class="math inline">\(\partial B(r)\)</span> 是圆周 <span class="math inline">\(|x|=r\)</span>。</li><li>设 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(0&lt;|x|&lt;r\)</span> 是<span class="math inline">\(B(r)\)</span> 内一点，<span class="math inline">\(S_n\)</span> 是从 <span class="math inline">\(x\)</span> 出发的随机游动在 <span class="math inline">\(n\)</span> 时刻的位置，<span class="math inline">\(S_0=x\)</span>。</li><li>记 <span class="math inline">\(\tau_{0}=\min\{n\geq1:\,S_n=0\}\)</span>，<span class="math inline">\(\tau_{\partialB(r)}=\min\{n\geq1:\, |S_n|\geq r\}\)</span>。于是 <span class="math inline">\(\tau_{0}\)</span> 和 <span class="math inline">\(\tau_{\partial B(r)}\)</span> 分别是 <span class="math inline">\(S_n\)</span> 首次到达原点的时刻和首次走出 <span class="math inline">\(B(r)\)</span> 的时刻。记 <span class="math inline">\(\tau=\min\{\tau_{0},\tau_{\partialB(r)}\}\)</span>，则 <span class="math inline">\(\tau_{0},\,\tau_{\partial B(r)},\,\tau\)</span>都是停时。</li></ol><p>为了能够使用可料停时定理，我们首先需要说明 <span class="math inline">\(\{a(S_{n\wedge\tau})\}\)</span> 是一个鞅，且停时<span class="math inline">\(\tau\)</span> 满足可料停时定理的条件。由于<span class="math inline">\(a(x)\)</span> 在任何 <span class="math inline">\(x\ne 0\)</span> 处调和，所以 <span class="math inline">\(\{a(S_{n\wedge\tau})\}\)</span>是一个鞅是没有问题的。</p><p>注意到 <span class="math inline">\(\{S_{n\wedge\tau}\}\)</span>是一个限制在 <span class="math inline">\(B(r)\)</span>内的随机游动，它访问其中任何一点的期望步数都是有限的，所以 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}{\tau}&lt;\infty\)</span>。其次根据<a href="#axorder" title="推论 4.3">推论 4.3</a>，<span class="math inline">\(|a(x+e)-a(x)|\)</span> 是一致有界的，所以停时<span class="math inline">\(\tau\)</span> 满足 <a href="https://en.wikipedia.org/wiki/Optional_stopping_theorem">可料停时定理的条件</a>，从而</p><p><span class="math display">\[\begin{aligned}a(x)&amp;=a(S_0)=\mathbb{E}_x\,a(S_{\tau})\\&amp;=p\cdot\mathbb{E}_x\,\left[a(S_{\tau_{\partial B(r)}})\mid\tau_{\partialB(r)}&lt;\tau_{0}\right]+(1-p)\cdot\mathbb{E}_x\,\left[a(S_{\tau_{0}})\mid\tau_{0}&lt;\tau_{\partialB(r)}\right].\end{aligned}\]</span></p><p>其中 <span class="math inline">\(p=\mathbb{P}(\tau_{\partialB(r)}&lt;\tau_{0})\)</span> 正是随机游动在回到原点之前逃出区域 <span class="math inline">\(B(r)\)</span> 的概率。但是又注意到 <span class="math inline">\(a(S_{\tau_{0}})=a(0)=0\)</span>，所以上面式子中第二项恒为0，即 <span class="math display">\[p=\frac{a(x)}{\mathbb{E}_x\left[a(S_{\tau_{\partialB(r)}})\mid\tau_{\partial B(r)}&lt;\tau_{0}\right]}.\]</span></p><p>记上面的分母为 <span class="math inline">\(g=\mathbb{E}_x\left[a(S_{\tau_{\partialB(r)}})|\tau_{\partial B(r)}&lt;\tau_{0}\right]\)</span>，则 <span class="math inline">\(g\)</span> 是势核 <span class="math inline">\(a(\cdot)\)</span> 在圆周 <span class="math inline">\(\partial B(r)\)</span>上关于一个条件概率测度的积分，而我们已经看到势核 <span class="math inline">\(a(y)\)</span> 是近似球对称的，它只依赖于 <span class="math inline">\(|y|\)</span>。当随机游动刚好走到 <span class="math inline">\(\partial B(r)\)</span> 时，其位置 <span class="math inline">\(y\)</span> 未必正好落在圆周上，但是满足 <span class="math inline">\(r\le |y|&lt;r+1\)</span>。我们滥用一点记号，对任意的实数 <span class="math inline">\(r&gt;0\)</span>，记 <span class="math display">\[a(r) = \frac{2}{\pi}\ln r +\frac{2\gamma+\ln8}{\pi},\]</span> 与 <a href="#axorder" title="推论 4.3">推论 4.3</a> 同样的道理，当 <span class="math inline">\(r\le |y|&lt; r+1\)</span> 时有 <span class="math display">\[|a(y) - a(r)| = O(1/r).\]</span> 所以 <span class="math inline">\(g\)</span> 作为 <span class="math inline">\(a(\cdot)\)</span> 在 <span class="math inline">\(\partial B(r)\)</span> 附近的一些 <span class="math inline">\(y\)</span> 在一个条件概率下的加权组合，其值等于<span class="math display">\[\frac{2}{\pi}\ln r +\frac{2\gamma+\ln8}{\pi} + O(r^{-1}).\]</span></p><p>至此我们就证明了如下结论：</p><div id="-------4" class="statement sta____4 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">定理4</span>.</span><span class="statement-spah"> </span>： 设 <span class="math inline">\(x\in B(r)\)</span> 且 <span class="math inline">\(x\ne 0\)</span>，考虑从 <span class="math inline">\(x\)</span> 出发的简单随机游动，则 <span class="math display">\[\mathbb{P}_x(\tau_{\partial B(r)} &lt; \tau_0) =\frac{a(x)}{\dfrac{2}{\pi}\ln r + \dfrac{2\gamma+\ln8}{\pi} +O(r^{-1})}.\]</span></p></div><p>本文开头的赌局的答案就蕴含在这个定理的结论中：由于从原点出发的随机游动第一步必然走到某个邻居<span class="math inline">\(x\in\{\pm e_1,\pm e_2\}\)</span>上，所以从原点出发的随机游动能够逃逸到 <span class="math inline">\(B(r)\)</span> 之外的概率是 <span class="math display">\[\frac{1}{4}\sum_{x\in\{\pm e_1,\pme_2\}}\mathbb{P}_x(\tau_{\partialB(r)}&lt;\tau_{0})=\frac{1}{4}\sum_{x\in\{\pm e_1,\pme_2\}}\frac{a(x)}{\dfrac{2}{\pi}\ln r +\dfrac{2\gamma+\ln8}{\pi}+O(r^{-1})}.\]</span> 而 <span class="math inline">\(a(x)\)</span> 在这四个点上的值都是1，所以这个概率值等于 <span class="math display">\[\dfrac{1}{\dfrac{2}{\pi}\ln r +\dfrac{2\gamma+\ln8}{\pi} + O(r^{-1})}\approx\left(\dfrac{2}{\pi}\ln r +1.0293737\right)^{-1},\quad r\to\infty,\]</span> 这也正是我们之前介绍的B 的获胜概率！</p><blockquote><p>我们需要根据第一步将概率进行分解是因为 <span class="math inline">\(a(x)\)</span> 在 <span class="math inline">\(x\ne0\)</span> 时才是调和的，从而 <span class="math inline">\(a(S_{n\wedge\tau})\)</span> 是鞅。</p></blockquote><h1 id="结语">结语</h1><p>洋洋洒洒一大篇，总算回答了开头提出的一个小问题。你可能要问了：这只是二维的情形呀，如果是三维太阳系中的随机游动，A和 B 获胜的概率又该怎么算？这种情形方法其实是类似的，需要估计势核 Green函数的阶，然后仿照 <a href="#ax-asy" title="定理 4.1">定理 4.1</a>进行估计。可以证明在维数 <span class="math inline">\(d&gt;2\)</span>时，<span class="math inline">\(G(x)=G(0,x)\)</span> 的大小近似为 <span class="math display">\[G(x)=\frac{\gamma_d}{|x|^{d-2}} + O(|x|^{-d}).\]</span> 其中 <span class="math inline">\(\gamma_d\)</span> 是一个只与<span class="math inline">\(d\)</span> 相关的常数。详情可见 Lawler 的书4.3 节。</p><p>本文选择 <span class="math inline">\(d=2\)</span>情形讨论是因为它更有趣，而且这里的结论在后面的文章中会用到。下篇文章见！</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Durrett2019" class="csl-entry" role="listitem">Durrett, Rick. 2019. <em>Probability: Theory and Examples</em>. 5th ed.Cambridge Series in Statistical and Probabilistic Mathematics. CambridgeUniversity Press.</div><div id="ref-lawler2010random" class="csl-entry" role="listitem">Lawler, Gregory F, and Vlada Limic. 2010. <em>Random Walk: A ModernIntroduction</em>. Vol. 123. Cambridge University Press.</div><div id="ref-spitzergtm" class="csl-entry" role="listitem">Spitzer, Frank. 1976. <em>Principles of Random Walk</em>. Second. Vol.Vol. 34. Graduate Texts in Mathematics. Springer-Verlag, NewYork-Heidelberg.</div></div><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>这是程序仿真的结果，下面的渐进公式给出的值约为 4.59米，但渐进公式的误差是在 <span class="math inline">\(R\to\infty\)</span>时才趋于 0 的，仿真结果应当更准确。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 随机游动 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Coupling from the past</title>
      <link href="/coupling-from-the-past/"/>
      <url>/coupling-from-the-past/</url>
      
        <content type="html"><![CDATA[<p><strong>2025/12/13 更新</strong>：我用 GPT 帮我把画图的 Python脚本改成了 Javascript 动画：</p><div style="width:100%; margin:1rem 0;"><p><iframe id="cftp-iframe" src="/demos/cftp.html" style="width:100%; border:0; border-radius:16px; overflow:hidden;" scrolling="no" title="CFTP demo"></iframe></p></div><script>(function () {  const f = document.getElementById("cftp-iframe");  window.addEventListener("message", (e) => {    // 如果同源部署，建议加：if (e.origin !== location.origin) return;    if (!e.data || e.data.type !== "cftp:resize") return;    f.style.height = (e.data.height + 2) + "px"; // +2 防止边框裁切  });})();</script><hr><p>今天我要介绍一个 Markov 链采样中的精彩算法，叫做 coupling from thepast(CFTP)。这个算法看似简单，实则充满玄机。我相信你可以在五分钟内理解算法的步骤，然后再花五分钟左右看懂算法的证明，但是我打赌你需要几个星期甚至更久的时间来细细回味其中奥妙。</p><p>为了引出算法，我们从一个计数问题开始：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>下图是一个边长分别为 <span class="math inline">\(a,b,c\)</span> 的平行六边形，其中 <span class="math inline">\(a,b,c\)</span> 都是正整数，内角均为 120 度：</p><p><img src="/images/cftp/hexagon.svg" class="fig" width="400"></p><p>请问：用边长为 1 的菱形密铺它，有多少种不同的方法？</p></div><span id="more"></span><p>比如下图就是一种密铺的示例：</p><p><img src="/images/cftp/random_lozenge_tiling.svg" class="fig" width="400"></p><p>图中三种不同摆放角度的菱形被染成了不同的颜色。</p><p>这个问题的答案很不容易猜到，叫做 Macmahon 公式：</p><div id="macmahon-------" class="unnumbered statement sta_macmahon___ plain"><p><span class="statement-heading"><span class="statement-label">Macmahon 公式</span>.</span><span class="statement-spah"> </span>记 <span class="math inline">\(H(a,b,c)\)</span>为所求的六边形的不同菱形密铺的个数，则 <span class="math display">\[H(a,b,c)=\prod_{i=1}^a\prod_{j=1}^b\prod_{k=1}^c\frac{i+j+k-1}{i+j+k-2}.\]</span></p></div><p>关于 Macmahon 公式，以及它背后的 plane partition理论是另一段精彩的故事，这里不作介绍。需要注意的是，<span class="math inline">\(H(a,b,c)\)</span> 的值是指数级增长的，比如对 <span class="math inline">\(a=b=c=10\)</span> 这种比较小的情形 <span class="math inline">\(H(a,b,c)\approx9.265\times10^{33}\)</span>，已经是一个天文数字了。</p><p>真正的问题来了：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>怎样在全部 <span class="math inline">\(H(a,b,c)\)</span>种不同的密铺中完全随机地任选一种？也就是说，每一种密铺都应该以同样的概率被选中。不能有偏向，也不能近似凑合，必须是完完全全的随机。</p></div><p>由于 <span class="math inline">\(H(a,b,c)\)</span>太太太大了，我们不可能先把所有密铺都列出来然后再挑选，那样的话全世界的计算机内存加起来也装不下。所以得设计一个聪明点的方法，这就是CFTP 要做的。</p><h1 id="markov-链的随机取样">Markov 链的随机取样</h1><p>设 <span class="math inline">\(M\)</span> 是一个有限遍历的 Markov链，其状态空间为 <span class="math inline">\(S\)</span>，平稳分布为<span class="math inline">\(\pi\)</span>，我们希望以分布 <span class="math inline">\(\pi\)</span> 从 <span class="math inline">\(S\)</span> 中随机地取样，即对任何 <span class="math inline">\(s\in S\)</span>，取样抽到 <span class="math inline">\(s\)</span> 的概率为 <span class="math inline">\(\pi(s)\)</span>。这在许多实际应用中都有重要意义。通常的方法是任选一个初始状态<span class="math inline">\(s_0\)</span> 然后从 <span class="math inline">\(s_0\)</span> 出发跑这个 Markov链。可以证明只要运行的时间 <span class="math inline">\(n\)</span>足够大，其 <span class="math inline">\(n\)</span> 时刻的状态 <span class="math inline">\(s_n\)</span> 服从的分布就可以任意逼近平稳分布：<span class="math display">\[|\mathbb{P}(s_n=s) - \pi(s)| &lt;\epsilon,\quad\forall s\in S,\ \forall\epsilon&gt;0.\]</span>这个方法非常简单易行，但是它有两个缺陷：首先它只是一个近似算法，不管<span class="math inline">\(n\)</span> 取得多么大，返回的 <span class="math inline">\(s_n\)</span> 的分布只是近似而非严格等于平稳分布<span class="math inline">\(\pi\)</span>；其次为了获得足够的精度所需的时间<span class="math inline">\(n\)</span>（叫做 mixingtime）也不总是那么容易估计的，也就是说，你压根不知道需要跑多久才能让<span class="math inline">\(s_n\)</span> 的分布足够接近 <span class="math inline">\(\pi(s)\)</span>。那么有没有什么办法可以获得精确地服从<span class="math inline">\(\pi\)</span> 的采样呢？</p><p>Propp 和 Wilson 提出了如下的想法：既然从初始状态出发向未来 （<span class="math inline">\(+\infty\)</span> 方向） 跑 Markov链得不到真正的平稳分布，我们何不从无穷远的过去 （<span class="math inline">\(-\infty\)</span> 方向） 向现在 （时刻 0）跑呢？可以想象当这个链经过了无穷次迭代后，其 0 时刻的状态 <span class="math inline">\(s^\ast\)</span> 服从的分布就是 <span class="math inline">\(\pi\)</span>。当然，一个可行的算法必须在有限时间内输出结果，我们不可能做到真的从无穷远的过去出发。我们能做的只是选择一个足够大的<span class="math inline">\(n\)</span> 然后从 <span class="math inline">\(-n\)</span> 时刻出发向时刻 0 跑，但是这种做法和从0 时刻向时刻 <span class="math inline">\(n\)</span>跑没有什么区别。Propp 和 Wilson的观察的关键之处在于，只跑一个链是不行的，我们需要从每个 <span class="math inline">\(s\in S\)</span> 出发，同时跑 <span class="math inline">\(M\)</span> 的 <span class="math inline">\(|S|\)</span> 个不同的版本，并且观察它们是否在时刻0 时耦合在一起 (coupled together)，即相遇到了相同的状态 <span class="math inline">\(s^\ast\)</span>。一旦这件事情发生的话，那么假设我们还有一个额外的从无穷远出发、初始分布是<span class="math inline">\(\pi\)</span> 的链，由于它来到 0时刻必然也处于状态 <span class="math inline">\(s^\ast\)</span>，所以<span class="math inline">\(s^\ast\)</span> 就服从分布 <span class="math inline">\(\pi\)</span>。如果没有相遇呢？那就从某个更久远的位置开始再来一遍，直到耦合出现为止，这就是coupling from the past 的由来。</p><p>用不太准确的话说，我们是在时间 <span class="math inline">\(-n\)</span> 处设置了 <span class="math inline">\(|S|\)</span>个不同的链，封死了从无穷远过去出发的链在 <span class="math inline">\(-n\)</span>处的所有可能状态，然后通过将所有链在时刻 0“坍缩”为单个状态来获得采样。</p><p>其实我上面的描述仍然遗漏了 CFTP 的一些关键细节。为了准确的描述CFTP，我们首先引入 Markov 链的随机映射表示 (random mappingrepresentation)。</p><h1 id="markov-链的随机映射表示">Markov 链的随机映射表示</h1><p>随机映射表示能够让我们用计算机程序来模拟 Markov链，它是一个由随机数流驱动的更新函数 <span class="math inline">\(f:S\times [0, 1]\to S\)</span>。<span class="math inline">\(f\)</span>本身是确定的，对任何状态 <span class="math inline">\(s\in S\)</span> 和<span class="math inline">\(u\in [0,1]\)</span>，<span class="math inline">\(s'=f(s,u)\)</span> 给出 Markov链更新后的状态。我们要求 <span class="math inline">\(f\)</span> 满足当<span class="math inline">\(U\)</span> 是服从 <span class="math inline">\([0, 1]\)</span> 上的均匀分布的随机变量时，<span class="math inline">\(\mathbb{P}(f(s,U)=s')=P_{s,s'}\)</span>。这里 <span class="math inline">\(P_{s,s'}\)</span> 是 Markov 链从 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(s'\)</span> 的转移概率。任何有限 Markov链都存在随机映射表示，而且表示方法不是唯一的。最简单的构造方式是用一个阶梯函数：<span class="math display">\[f(s_i, u) =\begin{cases}\begin{array}{ll}s_1, &amp;\text{for } u\in[0,P_{i,1}),\\s_2, &amp;\text{for } u\in[P_{i,1}, P_{i,1}+P_{i,2}),\\\vdots&amp;\vdots\\s_j, &amp;\text{for } u\in\left[\sum_{k=1}^{j-1}P_{i,k},\sum_{k=1}^jP_{i,k}\right),\\\vdots &amp;\vdots\\s_n, &amp;\text{for }u\in\left[\sum_{k=1}^{n-1}P_{i,k},1\right].\end{array}\end{cases}\]</span></p><p>假设有一个随机数发生器可以产生独立且服从 <span class="math inline">\([0,1]\)</span> 上均匀分布的随机变量序列 <span class="math inline">\(U_0,U_{-1},U_{-2},\ldots\)</span>，则我们可以由此来驱动Markov 链 <span class="math inline">\(M\)</span>从过去的某个时刻向现在运行： <span class="math display">\[s_{-n}\xrightarrow{f(s_{-n+1},\,U_{-n+1})}s_{-n+1}\xrightarrow{f(s_{-n+2},\,U_{-n+2})}\cdots\xrightarrow{f(s_0,\,U_0)}s_0.\]</span></p><h1 id="coupling-from-the-past-算法">Coupling from the past 算法</h1><p>现在我们可以来表述 coupling from the past 算法了。</p><p>设 <span class="math inline">\(M\)</span> 是一个有限遍历的 Markov链，状态空间为 <span class="math inline">\(S\)</span>，<span class="math inline">\(f: S\times [0, 1]\to S\)</span>是其随机映射表示。<span class="math inline">\(U_0,U_{-1},\ldots\)</span>是一列随机数，它们分别来自一列独立且服从 <span class="math inline">\([0,1]\)</span> 上均匀分布的随机变量。记 <span class="math inline">\((N_1,N_2,\ldots)=(1,2,4,8,\ldots)\)</span>，<span class="math inline">\(-N_{m}\)</span> 将作为我们第 <span class="math inline">\(m\)</span> 次重启的出发时间。</p><div id="coupling-from-the-past-------" class="statement sta_coupling_from_the_past___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Coupling from the past 算法</span>.</span><span class="statement-spah"> </span>：</p><ol type="1"><li>令 <span class="math inline">\(m=1\)</span>。</li><li>对每个 <span class="math inline">\(s\in S\)</span>，以 <span class="math inline">\(s\)</span> 为初始状态，以 <span class="math inline">\(-N_m\)</span> 为初始时刻向时刻 0 的方向运行 Markov链 <span class="math inline">\(M\)</span>，所有 <span class="math inline">\(|S|\)</span> 个链使用的随机数流是一样的，都是<span class="math inline">\((U_{-N_m+1},\ldots,U_{-1},U_0)\)</span>。</li><li>如果步骤 2 中的 <span class="math inline">\(|S|\)</span> 个链在时刻0 给出的状态相同，记此状态为 <span class="math inline">\(s^\ast\)</span>，则输出 <span class="math inline">\(s^\ast\)</span> 并退出程序。否则将 <span class="math inline">\(m\)</span> 的值加 1 并重复步骤 2。</li></ol><p>下图显示了算法的每个重启时刻，相同颜色的随机数是在同一批中生成的。</p><p><img src="/images/cftp/random_numbers.svg" class="fig"></p><p><strong>断言</strong>：如果上述步骤以概率 1在有限时间内结束，则其返回值 <span class="math inline">\(s^\ast\)</span>服从平稳分布 <span class="math inline">\(\pi\)</span>: <span class="math display">\[\mathbb{P}(s^\ast = s) = \pi(s),\quad \foralls\in S.\]</span></p></div><p>注意这里的两个细节：</p><ol type="1"><li>我们强调了前提<strong>如果算法以概率 1在有限时间内结束，则返回值服从平稳分布</strong>。为了保证这个前提成立更新函数<span class="math inline">\(f\)</span>的选择就不能是任意的，特别地在后面的 monotone CFTP 中更新函数还要与<span class="math inline">\(S\)</span>上的偏序相容，更不能是任意的。</li><li>当第 <span class="math inline">\(m\)</span> 次执行步骤 2时，使用的随机数为 <span class="math inline">\((U_{-N_m+1},U_{-N_m+2},\ldots,U_{-1},U_0)\)</span>，其中的后半部分<span class="math inline">\((U_{-N_{m-1}+1},U_{-N_{m-1}+2},\ldots,U_{-1},U_0)\)</span>需要与上一次使用的相同，<strong>即每一次都重复使用上一次的随机数作为后半段的随机源</strong>，否则每次都重新生成一列新的随机数的话得到的最终状态未必服从平稳分布。</li></ol><p><strong>证明</strong>：任取 <span class="math inline">\(s_i\inS\)</span>，只要证明对任何 <span class="math inline">\(\epsilon&gt;0\)</span> 都有 <span class="math display">\[|\mathbb{P}(s^\ast=s_i) -\pi(s_i)|&lt;\epsilon.\]</span> 设 <span class="math inline">\(\Omega=\{(U_{-1},U_{-2},\ldots)\mid U_i \text{i.i.d on } [0,1]\}\)</span> 是所有随机数流组成的样本空间， <span class="math display">\[A=\{\omega\in\Omega\mid\text{算法在有限时间内结束}\}.\]</span> 则由已知有 <span class="math inline">\(\mathbb{P}(A)=1\)</span>。又记 <span class="math display">\[A_i = \{ \omega\in\Omega\mid \text{算法从某个$\geq -N_i$ 的时刻出发可以结束}\}.\]</span></p><p>显然我们有 <span class="math inline">\(A_i\uparrow A\)</span>，<span class="math inline">\(\mathbb{P}(A_i)\uparrow\mathbb{P}(A)=1\)</span>。因此对充分大的<span class="math inline">\(K\)</span> 有 <span class="math inline">\(\mathbb{P}(A_K) \geq1-\epsilon\)</span>。取定这样的 <span class="math inline">\(K\)</span>，则在事件 <span class="math inline">\(A_K\)</span> 上，所有的链在时刻 0 耦合到相同的状态<span class="math inline">\(s^\ast\)</span>。</p><p>除了以上 <span class="math inline">\(|S|\)</span>条链之外，我们再额外跑一条单独的链 <span class="math inline">\(Y\)</span>，这条链的初始状态选自平稳分布 <span class="math inline">\(\pi\)</span>，也从时刻 <span class="math inline">\(-N_K\)</span> 出发，也使用相同的随机数 <span class="math inline">\((U_{-N_K+1},\ldots,U_0)\)</span> 运行至时刻0，并设这个链在时刻 0 的状态为 <span class="math inline">\(Y_0\)</span>，则 <span class="math inline">\(Y_0\)</span> 服从平稳分布。</p><p>在事件 <span class="math inline">\(A_K\)</span>上，不管这条单独的链初始状态是什么，由于它使用了同样的随机数序列，所以它最后一定会和其余<span class="math inline">\(|S|\)</span> 条链一起耦合，所以 <span class="math display">\[\mathbb{P}(s^\ast=Y_0) \geq \mathbb{P}(A_K)\geq 1- \epsilon.\]</span> 从而对任何 <span class="math inline">\(s_i\inS\)</span>， <span class="math display">\[\begin{aligned}\mathbb{P}(s^\ast =s_i)-\pi(s_i)&amp;= \mathbb{P}(s^\ast = s_i)-\mathbb{P}(Y_0 =s_i)\\&amp;\leq\mathbb{P}(s^\ast=s_i, Y_0\ne s_i)\\&amp;\leq\mathbb{P}(Y_0\nes^\ast)\\&amp;\leq\epsilon.\end{aligned}\]</span> 类似地 <span class="math display">\[\begin{aligned}\pi(s_i)-\mathbb{P}(s^\ast =s_i)&amp;=\mathbb{P}(Y_0 = s_i)-\mathbb{P}(s^\ast =s_i)\\&amp;\leq\mathbb{P}(Y_0=s_i, s^\ast\ne s_i)\\&amp;\leq\mathbb{P}(Y_0\nes^\ast)\\&amp;\leq\epsilon.\end{aligned}\]</span> 从而 <span class="math display">\[|\mathbb{P}(s^\ast = s_i)-\pi(s_i)| \leq\epsilon.\]</span> 令 <span class="math inline">\(K\to\infty\)</span>，则 <span class="math inline">\(\epsilon\downarrow0\)</span>。注意到对任何样本点<span class="math inline">\(\omega\in A_K\)</span>，如果 <span class="math inline">\(\omega\)</span> 给出的所有链的耦合状态是 <span class="math inline">\(s^\ast=s_i\)</span>，则从更久远的时刻出发，<span class="math inline">\(\omega\)</span> 给出的耦合状态仍然是 <span class="math inline">\(s_i\)</span>，即 <span class="math inline">\(\omega\)</span> 输出的采样结果 <span class="math inline">\(s^\ast\)</span> 是不会随着 <span class="math inline">\(K\)</span> 增大而改变的，所以由 <span class="math inline">\(\epsilon\)</span> 的任意性即得 <span class="math inline">\(s^\ast\)</span> 服从平稳分布。</p><h1 id="算法中的若干陷阱">算法中的若干陷阱</h1><p>CFTP算法的证明看似不难，但其实微妙之处不少，值得细细品味。最主要的地方有三个：</p><blockquote><p><strong>问题 1</strong>：为什么说更新函数 <span class="math inline">\(f\)</span> 的选择不能是任意的？</p><p><strong>问题 2</strong>：既然 「coupling from the past」 可以，那「coupling to the future」 可不可以？从时刻 0 开始从每个 <span class="math inline">\(s\in S\)</span> 出发跑 <span class="math inline">\(|S|\)</span> 个不同的链，直到它们在未来某个时刻<span class="math inline">\(n\)</span>耦合为止，然后输出第一次耦合时的状态不行吗？</p><p><strong>问题 3</strong>：每次重启步骤 2时需要复用之前的随机数，这一点在证明中哪里用到了？使用一列新的随机数为什么不可以？</p></blockquote><p>我们用几个例子来说明这三个问题。</p><h2 id="为什么更新函数不能是任意的">为什么更新函数不能是任意的</h2><p>考虑含有两个状态 <span class="math inline">\(S=\{s_1, s_2\}\)</span>的 Markov 链，其转移矩阵为 <span class="math inline">\(P=\begin{bmatrix}0.5 &amp; 0.5\\0.5 &amp;0.5\end{bmatrix}\)</span>，更新函数为 <span class="math display">\[f(s_1, u) =\begin{cases}\begin{array}{ll}s_1&amp; \text{for } u \in [0, 0.5)\\s_2 &amp; \text{for } u \in [0.5,1]\end{array}\end{cases}\]</span> 和 <span class="math display">\[f(s_2,u) =\begin{cases}\begin{array}{ll}s_2 &amp; \text{for } u \in [0,0.5)\\s_1 &amp; \text{for } u \in [0.5,1]\end{array}\end{cases}\]</span> 于是若从 <span class="math inline">\(s_1,s_2\)</span>分别出发跑两个不同的链，但是每次使用相同的随机数，则它们要么保持不动，要么交换状态，永不耦合。</p><h2 id="为什么-coupling-into-the-future-不行">为什么 Coupling into thefuture 不行</h2><p>我打赌任何看到 CFTP算法的人都会想到同样的问题：为什么不能向未来耦合呢？</p><blockquote><p><strong>Coupling into the future</strong>: 从时刻 0 出发同时跑 <span class="math inline">\(|S|\)</span> 个不同的链，其中链 <span class="math inline">\(i\)</span> 的初始状态是 <span class="math inline">\(s_i\)</span>。当所有链首次耦合到同一状态 <span class="math inline">\(s^\ast\)</span> 时，终止算法并输出 <span class="math inline">\(s^\ast\)</span> 作为采样状态。</p></blockquote><p>向未来耦合与 CFTP有一个根本不同：向未来耦合的结束时间是一个随机时间，而在 CFTP中，我们总是在固定的时刻 0 观察所有链是否耦合。</p><p>我们来试试把上面 CFTP 的证明照抄在这里：设 <span class="math inline">\(\tau\)</span> 是所有 <span class="math inline">\(|S|\)</span> 条链首次耦合的时间，<span class="math inline">\(Y\)</span> 是额外的从时刻 0出发的、初始分布为平稳分布的链，并且使用相同的随机数流，则对任何时刻<span class="math inline">\(n\ge0\)</span>，<span class="math inline">\(Y_n\)</span>都服从平稳分布。但是当把下标换成随机时间 <span class="math inline">\(\tau\)</span> 时，<span class="math inline">\(Y_\tau\)</span>未必仍然服从平稳分布，所以之前的证明不再可用。</p><p>我们用一个反例来说明：仍然考虑两个状态 <span class="math inline">\(S=\{s_1, s_2\}\)</span> 的 Markov 链，其转移矩阵为<span class="math inline">\(P=\begin{bmatrix}0.5 &amp; 0.5\\1 &amp;0\end{bmatrix}\)</span>，即从 <span class="math inline">\(s_1\)</span>出发的话以 0.5 的概率待在原地，以 0.5 的概率跳到 <span class="math inline">\(s_2\)</span>，从 <span class="math inline">\(s_2\)</span> 出发的话则总是跳到 <span class="math inline">\(s_1\)</span>。</p><p><img style="margin:0px auto;display:block" width="250" src="/images/cftp/counter_example.svg"></p><p>这个链的平稳分布为 <span class="math inline">\(\pi=(\frac{2}{3},\frac{1}{3})\)</span>。现在假设从<span class="math inline">\(s_1,s_2\)</span> 分别出发，从时刻 0 开始向<span class="math inline">\(+\infty\)</span> 方向跑两个不同的链，<span class="math inline">\(\tau\)</span> 是它们首次耦合的时间，则 <span class="math inline">\(\tau-1\)</span> 时刻它俩必然一个位于 <span class="math inline">\(s_1\)</span>，一个位于 <span class="math inline">\(s_2\)</span>。但是位于 <span class="math inline">\(s_2\)</span> 的状态只能转移到 <span class="math inline">\(s_1\)</span>，所以 <span class="math inline">\(\tau\)</span> 时刻的输出永远是 <span class="math inline">\(s_1\)</span>，从而得到的采样 <span class="math inline">\(Y_\tau\)</span> 不满足平稳分布。</p><h2 id="为什么每次不能重新生成随机数">为什么每次不能重新生成随机数</h2><p>思考一下，在算法的证明当中，如果在每次迭代中都使用全新的随机数序列的话，那么事件<span class="math inline">\(A\)</span> 的定义会变成什么？难道是 <span class="math inline">\(\Omega\)</span>的某个有限子集，使得其包含一个可以耦合的序列？Hmm，这就不太对劲了。直观上看，在第<span class="math inline">\(m\)</span>次迭代时，由于生成的序列是全新的，有可能它实际上对某个 <span class="math inline">\(i&lt;m\)</span>，从 <span class="math inline">\(-N_i\)</span>出发就可以耦合，这会导致算法过度采样那些很快就可以耦合的短链，从而使得最终的分布不服从平稳分布。</p><p>我们继续用上一小节中的例子来说明。我们指定其更新函数 <span class="math inline">\(f\)</span>为随机映射表示一节中给出的阶梯函数形式。假设算法每次都使用一列新的随机数，其最终输出为<span class="math inline">\(s^\ast\)</span>。定义随机变量 <span class="math inline">\(\tau\)</span> 为正整数 <span class="math inline">\(m\)</span> 使得算法中使用的最早的出发时间为 <span class="math inline">\(-N_m\)</span>，则 <span class="math display">\[\begin{aligned}\mathbb{P}(s^\ast=s_1)&amp;=\sum_{m=1}^\infty\mathbb{P}(s^\ast=s_1,\tau=m)\\&amp;\geq\mathbb{P}(s^\ast=s_1,\tau=1)+\mathbb{P}(s^\ast=s_1,\tau=2)\\&amp;=\mathbb{P}(\tau=1)\mathbb{P}(s^\ast=s_1|\tau=1)+\mathbb{P}(\tau=2)\mathbb{P}(s^\ast=s_1|\tau=2)\end{aligned}\]</span> 注意事件 <span class="math inline">\(\{\tau=1\}\)</span> 包含两种不同的演化路径： <span class="math display">\[\begin{aligned}(1)\quad &amp; s_1\to s_1,\quads_2\to s_1.\\(2)\quad &amp; s_1\to s_2,\quad s_2\to s_1.\end{aligned}\]</span>其中只有前者能成功耦合，所以 <span class="math inline">\(\mathbb{P}(\tau=1)=\frac{1}{2}\)</span>，这时输出的状态只能是<span class="math inline">\(s_1\)</span>，所以<span class="math inline">\(\mathbb{P}(s^\ast=s_1|\tau=1)=1\)</span>。</p><p>可以看到这个长度是 1 的短链的耦合只发生在状态 <span class="math inline">\(s_1\)</span> 上，它非常偏爱 <span class="math inline">\(s_1\)</span>。</p><p>事件 <span class="math inline">\(\{\tau=2\}\)</span>包含四种不同的演化路径： <span class="math display">\[\begin{align*}(1)\quad &amp; s_1\to s_1\tos_1,\quad s_2\to s_1 \to s_1.\\(2)\quad &amp; s_1\to s_2\to s_1,\quad s_2\to s_1 \to s_1.\\(3)\quad &amp; s_1\to s_1\to s_2,\quad s_2\to s_1 \to s_2.\\(4)\quad &amp; s_1\to s_2\to s_1,\quad s_2\to s_1 \tos_2.\end{align*}\]</span>注意以下两种演化路径是非法的，因为每个时刻两个链使用的随机数一样，不可能在某个时刻同时出现一个链<span class="math inline">\(s_1\to s_2\)</span>，另一个 <span class="math inline">\(s_1\to s_1\)</span> 的情况： <span class="math display">\[\begin{array}{ll}(*)\quad &amp; s_1\to s_1\to s_2,\quad &amp;s_2\to s_1 \to s_1.\\(**)\quad &amp; s_1\to s_1\to s_1,\quad &amp;s_2\to s_1 \to s_2.\\\end{array}\]</span></p><p>在我们现在这个错误的版本中，由于使用了全新的随机数流，四种路径都是合法的。这四个路径中前三种都成功耦合，两个耦合于<span class="math inline">\(s_1\)</span> 一个耦合于 <span class="math inline">\(s_2\)</span>，所以 <span class="math inline">\(\mathbb{P}(s^\ast=s_1|\tau=2)=\frac{2}{3}\)</span>。</p><p>注意到其中第二条路径 <span class="math display">\[(2)\quad  s_1\tos_2\to s_1,\quad s_2\to s_1 \to s_1.\]</span> 从时刻 <span class="math inline">\(-1\)</span> 出发就可以耦合，它不应该属于事件 <span class="math inline">\(\{\tau=2\}\)</span>。每次使用全新的随机数流会导致偏爱<span class="math inline">\(s_1\)</span> 的短链被过度采样。</p><p>我们来具体验证一下： <span class="math display">\[\mathbb{P}(\tau=2)=\mathbb{P}(\tau\ne1)\cdot\mathbb{P}(\tau=2\\text{时耦合})=\frac{1}{2}\cdot\frac{3}{4}=\frac{3}{8}.\]</span></p><p>所以 <span class="math display">\[\begin{align*}\mathbb{P}(s^\ast=s_1)&amp;\geq\mathbb{P}(\tau=1)\mathbb{P}(s^\ast=s_1|\tau=1)+\mathbb{P}(\tau=2)\mathbb{P}(s^\ast=s_1|\tau=2)\\&amp;=\frac{1}{2}\cdot1+ \frac{3}{8}\cdot\frac{2}{3}\\&amp;=\frac{3}{4}&gt;\pi(s_1).\end{align*}\]</span></p><p>确实如我们的预言，<span class="math inline">\(s_1\)</span>被过度采样了。</p><h1 id="monotone-coupling-from-the-past">Monotone coupling from thepast</h1><p>在 CFTP 算法中，我们需要同时跑 <span class="math inline">\(|S|\)</span> 个不同的链并要求它们在时刻 0处耦合，当 <span class="math inline">\(|S|\)</span>很大时所耗的时间和计算量都很不划算，所以这个算法在应用中是有限制的。但是有一种情形它是非常好用的：如果<span class="math inline">\(S\)</span> 是一个偏序集 <span class="math inline">\((S, \preceq)\)</span>，有最大最小元 <span class="math inline">\(s_\max, s_\min\)</span>，并且更新函数 <span class="math inline">\(f\)</span> 与偏序 <span class="math inline">\(\preceq\)</span> 相容，即对任何 <span class="math inline">\(s,s'\in S\)</span>，<span class="math inline">\(u\in[0,1]\)</span>， <span class="math display">\[s\preceq s' \Rightarrow f(s, u) \preceqf(s', u),\]</span> 则我们只要对 <span class="math inline">\(s_\max,s_\min\)</span>这两个状态跑两个不同的链即可，当它俩耦合时，所有其它的链也会被“挤压”到相同的状态。这就是前面六边形的菱形密铺取样所采取的方法。</p><p>我们在所有菱形密铺组成的集合 <span class="math inline">\(S\)</span>上定义一个偏序 <span class="math inline">\(\preceq\)</span>，这个偏序的定义颇有技巧性，它需要将任一密铺对应到一个不相交的格点路径组，如下图所示：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/non-intersecting_paths_lozenge.svg"></p><p>图中一共出现了 <span class="math inline">\(c+2\)</span>条不相交的路径，其中最上方和最下方两条路径对任何密铺都是固定的（它俩是用来约束中间的 <span class="math inline">\(c\)</span>条路径，让它们在翻转的过程不要越界），中间的 <span class="math inline">\(c\)</span>条路径，每条路径的起点和终点也是固定的，它们从菱形最左边的边的每个单位线段中点出发，每一步分别向右上或者右下走一步，经过<span class="math inline">\(a+b\)</span>步后到达最右边的边的对应位置。</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/two_paths.svg"></p><p>上图中从菱形的最左边到最右边共有 <span class="math inline">\(a+b+1\)</span>条竖直的网格线，每一步向右上或者右下走一步会向右移动到下一个网格线，所以总共需要<span class="math inline">\(a + b\)</span>次到达最右边。不同的路径互不相交，所以它们的终点必须互不相同，因此这些终点必然分别依次是菱形最右边的单位线段的中点。</p><p>不难说明所有的菱形密铺和所有不相交路径组之间的一一对应关系：当密铺给定时，从左边每个起点出发开始，根据当前菱形的倾斜方向依次描出路径即可；反之当路径组给定时，可以沿着每条路径铺砖，这样确定所有的“斜”菱形的位置，余下的空白位置只有唯一的方式可以被水平的菱形填充。</p><p>我们在所有不相交的路径组之间定义一个偏序：两个路径组 <span class="math inline">\(\mathcal{P}\preceq\mathcal{P}'\)</span>当且仅当对任何 <span class="math inline">\(1\leq i\leqc+2\)</span>，<span class="math inline">\(\mathcal{P}\)</span> 中的第<span class="math inline">\(i\)</span> 条路径 <span class="math inline">\(p_i\)</span> 整体地位于 <span class="math inline">\(\mathcal{P}'\)</span> 中第 <span class="math inline">\(i\)</span> 条路径 <span class="math inline">\(p_i'\)</span>的下方。在这个偏序下的最大元就是所有路径尽可能地「向上拱」：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/max_state.svg"></p><p>而最小元则是所有路径尽可能地「向下走」：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/min_state.svg"></p><p>有了偏序，我们还要定义一个与之相容的更新函数 <span class="math inline">\(f\)</span>。<span class="math inline">\(f\)</span>的定义是这样的：对一个不相交路径组 <span class="math inline">\(\mathcal{P}\)</span>，我们每次在 <span class="math inline">\(\mathcal{P}\)</span> 的中间 <span class="math inline">\(c\)</span> 条路径中，在路径内部 （两头端点除外）任选一个顶点 <span class="math inline">\(v\)</span>：</p><ol type="1"><li>如果 <span class="math inline">\(v\)</span> 是一个「山峰」，即形如<span class="math inline">\(\wedge\)</span>，则我们以 1/2 的概率保持<span class="math inline">\(\mathcal{P}\)</span> 不变，以 1/2的概率尝试将 <span class="math inline">\(\mathcal{P}\)</span> 在 <span class="math inline">\(v\)</span> 处翻转为一个「山谷」 <span class="math inline">\(\vee\)</span>，如果翻转之后得到的路径组 <span class="math inline">\(\mathcal{P}'\)</span>仍然满足路径之间不相交的约束，则规定 <span class="math inline">\(\mathcal{P}'=f(\mathcal{P})\)</span>，否则仍然保持<span class="math inline">\(\mathcal{P}\)</span> 不变。</li><li>如果 <span class="math inline">\(v\)</span> 是一个「山谷」，即形如<span class="math inline">\(\vee\)</span>，则与上面的情形类似，我们以1/2 的概率保持 <span class="math inline">\(\mathcal{P}\)</span> 不变，以1/2 的概率尝试将 <span class="math inline">\(\mathcal{P}\)</span> 在<span class="math inline">\(v\)</span> 处翻转为一个「山峰」 <span class="math inline">\(\wedge\)</span>，如果翻转之后得到的路径组满足不相交的约束，则规定<span class="math inline">\(\mathcal{P}'=f(\mathcal{P})\)</span>，否则仍然保持<span class="math inline">\(\mathcal{P}\)</span> 不变。</li><li>如果 <span class="math inline">\(v\)</span>既不是「山峰」也不是「山谷」，则保持 <span class="math inline">\(\mathcal{P}\)</span> 不变。</li></ol><p>菱形密铺在三维空间中看起来像是「堆箱子」，这个翻转路径的操作就相当于从中添加/移除一个箱子，并且必须保证这个箱子有三个面可见：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/cftp/flip_lozenge.svg"></p><p>我们来验证 <span class="math inline">\(f\)</span>是和路径组之间的偏序 <span class="math inline">\(\preceq\)</span>相容的：设 <span class="math inline">\(\mathcal{P}\preceq\mathcal{P}'\)</span>是两个不相交路径组，对给定的随机操作 <span class="math inline">\(u\)</span>，<span class="math inline">\(f(\mathcal{P}, u)\)</span> 和 <span class="math inline">\(f(\mathcal{P}', u)\)</span> 就是对 <span class="math inline">\(\mathcal{P}\)</span> 和 <span class="math inline">\(\mathcal{P}'\)</span> 的同一个位置 <span class="math inline">\((k, j)\)</span>（即第 <span class="math inline">\(k\)</span> 条路径中的第 <span class="math inline">\(j\)</span> 个顶点）同时尝试进行一个 <span class="math inline">\(\vee\to\wedge\)</span> 或者 <span class="math inline">\(\wedge\to\vee\)</span> 的操作。不妨假设这个操作是<span class="math inline">\(\vee\to\wedge\)</span>，则有四种可能的结果：<span class="math inline">\(\mathcal{P}\)</span> 和 <span class="math inline">\(\mathcal{P}'\)</span>都操作成功，都保持不变或者一个操作成功另一个保持不变。不难验证这四种情况下都有<span class="math inline">\(f(\mathcal{P},u)\preceq f(\mathcal{P}',u)\)</span>。</p><p>由于每个不相交的路径组都可以通过适当操作变为最大元或者最小元，所以这个链是个互通的Markov 链。并且由于 <span class="math inline">\(\mathcal{P}\)</span>以至少 1/2 的概率在 <span class="math inline">\(f\)</span>下保持不变，这个链还是非周期的，因此是一个遍历的 Markov链，所以有唯一的平稳分布。但是不难看到这个链还是对称的，所以这个唯一的平稳分布是均匀分布。即从最大元和最小元出发跑CFTP，最终得到的样本服从全体菱形密铺上的均匀分布。</p><p>Monotone CFTP 也可以应用在其它许多密铺问题的均匀采样中，例如下图是在<span class="math inline">\(20\times 20\)</span>的矩形区域的所有多米诺骨牌密铺中均匀采样，同样可以把密铺一一对应到不相交的路径组：</p><p><img style="margin:0px auto;display:block" width="600" src="/images/cftp/domino_tiling_example.svg"></p><h1 id="参考文献">参考文献</h1><ol type="1"><li>Finite Markov chains and algorithmic applications, OlleHäggström.</li><li><a href="https://pages.uoregon.edu/dlevin/MARKOV/mcmt2e.pdf">Markovchains and mixing times</a>, Yuval Peres, Elizabeth L. Wilmer, David A.Levin.</li><li><a href="https://www.researchgate.net/publication/2455641_Markov_Chain_Algorithms_for_Planar_Lattice_Structures">MarkovChain Algorithms for Planar Lattice Structures</a>, Michael Luby, DanaRandall, Alistair Sinclair.</li><li><a href="https://arxiv.org/abs/math/0102193">Mixing times of lozengetiling and card shuffling Markov chains</a>, David B. Wilson.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 完美采样 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>递降平面分拆的 Andrews 猜想</title>
      <link href="/descending-plane-partitions/"/>
      <url>/descending-plane-partitions/</url>
      
        <content type="html"><![CDATA[<p>你可能经常听到这样一句话：“做数学要大胆假设，小心求证”。我们今天要介绍的故事主角平面分拆中的Andrews猜想就完美地符合这一点。两个看似风马牛不相及的计数对象，因为有着相同的计数序列，冥冥中被联系在了一起，启发三位数学家Mill, Robins 和 Rumsey解决了一个困难的组合学猜想。整个过程并无高深的内容，但是其中的“信仰一跃”和“灵魂一猜”构成了故事的高潮，而那些繁琐的计算过程不过是小心求证的注脚而已。</p><p>本文来自我几年前读 David Bressoud 的 <span class="citation" data-cites="Bressoud1999">(<a href="#ref-Bressoud1999" role="doc-biblioref">Bressoud 1999</a>)</span></p><blockquote><p>Proofs and Confirmations: The Story of the Alternating Sign MatrixConjecture</p></blockquote><p>一书时的读书笔记。我这里采用的叙述方式与 Bressoud 的书不同：Bressoud是把 DPP 的 Andrews 猜想和 CSPP 的 Macdonald 猜想统一用 <span class="math inline">\(q\)</span>- 超几何级数一起解决的。Macdonald猜想的证明似乎无法避免使用超几何级数的知识，但 Andrews猜想是完全可以仅使用初等的 <span class="math inline">\(q\)</span>-多项式解决的。本文只介绍 DPP 的 Andrews 猜想，并仅使用初等的 <span class="math inline">\(q\)</span>- 二项式定理作为工具。</p><span id="more"></span><h1 id="问题描述">问题描述</h1><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>一个<strong>严格错位平面分拆</strong> (strict shifted planepartition) 是一个二维的正整数数组 <span class="math inline">\(\pi\)</span>，其形状如下： <span class="math display">\[\begin{matrix}a_{11}&amp;a_{12}&amp;\cdots&amp;\cdots&amp;\cdots&amp;a_{1,\lambda_1}\\      &amp;a_{22}&amp;\cdots&amp;\cdots&amp;\cdots&amp;a_{2,\lambda_2+1}\\      &amp;&amp;\ddots&amp;\cdots&amp;\cdots&amp;\cdots\\      &amp;&amp;&amp;a_{mm}&amp;\cdots&amp;a_{m,\lambda_m+m-1}\end{matrix}\]</span> 其中 <span class="math inline">\(\pi\)</span>满足如下限制条件：</p><ol type="1"><li>每一行与上一行相比都缩进 1 个位置。第 <span class="math inline">\(i\)</span> 行的非零元个数为 <span class="math inline">\(\lambda_i\)</span>。</li><li>每一行从左到右是弱递减的：<span class="math inline">\(a_{ij}\geqa_{i,j+1}\)</span>。</li><li>每一列从上到下是严格递减的：<span class="math inline">\(a_{ij}&gt;a_{i+1,j}\)</span>。</li></ol><p>此外如果 <span class="math inline">\(\pi\)</span>满足任何一行的长度严格小于该行第一个元素，并且大于等于下一行的第一个元素，即<span class="math display">\[a_{11}&gt;\lambda_1\geq a_{22}&gt;\lambda_2\geq\cdots\geqa_{mm}&gt;\lambda_m,\]</span> 就称 <span class="math inline">\(\pi\)</span>是一个<strong>递降平面分拆</strong> (descending planepartition，本文以下简称为 DPP)。显然 DPP 是严格错位平面分拆的子集。</p><p>记 <span class="math inline">\(|\pi|=\sum_{i,j}a_{ij}\)</span> 为<span class="math inline">\(\pi\)</span> 的所有元素之和。</p></div><p>OK，我知道在一个定义里面一下子塞进去这么多概念会让人很晕，所以下面是一张插图：任何类型的平面分拆从“空间鸟瞰图”的角度去看都是在房间中按照一定的规则“堆方块”。例如DPP 分拆 <span class="math display">\[\pi\ =\ \begin{matrix}7&amp;7&amp;6&amp;6&amp;3&amp;1\\&amp;6&amp;5&amp;4&amp;2\\&amp;&amp;3&amp;3\\&amp;&amp;&amp;2\end{matrix}\]</span> 对应的鸟瞰图如下图所示：</p><p><img src="/images/dpp/dpp_example.png" class="fig" width="500"></p><p>你可以看到数组的每一行与方块的每一层一一对应。由于 <span class="math inline">\(\pi\)</span>是严格错位平面分拆，所以每一层相对于下面一层在两个方向上分别缩进一个单位以后仍然可以被下面一层托住，从而不会出现“悬空”的方块。</p><p>设 <span class="math inline">\(\mathrm{dpp}(n)\)</span>为所有数字均不超过 <span class="math inline">\(n\)</span> 的 DPP组成的集合，这样的 DPP 最多有 <span class="math inline">\(n-1\)</span>行，每一行长度最多是 <span class="math inline">\(n-1\)</span>，每个元素不大于 <span class="math inline">\(n\)</span>，所以必然能装进一个大小为 <span class="math inline">\(n\times n\times n\)</span> 的空间（当然不可能填满）。我们的目标是求出生成函数 <span class="math display">\[\sum_{\pi\in \mathrm{dpp}(n)} q^{|\pi|}.\]</span></p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span><span class="math inline">\(\mathrm{dpp}(3)\)</span> 总共包含 7种不同的分拆 （空分拆也算一种）： <span class="math display">\[\mathrm{dpp}(3)=\big\{  \begin{array}{ccccccc}  \emptyset,  &amp;\begin{matrix}3&amp;3\\&amp;2\end{matrix},  &amp;2,  &amp;\begin{matrix}3&amp;3\end{matrix},  &amp;3,  &amp;\begin{matrix}3&amp;2\end{matrix},  &amp;\begin{matrix}3&amp;1\end{matrix}  \end{array}  \big\}.\]</span> 所以其 <span class="math inline">\(q\)</span>- 计数为 <span class="math display">\[\sum_{\pi\in \mathrm{dpp}(3)} q^{|\pi|}=1+q^2+q^3+q^4+q^5+q^6+q^8.\]</span></p></div><p><a href="https://en.wikipedia.org/wiki/George_Andrews_(mathematician)">GeorgeAndrews</a> 发现，这个生成函数可以表示为一个 <span class="math inline">\(q\)</span>- 行列式： <span class="math display">\[\sum_{\pi\in \mathrm{dpp}(n)} q^{|\pi|}=\det\left(  \delta_{ij}+q^{i+1}    \binom{i+j}{j-1}_q    \right)_{1\leq i,j\leq n-1}.\]</span> Andrews 会求 DPP 的计数序列，即 <span class="math inline">\(q=1\)</span> 的情形，但是不会算这个 <span class="math inline">\(q\)</span>- 行列式。事实上这个问题最难的地方就在求<span class="math inline">\(q\)</span>- 行列式这一步上！不过 Andrews猜出了这个行列式的表达式：</p><div id="Andrews-conjecture" class="statement sta_andrews___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Andrews猜想</span>.</span><span class="statement-spah"> </span><br></p><p><span class="math display">\[\det\left(\delta_{ij}+q^{i+1}\binom{i+j}{j-1}_q\right)_{1\leqi,j\leq n-1}=\prod_{1\leq i\leq j\leqn}\frac{1-q^{n+i+j-1}}{1-q^{2i+j-1}}.\]</span></p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>注意上式右边下标 <span class="math inline">\(i,j\)</span>的范围是 <span class="math inline">\(1\leq i\leq j\leq n\)</span>！</p></div><p>这个猜想最终在 80 年代由 Mills, Robbins, Rumsey 三人解决 <span class="citation" data-cites="Mills1983">(<a href="#ref-Mills1983" role="doc-biblioref">Mills, Robbins, and Rumsey1983</a>)</span>，整个证明过程可谓一波三折，既需要缜密细心的推理，也不乏大胆的猜测，本文接下来就来介绍他们的证明。</p><h1 id="故事的开始">故事的开始</h1><p>了解 DPP背后的故事对理解证明是很有帮助的。对第一次接触递降平面分拆这个名词的读者来说，可能会纳闷：“数学家们为什么要考虑这种看起来很奇怪的计数问题呢？它似乎不像代数几何、数论中的问题那么有分量，而且还有一些不明所以的限制条件”。这是一种错觉，平面分拆简单的外表背后有许多深刻而有趣的理论。DPP最初是上世纪 70 年代 Andrews 在研究另一类平面分拆循环对称平面分拆 （简称CSPP） 时得到的副产品，我们之前提到 Andrews 会算 DPP 计数序列在 <span class="math inline">\(q=1\)</span> 的情形，也猜出了 <span class="math inline">\(q\)</span>-计数的正确答案，但是没有给出证明，不过那时 DPP作为众多平面分拆猜想之一并不显得特别重要。</p><p>差不多在与 Andrews 研究 DPP 同样的时期，数学家 Mills, Robbins, Rumsey三人正在为 <a href="https://en.wikipedia.org/wiki/Alternating_sign_matrix">交错符号矩阵</a>（Alternating Sign Matrix，以下简称 ASM） 猜想而苦苦挣扎，他们考虑的<span class="math inline">\(n\)</span>阶的交错符号矩阵是指满足如下条件的 <span class="math inline">\(n\timesn\)</span> 矩阵：</p><ol type="1"><li>每个元素取值为 <span class="math inline">\(1,-1,0\)</span>。</li><li>矩阵的每一行和每一列的和都是 1。</li><li>对每一行和每一列，其 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(-1\)</span> 交替出现。</li></ol><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>3 阶的交错符合矩阵共有 7 个，其中 6 个是置换矩阵，只有一个含有-1： <span class="math display">\[\begin{align*}&amp;\mathrm{ASM}(3)=\Bigg\{  \begin{pmatrix}1&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\end{pmatrix},  \begin{pmatrix}0&amp;0&amp;1\\0&amp;1&amp;0\\1&amp;0&amp;0\end{pmatrix},  \begin{pmatrix}1&amp;0&amp;0\\0&amp;0&amp;1\\0&amp;1&amp;0\end{pmatrix},\\  &amp;\begin{pmatrix}0&amp;0&amp;1\\1&amp;0&amp;0\\0&amp;1&amp;0\end{pmatrix},  \begin{pmatrix}0&amp;1&amp;0\\1&amp;0&amp;0\\0&amp;0&amp;1\end{pmatrix},  \begin{pmatrix}0&amp;1&amp;0\\0&amp;0&amp;1\\1&amp;0&amp;0\end{pmatrix},  \begin{pmatrix}0&amp;1&amp;0\\1&amp;-1&amp;1\\0&amp;1&amp;0\end{pmatrix}  \Bigg\}.\end{align*}\]</span></p></div><p>Mills 等人通过直观的杨辉三角法猜出了 <span class="math inline">\({\rmASM}(n)\)</span> 的计数序列，但是对怎样证明它毫无头绪，于是他们求助于MIT 的组合学大师 Stanley。Stanley 告诉他们自己也不知道答案，但是 Mills等人给出的 ASM 的计数序列<strong>看起来</strong>与 Andrews 得到的 DPP的计数序列是相同的： <span class="math display">\[|\mathrm{dpp}(n)|=|\mathrm{ASM}(n)|=\prod_{j=0}^{n-1}\frac{(3j+1)!}{(n+j+1)!}=1,2,7,42,429,\ldots\]</span> 于是 Mills 等人很自然地转而研究 DPP，希望从中找到解决 ASM猜想的办法。有趣的是他们没能解决 ASM 猜想 （1995/96 年由 Zeilberger 和Kuperberg 分别解决），倒是解决了 DPP 的 Andrews 猜想以及 CSPP 的Macdonald 猜想，这不能不说是“失之东隅，收之桑榆”。</p><p>Mills 等人的证明受到了 DPP 与 ASM<strong>貌似</strong>有相同的计数序列这个事情的启发。在一个 <span class="math inline">\(n\)</span> 阶 ASM 中，第一行必然有且只有一个 +1（否则有 -1 的话这个 -1 所在的列不可能满足 +1 和 -1 交替出现且列和为+1），这个 +1 所处的位置是一个重要的参数，根据这个 +1 所在的列 <span class="math inline">\(k\)</span> 可以把 <span class="math inline">\(\mathrm{ASM}(n)\)</span> 分成 <span class="math inline">\(n\)</span> 个子集 <span class="math inline">\(\{A_{n,k},k=1,\ldots,n\}\)</span>。Mills等人<strong>猜测</strong> <span class="math inline">\(A_{n,k}\)</span>的大小为 <span class="math display">\[\left|A_{n,k}\right|=  \begin{pmatrix}n+k-2\\k-1\end{pmatrix}  \frac{(2n-k-1)!}{(n-k)!}  \prod_{j=0}^{n-2}\frac{(3j+1)!}{(n+j)!}.\]</span> 既然 <span class="math inline">\(\mathrm{dpp}(n)\)</span> 和<span class="math inline">\({\rm ASM}(n)\)</span><strong>看起来</strong>是一样大小的，那是不是意味着它也应该有一个参数，将<span class="math inline">\(\mathrm{dpp}(n)\)</span> 对应地分为 <span class="math inline">\(n\)</span> 个不同的子集呢？</p><p>注意在一个 <span class="math inline">\(\pi\in\mathrm{dpp}(n)\)</span>中 <span class="math inline">\(n\)</span> 出现的次数 <span class="math inline">\(k\)</span> 满足 <span class="math inline">\(0\leqk\leq n-1\)</span>，不可能大于等于 <span class="math inline">\(n\)</span>。否则由于这些 <span class="math inline">\(n\)</span> 必然都在第一行，不满足 DPP的行首严格大于该行长度的限制。很自然地，Mills 等人猜测在一个 <span class="math inline">\(\pi\in\mathrm{dpp}(n)\)</span> 中数字 <span class="math inline">\(n\)</span>出现的次数就是对应的参数，而且他们猜测恰好含有 <span class="math inline">\(k\,(0\leq k\leq n-1)\)</span> 个 <span class="math inline">\(n\)</span> 的 DPP 的个数等于 <span class="math inline">\(|A_{n,k}|\)</span>，这个猜测在他们的证明中起着关键的作用。</p><p>证明的第一步是把计数问题转化为行列式的求值，为此我们需要一些关于Gauss 二项式系数的结论。</p><h1 id="一点预备知识">一点预备知识</h1><p>本文需要的预备知识大致分为三点：</p><ol type="1"><li><span class="math inline">\(q\)</span>- 二项式定理。</li><li>Gauss 路径的 <span class="math inline">\(q\)</span>- 计数。</li><li>格点图上不相交路径组计数的 Gessel-Viennot 引理。</li></ol><p>其中 Gessel-Viennot引理由于详细叙述起来比较占篇幅，这里就省略了，读者可以参考 <span class="citation" data-cites="thebook">(<a href="#ref-thebook" role="doc-biblioref">Aigner and Ziegler 2018</a>)</span> 的 “Latticepaths and determinants” 一节。</p><p><a href="https://en.wikipedia.org/wiki/Gaussian_binomial_coefficient">Gauss二项式系数</a> 的定义为 <span class="math display">\[\binom{n}{k}_q=\frac{(1-q^n)(1-q^{n-1})\cdots(1-q^{n-k+1})}{(1-q^k)(1-q^{k-1})\cdots(1-q)}.\]</span> 其中约定 <span class="math inline">\(\binom{n}{0}_q=1\)</span>以及 <span class="math inline">\(k&lt;0\)</span> 时 <span class="math inline">\(\binom{n}{k}_q=0\)</span>。</p><p>关于 Gauss 二项式系数的两个基本结论是：</p><div id="binom-thm1" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.1</span>.</span><span class="statement-spah"> </span><span class="math display">\[\prod_{k=0}^{n-1}(1+xq^k)=\sum_{k=0}^nq^{\binom{k}{2}}\binom{n}{k}_qx^k.\]</span></p></div><div id="binom-thm2" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.2</span>.</span><span class="statement-spah"> </span><span class="math display">\[\prod_{k=0}^{n}\frac{1}{1-xq^k}=\sum_{k=0}^\infty\binom{n+k}{k}_qx^k.\]</span></p></div><p>Gauss 二项式系数有不少等价的描述方式，我们这里要用到的是它等于 Gauss路径的 <span class="math inline">\(q\)</span>- 计数。</p><p>考虑格点图 <span class="math inline">\(\mathbb{Z}^2\)</span>，并设<span class="math inline">\(A=(0, m)\)</span>，<span class="math inline">\(B=(n,0)\)</span>。一条从 <span class="math inline">\(A\)</span> 到 <span class="math inline">\(B\)</span> 的 Gauss 路径 <span class="math inline">\(P\)</span> 是一个从 <span class="math inline">\(A\)</span>出发，每一步向右或者向下一个单位距离，经过 <span class="math inline">\(m+n\)</span> 步后到达 <span class="math inline">\(B\)</span> 的格点路径，如下图所示：</p><figure><img src="/images/dpp/gausspath.svg" width="350" alt="图中的圆圈标注了 P 的权重方格"><figcaption aria-hidden="true">图中的圆圈标注了 <span class="math inline">\(P\)</span> 的权重方格</figcaption></figure><p>这样的 Gauss 路径一共有 <span class="math inline">\(\binom{m+n}{n}\)</span> 条，它们组成的集合记作<span class="math inline">\(\mathcal{G}(m,n)\)</span>。</p><p>我们规定路径 <span class="math inline">\(P\)</span> 的权重为 <span class="math inline">\(q^{|P|}\)</span>，其中 <span class="math inline">\(|P|\)</span> 等于 <span class="math inline">\(P\)</span>与坐标轴所围成的区域中包含的方格的个数，上图中用圆圈标出了这些方格，一共有21 个，所以其权重为 <span class="math inline">\(q^{21}\)</span>。</p><p>关于 Gauss 路径的一个基本结论是，所有 <span class="math inline">\(\mathcal{G}(m,n)\)</span> 中路径的权重之和等于Gauss 二项式系数 <span class="math inline">\(\binom{m+n}{n}_q\)</span>：<span class="math display">\[\sum_{P\in\mathcal{G}(m,n)}q^{|P|} = \binom{m+n}{n}_q.\]</span></p><h1 id="将问题转化为行列式求值">将问题转化为行列式求值</h1><p>设 <span class="math inline">\(\pi\in\mathrm{dpp}(n)\)</span>的行首<strong>从下到上</strong>分别为 <span class="math inline">\(2\leqa_1 &lt;\cdots &lt; a_m\leq n\)</span>，注意 <span class="math inline">\(a_1\)</span> 是必须大于 1的，因为每一行的第一个元素必须大于该行的长度。我们的策略是先固定行首<span class="math inline">\(\{a_1,\ldots,a_m\}\)</span>，求出行首恰好为集合<span class="math inline">\(\{a_1,\ldots,a_m\}\)</span> 的那些 DPP的生成函数，然后再对 <span class="math inline">\(\{a_1,\ldots,a_m\}\)</span> 的所有可能求和。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>我们这里对 <span class="math inline">\(a_1,\ldots,a_m\)</span>的标记顺序与前面 DPP 定义中的行的顺序是反着来的，<span class="math inline">\(a_1\)</span> 是第 <span class="math inline">\(m\)</span> 行的行首，<span class="math inline">\(a_2\)</span> 是第 <span class="math inline">\(m-1\)</span> 行的行首，以此类推，<span class="math inline">\(a_m\)</span>是第一行的行首。这样做看起来有些奇怪，其实是为了后面记号方便，下面很快就会看到原因。</p></div><p>既然这些行首 <span class="math inline">\(\{a_1,\ldots,a_m\}\)</span>已经固定，我们就可以把这 <span class="math inline">\(\sum_{i=1}^ma_i\)</span> 个箱子移走 （后面补上 <span class="math inline">\(q^{\sum_{i=1}^ma_i}\)</span>的因子即可）。由于递降平面分拆中每一行的行首严格大于该行的长度，所以在第<span class="math inline">\(i\)</span> 行中删去行首 <span class="math inline">\(a_i\)</span> 以后，该行剩下的部分是一个长度 <span class="math inline">\(\lambda_i-1\leq a_i-2\)</span>，最大元素 <span class="math inline">\(\leq a_i\)</span>的序列。任何这样的序列都对应一条从 <span class="math inline">\((0,a_i)\)</span> 出发，每一步向右或者向下，到达 <span class="math inline">\((a_i-2,0)\)</span> 的 Gauss 路径 <span class="math inline">\(P_i\)</span>。所有这些 <span class="math inline">\(\{P_i\}\)</span>构成一个<strong>不相交的格点路径组</strong> <span class="math inline">\(\mathcal{P}=\{P_1,\ldots,P_m\}\)</span>，其起点集合为<span class="math inline">\(\{A_i=(0, a_i)\}\)</span>，终点集合为 <span class="math inline">\(\{B_j=(a_j-2,0)\}\)</span>，如下面的动画所示：</p><video src="/images/dpp/dpp-path.mp4" width="500" controls=""></video><p>将这些路径投影到地面上就得到如下的示意图：</p><figure><img src="/images/dpp/dpp-path.svg" class="fig" width="400" alt="路径是从下向上编号的，最左下角的路径是 P_1，向上依次为 P_2,\ldots,P_m。路径 P_i 从 y 轴上的点 (0,a_i) 出发，到达 x 轴上的 (a_i-2,0)。每个数字 k 对应路径中高度为 y=k 的水平一步。P_i 水平向右走 \lambda_i-1 步以后高度降为 0。由于 \lambda_i-1\leq a_i-2，所以 P_i 一定经过 x 轴上的点 (\lambda_i-1,0)。"><figcaption aria-hidden="true">路径是从下向上编号的，最左下角的路径是<span class="math inline">\(P_1\)</span>，向上依次为 <span class="math inline">\(P_2,\ldots,P_m\)</span>。路径 <span class="math inline">\(P_i\)</span> 从 <span class="math inline">\(y\)</span> 轴上的点 <span class="math inline">\((0,a_i)\)</span> 出发，到达 <span class="math inline">\(x\)</span> 轴上的 <span class="math inline">\((a_i-2,0)\)</span>。每个数字 <span class="math inline">\(k\)</span> 对应路径中高度为 <span class="math inline">\(y=k\)</span> 的水平一步。<span class="math inline">\(P_i\)</span> 水平向右走 <span class="math inline">\(\lambda_i-1\)</span> 步以后高度降为 0。由于 <span class="math inline">\(\lambda_i-1\leq a_i-2\)</span>，所以 <span class="math inline">\(P_i\)</span> 一定经过 <span class="math inline">\(x\)</span> 轴上的点 <span class="math inline">\((\lambda_i-1,0)\)</span>。</figcaption></figure><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>我们费点笔墨解释下为什么这些路径之间是没有交点的。注意我们现在对行的编号是从下向上。</p><p>首先 <span class="math inline">\(P_i\)</span> 和 <span class="math inline">\(P_{i+1}\)</span> 在 <span class="math inline">\(y\)</span> 轴上不会有交点，若不然，这只能是 <span class="math inline">\(P_{i+1}\)</span> 的第一步就竖直向下，这说明 <span class="math inline">\(P_{i+1}\)</span> 对应的行是空行，这不可能。</p><p>其次 <span class="math inline">\(P_i\)</span> 和 <span class="math inline">\(P_{i+1}\)</span> 在 <span class="math inline">\(x\)</span> 轴上也不会相交。这是因为 <span class="math inline">\(P_i\)</span> 在 <span class="math inline">\(x\)</span> 轴上的终点是 <span class="math inline">\((a_i-2,0)\)</span>，它上方的路径 <span class="math inline">\(P_{i+1}\)</span> 必然经过 <span class="math inline">\(x\)</span> 轴上的点 <span class="math inline">\((\lambda_{i+1}-1,0)\)</span>。由于 DPP 要求 <span class="math inline">\(i\)</span> 行的行首小于等于 <span class="math inline">\(i+1\)</span> 行的长度，<span class="math inline">\(\lambda_{i+1}\geq a_i\)</span>，即 <span class="math inline">\(\lambda_{i+1}-1&gt; a_i-2\)</span>，从而它们在<span class="math inline">\(x\)</span> 轴上无交点。</p><p>最后 <span class="math inline">\(P_i\)</span> 和 <span class="math inline">\(P_{i+1}\)</span>不会在第一象限内部有交点。若不然，设 <span class="math inline">\(v\)</span> 是它们的第一个交点，则 <span class="math inline">\(v\)</span> 必然是 <span class="math inline">\(P_i\)</span> 向右一步到达的点，同时也是 <span class="math inline">\(P_{i+1}\)</span> 向下一步到达的点。设 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(y\)</span> 坐标为 <span class="math inline">\(h&gt;0\)</span>，则 <span class="math inline">\(P_{i+1}\)</span> 在 <span class="math inline">\(v\)</span> 之后的第一条水平边的高度 <span class="math inline">\(h'\leq h\)</span>。然而在 <span class="math inline">\(\pi\)</span> 中 <span class="math inline">\(h'\)</span> 恰好位于 <span class="math inline">\(h\)</span> 上方，这与 <span class="math inline">\(\pi\)</span> 的列是严格递降的矛盾。</p></div><p>反之给定这样的一个不相交路径组 <span class="math inline">\(\mathcal{P}\)</span>，我们也可以还原出对应的 DPP来，于是根据 Gessel-Viennot 引理，以 <span class="math inline">\(\{a_1,\ldots,a_m\}\)</span> 为行首的 DPP 的个数为<span class="math display">\[\det\left(\binom{a_i+a_j-2}{a_j-2}\right)_{1\leq i,j\leq m}.\]</span> 其中矩阵的 <span class="math inline">\((i,j)\)</span>位置的元素为从 <span class="math inline">\(A_i=(0,a_i)\)</span> 到 <span class="math inline">\(B_j=(a_j-2,0)\)</span> 的 Gauss路径的个数，这当然是 <span class="math inline">\(\binom{a_i+a_j-2}{a_j-2}\)</span>。</p><p>对所有的 <span class="math inline">\(2\leq a_1 &lt;\cdots &lt;a_m\leq n\)</span> 求和即为 <span class="math inline">\(\mathrm{dpp}(n)\)</span> 的个数： <span class="math display">\[|\mathrm{dpp}(n)|=\sum_{2\leq a_1&lt;\cdots&lt; a_m\leqn}\det\left(\binom{a_i+a_j-2}{a_j-2}\right)_{1\leq i,j\leq m}.\]</span> 为了把这个表达式化简，我们用 <span class="math inline">\(a_i-1\)</span> 代替每个 <span class="math inline">\(a_i\)</span>，于是 <span class="math display">\[|\mathrm{dpp}(n)|=\sum_{1\leq a_1&lt;\cdots&lt; a_m\leqn-1}\det\left(\binom{a_i+a_j}{a_j-1}\right).\]</span> 现在我们只需要一个线性代数的引理：</p><div id="linalg1" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理4.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是一个 <span class="math inline">\(r\times r\)</span> 矩阵，则 <span class="math inline">\(\det(I_r+A)\)</span> 等于对 <span class="math inline">\(A\)</span> 的所有主子式求和，即 <span class="math display">\[\det(I_r+A)=\sum_{1\leq a_1&lt;\cdots&lt; a_m\leqr}\det A[a_1a_2\cdots a_m].\]</span> 其中 <span class="math inline">\(A[a_1a_2\cdots a_m]\)</span>是下标 <span class="math inline">\(\{a_1,\ldots,a_m\}\)</span> 决定的<span class="math inline">\(A\)</span> 的 <span class="math inline">\(m\)</span> 阶子矩阵。</p></div><p>由此我们得到 <span class="math display">\[|\mathrm{dpp}(n)|=\det\left(\delta_{ij}+\binom{i+j}{j-1}\right)_{1\leqi,j\leq n-1}.\]</span> 至此我们就得到了 <span class="math inline">\(q=1\)</span> 时<span class="math inline">\(\mathrm{dpp}(n)\)</span>的计数序列的行列式形式。</p><p>得到 <span class="math inline">\(q\)</span>-计数的表达式需要多做一点微小的工作：我们不能简单地把上面的行列式直接替换为<span class="math inline">\(q\)</span>- 版本。我们需要说明在Gessel-Viennot引理中，在交换路径操作前后，路径组的权重是保持不变的，否则无法直接使用Gessel-Viennot 引理（Bressoud 的书插图 3.4给出了针对通常平面分拆的一个反例）。</p><p>注意到一个长度为 <span class="math inline">\(l\)</span> 的 Gauss路径可以用一个长度为 <span class="math inline">\(l\)</span> 的 0-1 序列<span class="math inline">\(\sigma\)</span> 来表示，0表示垂直向下的一步，1表示水平向右的一步，路径的权重，即其下方的方格数目等于序列 <span class="math inline">\(\sigma\)</span> 的“逆序数” <span class="math inline">\(\mathrm{inv}(\sigma)\)</span>： <span class="math display">\[\mathrm{inv}(\sigma) = \#\{(i,j)\, |\, i &lt; j, 1=\sigma(i)&gt;\sigma(j)=0\}.\]</span> 这个方格个数与逆序对的对应很容易从下图看出来：</p><figure><img src="/images/dpp/path-weight.svg" width="350" alt="\sigma=1110011000"><figcaption aria-hidden="true"><span class="math inline">\(\sigma=1110011000\)</span></figcaption></figure><p>设 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(Q\)</span> 是两个 Gauss 路径，其对应的 0,1序列分别为 <span class="math inline">\(\sigma_1\)</span> 和 <span class="math inline">\(\sigma_2\)</span>，<span class="math inline">\(P\)</span> 和 <span class="math inline">\(Q\)</span> 有一个公共的交点 <span class="math inline">\(v\)</span>。交换 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(Q\)</span> 在 <span class="math inline">\(v\)</span> 之后的部分，记得到的两个新路径为 <span class="math inline">\(P'\)</span> 和 <span class="math inline">\(Q'\)</span>，它们对应的 0,1 序列分别为 <span class="math inline">\(\sigma_1'\)</span> 和 <span class="math inline">\(\sigma_2'\)</span>，则不难验证有 <span class="math display">\[\begin{align*}|P'|+|Q'|-|P|-|Q|&amp;=\mathrm{inv}(\sigma_1')+\mathrm{inv}(\sigma_2')-\mathrm{inv}(\sigma_1)-\mathrm{inv}(\sigma_2)\\&amp;=(p_0-q_0)(p_1-q_1).\end{align*}\]</span> 这里 <span class="math inline">\(p_0,q_0\)</span> 分别表示<span class="math inline">\(P,Q\)</span> 在交点 <span class="math inline">\(v\)</span> <strong>之后</strong>的部分所含的 0的个数，<span class="math inline">\(p_1,q_1\)</span> 分别表示 <span class="math inline">\(P,Q\)</span> 在交点 <span class="math inline">\(v\)</span> <strong>之前</strong>的部分所含的 1的个数。</p><p>在 DPP 的情形，由于每条路径的出发点都在 <span class="math inline">\(y\)</span> 轴上，终点都在 <span class="math inline">\(x\)</span> 轴上，因此 <span class="math inline">\(P,Q\)</span>在到达它们的交点处各自横向移动的步数相同，从交点到终点各自纵向移动的步数也相同，所以<span class="math inline">\(p_0=q_0\)</span>，<span class="math inline">\(p_1=q_1\)</span>，从而 <span class="math display">\[|P'|+|Q'|=|P|+|Q|.\]</span>因此路径权重之积 <span class="math inline">\(q^{|P|}\cdotq^{|Q|}=q^{|P'|}\cdot q^{|Q'|}\)</span> 保持不变，从而Gessel-Viennot 引理仍然可用。</p><p>现在顶点集合 <span class="math inline">\(\{A_i=(0,a_i)\}\)</span>，<span class="math inline">\(\{B_j=(a_j-2,0)\}\)</span>，而从 <span class="math inline">\(A_i\)</span> 到 <span class="math inline">\(B_j\)</span> 的 Gauss 路径的 <span class="math inline">\(q\)</span>- 计数为 <span class="math inline">\(\binom{a_i+a_j-2}{a_j-2}_q\)</span>，于是行首分别为<span class="math inline">\(\{a_1,\ldots,a_m\}\)</span> 的 DPP 的 <span class="math inline">\(q\)</span>- 计数为 <span class="math display">\[q^{\sum_{i=1}^ma_i}\cdot\det\left(\binom{a_i+a_j-2}{a_j-2}_q\right)_{1\leq i,j\leq m}=\det\left(q^{a_i}\binom{a_i+a_j-2}{a_j-2}_q\right)_{1\leq i,j\leq m}.\]</span> 通过用 <span class="math inline">\(a_i-1\)</span> 代替 <span class="math inline">\(a_i\)</span> 并使用 <a href="#linalg1" title="引理 4.1">引理 4.1</a>，我们得到</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathrm{dpp}(n)\)</span> 的 <span class="math inline">\(q\)</span>- 计数为 <span class="math display">\[\det\left(\delta_{ij}+q^{i+1}\binom{i+j}{j-1}_q\right)_{1\leq i,j\leqn-1}.\]</span></p></div><p>（这里你需要小心 <span class="math inline">\(\mathrm{dpp}(n)\)</span>对应的是一个 <span class="math inline">\(n-1\)</span>阶矩阵，这在记号上确实会带来一些困扰）</p><p>现在剩下的任务就是求这个行列式的值了，而这才是整个故事中最困难的部分，到目前为止我们的路才走了一小半呢。</p><h1 id="用关键参数将行列式分解">用关键参数将行列式分解</h1><p>在上一节中我们已经把 <span class="math inline">\(\mathrm{dpp}(n)\)</span> 的 <span class="math inline">\(q\)</span>- 计数归结为计算行列式 <span class="math inline">\(\det(I_{n-1}+H_{n-1})\)</span>，其中 <span class="math display">\[H_{n-1}=\left(q^{i+1}\binom{i+j}{j-1}_q\right)_{1\leqi,j\leq n-1}.\]</span></p><p>Mills 等人认为，在一个 <span class="math inline">\(\pi\in\mathrm{dpp}(n)\)</span> 中，<span class="math inline">\(n\)</span> 出现的次数是一个重要的参数，根据 <span class="math inline">\(n\)</span> 出现的次数 <span class="math inline">\(k\)</span> 可以把 <span class="math inline">\(\mathrm{dpp}(n)\)</span> 分成 <span class="math inline">\(n\)</span> 个子集 <span class="math inline">\(\{S_k\}_{0\leq k\leqn-1}\)</span>，解决问题的关键在于分别求出每个 <span class="math inline">\(S_k\)</span> 的 <span class="math inline">\(q\)</span>-计数对应的行列式表示，并找到这些行列式满足的递推关系。</p><div id="theorem-Hkn" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(S_k\)</span> 的 <span class="math inline">\(q\)</span>- 计数为 <span class="math inline">\(\det H_{k,n-1}\)</span>，其中 <span class="math inline">\(H_{k,n-1}\)</span> 在 <span class="math inline">\(k=0\)</span> 时是把 <span class="math inline">\(I_{n-1}+H_{n-1}\)</span> 的最后一行用 <span class="math inline">\((0,\ldots,0,1)\)</span> 替换得到的矩阵，而在 <span class="math inline">\(k&gt;0\)</span> 时则是把 <span class="math inline">\(I_{n-1}+H_{n-1}\)</span> 的最后一行用向量 <span class="math display">\[q^{kn}\left(\binom{n+0-k}{1-k}_q,\binom{n+1-k}{2-k}_q,\cdots,\binom{n+n-2-k}{n-1-k}_q\right)\]</span> 替换得到的矩阵。</p></div><p>和之前一样，我们规定当 <span class="math inline">\(m&lt;0\)</span>时有 <span class="math inline">\(\binom{a}{m}_q=0\)</span>。</p><p><strong>证明</strong>：<span class="math inline">\(k=0\)</span>的情形其实就是 <span class="math inline">\(\mathrm{dpp}(n-1)\)</span> 的<span class="math inline">\(q\)</span>- 计数，它等于 <span class="math inline">\(I_{n-2}+H_{n-2}\)</span>，正好是 <span class="math inline">\(I_{n-1}+H_{n-1}\)</span> 的左上角 <span class="math inline">\(n-2\)</span>阶子矩阵，所以这个情形很简单，下面考虑 <span class="math inline">\(k&gt;0\)</span> 的情形。</p><p>我们还是先<strong>从下到上</strong>固定每一行的行首 <span class="math inline">\(\{a_1,\ldots,a_m\}\)</span>，求出行首固定时的生成函数，再对所有可能的行首相加。</p><p>办法和以前一样：现在除了行首 <span class="math inline">\(\{a_1,\ldots,a_m\}\)</span>是已知的，我们知道最上面一行，紧跟在行首的 <span class="math inline">\(n\)</span> 后面还有 <span class="math inline">\(k-1\)</span> 个 <span class="math inline">\(n\)</span>。我们把这些已知的 <span class="math inline">\(\sum_{i=1}^{m-1}a_i+kn\)</span>个箱子移走，将剩下的部分对应到一个不相交的路径组，用 Gessel-Viennot引理得出其生成函数，最后再补上因子 <span class="math inline">\(q^{\sum_{i=1}^{m-1}a_i+kn}\)</span> 即可。</p><p>这个到路径组的对应方法和以前类似，区别是，这里我们要截掉 <span class="math inline">\(\pi\)</span>最上面路径中已知的部分，以之前的插图为例子并取 <span class="math inline">\(n=7\)</span>：</p><p><img src="/images/dpp/dpp-path2.svg" class="fig" width="400"></p><p>这里最上面的路径是从 <span class="math inline">\((0,n)\)</span>出发，向右走 <span class="math inline">\(k-1\)</span> 步到达 <span class="math inline">\((k-1,n)\)</span>，然后向下走到 <span class="math inline">\((k-1,n-1)\)</span>。我们把这部分截去，只保留剩下的部分，这相当于把起点<span class="math inline">\(A_m=(0, n)\)</span> 换成了 <span class="math inline">\((k-1,n-1)\)</span>，其余的起点和终点保持不变。注意由于终点都在<span class="math inline">\(x\)</span> 轴上因此 Gesssel-Viennot引理仍然可用，于是新顶点集 <span class="math inline">\(\{A_i\}\)</span>和 <span class="math inline">\(\{B_j\}\)</span> 之间的不相交的路径组的<span class="math inline">\(q\)</span>- 计数为 <span class="math inline">\(\det X=\det(x_{ij})\)</span>，其中 <span class="math display">\[x_{ij}=\left\{\begin{align*}&amp;\binom{a_i+a_j-2}{a_j-2}_q, \quad &amp; i &lt; m\\&amp;\binom{n+a_j-k-2}{a_j-k-1}_q, \quad &amp; i=m\end{align*}\right.\]</span> 把因子 <span class="math inline">\(q^{\sum_{i=1}^{m-1}a_i+kn}\)</span> 补回去，其中<span class="math inline">\(q^{a_i}\)</span> 补在 <span class="math inline">\(X\)</span> 的第 <span class="math inline">\(i\)</span> 行上，<span class="math inline">\(kn\)</span> 补在 <span class="math inline">\(X\)</span> 的第 <span class="math inline">\(m\)</span> 行，我们就得到行首为 <span class="math inline">\(\{a_1,\ldots,a_m\}\)</span> 且恰好含有 <span class="math inline">\(k\)</span> 个 <span class="math inline">\(n\)</span> 的 DPP 的 <span class="math inline">\(q\)</span>- 计数为 <span class="math inline">\(\det Y=\det(y_{ij})\)</span>，其中 <span class="math display">\[y_{ij}=\left\{\begin{align*}&amp;q^{a_i}\binom{a_i+a_j-2}{a_j-2}_q, \quad &amp; i&lt;m\\&amp;q^{kn}\binom{n+a_j-k-2}{a_j-k-1}_q, \quad &amp; i=m.\end{align*}\right.\]</span> 对每个 <span class="math inline">\(1\leq i\leq m\)</span> 用<span class="math inline">\(a_i-1\)</span> 代替 <span class="math inline">\(a_i\)</span>，可以将 <span class="math inline">\(Y\)</span> 改写为 <span class="math display">\[y_{ij}=\left\{\begin{align*}  &amp;q^{a_i+1}\binom{a_i+a_j}{a_j-1}_q, \quad &amp; i &lt; m\\  &amp;q^{kn}\binom{a_m+a_j-k}{a_j-k}_q, \quad &amp; i=m\end{align*}\right.\]</span> 这时 <span class="math inline">\(1\leq a_1&lt;\cdots&lt;a_{m-1}&lt; a_m=n-1\)</span>，从而 <span class="math inline">\(Y\)</span> 的左上角 <span class="math inline">\(m-1\)</span> 阶矩阵来自 <span class="math inline">\(H_{n-1}\)</span> 的左上角 <span class="math inline">\(n-2\)</span> 阶子矩阵的主子式，<span class="math inline">\(Y\)</span>的最后一行和最后一列分别来自固定的向量，因此要说明对所有 <span class="math inline">\(\det Y\)</span> 求和等于 <span class="math inline">\(\detH_{k,n-1}\)</span>，我们只需要一个与之前稍有不同的线性代数结论：</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是一个 <span class="math inline">\(n-1\)</span> 阶方阵，<span class="math inline">\(D_{n-1}\)</span> 是前 <span class="math inline">\(n-2\)</span> 个对角元为 1，其余元素均为 0 的 <span class="math inline">\(n\)</span> 阶对角矩阵，则 <span class="math display">\[\det(D_{n-1}+A)=\sum_{1\leq a_1&lt;\cdots&lt; a_{m-1}\leq n-2}\detA[a_1\cdots a_{m-1}|n-1],\]</span> 这里求和项跑遍由下标 <span class="math inline">\(\{a_1,\ldots,a_{m-1},n-1\}\)</span> 决定的 <span class="math inline">\(A\)</span> 的 <span class="math inline">\(m\)</span> 阶主子式。</p></div><p>这就完成了 <a href="#theorem-Hkn" title="定理 5.1">定理 5.1</a>的证明。</p><h1 id="mills-robbins-rumsey-的巧妙想法">Mills, Robbins, Rumsey的巧妙想法</h1><p>记 <span class="math inline">\(h_n=\det(I_n+H_n)\)</span> 为 <span class="math inline">\(\mathrm{dpp}(n+1)\)</span> 的 <span class="math inline">\(q\)</span>- 计数，<span class="math inline">\(h_{kn}=\det H_{kn}\)</span> 是其中 <span class="math inline">\(n+1\)</span> 恰好出现 <span class="math inline">\(k(0\leq k\leq n)\)</span> 次的 <span class="math inline">\(q\)</span>- 计数，从上节的讨论我们知道， <span class="math display">\[h_n=\sum_{k=0}^n h_{kn}.\]</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>注意 <span class="math inline">\(H_{kn}\)</span>，<span class="math inline">\(h_{kn}\)</span> 这些记号来自 <span class="math inline">\(n\)</span> 阶矩阵，但它们对应的都是 <span class="math inline">\(\mathrm{dpp}(n+1)\)</span> 中的分拆。</p></div><p><span class="math inline">\(h_{0n}\)</span> 是 <span class="math inline">\(n+1\)</span> 出现 0 次的 <span class="math inline">\(q\)</span>- 计数，因而等于 <span class="math inline">\(\mathrm{dpp}(n)\)</span> 的 <span class="math inline">\(q\)</span>- 计数，即 <span class="math inline">\(h_{0n}=h_{n-1}\)</span>。<span class="math inline">\(\{h_{kn}\}\)</span>构成一个三角阵列，其每一行的和等于下一行的首元素。</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(h_n\)</span></th><th style="text-align: center;"><span class="math inline">\(h_{0n}\)</span></th><th style="text-align: center;"><span class="math inline">\(h_{1n}\)</span></th><th style="text-align: center;"><span class="math inline">\(h_{2n}\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(n=0\)</span></td><td style="text-align: center;"><span class="math inline">\(h_0\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(n=1\)</span></td><td style="text-align: center;"><span class="math inline">\(h_1\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><span class="math inline">\(q^2\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(n=2\)</span></td><td style="text-align: center;"><span class="math inline">\(h_2\)</span></td><td style="text-align: center;"><span class="math inline">\(1+q^2\)</span></td><td style="text-align: center;"><span class="math inline">\(q^3+q^4+q^5\)</span></td><td style="text-align: center;"><span class="math inline">\(q^6+q^8\)</span></td></tr></tbody></table><p>由此我们可以得到 <span class="math inline">\(\mathrm{dpp}(n+1)\)</span> 与 <span class="math inline">\(\mathrm{dpp}(n)\)</span> 的 <span class="math inline">\(q\)</span>- 计数之间的递推关系： <span class="math display">\[\frac{h_n}{h_{n-1}} = 1 +\sum_{k=1}^n\frac{h_{kn}}{h_{0n}}.\]</span></p><p>另一方面，<a href="#Andrews-conjecture" title="Andrews 猜想">Andrews猜想</a> 给出的递推关系是 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> <span class="math display">\[\prod_{1\leq i\leq j\leqn+1}\frac{1-q^{n+i+j}}{1-q^{2i+j-1}}\,\bigg/ \prod_{1\leq i\leq j\leqn}\frac{1-q^{n+i+j-1}}{1-q^{2i+j-1}} =\prod_{i=1}^n\frac{1-q^{2n+i+1}}{1-q^{n+i}}=\frac{\binom{3n+1}{n}_q}{\binom{2n}{n}_q}.\]</span>并且在 <a href="#Andrews-conjecture" title="Andrews 猜想">Andrews猜想</a> 中分别取 <span class="math inline">\(n=0\)</span> 和 <span class="math inline">\(n=1\)</span> 可得 <span class="math display">\[\left.\prod_{1\leq i\leq j\leqn+1}\frac{1-q^{n+i+j}}{1-q^{2i+j-1}}\right|_{n=0}=1=h_0,\quad\left.\prod_{1\leq i\leq j\leqn+1}\frac{1-q^{n+i+j}}{1-q^{2i+j-1}}\right|_{n=1}=1+q^2=h_1.\]</span>所以我们只要证明 <span class="math display">\[1 +\sum_{k=1}^n\frac{h_{kn}}{h_{0n}}=\frac{\binom{3n+1}{n}_q}{\binom{2n}{n}_q}.\]</span>即可验证 Andrews 猜想成立。</p><p>我们已经设定好了目标，现在我们从一段“平平无奇”的线性代数操作开始，逐步触及证明的核心。</p><p>由于 <span class="math inline">\(I_n+H_n\)</span> 和所有的 <span class="math inline">\(\{H_{kn}\}_{0\leq k\leq n}\)</span> 的前 <span class="math inline">\(n-1\)</span>行都相同，仅最后一行不同，所以它们最后一行有共同的代数余子式。设 <span class="math inline">\(R_k\)</span> 是 <span class="math inline">\(H_{kn}\)</span> 的最后一行，列向量 <span class="math inline">\(C=(c_1,\ldots,c_n)^{T}\)</span> 是 <span class="math inline">\(R_k\)</span> 对应的代数余子式，<span class="math inline">\(C\)</span> 对所有 <span class="math inline">\(0\leq k\leq n\)</span> 都是一样的。则 <span class="math display">\[R_k\cdot C=\det H_{kn}=h_{kn}.\]</span> 将 <span class="math inline">\(R_1,\ldots,R_n\)</span> 以行向量依次排成 <span class="math inline">\(n\times n\)</span> 矩阵，记作 <span class="math inline">\(R\)</span>，则 <span class="math display">\[RC = \begin{pmatrix}h_{1n}\\h_{2n}\\\vdots\\h_{nn}\end{pmatrix}.\]</span> <strong>不难看出 <span class="math inline">\(R\)</span>是一个对角线上都是 1 的上三角矩阵</strong> （在 <a href="#theorem-Hkn" title="定理 5.1">定理 5.1</a> 中对 <span class="math inline">\(n+1\)</span> 的情形依次令 <span class="math inline">\(k=1,\ldots,n\)</span>），所以 <span class="math inline">\(R\)</span> 可逆，从而 <span class="math display">\[C = R^{-1}\begin{pmatrix}h_{1n}\\h_{2n}\\\vdots\\h_{nn}\end{pmatrix}.\]</span> 由于矩阵 <span class="math inline">\(H_{0n}\)</span>满足最后一行 <span class="math inline">\(R_0\cdot C=\detH_{0n}=h_{0n}\)</span>，并且其它行与 <span class="math inline">\(C\)</span> 的内积是 0，所以 <span class="math display">\[H_{0n}C=\begin{pmatrix}0\\0\\\vdots\\h_{0n}\end{pmatrix}=h_{0n}\begin{pmatrix}0\\0\\\vdots\\1\end{pmatrix}.\]</span> 于是 <span class="math display">\[RH_{0n}R^{-1}\begin{pmatrix}h_{1n}\\h_{2n}\\\vdots\\h_{nn}\end{pmatrix}=RH_{0n}C=h_{0n}R\begin{pmatrix}0\\0\\\vdots\\1\end{pmatrix}.\]</span> 记 <span class="math inline">\(A_n=RH_{0n}R^{-1}\)</span>，并记 <span class="math display">\[V_n=R\begin{pmatrix}0\\0\\\vdots\\1\end{pmatrix},\]</span> 则我们有 <span class="math display">\[\begin{equation}A_n\begin{pmatrix}h_{1n}\\h_{2n}\\\vdots\\h_{nn}\end{pmatrix}=h_{0n}V_n.\end{equation}\label{eq:hn}\tag{1}\]</span> 观察上式，看起来 <span class="math inline">\(h_{0n}\)</span>孤零零地在右边，这不美观啊？可不可以把它和 <span class="math inline">\(h_{1n},\ldots,h_{nn}\)</span> 放在一起呢？这就是Mills 等人的精彩操作了：考虑 <span class="math display">\[K_n=\begin{pmatrix}\ast&amp;\ast\\V_n&amp;I_n-A_n\end{pmatrix}.\]</span> <span class="math inline">\(K_n\)</span> 是一个 <span class="math inline">\(n+1\)</span> 阶的矩阵，<span class="math inline">\(\ast\)</span> 位置是 <span class="math inline">\(K_n\)</span> 的第一行，暂时不确定是什么，但是不管<span class="math inline">\(\ast\)</span> 是什么，<span class="math inline">\(K_n\)</span> 都满足 <span class="math display">\[K_n\begin{pmatrix}h_{0n}\\h_{1n}\\\vdots\\h_{nn}\end{pmatrix}=  \begin{pmatrix}\ast\\h_{1n}\\\vdots\\h_{nn}\end{pmatrix}.\]</span>上面右边向量的第一个分量我们不知道，但它<strong>应该</strong>是什么是显而易见的，肯定是<span class="math inline">\(h_{0n}\)</span> 啊！这不就是一个特征值是 1的特征向量嘛？所以我们下面的任务肯定是构造合适的 <span class="math inline">\(K_n\)</span>，使得 <span class="math display">\[K_n\begin{pmatrix}h_{0n}\\h_{1n}\\\vdots\\h_{nn}\end{pmatrix}=  \begin{pmatrix}h_{0n}\\h_{1n}\\\vdots\\h_{nn}\end{pmatrix}.\]</span> 成立，然后求解它特征值为 1 的特征向量啊！</p><p>Mills 等人算出了 <span class="math inline">\(I_n-A_n\)</span> 和<span class="math inline">\(V_n\)</span>： <span class="math display">\[\begin{align*}I_n-A_n&amp;=\left((-1)^{j}q^{(i-j)(n+1)+ij}q^{\binom{j+1}{2}}\binom{2n-i}{n-i-j}_q\right)_{1\leqi,j\leq n},\\V_n&amp;=\left(q^{k(n+1)}\binom{2n-k}{n-k}_q\right)^T_{1\leq k\leq n}.\end{align*}\]</span> 把 <span class="math inline">\(V_n\)</span> 和 <span class="math inline">\(I_n-A_n\)</span> 分别填入 <span class="math inline">\(K_n\)</span> 的左下角和右下角，能帮助我们推断<span class="math inline">\(K_n\)</span> 的第一行吗？注意到如果在 <span class="math inline">\(I_n-A_n\)</span> 的表达式中令下标 <span class="math inline">\(j=0\)</span>，则得到的列向量正是 <span class="math inline">\(V_n\)</span>，那 <span class="math inline">\(K_n\)</span> 是什么已经呼之欲出了：它应该是把<span class="math inline">\(I_n-A_n\)</span> 中的 <span class="math inline">\(i,j\)</span> 下标各自扩展到 0 后得到的 <span class="math inline">\(n+1\)</span> 阶方阵！即 <span class="math display">\[K_n=\left((-1)^{j}q^{(i-j)(n+1)+ij}q^{\binom{j+1}{2}}\binom{2n-i}{n-i-j}_q\right)_{0\leqi,j\leq n}.\]</span></p><p><strong>这一步即为 Mills 等人的“信仰一跃”</strong>。</p><p>然而看到 <span class="math inline">\(K_n\)</span>的表达式还是不免让人倒吸一口凉气，这么复杂的矩阵，Mills等人是怎么得出它的特征值 1 对应的特征向量来的呢？</p><p>我们之前说过，Mills 等人研究 DPP 的目的是为了解决 ASM的计数。他们正确的猜出了 <span class="math inline">\({\rmASM}(n)\)</span> 中第一行的 1 恰好出现在第 <span class="math inline">\(1\leq k\leq n\)</span> 列的 ASM 个数为 <span class="math display">\[|A_{n,k}|=\binom{n+k-2}{k-1}\frac{(2n-k-1)!}{(n-k)!}\prod_{j=0}^{n-2}\frac{(3j+1)!}{(n+j)!}.\]</span> 而且他们直觉认为这就是 <span class="math inline">\(\mathrm{dpp}(n)\)</span> 中恰好含有 <span class="math inline">\(k-1\)</span> 个 <span class="math inline">\(n\)</span> 的 DPP 的个数，即 <span class="math inline">\(h_{k-1,n-1}\)</span>。把下标换成 <span class="math inline">\(k+1\)</span> 和 <span class="math inline">\(n+1\)</span>，即他们猜测 <span class="math display">\[|A_{n+1,k+1}|=h_{kn}=\binom{n+k}{k}\frac{(2n-k)!}{(n-k)!}\prod_{j=0}^{n-1}\frac{(3j+1)!}{(n+j+1)!}.\]</span></p><p>所以他们猜测特征向量 <span class="math inline">\(v_n\)</span> 的第<span class="math inline">\(k\)</span> 个分量 <span class="math inline">\(v_{kn}\)</span> 应该形如 <span class="math display">\[q^{\text{some power}}\times\binom{n+k}{k}_q\binom{2n-k}{n-k}_q.\]</span> 经过试验以后他们发现取 <span class="math display">\[v_{kn}=q^{k(n+1)}\binom{n+k}{k}_q\binom{2n-k}{n-k}_q\]</span> 即可。<strong>这一步即为 Mills 等人的“灵魂一猜”</strong>。</p><p>记 <span class="math inline">\(v_n=\sum_{k=0}^{n}v_{kn}\)</span>。经过计算可以得到 <span class="math display">\[v_{0n}=\binom{2n}{n}_q,\quad\sum_{k=0}^nv_{kn}=\binom{3n+1}{n}_q.\]</span> 我们断言向量 <span class="math inline">\((v_{0n},\ldots,v_{nn})\)</span> 和 <span class="math inline">\((h_{0n},\ldots,h_{nn})\)</span>必然是共线的。这是因为，如果适当缩放前者使得 <span class="math inline">\(v_{0n}=h_{0n}\)</span> 的话，那么 <span class="math inline">\((v_{1n},\ldots,v_{nn})\)</span> 也是 <span class="math inline">\((\ref{eq:hn})\)</span> 中关于 <span class="math inline">\(\{h_{kn}\}_{k\geq1}\)</span>的线性方程组的解，而由于 <span class="math inline">\(A_n\)</span>可逆，该方程组的解唯一，所以对 <span class="math inline">\(k\geq1\)</span> 同样有 <span class="math inline">\(v_{kn}=h_{kn}\)</span>。于是 <span class="math display">\[1+\sum_{k=1}^n\frac{h_{kn}}{h_{0n}}=\frac{\sum_{k=0}^nv_{kn}}{v_{0n}}=\frac{\binom{3n+1}{n}_q}{\binom{2n}{n}_q}.\]</span></p><p>这就完成了 Andrews 猜想的证明。</p><h1 id="详细计算步骤">详细计算步骤</h1><p>下面进入“小心求证”的部分，这里主要的工具是前面的 Gauss 二项式 <a href="#binom-thm1" title="定理 3.1">定理 3.1</a> 和 <a href="#binom-thm2" title="定理 3.2">定理 3.2</a>。我们要计算 <span class="math inline">\(I_n-A_n=I_n-RH_{0n}R^{-1}\)</span>，为此需要先计算<span class="math inline">\(R^{-1}\)</span>。</p><h2 id="计算-r-1">计算 <span class="math inline">\(R^{-1}\)</span></h2><p>从 <a href="#theorem-Hkn" title="定理 5.1">定理 5.1</a> 可知 <span class="math display">\[R=\left(q^{i(n+1)}\binom{n+j-i}{j-i}_q\right)_{1\leq i,j\leq n}.\]</span> 利用 <span class="math inline">\(\prod_{k=0}^n(1-xq^k)\cdot\prod_{k=0}^n\dfrac{1}{(1-xq^k)}=1\)</span>得到 <span class="math display">\[\left(\sum_{k=0}^{n+1}(-1)^kq^{\binom{k}{2}}\binom{n+1}{k}_qx^k\right)\left(\sum_{l=0}^\infty\binom{n+l}{l}_qx^l\right)=1.\]</span> 对 <span class="math inline">\(1\leq i,j\leqn\)</span>，比较两边 <span class="math inline">\(x^{j-i}\)</span>项的系数，右边显然是 <span class="math inline">\(\delta_{ij}\)</span>，左边取第一个因子的 <span class="math inline">\(x^{k-i}\)</span> 项系数，取第二个因子的 <span class="math inline">\(x^{j-k}\)</span> 项系数并对 <span class="math inline">\(k\)</span> 求和，有 <span class="math display">\[\sum_{i\leq k\leq j}(-1)^{k-i}q^{\binom{k-i}{2}}\binom{n+1}{k-i}_q\binom{n+j-k}{j-k}_q =\delta_{ij}.\]</span> 采用我们之前的约定 <span class="math inline">\(\binom{a}{-m}_q=0\)</span>，上式可以写成 <span class="math display">\[\sum_{1\leq k\leq n}(-1)^{k-i}q^{\binom{k-i}{2}}\binom{n+1}{k-i}_q\binom{n+j-k}{j-k}_q=\delta_{ij}.\]</span> 这说明 <span class="math inline">\(\left((-1)^{j-i}q^{\binom{j-i}{2}}\binom{n+1}{j-i}_q\right)_{1\leqi,j\leq n}\)</span> 和 <span class="math inline">\(\left(\binom{n+j-i}{j-i}_q\right)_{1\leq i,j\leqn}\)</span> 互为逆矩阵。而后者与 <span class="math inline">\(R\)</span>的第 <span class="math inline">\(i\)</span> 行相差 <span class="math inline">\(q^{i(n+1)}\)</span> 的因子，所以给前者的第 <span class="math inline">\(j\)</span> 列补上 <span class="math inline">\(q^{-j(n+1)}\)</span> 的因子便可得到 <span class="math display">\[R^{-1}=\left((-1)^{j-i}q^{\binom{j-i}{2}}q^{-j(n+1)}\binom{n+1}{j-i}_q\right)_{1\leqi,j\leq n}.\]</span></p><h2 id="计算-rh_0nr-1">计算 <span class="math inline">\(RH_{0n}R^{-1}\)</span></h2><p>记 <span class="math inline">\(H_n^\ast\)</span> 是与 <span class="math inline">\(H_n\)</span> 的前 <span class="math inline">\(n-1\)</span> 行全相同，但是最后一行全是 0的矩阵，则 <span class="math inline">\(H_{0n}=I_n+H_n^\ast\)</span>，于是 <span class="math inline">\(RH_{0n}R^{-1}=I_n+RH_n^\astR^{-1}\)</span>，所以只要计算 <span class="math inline">\(RH_n^\astR^{-1}\)</span> 即可。</p><p>首先由于 <span class="math inline">\(H_n^\ast\)</span> 的最后一行是0，所以 <span class="math inline">\(H_n^\ast R^{-1}\)</span>的最后一行也是 0，其它行的 <span class="math inline">\((i,j)\)</span>分量为当 <span class="math inline">\(i&lt;n\)</span> 时为 <span class="math display">\[\sum_{k=1}^n(H_n^*)_{ik}(R^{-1})_{kj}=q^{i+1-j(n+1)}\sum_{k=1}^n(-1)^{j-k}q^{\binom{j-k}{2}}\binom{i+k}{k-1}_q\binom{n+1}{j-k}_q.\]</span> 用 Gauss 二项式定理展开 <span class="math display">\[\prod_{l=0}^n(1-xq^l)\cdot\prod_{l=0}^{i+1}\frac{1}{1-xq^l}=\prod_{l=i+2}^n(1-xq^l)\]</span>左边第一个因子的 <span class="math inline">\(x^{j-k}\)</span> 项系数为<span class="math inline">\((-1)^{j-k}q^{\binom{j-k}{2}}\binom{n+1}{j-k}_q\)</span>，第二个因子中<span class="math inline">\(x^{k-1}\)</span> 项系数为 <span class="math inline">\(\binom{i+k}{k-1}_q\)</span>，相乘并对 <span class="math inline">\(k\)</span> 求和后是右边 <span class="math inline">\(x^{j-1}\)</span> 项系数，利用代换 <span class="math inline">\(z=xq^{i+2}\)</span> 不难得出此系数为 <span class="math display">\[(-1)^{j-1}q^{(i+2)(j-1)}q^{\binom{j-1}{2}}\binom{n-i-1}{j-1}_q.\]</span> 于是 <span class="math display">\[\begin{align*}\sum_{k=1}^n(H_n^*)_{ik}(R^{-1})_{kj}&amp;=q^{i+1-j(n+1)}q^{(i+2)(j-1)}(-1)^{j-1}q^{\binom{j-1}{2}}\binom{n-i-1}{j-1}_q\\&amp;=q^{ij-jn}(-1)^{j-1}q^{\binom{j}{2}}\binom{n-i-1}{j-1}_q.\end{align*}\]</span> 即 <span class="math display">\[H_n^*R^{-1}=\left(  q^{ij-jn}(-1)^{j-1}q^{\binom{j}{2}}\binom{n-i-1}{j-1}_q  \right)_{1\leq i,j\leq n}.\]</span> 如果约定 <span class="math inline">\(\binom{-a}{m}_q=0\)</span> 的话我们可以把 <span class="math inline">\(H_n^*R^{-1}\)</span> 最后一行都是 0也统一到上面的表达式中。</p><p>继续 <span class="math display">\[\sum_{k=1}^n(R)_{ik}(H_n^*R^{-1})_{kj}=\sum_{k=1}^nq^{i(n+1)}\binom{n+k-i}{k-i}_qq^{kj-jn}(-1)^{j-1}q^{\binom{j}{2}}\binom{n-k-1}{j-1}_q.\]</span>把右边与 <span class="math inline">\(k\)</span>无关的项提出来，得到其等于 <span class="math display">\[(-1)^{j-1}q^{(i-j)(n+1)+ij}q^{\binom{j+1}{2}}\sum_{k=1}^nq^{(k-i)j}\binom{n+k-i}{k-i}_q\binom{n-k-1}{j-1}_q.\]</span> 把 <span class="math inline">\(\binom{n-k-1}{j-1}_q\)</span>改写为 <span class="math inline">\(\binom{j-1+(n-k-j)}{n-k-j}_q\)</span>，可以将其进一步化为<span class="math display">\[(-1)^{j-1}q^{(i-j)(n+1)+ij}q^{\binom{j+1}{2}}\sum_{k=1}^n q^{(k-i)j}\binom{n+k-i}{k-i}_q\binom{j-1+(n-k-j)}{n-k-j}_q.\]</span> 注意 <span class="math inline">\(\binom{j-1+(n-k-j)}{n-k-j}_q\)</span> 是 <span class="math inline">\(\prod\limits_{l=0}^{j-1}\frac{1}{1-xq^l}\)</span>中 <span class="math inline">\(x^{n-k-j}\)</span> 项的系数，<span class="math inline">\(q^{(k-i)j}\binom{n+k-i}{k-i}_q\)</span> 是 <span class="math inline">\(\prod\limits_{l=j}^{n+j}\frac{1}{1-xq^l}\)</span>中 <span class="math inline">\(x^{k-i}\)</span> 项的系数，二者相乘并对<span class="math inline">\(k\)</span> 求和得到的是 <span class="math inline">\(\prod\limits_{l=0}^{n+j}\frac{1}{1-xq^l}\)</span>中 <span class="math inline">\(x^{n-i-j}\)</span> 项的系数，即 <span class="math inline">\(\binom{2n-i}{n-i-j}_q\)</span>，于是 <span class="math display">\[RH_n^*R^{-1}=\left(  (-1)^{j-1}q^{(i-j)(n+1)+ij}q^{\binom{j+1}{2}}\binom{2n-i}{n-i-j}_q  \right)_{1\leq i,j\leq n}.\]</span> 从而 <span class="math display">\[I_n-A_n=-RH_n^*R^{-1}=\left(  (-1)^{j}q^{(i-j)(n+1)+ij}q^{\binom{j+1}{2}}\binom{2n-i}{n-i-j}_q  \right)_{1\leq i,j\leq n}.\]</span></p><h2 id="得到-v_n">得到 <span class="math inline">\(V_n\)</span></h2><p>列向量 <span class="math inline">\(V_n\)</span> 比较好求，它就是<span class="math inline">\(R\)</span> 的最后一列，也就是分别取出 <span class="math inline">\(H_{1n},\ldots,H_{nn}\)</span>最右下角元素后排成的列向量，即 <span class="math display">\[V_n=\left(q^{k(n+1)}\binom{2n-k}{n-k}_q\right)^T_{1\leq k\leq n}.\]</span></p><h2 id="验证-v_n-是-k_n-的特征向量">验证 <span class="math inline">\(v_n\)</span> 是 <span class="math inline">\(K_n\)</span> 的特征向量</h2><p>我们来验证 <span class="math inline">\(\left(q^{k(n+1)}\binom{n+k}{k}_q\binom{2n-k}{n-k}_q\right)_{0\leqk\leq n}\)</span> 是 <span class="math inline">\(K_n\)</span>的特征向量。 <span class="math display">\[\sum_{k=0}^n(K_n)_{ik}v_{kn}=\sum_{k=0}^n(-1)^{k}q^{i(n+1)+ik}q^{\binom{k+1}{2}}\binom{2n-i}{n-i-k}_q\binom{n+k}{k}_q\binom{2n-k}{n-k}_q.\]</span> 利用 Gauss 二项式的定义不难验证 <span class="math display">\[\binom{2n-i}{n-i-k}_q\binom{n+k}{k}_q=\binom{2n-i}{n-i}_q\binom{n-i}{k}_q.\]</span> 所以 <span class="math display">\[\sum_{k=0}^n(K_n)_{ik}v_{kn}=q^{i(n+1)}\binom{2n-i}{n-i}_q\sum_{k=0}^n(-1)^{k}q^{ik}q^{\binom{k+1}{2}}\binom{n-i}{k}_q\binom{2n-k}{n-k}_q.\]</span> 所以要证明 <span class="math inline">\(\sum_{k=0}^n(K_n)_{ik}v_{kn}=v_{in}\)</span>，只要再证明<span class="math display">\[\sum_{k=0}^n(-1)^{k}q^{ik}q^{\binom{k+1}{2}}\binom{n-i}{k}_q\binom{2n-k}{n-k}_q=\binom{n+i}{i}_q.\]</span> 实际上右边是 <span class="math inline">\(\prod\limits_{l=0}^i\dfrac{1}{1-xq^l}\)</span> 中<span class="math inline">\(x^n\)</span> 项的系数，而 <span class="math display">\[\prod\limits_{l=0}^i\dfrac{1}{1-xq^l} =\left(\prod\limits_{l=i+1}^n(1-xq^l)\right) \left(\prod\limits_{l=0}^n\dfrac{1}{1-xq^l}\right).\]</span> 取第一个因子的 <span class="math inline">\(x^k\)</span>项系数，第二个因子的 <span class="math inline">\(x^{n-k}\)</span>项系数相乘并对 <span class="math inline">\(k\)</span>求和即为所求等式。</p><h2 id="验证-sumlimits_k0nv_knbinom3n1n_q">验证 <span class="math inline">\(\sum\limits_{k=0}^nv_{kn}=\binom{3n+1}{n}_q\)</span></h2><p>最后我们来验证 <span class="math display">\[\sum\limits_{k=0}^nv_{kn}=\sum\limits_{k=0}^nq^{k(n+1)}\binom{n+k}{k}_q\binom{2n-k}{n-k}_q=\binom{3n+1}{n}_q.\]</span> 只要比较 <span class="math display">\[\left(\prod_{l=0}^n\frac{1}{1-xq^l}\right)\left(\prod_{l=n+1}^{2n+1}\frac{1}{1-xq^l}\right)=\left(\prod_{l=0}^{2n+1}\frac{1}{1-xq^l}\right)\]</span> 两边 <span class="math inline">\(x^n\)</span>的系数，取第一个因子的 <span class="math inline">\(x^k\)</span>项系数，第二个因子的 <span class="math inline">\(x^{n-k}\)</span>系数并对 <span class="math inline">\(k\)</span> 求和即得。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-thebook" class="csl-entry" role="listitem">Aigner, Martin, and Gnter M. Ziegler. 2018. <em>Proofs from THEBOOK</em>. 6th ed. Springer Publishing Company, Incorporated.</div><div id="ref-Bressoud1999" class="csl-entry" role="listitem">Bressoud, David M. 1999. <em>Proofs and Confirmations: The Story of theAlternating-Sign Matrix Conjecture</em>. Spectrum. Cambridge UniversityPress.</div><div id="ref-Mills1983" class="csl-entry" role="listitem">Mills, W. H, David P Robbins, and Howard Rumsey. 1983.<span>“Alternating Sign Matrices and Descending PlanePartitions.”</span> <em>Journal of Combinatorial Theory, Series A</em>34 (3): 340–59.</div></div><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>我们来验证这个递推关系。记 <span class="math display">\[\prod_{1\leq i\leq j\leq n+1}\frac{1-q^{n+i+j}}{1-q^{2i+j-1}} =\frac{x_{n+1}}{y_{n+1}},\]</span> 对分母，分离 <span class="math inline">\(j=n+1\)</span>的部分有 <span class="math display">\[y_{n+1}=y_n\cdot\prod\limits_{i=1}^{n+1}(1-q^{2i+n}).\]</span> 对分子，分离 <span class="math inline">\(j=n+1\)</span> 的部分有 <span class="math display">\[\begin{aligned}x_{n+1}&amp;=\prod_{i=1}^n\prod_{j=i}^n(1-q^{n+i+j})\cdot\prod_{i=1}^{n+1}(1-q^{2n+i+1})\\&amp;=\prod_{i=1}^{n-1}\prod_{j=i}^n(1-q^{n+i+j})\cdot (1-q^{3n}) \cdot\prod_{i=1}^{n+1}(1-q^{2n+i+1})\\&amp;=\prod_{i=2}^n\prod_{j=i-1}^n(1-q^{n+i+j-1})\cdot (1-q^{3n}) \cdot\prod_{i=1}^{n+1}(1-q^{2n+i+1})\\&amp;=\prod_{i=2}^n\prod_{j=i}^n(1-q^{n+i+j-1})\cdot\prod_{i=2}^n(1-q^{n+2i-2})\cdot (1-q^{3n})\cdot\prod_{i=1}^{n+1}(1-q^{2n+i+1})\\&amp;=\prod_{i=2}^n\prod_{j=i}^n(1-q^{n+i+j-1})\cdot\prod_{i=1}^{n}(1-q^{n+2i})\cdot \prod_{i=1}^{n+1}(1-q^{2n+i+1})\\&amp;=x_n\cdot\prod_{i=1}^{n}(1-q^{n+2i})\cdot\prod_{i=1}^{n+1}(1-q^{2n+i+1})\,\bigg/\prod_{j=1}^n(1-q^{n+j}).\end{aligned}\]</span><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 计数组合学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Wilson 均匀生成树算法</title>
      <link href="/wilson-algorithm/"/>
      <url>/wilson-algorithm/</url>
      
        <content type="html"><![CDATA[<div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>给定一个有限、无向的连通图 <span class="math inline">\(G= ( V,E )\)</span>，设 <span class="math inline">\(\mathcal{T}\)</span> 是 <span class="math inline">\(G\)</span> 的所有生成树组成的集合，怎样在 <span class="math inline">\(\mathcal{T}\)</span>中按照均匀分布进行采样？即设计一个算法，能够随机地给出 <span class="math inline">\(G\)</span> 的一个生成树，并且 <span class="math inline">\(\mathcal{T}\)</span>中每个生成树被取到的概率是相等的。</p></div><p>常见的生成树算法如 DFS/BFS 算法、Prim 算法、Kruskal算法等给出的生成树都不是完全随机的。例如，取 <span class="math inline">\(G\)</span> 为 <span class="math inline">\(\mathbb{Z}^2\)</span> 中 <span class="math inline">\(m\times n\)</span> 的网格图，<span class="math inline">\(G\)</span>的任何生成树都是一个迷宫，把背景平面涂黑，把生成树的边涂白，就可以清楚地看到迷宫的结构。迷宫的任何两个房间( 即树的顶点 )可以通过生成树中唯一的路径相连，这样的迷宫叫做完美迷宫。</p><p>DFS 算法 ( 每次将新顶点的顺序打乱再入栈 )倾向于尽可能深地探索整个图，因此得到的迷宫往往包含长且蜿蜒的路径，死角 (即叶节点 ) 是很少的：</p><figure><img src="/images/gifmaze/random_dfs.gif" class="fig" width="500" alt="DFS 算法动画"><figcaption aria-hidden="true">DFS 算法动画</figcaption></figure><span id="more"></span><p>与之相反，Prim算法由于每次是在当前树上随机添加一个叶节点，因此得到的迷宫往往包含很多死角，几乎没有笔直且长的路径：</p><figure><img src="/images/gifmaze/prim.gif" class="fig" width="500" alt="Prim 算法动画"><figcaption aria-hidden="true">Prim 算法动画</figcaption></figure><p>总之从直观上就可以看出这两个算法得到的生成树都不是完全随机的。</p><p>目前最快的生成均匀生成树的算法是 Wilson算法，这个算法描述起来很简单，但神奇的是，从描述里面你看不到任何关于均匀性的信息，但是它确实可以生成均匀的生成树！</p><div id="wilson-algo" class="statement sta_wilson___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Wilson算法</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(G\)</span> 是一个有限简单连通图。</p><ol type="1"><li>任取一个顶点 <span class="math inline">\(r\)</span>，维护一个树<span class="math inline">\(T\)</span>，初始时 <span class="math inline">\(T=\{r\}\)</span>。</li><li>任取一个不属于 <span class="math inline">\(T\)</span> 的顶点 <span class="math inline">\(v\)</span>，从 <span class="math inline">\(v\)</span>出发作图上的随机游动，一边走一边随时擦掉路径中出现的圈 ( 此谓之 looperased random walk ) ，即每当走到一个以前访问过的顶点 <span class="math inline">\(x\)</span>，则两次访问 <span class="math inline">\(x\)</span>之间的路径都被擦掉。按此规则持续行走直到与 <span class="math inline">\(T\)</span> 相遇为止，这时得到一条从 <span class="math inline">\(v\)</span> 到 <span class="math inline">\(T\)</span> 的不含圈的路径 <span class="math inline">\(p\)</span>，把 <span class="math inline">\(p\)</span> 加入到 <span class="math inline">\(T\)</span> 中，将 <span class="math inline">\(T\)</span> 更新为 <span class="math inline">\(T=T\cup p\)</span>。</li><li>重复步骤 2 直到 <span class="math inline">\(T\)</span> 包含 <span class="math inline">\(G\)</span> 的所有顶点，这时 <span class="math inline">\(T\)</span> 是一个服从均匀分布的生成树。</li></ol></div><p>下面是 Wilson 算法的 Javascript演示，你可以随时单击鼠标来重启动画。</p><script type="text/javascript" src="/code/wilson.js"></script><canvas id="wilson" width="600" height="600"></canvas><div id="two-arbitrary"><p>注意 Wilson 算法的描述中有两个<strong>任意</strong>：</p><ol type="1"><li>初始时可以任选一个初始根节点 <span class="math inline">\(r\)</span>。</li><li>每次可以任选一个不属于 <span class="math inline">\(T\)</span>的顶点出发作随机游动。</li></ol></div><p>Wilson 的 <a href="https://dl.acm.org/doi/10.1145/237814.237880">论文</a>中给出的证明相当有技巧性，而且有一些晦涩的部分，我是花了很久才真正理解。本文就来介绍这个证明。</p><h1 id="证明思路">证明思路</h1><p>先不管均匀分布的事情，我们来说明 Wilson 算法以概率 1会在有限时间内结束。</p><div id="algo-success" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题1.1</span>.</span><span class="statement-spah"> </span>Wilson 算法以概率1 在有限时间内返回一个生成树。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(G\)</span>有限且连通，所以其上的随机游动是常返的，在算法第 2步中，每次从一个新顶点 <span class="math inline">\(v\)</span>出发的随机游动以概率 1 在有限时间内撞到 <span class="math inline">\(T\)</span>。这样的循环只能执行有限多次 ( 次数以<span class="math inline">\(|V|\)</span> 为上界 ) ，所以算法以概率 1在有限时间内结束。<span class="math inline">\(\blacksquare\)</span></p><p>所以真正有挑战性的地方在于论证得到的生成树服从均匀分布。</p><p>证明的大致想法是这样的：我们构造概率空间 <span class="math inline">\(( \Omega,\mathbb{P} )\)</span> 和映射 <span class="math inline">\(\phi:\Omega\to\mathcal{T}\)</span>，使得它们满足如下的条件：</p><div id="requirements" class="statement simple plain unnumbered"><ol type="1"><li><span class="math inline">\(\phi\)</span> 对几乎处处的 <span class="math inline">\(\omega\in\Omega\)</span> 有定义 ( 不是所有的 <span class="math inline">\(\omega\)</span>都对应一个生成树，但这种例外发生的概率是 0 ) 。</li><li><span class="math inline">\(\phi\)</span> 是满射。 ( 不能漏掉任何树)</li><li>对任何树 <span class="math inline">\(T\in\mathcal{T}\)</span>，其在<span class="math inline">\(\Omega\)</span> 中的原像 <span class="math inline">\(\phi^{-1} ( T )\)</span> 的测度是一个与 <span class="math inline">\(T\)</span> 无关的常数。</li></ol></div><p>一旦找到了这样的概率空间 <span class="math inline">\((\Omega,\mathbb{P} )\)</span> 和映射 <span class="math inline">\(\phi\)</span>，则 <span class="math inline">\(\phi( \omega )\)</span> 以概率 1 是一个生成树，且服从 <span class="math inline">\(\mathcal{T}\)</span> 上的均匀分布。</p><p>构造 <span class="math inline">\(( \Omega,\mathbb{P} )\)</span> 和<span class="math inline">\(\phi\)</span> 的关键，是把 <span class="math inline">\(( \Omega,\mathbb{P} )\)</span>看作一个游戏的系统随机性，Wilson算法看作玩家的一种操作策略，但是这个策略对结果没有影响，即实际上任何游戏策略都会得到相同的结果，从而游戏结果完全由系统随机性<span class="math inline">\(\omega\in\Omega\)</span> 决定，这就是映射<span class="math inline">\(\phi\)</span>！</p><p>系统随机性在许多游戏中是一个常见的概念：玩家的出生地，道具的出现，各种boss的行为都是由系统随机性决定的。系统随机性和玩家的操作合起来决定了游戏的结果（当然我们忽略了玩家的硬件差异等其它因素）。</p><p>作为例子，我们来看看大家都熟悉的 Tetris游戏（俄罗斯方块）。我喜欢这个例子是因为它也涉及“消去”的操作。</p><p>经典的 Tetris 游戏是这样的，系统每次会随机从屏幕顶端落下 <span class="math inline">\(\{I,L,J,O,S,T,Z\}\)</span> 七种四方块 ( tetromino)中的一个。玩家可以在方块下落的过程中移动或者旋转它，尽可能地形成完整的水平行。每当出现完整的水平行时，这些行会被立刻消掉，同时玩家获得一定的分数。玩家的目的是获得尽可能高的分数。</p><figure><img src="/images/wilson/tetris.gif" class="fig" width="500" alt="Tetris 游戏动画"><figcaption aria-hidden="true">Tetris 游戏动画</figcaption></figure><p>Tetris 游戏的系统随机性可以用一个概率空间 <span class="math inline">\(( \Omega,\mathbb{P} )\)</span> 来描述：任何样本点<span class="math inline">\(\omega\in\Omega\)</span> 是一个无穷序列<span class="math inline">\(\omega=\{X_i\}_{i=1}^\infty\)</span>，<span class="math inline">\(X_i\)</span> 表示第 <span class="math inline">\(i\)</span> 个落下的方块的类型，它来自集合 <span class="math inline">\(\{I,L,J,O,S,T,Z\}\)</span> 的独立均匀采样。<span class="math inline">\(\Omega\)</span> 上的概率测度 <span class="math inline">\(\mathbb{P}\)</span> 是无穷乘积测度。</p><p>例如，一个样本点 <span class="math inline">\(\omega\)</span>可能是这样的 <span class="math display">\[\omega=\{J, S, I, O, J, I, T,T, S, Z, Z, Z,\ldots\}.\]</span> 即第一个落下的方块是 <span class="math inline">\(J\)</span>，第二个是 <span class="math inline">\(S\)</span>，第三个是 <span class="math inline">\(I\)</span>，等等。</p><p>一旦给定了 <span class="math inline">\(\omega\)</span>，游戏的结果将只依赖于玩家的操作。</p><p>现在我要告诉你，Wilson 算法背后是一个类似 Tetris的游戏，游戏的目标是获得一个生成树 <span class="math inline">\(T\)</span>。但这个游戏和 Tetris游戏有一个关键不同：它得到的 <span class="math inline">\(T\)</span>只依赖于系统的随机性，不依赖于玩家的操作。换句话说：对给定的 <span class="math inline">\(\omega\)</span>，要么玩家的任何操作都会得到同一个生成树；要么任何操作都不能。即<span class="math inline">\(T\)</span> 是由 <span class="math inline">\(\omega\)</span>完全决定的。于是我们有一个确定的映射 <span class="math inline">\(\phi (\omega ) =T\)</span>！根据 <a href="#algo-success" title="命题 1.1">命题1.1</a>, Wilson 算法以概率 1 成功得到一个生成树，所以 <span class="math inline">\(\phi\)</span> 对几乎处处的 <span class="math inline">\(\omega\)</span> 是有定义的！</p><h1 id="wilson-算法作为游戏策略">Wilson 算法作为游戏策略</h1><p>我们来玩一个叫做回路弹出 ( cycle popping )的游戏。我先介绍这个游戏背后的系统随机性 <span class="math inline">\((\Omega,\mathbb{P} )\)</span>。</p><div id="----------------omega--mathbb-p-------------" class="statement sta_________omega__mathbb_p_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">概率空间 <span class="math inline">\((\Omega,\mathbb{P} )\)</span> 的构造</span>.</span></p><ol type="1"><li>固定一个顶点 <span class="math inline">\(r\)</span>。对每个 <span class="math inline">\(v\ne r\)</span>，定义栈 <span class="math inline">\(S_v=\{S_{v,1},S_{v,2},\ldots\}\)</span>。<span class="math inline">\(S_v\)</span> 的长度是无穷，其元素 <span class="math inline">\(S_{v,i}\)</span> 都是来自 <span class="math inline">\(v\)</span>的邻居的均匀采样。所有栈元素都是独立的。顶点 <span class="math inline">\(r\)</span> 的栈是空栈：<span class="math inline">\(S_r=\emptyset\)</span>。</li><li>概率空间 <span class="math inline">\(\Omega\)</span> 是所有栈 <span class="math inline">\(\{S_v\mid v\ne r\}\)</span>的所有可能的状态组成的集合。这是一个无穷离散的概率空间，其上的测度 <span class="math inline">\(\mathbb{P}\)</span> 为乘积测度。</li></ol></div><p>为了方便，我们称 <span class="math inline">\(S_v\)</span> 的第 <span class="math inline">\(i\)</span> 个元素 <span class="math inline">\(S_{v,i}\)</span> 的颜色是 <span class="math inline">\(i\)</span>。</p><p>在任何时刻，这些栈 <span class="math inline">\(\{S_v,v\ner\}\)</span> 的栈顶元素都定义了一个有向图 <span class="math inline">\(\overrightarrow{G}_S\)</span>：在 <span class="math inline">\(\overrightarrow{G}_S\)</span> 中 <span class="math inline">\(v\rightarrow u\)</span> 当且仅当 <span class="math inline">\(u\)</span> 是 <span class="math inline">\(S_v\)</span> 的栈顶元素。每个 <span class="math inline">\(v\ne r\)</span> 的出度都恰好是 1，顶点 <span class="math inline">\(r\)</span> 的出度是 0。于是若 <span class="math inline">\(\overrightarrow{G}_S\)</span>不含回路的话它就是一个以 <span class="math inline">\(r\)</span>为根的生成树。</p><div id="------------------" class="statement sta_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">回路弹出游戏</span>.</span><span class="statement-spah"> </span>给定栈的一个状态 <span class="math inline">\(\omega\in\Omega\)</span>，<span class="math inline">\(\overrightarrow{G}_S\)</span> 是 <span class="math inline">\(\omega\)</span> 对应的栈顶图，若 <span class="math inline">\(\overrightarrow{G}_S\)</span>不含回路的话则它已经是一个生成树，游戏结束；否则设 <span class="math inline">\(C\)</span> 是 <span class="math inline">\(\overrightarrow{G}_S\)</span>中的一个回路，我们可以将其「弹出」：对每个 <span class="math inline">\(v\in C\)</span>，弹出 <span class="math inline">\(S_v\)</span> 的栈顶元素 ( 于是若当前 <span class="math inline">\(S_v\)</span> 的栈顶元素为 <span class="math inline">\(S_{v,i}\)</span>，则弹出 <span class="math inline">\(S_{v,i}\)</span> 以后栈顶元素变为 <span class="math inline">\(S_{v,i+1}\)</span> ) ，这样得到更新的 <span class="math inline">\(\overrightarrow{G}_S\)</span>。玩家每次可以任选<span class="math inline">\(\overrightarrow{G}_S\)</span>中的一个回路并将其弹出。如果玩家能够经过有限多次弹出操作后使得 <span class="math inline">\(\overrightarrow{G}_S\)</span> 中不含任何回路，即<span class="math inline">\(\overrightarrow{G}_S\)</span>是一个生成树，则玩家获胜。</p></div><p>在回路弹出游戏中，玩家能做的就是每次选择一个需要弹出的回路，别的什么也做不了。游戏开始之前，<span class="math inline">\(\overrightarrow{G}_S\)</span> 中所有顶点的颜色都是1，但是随着游戏的进行，<span class="math inline">\(\overrightarrow{G}_S\)</span>会变得「五颜六色」。一个回路中可以包含不同颜色的顶点。</p><div id="wilson-------------------------" class="statement sta_wilson_________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Wilson算法作为游戏策略</span>.</span><span class="statement-spah"></span>每次任选一个不属于 <span class="math inline">\(T\)</span> 的顶点<span class="math inline">\(v\)</span>，从 <span class="math inline">\(v\)</span> 出发按照 <span class="math inline">\(\overrightarrow{G}_S\)</span>的边的指引来搜索下一个要弹出的回路。</p></div><p>树 <span class="math inline">\(T\)</span>的作用是维护那些已经完全确定下来、必然属于最终生成树的那些边。这是因为，<span class="math inline">\(T\subset\overrightarrow{G}_S\)</span> 始终是一个以<span class="math inline">\(r\)</span> 为根节点的有向树，从 <span class="math inline">\(T\)</span> 中的任何顶点出发沿着 <span class="math inline">\(\overrightarrow{G}_S\)</span>的有向边都会走到根节点 <span class="math inline">\(r\)</span>。而 <span class="math inline">\(r\)</span> 是个死胡同 ( <span class="math inline">\(r\)</span> 的出度是 0 ) ，所以 <span class="math inline">\(T\)</span> 中的顶点不可能属于任何回路。</p><p>我们前面剧透过，回路弹出游戏的结果不依赖于玩家的操作。我们把这个事实的证明放在后面，先承认它是正确的，于是我们可以定义映射<span class="math inline">\(\phi\)</span>：</p><div id="-phi----------" class="statement sta__phi____ plain unnumbered"><p><span class="statement-heading"><span class="statement-label"><span class="math inline">\(\phi\)</span> 的构造</span>.</span><span class="statement-spah"> </span>设使用 Wilson 算法对 <span class="math inline">\(\omega\)</span> 执行操作以后得到的生成树为 <span class="math inline">\(T\)</span>，定义 <span class="math inline">\(\phi( \omega ) =T\)</span>。</p></div><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(T\)</span> 服从所有生成树组成的集合 <span class="math inline">\(\mathcal{T}\)</span> 上的均匀分布。</p></div><p>这个结论解释了为什么 Wilson 算法中的 <a href="#two-arbitrary">两个任意</a> 对最终结果是没有影响的。</p><p><strong>证明</strong>：我们来计算如下事件的概率：依次弹出回路 <span class="math inline">\(\mathcal{C}= ( C_1,\ldots,C_n )\)</span>后得到的生成树是 <span class="math inline">\(T\)</span>。注意 <span class="math inline">\(\mathcal{C}\)</span> 和 <span class="math inline">\(T\)</span>的顶点必然<strong>无缝隙</strong>地填满栈 <span class="math inline">\(\{S_v\}\)</span> 的上面的部分，所以这个概率就是<span class="math inline">\(\mathcal C\)</span> 和 <span class="math inline">\(T\)</span> 中的边各自指向正确位置的概率： <span class="math display">\[\mathbb{P} ( \mathcal{C},T ) =\prod_{e\in\mathcal{C}\cup T} p_e=\Phi ( T ) \cdot \Phi ( \mathcal{C} ).\]</span> 这里 <span class="math inline">\(\Phi ( \bullet )\)</span>返回集合 <span class="math inline">\(\bullet\)</span>中所有边的概率的乘积。</p><p>设 <span class="math inline">\(\mathcal{C}_T\)</span> 是所有可能得到<span class="math inline">\(T\)</span> 的那些 <span class="math inline">\(\mathcal{C}\)</span> 组成的集合，在上式两边对<span class="math inline">\(\mathcal{C}_T\)</span> 求和，则 <span class="math display">\[\mathbb{P} ( T ) =\left (\sum_{\mathcal{C}\in\mathcal{C}_T}\Phi ( \mathcal C ) \right ) \cdot\Phi( T ) .\]</span> 然而 <span class="math inline">\(\mathcal{C}_T\)</span>是一个与 <span class="math inline">\(T\)</span>无关的集合，这是因为在给定 <span class="math inline">\(\mathcal{C}\)</span> 后，任何生成树 <span class="math inline">\(T\)</span> 都有可能出现 ( 解释见后面 ) ，因此<span class="math display">\[\mathbb{P} ( T ) ={\rm const}\cdot \Phi ( T) .\]</span> 而 <span class="math inline">\(\Phi ( T ) =\prod\limits_{v\ne r} ( 1/d_v )\)</span> 是与 <span class="math inline">\(T\)</span> 无关的量，从而 <span class="math inline">\(\mathbb{P} ( T )\)</span> 是常数，这就证明了 <span class="math inline">\(\phi\)</span> 满足 <a href="#requirements" title="条件 3">条件 3</a> 。</p><p>为什么给定 <span class="math inline">\(\mathcal{C}\)</span> 以后任何<span class="math inline">\(T\)</span>都可能出现？打个比方，想象一个向弹夹里面压子弹的过程：把树 <span class="math inline">\(T\)</span> 放在栈顶，然后依次用 <span class="math inline">\(C_n,\ldots,C_1\)</span> 将 <span class="math inline">\(T\)</span> 往下压，得到一个栈的状态 <span class="math inline">\(\{S_v\}\)</span>，对这个状态执行回路弹出，显然依次弹出的就是<span class="math inline">\(C_1,\ldots,C_n\)</span>，最终得到的树是<span class="math inline">\(T\)</span>。这顺便也说明了 <span class="math inline">\(\phi\)</span> 是满射的。</p><p>现在 <span class="math inline">\(\phi\)</span> 满足前面提到的全部 <a href="#requirements" title="三个条件">三个条件</a> ，这就证明了 Wilson算法的正确性。</p><h1 id="游戏结果与策略无关">游戏结果与策略无关</h1><p>最后我们证明最关键的部分：Wilson算法的结果与每次选择弹出的回路无关。</p><p>假设有若干玩家分别玩回路弹出的游戏，每个人采取的策略是不同的。我们想知道，对给定的系统随机性<span class="math inline">\(\omega\)</span>，这些玩家都能获胜吗？他们最终得到的生成树一样吗？需要的操作次数相同吗？</p><p>答案是：不管这些玩家采取怎样的策略，只有两种可能的结果出现：</p><ol type="1"><li>所有人都不能获胜。</li><li>所有人都能获胜，而且每个人使用的操作次数也相同，最终得到的栈顶图<span class="math inline">\(\overrightarrow{G}_S\)</span>也相同。不仅如此，每个人弹出的回路组成的集合 <span class="math inline">\(\{C_1,\ldots,C_n\}\)</span>也都是相同的。注意这里的回路 <span class="math inline">\(C_i\)</span>是带有颜色标记的，两个回路相同不仅要求包含的顶点相同，也要求对应顶点的颜色相同。仅仅弹出的顺序可能不同。</li></ol><p>我们只要证明如下的结论即可：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>对任一栈状态 <span class="math inline">\(\omega\in\Omega\)</span>，若玩家 <span class="math inline">\(A\)</span> 可以经过 <span class="math inline">\(n\)</span> 次操作后获胜，其弹出的回路依次为 <span class="math inline">\(C_1,\ldots,C_n\)</span>，则不论玩家 <span class="math inline">\(B\)</span> 的策略如何，其必然也经过 <span class="math inline">\(n\)</span> 次操作后获胜，其弹出的回路集合 <span class="math inline">\(\{D_1,\ldots,D_n\}\)</span> 与 <span class="math inline">\(\{C_1,\ldots,C_n\}\)</span> 是相同的，即适当重排<span class="math inline">\(\{D_1,\ldots,D_n\}\)</span> 后有 <span class="math inline">\(D_i=C_i\)</span>。</p></div><p><strong>证明</strong>：对玩家 <span class="math inline">\(A\)</span>的操作次数 <span class="math inline">\(n\)</span> 归纳。<span class="math inline">\(n=0\)</span> 时结论显然成立 ( 双方均无任何操作 )，下面设 <span class="math inline">\(n\geq1\)</span> 且结论对所有小于<span class="math inline">\(n\)</span> 的情形成立。</p><p>设 <span class="math inline">\(B\)</span> 第一次弹出的回路是 <span class="math inline">\(D_1\)</span>，如果 <span class="math inline">\(C_1=D_1\)</span> 则这一步操作后 <span class="math inline">\(A,B\)</span> 到达了相同的状态，而 <span class="math inline">\(A\)</span> 可以继续经过 <span class="math inline">\(n-1\)</span> 次操作后获胜，于是根据归纳假设 <span class="math inline">\(B\)</span> 也一定经过 <span class="math inline">\(n-1\)</span> 次操作获胜且后续操作 <span class="math inline">\(\{D_2,\ldots,D_n\}=\{C_2,\ldots,C_n\}\)</span>。</p><p>如果 <span class="math inline">\(C_1\ne D_1\)</span>，我们断言 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(D_1\)</span> 没有公共的顶点。否则若 <span class="math inline">\(v\in C_1\cap D_1\)</span>，由于第一次操作时 <span class="math inline">\(C_1,D_1\)</span> 属于同一个栈顶图中，以及 <span class="math inline">\(v\)</span> 的出度是 1，所以 <span class="math inline">\(v\)</span> 在 <span class="math inline">\(G_S\)</span> 中的后继 <span class="math inline">\(v_1\)</span> 也同时属于 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(D_1\)</span>，进而 <span class="math inline">\(v_1\)</span> 的后继 <span class="math inline">\(v_2\)</span> 也是如此，这样一直下去回到 <span class="math inline">\(v\)</span> 就会有 <span class="math inline">\(C_1=D_1\)</span>，矛盾。</p><p>既然 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(D_1\)</span> 没有相同顶点，那说明不论先弹 <span class="math inline">\(C_1\)</span> 后弹<span class="math inline">\(D_1\)</span>，或是先弹 <span class="math inline">\(D_1\)</span> 后弹 <span class="math inline">\(C_1\)</span>，得到的栈顶图是一样的。</p><p>接下来的论述是钻石引理 ( diamond lemma )的典型操作：我们引入两个新玩家 <span class="math inline">\(A'\)</span> 和 <span class="math inline">\(B'\)</span>：<span class="math inline">\(A'\)</span> 的前两步操作是先弹出 <span class="math inline">\(C_1\)</span> 后弹出 <span class="math inline">\(D_1\)</span>，<span class="math inline">\(B'\)</span> 的前两步操作是先弹出 <span class="math inline">\(D_1\)</span> 后弹出 <span class="math inline">\(C_1\)</span>。</p><ol type="1"><li><span class="math inline">\(A\)</span> 和 <span class="math inline">\(A'\)</span> 第一步操作相同，因此由归纳假设<span class="math inline">\(A'\)</span> 可以经过 <span class="math inline">\(n-2\)</span> 步后获胜；</li><li><span class="math inline">\(A'\)</span> 和 <span class="math inline">\(B'\)</span> 前两步操作后到达相同的状态，而已知<span class="math inline">\(A'\)</span> 可以在 <span class="math inline">\(n-2\)</span> 步后获胜，所以由归纳假设 <span class="math inline">\(B'\)</span> 也可以在 <span class="math inline">\(n-2\)</span> 步后获胜；</li><li><span class="math inline">\(B'\)</span> 和 <span class="math inline">\(B\)</span> 第一步操作相同，而已知 <span class="math inline">\(B'\)</span> 可以在 <span class="math inline">\(n-1\)</span> 步后获胜，所以由归纳假设 <span class="math inline">\(B\)</span> 也可以在 <span class="math inline">\(n-1\)</span> 步后获胜。</li></ol><p><span class="math inline">\(A,B,A',B'\)</span>弹出的回路集合相同是显然的。</p><p>至此我们就说明了 <span class="math inline">\(\phi\)</span>的定义是合理的，它是一个确定的映射。</p><p>对没有接触过钻石引理的读者，我这个论述比 Wilson的原证明的论述要繁琐，但是这个角度更本质地揭示了为什么游戏的结果不依赖于具体的策略。</p>]]></content>
      
      
      <categories>
          
          <category> 完美采样 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter element</title>
      <link href="/coxeter-element/"/>
      <url>/coxeter-element/</url>
      
        <content type="html"><![CDATA[<p>如果你对 Lie 代数有所了解的话，相信很大概率你会见过下面的图案： (参考维基百科的 <a href="https://en.wikipedia.org/wiki/Lie_algebra">Liealgebra 词条</a> )</p><p><img style="margin:0px auto;display: block" src="/images/coxeter-element/e8.svg" width="350"></p><p>它展示的是 Lie 代数 <span class="math inline">\(E_8\)</span>的根系图。<span class="math inline">\(E_8\)</span> 的根系由 8 维欧式空间<span class="math inline">\(\mathbb{R}^8\)</span> 中的 240个向量组成，将这 240 个向量投影到一个特殊的 2 维平面 ( 称作 Coxeter 平面) 上就会呈现出上图中旋转对称的图案。图中 240 个投影点分布在 8个圆周上，每个圆周包含 30 个均匀分布的点，整个图案在角度为 <span class="math inline">\(2\pi/30\)</span> 的旋转下保持不变。<span class="math inline">\(h=30\)</span> 正是 <span class="math inline">\(E_8\)</span> 的 Coxeter 数。</p><p>本文目的是介绍 Coxeter 元的一些基础知识，然后教大家怎样在 Python中编写一个程序绘制上面的投影图案。我主要参考了 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990</a>)</span> 和 <span class="citation" data-cites="CasselmanCoxeterElement">(<a href="#ref-CasselmanCoxeterElement" role="doc-biblioref">Casselman2017</a>)</span>。虽然这里面涉及的数学并不复杂，但是真正动手编程实现的时候会有一些魔鬼藏在细节中，而这些细节是仅凭念书很难发现的。</p><p>本文的代码在 <a href="https://github.com/neozhaoliang/pywonderland/blob/master/src/misc/E8.py">Github上</a> 。David Madore 也有一个很棒的 <a href="http://www.madore.org/~david/math/e8w.html">交互式网页</a>可以绘制 <span class="math inline">\(E_8\)</span>的多种不同风格的图案。</p><span id="more"></span><h1 id="coxeter-元">Coxeter 元</h1><p>在介绍 Coxeter 元之前，我们先回顾一些基础概念。</p><p>设 <span class="math inline">\((W,S)\)</span> 是一个有限且不可约的Coxeter 系，<span class="math inline">\(|S|=n\)</span>。<span class="math inline">\(S\)</span> 中的生成元满足辫关系： <span class="math display">\[(s_is_j)^{m_{ij}}=1,\quad \forall s_i,s_j\inS.\]</span> 其中 <span class="math inline">\(m_{ij}\)</span>是正整数，<span class="math inline">\(m_{ii}=1\)</span> 且 <span class="math inline">\(m_{ij}\geq2\,(i\ne j)\)</span>。</p><p>取 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(n\)</span> 维实向量空间，<span class="math inline">\(\Delta=\{\alpha_1,\ldots,\alpha_n\}\)</span> 是<span class="math inline">\(V\)</span> 的一组基，<span class="math inline">\(\Delta\)</span>叫做一组<strong>单根系</strong>，任何 <span class="math inline">\(\alpha_i\)</span> 叫做<strong>单根</strong>。定义<span class="math inline">\(V\)</span> 上的内积 <span class="math inline">\(\bullet\)</span> 如下： <span class="math display">\[\alpha_i\bullet\alpha_j=-\cos\frac{\pi}{m_{ij}}.\]</span>在这个内积下，每个 <span class="math inline">\(\alpha_i\in\Delta\)</span> 都是单位向量：<span class="math inline">\(\alpha_i\bullet\alpha_i=1\)</span>。</p><p><span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, secs.6.2–6.4</a>)</span> 中证明了 <span class="math inline">\(( W,S)\)</span> 是有限群当且仅当 <span class="math inline">\(\bullet\)</span>是正定的。</p><p>记 <span class="math inline">\(A= ( \alpha_i\bullet\alpha_j )_{1\leqi,j\leq n}\)</span> 是 <span class="math inline">\(\bullet\)</span> 在<span class="math inline">\(\Delta\)</span> 这组基下的 Gram 矩阵，<span class="math inline">\(A\)</span> 叫做 Cartan 矩阵。</p><p>规定每个生成元 <span class="math inline">\(s_i\in S\)</span> 在 <span class="math inline">\(V\)</span> 上的作用为 <span class="math display">\[s_i ( v ) = v - 2 ( v\bullet\alpha_i )\alpha_i,\quad v\in V.\]</span> 即 <span class="math inline">\(s_i\)</span> 是关于以 <span class="math inline">\(\alpha_i\)</span>为法向量的超平面的反射。这个作用将 <span class="math inline">\(W\)</span> 同构地映射为 <span class="math inline">\(O ( V )\)</span> 的一个有限反射子群。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{i_1,i_2,\ldots,i_n\}\)</span> 是集合 <span class="math inline">\(\{1,2,\ldots,n\}\)</span> 的一个置换，乘积 <span class="math inline">\(s_{i_1}s_{i_2}\cdots s_{i_n}\)</span> 叫做<strong>Coxeter 元</strong>。</p></div><p>换句话说，Coxeter 元就是把 <span class="math inline">\(W\)</span>的生成元 <span class="math inline">\(s_1,\ldots,s_n\)</span>按照任意顺序排列，然后相乘得到的群元素。</p><p>Coxeter 元的重要性质之一是：</p><div id="coxeter-conjugate" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span> <span class="statement-info">(<span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.3.16</a>)</span>)</span>.</span><span class="statement-spah"></span>所有 Coxeter 元都是互相共轭的。</p></div><p>由于 Coxeter元都是共轭的，所以它们有相同的阶、特征多项式和特征值。任一 Coxeter元的阶叫做 <span class="math inline">\(W\)</span> 的 <strong>Coxeter数</strong>，记作 <span class="math inline">\(h\)</span>。</p><p>设 <span class="math inline">\(\gamma\)</span> 是一个 Coxeter元，由于 <span class="math inline">\(\gamma\)</span> 满足 <span class="math inline">\(\gamma^h=1\)</span>，所以 <span class="math inline">\(\gamma\)</span> 的特征值必然都是 <span class="math inline">\(h\)</span> 次单位根，并且成对共轭出现： <span class="math display">\[\{\zeta^{m_1},\ldots,\zeta^{m_n},0\leqm_i&lt;h\}.\]</span> 其中 <span class="math inline">\(\zeta\)</span>是本原 <span class="math inline">\(h\)</span> 次单位根。<span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec. 3.16</a>)</span> 证明了 1不可能是 <span class="math inline">\(\gamma\)</span>的特征值，所以每个指数 <span class="math inline">\(1\leq m_i\leqh-1\)</span>。此外，<span class="math inline">\(\gamma\)</span>如果有实特征值的话只能是 <span class="math inline">\(-1\)</span>( 对应<span class="math inline">\(\zeta^{h/2}\)</span> ) 。</p><p>我们取一种特殊的 Coxeter 元如下：设 <span class="math inline">\((W,S)\)</span> 的 Coxeter 图为 <span class="math inline">\(\Gamma\)</span>，由于 <span class="math inline">\(W\)</span> 有限且不可约，<span class="math inline">\(\Gamma\)</span> 是一个树。任取 <span class="math inline">\(\Gamma\)</span> 的一个顶点作为 <span class="math inline">\(s_n\)</span>，将 <span class="math inline">\(\Gamma\)</span> 的顶点按照与 <span class="math inline">\(s_n\)</span> 的图距离划分为两个不相交的集合 <span class="math inline">\(\Gamma=I\sqcup J\)</span>：<span class="math inline">\(I\)</span> 包含所有与 <span class="math inline">\(s_n\)</span> 的距离为偶数的顶点（包括 <span class="math inline">\(s_n\)</span>）；<span class="math inline">\(J\)</span> 包含所有与 <span class="math inline">\(s_n\)</span> 的距离为奇数的顶点。由于 <span class="math inline">\(\Gamma\)</span>是树，顶点之间的距离是唯一确定的，因此 <span class="math inline">\(I\)</span> 中任何两个顶点不相邻，从而 <span class="math inline">\(I\)</span> 中的生成元两两交换。<span class="math inline">\(J\)</span> 也是如此。记 <span class="math display">\[x=\prod_{i\in I}s_i,\quad y=\prod_{j\inJ}s_j.\]</span> 则 <span class="math inline">\(\gamma=xy\)</span> 是Coxeter 元。下面对 <span class="math inline">\(\gamma\)</span>进行分析。</p><h1 id="coxeter-平面">Coxeter 平面</h1><p>设 <span class="math inline">\(\{\omega_i\}_{i=1}^n\)</span> 是 <span class="math inline">\(\{\alpha_i\}_{i=1}^n\)</span> 在内积 <span class="math inline">\(\bullet\)</span> 下的对偶基： <span class="math display">\[(\alpha_i\bullet\omega_j)=\delta_{ij}.\]</span><span class="math inline">\({\bf A}\)</span> 是把每个 <span class="math inline">\(\omega_i\)</span> 映射为 <span class="math inline">\(\alpha_i\)</span> 的线性变换： <span class="math display">\[{\bf A}\omega_i=\alpha_i,\quad \forall 1\leqi\leq n.\]</span> 则 <span class="math inline">\({\bf A}\)</span> 在<span class="math inline">\(\{\omega_i\}_{i=1}^n\)</span>这组基下的矩阵就是 Cartan 矩阵 <span class="math inline">\(A\)</span>。</p><p><span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.2.6</a>)</span> 证明了矩阵 <span class="math inline">\(A\)</span>的极小特征值 <span class="math inline">\(c&gt;0\)</span> 的重数是1，并且对应的特征向量 <span class="math inline">\({\bfc}=(c_1,\ldots,c_n)\)</span> 的所有分量都是正的。我们将变换 <span class="math inline">\({\bf A}\)</span> 的特征向量 <span class="math inline">\(\sum_{i=1}^nc_i\omega_i\)</span>写成两个向量之和： <span class="math display">\[\sum_{i=1}^nc_i\omega_i=\sum_{i\in I}c_i\omega_i+\sum_{i\in J}c_i\omega_i=\lambda+\mu.\]</span> <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec. 3.17</a>)</span>证明了如下事实：</p><ul><li><span class="math inline">\(\lambda,\mu\)</span> 张成一个二维子空间<span class="math inline">\(P\)</span>，<span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 限制在 <span class="math inline">\(P\)</span> 上分别是保持直线 <span class="math inline">\(\mathbb{R}\mu\)</span> 和 <span class="math inline">\(\mathbb{R}\lambda\)</span> 不动的反射，从而 <span class="math inline">\(\gamma=xy\)</span> 限制在 <span class="math inline">\(P\)</span> 上是一个旋转；</li><li>这个旋转在 <span class="math inline">\(P\)</span> 上的阶与 <span class="math inline">\(\gamma\)</span> 在 <span class="math inline">\(\mathbb{R}^8\)</span> 上的阶相同，也是 <span class="math inline">\(h\)</span>，从而旋转的角度等于 <span class="math inline">\(2\pi/h\)</span>。</li></ul><p>由于 <span class="math inline">\(\gamma\)</span> 置换根系 <span class="math inline">\(\Phi\)</span>，所以如果我们把 <span class="math inline">\(\Phi\)</span> 投影到 <span class="math inline">\(P\)</span> 上，就会看到一个具有 <span class="math inline">\(h\)</span> 阶旋转对称性的图案。</p><p>不过直接使用上面 <span class="math inline">\(\lambda,\mu\)</span>的定义来计算 <span class="math inline">\(P\)</span>是很不方便的，因为其中涉及了对偶基 <span class="math inline">\(\{\omega_i\}\)</span>。我们可以绕开对偶基的计算。<span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, 78</a>)</span> 中提供了以下公式<span class="math display">\[\begin{aligned}(c-1)\mu+\lambda &amp;=\sum_{i\in I}c_i\alpha_i,\\(c-1)\lambda+\mu &amp;=\sum_{j\in J}c_j\alpha_j.\end{aligned}\]</span></p><p>由于 <span class="math inline">\(c\ne 1\)</span>（1 不是 Coxeter元的特征值），这两个等式告诉我们 <span class="math display">\[P=\mathop{\mathrm{span}}\{\lambda,\,\mu\}=\mathop{\mathrm{span}}\left\{\sum_{i\inI}c_i\alpha_i,\,\sum_{j\inJ}c_j\alpha_j\right\}.\tag{$\ast$}\label{eq:alpha}\]</span>所以我们完全可以仅通过特征向量 <span class="math inline">\({\bfc}\)</span> 和 <span class="math inline">\(\Delta\)</span> 得出 <span class="math inline">\(P\)</span> 的一组基。</p><h1 id="进一步改进">进一步改进</h1><p>如果你去看 <a href="https://github.com/neozhaoliang/pywonderland/blob/master/src/misc/E8.py">Github代码</a> 的话，会发现它并不是完全按上面的逻辑写的。这是怎么回事呢？</p><p>前面的计算还有个美中不足之处，就是我们需要显式地将 <span class="math inline">\(S\)</span> 划分为 <span class="math inline">\(S=I\sqcup J\)</span>，使得 <span class="math inline">\(I,J\)</span>内部的生成元两两交换。下面的方式是我从 <span class="citation" data-cites="CasselmanCoxeterElement">(<a href="#ref-CasselmanCoxeterElement" role="doc-biblioref">Casselman2017</a>)</span> 中学到的，它使我们能够跳过 <span class="math inline">\(S\)</span> 的划分，直接计算 Coxeter 平面。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.1</span> <span class="statement-info">(<span class="citation" data-cites="CasselmanCoxeterElement">(<a href="#ref-CasselmanCoxeterElement" role="doc-biblioref">Casselman 2017,lemma. 3.3</a>)</span>)</span>.</span><span class="statement-spah"></span><span class="math inline">\(2I + \gamma + \gamma^{-1}= ( 2I-A)^2\)</span>。</p></div><p>根据这个结论，如果 <span class="math inline">\(s=e^{i\theta}\)</span>和 <span class="math inline">\(\bar{s}=e^{-i\theta}\)</span> 是 <span class="math inline">\(\gamma\)</span> 的一对共轭的复特征值，<span class="math inline">\(V_s,V_{\bar{s}}\)</span>分别是对应的特征子空间，记 <span class="math inline">\(U=V_s\oplusV_{\bar{s}}\)</span>，则对任何 <span class="math inline">\(u\inU\)</span> 有 <span class="math display">\[( 2I-A )^2 ( u ) = (2+e^{i\theta}+e^{-i\theta} ) u= 4\cos^2(\theta/2) u.\]</span> 即 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(( 2I-A)^2\)</span> 的特征值为 <span class="math inline">\(4\cos^2(\theta/2)\)</span> 的特征子空间。</p><p>我们想把这个结论中的平方去掉，即证明 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(2I-A\)</span> 的特征值为 <span class="math inline">\(\pm 2\cos(\theta/2)\)</span>的特征子空间的直和。</p><div id="u-pm" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(U_{\pm}\)</span> 是 <span class="math inline">\(2I-A\)</span> 的 <span class="math inline">\(\pm2\cos(\theta/2)\)</span> 特征子空间，则 <span class="math inline">\(\dim U_+=\dim U_-\)</span> 并且 <span class="math inline">\(U=U_+\oplus U_-\)</span>。</p></div><p><strong>证明</strong>：显然 <span class="math inline">\(U\supseteqU_+\oplus U_-\)</span>。下面证明反向包含。</p><p>显然 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(2I-A\)</span> 的不变子空间。而 <span class="math inline">\(2I-A\)</span> 是可对角化的，所以 <span class="math inline">\(2I-A\)</span> 限制在 <span class="math inline">\(U\)</span> 上也可以对角化，即 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(2I-A\)</span> 的特征子空间的直和。显然 <span class="math inline">\(2I-A\)</span> 在 <span class="math inline">\(U\)</span> 上的特征值只有可能是 <span class="math inline">\(\pm 2\cos(\theta/2)\)</span>，从而 <span class="math inline">\(U\subseteq U_+\oplus U_-\)</span>，即 <span class="math inline">\(U=U_+\oplus U_-\)</span>。</p><p>为了说明 <span class="math inline">\(\dim U_+=\dimU_-\)</span>，我们需要下面的引理，这个引理的证明并不是简单的线性代数，它要用到Coxeter 图 <span class="math inline">\(\Gamma\)</span>的不可约条件：</p><div id="same-characteristic" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.3</span> <span class="statement-info">(<span class="citation" data-cites="CasselmanCoxeterElement">(<a href="#ref-CasselmanCoxeterElement" role="doc-biblioref">Casselman 2017,lemma. 3.5</a>)</span>)</span>.</span><span class="statement-spah"></span><span class="math inline">\(2I-A\)</span> 和 <span class="math inline">\(A-2I\)</span> 有同样的特征多项式。</p></div><p>这个引理告诉我们，若 <span class="math inline">\(\lambda\)</span> 是<span class="math inline">\(A-2I\)</span> 的特征值，则 <span class="math inline">\(-\lambda\)</span>也是，并且二者的特征子空间维数相等（<span class="math inline">\(A-2I\)</span>是可对角化的，特征值的几何重数等于代数重数）。于是 <span class="math inline">\(\dim U_+=\dim U_-\)</span>。<a href="#u-pm" title="命题 3.2">命题 3.2</a> 得证。<span class="math inline">\(\blacksquare\)</span></p><p>由于 <span class="math inline">\(2I-A\)</span> 的 <span class="math inline">\(\pm2\cos(\theta/2)\)</span> 特征子空间对应的是<span class="math inline">\(A\)</span> 的 <span class="math inline">\(2\mp2\cos(\theta/2)\)</span>特征子空间，所以我们得到了下面的推论：</p><div id="eigenspace-pair" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论3.4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(A\)</span> 的不等于 2 的特征值成对出现，它们形如<span class="math inline">\(2\mp2\cos(\theta/2)\)</span>，并且对应的特征子空间<span class="math inline">\(U_{\pm}\)</span> 的维数是相等的。</p></div><p>一般来说 <span class="math inline">\(U=U_+\oplus U_-\)</span>的维数未必是 2，所以 <span class="math inline">\(U\)</span>不一定是平面。</p><p>然而对 <span class="math inline">\(A\)</span> 的极小特征值 <span class="math inline">\(c_\min=2-2\cos(\theta_0/2)\)</span>，我们知道<span class="math inline">\(c_\min\)</span> 的重数是 1。根据 <a href="#eigenspace-pair" title="推论 3.4">推论 3.4</a>，<span class="math inline">\(A\)</span> 的极大特征值 <span class="math inline">\(c_\max=2+2\cos(\theta_0/2)\)</span> 的重数也是1，这时 <span class="math inline">\(U\)</span> 就是一个二维平面，并且<span class="math inline">\(\gamma\)</span> 在 <span class="math inline">\(U\)</span>上的作用是一个旋转。我们来说明这个旋转的阶等于 <span class="math inline">\(\gamma\)</span> 的阶 <span class="math inline">\(h\)</span>，从而 <span class="math inline">\(U\)</span> 就是要找的 Coxeter 平面：</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.5</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(u,v\)</span> 分别是 <span class="math inline">\(c_\min,c_\max\)</span> 对应的特征向量，<span class="math inline">\(U=\mathop{\mathrm{span}}\{u,v\}\)</span>，则 <span class="math inline">\(\gamma\)</span> 作为 <span class="math inline">\(U\)</span> 上的旋转的阶等于 <span class="math inline">\(\gamma\)</span> 的阶 <span class="math inline">\(h\)</span>。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(u=\sum_{i=1}^nc_i\omega_i\)</span>，<span class="math inline">\(\gamma\)</span> 限制在 <span class="math inline">\(P\)</span> 上的阶是 <span class="math inline">\(k\)</span>。由于 <span class="math inline">\(u\inP\)</span>，所以 <span class="math inline">\(\gamma^k u=u\)</span>。</p><p>由于每个 <span class="math inline">\(c_i&gt;0\)</span> <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec. 2.6</a>)</span>，所以 <span class="math inline">\((u\bullet\alpha_s)&gt;0\)</span> 对任何单根 <span class="math inline">\(\alpha_s\)</span> 成立，即 <span class="math inline">\(u\)</span> 属于 <span class="math inline">\(W\)</span> 在 <span class="math inline">\(V\)</span> 上作用的基本区域 <span class="math inline">\(C\)</span>。然而根据 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec. 1.12</a>)</span>，在 <span class="math inline">\(W\)</span> 中只有单位元 1 可以保持 <span class="math inline">\(u\in C\)</span> 不动，所以 <span class="math inline">\(\gamma^k=1\)</span>，从而 <span class="math inline">\(k=h\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>于是计算 <span class="math inline">\(P\)</span> 归结为计算 <span class="math inline">\({\bf A}\)</span> 在 <span class="math inline">\(\{\omega_i\}_{i=1}^n\)</span>这组基下极小/极大特征值对应的特征向量。设 <span class="math display">\[u=\sum_{i=1}^nc_i\omega_i\quad\text{and}\quadv=\sum_{i=1}^nd_i\omega_i\]</span> 分别是 <span class="math inline">\({\bf A}\)</span> 对应 <span class="math inline">\(c_\min,c_\max\)</span> 的特征向量，它们构成 <span class="math inline">\(P\)</span> 的一组正交基。它们被 <span class="math inline">\({\bf A}\)</span>作用以后与自身相差一个常数倍，所以 <span class="math display">\[{\bfA}u=\sum_{i=1}^nc_i\alpha_i\quad\text{and}\quad {\bfA}v=\sum_{i=1}^nd_i\alpha_i\]</span> 也构成 <span class="math inline">\(P\)</span> 的一组正交基。而计算这组正交基只用到Cartan 矩阵 <span class="math inline">\(A\)</span> 和单根系 <span class="math inline">\(\Delta\)</span>。</p><h1 id="e_8-的例子"><span class="math inline">\(E_8\)</span> 的例子</h1><p>在这一节中，我们以 <span class="math inline">\(E_8\)</span>​为例，应用上述理论进行实际计算。</p><p><span class="math inline">\(E_8\)</span> 的 Coxeter 图如下：</p><p><img src="/images/coxeter-element/e8-dynkin.svg" class="fig" width="400"></p><p>我们第一步需要取 <span class="math inline">\(\mathbb{R}^8\)</span>的一组基 <span class="math inline">\(\Delta=\{\alpha_i\}_{1\leq i\leq8}\)</span> 作为单根系，并规定它们之间的内积 <span class="math inline">\(\bullet\)</span> 为 <span class="math display">\[(\alpha_i\bullet\alpha_j)_{1\leq i,j\leq8}=\begin{pmatrix}2&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\-1&amp;2&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0\\0&amp;-1&amp;2&amp;-1&amp;0&amp;0&amp;0&amp;0\\0&amp;0&amp;-1&amp;2&amp;-1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;-1&amp;2&amp;-1&amp;0&amp;-1\\0&amp;0&amp;0&amp;0&amp;-1&amp;2&amp;-1&amp;0\\0&amp;0&amp;0&amp;0&amp;0&amp;-1&amp;2&amp;0\\0&amp;0&amp;0&amp;0&amp;-1&amp;0&amp;0&amp;2\end{pmatrix}.\]</span>注意这里每个单根 <span class="math inline">\(\alpha_i\bullet\alpha_i=2\)</span>，并不是单位向量，这样主要是为了书写代码更方便。</p><p>由于 <span class="math inline">\(\bullet\)</span>是正定的，所以我们可以适当选择单根系 <span class="math inline">\(\Delta\)</span> 使得在这组基下 <span class="math inline">\(\bullet\)</span> 就是标准的 Euclidean内积。例如，取 <span class="math inline">\(\alpha_i\)</span>为下面矩阵的第 <span class="math inline">\(i\)</span> 行： <span class="math display">\[\begin{bmatrix}1&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\0&amp;1&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;-1&amp;0&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;1&amp;-1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;0&amp;1&amp;-1&amp;0&amp;0\\0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;1&amp;0\\-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}\\0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;-1&amp;0\end{bmatrix}.\]</span></p><p>用代码来写的话，就是</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># A set of simple roots listed by rows of 'delta'</span><br>delta = np.array([<br>    [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>    [-<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>])<br><br><span class="hljs-comment"># The cartan matrix:</span><br>cartan = np.dot(delta, delta.transpose())<br></code></pre></td></tr></tbody></table></figure><p>所有单反射 <span class="math inline">\(\{s_i\}_{i=1}^8\)</span>生成的群 <span class="math inline">\(W\)</span> 叫做 <span class="math inline">\(E_8\)</span> 的 Weyl 群，这个群包含 696729600个元素。单根系在 <span class="math inline">\(W\)</span> 作用下生成的集合<span class="math inline">\(\Phi = \{w\cdot\alpha\,|\, w\in W,\alpha\in\Delta\}\)</span> 叫做 <span class="math inline">\(E_8\)</span>的根系，<span class="math inline">\(\Phi\)</span> 中包含 240个不同的向量，<span class="math inline">\(W\)</span> 置换 <span class="math inline">\(\Phi\)</span> 中的向量。</p><p><span class="math inline">\(\Phi\)</span>中的向量从形式上看分为两类：</p><ol type="1"><li>第一类包含 <span class="math inline">\((\pm1,\pm1,0,0,0,0,0,0)\)</span>的所有置换，即有两个分量是 <span class="math inline">\(+1\)</span> 或者<span class="math inline">\(-1\)</span>，其余６个分量都是 0的向量。这样的向量有 112 个。</li><li>第二类包含所有形如 <span class="math inline">\(1/2\times(\pm1,\pm1,\cdots,\pm1)\)</span>的向量，其中 <span class="math inline">\(-1\)</span>的个数是偶数。这样的向量有 128 个。</li></ol><p>为了编程方便，我们可以把所有根都乘以2，使得它们都是整数向量。于是生成根系 <span class="math inline">\(\Phi\)</span> 的代码可以这样写：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br>roots = []<br><br><span class="hljs-comment"># Roots of the form (+-1, +-1, 0, 0, 0, 0, 0, 0),</span><br><span class="hljs-comment"># signs can be chosen independently and the two non-zeros can be anywhere.</span><br><span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> combinations(<span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>), <span class="hljs-number">2</span>):<br>    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> product([-<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], repeat=<span class="hljs-number">2</span>):<br>        v = np.zeros(<span class="hljs-number">8</span>)<br>        v[i] = x<br>        v[j] = y<br>        roots.append(v)<br><br><span class="hljs-comment"># Roots of the form 1/2 * (+-1, +-1, ..., +-1), signs can be chosen</span><br><span class="hljs-comment"># indenpendently except that there must be an even numer of -1s.</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> product([-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], repeat=<span class="hljs-number">8</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(v) % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>:<br>        roots.append(v)<br>roots = np.array(roots).astype(<span class="hljs-built_in">int</span>)<br><br><span class="hljs-comment"># Connect a root to its nearest neighbors,</span><br><span class="hljs-comment"># two roots are connected if and only if they form an angle of pi/3.</span><br>edges = []<br><span class="hljs-keyword">for</span> i, r <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(roots):<br>    <span class="hljs-keyword">for</span> j, s <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(roots[i + <span class="hljs-number">1</span> :], i + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">sum</span>((r - s) ** <span class="hljs-number">2</span>) == <span class="hljs-number">8</span>:<br>            edges.append([i, j])<br></code></pre></td></tr></tbody></table></figure><p>我们来计算 Coxeter 平面 <span class="math inline">\(P\)</span>的一组基。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">eigenvals, eigenvecs = np.linalg.eigh(cartan)<br>u = eigenvecs[:, <span class="hljs-number">0</span>]<br>v = eigenvecs[:, -<span class="hljs-number">1</span>]<br><br>u = np.dot(u, delta)<br>v = np.dot(v, delta)<br></code></pre></td></tr></tbody></table></figure><p>其中 <code>eigenvals</code> 返回 Cartan矩阵的特征值，按照从小到大排列；<code>eigenvecs</code> 的列向量是 Cartan矩阵的特征向量，也是按照特征值递增的顺序排列，第一列<code>u = eigenvecs[:, 0]</code> 和最后一列<code>v = eigenvecs[:, -1]</code>就是最小和最大特征值对应的特征向量。</p><p>把 <code>eigenvals</code> 中的特征值打印出来：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">0.01095621</span> <span class="hljs-number">0.51371035</span> <span class="hljs-number">1.18652671</span> <span class="hljs-number">1.58417662</span> <span class="hljs-number">2.41582338</span> <span class="hljs-number">2.81347329</span> <span class="hljs-number">3.48628965</span> <span class="hljs-number">3.98904379</span>]<br></code></pre></td></tr></tbody></table></figure><p>可以看到最小的特征值 <span class="math display">\[0.01095621 \approx2-2\cos\frac{\theta_0}{2},\quad \theta_0\approx2\arccos0.994521895\approx\frac{2\pi}{30}.\]</span> 所以我们验证了 <span class="math inline">\(\gamma\)</span> 在 <span class="math inline">\(P\)</span> 上的作用是一个 30 阶的旋转，即 <span class="math inline">\(W\)</span> 的 Coxeter 数是 30。</p><p>根据上一节末尾的介绍，<span class="math inline">\(\sum_{i=1}^8u_i\alpha_i\)</span> 和 <span class="math inline">\(\sum_{i=1}^8v_i\alpha_i\)</span> 构成 <span class="math inline">\(P\)</span>的一组正交基。把它们归一化为单位向量，然后计算根系 <code>roots</code> 到<span class="math inline">\(P\)</span> 的投影：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">u /= np.linalg.norm(u)<br>v /= np.linalg.norm(v)<br>roots_2d = [(np.dot(u, x), np.dot(v, x)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> roots]<br></code></pre></td></tr></tbody></table></figure><p>剩下的就是具体的绘图过程了，这里不再赘述。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-CasselmanCoxeterElement" class="csl-entry" role="listitem">Casselman, Bill. 2017. <span>“Coxeter Elements in Finite CoxeterGroups”</span> Essays on Coxeter groups. <a href="https://personal.math.ubc.ca/~cass/research/pdf/Element.pdf">https://personal.math.ubc.ca/~cass/research/pdf/Element.pdf</a>.</div><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div></div>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Birkhoff 遍历定理</title>
      <link href="/Birkhoff-ergodic-theorem/"/>
      <url>/Birkhoff-ergodic-theorem/</url>
      
        <content type="html"><![CDATA[<p>我念研究生时的高等概率论课用的是 Durrett 的教材 “Probability: TheoryandExamples”。这本书的好处我就不再介绍了，院长陈大岳老师在世图影印版的前言中已经夸了一遍。我个人的体会是，Durrett的书在讲解证明的时候非常简练，很少写为什么要这样证，我有时候读了半天也没搞明白思路。Birkhoff遍历定理算是其中一个，于是我重新整理了一下书中的证明，作此文留念。</p><p>Birkhoff 遍历定理最初由 Birkhoff 本人在 1931 年发表，原文长达 50页。随后在 1939 年 K.Yosida （吉田耕作） 和 S.Kakutani （角谷）利用极大遍历定理给出了一个 10页的简洁证明，不过他们关于极大遍历定理的证明还是啰嗦了点，后来 Garsia给出了极大遍历定理的一个仅有寥寥数行的惊人证明，这也是当前大多数教材采用的途径，本文就来介绍这一证明。</p><span id="more"></span><h1 id="准备工作">准备工作</h1><p>给定一个概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span>，我们称两个可测集<span class="math inline">\(A,B\in F\)</span>几乎处处相等，是指它们的示性函数 <span class="math inline">\(\mathbb{1}_A,\mathbb{1}_B\)</span>几乎处处相等，记作 <span class="math inline">\(A\stackrel{\mathrm{a.e.}}{=}B\)</span>。等价的说法是<span class="math inline">\(A,B\)</span>只差一个零测集，或者再换一个说法，差集 <span class="math inline">\(A\Delta B\)</span> 是零测集。</p><p>设 <span class="math inline">\(T:\Omega\rightarrow \Omega\)</span>是一个可测变换，即对任何 <span class="math inline">\(E\in\mathcal{F}\)</span> 有 <span class="math inline">\(T^{-1}E\in\mathcal{F}\)</span>。</p><div id="def-1" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>如果可测集 <span class="math inline">\(E\)</span> 满足 <span class="math inline">\(T^{-1}E\stackrel{\mathrm{a.e.}}{=}E\)</span>，就称<span class="math inline">\(E\)</span> 是一个 <span class="math inline">\(T\)</span>- 不变集合。不难验证所有的 <span class="math inline">\(T\)</span>- 不变集合 <span class="math display">\[\mathcal{I}=\{E\in F\midT^{-1}E\stackrel{\mathrm{a.e.}}{=}E\}\]</span> 构成 <span class="math inline">\(\mathcal{F}\)</span> 的一个子 <span class="math inline">\(\sigma\)</span>- 代数。</p></div><div id="def-2" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.2</span>.</span><span class="statement-spah"> </span>如果对任何可测集<span class="math inline">\(E\in\mathcal{F}\)</span> 有 <span class="math inline">\(\mu(T^{-1}E)=\mu(E)\)</span>，就称 <span class="math inline">\(T\)</span> 是一个保测变换。</p></div><p>在本文中，<span class="math inline">\(T\)</span>始终代表一个保测变换。</p><p>保测变换有如下性质：</p><div id="lemma-1" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(f\in L^1(\Omega)\)</span>是一个可积的随机变量，<span class="math inline">\(T\)</span>是保测变换，则 <span class="math display">\[\int_\Omegaf\,\mathrm{d}\mu=\int_\Omega f\circ T\,\mathrm{d}\mu.\]</span></p></div><p><strong>证明</strong>：若 <span class="math inline">\(E\in\mathcal{F}\)</span> 是可测集，由于 <span class="math display">\[\omega\in T^{-1}E\Leftrightarrow T(\omega)\inE\Leftrightarrow(\mathbb{1}_E\circ T) (\omega)=1.\]</span> 所以 <span class="math inline">\(\mathbb{1}_{E}\circT=\mathbb{1}_{\{T^{-1}E\}}\)</span>，因此 <span class="math display">\[\int_\Omega\mathbb{1}_E\,\mathrm{d}\mu=\mu(E)=\mu(T^{-1}E)=\int_\Omega\mathbb{1}_{\{T^{-1}E\}}\,\mathrm{d}\mu=\int_\Omega \mathbb{1}_E\circT\,\mathrm{d}\mu.\]</span>从而结论对集合的示性函数成立，进一步由积分的线性性质对任何简单函数也成立，再取极限即得对一般的可积函数结论成立。</p><div id="lemma-2" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.4</span>.</span><span class="statement-spah"> </span>一个 <span class="math inline">\(\Omega\)</span> 上的随机变量 <span class="math inline">\(X\)</span> 关于 <span class="math inline">\(\mathcal{I}\)</span> 可测，当且仅当有 <span class="math display">\[X\circ T=X\quad \text{a.e.}\]</span>成立。这时我们称 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(T\)</span>- 不变的随机变量。</p></div><p>这是 Durrett书中的一道习题，我一直觉得它很平凡，其实这个结论还是需要论证一番的。</p><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>：如果 <span class="math inline">\(X\)</span> 关于 <span class="math inline">\(\mathcal{I}\)</span> 可测，则对任何 Borel 集 <span class="math inline">\(B\in\mathcal{B}(\mathbb{R}^1)\)</span> 有 <span class="math inline">\(X^{-1}B\in\mathcal{I}\)</span>，即 <span class="math inline">\(T^{-1}(X^{-1}B)\stackrel{\mathrm{a.e.}}{=}X^{-1}B\)</span>，这说明<span class="math inline">\(\{X\circ T\inB\}\stackrel{\mathrm{a.e.}}{=}\{X\in B\}\)</span>。特别地取 <span class="math inline">\(B=(-\infty, t)\)</span> 我们得到 <span class="math inline">\(\{X\circT&lt;t\}\stackrel{\mathrm{a.e.}}{=}\{X&lt;t\}\)</span>。我们来证明如果<span class="math inline">\(\xi,\,\eta\)</span>是两个可测函数且对任何实数 <span class="math inline">\(t\)</span> 有<span class="math inline">\(\{\xi&lt;t\}\stackrel{\mathrm{a.e.}}{=}\{\eta&lt;t\}\)</span>，则<span class="math inline">\(\xi=\eta,\,\mathrm{a.e.}\)</span>。然后对<span class="math inline">\(\xi=X\circ T,\,\eta=T\)</span>应用此结论即可。若不然，不妨设 <span class="math inline">\(\{\xi&gt;\eta\}\)</span> 具有正测度，则存在有理数<span class="math inline">\(c\)</span> 使得集合 <span class="math inline">\(\{\xi&gt;c&gt;\eta\}\)</span>具有正测度，这个集合在 <span class="math inline">\(\{\eta&lt;c\}\)</span> 中，但是不在 <span class="math inline">\(\{\xi&lt;c\}\)</span> 中，这与 <span class="math inline">\(\{\eta&lt;c\}\)</span> 和 <span class="math inline">\(\{\xi&lt;c\}\)</span> 只差一个零测集矛盾。</p><p><span class="math inline">\(\Leftarrow\)</span>：如果 <span class="math inline">\(X\circ T=X\)</span> 几乎处处成立，则对任何 <span class="math inline">\(B\in\mathcal{B}(\mathbb{R}^1)\)</span> 有 <span class="math inline">\(X^{-1}B\stackrel{\mathrm{a.e.}}{=}T^{-1}X^{-1}B\)</span>，这说明<span class="math inline">\(X^{-1}B\in\mathcal{I}\)</span>，即 <span class="math inline">\(X\)</span> 关于 <span class="math inline">\(\mathcal{I}\)</span> 可测。</p><h1 id="birkhoff-遍历定理">Birkhoff 遍历定理</h1><p>设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\Omega\)</span> 上的随机变量，对每个整数 <span class="math inline">\(n\geq 1\)</span>，令 <span class="math display">\[S_n(\omega)= \sum_{k=0}^{n-1}f(T^k(\omega)).\]</span> 我们有如下的定理：</p><div id="birkhoff" class="statement sta_birkhoff_____ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Birkhoff 遍历定理</span>.</span><span class="statement-spah"> </span><br></p><p>设 <span class="math inline">\(T\)</span> 是概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span>上的保测变换，则对任何 <span class="math inline">\(f\inL^1(\Omega)\)</span> 有 <span class="math display">\[\lim_{n\to\infty}\frac{S_n}{n}\rightarrow\mathbb{E}[f\,|\,\mathcal{I}]\quad\text{a.e.}\]</span></p></div><p>证明 Birkhoff遍历定理定理的关键是证明如下的极大遍历定理：（极大遍历定理这个名字来源于分析中的Hardy-Littlewood 极大函数，这一类的不等式统称为极大不等式）</p><div id="max-ergodic" class="statement sta_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">极大遍历定理</span>.</span><span class="statement-spah"> </span><br></p><p>定义极大算子 <span class="math display">\[M_f(\omega)=\sup_{n\geq1}\frac{1}{n}S_n(\omega),\]</span> 则对 <span class="math inline">\(f\inL^1(\Omega)\)</span> 和任一 <span class="math inline">\(a\in\mathbb{R}\)</span>，有 <span class="math display">\[\int_{\{M_f&gt;a\}} f\,\mathrm{d}\mu\geqa\mu(\{M_f&gt;a\}).\]</span></p></div><p>极大遍历定理是整个 Birkhoff遍历定理的证明中最不直观的部分，而且我也确实不知道怎么解释引入它的动机。我第一次看到这个式子的时候是很懵的。一个直观的理解是，观察下面这个显然成立的不等式：<span class="math display">\[\int_{\{M_f&gt;a\}} M_f\,\mathrm{d}\mu\geqa\mu(\{M_f&gt;a\}).\]</span> 极大遍历定理是说把其中的积分函数换成 <span class="math inline">\(f\)</span>，积分范围保持不变的话，不等式仍然成立。</p><p>我把极大遍历定理的证明放在最后，先用它来证明 Birkhoff 遍历定理。</p><h1 id="birkhoff-遍历定理的证明">Birkhoff 遍历定理的证明</h1><p>首先可以假定条件期望 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]=0\)</span>，否则我们可以用<span class="math inline">\(f-\mathbb{E}[f\,|\,\mathcal{I}]\)</span>代替 <span class="math inline">\(f\)</span>，注意到 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]\)</span> 是 <span class="math inline">\(T\)</span>- 不变的，所以根据上面的 <a href="#lemma-2" title="引理 1.4">引理 1.4</a> 有 <span class="math display">\[\mathbb{E}[f\,|\,\mathcal{I}]\circ T^k =\mathbb{E}[f\,|\,\mathcal{I}],\quad \mathrm{a.e.}\]</span>对所有的正整数 <span class="math inline">\(k\)</span> 都成立，这时 <a href="#birkhoff" title="Birkhoff 遍历定理">Birkhoff 遍历定理</a> 的左边<span class="math inline">\(S_n\)</span> 中每一项都会多出来一个 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]\)</span>，除以 <span class="math inline">\(n\)</span> 正好和右边的 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]\)</span>抵消掉。</p><p>这样问题变成在 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]=0\)</span>的前提下证明 <span class="math display">\[\lim\limits_{n\to\infty}\frac{S_n}{n}=0.\quad\text{a.e.}\]</span> 设 <span class="math inline">\(a\)</span>是任一正数，考虑集合 <span class="math display">\[A= \left\{\omega \mid\varlimsup_{n\to\infty}\frac{S_n}{n}&gt;a\right\}.\]</span> 我们想证明<span class="math inline">\(\mu(A)=0\)</span>。若真如此，则有 <span class="math inline">\(\varlimsup\limits_{n\to\infty}S_n/n\leq a\)</span>几乎处处成立，根据 <span class="math inline">\(a\)</span> 的任意性就得到<span class="math inline">\(\varlimsup\limits_{n\to\infty}S_n/n\leq0\)</span> 几乎处处成立。再把这个结果用在 <span class="math inline">\(-f\)</span> 上就得到 <span class="math inline">\(\varliminf\limits_{n\to\infty}S_n/n\geq 0\)</span>也几乎处处成立，这样就证明了 <span class="math inline">\(\lim\limits_{n\to\infty}S_n/n=0\)</span>几乎处处成立。（拗口）</p><p>为了证明 <span class="math inline">\(\mu(A)=0\)</span>，我们希望对函数 <span class="math inline">\(f\)</span> 和集合 <span class="math inline">\(A\)</span> 应用极大不等式： <span class="math display">\[\int_A f\,\mathrm{d}\mu\geq a\mu(A).\]</span>这是因为，<span class="math inline">\(A\)</span> 其实是一个 <span class="math inline">\(T\)</span>- 不变的集合，即 <span class="math inline">\(A\in\mathcal{I}\)</span>，我们会在证明末尾再验证这一点。于是根据条件期望的性质，<span class="math display">\[\int_A f\,\mathrm{d}\mu = \int_A\mathbb{E}[f\,|\,\mathcal{I}]\,\mathrm{d}\mu =0.\]</span> 即 <span class="math inline">\(0\geq a\mu(A)\)</span>，结合 <span class="math inline">\(a&gt;0\)</span> 即得 <span class="math inline">\(\mu(A)=0\)</span>。</p><p>但是，我们能对 <span class="math inline">\(A\)</span>使用极大不等式吗？请注意 <span class="math inline">\(\varlimsup\limits_{n\to\infty}\)</span> 和 <span class="math inline">\(\sup\limits_{n\geq 1}\)</span>的区别，它们定义的是两个不同的随机变量。<span class="math inline">\(A\)</span> 是用 <span class="math inline">\(\varlimsup\limits_{n\to\infty}\)</span>定义的，而极大遍历定理中说的是 <span class="math inline">\(\sup\limits_{n\geq 1}\)</span>。注意到 <span class="math display">\[A=\left\{\varlimsup_{n\to\infty}\frac{S_n}{n}&gt;a\right\}\subseteq\left\{\sup_{n\geq 1}\frac{S_n}{n}&gt;a\right\}=\left\{M_f&gt;a\right\},\]</span>所以我们只需要证明下面的结论就好了：</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\subseteq \{M_f&gt;a\}\)</span> 而且 <span class="math inline">\(A\)</span> 是一个 <span class="math inline">\(T\)</span>- 不变集合，那么极大遍历定理仍然成立：<span class="math display">\[\int_A f\,\mathrm{d}\mu\geqa\mu(A).\]</span></p></div><p><strong>引理的证明</strong>：对函数 <span class="math inline">\(g=f\cdot\mathbb{1}_A\)</span> 应用极大遍历定理：<span class="math display">\[\int_{\{M_g&gt;a\}}f\cdot\mathbb{1}_A\,\mathrm{d}\mu\geq a\mu(\{M_g&gt;a\}).\]</span> 但是<span class="math inline">\(M_g=M_f\cdot\mathbb{1}_A\)</span>，这一点要用到<span class="math inline">\(A\)</span> 是 <span class="math inline">\(T\)</span>- 不变集合这个条件，因此 <span class="math display">\[\{M_g&gt;a\}=\{M_f&gt;a\}\cap A=A.\]</span>因此确实有 <span class="math display">\[\int_Af\,\mathrm{d}\mu\geq a \mu(A).\]</span> 这样就证明了 Birkhoff遍历定理。</p><p>实际上定理中的收敛也是一个依 <span class="math inline">\(L^1\)</span>范数的收敛，这点的证明相比几乎处处收敛就容易多了，这里不再赘述。</p><p>最后我们来补上证明中遗漏的部分，即验证集合 <span class="math inline">\(A=\left\{\varlimsup\limits_{n\to\infty}S_n/n&gt;a\right\}\)</span>确实是 <span class="math inline">\(T\)</span>- 不变的：</p><p>利用 <span class="math inline">\(S_{n+1} = f + S_n\circ T\)</span>可得 <span class="math display">\[\frac{S_{n+1}}{n+1} = \frac{f}{n+1} +\frac{S_n\circ T}{n}\cdot \frac{n}{n+1}.\]</span>对两边同时取上极限，注意由于 <span class="math inline">\(f\inL^1(\Omega)\)</span> 所以 <span class="math inline">\(f\)</span>几乎处处有限，从而 <span class="math inline">\(\lim\limits_{n\to\infty}f/(n+1)=0,\,\text{a.e.}\)</span>。所以<span class="math display">\[\varlimsup_{n\to\infty} \frac{S_{n+1}}{n+1}= \varlimsup_{n\to\infty}\frac{S_{n}\circ T}{n}.\]</span> 这正说的是<span class="math inline">\(\varlimsup\limits_{n\to\infty}S_n/n\)</span>是 <span class="math inline">\(T\)</span>- 不变的随机变量，从而 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(T\)</span>- 不变的集合。</p><p>最后来证明极大遍历定理。</p><h1 id="极大遍历定理的证明">极大遍历定理的证明</h1><p>只要证明 <span class="math inline">\(a=0\)</span>的情形，然后对一般的 <span class="math inline">\(a\)</span>，将结论应用在函数 <span class="math inline">\(f-a\)</span> 上即可。定义 <span class="math inline">\(S_0=0\)</span> 以及 <span class="math inline">\(M_n =\max\{S_0,S_1,\cdots,S_n\}\)</span>。对每个<span class="math inline">\(k=1,\ldots,n\)</span> 有 <span class="math display">\[S_k=f+S_{k-1}\circ T\leq f+M_n \circ T.\]</span>从而 <span class="math display">\[\max_{1\leq k\leq n}S_k\leq f+M_n\circ T.\]</span></p><p>但是在集合 <span class="math inline">\(\{M_n&gt;0\}\)</span>上，<span class="math inline">\(M_n\)</span> 作为 <span class="math inline">\(S_0,S_1,\ldots,S_n\)</span> 中的最大者肯定不能来自<span class="math inline">\(S_0=0\)</span>，所以 <span class="math inline">\(M_n=\max\limits_{1\leq k\leq n}S_k\)</span>，因此<span class="math display">\[M_n\leq f+M_n \circ T,\quad \omega\in\{M_n&gt;0\}.\]</span> 注意 <span class="math inline">\(M_n\)</span>总是非负的随机变量，从而 <span class="math display">\[\begin{align*}\int_{\{M_n&gt;0\}} f &amp;\geq\int_{\{M_n&gt;0\}}M_n -\int_{\{M_n&gt;0\}}M_n\circ T\\ &amp; =\int_\Omega M_n- \int_{\{M_n&gt;0\}}M_n\circ T\\&amp;\geq \int_\OmegaM_n-\int_\Omega M_n\circ T\\&amp;=0.\end{align*}\]</span> 最后由于 <span class="math inline">\(\{M_n&gt;0\}\uparrow\{M_f&gt;0\}\)</span>，所以由控制收敛定理即可得到 <span class="math display">\[\int_{\{M_f&gt;0\}}f\geq 0.\]</span>极大遍历定理得证。</p>]]></content>
      
      
      <categories>
          
          <category> Durrett 概率论批判 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实表示和复表示</title>
      <link href="/real-and-complex-representations/"/>
      <url>/real-and-complex-representations/</url>
      
        <content type="html"><![CDATA[<p>在数学中有许多「三分天下」的例子，比如：</p><ol type="1"><li>常曲率空间只有 Euclidean、球面、双曲三种。</li><li>三类典型的偏微分方程：热方程 （抛物）、Laplace 方程 （椭圆）、波方程（双曲）。</li><li>复平面上全纯等价下只有三种单连通区域：单位圆 <span class="math inline">\(\mathbb{D}\)</span>、复平面 <span class="math inline">\(\mathbb{C}\)</span>、扩充复平面 <span class="math inline">\(\overline{\mathbb{C}}\)</span>。</li><li>不可约代数簇 （素理想） 在扩张下的三种行为：分解、惯性、分歧。</li><li>随机游动可以分为零常返、正常返、暂态。</li><li>实数域 <span class="math inline">\(\mathbb{R}\)</span>上的有限维结合可除代数只有三种：<span class="math inline">\(\mathbb{R}\)</span>、复数域 <span class="math inline">\(\mathbb{C}\)</span>、四元数 <span class="math inline">\(\mathbb{H}\)</span>。</li></ol><p>本文要介绍的是另外两个三分天下的例子，它们来自群表示论，即有限群的不可约实表示在复数域上的分解，和不可约复表示在实数域上的实现。这两个例子是紧密相关的。</p><span id="more"></span><h1 id="不可约实表示在复数域上的分解">不可约实表示在复数域上的分解</h1><p>在有限群的表示论中，遇到的第一个重要结论大概非 Schur 引理莫属：</p><div id="schur-------" class="statement sta_schur___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Schur引理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(G\)</span> 是一个有限群，<span class="math inline">\(k\)</span> 是一个特征为 0 的域，<span class="math inline">\(V\)</span> 是一个不可约左 <span class="math inline">\(kG\)</span>- 模。则 <span class="math inline">\(D=\mathrm{Hom}_{kG}(V,V)\)</span> 是 <span class="math inline">\(k\)</span> 上的有限维结合可除代数。</p></div><p>我至今还记得，在我还是本科生的时候，读到这个引理，脑中就出现一个念头：当<span class="math inline">\(k=\mathbb{R}\)</span> 是实数域时，<span class="math inline">\(D\)</span> 作为 <span class="math inline">\(\mathbb{R}\)</span>上的有限维结合可除代数只有三种可能：实数域 <span class="math inline">\(\mathbb{R}\)</span>，复数域 <span class="math inline">\(\mathbb{C}\)</span>，四元数体 <span class="math inline">\(\mathbb{H}\)</span>。这三种可能性分别对应 <span class="math inline">\(\mathbb{R}G\)</span>- 模 <span class="math inline">\(V\)</span> 的什么内在属性呢？</p><p>答案出奇地优美：<span class="math inline">\(D\)</span>的类型，恰好决定了当我们把 <span class="math inline">\(V\)</span>看作复表示时，它会如何分解。</p><p>但等等，把 <span class="math inline">\(V\)</span>看作复表示是什么意思来着？</p><p>我们有两种方式来理解复化，一种是直观的矩阵方式，另一种是更抽象但也更强大的张量积方式。</p><p>使用矩阵的语言最为直观。让我们回忆，<span class="math inline">\(V\)</span> 是 <span class="math inline">\(G\)</span> 的实表示，无非就是有一个群同态 <span class="math display">\[G\overset{\rho}{\longrightarrow} {\rmGL}(n,\mathbb{R}),\quad n=\dim V.\]</span>但任何实矩阵也都是复矩阵，对吧？所以 <span class="math inline">\(\rho\)</span> 自然也可以看作是 <span class="math inline">\(G\to {\rm GL}(n,\mathbb{C})\)</span> 的同态。所以<span class="math inline">\(\rho\)</span> 自然也是 <span class="math inline">\(G\)</span> 的复表示。简单粗暴，但有效。</p><p>不过，我更偏爱张量积的语言。它虽然初看之下有些抽象，却能让我们在更高的抽象层次上进行分析。为了把<span class="math inline">\(V\)</span> 看作 <span class="math inline">\(\mathbb{C}G\)</span>-模，我们需要告诉它如何与复数相乘。这就要用到 <a href="https://en.wikipedia.org/wiki/Complexification">复化</a> <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>：我们构造一个新的空间 <span class="math inline">\(V_\mathbb{C}=\mathbb{C}\otimes_\mathbb{R}V\)</span>。<span class="math inline">\(V_\mathbb{C}\)</span>中复数与向量的乘法由如下规则给出： <span class="math display">\[z(c\otimes v)=zc\otimes v,\quadz,c\in\mathbb{C},v\in V.\]</span> <span class="math inline">\(V\)</span>可以等同于 <span class="math inline">\(V_\mathbb{C}\)</span> 的实子空间<span class="math inline">\(1\otimes V\)</span>。在这个等同下，<span class="math inline">\(V\)</span> 的一组 <span class="math inline">\(\mathbb{R}\)</span>- 基也是 <span class="math inline">\(V_\mathbb{C}\)</span> 的一组 <span class="math inline">\(\mathbb{C}\)</span>- 基。任何 <span class="math inline">\(T\in\mathrm{End}_\mathbb{R}(V)\)</span> 通过 <span class="math inline">\(T\to 1\otimes T\)</span> 变成 <span class="math inline">\(V_\mathbb{C}\)</span> 上的 <span class="math inline">\(\mathbb{C}\)</span>- 线性变换。于是我们可以把<span class="math inline">\(G\)</span> 在 <span class="math inline">\(V_\mathbb{C}\)</span> 上的作用定义为 <span class="math inline">\(1\otimes g\)</span> 在 <span class="math inline">\(V_\mathbb{C}\)</span> 上的作用： <span class="math display">\[g(c\otimes v) = c\otimes gv.\]</span> 这个作用是<span class="math inline">\(\mathbb{C}\)</span>- 线性的，在此作用下<span class="math inline">\(V_\mathbb{C}\)</span> 成为一个 <span class="math inline">\(\mathbb{C}G\)</span>- 模。并且在你指定 <span class="math inline">\(V\)</span> 的一组基后，这组基也是 <span class="math inline">\(V_\mathbb{C}\)</span> 的一组基，在这组基下，<span class="math inline">\(1\otimes g\)</span> 在 <span class="math inline">\(V_\mathbb{C}\)</span> 上作用的矩阵与 <span class="math inline">\(g\)</span> 在 <span class="math inline">\(V\)</span> 上作用的矩阵是完全一样的。</p><p>总之，用张量积方式来表述复化与矩阵方式是一致的。</p><p>问题来了：怎么将 <span class="math inline">\(V_\mathbb{C}\)</span>的分解为不可约表示呢？这就要用到群表示论中关于半单代数结构的一个基本结论：</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(W\)</span> 是一个 <span class="math inline">\(\mathbb{C}G\)</span>- 模，<span class="math inline">\(W = n_1W_1\oplus n_2W_2\oplus\cdots\oplusn_rW_r\)</span>，其中 <span class="math inline">\(W_i\)</span>是互不同构的 <span class="math inline">\(\mathbb{C}G\)</span>- 模，<span class="math inline">\(n_i\)</span> 是 <span class="math inline">\(W_i\)</span> 出现在 <span class="math inline">\(W\)</span> 中的重数，则有 <span class="math inline">\(\mathbb{C}\)</span>- 代数同构 <span class="math display">\[\mathrm{End}_{\mathbb{C}G}(W) \cong\mathrm{Mat}_{n_1}(\mathbb{C})\times\mathrm{Mat}_{n_2}(\mathbb{C})\times\cdots\times\mathrm{Mat}_{n_r}(\mathbb{C}).\]</span></p></div><p>这个结论告诉我们，可以通过将 <span class="math inline">\(\mathrm{End}_{\mathbb{C}G}(V_\mathbb{C})\)</span>表示为矩阵代数的直积来获得 <span class="math inline">\(V_\mathbb{C}\)</span> 的分解。然而我们还有自然同构<span class="math display">\[\mathrm{End}_{\mathbb{C}G}(V_\mathbb{C})\cong\mathbb{C}\otimes_{\mathbb{R}}\mathrm{End}_{\mathbb{R}G}(V)=\mathbb{C}\otimes_\mathbb{R}D.\]</span>看！谜底就在眼前！我们只需要研究 <span class="math inline">\(\mathbb{C}\otimes_{\mathbb{R}}D\)</span>是如何分解为 <span class="math inline">\(\mathbb{C}\)</span>上的矩阵代数的直积的。</p><p>我们来论证 <span class="math inline">\(V_\mathbb{C}\)</span>的分解具有如下的「三分性质」：</p><ol type="1"><li><span class="math inline">\(D=\mathbb{R}\)</span>：由 <span class="math inline">\(\mathbb{R}\otimes_\mathbb{R}\mathbb{C}\cong\mathbb{C}\)</span>，因此<span class="math inline">\(V_\mathbb{C}\)</span> 仍然是不可约的。</li><li><span class="math inline">\(D=\mathbb{C}\)</span>：根据 <span class="math inline">\(\mathbb{C}\)</span>- 代数同构 <span class="math inline">\(\mathbb{C}\otimes_\mathbb{R}\mathbb{C}\cong\mathbb{C}\times\mathbb{C}\)</span><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>，因此 <span class="math inline">\(V_\mathbb{C}\)</span> 的分解为 <span class="math inline">\(V_\mathbb{C}=V_1\oplus V_2\)</span>，即 <span class="math inline">\(V_\mathbb{C}\)</span>是两个不同构的复表示的直和。注意 <span class="math inline">\(V_\mathbb{C}\)</span> 的特征与 <span class="math inline">\(V\)</span> 相同，是个实特征，所以 <span class="math inline">\(V_1\)</span> 和 <span class="math inline">\(V_2\)</span> 是共轭的，即 <span class="math inline">\(V_2=V_1^\ast\)</span>。</li><li><span class="math inline">\(D=\mathbb{H}\)</span>：根据 <span class="math inline">\(\mathbb{C}\)</span>- 代数同构 <span class="math inline">\(\mathbb{H}\otimes_\mathbb{R}\mathbb{C}\cong\mathrm{Mat}_2(\mathbb{C})\)</span><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>，因此 <span class="math inline">\(V_\mathbb{C}\)</span> 的分解为 <span class="math inline">\(V_\mathbb{C}=2V_1\)</span>，即 <span class="math inline">\(V_\mathbb{C}\)</span>是某个不可约模的二重和。</li></ol><p>多么漂亮的结果！一个不可约实表示的命运，在它进入复数世界的那一刻，就由它自身的“代数基因”(<span class="math inline">\(\mathbb{R},\mathbb{C},\mathbb{H}\)</span>)决定了！</p><h1 id="不可约复表示在实数域上的实现">不可约复表示在实数域上的实现</h1><p>好了，我们刚刚从实数出发，航行到了复数的世界。现在，让我们掉转船头：一个不可约的复表示，什么时候能够“回到”实数域呢？换句话说：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>给定一个不可约复表示 <span class="math inline">\(V\)</span>，我们想知道这个表示是否能在实数域上实现？即是否存在一个实表示<span class="math inline">\(W\)</span>，使得 <span class="math inline">\(W\)</span> 的复化正是 <span class="math inline">\(V\)</span>？</p></div><p>显然 <span class="math inline">\(V\)</span>可以在实数域上可以实现的一个必要条件是其特征 <span class="math inline">\(\chi\)</span> 是实的，即对任何 <span class="math inline">\(g\in G\)</span>，<span class="math inline">\(\chi(g)\)</span>都是实数，但这个条件是否也是充分的呢？</p><p>唉，答案是否定的。要是数学总是这么简单就好了。</p><div id="------" class="statement sta___ definition unnumbered"><p><span class="statement-heading"><span class="statement-label">反例</span>：</span><span class="statement-spah"> </span>四元数群 <span class="math inline">\(Q_8=\{\bf \pm1, \pm i,\pm j, \pm k\}\)</span>只有一个次数大于 1 的不可约复表示，其次数为 2，但是它没有次数为 2的不可约实表示，所以这个复表示不能在实数域上实现。</p><p>具体讲，<span class="math inline">\(Q_8\)</span>有四个不可约一维复表示，这四个复表示同时也是实表示。此外 <span class="math inline">\(Q_8\)</span> 在四元数体 <span class="math inline">\(\mathbb{H}\)</span> 上的左乘给出其一个不可约 4维实表示（除环作为自己的左正则模必然是不可约的），因此我们有群代数分解<span class="math display">\[\mathbb{R}Q_8 \cong4\mathbb{R}\oplus\mathbb{H}.\]</span> 另一方面 <span class="math inline">\(Q_8\)</span> 有一个不可约的二维复表示，这个表示由Pauli 矩阵给出： <span class="math display">\[{\bfi}\to\begin{pmatrix}0&amp;i\\i&amp;0\end{pmatrix},\quad {\bfj}\to\begin{pmatrix}0&amp;-1\\1&amp;0\end{pmatrix},\quad {\bfk}\to\begin{pmatrix}i&amp;0\\0&amp;-i\end{pmatrix}.\]</span>这三个矩阵和恒等矩阵一起构成 <span class="math inline">\(\mathrm{Mat}_2(\mathbb{C})\)</span>的一组基，因此有群代数分解 <span class="math display">\[\mathbb{C}Q_8\cong4\mathbb{C}\oplus\mathrm{Mat}_2(\mathbb{C}).\]</span>由于 <span class="math inline">\(Q_8\)</span>没有二维不可约实表示，因此这个二维不可约复表示不能在实数域上实现。</p></div><p>要使得一个不可约复表示可以在实数域上实现，它应该满足怎样的条件？</p><p>这里真正的秘密在于一种叫做 <a href="https://en.wikipedia.org/wiki/Complex_conjugate">复共轭</a>的东西。一个复表示 <span class="math inline">\(V\)</span>能“回到”实数世界，当且仅当在 <span class="math inline">\(V\)</span>上存在一个 <a href="https://en.wikipedia.org/wiki/Antilinear_map">共轭线性</a> 的变换<span class="math inline">\(J\colon\ V\toV\)</span>，它满足两个条件：</p><ol type="1"><li><span class="math inline">\(J\)</span> 与 <span class="math inline">\(G\)</span> 的作用交换：对任何 <span class="math inline">\(g\in G\)</span> 有 <span class="math inline">\(gJ=Jg\)</span>。</li><li><span class="math inline">\(J^2=1\)</span>。</li></ol><p>为什么呢？因为 <span class="math inline">\(J\)</span> 是复共轭（<span class="math inline">\(J\)</span> 共轭线性且 <span class="math inline">\(J^2=1\)</span>）可以保证存在 <span class="math inline">\(V\)</span> 的实子空间 <span class="math inline">\(W\)</span> 使得 <span class="math inline">\(V\cong\mathbb{C}\otimes_\mathbb{R}W\)</span>。<span class="math inline">\(J\)</span> 与 <span class="math inline">\(G\)</span> 交换则保证了 <span class="math inline">\(W\)</span> 是 <span class="math inline">\(G\)</span> 的 <span class="math inline">\(\mathbb{R}\)</span>- 不变子空间，并且 <span class="math inline">\(G\)</span> 在 <span class="math inline">\(V\)</span> 上的作用都形如 <span class="math inline">\(1\otimes g\)</span>。即 <span class="math inline">\(\mathbb{C}G\)</span>- 模 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(\mathbb{R}G\)</span>- 模 <span class="math inline">\(W\)</span> 的复化。取 <span class="math inline">\(W\)</span> 的一组 <span class="math inline">\(\mathbb{R}\)</span>- 基，这组基也是 <span class="math inline">\(V\)</span> 的一组 <span class="math inline">\(\mathbb{C}\)</span>- 基，在这组基下 <span class="math inline">\(\mathbb{R}G\)</span>- 模 <span class="math inline">\(W\)</span> 与 <span class="math inline">\(\mathbb{C}G\)</span>- 模 <span class="math inline">\(V\)</span> 有同样的矩阵，从而复表示 <span class="math inline">\(V\)</span> 可以在实表示 <span class="math inline">\(W\)</span> 上“实现”。</p><p>我们会看到，存在三种互斥的情形：</p><ol type="1"><li>不存在与 <span class="math inline">\(G\)</span> 交换的共轭线性变换<span class="math inline">\(J\)</span>；</li><li>或者如果存在的话，这样的 <span class="math inline">\(J\)</span>在只差一个常数的意义下是唯一确定的，在适当缩放以后有两种可能：<span class="math inline">\(J^2=\pm1\)</span>。</li></ol><p>1 和 2 互斥是显然的，但是 2中的两种情形为什么互斥就不那么显然了。注意不要错误地认为 <span class="math inline">\(J^2= 1\)</span> 的话会有 <span class="math inline">\((iJ)^2=-1\)</span>。因为 <span class="math inline">\(J\)</span> 是共轭线性的，<span class="math inline">\(iJ=J\overline{i}\)</span>，所以 <span class="math inline">\((iJ)^2=J^2\)</span>。</p><p>记 <span class="math inline">\(V^\ast\)</span> 为 <span class="math inline">\(V\)</span> 的对偶表示。<span class="math inline">\(V^\ast\)</span> 的特征是 <span class="math inline">\(\overline{\chi}\)</span>。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.1</span>.</span></p><ol type="1"><li>如果 <span class="math inline">\(V\ncong V^\ast\)</span>，就称 <span class="math inline">\(V\)</span> 是复的 (complex type)；</li><li>如果 <span class="math inline">\(V\cong V^\ast\)</span> 且 <span class="math inline">\(V\)</span> 是某个不可约 <span class="math inline">\(\mathbb{R}G\)</span>- 模 <span class="math inline">\(W\)</span> 的复化：<span class="math inline">\(V\cong \mathbb{C}\otimes_{\mathbb{R}}W\)</span>，就称 <span class="math inline">\(V\)</span> 是实的 (realtype)；</li><li>如果 <span class="math inline">\(V\cong V^\ast\)</span> 且 <span class="math inline">\(V\)</span> 是某个不可约 <span class="math inline">\(\mathbb{H}G\)</span>- 模在复数域上的限制，就称<span class="math inline">\(V\)</span> 是四元数的 (quaterniontype)。</li></ol></div><p>这三种情况，完美地对应了又一个「三分天下」：</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(V\)</span>必然恰好属于复、实、四元数三种类型之一，即这三种类型是互斥的。</p></div><p>复类型显然与另外两种类型是互斥的。所以我们只需要在 <span class="math inline">\(V\cong V^\ast\)</span>的前提下区分实与四元数类型。</p><p>根据 Schur 引理，<span class="math inline">\(\mathrm{Hom}_G(V,V^\ast)\cong\mathbb{C}\)</span>是一维的。根据自然的 <span class="math inline">\(G\)</span>- 模同构<span class="math display">\[\mathrm{Hom}_G(V,V^\ast)\cong\mathrm{Bil}(V) \cong V^\ast\otimes V^\ast.\]</span> 于是 <span class="math inline">\(V^\ast\otimes V^\ast\)</span> 作为 <span class="math inline">\(\mathbb{C}G\)</span>- 模也是一维的。然而我们知道<span class="math inline">\(V^\ast\otimes V^\ast\)</span>总是可以分解为两个 <span class="math inline">\(G\)</span>-不变子空间的直和，即对称和反对称的双线性形式： <span class="math display">\[V^\ast\otimesV^\ast=S^2V^\ast\oplus\Lambda^2V^\ast.\]</span> 所以 <span class="math inline">\(V\)</span> 上的任何 <span class="math inline">\(G\)</span>- 不变双线性型 <span class="math inline">\(B\)</span> 必然要么对称： <span class="math display">\[B(v,w)=B(w,v).\]</span> 要么反对称： <span class="math display">\[B(v,w)=-B(w,v).\]</span> 取 <span class="math inline">\(\langle\,,\,\rangle\)</span> 为 <span class="math inline">\(V\)</span> 上的任一 <span class="math inline">\(G\)</span>- 不变的正定 Hermite内积（你知道这是存在的）。<span class="math inline">\(\langle\,,\,\rangle\)</span>关于第一个分量是共轭线性的，关于第二个是线性的。由于 <span class="math inline">\(\langle\,,\,\rangle\)</span> 非退化，<span class="math inline">\(V\)</span> 上的任何 <span class="math inline">\(\mathbb{C}\)</span>- 线性泛函 <span class="math inline">\(f\)</span> 都形如 <span class="math inline">\(f=\langle z,\,\cdot\rangle\)</span>。这里 <span class="math inline">\(z\)</span> 由 <span class="math inline">\(f\)</span> 唯一决定。</p><p>固定 <span class="math inline">\(v\in V\)</span>，对线性泛函 <span class="math inline">\(w\mapsto B(v,w)\)</span>，存在 <span class="math inline">\(z\in V\)</span> 使得 <span class="math display">\[\langle z,\, w\rangle = B(v,w).\]</span> 这里<span class="math inline">\(z\)</span> 由 <span class="math inline">\(v\)</span> 唯一确定。我们记这个从 <span class="math inline">\(v\)</span> 到 <span class="math inline">\(z\)</span> 的映射为 <span class="math inline">\(J\colon\ v\mapsto z\)</span>。从而 <span class="math display">\[B(v, w) = \langle Jv, w\rangle.\]</span> 由于<span class="math inline">\(B\)</span> 和 <span class="math inline">\(\langle\,,\,\rangle\)</span> 都是 <span class="math inline">\(G\)</span>- 不变的，因此 <span class="math inline">\(J\)</span> 必然与 <span class="math inline">\(G\)</span> 的作用交换 <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>。</p><p>由于 <span class="math inline">\(B\)</span>关于第一个分量是线性的，但是 <span class="math inline">\(\langle\,,\,\rangle\)</span>关于第一个分量是共轭线性的，所以 <span class="math inline">\(J\)</span>也是共轭线性的，即对任何 <span class="math inline">\(c\in\mathbb{C}\)</span> 有 <span class="math display">\[J(cv) = \overline{c}z.\]</span> 由于 <span class="math inline">\(J^2\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span>- 线性的且与 <span class="math inline">\(G\)</span> 交换，由 Schur 引理存在 <span class="math inline">\(c\ne0\in\mathbb{C}\)</span> 使得 <span class="math inline">\(J^2=cI\)</span>。我们来说明必有 <span class="math inline">\(c&gt;0\)</span> 或者 <span class="math inline">\(c&lt;0\)</span>。这两种情形分别取决于 <span class="math inline">\(B\)</span> 是对称的或者反对称的。</p><ol type="1"><li><p>如果 <span class="math inline">\(B\)</span> 是对称的，则 <span class="math display">\[\langle Jv, w\rangle= \langle Jw,v\rangle.\]</span> 取 <span class="math inline">\(v=Jw\)</span>带入上式得到 <span class="math display">\[\langle J^2w, w\rangle=\langleJw, Jw\rangle\geq0.\]</span> 由于 <span class="math inline">\(J^2=cI\)</span>，所以必然有 <span class="math inline">\(c&gt;0\)</span>。</p></li><li><p>类似地当 <span class="math inline">\(B\)</span> 反对称时可得<span class="math inline">\(c&lt;0\)</span>。</p></li></ol><p>于是通过给 <span class="math inline">\(J\)</span> 除以 <span class="math inline">\(\sqrt{|c|}\)</span>，我们就得到了一个新的共轭线性变换，把它仍然记作<span class="math inline">\(J\)</span>，则 <span class="math inline">\(J\)</span> 满足 <span class="math inline">\(J^2=\pm1\)</span>。我们来说明这两种情形分别对应<span class="math inline">\(V\)</span> 是实类型或者四元数类型。</p><ol type="1"><li>如果 <span class="math inline">\(J^2=1\)</span>，由于 <span class="math inline">\(J\)</span> 是共轭线性的，<span class="math inline">\(J\)</span> 是 <span class="math inline">\(V\)</span> 上的复共轭。令 <span class="math display">\[W=\{w\in V\mid J(w)=w\}\]</span> 是 <span class="math inline">\(J\)</span> 的不动点，则 <span class="math inline">\(W\)</span> 是实子空间且 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(W\)</span> 的复化：<span class="math inline">\(V\cong\mathbb{C}\otimes_{\mathbb{R}}W\)</span>。由于 <span class="math inline">\(G\)</span> 的作用与 <span class="math inline">\(J\)</span> 交换，所以 <span class="math inline">\(G\)</span> 在 <span class="math inline">\(V\)</span> 上的作用 <span class="math inline">\(\rho(g)\)</span> 都形如 <span class="math inline">\(\rho(g)=1\otimes\rho_W(g)\)</span>，其中 <span class="math inline">\(\rho_W(g)\)</span> 是 <span class="math inline">\(W\)</span> 上的 <span class="math inline">\(\mathbb{R}\)</span>- 线性变换。即表示 <span class="math inline">\(\rho\)</span> 是表示 <span class="math inline">\(\rho_W\)</span> 的复化。所以 <span class="math inline">\(V\)</span> 是实的。</li><li>如果 <span class="math inline">\(J^2=-1\)</span>，那么 <span class="math inline">\(1,\, I=i,\,J,\, K=IJ\)</span>满足通常的四元数乘法，它们都和 <span class="math inline">\(G\)</span>的作用交换，所以 <span class="math inline">\(V\)</span> 可以变成一个左<span class="math inline">\(\mathbb{H}G\)</span>-模，将此模限制在复数域上即为表示 <span class="math inline">\(V\)</span>，从而表示 <span class="math inline">\(V\)</span> 是四元数的。</li></ol><p>实类型和四元数类型是互斥的，否则 <span class="math inline">\(V\)</span>上将同时存在一个对称双线性型和一个反对称双线性型，与 <span class="math inline">\(\dim_\mathbb{C}(V^\ast\otimes V^\ast)=1\)</span>矛盾。</p><p>总之我们证明了表示 <span class="math inline">\(V\)</span>必然恰好属于实、复、四元数三种类型之一，其中只有实类型可以在实数域上实现。而且由上面的分析不难得出下面的推论：</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.3</span>.</span></p><ol type="1"><li><span class="math inline">\(V\)</span> 是复的当且仅当 <span class="math inline">\(V\)</span> 上不存在任何非零的 <span class="math inline">\(G\)</span>- 不变双线性型。</li><li><span class="math inline">\(V\)</span> 是实的当且仅当 <span class="math inline">\(V\)</span> 上存在一个非零的 <span class="math inline">\(G\)</span>- 不变对称双线性型。</li><li><span class="math inline">\(V\)</span> 是四元数的当且仅当 <span class="math inline">\(V\)</span> 上存在一个非零的 <span class="math inline">\(G\)</span>- 不变反对称双线性型。</li></ol></div><p>这三种情形分别对应 <span class="math inline">\(\dim_{\mathbb{C}}(S^2V^\ast)-\dim_{\mathbb{C}}(\Lambda^2V^\ast)\)</span>的值是 0, +1 和 -1。通过一些简单的计算不难得到 <span class="math display">\[\dim_{\mathbb{C}}(S^2V^\ast)-\dim_{\mathbb{C}}(\Lambda^2V^\ast)=\frac{1}{|G|}\sum_{g\inG}\chi(g^2).\]</span></p><p><span class="math inline">\(F(\chi)=\dfrac{1}{|G|}\sum\limits_{g\inG}\chi(g^2)\)</span> 叫做 <span class="math inline">\(\chi\)</span> 的Frobenius-Schur 指标，于是我们有</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.4</span>.</span><span class="statement-spah"> </span>（Frobenius-Schur指标）</p><ol type="1"><li><span class="math inline">\(V\)</span> 是复的当且仅当 <span class="math inline">\(F(\chi)=0\)</span>。</li><li><span class="math inline">\(V\)</span> 是实的当且仅当 <span class="math inline">\(F(\chi)=1\)</span>。</li><li><span class="math inline">\(V\)</span> 是四元数的当且仅当 <span class="math inline">\(F(\chi)=-1\)</span>。</li></ol></div><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>如果你对复化不够熟悉的话，可以参考我的一篇 <a href="/real-complex">旧文</a>。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>一个同构由 <span class="math inline">\(z_1\otimes z_2\to(z_1z_2, z_1\overline{z}_2)\)</span> 给出。首先此映射是一个 <span class="math inline">\(\mathbb{C}\)</span>- 代数同态。此同态是满射，因为<span class="math inline">\(\frac{1}{2}(1\otimes1+ i\otimes i)\)</span>被映射为 <span class="math inline">\((1,0)\)</span>，<span class="math inline">\(\frac{1}{2}(1\otimes1 - i\otimes i)\)</span>被映射为 <span class="math inline">\((0, 1)\)</span>。此外由于两边作为<span class="math inline">\(\mathbb{C}\)</span>- 代数的维数相同，都是2，所以是一个同构。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p>有个一般性的结论：设 <span class="math inline">\(D\)</span> 是域 <span class="math inline">\(F\)</span> 上的有限维可除代数且 <span class="math inline">\(D\)</span> 的中心为 <span class="math inline">\(F\)</span>，<span class="math inline">\(K\)</span>是 <span class="math inline">\(D\)</span> 的极大子域，<span class="math inline">\(n=[D:K]\)</span>。则有 <span class="math inline">\(K\)</span>- 代数同构 <span class="math inline">\(K\otimes_FD\cong\mathrm{Mat}_n(K)\)</span>。将此结论应用于 <span class="math inline">\(D=\mathbb{H}\)</span>，<span class="math inline">\(F=\mathbb{R}\)</span>，<span class="math inline">\(K=\mathbb{C}\)</span> 即可。</p><p>不过针对四元数 <span class="math inline">\(\mathbb{H}\)</span>我们可以给一个直接的证明：把 <span class="math inline">\(\mathbb{H}\)</span> 看作 <span class="math inline">\(\mathbb{C}\)</span>上的<strong>二维右向量空间</strong>（即 <span class="math inline">\(\mathbb{C}\)</span> 的数乘写在右边），则 <span class="math inline">\(\mathbb{H}=1\mathbb{C}\oplusj\mathbb{C}\)</span>。任何 <span class="math inline">\(a\in\mathbb{H}\)</span> 在自身上的左乘给出了一个<span class="math inline">\(\mathbb{C}\)</span>- 线性变换：<span class="math display">\[a(xc) = (ax)c\quada,x\in\mathbb{H},\,c\in\mathbb{C}.\]</span> 这是因为 <span class="math inline">\(\mathbb{H}\)</span> 是结合的，所以 <span class="math inline">\(a\)</span> 在 <span class="math inline">\(\mathbb{H}\)</span> 上的左乘与 <span class="math inline">\(\mathbb{C}\)</span> 在 <span class="math inline">\(\mathbb{H}\)</span> 上的右乘交换。于是这给出了一个<span class="math inline">\(\mathbb{H}\to\mathrm{Mat}_2(\mathbb{C})\)</span>的嵌入。</p><p>设 <span class="math inline">\(a=z+jw\in\mathbb{H}\)</span>，我们来计算 <span class="math inline">\(a\)</span> 的左乘在 <span class="math inline">\(\{1,j\}\)</span> 这组基下的矩阵： <span class="math display">\[\begin{aligned}(z+jw)\cdot 1 &amp;= z+jw,\\(z+jw)\cdot j&amp;= zj+jwj=-\overline{w}+j\overline{z}.\end{aligned}\]</span> 所以 <span class="math inline">\(z+jw\)</span> 在 <span class="math inline">\(\mathrm{Mat}_2(\mathbb{C})\)</span> 中对应的矩阵为<span class="math inline">\(\begin{pmatrix}z&amp;-\overline{w} \\ w&amp; \overline{z}\end{pmatrix}\)</span>。由于 <span class="math inline">\(\mathbb{H}\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span> 上的二维右向量空间，所以它嵌入<span class="math inline">\(\mathrm{Mat}_2(\mathbb{C})\)</span>以后的像也是二维的，并不构成整个 <span class="math inline">\(\mathrm{Mat}_2(\mathbb{C})\)</span>。</p><p>但是对 <span class="math inline">\(D=\mathbb{H}\otimes_\mathbb{R}\mathbb{C}\)</span>，事情就不一样了：<span class="math inline">\(D\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span> 上的 4维右向量空间，并且它也作用在二维的右 <span class="math inline">\(\mathbb{C}\)</span>- 向量空间 <span class="math inline">\(\mathbb{H}\)</span> 上：对任何 <span class="math inline">\(a,x\in\mathbb{H}\)</span> 和 <span class="math inline">\(c\in\mathbb{C}\)</span> 我们定义 <span class="math inline">\(a\otimes c\)</span> 在 <span class="math inline">\(\mathbb{H}\)</span> 上的作用为 <span class="math display">\[(a\otimes c)x=axc,\quada,x\in\mathbb{H},c\in\mathbb{C}.\]</span> 这个作用是右 <span class="math inline">\(\mathbb{C}\)</span>- 线性的，从而给出了 <span class="math inline">\(D\)</span> 到 <span class="math inline">\(\mathrm{Mat}_2(\mathbb{C})\)</span>的同态。你可以用 <span class="math inline">\(D\)</span>是单代数来说明这是一个单射，然后再比较维数来说明它是同构，但这需要一些关于中心单代数的知识；也可以换一种方法来验证：<span class="math inline">\(D\)</span> 在 <span class="math inline">\(\mathbb{H}\)</span> 上的作用，相比前面 <span class="math inline">\(\mathbb{H}\)</span> 在自身上的左乘，还额外包含了<span class="math inline">\(i\)</span> 的右乘。这个右乘在 <span class="math inline">\(\{1,j\}\)</span> 这组基下的矩阵是对角矩阵 <span class="math inline">\(\begin{pmatrix}i&amp;\\ &amp;i\end{pmatrix}\)</span>。所以 <span class="math inline">\(D\)</span> 在<span class="math inline">\(\mathbb{H}\)</span>上的作用包含了所有如下形式的矩阵： <span class="math display">\[\begin{pmatrix}z&amp;-\overline{w} \\ w &amp;\overline{z}\end{pmatrix}\quad\text{and}\quad\begin{pmatrix}z&amp;-\overline{w}\\ w &amp; \overline{z}\end{pmatrix}\cdot\begin{pmatrix}i&amp;\\ &amp;i\end{pmatrix}.\]</span> 不难验证这两种矩阵的线性组合生成了整个 <span class="math inline">\(\mathrm{Mat}_2(\mathbb{C})\)</span>，从而这是一个<span class="math inline">\(D\to\mathrm{Mat}_2(\mathbb{C})\)</span>的满同态，再比较维数即可。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>对任何 <span class="math inline">\(g\inG\)</span>，我们有 <span class="math display">\[\langle Jv,w\rangle=B(v,w)=B(gv,gw)=  \langle Jgv, gw\rangle =  \langle g^{-1}Jgv,w\rangle.\]</span> 即 <span class="math inline">\(g^{-1}Jg =J\)</span>，从而 <span class="math inline">\(J\)</span> 与 <span class="math inline">\(G\)</span> 的作用交换。<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 有限群表示与结合代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>相亲问题与倒向归纳法</title>
      <link href="/optimal-stopping-and-backward-induction/"/>
      <url>/optimal-stopping-and-backward-induction/</url>
      
        <content type="html"><![CDATA[<div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"></span>假设你是一位大龄单身男士，年纪不小，但仍心怀浪漫。你准备参加 100场相亲 （别介意具体数字）。你打算依次与每个女士 <span class="math inline">\(i\)</span> 约会，然后根据印象给她打一个分数 <span class="math inline">\(X_i\)</span>，<span class="math inline">\(X_i\)</span> 的值介于 <span class="math inline">\([0,1]\)</span> 之间。如果你对女士 <span class="math inline">\(i\)</span>很满意，那么就和她结婚，否则就放弃她，参加下一场相亲，当然拒绝了人家可就没有回头的机会了。如果你拒绝了前99 位女士，那么不论第 100次相亲结果如何你都只能和最后这位女士结婚。在相亲之前，你对这些女士的情况一无所知，所以姑且假定她们的分数<span class="math inline">\(X_i\)</span> 都是 <span class="math inline">\([0,1]\)</span>上均匀分布的独立的随机变量。问题是：应该采取怎样的相亲策略，才能娶到你最中意的女士？</p></div><span id="more"></span><p>再费点笔墨解释下。每次相亲结束以后，你都面临一个选择：要么和当前的女士结婚，要么继续见下一位女士，这依赖于你之前相亲的结果：如果你挑挑拣拣到了90号女士还拿不定主意，最后发现「糟了，我快要变剩男了！」，那很可能接下来你就会放低择偶标准，遇到一个还凑合的就赶紧结婚了，哪怕她可能比你之前拒绝的许多女士分数还低。当然也不排除你对第一位女士就一见钟情的可能，因此你最终选择的女士的编号<span class="math inline">\(\tau\)</span>是一个随机变量，你要做的就是让你的未来太太的期望分数 <span class="math inline">\(\mathbb{E}X_\tau\)</span> 尽可能的高。</p><p>那么应该采取怎样的策略为好呢？就像买东西讨价还价时总有一个心理价位一样，似乎可以先设定一个心理的期望值，如果遇到的女士的分数大于等于这个值，那就和她结婚；否则就继续下一位女士。这个思路很合理，但是问题是，期望值应该设定为多少呢？</p><p>在概率论里面我们学过如下关于顺序统计量的经典结论：设 <span class="math inline">\(X_1,\cdots,X_N\)</span> 是 <span class="math inline">\([0,1]\)</span> 上独立同分布的均匀随机变量，则<span class="math inline">\(Y=\max_{1\leq i\leq N}X_i\)</span> 的期望是<span class="math inline">\(\frac{N}{N+1}\)</span>。所以如果你把 100次相亲全部进行完，得分最高的女士的期望值理论上应该是 <span class="math inline">\(\frac{100}{101}\)</span>，于是你应该把心理门槛设置在<span class="math inline">\(\frac{100}{101}\)</span>，是这样吗？</p><p>答案是NO！首先门槛值应该是一个随着相亲的进行而逐渐降低的数列，这才符合实际的情形：如果前面太挑剔，为了不当剩男你后面的标准就会放低。其次我们会用倒向归纳法计算出，最优策略下初始的门槛值并不是最中意的女士的期望值<span class="math inline">\(\frac{100}{101}\)</span>，实际上它更接近于得分第二高的女士的期望值<span class="math inline">\(\frac{99}{101}\)</span>。正如梅艳芳在《似是故人来》中唱的那样：「但凡未得到，但凡是过去，总是最登对」— 最好的那个永远是你得不到的那个。</p><h1 id="倒向归纳法">倒向归纳法</h1><p>相亲问题是应用倒向归纳法的一个典型例子。</p><p>我们从最后的情形开始分析，假设只剩一位女士可选，那么你只能去和她结婚，而她的期望值是1/2，我们记作 <span class="math inline">\(a_1=1/2\)</span>。</p><p>假设还剩两位女士可选呢？这种情况下应该先和其中一个相亲，如果她的分数大于等于1/2，那就应该和她结婚 （后者的期望只有 1/2，很可能不如她），而小于 1/2的话则去和第二位女士相亲 （后者的期望是1/2，所以我没道理现在娶一个分数小于 1/2 的）。而第一位女士分数大于等于1/2 的概率是 1/2，在大于等于 1/2 的条件下她的分数服从 <span class="math inline">\([1/2,1]\)</span> 上的均匀分布，期望值是3/4；第二位女士的期望分数就是 1/2。所以你以 1/2 的概率娶到一个期望值为3/4 的女士，以 1/2 的概率娶到一个期望值为 1/2的女士。因此有两位女士可选时这个策略的期望分数为 <span class="math display">\[a_2=\frac{1}{2}\cdot\frac{3}{4}+\frac{1}{2}\cdot\frac{1}{2}=\frac{5}{8}.\]</span></p><p>一般地，假设还剩下 <span class="math inline">\(i\)</span>位女士的时候你的心理期望值是 <span class="math inline">\(a_i\)</span>，我们来推导 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{i+1}\)</span>之间的递推关系：首先和其中一位女士相亲，如果她的分数大于等于 <span class="math inline">\(a_i\)</span> 那么就和她结婚，否则就拒绝她（因为后面 <span class="math inline">\(i\)</span> 个人的心理期望是 <span class="math inline">\(a_i\)</span>，我没道理现在娶一个分数小于 <span class="math inline">\(a_i\)</span> 的）。前一种情形的期望是 <span class="math inline">\(\frac{1+a_i}{2}\)</span> 但是发生的概率是 <span class="math inline">\(1-a_i\)</span>，后一种情形的期望是 <span class="math inline">\(a_i\)</span> 发生的概率也是 <span class="math inline">\(a_i\)</span>，因此 <span class="math display">\[a_{i+1}=(1-a_i)\left(\frac{1+a_i}{2}\right)+a_i\cdota_i=\frac{1+a_i^2}{2}.\]</span> 结合初值 <span class="math inline">\(a_1=\frac{1}{2}\)</span>就可以算出整个序列来，因此我们的相亲策略应该是：</p><div class="statement simple plain unnumbered"><p>假设当前还剩 <span class="math inline">\(i\)</span>位女士。就把心里期望设定在 <span class="math inline">\(a_i\)</span>，然后进行一次相亲。如果相亲结果大于等于<span class="math inline">\(a_i\)</span>，那就和这位女士结婚；否则就把心里期望降低为<span class="math inline">\(a_{i-1}\)</span>，然后继续去见下一位女士。这里序列<span class="math inline">\(\{a_i\}\)</span> 由 <span class="math inline">\(a_1=1/2\)</span>，<span class="math inline">\(a_{i+1}=\frac{1+a_i^2}{2}\)</span> 给出。</p></div><p>在这个策略下，你最终娶到的女士得分期望是 <span class="math inline">\(a_{100}\)</span>。</p><p>序列 <span class="math inline">\((a_n)_{n\geq1}\)</span> 是所谓的QuadraticMap，它的通项公式是求不出来的，只能用计算机来算。不过可以用归纳法证明<span class="math inline">\(\frac{N-1}{N+1}&lt;a_{N}&lt;\frac{N-0.5}{N+1}\)</span>，即<span class="math inline">\(a_N\)</span> 的值更接近于次优女士的期望值<span class="math inline">\(\frac{N-1}{N+1}\)</span>。当 <span class="math inline">\(N=100\)</span> 时，<span class="math inline">\(a_{100}\approx0.981\)</span>，<span class="math inline">\(\frac{N-1}{N+1}\approx 0.98\)</span> 而 <span class="math inline">\(\frac{N}{N+1}=100/101\approx 0.99\)</span>，可见<span class="math inline">\(a_{100}\)</span> 与 <span class="math inline">\(\frac{N-1}{N+1}\)</span>更接近。这印证了之前说过的：和你结婚的往往不是你最中意的那个。</p><p>请注意，虽然我们已经设计出了一个不错的策略，但这个策略到底是不是最优的呢？我们还没有严格证明。而且就算这个策略是最优的，是否只有这一种最优策略呢？没准还有其它最优策略能让你更省时省心地娶到好太太呢！要严格的解释这些，就要用到鞅的理论。</p><h1 id="翻译为鞅的语言">翻译为鞅的语言</h1><p>用鞅的语言重新表述上面的问题，会给人一种画风突变的感觉，看起来非常晦涩，不像是在说人话：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>设 <span class="math inline">\(N\)</span>是一个给定的正整数，<span class="math inline">\(\{\mathcal{F}_n\}_{n=0}^N\)</span>是某概率空间上的递增的 <span class="math inline">\(\sigma\)</span>-域流，<span class="math inline">\(\{X_n\}_{n=0}^N\)</span>是一列可积的随机变量且 <span class="math inline">\(X_k\in\mathcal{F}_k\)</span>。设 <span class="math inline">\(\mathcal{M}\)</span> 是所有满足 <span class="math inline">\(0\leq\tau\leq N\)</span> 的停时 <span class="math inline">\(\tau\)</span> 组成的集合。我们想求出值函数 <span class="math display">\[V= \sup_{\tau\in\mathcal{M}}\mathbb{E}X_\tau\]</span> 以及使得这个最大值取到的停时 <span class="math inline">\(\tau\)</span>。</p></div><p>这里下标改成了 从 0 开始，以符合大多数文献的习惯。<span class="math inline">\(X_0=0\)</span>，<span class="math inline">\(\mathcal{F}_0=\{\emptyset,\Omega\}\)</span>是平凡的，表示在 0 时刻，即相亲开始之前，你对未来太太“一无所知”。<span class="math inline">\(\mathcal{F}_n=\sigma(X_0,\ldots,X_n)\)</span> 是前<span class="math inline">\(n\)</span> 位女士得分生成的 <span class="math inline">\(\sigma\)</span>- 域，它包含了所有前 <span class="math inline">\(n\)</span>次相亲后可能知道的信息。你的一个相亲策略对应一个停时 <span class="math inline">\(\tau\)</span>，你所有可能的策略由集合 <span class="math inline">\(\mathcal{M}\)</span> 描述。</p><p>定义 <span class="math inline">\(\{X_n\}\)</span> 的 <strong>Snell包络</strong>为 <span class="math display">\[S_n=\begin{cases}X_N&amp;n=N,\\\max\{X_n,\,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}&amp;n=N-1,\ldots,0.\end{cases}\]</span> 这里的 <span class="math inline">\(S_n\)</span> 是从 <span class="math inline">\(N\)</span> 开始倒向递归定义的。注意 <span class="math inline">\(S_n\)</span> 关于 <span class="math inline">\(\mathcal{F}_n\)</span> 可测。</p><p><span class="math inline">\(S_n\)</span> 的直观意义是：在时刻 <span class="math inline">\(n\)</span>，比较当前女士的分数 <span class="math inline">\(X_n\)</span>，和 <span class="math inline">\(n+1\)</span> 时刻对后面所有女士的最佳得分估计<span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>，二者取最大值<span class="math inline">\(\max\{X_n,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}\)</span>即为 <span class="math inline">\(n\)</span>时刻对未来太太最佳分数的估计。注意这里 <span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>要取条件期望，因为一般情况下 <span class="math inline">\(\{X_n\}\)</span>之间不是独立的，从而对未来最佳收益的估计依赖于历史信息。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>在相亲问题中，<span class="math inline">\(\{X_n\}\)</span>是独立的随机变量序列，于是 <span class="math inline">\(S_{n+1}\)</span>与 <span class="math inline">\(\mathcal{F}_n\)</span> 独立（你可以倒着从<span class="math inline">\(S_N\)</span> 开始验证 <span class="math inline">\(S_{n+1}\)</span> 完全由 <span class="math inline">\(X_{n+1},\ldots,X_N\)</span> 决定），从而 <span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]=\mathbb{E}S_{n+1}\)</span>，所以</p><p><span class="math display">\[S_n=\begin{cases}X_N&amp;n=N,\\\max\{X_n,\,\mathbb{E}S_{n+1}\}&amp;n=N-1,\ldots,0.\end{cases}\]</span></p><p>记事件 <span class="math inline">\(A_n=\{X_n&gt;\mathbb{E}S_{n+1}\}\)</span>，则<span class="math inline">\(\mathbb{P}(A_n)=1-\mathbb{E}S_{n+1}\)</span>。于是序列<span class="math inline">\(\{\mathbb{E}S_n\}\)</span> 满足倒向递推关系<span class="math display">\[\mathbb{E}S_n=\mathbb{P}(A_n)\frac{1+\mathbb{E}S_{n+1}}{2} +\mathbb{E}S_{n+1}\cdot(1-\mathbb{P}(A_n))=\frac{1+(\mathbb{E}S_{n+1})^2}{2}.\]</span> 这正是我们前一节中推导的序列 <span class="math inline">\((a_n)_{n\geq1}\)</span>的递推关系，只是相差一个下标的翻转。</p></div><p>设 <span class="math inline">\(\tau=\inf\,\{n:\,S_n=X_n\}\)</span>，则 <span class="math inline">\(\tau\)</span>是停时。由于 <span class="math inline">\(S_N=X_N\)</span>，因此 <span class="math inline">\(0\leq\tau\leq N\)</span>。<span class="math inline">\(\tau\)</span> 就是我们采取的相亲策略：在 <span class="math inline">\(\tau\)</span> 时刻，由于这时 <span class="math inline">\(\max\{X_n,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}=X_n\)</span>，即<span class="math inline">\(n\)</span> 号女士的分数 <span class="math inline">\(X_n\)</span>大于等于后面继续相亲所能获得的最佳收益 <span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>，剩下的相亲就不必再进行了。</p><p>到目前为止，我们已经把相亲问题完整地翻译成了鞅的语言。我们来证明<span class="math inline">\(\tau\)</span>确实是最优策略。为此我们需要做一些准备：</p><div id="super" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\{S_n\}\)</span> 是控制 <span class="math inline">\(\{X_n\}\)</span> 的最小上鞅。</p></div><p><strong>证明</strong>：由 <span class="math inline">\(S_n=\max\{X_n,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}\)</span>直接可见 <span class="math inline">\(S_n\geq X_n\)</span> 并且 <span class="math inline">\(\{S_n\}\)</span> 是上鞅。设 <span class="math inline">\(\{Y_n\}\)</span> 是任意满足 <span class="math inline">\(Y_n\geq X_n\)</span> 的上鞅序列，我们要证明必有<span class="math inline">\(Y_n\geq S_n\)</span>。这只要从最后一项 <span class="math inline">\(n=N\)</span> 开始逐项验证即可。由定义 <span class="math inline">\(Y_N\geq X_N=S_N\)</span>，这一项没问题。假设 <span class="math inline">\(Y_n\geq S_n\)</span>，两边对 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 取条件期望可得 <span class="math display">\[Y_{n-1}\geq \mathbb{E}[Y_n|\mathcal{F}_{n-1}]\geq \mathbb{E}[S_n|\mathcal{F}_{n-1}].\]</span>其中第一个不等号是根据上鞅的定义，第二个不等号是根据条件期望的单调性。再结合<span class="math inline">\(Y_{n-1}\geq X_{n-1}\)</span> 可得 <span class="math inline">\(Y_{n-1}\geq\max\{X_{n-1},\mathbb{E}[S_n|\mathcal{F}_{n-1}]\}=S_{n-1}\)</span>，所以<span class="math inline">\(n-1\)</span>项也没有问题。这样倒着向前递推即得结论成立。<span class="math inline">\(\blacksquare\)</span></p><div id="martingale" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\{S_{n\wedge\tau}\}\)</span> 是一个鞅。</p></div><p><strong>证明</strong>：<span class="math display">\[S_{(n+1)\wedge\tau}-S_{n\wedge\tau}=1_{\{\tau&gt;n\}}(S_{n+1}-S_n).\]</span></p><p>对上式右边求条件期望： <span class="math display">\[\mathbb{E}[1_{\{\tau&gt;n\}}(S_{n+1}-S_n)|\mathcal{F}_n]=1_{\{\tau&gt;n\}}\mathbb{E}[(S_{n+1}-S_n)|\mathcal{F}_n]=0.\]</span></p><p>这是因为如果 <span class="math inline">\(\tau&gt;n\)</span>的话那么由 <span class="math inline">\(\tau\)</span> 的定义 <span class="math inline">\(S_n=\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="expectation-tau" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathbb{E}X_\tau=\mathbb{E}S_0\)</span>。</p></div><p><strong>证明</strong>：注意 <span class="math inline">\(X_\tau=S_\tau\)</span>，利用 <span class="math inline">\(0\leq\tau\leq N\)</span> 和鞅性质即可： <span class="math display">\[\mathbb{E}X_\tau=\mathbb{E}S_\tau=\mathbb{E}S_{\tau\wedgeN}=\mathbb{E}S_{\tau\wedge0}=\mathbb{E}S_0.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div id="optimal" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{M}\)</span> 是所有满足 <span class="math inline">\(0\leq T\leq N\)</span> 的停时 <span class="math inline">\(T\)</span> 组成的集合，则 <span class="math inline">\(\tau\)</span> 是其中最优的： <span class="math display">\[\mathbb{E}S_0=\mathbb{E}X_\tau=\sup_{T\in\mathcal{M}}\mathbb{E}X_T.\]</span></p></div><p><strong>证明</strong>：设 <span class="math inline">\(T\)</span>是任意停时，我们要证明 <span class="math inline">\(\mathbb{E}X_\tau\geq\mathbb{E}X_T\)</span>。为此只要注意到 <span class="math display">\[\mathbb{E}X_\tau =\mathbb{E}S_0\geq \mathbb{E}S_T\geq\mathbb{E}X_T.\]</span> 第一个等号是根据 <a href="#expectation-tau" title="推论 2.3">推论 2.3</a>，中间的不等号是因为 <span class="math inline">\(\{S_n\}\)</span> 是上鞅，所以对任何停时 <span class="math inline">\(T\)</span> 都有 <span class="math inline">\(\mathbb{E}S_T\leq\mathbb{E}S_0\)</span>。最后的不等号是因为 <span class="math inline">\(S_n\)</span> 控制 <span class="math inline">\(X_n\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>至此我们就从数学上严格论证了前面的相亲策略确实是最优的。</p><p>回顾上面的分析，可以发现我们实际上使用了 <span class="math inline">\(\tau\)</span> 的两个性质：<span class="math inline">\(S_\tau=X_\tau\)</span> 和 <span class="math inline">\(\{S_{n\wedge\tau}\}\)</span>是鞅。这两个性质保证了 <span class="math inline">\(\tau\)</span>是最优策略。那这是不是说明还有其它最优的策略呢？</p><div id="suff-nece" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.5</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\nu\in\mathcal{M}\)</span>是最优停时的充要条件是：</p><ol type="1"><li><span class="math inline">\(S_\nu=X_\nu\)</span>。</li><li><span class="math inline">\(\{S_{n\wedge\nu}\}\)</span> 是鞅。</li></ol></div><p><a href="#suff-nece" title="定理 2.5">定理 2.5</a>告诉我们，前面采用的相亲策略是所有最优策略中时间成本最低的：即若 <span class="math inline">\(\nu\)</span> 是任意最优停时，则 <span class="math inline">\(\tau\leq\nu\)</span> （回顾一下 <span class="math inline">\(\tau\)</span> 的定义）。</p><p>我们还可以给出最优策略中最大的一个来：</p><div id="largest" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.6</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(S_n=M_n-A_n\)</span> 是 Snell 包络 <span class="math inline">\(\{S_n\}\)</span> 的 Doob-Meyer 分解，其中 <span class="math inline">\(\{M_n\}\)</span> 是鞅，<span class="math inline">\(A_n\)</span> 是可料递增过程，由 <span class="math display">\[A_n=\sum_{k=1}^n(S_{k-1}-\mathbb{E}[S_k|\mathcal{F}_{k-1}]) \]</span> 给出。定义</p><p><span class="math display">\[\tau_\max = \begin{cases}N &amp; A_N=0,\\\min\{n\geq0 \mid A_{n+1}&gt;0\} &amp; A_N&gt;0.\end{cases}\]</span></p><p>则 <span class="math inline">\(\tau_\max\)</span>是所有最优停时中最大的。</p></div><p>这个策略在现实很有用，它是以最优方式行使美式期权的最大停时。</p><p><a href="#suff-nece" title="定理 2.5">定理 2.5</a> 和 <a href="#largest" title="定理 2.6">定理 2.6</a>的证明都不难，这里就省略了。读者可以参考 <span class="citation" data-cites="RiskNeutralValuation">(<a href="#ref-RiskNeutralValuation" role="doc-biblioref">Bingham and Kiesel 2004, sec. 3.6</a>)</span>。</p><p>我猜某些读者可能会对 <span class="math inline">\(\tau_\max\)</span>对应的相亲策略感兴趣，因为这个策略有点渣男：它会在保证娶到最优女士的前提下和尽可能多的女士相亲。不过在<span class="math inline">\(\{X_n\}\)</span>是独立随机变量序列的情形，你还是死了这份心吧。因为这时 <span class="math display">\[A_n=\sum_{k=1}^n(S_{k-1}-\mathbb{E}S_k)=\sum_{k=1}^n\max\{X_{k-1}-\mathbb{E}S_k,0\}.\]</span>所以使得 <span class="math inline">\(A_{n+1}&gt;0\)</span> 成立的最小<span class="math inline">\(n\)</span> 正是使得 <span class="math inline">\(X_n&gt;\mathbb{E}S_{n+1}\)</span> 成立的最小 <span class="math inline">\(n\)</span>，即使得 <span class="math inline">\(X_n=S_n\)</span> 成立的最小 <span class="math inline">\(n\)</span>。这不就是前面见好就收的策略 <span class="math inline">\(\tau\)</span> 嘛！换句话说，在 <span class="math inline">\(\{X_n\}\)</span>是独立随机变量序列的情形，只有一种最优相亲策略！</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-RiskNeutralValuation" class="csl-entry" role="listitem">Bingham, N. H., and Rüdiger Kiesel. 2004. <em>Risk-Neutral Valuation :Pricing and Hedging of Financial Derivatives / n.h. Bingham and r.Kiesel.</em> Second edition. Springer Finance. London: Springer.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三质点弹簧系统的简正模式</title>
      <link href="/three-mass-spring-system/"/>
      <url>/three-mass-spring-system/</url>
      
        <content type="html"><![CDATA[<p>今天的问题是群表示论在物理中的一个小应用：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>平面上有三个质量均为 <span class="math inline">\(m\)</span> 的质点 <span class="math inline">\(A,B,C\)</span>，它们位于正三角形的三个顶点。质点之间两两由弹簧相连，三个弹簧完全一样。弹簧质量忽略不计。</p><p><img src="/images/mass-spring/abc.png" class="fig" width="250"></p><p>初始时所有质点都处于静止状态，弹簧之间没有张力。假设给这三个质点分别施加一个初始速度，使这三个质点在平面内作刚体运动，不考虑任何摩擦力和空气阻力，那么这个系统的简正模式(normal mode) 是什么？</p></div><p>这里 <a href="https://en.wikipedia.org/wiki/Normal_mode">简正模式</a>的含义是所有质点按照一个共同的频率和固定的相位关系相对于各自的平衡位置作简谐振动。</p><span id="more"></span><p>比较容易发现的简正模式有：</p><ol type="1"><li><p>平移。初始时给所有质点以同样的速度，它们会继续以相同的速度移动。</p><p><img src="/images/mass-spring/trans.gif" class="fig" width="250"></p></li><li><p>旋转。初始时给所有质点以相同的切向速度，它们会继续绕中心旋转。</p><p><img src="/images/mass-spring/rot.gif" class="fig" width="250"></p></li><li><p>呼吸。初始时给每个质点相同的径向速度，系统会重复膨胀 —收缩的过程。</p><p><img src="/images/mass-spring/breath.gif" class="fig" width="250"></p></li></ol><p>但是要找出其它的简正模式，并保证没有遗漏，就不能只靠想象了。</p><p>我们把这个物理问题转换为一个线性代数问题，然后用一些群表示论的知识解决它。</p><p>这个质点弹簧系统有 6 个自由度 <span class="math inline">\(\{q_1,\ldots,q_6\}\)</span>，其中 <span class="math inline">\((q_1,q_2)\)</span>，<span class="math inline">\((q_3,q_4)\)</span>，<span class="math inline">\((q_5,q_6)\)</span> 分别是质点 <span class="math inline">\(A,B,C\)</span> 在 <span class="math inline">\(x,y\)</span>方向上相对于其平衡位置的位移，如下图所示：</p><figure><img src="/images/mass-spring/coords.svg" width="300" alt="建立坐标系，水平向右为 x 轴，竖直向上为 y 轴"><figcaption aria-hidden="true">建立坐标系，水平向右为 <span class="math inline">\(x\)</span> 轴，竖直向上为 <span class="math inline">\(y\)</span> 轴</figcaption></figure><p>设弹簧的弹性系数为 <span class="math inline">\(k\)</span>，原点在三角形中心，<span class="math inline">\(x\)</span>轴水平向右，于是三个弹簧所含的弹性势能为 （将形变投影到弹簧所在的方向）<span class="math display">\[\begin{aligned}V=&amp;\frac{1}{2}k(q_3-q_1)^2+\frac{1}{2}k\left[\frac{-1}{2}(q_5-q_3) +\frac{\sqrt{3}}{2}(q_6-q_4)\right]^2+\\&amp;\frac{1}{2}k\left[\frac{1}{2}(q_1-q_5)+ \frac{\sqrt{3}}{2}(q_2-q_6)\right]^2.\end{aligned}\]</span> 这是一个关于 <span class="math inline">\(\mathbf{q}=(q_1,q_2,\ldots,q_6)^T\)</span>的二次型： <span class="math display">\[V=\frac{1}{2}k\,\mathbf{q}^TU\mathbf{q}.\]</span> 其中 <span class="math display">\[U=\frac{1}{4}\begin{pmatrix}5&amp;\sqrt{3}&amp;-4&amp;0&amp;-1&amp;-\sqrt{3}\\\sqrt{3}&amp;3&amp;0&amp;0&amp;-\sqrt{3}&amp;3\\-4&amp;0&amp;5&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}\\0&amp;0&amp;-\sqrt{3}&amp;3&amp;\sqrt{3}&amp;-3\\-1&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}&amp;2&amp;0\\-\sqrt{3}&amp;-3&amp;\sqrt{3}&amp;-3&amp;0&amp;6\end{pmatrix}.\]</span></p><p>由牛顿第二定律我们有 <span class="math display">\[m\frac{\mathrm{d}^2q_i}{\mathrm{d}t^2}=-\frac{\partialV}{\partial q_i}=-k\sum_{j=1}^6U_{ij}q_j.\]</span>系统的简正模式就是所有 <span class="math inline">\(q_i\)</span>按照同一个频率 <span class="math inline">\(\omega\)</span>作简谐振动，但振幅可以不同，故而可以设 <span class="math inline">\(q_i=\overline{q}_i\mathrm{e}^{i\omegat}\)</span>，其中 <span class="math inline">\(\overline{q}_i\)</span>是振幅，与时间 <span class="math inline">\(t\)</span> 无关。代入上式得到<span class="math display">\[\frac{m\omega^2}{k}\overline{q}_i =\sum_{j=1}^6U_{ij}\overline{q}_j.\]</span> 即 <span class="math inline">\(U\overline{\mathbf{q}}=\lambda\overline{\mathbf{q}}\)</span>，<span class="math inline">\(\lambda=m\omega^2/k\)</span>，于是简正模式的振幅<span class="math inline">\(\overline{\mathbf{q}}=(\overline{q}_1,\overline{q}_2,\ldots,\overline{q}_6)\)</span>是 <span class="math inline">\(U\)</span> 的特征向量，频率 <span class="math inline">\(\omega\)</span> 与特征值 <span class="math inline">\(\lambda\)</span> 之间的关系为 <span class="math inline">\(\omega=\sqrt{\lambdak/m}\)</span>，从而问题转化为求矩阵 <span class="math inline">\(U\)</span> 的特征值和特征向量。由于 <span class="math inline">\(U\)</span> 是一个实对称矩阵，所以一定存在 6个线性无关的特征向量。</p><p>你当然可以直接硬算，但是手动求一个 6阶矩阵的特征值还是一件挺麻烦的事情，鉴于搞数学的人一般比较懒，我们可以换个思路想一想。</p><p>注意到这个系统具有对称性，其对称群是 <span class="math inline">\(S_3\)</span>。<span class="math inline">\(S_3\)</span> 这个群是集合 <span class="math inline">\(\{1,2,3\}\)</span>的置换群，同时也是平面上正三角形的对称群，在后者的情形通常称为二面体群<span class="math inline">\(D_3\)</span>。</p><p>回忆 <span class="math inline">\(S_3\)</span> 的一个表现为 <span class="math display">\[S_3=\{a,b\mid a^2=b^3=(ab)^2=1\}.\]</span>当作为置换群时，<span class="math inline">\(a=(12),\,b=(123)\)</span>。当作为二面体群时，<span class="math inline">\(a=\left(\begin{smallmatrix}-1&amp;0\\0&amp;1\end{smallmatrix}\right)\)</span>是关于 <span class="math inline">\(y\)</span> 轴的反射，<span class="math inline">\(b=\left(\begin{smallmatrix}\cos2\pi/3&amp;-\sin2\pi/3\\\sin2\pi/3&amp;\cos2\pi/3\end{smallmatrix}\right)\)</span>是关于原点角度为 <span class="math inline">\(2\pi/3\)</span>的旋转。</p><p>系统状态 <span class="math inline">\(\mathbf{q}\)</span> 所在的空间<span class="math inline">\(\mathbb{R}^6\)</span> 是三个 <span class="math inline">\(\mathbb{R}^2\)</span> 的直和：<span class="math inline">\(\mathbb{R}^6=\mathbb{R}^2_A\oplus\mathbb{R}^2_B\oplus\mathbb{R}^2_C\)</span>。其中<span class="math inline">\(\mathbb{R}^2_A,\mathbb{R}^2_B,\mathbb{R}^2_C\)</span>分别是 <span class="math inline">\(A,B,C\)</span> 的坐标空间。<span class="math inline">\(S_3\)</span> 在置换这三个直和项的同时，又以 <span class="math inline">\(D_3\)</span>的方式作用在每个直和项上，所以这个表示是 <span class="math inline">\(S_3\)</span> 的置换表示和在 <span class="math inline">\(\mathbb{R}^2\)</span> 上二维表示的张量积。</p><p>例如，对换 <span class="math inline">\((12)\)</span> 是关于 <span class="math inline">\(y\)</span> 轴的反射，它交换 <span class="math inline">\(A,B\)</span> 的同时，改变 <span class="math inline">\(x\)</span> 坐标的符号： <span class="math display">\[\begin{aligned}A\otimes (q_1,q_2) &amp;\xrightarrow{(12)} B\otimes(-q_1,q_2),\\B\otimes (q_3,q_4) &amp;\xrightarrow{(12)} A\otimes(-q_3,q_4).\end{aligned}\]</span></p><p>我们把这个张量积表示记作 <span class="math inline">\(\rho\)</span>，并记 <span class="math display">\[R=\begin{pmatrix}\cos\frac{2\pi}{3}&amp;-\sin\frac{2\pi}{3}\\\sin\frac{2\pi}{3}&amp;\cos\frac{\pi}{3}\end{pmatrix},\quadS=\begin{pmatrix}-1&amp;0\\0&amp;1\end{pmatrix}.\]</span></p><p>下面列出了 <span class="math inline">\(S_3\)</span> 的各个元素在<span class="math inline">\(\rho\)</span> 下对应的矩阵：</p><p><span class="math display">\[\begin{align*}\rho(e)&amp;=I_3\otimesI_2=\begin{pmatrix}I_2&amp;0&amp;0\\0&amp;I_2&amp;0\\0&amp;0&amp;I_2\end{pmatrix},\\\rho(a)&amp;=\begin{pmatrix}0&amp;1&amp;0\\1&amp;0&amp;0\\0&amp;0&amp;1\end{pmatrix}\otimesS=\begin{pmatrix}0&amp;S&amp;0\\S&amp;0&amp;0\\0&amp;0&amp;S\end{pmatrix},\\\rho(b)&amp;=\begin{pmatrix}0&amp;1&amp;0\\0&amp;0&amp;1\\1&amp;0&amp;0\end{pmatrix}\otimesR=\begin{pmatrix}0&amp;R&amp;0\\0&amp;0&amp;R\\R&amp;0&amp;0\end{pmatrix},\\\rho(b^2)&amp;=\begin{pmatrix}0&amp;0&amp;1\\1&amp;0&amp;0\\0&amp;1&amp;0\end{pmatrix}\otimesR^2=\begin{pmatrix}0&amp;0&amp;R^2\\R^2&amp;0&amp;0\\0&amp;R^2&amp;0\end{pmatrix},\\\rho(ab)&amp;=\begin{pmatrix}0&amp;0&amp;1\\0&amp;1&amp;0\\1&amp;0&amp;0\end{pmatrix}\otimesSR=\begin{pmatrix}0&amp;0&amp;SR\\0&amp;SR&amp;0\\SR&amp;0&amp;0\end{pmatrix},\\\rho(ab^2)&amp;=\begin{pmatrix}1&amp;0&amp;0\\0&amp;0&amp;1\\0&amp;1&amp;0\end{pmatrix}\otimesSR^2=\begin{pmatrix}SR^2&amp;0&amp;0\\0&amp;0&amp;SR^2\\0&amp;SR^2&amp;0\end{pmatrix}.\end{align*}\]</span></p><p><span class="math inline">\(S_3\)</span> 在表示 <span class="math inline">\(\rho(g)\)</span>下显然都是正交矩阵，而且保持系统的势能不变，所以对任何状态 <span class="math inline">\(\mathbf{q}\)</span> 有 <span class="math display">\[V(\rho(g)\mathbf{q})=V(\mathbf{q}),\]</span> 即<span class="math display">\[{\bf q^T}\rho(g)^TU\rho(g){\bfq}=U.\]</span> 由于 <span class="math inline">\(\rho(g)\)</span>正交所以 <span class="math inline">\(\rho(g)U=U\rho(g)\)</span>，即<span class="math inline">\(U\)</span> 与表示 <span class="math inline">\(\rho\)</span> 交换。</p><p>在表示论中，我们非常喜欢这种与一个表示 <span class="math inline">\(\rho\)</span>交换的矩阵，因为这种矩阵的任何特征子空间都是 <span class="math inline">\(\rho\)</span> 的子表示，从而可以帮助我们将 <span class="math inline">\(\rho\)</span>分解为一些更简单表示的直和。不过在这里，我们要反过来借助 <span class="math inline">\(\rho\)</span> 的分解来分析 <span class="math inline">\(U\)</span> 的特征子空间的结构。</p><p>注意到 <span class="math inline">\(S_3\)</span> 在 <span class="math inline">\(\{1,2,3\}\)</span>上的置换表示，其特征只有在单位元 <span class="math inline">\(e\)</span>处不为 0（值是 3），在任何非单位元 <span class="math inline">\(g\inS_3\)</span> 处都是 0。这个表示是张量积表示 <span class="math inline">\(\rho\)</span> 的分量，所以 <span class="math inline">\(\rho\)</span> 的特征 <span class="math inline">\(\chi\)</span> 也具有此性质。显然 <span class="math inline">\(\chi(e)=6\)</span>，于是 <span class="math inline">\(\chi\)</span> 与 <span class="math inline">\(S_3\)</span>的正则表示的特征完全相同，从而同构于正则表示，从而 <span class="math inline">\(\chi\)</span>可以分解为两个一次表示和两个二次不可约表示的和： <span class="math display">\[\chi = \chi_1 + \chi_2 + \chi_3+\chi_4.\]</span>其中 <span class="math inline">\(\chi_1\)</span> 是平凡表示的特征，<span class="math inline">\(\chi_2\)</span> 是符号表示的特征（偶置换为+1，奇置换为 -1），这两个特征都是一次的。<span class="math inline">\(\chi_3=\chi_4\)</span> 是 <span class="math inline">\(S_3\)</span>作为二面体群的二维不可约表示的特征。</p><p>记 <span class="math inline">\(\chi_i\)</span> 对应的不可约模是 <span class="math inline">\(V_i\)</span>，则 <span class="math inline">\(\dimV_1=\dim V_2=1\)</span>，<span class="math inline">\(\dim V_3=\dimV_4=2\)</span> 并且 <span class="math display">\[\mathbb{R}^6=V_1\oplusV_2\oplus V_3\oplus V_4.\]</span></p><p>由于 <span class="math inline">\(U\)</span> 是可对角化的变换，并且<span class="math inline">\(U\)</span> 的特征子空间都是 <span class="math inline">\(\rho\)</span> 的不变子空间从而可以分解为 <span class="math inline">\(V_i\)</span> 的直和，所以 <span class="math inline">\(U\)</span> 在每个 <span class="math inline">\(V_i\)</span> 上的作用是数乘 <span class="math inline">\(\lambda_i\)</span>。</p><p>从 <span class="math inline">\(V_1,\ldots,V_4\)</span>中分别选择一组基，它们合起来构成 <span class="math inline">\(\mathbb{R}^6\)</span> 的一组基。在这组基下 <span class="math inline">\(U\)</span> 是对角矩阵，形如 <span class="math display">\[U=\begin{pmatrix}\lambda_1&amp;0&amp;0&amp;0\\0&amp;\lambda_2&amp;0&amp;0\\0&amp;0&amp;\lambda_3I_2&amp;0\\0&amp;0&amp;0&amp;\lambda_4I_2\end{pmatrix}.\]</span>同时 <span class="math inline">\(\rho(g)\)</span> 形如 <span class="math display">\[\rho(g)=\begin{pmatrix}D_1&amp;0&amp;0&amp;0\\0&amp;D_2&amp;0&amp;0\\0&amp;0&amp;D_3&amp;0\\0&amp;0&amp;0&amp;D_4\end{pmatrix}.\]</span></p><p>我们来计算 <span class="math inline">\(\rho(g)U\)</span> 对不同 <span class="math inline">\(g\in S_3\)</span> 的迹。首先注意到 <span class="math display">\[\mathop{\mathrm{tr}}{\rho(g)U}=\mathop{\mathrm{tr}}{\begin{pmatrix}\lambda_1D_1&amp;0&amp;0&amp;0\\0&amp;\lambda_2D_2&amp;0&amp;0\\0&amp;0&amp;\lambda_3D_3&amp;0\\0&amp;0&amp;0&amp;\lambda_4D_4\end{pmatrix}}=\sum_{i=1}^4\lambda_i\chi_i(g).\]</span></p><p>另一方面，我们对 <span class="math inline">\(S_3\)</span> 中的 <span class="math inline">\(e,a,b\)</span> 这三个元素，根据前面列出的 <span class="math inline">\(\rho(g)\)</span> 矩阵，计算其与 <span class="math inline">\(U\)</span>的乘积，再求迹得到（这是本文计算量最大的部分！） <span class="math display">\[\begin{align*}\mathop{\mathrm{tr}}{\rho(e)U}&amp;=\mathop{\mathrm{tr}}{U}=\frac{1}{4}(5+3+5+3+2+6)=6,\\\mathop{\mathrm{tr}}{\rho(a)U}&amp;=\mathop{\mathrm{tr}}{\begin{pmatrix}0&amp;S&amp;0\\S&amp;0&amp;0\\0&amp;0&amp;S\end{pmatrix}\frac{1}{4}\begin{pmatrix}5&amp;\sqrt{3}&amp;-4&amp;0&amp;-1&amp;-\sqrt{3}\\\sqrt{3}&amp;3&amp;0&amp;0&amp;-\sqrt{3}&amp;3\\-4&amp;0&amp;5&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}\\0&amp;0&amp;-\sqrt{3}&amp;3&amp;\sqrt{3}&amp;-3\\-1&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}&amp;2&amp;0\\-\sqrt{3}&amp;-3&amp;\sqrt{3}&amp;-3&amp;0&amp;6\end{pmatrix}}\\&amp;=\frac{1}{4}(4+0+4+0-2+6)=3,\\\mathop{\mathrm{tr}}{\rho(b)U}&amp;=\mathop{\mathrm{tr}}{\begin{pmatrix}0&amp;R&amp;0\\0&amp;0&amp;R\\R&amp;0&amp;0\end{pmatrix}\frac{1}{4}\begin{pmatrix}5&amp;\sqrt{3}&amp;-4&amp;0&amp;-1&amp;-\sqrt{3}\\\sqrt{3}&amp;3&amp;0&amp;0&amp;-\sqrt{3}&amp;3\\-4&amp;0&amp;5&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}\\0&amp;0&amp;-\sqrt{3}&amp;3&amp;\sqrt{3}&amp;-3\\-1&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}&amp;2&amp;0\\-\sqrt{3}&amp;-3&amp;\sqrt{3}&amp;-3&amp;0&amp;6\end{pmatrix}}\\&amp;=\frac{1}{4}(2+0-1+3+2+0)=\frac{3}{2}.\end{align*}\]</span> 于是我们得到三个方程 <span class="math display">\[\begin{align*}6&amp;=\lambda_1+\lambda_2+2(\lambda_3+\lambda_4),\\3&amp;=\lambda_1-\lambda_2,\\3/2&amp;=\lambda_1+\lambda_2-(\lambda_3+\lambda_4).\end{align*}\]</span> 可以解出 <span class="math inline">\(\lambda_1=3\)</span>，<span class="math inline">\(\lambda_2=0\)</span>，<span class="math inline">\(\lambda_3+\lambda_4=3/2\)</span>。</p><p>我们还缺一个方程！可以用 <span class="math inline">\(\mathop{\mathrm{tr}}{U^2}=\lambda_1^2+\lambda_2^2+2(\lambda_3^2+\lambda_4^2)\)</span>来做，但手算 <span class="math inline">\(U^2\)</span>的话计算量还是不小的。更简单的办法是用物理直观：我们已经看到平移和旋转是两种简正模式，这两种模式下质点的振动频率是0，而平移包含了 <span class="math inline">\(x\)</span> 轴和 <span class="math inline">\(y\)</span> 轴两个线性无关的方向上的平移，所以<strong>0 作为 <span class="math inline">\(U\)</span>的特征值至少是三重的</strong>。我们已经解得 <span class="math inline">\(\lambda_2=0\)</span> 是一个，所以 <span class="math inline">\(\lambda_3\)</span> 和 <span class="math inline">\(\lambda_4\)</span> 中必然还有一个是 0，不妨设<span class="math inline">\(\lambda_3=0\)</span>，则 <span class="math inline">\(\lambda_4=3/2\)</span>。</p><p>总结一下，系统总共有 4 种简正模式：</p><ol type="1"><li><p>平凡表示 (<span class="math inline">\(\lambda_1=3\)</span>)对应的简正模式是呼吸，其频率为 <span class="math inline">\(\omega=\sqrt{3k/m}\)</span>：</p><figure><img src="/images/mass-spring/breath.gif" width="250" alt="呼吸　\omega=\sqrt{3k/m}"><figcaption aria-hidden="true">呼吸　<span class="math inline">\(\omega=\sqrt{3k/m}\)</span></figcaption></figure></li><li><p>符号表示 (<span class="math inline">\(\lambda_2=0\)</span>)对应的简正模式是旋转，其频率 <span class="math inline">\(\omega=0\)</span>：</p><figure><img src="/images/mass-spring/rot.gif" width="250" alt="旋转　\omega=0"><figcaption aria-hidden="true">旋转　<span class="math inline">\(\omega=0\)</span></figcaption></figure></li><li><p>第一个二维不可约表示 (<span class="math inline">\(\lambda_3=0\)</span>)包含了两种简正模式，它们分别是沿着 <span class="math inline">\(x\)</span> 方向和 <span class="math inline">\(y\)</span> 方向的平移，其频率 <span class="math inline">\(\omega=0\)</span>。</p><figure><img src="/images/mass-spring/trans.gif" width="250" alt="平移　\omega=0"><figcaption aria-hidden="true">平移　<span class="math inline">\(\omega=0\)</span></figcaption></figure></li><li><p>第二个二维不可约表示 (<span class="math inline">\(\lambda_4=3/2\)</span>)也包含了两种简正模式，它们分别是两个不同方向上的“鼓掌”：</p><figure><img src="/images/mass-spring/clap.gif" width="250" alt="鼓掌　\omega=\sqrt{\frac{3k}{2m}}"><figcaption aria-hidden="true">鼓掌　<span class="math inline">\(\omega=\sqrt{\frac{3k}{2m}}\)</span></figcaption></figure><p>另一种可以由上面的旋转 <span class="math inline">\(2\pi/3\)</span>后得到。这两个简正模式的频率都是 <span class="math inline">\(\omega=\sqrt{\frac{3k}{2m}}\)</span>。</p></li></ol><p>至此我们就求出了系统的全部简正模式。</p>]]></content>
      
      
      <categories>
          
          <category> 有限群表示与结合代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模式的等待时间与反直觉概率</title>
      <link href="/pattern-occurrence/"/>
      <url>/pattern-occurrence/</url>
      
        <content type="html"><![CDATA[<p>著名概率学家 Feller 在他的名著 “An introduction to probability andits applications” 中提到了这样一个实验：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>重复抛掷一枚均匀的硬币，用 <code>H</code>代表正面向上，<code>T</code> 代表背面向上，一直到连续出现 6 次<code>H</code> 为止。这里连续 6 个 <code>Ｈ</code> 组成的模式记作<code>HHHHHH</code>，所需要抛掷硬币的次数叫做等待时间。等待时间是一个随机变量，最小值是6，最大值可以是无限。Feller 问：等待时间的期望是多少？</p></div><p>这个问题可以用 Markov链来解，但是非常繁琐。香港中文大学李硕彦教授在他的论文 <span class="citation" data-cites="Li1980">(<a href="#ref-Li1980" role="doc-biblioref">Li 1980</a>)</span>中用离散鞅的知识给出了一个简洁而巧妙的解法，本文就来介绍他的方法。</p><span id="more"></span><h1 id="鞅和赌博序列">鞅和赌博序列</h1><p>我们用 <code>HTHT</code>这个模式为例子，来演示如何求出它的平均等待时间。</p><p>假设有一个赌徒，怀里揣着 1 元钱来到一家赌场，他的目标是赌中<code>HTHT</code> 这个序列。</p><ul><li><p>第一天，他押上这 1 元钱，赌第一次掷硬币的结果是<code>H</code>。如果他赌错了就得空手走人，而赌对的话则可以赢得 2 元（资金翻番） 并留在赌场。</p></li><li><p>第二天，他押上全部的 2 元，赌第二次掷硬币的结果是<code>Ｔ</code>。跟以前一样，赌错了空手走人，赌对了的话则资金翻番变成 4元并留在赌场。</p></li><li><p>第三天，他押上全部的 4 元，赌第三次掷硬币的结果是<code>H</code>。赌错了空手走人，赌对了的话则资金翻番变成 8元并留在赌场。</p></li><li><p>第四天，他押上全部的 8 元，赌第四次掷硬币的结果是<code>T</code>。赌错了空手走人，赌对了资金翻番变成 16元，赌局结束。</p></li></ul><p>这个赌局很像电视节目里的闯关游戏，赌局一共有 4关，赌徒要一关一关的闯，中间任何一关输了都要空手走人。</p><p>赌局对赌徒和庄家来讲都是公平的：大家在期望的意义下都是不赔不赚。每一天，赌徒都以1/2 的概率输光赌本，也以 1/2 的概率将赌本翻番。</p><p>现在假设有一个赌博团伙，他们每天都派一个人到赌场赌博，每个赌徒的赌局与上面的描述相同，不同的赌徒的赌局互相独立。我们用<span class="math inline">\(\{X_n,n=0,1,2,\ldots\}\)</span> 表示第 <span class="math inline">\(n\)</span> 天结束以后这个团伙的「净收益」，其中<span class="math inline">\(X_0=0\)</span>。由于赌局是公平的，因此 <span class="math inline">\(\{X_n\}\)</span> 是一个鞅。</p><p>设 <span class="math inline">\(\tau\)</span> 是模式 <code>HTHT</code>的等待时间，则 <span class="math inline">\(\tau\)</span>是一个停时。不难验证 <span class="math inline">\(\{X_n\}\)</span> 和<span class="math inline">\(\tau\)</span> 满足 <a href="https://en.wikipedia.org/wiki/Optional_stopping_theorem">Doob可料停时定理</a> 的条件</p><div id="doob-------------------" class="statement sta_doob_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Doob可料停时定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{X_n, n=0,1,2,\ldots\}\)</span> 是一个鞅，<span class="math inline">\(\tau\)</span> 是停时且满足</p><ol type="1"><li><span class="math inline">\(\mathbb{E}\tau &lt;\infty\)</span>，</li><li>存在常数 <span class="math inline">\(M\)</span> 使得 <span class="math inline">\(|X_{n+1}-X_{n}|\leq M\)</span> 对任何 <span class="math inline">\(n\)</span> 都几乎处处成立。</li></ol><p>则 <span class="math inline">\(\mathbb{E}X_\tau =\mathbb{E}X_0\)</span>。</p></div><p>因此在我们的问题中 <span class="math inline">\(\mathbb{E}X_\tau =\mathbb{E}X_0 = 0\)</span>。</p><p>显然 <span class="math inline">\(X_\tau=W-\tau\)</span>，这里 <span class="math inline">\(W\)</span> 表示第 <span class="math inline">\(\tau\)</span>天结束时留在赌场内的赌徒的资金之和，要减去 <span class="math inline">\(\tau\)</span> 是因为第 <span class="math inline">\(\tau\)</span> 天结束时赌博团伙总共派出了 <span class="math inline">\(\tau\)</span> 个赌徒，他们投入的赌本总共是 <span class="math inline">\(\tau\)</span> 元。根据上面的讨论，有 <span class="math inline">\(\mathbb{E}W=\mathbb{E}\tau\)</span>成立。这里的关键在于 <span class="math inline">\(W\)</span>不是一个随机变量，而是一个可以算出来的常数！</p><table><tbody><tr><td style="text-align: left;"><span class="math inline">\(\tau\)</span>-3</td><td style="text-align: left;"><span class="math inline">\(\tau\)</span>-2</td><td style="text-align: left;"><span class="math inline">\(\tau\)</span>-1</td><td style="text-align: left;"><span class="math inline">\(\tau\)</span></td></tr><tr><td style="text-align: left;">H</td><td style="text-align: left;">T</td><td style="text-align: left;">H</td><td style="text-align: left;">T</td></tr></tbody></table><p>我们仔细分析一下当第 <span class="math inline">\(\tau\)</span>天结束的时候，哪些赌徒还在赌场内，他们各自有多少钱。由于 <span class="math inline">\(\tau\)</span>是首次有某个赌徒闯关成功的时刻，所以只有第 <span class="math inline">\(\tau-3\)</span> 到第 <span class="math inline">\(\tau\)</span> 天来赌场的这 4个赌徒还有可能留在赌场，更早的赌徒都输光走人了。</p><ul><li>第 <span class="math inline">\(\tau-3\)</span>天来的赌徒是那个闯关成功的幸运儿，他有 16 元；</li><li>第 <span class="math inline">\(\tau-2\)</span> 和第 <span class="math inline">\(\tau\)</span> 天来的两个赌徒由于赌的是<code>H</code> 但结果是 <code>T</code>，所以他们当天就走人了；</li><li>第 <span class="math inline">\(\tau-1\)</span> 天来的赌徒连续赌对了<code>HT</code>，他还有 4 元。</li></ul><p>因此赌徒们总共有 <span class="math inline">\(W=16+4=20\)</span>元，即 <span class="math inline">\(\mathbb{E}\tau=20\)</span>。</p><p>这里第 <span class="math inline">\(\tau-1\)</span>天来的赌徒最有趣：他赌的明明是 <code>HTHT</code> 的前缀<code>HT</code>，但是由于 <code>HT</code> 恰好也是 <code>HTHT</code>的后缀，因此他也能赢到钱！</p><p>这个推理完全适用于一般的情形：设 <span class="math inline">\(P=(a_1,a_2,\cdots,a_m)\)</span> 是一个给定的由<code>T</code> 和 <code>H</code>组成的模式，我们计算它的全部既是前缀又是后缀的子序列的长度，设为 <span class="math inline">\(l_1,\cdots,l_r\)</span>，则 <span class="math inline">\(P\)</span> 的等待时间 <span class="math inline">\(\tau\)</span> 的期望为 <span class="math display">\[\mathbb{E}\tau =2^{l_1}+\cdots+2^{l_r}.\]</span></p><p>回到开头的例子：<code>HHHHHH</code>的每一个前缀都同时是它的后缀，因此它的平均等待时间为 <span class="math display">\[2^6+2^5+2^4+2^3+2^2+2^1 = 126.\]</span>所以一个模式的平均等待时间完全由它的自匹配的程度决定。</p><p>把上面的方法稍作修改，还可以用来计算 <span class="math inline">\(\tau\)</span> 的生成函数 <span class="math display">\[ \mathbb{E}[s^\tau] =\sum_{n=1}^\infty\mathbb{P}(\tau=n)s^n.\]</span> 为此只要假设第 <span class="math inline">\(n\)</span> 天来的赌徒怀里揣的钱是 <span class="math inline">\(s^n(0&lt;s&lt;1)\)</span> 即可，这里不再赘述。</p><h1 id="多个模式的等待时间与获胜概率">多个模式的等待时间与获胜概率</h1><p>假设同时有多个模式 <span class="math inline">\(A_1,\ldots,A_m\)</span>加入「赛跑」，我们想计算它们各自胜出的概率。用数学公式表示，就是设 <span class="math inline">\(A_i\)</span> 的等待时间为 <span class="math inline">\(\tau_i\)</span>，令 <span class="math display">\[\tau=\min\{\tau_1,\ldots,\tau_m\},\]</span> 则<span class="math inline">\(\tau\)</span>表示赛跑过程中冠军「撞线」的时刻，又令 <span class="math inline">\(p_i=\mathbb{P}(\tau=\tau_i)\)</span>，则 <span class="math inline">\(p_i\)</span> 表示模式 <span class="math inline">\(A_i\)</span> 「夺冠」 的概率。我们想计算出每个<span class="math inline">\(p_i\)</span> 的值来。</p><p>为此先给一个定义：</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 是两个给定的模式，且 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>都不是对方的连续子序列。我们计算所有既是 <span class="math inline">\(A\)</span> 的后缀又是 <span class="math inline">\(B\)</span> 的前缀的全部子序列，设它们的长度为<span class="math inline">\(l_1,\cdots,l_r\)</span>，定义 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 的匹配指数为 <span class="math display">\[A\ast B = 2^{l_1}+\cdots+2^{l_r}.\]</span> 如果<span class="math inline">\(A\)</span> 的任何后缀都不是 <span class="math inline">\(B\)</span> 的前缀则 <span class="math inline">\(A\ast B\)</span> 定义为 0。特别当 <span class="math inline">\(A=B\)</span> 时，<span class="math inline">\(A\astA\)</span> 就是前面计算的 <span class="math inline">\(A\)</span>的平均等待时间，这个值又叫做 <span class="math inline">\(A\)</span>的自匹配指数。</p></div><p>我们要证明这样一个引理 ：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>如果已知掷硬币的结果是以模式 <span class="math inline">\(A\)</span> 开头的，那么距离模式 <span class="math inline">\(B\)</span> 出现还需要等待的时间的期望为 <span class="math display">\[\mathbb{E}\tau_{AB} = B\ast B -A\astB.\]</span></p></div><p>引理的证明：仍然是采用赌博序列的方法，每天来的赌徒赌的是模式 <span class="math inline">\(B\)</span>，只不过这个时候我们已经知道了前 <span class="math inline">\(k\)</span> 次赌博的结果是模式 <span class="math inline">\(A\)</span>（假设序列 <span class="math inline">\(A\)</span> 的长度为 <span class="math inline">\(k\)</span>），所以不难算出前 <span class="math inline">\(k\)</span> 天赌博团伙的总资金为 <span class="math inline">\(A\ast B\)</span> 元。由于赌局始终是公平的，所以从<span class="math inline">\(k+1\)</span> 天起，直到模式 <span class="math inline">\(B\)</span> 出现的这 <span class="math inline">\(\tau_{AB}\)</span> 天里，赌徒们的净收益期望应该是0。到模式 <span class="math inline">\(B\)</span>出现时，赌徒们的资金将变成 <span class="math inline">\(B\ast B\)</span>元，所以这 <span class="math inline">\(\tau_{AB}\)</span>天中赌徒们的资金增加了 <span class="math inline">\(B\ast B-A\astB\)</span> 元，扣除他们的投入 <span class="math inline">\(\tau_{AB}\)</span>元，就是这段时间的净收益，其期望为 0： <span class="math display">\[\mathbb{E} [B\ast B-A\ast B-\tau_{AB}]=0.\]</span> 引理证毕。</p><p>接下来叙述并证明一个一般的结论：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(A_1\)</span>, <span class="math inline">\(A_2\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(A_m\)</span> 是 <span class="math inline">\(m\)</span>个事先给定的且两两互不嵌套的模式，记矩阵 <span class="math display">\[M=\begin{pmatrix} A_1\ast A_1 &amp; A_1\astA_2&amp;\cdots&amp; A_1\ast A_m\\ A_2\ast A_1&amp;A_2\astA_2&amp;\cdots&amp; A_2\ast A_m\\\cdots&amp;\cdots&amp;\cdots&amp;\cdots\\ A_m\ast A_1&amp;A_m\astA_2&amp;\cdots&amp;A_m\ast A_m\end{pmatrix},\]</span> <span class="math display">\[\pi = (p_1,p_2,\cdots,p_m)^T,\quad\mathbf{1}=(1,1,\cdots,1)^T,\]</span> 则 <span class="math inline">\(M\)</span> 是可逆矩阵，并且 <span class="math display">\[M\pi =\mathbb{E}[\tau]\mathbf{1}.\]</span></p></div><p>在证明定理之前，先说说怎样根据定理的结论来计算 <span class="math inline">\(\mathbb{E}[\tau]\)</span> 和概率分布向量 <span class="math inline">\(\pi\)</span>。首先解出 <span class="math inline">\(MY=\mathbf{1}\)</span> 的解 <span class="math inline">\(Y=(y_1,y_2,\cdots,y_m)^T\)</span>来。根据可逆矩阵解的唯一性，必然有 <span class="math inline">\(\pi=\mathbb{E}[\tau]Y\)</span>。但是 <span class="math inline">\(\pi\)</span> 是一个概率分布，它的所有分量之和为1，因此 <span class="math display">\[\mathbb{E}[\tau]=\frac{1}{y_1+y_2+\cdots+y_m}.\]</span></p><p><span class="math inline">\(M\)</span>是可逆矩阵这一点是需要证明的，本文就省略了。事实上 <span class="math inline">\(A_i\)</span> 之间两两互不嵌套这个条件就可以保证<span class="math inline">\(M\)</span> 是可逆的。</p><p>有了 <span class="math inline">\(Y\)</span> 和 <span class="math inline">\(\mathbb{E}[\tau]\)</span> 自然立刻就得到了 <span class="math inline">\(\pi\)</span>。</p><p>定理的证明：我们有 <span class="math display">\[\mathbb{E}[\tau_i] =\mathbb{E}[\tau] + \mathbb{E}[\tau_i-\tau] =\mathbb{E}[\tau]+\sum_{j=1}^m p_j\mathbb{E}[\tau_i-\tau|\tau=\tau_j].\]</span>根据引理， <span class="math display">\[\mathbb{E}[\tau_i-\tau|\tau=\tau_j] = A_i\astA_i-A_j\ast A_i,\]</span> 因此 <span class="math display">\[A_i\astA_i=\mathbb{E}[\tau]+A_i\ast A_i-\sum_{j=1}^np_j A_j\ast A_i.\]</span>这就证明了定理。</p><h1 id="penney-游戏">Penney 游戏</h1><p>Penney 游戏是两个玩家 Bob 和 Alice的博弈游戏，它以掷硬币为工具：游戏开始前，两人各自选择一个长度为 3 的由<code>H</code> 和 <code>T</code> 组成的模式，比如说 Bob 选择<code>HHH</code>，Alice 选择<code>THH</code>，然后掷硬币直到其中一人选择的模式首先出现，先出现的一方获胜。</p><p>Penney 游戏有一个独特之处：</p><blockquote><p>假设 Bob 先选择他的序列，则不论 Bob 怎样选，Alice总可以「针锋相对」地选一个合适的序列，使得自己的获胜概率更高。总而言之，Penney游戏是所谓的「后发制人，先发者制于人」。</p></blockquote><p>这个有点类似于我们都熟悉的「剪子，石头，布」游戏。在 Penney游戏中，各种策略循环相克，<a href="http://en.wikipedia.org/wiki/Penney's_game">维基百科</a>中给出了各种情形下二人的获胜概率之比。在这个例子中，Alice 的获胜概率为7/8。</p><p>Penney 游戏是非传递博弈的典型例子：策略 <span class="math inline">\(A\)</span> 优于 <span class="math inline">\(B\)</span>，<span class="math inline">\(B\)</span>优于 <span class="math inline">\(C\)</span> 并不能推出 <span class="math inline">\(A\)</span> 优于 <span class="math inline">\(C\)</span>。</p><p>在只有两个模式 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>的情形，二者各自获胜的概率有一个很简单的表达式：</p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(A,B\)</span>是两个给定的序列，它们互不为对方的连续子序列，则序列 <span class="math inline">\(B\)</span> 和序列 <span class="math inline">\(A\)</span> 的获胜概率之比为 <span class="math inline">\(p_B:p_A = (A\ast A-A\ast B):(B\ast B-B\astA)\)</span>。</p></div><h1 id="还有更不可思议的事情">还有更不可思议的事情</h1><p>我们已经介绍了怎样计算一个模式的平均等待时间，以及多个模式同时「赛跑」时各自的获胜概率。我们现在来看看<code>THTH</code> 和 <code>HTHH</code> 比赛的结果如何。</p><p>首先不难算出 <code>THTH</code> 的平均等待时间是 20，<code>HTHH</code>的平均等待时间是 18，也就是说 <code>THTH</code>跑的慢一些，<code>HTHH</code>跑的快一些，这是不是意味着让它俩赛跑的话，<code>HTHH</code>获胜的概率更大呢？</p><p>答案是否定的，这其实是一个一面倒的竞赛：</p><blockquote><p>看起来慢一些的模式 <code>THTH</code>，其与 <code>HTHH</code>的胜算之比为 9 比 5，即平均每 14 场赛跑，<code>THTH</code> 会赢 9场，而貌似快一些的 <code>HTHH</code> 倒只赢 5 场。</p></blockquote><p>为什么会出现这种反直觉的现象呢？其实「跑得慢」和「赢得多」并不矛盾。我们随便看一个由<code>H</code> 和 <code>T</code> 组成的随机序列：</p><p>HHTHT<font color="red">H</font><font color="green">H</font>THT<font color="red">H</font><font color="green">H</font>TTTHHTH<font color="green">H</font>HHTTHHTTHTTHT<font color="red">H</font><font color="green">H</font>TH<font color="green">H</font>TH<font color="green">H</font>TH<font color="green">H</font>HHTTHTTTTTTHTTHT<font color="red">H</font>TTHHTH<font color="green">H</font>HHHHTTHT<font color="red">H</font><font color="green">H</font>THT<font color="red">H</font><font color="green">H</font>TTTTTHTTHHHHHHTH<font color="green">H</font>HTTTHTTTHTTTHHHTH<font color="green">H</font>THT<font color="red">H</font>TTTHTTHTTHT<font color="red">H</font><font color="green">H</font>TH<font color="green">H</font>TTHT<font color="red">H</font><font color="green">H</font>HTTHH…</p><p>其中分别用红色和绿色标记了模式 <code>THTH</code> 和 <code>HTHH</code>的出现的位置。注意到任何绿色 <code>H</code>后面连续的三个字符中绝对不会出现红色 <code>H</code>，而大约一半的红色的<code>H</code> 后面紧跟一个绿色的<code>H</code>。所以从一个随机序列中任选一点作为起点开始比赛，那么在<code>THTH</code> 先撞线的比赛中，第二个撞线的绿色 <code>HTHH</code>往往会只落后一个身位，但是在绿色 <code>HTHH</code>先撞线的比赛中，红色的 <code>THTH</code> 至少要落后四个身位以上。</p><p>用足球来类比，领先一个身位就好比取得一个净胜球。<code>THTH</code>击败 <code>HTHH</code> 的方法类似「一比零主义」：<code>THTH</code>一半的赢球是靠一比零拿下的，而且每次输球都要输四个以上的球，所以总净胜球为负（平均等待时间长）。但由于赢的场数多，积分反而领先。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Li1980" class="csl-entry" role="listitem">Li, Shuo-Yen Robert. 1980. <span>“<span class="nocase">A MartingaleApproach to the Study of Occurrence of Sequence Patterns in RepeatedExperiments</span>.”</span> <em>The Annals of Probability</em> 8 (6):1171–76. <a href="https://doi.org/10.1214/aop/1176994578">https://doi.org/10.1214/aop/1176994578</a>.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洛奇绵羊问题</title>
      <link href="/mabinogion-sheep-problem/"/>
      <url>/mabinogion-sheep-problem/</url>
      
        <content type="html"><![CDATA[<figure><img src="/images/midjourney/mabinogion.png" class="fig" width="350" alt="感谢 MidJourney，这下更有画面感了！"><figcaption aria-hidden="true">感谢MidJourney，这下更有画面感了！</figcaption></figure><p>今天的问题源自中世纪威尔士人的故事集《Mabinogion》中的一段：</p><blockquote><p>一个男孩来到了一个美丽的山谷，有一条小河在谷中流淌。他看到河一边的草地上有一群黑绵羊，另一边的草地上有一群白绵羊。羊群被施以一种魔法：每个时刻都恰有一只绵羊发出咩咩的叫声。如果发出叫声的是白绵羊，就会有一只黑绵羊趟过小河跑过来并且变成白绵羊；如果发出叫声的是黑绵羊，则会有一只白绵羊趟过小河跑过去并且变成黑绵羊。每个时刻发出叫声的绵羊是完全随机的，整个过程没有绵羊出生或者死亡，一直持续到所有绵羊都变成同一种颜色为止。</p></blockquote><p>问题是这样的：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>如果男孩可以选择在初始时刻 <span class="math inline">\(0\)</span>，或者是每个魔法时刻 <span class="math inline">\(1,2,\ldots\)</span>结束后将任意数量的白绵羊赶出山谷，那么为了最终得到尽可能多的黑绵羊，他应该采取怎样的策略？</p></div><span id="more"></span><p>洛奇绵羊问题出自 <span class="citation" data-cites="Williams1991">(<a href="#ref-Williams1991" role="doc-biblioref">Williams1991</a>)</span>，是一个很有趣的问题。这种在随机的环境中施加一个控制的力，以最大化期望收益的问题属于随机控制的范畴。</p><p>我们首先说明不论男孩采取怎样的策略，最终羊群都会以概率 1全部变成同一种颜色。</p><p>设 <span class="math inline">\(\Omega=\{(w,b)\in\mathbb{Z}_{\geq0}\times\mathbb{Z}_{\geq0}\}\)</span>是羊群所有可能的状态组成的集合，其中 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span>分别表示白绵羊和黑绵羊的数目。男孩采取的一个策略 <span class="math inline">\(S\)</span> 就是从一个状态 <span class="math inline">\((w,b)\)</span> 移动到另一个状态 <span class="math inline">\((w',b')\)</span> 的规则：根据当前 <span class="math inline">\((w,b)\)</span> 的值，男孩决定到底是按兵不动（不做任何干预），还是赶走 <span class="math inline">\(c\)</span>只白绵羊，把状态 <span class="math inline">\((w,b)\)</span> 变成状态<span class="math inline">\((w-c,b)\)</span>，这里 <span class="math inline">\(0&lt;c\leq w\)</span>是一个正整数。如果男孩始终不做任何干预的话，那么羊群状态将始终保持在线段<span class="math display">\[\{ (x,y)\mid x\geq0, y\geq0,x+y=w+b\}\]</span> 上，这是一个互通的 Markov 链，因此以概率 1撞到吸收状态 <span class="math inline">\((0,w+b)\)</span> 或 <span class="math inline">\((w+b,0)\)</span>，即最终变成同一种颜色。如果男孩在某个时刻移走了<span class="math inline">\(c\)</span>只白绵羊，那么系统将会被强制转移到线段 <span class="math display">\[\{(x,y)\mid x\geq0, y\geq0, x+y=w+b-c\}\]</span>上，如此下去。由于男孩只能进行有限次移走绵羊的操作，可见不论男孩策略如何，羊群总是会最终变成同色的。</p><p>对任何策略 <span class="math inline">\(S\)</span>，我们用 <span class="math inline">\(V_S(w,b)\)</span> 表示从 <span class="math inline">\((w,b)\)</span> 状态出发，在策略 <span class="math inline">\(S\)</span> 下最终得到的黑绵羊数量的期望值。这里<span class="math inline">\(V_S\)</span> 是一个由 <span class="math inline">\(S\)</span> 决定的确定的函数，它不包含随机性。<span class="math inline">\(V_S\)</span> 叫做策略 <span class="math inline">\(S\)</span> 的值函数。显然 <span class="math inline">\(V_S\)</span> 总是满足边界条件 <span class="math display">\[V_S(0,b)=b,\quadV_S(w,0)=0\label{eq:boundary}\tag{$\ast$}.\]</span></p><p>假设我们能够找到这样一个策略 <span class="math inline">\(A\)</span>，它的值函数 <span class="math inline">\(V_A\)</span> 有如下性质，那么它就是最佳策略：</p><blockquote><p><strong>最优策略的充分条件</strong>：如果策略 <span class="math inline">\(A\)</span> 的值函数 <span class="math inline">\(V_A\)</span> 满足如下条件：对任何初始状态 <span class="math inline">\((w,b)\)</span> 和任何的策略 <span class="math inline">\(S\)</span>，设羊群在策略 <span class="math inline">\(S\)</span> 下第 <span class="math inline">\(n\)</span> 个魔法时刻结束后的状态为 <span class="math inline">\((W_n,B_n)\)</span>，序列 <span class="math inline">\(\{V_A(W_n,B_n),n=0,1,\ldots\}\)</span>是上鞅，则策略 <span class="math inline">\(A\)</span> 就是最优的。</p></blockquote><p>注意这里是把任一策略 <span class="math inline">\(S\)</span>下的状态序列 <span class="math inline">\((W_n, B_n)\)</span> 代入策略<span class="math inline">\(A\)</span> 的值函数中。</p><p>证明非常简单：对任何策略 <span class="math inline">\(S\)</span>，由于其吸收状态 <span class="math inline">\((W_\infty,B_\infty)\)</span> 中必有一个分量是0，从而由值函数边界条件 <span class="math inline">\((\ref{eq:boundary})\)</span> 有 <span class="math inline">\(B_\infty=V_A(W_\infty,B_\infty)\)</span>，所以<span class="math display">\[\mathbb{E}[B_\infty]=\mathbb{E}[V_A(W_\infty,B_\infty)]\leq\mathbb{E}[V_A(w,b)]=V_A(w,b).\]</span> 其中最后一个等号是因为 <span class="math inline">\(V_A(w,b)\)</span>是一个常数，常数的期望等于自身。</p><p>Williams 直接「猜出」了策略 <span class="math inline">\(A\)</span>：</p><blockquote><p><strong>策略 <span class="math inline">\(A\)</span></strong>：如果当前黑绵羊的数量多于白绵羊，则什么也不做；否则就把白绵羊的数量变为黑绵羊的数量减1。</p></blockquote><p>显然 <span class="math inline">\(V_A\)</span> 有如下性质：</p><div id="recurrence" class="statement sta_v_a______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label"><span class="math inline">\(V_A\)</span> 的递推关系</span>.</span></p><ol type="1"><li>边界条件 <span class="math inline">\(V_A(0,b)=b\)</span>，<span class="math inline">\(V_A(w,0)=0\)</span>。</li><li><span class="math inline">\(V_A(w,b)=V_A(w-1,b), w\geqb&gt;0\)</span>。</li><li><span class="math inline">\(V_A(w,b)=\frac{w}{w+b}V_A(w+1,b-1)+\frac{b}{w+b}V_A(w-1,b+1)\)</span>,<span class="math inline">\(b&gt;w&gt;0\)</span>。</li></ol></div><p><span class="math inline">\(V_A\)</span> 由边界条件 1 和递推关系 2, 3完全决定。</p><p>从定义上看，关系 2 只在一半的区域上成立，而关系 3则在另一半的区域上成立。但是花费一番功夫，我们其实可以证明它们各自的「弱形式」在整个区域上都是对的：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>在区域 <span class="math inline">\(\Omega\)</span> 上，<span class="math inline">\(V_A\)</span> 函数满足如下的不等式：</p><ol start="4" type="1"><li><span class="math inline">\(V_A(w,b)\geq V_A(w-1,b),w&gt;0\)</span>。</li><li><span class="math inline">\(V_A(w,b)\geq\frac{w}{w+b}V_A(w+1,b-1)+\frac{b}{w+b}V_A(w-1,b+1),w&gt;0,b&gt;0\)</span>。</li></ol></div><p>4 表明如果男孩执行移走白绵羊的操作，则他得到的黑绵羊的期望会下降； 5表明如果男孩不执行操作，而是让系统自发改变状态的话，最终得到的黑绵羊的期望仍然会下降。总之无论男孩策略如何，<span class="math inline">\(\{ V_A(W_n,B_n)\}\)</span> 总是一个上鞅！因此策略<span class="math inline">\(A\)</span> 确实是最优的。</p><p>引理的证明是纯粹的分析，过程比较繁琐，我把它留给 Williams 的教材第15.3 节。写出 <span class="math inline">\(V(w,b)\)</span>的显式表达式来是很难的，Williams 证明了 <span class="math display">\[\lim_{k\to\infty}V(k,k)-(2k+\frac{\pi}{4}-\sqrt{\pik})=0.\label{eq:vkk}\tag{$\ast\ast$}\]</span> 因此如果开始有黑、白绵羊各10000 只，则策略 <span class="math inline">\(A\)</span>下黑绵羊的期望数目大约是 19824 只。</p><p>我对 Williams给出的估计不太放心，于是用书中给出的递推关系写了一段代码验证了一下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> *<br><br>pi = <span class="hljs-number">3.14159265358979</span><br>getcontext().prec = <span class="hljs-number">20</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">solve_sheep</span>(<span class="hljs-params">n</span>):<br>    p = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    v = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    v[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    p[<span class="hljs-number">1</span>] = Decimal(<span class="hljs-number">0.5</span>)<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        p[k] = (<span class="hljs-number">1</span> - <span class="hljs-number">1</span> / Decimal(<span class="hljs-number">2</span> * k)) * p[k - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        w = (<span class="hljs-number">1</span> - p[k]) / (<span class="hljs-number">1</span> + p[k])<br>        v[k + <span class="hljs-number">1</span>] = w * v[k] + (<span class="hljs-number">1</span> - w) * (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">return</span> v[n]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">estimate_sheep</span>(<span class="hljs-params">n</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * n + pi / <span class="hljs-number">4</span> - (pi * n)**<span class="hljs-number">0.5</span><br><br><span class="hljs-built_in">print</span>(solve_sheep(<span class="hljs-number">10000</span>))<br><span class="hljs-built_in">print</span>(estimate_sheep(<span class="hljs-number">10000</span>))<br></code></pre></td></tr></tbody></table></figure><p>递推公式给出的真实值结果是 19823.5422285701，渐进公式给出的结果是19823.540013，准确的有点离谱啊！这真的有点刷新我对 Stirling公式的认知。</p><p>猜出最优策略、证明弱化的不等式、给出渐进公式，每一步都是神操作啊。</p><h1 id="附录">附录</h1><p>Williams 书中对渐进公式 <span class="math inline">\((\ref{eq:vkk})\)</span>的证明比较难读，我这里解释下其中的想法。关键是用对角线上的值 <span class="math inline">\(v_k=V(k,k)\)</span> 来表示出所有的 <span class="math inline">\(V(w, b),b&gt;w&gt;0\)</span>：</p><p><span class="math display">\[\begin{cases}V(k-c,k+c)=v_k+(2k-v_k)a_c,\\ V(k+1-c,k+c)=v_k+(2k+1-v_k)b_c.\end{cases}\]</span></p><p>其中</p><p><span class="math display">\[\begin{cases}a_c=2^{-(2k-2)}\sum\limits_{j=k}^{k+c-1}\dbinom{2k-1}{j},\\b_c=\left(2^{2k-1}+\frac{1}{2}\dbinom{2k}{k}\right)^{-1}\sum\limits_{j=k}^{k+c-1}\dbinom{2k}{j}.\end{cases}\]</span></p><p>Williams没有解释这组公式是怎么求出来的，它看起来很吓人，其实道理不复杂。我们用<span class="math inline">\(V(k-c,k+c)\)</span> 为例子来说明：</p><p>记 <span class="math inline">\(g(c) = V(k-c, k+c),0\leq c\leqk\)</span>，则 <span class="math inline">\(g(0)=v_k,\,g(k)=2k\)</span>，由前面 <a href="#recurrence" title="V_A 的递推关系"><span class="math inline">\(V_A\)</span> 的递推关系</a> 中的 3知其满足递推关系</p><p><span class="math display">\[g(c) = \frac{k-c}{2k}g(c-1) +\frac{k+c}{2k}g(c+1),\quad 1\leq c \leq k-1.\]</span> 这是一个 <span class="math inline">\([0,k]\)</span> 上的递推序列，并且已知边界条件<span class="math inline">\(g(0)\)</span> 和 <span class="math inline">\(g(k)\)</span>，我们来求解这个序列。</p><p>记</p><p><span class="math display">\[h(c) = \frac{g(c) - g(0)}{g(k)-g(0)} =\frac{g(c) - v_k}{g(k)-v_k}.\label{eq:hc}\tag{1}\]</span></p><p>则 <span class="math inline">\(h(c)\)</span>同样满足上述递推关系，但是边界条件为 <span class="math inline">\(h(0)=0\)</span>，<span class="math inline">\(h(k)=1\)</span>。于是</p><p><span class="math display">\[\begin{align}h(c+1)-h(c)&amp;=\frac{k-c}{k+c}(h(c)-h(c-1))\\&amp;=\cdots\\&amp;=\frac{(k-c)\cdots(k-1)}{(k+c)\cdots(k+1)}(h(1)-h(0))\\&amp;=\frac{\dbinom{2k-1}{k+c}}{\dbinom{2k-1}{k}}h(1).\label{eq:hrec}\tag{2}\end{align}\]</span></p><p>利用 <span class="math inline">\((\ref{eq:hrec})\)</span>我们可以解出 <span class="math inline">\(h(1)\)</span> 来：</p><p><span class="math display">\[1=h(k)=\sum_{c=0}^{k-1}\big(h(c+1)-h(c)\big)=h(1)\frac{\sum_{c=0}^{k-1}\dbinom{2k-1}{k+c}}{\dbinom{2k-1}{k}}=h(1)\dfrac{2^{2k-2}}{\dbinom{2k-1}{k}}.\]</span></p><p>即 <span class="math inline">\(h(1)=2^{-(2k-2)}\binom{2k-1}{k}\)</span>。再次利用<span class="math inline">\((\ref{eq:hrec})\)</span> 可得</p><p><span class="math display">\[h(c)=\sum_{j=0}^{c-1}\big(h(j)-h(j-1)\big)=\sum_{j=0}^{c-1}\frac{\dbinom{2k-1}{k+j}}{\dbinom{2k-1}{k}}h(1)=2^{-(2k-2)}\sum_{j=k}^{k+c-1}\dbinom{2k-1}{j}.\]</span></p><p>将上式代入 <span class="math inline">\((\ref{eq:hc})\)</span>即得结论。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Williams1991" class="csl-entry" role="listitem">Williams, David. 1991. <em>Probability with Martingales</em>. CambridgeUniversity Press.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>星际迷航问题</title>
      <link href="/star-trek/"/>
      <url>/star-trek/</url>
      
        <content type="html"><![CDATA[<div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"></span>一艘太空船正在宇宙中做星际航行时，飞船的控制系统出了故障，飞船不能正常地进行空间跳跃，而是只能预先设定一个距离，然后以此距离进行一次方向完全随机的跳跃。现在飞船想要返回太阳系。假设太阳系的半径是<span class="math inline">\(r\)</span>，发生故障时飞船与太阳的距离为<span class="math inline">\(R&gt;r\)</span>。好消息是在每个时刻，飞船能够知道自身与太阳系的距离。</p><p>求证：不论采用怎样的跳跃策略，飞船返回太阳系的概率都小于 <span class="math inline">\(r/R\)</span>；但是对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，可以采取适当的策略，使得飞船返回太阳系的概率大于<span class="math inline">\((r-\epsilon)/R\)</span>，即 <span class="math inline">\(r/R\)</span> 是最优概率。这个最优策略是什么？</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这里返回太阳系是指飞船落入开球 <span class="math inline">\(\{|x|&lt; r\}\)</span> 中。</p></div><p>这个问题是教材 <span class="citation" data-cites="Williams1991">(<a href="#ref-Williams1991" role="doc-biblioref">Williams 1991</a>)</span>中的一道习题。这个问题的设定很有趣，但是给出一个基于测度论的严格解答却并不轻松。下面是我的解答。</p><span id="more"></span><h1 id="预备知识">预备知识</h1><h2 id="冻结引理">“冻结”引理</h2><p>设 <span class="math inline">\(X,Y\)</span> 是两个随机变量，<span class="math inline">\(\varphi\)</span> 是可测函数。条件期望 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|X]\)</span>是一个关于 <span class="math inline">\(\sigma(X)\)</span>可测的随机变量，根据 Doob-Dynkin 引理，它可以写成 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|X]=g(X)\]</span>的形式，其中 <span class="math inline">\(g\)</span> 是一个 Borel可测函数。但是这个 <span class="math inline">\(g\)</span>具体是什么呢？下面的 freezing lemma <span class="citation" data-cites="Williams1991">(<a href="#ref-Williams1991" role="doc-biblioref">Williams 1991, sec. 9.10</a>)</span> or <span class="citation" data-cites="Durrett2019">(<a href="#ref-Durrett2019" role="doc-biblioref">Durrett 2019, sec. 4.1</a>)</span>告诉我们，在一定条件下，我们可以这样计算 <span class="math inline">\(g\)</span>：先将 <span class="math inline">\(X\)</span> 冻结为一个实数值 <span class="math inline">\(x\)</span>，上式的右边变成 <span class="math inline">\(g(x)\)</span>，左边变成 <span class="math inline">\(\{X=x\}\)</span> 条件下的期望 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|X=x]=\mathop{\mathrm{\mathbb{E}}}\varphi(x,Y).\]</span>即 <span class="math inline">\(g(x)=\mathop{\mathrm{\mathbb{E}}}\varphi(x,Y)\)</span>。</p><div id="freeze" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span>是一个概率空间，<span class="math inline">\(X, Y\)</span>是两个取值在某可测空间 <span class="math inline">\((S,\mathcal{S})\)</span> 中的随机变量，子 <span class="math inline">\(\sigma\)</span> 域 <span class="math inline">\(\mathcal{G}\subseteq\mathcal{F}\)</span> 满足<span class="math inline">\(X\in\mathcal{G}\)</span> 且 <span class="math inline">\(\mathcal{G}\)</span> 与 <span class="math inline">\(Y\)</span> 独立。可测函数 <span class="math inline">\(\varphi: S\times S\to\mathbb{R}\)</span> 满足<span class="math inline">\(\varphi\)</span> 非负或者 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}|\varphi(X,Y)|&lt;\infty\)</span>。令 <span class="math inline">\(g(x)=\mathop{\mathrm{\mathbb{E}}}\varphi(x,Y)\)</span>，则 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|\mathcal{G}]=g(X).\]</span></p></div><p>在进入证明之前，我们来看个例子：</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>设 <span class="math inline">\(X, Y\)</span>是两个独立的随机变量，<span class="math inline">\(Y\)</span> 服从的是<span class="math inline">\([0, 1]\)</span> 上的均匀分布，<span class="math inline">\(X\)</span> 服从的分布我们可以不用关心。问条件期望<span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\sin(XY)|X]\)</span>是什么？</p><p>这相当于在 <a href="#freeze" title="引理 1.1">引理 1.1</a> 中取 <span class="math inline">\(\varphi(X,Y)=\sin(XY)\)</span> 和 <span class="math inline">\(\mathcal{G}=\sigma(X)\)</span>。<a href="#freeze" title="引理 1.1">引理 1.1</a> 告诉我们可以把 <span class="math inline">\(\sin(XY)\)</span> 中的 <span class="math inline">\(X\)</span> 冻结为常数 <span class="math inline">\(X=x\)</span>，把 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\sin(XY)|X]\)</span>视作关于常数 <span class="math inline">\(x\)</span> 的积分 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\sin(xY)]=\int_0^1\sin(xy)\,\mathrm{d}y = \frac{1}{x}\int_0^x\sin(z)\,\mathrm{d}z=\frac{1-\cos x}{x}.\]</span> 然后把 <span class="math inline">\(x\)</span> 解冻为 <span class="math inline">\(X\)</span> 即得 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\sin(XY)|X] =\frac{1-\cos X}{X}.\]</span></p></div><p><a href="#freeze" title="引理 1.1">引理 1.1</a> 中的可测空间 <span class="math inline">\((S,\mathcal{S})\)</span> 可以是多维空间 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>，<span class="math inline">\(X,Y\)</span> 也可以是独立的随机向量。即如果 <span class="math inline">\(\varphi(X_1,\ldots,X_n,Y_1,\ldots,Y_m)\)</span>是关于随机变量的可测函数，<span class="math inline">\(\sigma(X_1,\ldots,X_n)\subset\mathcal{G}\)</span>并且 <span class="math inline">\(\mathcal{G}\)</span> 和 <span class="math inline">\(\sigma(Y_1,\ldots,Y_m)\)</span> 独立，那么条件期望<span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|\mathcal{G}]\)</span>就是一个以 <span class="math inline">\((x_1,\ldots,x_n)\)</span>为参变元的多重积分 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(x_1,\ldots,x_n,Y_1,\ldots,Y_m)]=g(x_1,\ldots,x_n).\]</span></p><p><strong>证明</strong>：我们要证明对任何可测集 <span class="math inline">\(C\in\mathcal{G}\)</span> 有</p><p><span class="math display">\[\int_C \varphi(X, Y)\mathrm{d}\mu =\int_C g(X)\mathrm{d}\mu.\]</span> 当 <span class="math inline">\(\varphi(x,y)=\mathbb{1}_A(x)\mathbb{1}_B(y)\)</span> 时，<span class="math inline">\(g(x)=\mathbb{1}_A(x)\mathbb{P}(\{Y\inB\})\)</span>，从而 <span class="math display">\[\begin{align*}\int_C\mathbb{1}_A(X)\mathbb{1}_B(Y)\mathrm{d}\mu&amp;=\mathbb{P}(\{X\inA\}\cap C\cap\{Y\in B\})\\&amp;=\mathbb{P}(\{X\in A\}\capC)\cdot\mathbb{P}(\{Y\inB\})\\&amp;=\int_C\mathbb{1}_A(X)\mathrm{d}\mu\cdot\mathbb{P}(\{Y\inB\})\\&amp;=\int_C g(X)\mathrm{d}\mu.\end{align*}\]</span></p><p>于是结论对所有形如 <span class="math inline">\(A\times B\)</span>的集合的示性函数成立。这样的示性函数构成一个 <span class="math inline">\(\pi\)</span>- 系。根据可测函数的单调类定理(monotone class theorem)，结论对所有非负或者可积函数都成立。<span class="math inline">\(\blacksquare\)</span></p><h2 id="newton-势">Newton 势</h2><div id="newton-potential" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B=B(A,R)\)</span> 是 <span class="math inline">\(\mathbb{R}^3\)</span> 中以点 <span class="math inline">\(A\)</span> 为中心，半径为 <span class="math inline">\(R\)</span> 的球，<span class="math inline">\(X\)</span> 是球面上均匀分布的随机点，则 <span class="math inline">\(X\)</span> 与原点 <span class="math inline">\(O\)</span> 之间距离倒数的期望为 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}\frac{1}{|X|}=\begin{cases}1/a&amp; a&gt;R,\\ 1/R &amp; a\leq R.\end{cases}\]</span> 其中 <span class="math inline">\(a=|A|\)</span> 是 <span class="math inline">\(A\)</span> 与原点之间的距离。</p></div><p>这个引理其实是我们都熟悉的高中物理知识：假设以 <span class="math inline">\(A\)</span> 为中心，半径为 <span class="math inline">\(R\)</span> 的球壳上有总量为 1的均匀分布的电荷，则球壳表面和内部的电势处处等于 <span class="math inline">\(1/R\)</span>，球壳外部任意一点 <span class="math inline">\(P\)</span> 的电势等于 <span class="math inline">\(P\)</span> 和球心距离的倒数，即 <span class="math inline">\(1/|P-A|\)</span>（不计物理常数），此即为结论。</p><p>当然这不是一个严格的证明，实际上这个积分正是 Newton势函数的简单情形。由于这不是本文的重点，就不再展开讲了，读者可以参考<span class="citation" data-cites="Donoghue2014">(<a href="#ref-Donoghue2014" role="doc-biblioref">Donoghue 2014, chap.8</a>)</span>。</p><h2 id="随机向量的内积">随机向量的内积</h2><p>下面这个命题相当于说：把球面上均匀分布的向量投影到“独立的随机方向”上，跟投到<span class="math inline">\(x\)</span> 轴上的分布是一样的。</p><div id="random-inn" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题1.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(U\)</span> 是定义在某概率空间 <span class="math inline">\((\Omega,\mathcal F,\mathbb P)\)</span> 中，在<span class="math inline">\(\mathbb R^d\)</span>的单位球面上均匀分布的随机向量，<span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\mathcal G\subset \mathcal F\)</span> 与 <span class="math inline">\(U\)</span> 独立。<span class="math inline">\(V\)</span> 是 <span class="math inline">\(\mathcalG\)</span>- 可测的 <span class="math inline">\(\mathbb R^d\)</span>中的单位向量。记 <span class="math inline">\(Y=U\cdot V\)</span>，则</p><ol type="1"><li><span class="math inline">\(Y\)</span> 与 <span class="math inline">\(\mathcal G\)</span> 独立。</li><li><span class="math inline">\(Y\)</span> 与 <span class="math inline">\(U^x\)</span> 同分布。</li></ol><p>这里 <span class="math inline">\(U^x\)</span> 表示 <span class="math inline">\(U\)</span> 的 <span class="math inline">\(x\)</span>- 分量。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(f:\mathbbR\to\mathbb R\)</span> 是任一有界 Borel 可测函数。根据冻结引理，我们有<span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[f(Y)\mid\mathcal G]= \mathop{\mathrm{\mathbb{E}}}[f(U\cdot V)\mid\mathcal G]=g(V),\quadg(v)=\mathop{\mathrm{\mathbb{E}}}[f(U\cdot v)].\]</span>换句话说，在计算 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[f(U\cdotV)\mid\mathcal G]\)</span> 时，我们可以先将 <span class="math inline">\(V\)</span> 视作一个常数单位向量 <span class="math inline">\(v\)</span>，计算 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[f(U\cdotv)]\)</span>，然后再将 <span class="math inline">\(v\)</span>替换回随机变量 <span class="math inline">\(V\)</span>。</p><p>由于 <span class="math inline">\(U\)</span> 服从 <span class="math inline">\(\mathbb R^d\)</span> 中单位球面上的均匀分布，所以<span class="math inline">\(U\cdot v\)</span>的分布是旋转不变的，即任何单位向量 <span class="math inline">\(v\)</span> 给出的 <span class="math inline">\(U\cdot v\)</span> 具有相同的分布。从而 <span class="math inline">\(f(U\cdot v)\)</span>的分布也相同。所以我们可以不妨取 <span class="math inline">\(v=e_1\)</span> 为 <span class="math inline">\(x\)</span> 轴的方向向量，得到 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[f(U\cdotv)]=\mathop{\mathrm{\mathbb{E}}}[f(U^x)].\]</span>右边是一个常数，它不依赖于 <span class="math inline">\(\omega\)</span>，所以它必然还等于 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[f(Y)\mid\mathcalG]\)</span> 的期望 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[f(Y)]\)</span>。于是<span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[f(Y)\mid\mathcalG]=\mathop{\mathrm{\mathbb{E}}}[f(U^{x})] =\mathop{\mathrm{\mathbb{E}}}[f(Y)].\]</span></p><ul><li><span class="math inline">\(Y\)</span> 与 <span class="math inline">\(\mathcal G\)</span> 独立是 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[f(Y)\mid\mathcalG]=\mathop{\mathrm{\mathbb{E}}}[f(Y)]\)</span> 的直接结论：对任何 Borel可测集 <span class="math inline">\(A\subset\mathbb R\)</span> 和 <span class="math inline">\(B\in\mathcal{G}\)</span>，取 <span class="math inline">\(f=\mathbb{1}_A\)</span>，利用 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[f(Y)\mid\mathcal{G}]=\mathop{\mathrm{\mathbb{E}}}[f(Y)]=\mathbb{P}(Y\inA).\]</span> 以及条件期望的塔式性质，可得 <span class="math display">\[\mathbb P(Y\in A,\,B)=\mathbbE[\mathbb{1}_B\mathbb{1}_{\{Y\in A\}}]=\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_B\mathbb E[\mathbb{1}_{\{Y\inA\}}\mid \mathcal G]]=\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_B\mathbb P(Y\in A)]=\mathbbP(Y\in A)\mathbb P(B).\]</span> 这正是 <span class="math inline">\(Y\)</span> 与 <span class="math inline">\(\mathcalG\)</span> 独立的定义。</li><li><span class="math inline">\(Y\)</span> 与 <span class="math inline">\(U^x\)</span> 同分布是 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[f(U^x)]=\mathop{\mathrm{\mathbb{E}}}[f(Y)]\)</span>的直接结论。这一点是显然的。</li></ul><p><span class="math inline">\(\blacksquare\)</span></p><h1 id="建立模型">建立模型</h1><p>我们开始正式求解本文开头的问题。</p><ol type="1"><li><p>初始时刻为 0，太阳系是以原点为圆心，半径为 <span class="math inline">\(r\)</span> 的球，飞船初始位置在 <span class="math inline">\((R,0,0)\)</span> 处。</p></li><li><p>设 <span class="math inline">\(\{U_n\}_{n\geq 1}\)</span>是定义在某个概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\)</span>上的一组独立同分布的、在单位球面上均匀分布的随机向量，它们表示飞船每次空间跳跃的随机方向。并设<span class="math inline">\(\mathcal{F}_n=\sigma(U_1,\ldots,U_n)\)</span> 以及<span class="math inline">\(\mathcal{F}_0=(\Omega,\emptyset)\)</span>。</p></li><li><p>设第 <span class="math inline">\(n\)</span> 次空间跳跃的距离为<span class="math inline">\(l_n(n\geq1)\)</span>，由于 <span class="math inline">\(l_n\)</span> 是根据 <span class="math inline">\(n\)</span> 时刻之前的信息决定的，所以 <span class="math inline">\(l_n\)</span> 关于 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 可测。</p></li><li><p>设第 <span class="math inline">\(n\)</span>次空间跳跃后飞船的坐标为 <span class="math inline">\(X_n\)</span>，那么<span class="math display">\[X_n=X_{n-1} + l_n U_n.\quadn=1,2,\ldots.\]</span> 其中 <span class="math inline">\(X_0=(R,0,0)\)</span> 是飞船的初始位置。</p></li><li><p>设 <span class="math inline">\(T\)</span>是飞船首次返回太阳系的时间： <span class="math display">\[T = \inf\,\{n\mid X_n\in B(0,r)\},\]</span>则 <span class="math inline">\(T\)</span>的取值范围是 <span class="math inline">\(\mathbb{N^+}\cup\{+\infty\}\)</span>。我们要估算的是事件<span class="math inline">\(\{T&lt;+\infty\}\)</span>的概率，这正是飞船能够在有限时间内回到太阳系的概率。</p></li></ol><p>现在我们着手研究一下飞船的运动规律。</p><p>记 <span class="math inline">\(|X_n|\)</span> 为第 <span class="math inline">\(n\)</span>次跳跃以后飞船与太阳系的距离，我们来推导 <span class="math inline">\(|X_n|\)</span> 和 <span class="math inline">\(|X_{n+1}|\)</span> 之间的关系。</p><p>对 <span class="math inline">\(\mathcal{F}=\mathcal{F}_n,\,\mathcal{G}=\mathcal{F}_{n-1},\,X=(X_{n-1},l_n),\,Y=U_n,\,\varphi(X,Y)=1/|X_{n-1}+l_nY|\)</span> 应用 <a href="#freeze" title="引理 1.1">引理 1.1</a> 和 <a href="#newton-potential" title="引理 1.2">引理 1.2</a> 得到</p><p><span class="math display">\[\mathop{\mathrm{\mathbb{E}}}\left[\left.\frac{1}{|X_n|}\right|\mathcal{F}_{n-1}\right]=\mathop{\mathrm{\mathbb{E}}}\left.\frac{1}{\left|X_{n-1}+l_nU_n\right|}\right|_{X_{n-1}=A}\leq\frac{1}{|A|}=\frac{1}{|X_{n-1}|}.\]</span></p><p>这里由于 <span class="math inline">\(X_{n-1}\)</span> 和 <span class="math inline">\(l_n\)</span> 都是关于 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 可测的，而 <span class="math inline">\(U_n\)</span> 和 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 是独立的，所以 <a href="#freeze" title="引理 1.1">引理 1.1</a> 的条件是满足的。</p><p>总结一下：</p><div id="supermartingale" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"></span>无论采取何种策略，<span class="math inline">\(\left\{\dfrac{1}{|X_n|}\right\}_{n\geq0}\)</span>总是一个上鞅。如果跳跃距离 <span class="math inline">\(l_n\)</span>满足对任何 <span class="math inline">\(n\geq1\)</span> 有 <span class="math inline">\(l_n\leq |X_{n-1}|\)</span>，则 <span class="math inline">\(\left\{\dfrac{1}{|X_n|}\right\}_{n\geq0}\)</span>还是一个鞅。</p></div><p><strong>证明</strong>：只要再说明 <span class="math inline">\(\dfrac{1}{|X_n|}\)</span> 可积即可。由于 <span class="math inline">\(\dfrac{1}{|X_n|}\)</span> 非负，因此条件期望 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}\left[\dfrac{1}{|X_n|}\bigg|\mathcal{F}_{n-1}\right]\)</span>有定义，并且上面已经证明了它小于等于 <span class="math inline">\(\dfrac{1}{|X_{n-1}|}\)</span>，于是 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}\left[\dfrac{1}{|X_n|}\right]=\mathop{\mathrm{\mathbb{E}}}\left[\mathop{\mathrm{\mathbb{E}}}\left[\dfrac{1}{|X_n|}\bigg|\mathcal{F}_{n-1}\right]\right]\leq\mathop{\mathrm{\mathbb{E}}}\left[\dfrac{1}{|X_{n-1}|}\right].\]</span>对 <span class="math inline">\(n\)</span> 归纳即可。<span class="math inline">\(\blacksquare\)</span></p><p><a href="#supermartingale" title="定理 2.1">定理 2.1</a>是解决整个问题最关键的一步，有了它就海阔天空，没有它就寸步难行。由它我们立刻可以导出一个有趣的观察：由于非负上鞅必然几乎处处收敛，因此<span class="math inline">\(\lim\limits_{n\to\infty}|X_n|\)</span>几乎处处存在。这有两种可能：<span class="math inline">\(\lim\limits_{n\to\infty}|X_n|=+\infty\)</span>或者 <span class="math inline">\(\lim\limits_{n\to\infty}|X_n|&lt;+\infty\)</span>。所以飞船要么飞向无穷远，即迷失在宇宙的深处，要么被吸引到某个有限的位置。</p><p>现在我们可以证明：</p><div id="lessthan" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.2</span>.</span><span class="statement-spah"></span>不论飞船采取怎样的策略，返回太阳系的概率都严格小于 <span class="math inline">\(r/R\)</span>。</p></div><p><strong>证明</strong>：记 <span class="math inline">\(Z_n=\dfrac{1}{|X_n|}\)</span>，根据 <a href="#supermartingale" title="定理 2.1">定理 2.1</a> <span class="math inline">\(\{Z_n\}_{n\geq0}\)</span> 是非负上鞅，所以 <span class="math inline">\(Z_\infty=\lim\limits_{n\to\infty}Z_n\)</span>几乎处处存在。考虑停时 <span class="math inline">\(T\)</span>截断的非负上鞅序列 <span class="math inline">\(\{Z_{T\wedgen}\}\)</span>。由非负可积函数列的 Fatou 引理有 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]\leq\varliminf_{n\to\infty}\mathop{\mathrm{\mathbb{E}}}[Z_{T\wedgen}]\leq \mathop{\mathrm{\mathbb{E}}}[Z_0]=\frac{1}{R}.\]</span>另一方面</p><p><span class="math display">\[\begin{aligned}\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]&amp;=\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]+\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_n\mathbb{1}_{\{T=\infty\}}]\\&amp;\geq \mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]\geq\frac{\mathbb{P}(T&lt;\infty)}{r}.\end{aligned}\]</span></p><p>其中最后一个不等号是因为在 <span class="math inline">\(\{T&lt;\infty\}\)</span> 上有 <span class="math inline">\(Z_T\geq 1/r\)</span>。综合这两个不等式就得到了<span class="math inline">\(\mathbb{P}(T&lt;\infty)\leqr/R\)</span>，即任何策略下飞船最终返回太阳系的概率不大于 <span class="math inline">\(r/R\)</span>。</p><p>要证明这个概率是严格小于 <span class="math inline">\(r/R\)</span>的，只要证明上面式子中，最后的不等号是严格成立的： <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]&gt;\frac{\mathbb{P}(T&lt;\infty)}{r}.\]</span></p><p>然而在事件 <span class="math inline">\(\{T&lt;\infty\}\)</span>上，由于 <span class="math inline">\(X_T&lt;r\)</span>，所以 <span class="math inline">\(Z_T&gt;1/r\)</span>，所以上面的不等式成立。<span class="math inline">\(\blacksquare\)</span></p><h1 id="对策略的进一步分析">对策略的进一步分析</h1><p>现在我们把注意力转移到飞船不能返回太阳系这个事件上来。前面已经说过，飞船的运动只有两种可能，迷失在无穷远处或者被禁锢在一个有限的区域内，所以如果飞船不能返回太阳系，则飞船要么飞向无穷远，要么在太阳系之外的一个有限区域内打转。我们想知道，怎么判断这两种情形哪一种会发生呢？</p><p>举个例子，考虑这样一个明显不合理的策略：第 <span class="math inline">\(n\)</span> 次的跳跃距离总是设定为 <span class="math inline">\(1/2^n\)</span>，在这个策略下飞船永远飞不出一个半径为1 的空间，所以这种策略是应该避免的。</p><p>你可以注意到这个糟糕的策略的问题出在跳跃距离之和是收敛的。如果我们强迫每次跳跃的距离都大于一个固定的值<span class="math inline">\(\epsilon\)</span>（<span class="math inline">\(\epsilon\)</span>可以是任意的正数），就可以避免这种情形出现，这就是下面的定理：</p><div id="goinf" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\epsilon\)</span> 是任一正数 <span class="math display">\[E:=\{\omega:\T(\omega)=\infty,\  l_n(\omega)\geq\epsilon,\ \forall n\geq1\},\]</span>则我们有 <span class="math display">\[\lim_{n\to\infty}|X_n|=+\infty,\quad \text{for a.e.}\ \omega\in E.\]</span></p></div><p><strong>证明</strong>：记 <span class="math inline">\(V_n=\frac{X_{n}}{|X_{n}|}\)</span> 是 <span class="math inline">\(X_n\)</span> 对应的单位方向向量，<span class="math inline">\(Y_n=U_n\cdot V_{n-1}\)</span>。由 <a href="#random-inn" title="命题 1.3">命题 1.3</a>，<span class="math inline">\(\{Y_n\}\)</span> 是 i.i.d 序列，其分布等于 <span class="math display">\[U_1^x\sim{\rm Uniform}[-1,1].\]</span>（三维空间中球面上均匀分布的随机向量，其每个坐标分量服从 <span class="math inline">\([-1,1]\)</span> 上的均匀分布）</p><p>由 <span class="math inline">\(X_n=X_{n-1}+l_nU_n\)</span> 可得 <span class="math display">\[|X_n|^2=|X_{n-1}|^2+2l_n|X_{n-1}|Y_n+l_n^2.\tag{$\ast$}\label{eq:jump}\]</span>令 <span class="math inline">\(B_n=\{Y_n\geq 1/2\}\)</span>，则 <span class="math inline">\(\{B_n\}\)</span> 是独立事件序列，对每个 <span class="math inline">\(n\)</span> 有 <span class="math inline">\(\mathbb{P}(B_n)=1/4\)</span>。所以 <span class="math display">\[\sum_{n=1}^\infty\mathbb P(B_n)=\sum_{n=1}^\infty1/4=\infty.\]</span> 由 second Borel-Cantelli lemma 有 <span class="math inline">\(\mathbb{P}(\{B_n\ \text{i.o.}\})=1\)</span>。</p><p>另一方面，在事件 <span class="math inline">\(B_n\)</span>上有如下不等式： <span class="math display">\[|X_n|^2\geq|X_{n-1}|^2+l_n|X_{n-1}|+l_n^2\geq(|X_{n-1}|+l_n/2)^2.\]</span>结合已知在事件 <span class="math inline">\(E\)</span> 上有 <span class="math inline">\(l_n\geq\epsilon\)</span>，所以在事件 <span class="math inline">\(B_n\cap E\)</span> 上有 <span class="math display">\[|X_n|\geq |X_{n-1}|+\epsilon/2,\quad\omega\inB_n\cap E.\]</span> 由于 <span class="math inline">\(\mathbb{P}(\{B_n\\text{i.o.}\})=1\)</span>，所以对几乎处处的 <span class="math inline">\(\omega\in E\)</span>，<span class="math inline">\(|X_n|\geq |X_{n-1}|+\epsilon/2\)</span> 对无穷多个<span class="math inline">\(n\)</span> 成立。对这些 <span class="math inline">\(\omega\)</span>，<span class="math inline">\(\lim\limits_{n\to\infty}|X_n|\)</span>不可能是一个有限点，所以必然是 <span class="math inline">\(\lim\limits_{n\to\infty}|X_n|=\infty\)</span>。即飞船在<span class="math inline">\(E\)</span> 上几乎处处飞向无穷远。<span class="math inline">\(\blacksquare\)</span></p><h1 id="最优策略">最优策略</h1><p>现在我们已经知道飞船返回太阳系的概率总是小于 <span class="math inline">\(r/R\)</span>，也知道只要策略得当，就可以避免飞船在原地打转的糟糕情况。接下来的问题是：最好的策略到底是什么？</p><p>我们揭晓答案：最佳策略是在恰好穿过太阳系表面 <span class="math inline">\(\epsilon\)</span> 处时”刹车”。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.1</span>.</span><span class="statement-spah"></span>定义如下的跳跃策略：在准备第 <span class="math inline">\(n\)</span> 次跳跃时，如果飞船已经在太阳系内，则令<span class="math inline">\(l_n=0\)</span>，否则令 <span class="math inline">\(l_n=|X_{n-1}|-r+\epsilon\)</span>，这里 <span class="math inline">\(0&lt;\epsilon&lt;r\)</span>。在这个跳跃策略下，飞船返回太阳系的概率大于<span class="math inline">\((r-\epsilon)/R\)</span>。</p></div><p>注意在这个策略中总是有 <span class="math inline">\(l_n&lt;|X_{n-1}|\)</span>，根据 <a href="#supermartingale" title="定理 2.1">定理 2.1</a>，<span class="math inline">\(\{Z_n=1/|X_n|\}\)</span>实际上是一个鞅。此外由于总是有 <span class="math inline">\(|X_n|\geqr-\epsilon\)</span>，所以 <span class="math inline">\(Z_n\leq1/(r-\epsilon)\)</span>，即 <span class="math inline">\(\{Z_n\}\)</span> 被常数 <span class="math inline">\(1/(r-\epsilon)\)</span> 所控制。</p><p>接下来的证明不过是 <a href="#lessthan" title="定理 2.2">定理 2.2</a>证明的重复：</p><p>这次根据控制收敛定理有 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]=\lim_{n\to\infty}\mathop{\mathrm{\mathbb{E}}}[Z_{T\wedgen}]=\mathop{\mathrm{\mathbb{E}}}[Z_0]=\frac{1}{R}.\]</span> 另一方面<span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]=\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]+\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_n\mathbb{1}_{\{T=\infty\}}].\]</span>这个时候要注意到在 <span class="math inline">\(\{T=\infty\}\)</span>上总是有 <span class="math inline">\(l_n\geq\epsilon\)</span>，因此根据<a href="#goinf" title="定理 3.1">定理 3.1</a>的结论，飞船几乎必然飞向无穷远，即 <span class="math display">\[\lim_{n\to\infty}Z_n=0,\quad\omega\in\{T=\infty\}.\]</span> 所以 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]=\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]\leq\frac{1}{r-\epsilon}\mathbb{P}(T&lt;\infty).\]</span>综合两个式子就证明了 <span class="math inline">\(\mathbb{P}(T&lt;\infty)\geq(r-\epsilon)/R\)</span>。</p><h1 id="star-trek-3-最糟糕的跳跃策略">Star Trek 3: 最糟糕的跳跃策略</h1><p><span class="citation" data-cites="Williams1991">(<a href="#ref-Williams1991" role="doc-biblioref">Williams 1991</a>)</span>的习题 E12.3 提出了一个新问题：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"></span>如果每次总是把飞船的跳跃距离设定为当前飞船到太阳系的距离，即对<span class="math inline">\(n\geq1\)</span> 有 <span class="math inline">\(l_n=|X_{n-1}|\)</span>，求证 <span class="math display">\[\sum_{n=1}^\infty\frac{1}{|X_n|^2}&lt;\infty,\quad\mathrm{a.e.}\]</span></p></div><p><strong>证明</strong>：在 <span class="math inline">\((\ref{eq:jump})\)</span> 中取 <span class="math inline">\(l_n=|X_{n-1}|\)</span> 可得 <span class="math display">\[|X_n|^2 = |X_{n-1}|^2(2+2 Y_n).\]</span>两边取对数，并迭代可得 <span class="math display">\[\ln |X_n|^2 = \lnR^2 + \sum_{k=1}^n \ln(2+2Y_k).\]</span> 根据强大数定律， <span class="math display">\[\frac{1}{n}\sum_{k=1}^n \ln(2+2Y_k)\xrightarrow{\rm a.e.}\mu:=\mathbb{E}[\ln(2+2Y_1)] = \frac{1}{2}\int_{-1}^{1}\ln(2+2x)\,\mathrm{d}x = \ln 4-1&gt;0.\]</span> 任取正数<span class="math inline">\(0&lt;\alpha&lt;\mu\)</span>，则对几乎处处的<span class="math inline">\(\omega\)</span>，存在随机变量 <span class="math inline">\(N(\omega)\)</span> 使得当 <span class="math inline">\(n\geq N(\omega)\)</span> 时， <span class="math display">\[\sum_{k=1}^n \ln(2+2Y_k)\geq \alpha n.\]</span>于是对几乎处处的 <span class="math inline">\(\omega\)</span>，当 <span class="math inline">\(n\geq N(\omega)\)</span> 时有 <span class="math display">\[|X_n|^2\geq R^2e^{\alphan}\Longrightarrow\frac{1}{|X_n|^2}\leq \frac{1}{R^2}e^{-\alpha n},\quadn\geq N(\omega).\]</span> 因此几乎处处有 <span class="math inline">\(\sum_{n=1}^\infty1/|X_n|^2&lt;\infty\)</span>成立。<span class="math inline">\(\blacksquare\)</span></p><p>从 <span class="math inline">\(|X_n|^2\geq R^2e^{\alpha n}\)</span>你可以看到，这个策略简直是自杀：它几乎必然会导致飞船跑到外太空去，而且是以指数的速度！</p><h1 id="star-trek-2-剧情反转">Star Trek 2: 剧情反转</h1><p>故事在二维平面上神奇地反转了。Star Trek 3 中同样的策略 <span class="math inline">\(l_n=|X_{n−1}|\)</span> 在 <span class="math inline">\(\mathbb R^2\)</span> 中竟让飞船必然回家！</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"></span>假设飞船只能在一个固定的二维平面内跳跃，并且和 Star Trek 3中一样，每次跳跃的距离都等于当前飞船到太阳系中心的距离。求证：飞船以概率1 在有限时间内返回太阳系。</p></div><p>由于每次跳跃的长度等于当前半径，我们有和 Star Trek 3 中一样的关系：<span class="math display">\[|X_n|^2 =|X_{n-1}|^2(2+2Y_n).\]</span><span class="math inline">\(\{Y_n\}\)</span> 仍然是 i.i.d 序列，只不过<span class="math inline">\(Y_n\)</span>不再是区间上的均匀随机变量，而是二维单位圆上的余弦分量： <span class="math display">\[Y_k=\cos\theta_k,\quad \theta_k\sim{\rmUniform}[0,2\pi).\label{eq:jump2d}\tag{$\star$}\]</span>像上次一样，对两边取对数，我们得到 <span class="math display">\[\ln|X_n| = \ln R + \frac{1}{2}\sum_{k=1}^n \ln(2+2\cos\theta_k).\]</span>其中我们记 <span class="math display">\[W_k=\ln(2+2\cos\theta_k),\quadS_n=\sum_{k=1}^n W_k.\]</span> 作为微积分的两个小练习，你可以证明 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}W_k = 0,\quad\mathop{\mathrm{\mathbb{E}}}W_k^2 = \sigma^2 &lt; \infty.\]</span> 所以<span class="math inline">\(\{W_k\}\)</span> 是一个均值为 0, 方差有限的i.i.d 序列。</p><p>这正是中心极限定理派上用场的地方： <span class="math display">\[\frac{S_n}{\sigma\sqrt{n}}\xrightarrow{\ d\ }N(0,1).\]</span> 接下来我们按照 <span class="citation" data-cites="Williams1991">(<a href="#ref-Williams1991" role="doc-biblioref">Williams 1991</a>)</span> 中的提示：</p><p>固定一个正数 <span class="math inline">\(\alpha&gt;0\)</span>，令<span class="math display">\[A_n=\{S_n\le -\alpha\sigma\sqrtn\}.\]</span> 显然 <span class="math inline">\(\{A_n\\text{i.o.}\}\subset\{\varliminf S_n=-\infty\}\)</span>，这是因为 <span class="math inline">\(-\alpha\sigma\sqrt n\to-\infty\)</span>。</p><p>由 Fatou 引理，有 <span class="math display">\[\mathbb P(\{A_n\\text{i.o.}\})=\mathbb P(\limsup A_n)\ge \limsup_{n\to\infty}\mathbbP(A_n).\]</span> 而中心极限定理给出 <span class="math display">\[\lim_{n\to\infty}\mathbb P(A_n)=\lim_{n\to\infty}\mathbb P\left(\frac{S_n}{\sigma\sqrt n}\le-\alpha\right)=\Phi(-\alpha)&gt;0.\]</span> 于是 <span class="math display">\[\mathbb P(\varliminfS_n=-\infty)\ge\mathbb P(\{A_n\ \text{i.o.}\})\ge\Phi(-\alpha)&gt;0.\]</span> 但是等等，<span class="math inline">\(\{\varliminfS_n=-\infty\}\subset\sigma(U_1,U_2,\ldots)\)</span>是一个尾事件，只依赖无限未来的 <span class="math inline">\(U_n\)</span>。Kolmogorov 0-1律告诉我们，它不是概率 0 就是概率 1。但是既然它有正概率，那就只能是1。类似地，也有 <span class="math inline">\(\mathbb{P}(\{\varlimsupS_n=+\infty\})=1\)</span>。即对几乎处处的 <span class="math inline">\(\omega\)</span>，<span class="math inline">\(S_n\)</span> 在 <span class="math inline">\((-\infty,+\infty)\)</span> 之间作“折返跑”。</p><p>最后回到飞船。由 <span class="math inline">\((\ref{eq:jump2d})\)</span> 可得 <span class="math display">\[|X_n| = R\exp (S_n/2).\]</span> 由于 <span class="math inline">\(\mathbb{P}(\varliminf S_n = -\infty) =1\)</span>，所以 <span class="math inline">\(\mathbb{P}(\varliminf |X_n|= 0) = 1\)</span>。即以概率 1，<span class="math inline">\(|X_n|\)</span>可以无限多次小于任何的正值。所以飞船以概率 1 返回太阳系。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Donoghue2014" class="csl-entry" role="listitem">Donoghue, W. F. 2014. <em>Distributions and Fourier Transforms</em>.ISSN. Elsevier Science. <a href="https://books.google.com/books?id=P30Y7daiGvQC">https://books.google.com/books?id=P30Y7daiGvQC</a>.</div><div id="ref-Durrett2019" class="csl-entry" role="listitem">Durrett, Rick. 2019. <em>Probability: Theory and Examples</em>. 5th ed.Cambridge Series in Statistical and Probabilistic Mathematics. CambridgeUniversity Press.</div><div id="ref-Williams1991" class="csl-entry" role="listitem">Williams, David. 1991. <em>Probability with Martingales</em>. CambridgeUniversity Press.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Schur 多项式与钩长公式</title>
      <link href="/schur-polynomials-and-hook-length-formula/"/>
      <url>/schur-polynomials-and-hook-length-formula/</url>
      
        <content type="html"><![CDATA[<p>在数学中有那么一些问题，它们的表述简单而初等，但是解决起来却非常困难，往往需要相当的奇思妙想和深刻的工具。围绕这些问题。不同领域的数学相互交织，演绎出许多奇妙的故事。</p><p>Young表就是一个典型的例子，组合数学，表示论，概率论在这里发生了奇妙的交汇。</p><p>我们从一个有趣的问题开始：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span><span class="math inline">\(n\)</span>位选民要在一次选举中给 <span class="math inline">\(m\)</span>个候选人投票，每个选民只能投一票。已知第 <span class="math inline">\(i\)</span> 位候选人最终的得票数为 <span class="math inline">\(\lambda_i\)</span>，这里 <span class="math inline">\(\sum_{i=1}^m\lambda_i=n\)</span> 且 <span class="math inline">\(\lambda_1\geq\cdots\geq\lambda_m\)</span>。问题是：有多少种不同的得票序列，使得在投票过程中的任一时刻，对任何的<span class="math inline">\(i&lt;j\)</span>，第 <span class="math inline">\(i\)</span> 位候选人所得的票数总不少于第 <span class="math inline">\(j\)</span> 位候选人所得的票数？</p><p>举个例子，假设有 <span class="math inline">\(n=10\)</span> 位选民和<span class="math inline">\(m=4\)</span> 个候选人，则得票序列 <span class="math display">\[1, 2, 1, 3, 2, 1, 2, 4, 3, 1\]</span>表示第一个选民投票给 1 号，第二个选民投票给 2 号，第三个选民投票给 1号，第四个选民投票给 3 号，依次类推。符合问题要求的序列必须满足对任何<span class="math inline">\(1\leq k\leq n\)</span> 和 <span class="math inline">\(1\leq i&lt;j\leq m\)</span>，序列的前 <span class="math inline">\(k\)</span> 项中数字 <span class="math inline">\(i\)</span> 出现的次数都大于等于数字 <span class="math inline">\(j\)</span> 出现的次数。</p></div><p>虽然问题的表述很简单，但其实答案相当复杂，叫做钩长公式 (hook lengthformula)。钩长公式有好几个证明，但我最喜欢的证明是基于 Schur多项式的理论，接下来就来介绍它。</p><span id="more"></span><h1 id="schur-多项式的组合定义">Schur 多项式的组合定义</h1><p>设 <span class="math inline">\(\lambda=(\lambda_1,\lambda_2,\ldots)\)</span>是一个非负整数构成的序列，且只有有限多个非零项。如果它满足 <span class="math inline">\(\lambda_1\geq \lambda_2\geq\cdots\)</span>，则称<span class="math inline">\(\lambda\)</span>是一个整数分拆，简称分拆，并记 <span class="math inline">\(|\lambda|=\sum\limits_{i=1}^\infty\lambda_i\)</span>。由于 <span class="math inline">\(\lambda\)</span>只有有限多项非 0，<span class="math inline">\(|\lambda|\)</span>总是有限的。如果 <span class="math inline">\(|\lambda|=k\)</span> 就称<span class="math inline">\(\lambda\)</span> 是整数 <span class="math inline">\(k\)</span> 的分拆，记作 <span class="math inline">\(\lambda\vdash k\)</span>。此外，记 <span class="math inline">\(l(\lambda)\)</span> 为 <span class="math inline">\(\lambda\)</span> 中非零项的个数。</p><p>对每个分拆 <span class="math inline">\(\lambda\vdashk\)</span>，可以用一个图 <span class="math inline">\(F_\lambda\)</span>来表示它，称为 <span class="math inline">\(\lambda\)</span> 的 Ferrers图。<span class="math inline">\(F_\lambda\)</span> 由 <span class="math inline">\(k\)</span> 个方格组成，排列规则如下：第一行有<span class="math inline">\(\lambda_1\)</span> 个方格，第二行有 <span class="math inline">\(\lambda_2\)</span> 个方格，. . .以此类推，每一行都是左对齐的，总共有 <span class="math inline">\(l(\lambda)\)</span> 行。</p><p>例如，分拆 <span class="math inline">\(\lambda=(4, 2, 2, 1)\)</span>的 Ferrers 图如下：</p><table><tbody><tr><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>注意 <span class="math inline">\(\lambda\)</span> 中的 0 不出现在Ferrers 图中。</p><p>将 <span class="math inline">\(F_\lambda\)</span>沿主对角线翻转（即行列互换），得到的也是一个 Ferrers图，其对应的分拆称为 <span class="math inline">\(\lambda\)</span>的共轭分拆，记作 <span class="math inline">\(\lambda'=(\lambda_1',\lambda_2',\ldots,\lambda_r')\)</span>，其中<span class="math inline">\(\lambda_i'\)</span> 是原 Ferrers 图第<span class="math inline">\(i\)</span> 列的长度，且 <span class="math inline">\(r=\lambda_1\)</span>。</p><p>例如，上图转置后得到的共轭分拆为 <span class="math inline">\(\lambda'=(4, 3, 1, 1)\)</span>：</p><table><tbody><tr><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>在 <span class="math inline">\(F_\lambda\)</span>的每个方格中填入正整数，并满足以下条件：</p><ol type="1"><li><strong>每一行从左到右非递减</strong>；</li><li><strong>每一列从上到下严格递增</strong>。</li></ol><p>满足上述条件的表格称为半标准 Young 表 (semistandard Youngtableaux)，简称为 SSYT；如果一个 SSYT 的所有填入的数字恰好为 <span class="math inline">\(\{1,2,\ldots,n\}\)</span>，且每个数字只出现一次，则称其为一个标准Young 表 (standard Young tableaux)，简称为 SYT。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>下图分别显示的是形状为 <span class="math inline">\(\lambda=(4, 3,2,1)\)</span> 的一个半标准和一个标准 Young 表。</p><table><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;">8</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">5</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><table><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">3</td><td style="text-align: center;">6</td><td style="text-align: center;">10</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">5</td><td style="text-align: center;">7</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;">9</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">8</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table></div><p>用记号 <span class="math inline">\(\mathrm{SSYT}(n,\lambda)\)</span>表示所有形状为 <span class="math inline">\(\lambda\)</span>，并且填入的数字不超过 <span class="math inline">\(n\)</span> 的半标准 Young表组成的集合。显然若要使得此集合非空必须有 <span class="math inline">\(n\geq l(\lambda)\)</span>（SSYT从上到下是递增的，第一列的最后一行填入的整数至少是 <span class="math inline">\(l(\lambda)\)</span>）。当 <span class="math inline">\(|\lambda|=n\)</span> 时我们也将其简写为 <span class="math inline">\(\mathrm{SSYT}(\lambda)\)</span>。类似地，<span class="math inline">\({\rm SYT}(\lambda)\)</span> 表示所有形状为 <span class="math inline">\(\lambda\)</span> 的标准 Young 表的集合。</p><p>文章开头的投票序列问题本质上等价于计算集合 <span class="math inline">\({\rm SYT}(\lambda)\)</span>的大小。具体来说，每个符合要求的投票序列都可以唯一地转化为一个标准 Young表，方法如下：</p><ul><li>依次处理数字 <span class="math inline">\(j=1,2,\ldots,n\)</span>，如果选民 <span class="math inline">\(j\)</span> 将票投给了候选人 <span class="math inline">\(i\)</span>，则将数字 <span class="math inline">\(j\)</span> 填入 <span class="math inline">\(\lambda\)</span> 的 Ferrers 图的第 <span class="math inline">\(i\)</span> 行从左边数起第一个空着的方格中。</li><li>所有 <span class="math inline">\(n\)</span>个数字填写完后得到的就是一个标准 Young 表 <span class="math inline">\(T\)</span>。若不然，假设第 <span class="math inline">\(k\)</span> 个选民投票给第 <span class="math inline">\(j\)</span> 个候选人，导致候选人 <span class="math inline">\(j\)</span> 的得票数大于某个候选人 <span class="math inline">\(i\,(i&lt;j)\)</span> 时，第 <span class="math inline">\(j\)</span> 行填入的 <span class="math inline">\(k\)</span> 上方对应的第 <span class="math inline">\(i\)</span>行的方格此时是空的，这个方格未来只能填大于 <span class="math inline">\(k\)</span> 的数字，这样的 Young表当然不是标准的。</li></ul><p>反之对一个标准 Young 表，其所有 <span class="math inline">\(\leqk\)</span> 的方格构成一个子 Young 表 <span class="math inline">\(T_k\)</span>，其每行长度是投票截止到第 <span class="math inline">\(k\)</span> 个选民时，第 <span class="math inline">\(i\)</span>个候选人的得票数，所以它给出一个满足要求的投票序列。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>标准 Young 表</p><table><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">3</td><td style="text-align: center;">6</td><td style="text-align: center;">10</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">5</td><td style="text-align: center;">7</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;">9</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">8</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>对应的得票序列为 <span class="math display">\[1, 2, 1, 3, 2, 1, 2, 4,3, 1\]</span> 只要依次将 <span class="math inline">\(1,2,\ldots,10\)</span> 所在的行写出来即可。</p></div><p>为了解决 <span class="math inline">\({\rm SYT}(\lambda)\)</span>的计数问题，我们需要引入 Schur 多项式的概念，Schur多项式可以看作是半标准 Young 表的“生成函数”。</p><p>给定一个满足 <span class="math inline">\(n\geq l(\lambda)\)</span>的分拆 <span class="math inline">\(\lambda=(\lambda_1,\ldots,\lambda_n)\)</span>（允许某些 <span class="math inline">\(\lambda_i\)</span> 为零），<span class="math inline">\(T\in {\rm SSYT}(n,\lambda)\)</span>是<strong>半标准 Young 表</strong>。我们称 <span class="math inline">\(c(T)=(c_1,c_2,\ldots,c_n)\)</span> 为 <span class="math inline">\(T\)</span> 的<strong>容度</strong> (content)，其中<span class="math inline">\(c_i\)</span> 是 <span class="math inline">\(T\)</span> 中数字 <span class="math inline">\(i\)</span> 出现的次数。记 <span class="math display">\[X^{c(T)} = x_1^{c_1}x_2^{c_2}\cdotsx_n^{c_n}.\]</span> <span class="math inline">\(X^{c(T)}\)</span>是一个单项式。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>对 <span class="math inline">\(n=10\)</span> 和 <span class="math inline">\(\lambda=(4,3,2,1)\)</span>，上面的半标准 Young表</p><table><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;">8</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">5</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>的容度为 <span class="math inline">\((2, 2, 2, 1, 1, 1, 0, 1, 0,0)\)</span>，其对应的单项式为 <span class="math display">\[X^{c(T)} =x_1^2x_2^2x_3^2x_4x_5x_6x_8.\]</span></p></div><div id="schur-------------------------" class="statement sta_schur_________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Schur多项式的组合定义</span>.</span><span class="statement-spah"> </span>设<span class="math inline">\(n\)</span> 是一个正整数，<span class="math inline">\(\lambda=(\lambda_1,\ldots,\lambda_n)\)</span>是一个满足 <span class="math inline">\(n\geq l(\lambda)\)</span> 的分拆（允许某些 <span class="math inline">\(\lambda_i\)</span> 为零），定义<span class="math inline">\(n\)</span> 变元多项式 <span class="math display">\[s_\lambda(x_1,\ldots,x_n)=\sum_{T\in {\rmSSYT}(n,\lambda)}X^{c(T)}.\]</span> <span class="math inline">\(s_\lambda\)</span> 叫做 <strong><span class="math inline">\(n\)</span> 变元的 Schur 多项式</strong>。</p></div><p>注意 <span class="math inline">\(s_\lambda(x_1,\ldots,x_n)\)</span>只有在 <span class="math inline">\(l(\lambda)\leq n\)</span>时才有定义。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>对 <span class="math inline">\(\lambda=(3,2)\)</span>， <span class="math display">\[\begin{align*}s_{(3,2)}(x_1,x_2,x_3) \,= \,&amp; x_1^3x_2^2  + x_1^3x_3^2 +  x_1^3x_2x_3 + x_1^2x_2^3 + x_1^2x_3^3+ 2x_1^2x_2x_3^2 + \\&amp;2x_1^2x_2^2x_3 +x_1x_2x_3^3 + 2x_1x_2^2x_3^2 + x_1x_2^3x_3+  x_2^2x_3^3 + x_2^3x_3^2.\end{align*}\]</span> 前几项对应的半标准 Young 表如下：</p><table><tbody><tr><th><span class="math inline">\(x_1^3x_2^2\)</span></th><th><span class="math inline">\(x_1^3x_3^2\)</span></th><th><span class="math inline">\(x_1^3x_2x_3\)</span></th><th><span class="math inline">\(x_1^2x_2^3\)</span></th><th><span class="math inline">\(x_1^2x_3^3\)</span></th></tr><tr><td><table><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;"></td></tr></tbody></table></td><td><table><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;"></td></tr></tbody></table></td><td><table><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"></td></tr></tbody></table></td><td><table><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;"></td></tr></tbody></table></td><td><table><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;"></td></tr></tbody></table></td></tr></tbody></table></div><p>可以看到虽然 Schur多项式的定义很直观，但写出它的具体表达式来却并不容易。我们需要找到 Schur多项式的其它表现形式。首先我们将证明 Schur 多项式总是对称多项式。</p><h1 id="bender-knuth-对合">Bender-Knuth 对合</h1><p>这一节我们来证明 Schur 多项式 <span class="math inline">\(s_\lambda(x_1,\ldots,x_n)\)</span>是对称多项式。即它在交换任何两个变元 <span class="math inline">\(x_i\)</span> 和 <span class="math inline">\(x_j\)</span> 后保持不变。为此只要证明它在交换<span class="math inline">\(x_i\)</span> 和 <span class="math inline">\(x_{i+1}\)</span>后保持不变即可。而这又只要说明容度为 <span class="math inline">\((\ldots,c_i,c_{i+1},\ldots)\)</span> 的半标准Young 表与容度为 <span class="math inline">\((\ldots,c_{i+1},c_i,\ldots)\)</span> 的半标准Young 表之间存在一一对应。看起来只要对每个形状为 <span class="math inline">\(\lambda\)</span> 的半标准 Young 表，把其中的数字<span class="math inline">\(i\)</span> 全换成 <span class="math inline">\(i+1\)</span>，同时把 <span class="math inline">\(i+1\)</span> 全换成 <span class="math inline">\(i\)</span> 就可以了，是吗？</p><p>问题出在这样简单粗暴地修改得到的未必还是半标准的 Young表。我们需要仔细点选择那些翻转的方格。我们作如下规定：</p><ul><li>如果某个 <span class="math inline">\(i\)</span> 的下方恰好是 <span class="math inline">\(i+1\)</span>，就称这样的 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(i+1\)</span> 构成匹配。</li><li>那些下方没有 <span class="math inline">\(i+1\)</span> 的 <span class="math inline">\(i\)</span>，或者上方没有 <span class="math inline">\(i\)</span> 的 <span class="math inline">\(i+1\)</span> 统称为未匹配的。</li></ul><p>下图中演示了 <span class="math inline">\(i=2\)</span>的例子，绿色显示了匹配的元素，红色显示了未匹配的元素。</p><style>table {max-width: 36%}</style><table style="width:100%;"><colgroup><col style="width: 14%"><col style="width: 14%"><col style="width: 14%"><col style="width: 14%"><col style="width: 14%"><col style="width: 14%"><col style="width: 14%"></colgroup><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"><span style="color:green">2</span></td></tr><tr><td style="text-align: center;"><span style="color:green">2</span></td><td style="text-align: center;"><span style="color:red">2</span></td><td style="text-align: center;"><span style="color:red">2</span></td><td style="text-align: center;"><span style="color:red">2</span></td><td style="text-align: center;"><span style="color:red">3</span></td><td style="text-align: center;"><span style="color:red">3</span></td><td style="text-align: center;"><span style="color:green">3</span></td></tr><tr><td style="text-align: center;"><span style="color:green">3</span></td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p><strong>关键观察</strong>：</p><blockquote><p>在任意一行中，未匹配的元素总是构成一段连续的序列。即设 <span class="math inline">\(i=x\leq y\leq i+1\)</span>是两个未匹配的元素，则它们中间不可能有匹配的元素。</p></blockquote><p>设某一行中的未匹配元素形如：<span class="math inline">\(r\)</span> 个<span class="math inline">\(i\)</span> 紧接着 <span class="math inline">\(s\)</span> 个 <span class="math inline">\(i+1\)</span>，我们将其替换为 <span class="math inline">\(s\)</span> 个 <span class="math inline">\(i\)</span> 紧接着 <span class="math inline">\(r\)</span> 个 <span class="math inline">\(i+1\)</span>，保持其他部分不变。对 Young表的每一行都执行这一操作，得到新表 <span class="math inline">\(T^\ast\)</span>，此时 <span class="math inline">\(T^\ast\)</span> 仍然是一个合法的半标准 Young表。</p><p>例如在上面的 <span class="math inline">\(T\)</span>中，红色标注的未匹配的元素是 3 个 2 后面跟了 2 个 3，变换后在 <span class="math inline">\(T^\ast\)</span> 中变成了 2 个 2 后面跟了 3 个3：</p><table style="width:100%;"><colgroup><col style="width: 14%"><col style="width: 14%"><col style="width: 14%"><col style="width: 14%"><col style="width: 14%"><col style="width: 14%"><col style="width: 14%"></colgroup><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"><font color="green">2</font></td></tr><tr><td style="text-align: center;"><font color="green">2</font></td><td style="text-align: center;"><font color="red">2</font></td><td style="text-align: center;"><font color="red">2</font></td><td style="text-align: center;"><font color="red">3</font></td><td style="text-align: center;"><font color="red">3</font></td><td style="text-align: center;"><font color="red">3</font></td><td style="text-align: center;"><font color="green">3</font></td></tr><tr><td style="text-align: center;"><font color="green">3</font></td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>容易验证 <span class="math inline">\(T^\ast\)</span> 的容度为 <span class="math inline">\((\ldots,c_{i+1},c_i,\ldots)\)</span>。这个变换显然是个对合：<span class="math inline">\((T^\ast)^\ast=T\)</span>，这就证明了 Schur多项式是对称的。</p><h1 id="jacobi-trudi-恒等式">Jacobi-Trudi 恒等式</h1><p>除了通过半标准 Young 表的生成函数定义之外，Schur多项式还有许多等价的表达方式。本节中，我们将 Schur多项式表示为齐次对称多项式行列式的形式。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义3.1</span>.</span><span class="statement-spah"> </span>记 <span class="math inline">\(h_k(x_1,\ldots,x_n)\)</span> 为所有次数为 <span class="math inline">\(k\)</span> 的单项式之和： <span class="math display">\[h_k(x_1,\ldots,x_n)=\sum_{\begin{subarray}{c}\alpha_1+\alpha_2+\cdots+\alpha_n=k\\\alpha_i\in\mathbb{Z}_{\geq0}\end{subarray}}x_1^{\alpha_1}x_2^{\alpha_2}\cdots x_n^{\alpha_n}.\]</span> 约定 <span class="math inline">\(h_0=1\)</span>，<span class="math inline">\(k&lt;0\)</span> 时 <span class="math inline">\(h_{k}=0\)</span>。<span class="math inline">\(h_k\)</span>也是对称多项式，称为<strong>齐次对称多项式</strong>。</p></div><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span><span class="math inline">\(h_2(x_1,\ldots,x_n)=\sum_{i=1}^nx_n^2 + \sum_{1&lt;i&lt;j&lt;n}x_ix_j\)</span>。</p></div><div id="jacobi-trudi----------" class="statement sta_jacobi_trudi____ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Jacobi-Trudi 恒等式</span>.</span><span class="statement-spah"> </span><br></p><p>设 <span class="math inline">\(\lambda=(\lambda_1,\ldots,\lambda_n)\in\mathbb{Z}^n_{\geq0}\)</span>为一个分拆，则 <span class="math display">\[s_\lambda(x_1,x_2,\ldots,x_n)=\det\left(h_{\lambda_i-i+j}\right)_{1\leq i,j\leq n}.\]</span></p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>另一种常见写法是 <span class="math display">\[s_\lambda(x_1,x_2,\ldots,x_n)=\det\left(h_{\lambda_i-i+j}\right)_{1\leq i,j\leq l(\lambda)}.\]</span>这没有区别。实际上令 <span class="math inline">\(r=l(\lambda)\)</span>，则 <span class="math display">\[\det\left(h_{\lambda_i-i+j}\right)_{1\leq i,j\leqn}=\det\left(\begin{array}{cc}\begin{array}{l}h_{\lambda_1}&amp;h_{\lambda_1+1} &amp;\cdots &amp; h_{\lambda_1+r-1}\\h_{\lambda_2-1}&amp;h_{\lambda_2} &amp;\cdots &amp; h_{\lambda_2+r-2}\\&amp;  &amp; \cdots &amp; \\h_{\lambda_r-(r-1)}&amp;h_{\lambda_r-(r-2)}&amp;\cdots &amp;h_{\lambda_r}\end{array} &amp; \Large\ast \\ \Large 0 &amp;\begin{matrix}1&amp;&amp;\\&amp;\ddots&amp;\\&amp;&amp;1\end{matrix}\end{array}\right).\]</span> 显然它等于左上角的主子式。</p></div><p>证明要用到 <a href="https://en.wikipedia.org/wiki/Lindstr%C3%B6m%E2%80%93Gessel%E2%80%93Viennot_lemma">Gessel-Viennot的不相交格点路径组方法</a>。关于这个方法你可以参考我之前的 <a href="/macmahon-formula-plane-partitions">一篇博文</a>。当然 <span class="citation" data-cites="thebook">(<a href="#ref-thebook" role="doc-biblioref">Martin Aigner and Ziegler 2018</a>)</span>中格点路径组一章也是极好的介绍。</p><p>关键是要<strong>把每个半标准 Young表对应到一个不相交的路径组</strong>。</p><p>下面的动图显示了 <span class="math inline">\(n=6, \lambda=(5,4,3,2,0,0)\)</span> 时的一个形状为 <span class="math inline">\(\lambda\)</span>的 Young 表 <span class="math inline">\(T\)</span>与其不相交的路径组：</p><table><tbody><tr><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;">5</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>其中，<span class="math inline">\(T\)</span> 的每一行是一个长度为<span class="math inline">\(\lambda_i\)</span>的递增数列，该数列对应一条从 <span class="math inline">\((0,1)\)</span>到 <span class="math inline">\((\lambda_i,n)\)</span> 的 Gauss路径，即这一行的“台阶图”。</p><p><img src="/images/schur/jacobi-trudi.gif" class="fig" width="600"></p><p>我省略了 <span class="math inline">\(\lambda_i=0\)</span>的部分，它们对应的是权重为 1 的垂直路径，对路径组的权重没有贡献：</p><p><img src="/images/schur/jacobi-trudi2.gif" class="fig" width="600"></p><p>但是半标准 Young 表的列是严格递增的，这个递减关系反映在 Gauss路径上，就是 <span class="math inline">\(T\)</span>的第二行对应的路径应该整体位于第一行对应路径的上方，第三行对应的路径整体位于第二行对应的路径的上方，…，两条路径之间可以有垂直的公共边，但是不能有水平的公共边。</p><p>对每个 <span class="math inline">\(i\)</span>，将第 <span class="math inline">\(i\)</span> 行对应的路径水平地向左平移 <span class="math inline">\(i\)</span> 个单位，使其成为一条从 <span class="math inline">\(A_i=(-i,1)\)</span> 到 <span class="math inline">\(B_i=(-i+\lambda_i,n)\)</span> 的 Gauss路径，则这样得到的 <span class="math inline">\(n\)</span>条路径构成一个不相交的路径组。</p><p>反过来每一个这样的不相交的路径组也对应于一个半标准 Young 表。</p><p>令水平线 <span class="math inline">\(y=k\)</span> 的权值为 <span class="math inline">\(x_k\)</span>，垂直边的权值一律为1，每条路径的权重是其所含各边的权重乘积。不难验证从 <span class="math inline">\(A_j=(-j,1)\)</span> 到 <span class="math inline">\(B_i=(-i+\lambda_i,n)\)</span> 的所有 Gauss路径权重之和是齐次对称多项式 <span class="math inline">\(h_{\lambda_i-i+j}\)</span>。于是由 Gessel-Viennot引理，行列式 <span class="math inline">\(\det\left(h_{\lambda_i-i+j}\right)_{1\leq i,j\leqn}\)</span>给出了所有不相交路径组的权重之和。另一方面每个不相交路径组的权重正是它对应Young 表的权重 <span class="math inline">\(X^{c(T)}\)</span>，所以 <span class="math display">\[s_\lambda=\det\left(h_{\lambda_i-i+j}\right)_{1\leqi,j\leq n}.\]</span> 这就证明了 Jacobi-Trudi 恒等式。</p><h1 id="bi-alternant-公式">Bi-alternant 公式</h1><p>设 <span class="math inline">\(\lambda=(\lambda_1,\ldots,\lambda_n),\,\mu=(\mu_1,\ldots,\mu_n)\in\mathbb{Z}^n_{\geq0}\)</span>是两个分拆。定义 Weyl 向量 <span class="math display">\[\rho=(n-1,n-2,\ldots,1,0).\]</span></p><p>设 <span class="math inline">\(T\in\mathrm{SSYT}(n,\mu)\)</span>，用记号 <span class="math inline">\(T_{\geq j}\)</span> 表示由 <span class="math inline">\(T\)</span> 的第 <span class="math inline">\(j,j+1,\ldots\)</span> 列组成的半标准 Young表，同理记号 <span class="math inline">\(T_{&gt;j}\)</span> 和 <span class="math inline">\(T_{&lt;j}\)</span>的含义都是不言自明的。如果对任何 <span class="math inline">\(j\)</span>，向量 <span class="math inline">\(\lambda+c(T_{\geq j})\)</span> 都是一个分拆，就称<span class="math inline">\(T\)</span> 是一个“好” Young 表，否则就称<span class="math inline">\(T\)</span> 是一个“坏” Young 表。</p><p>定义如下的 <span class="math inline">\(n\)</span> 阶行列式：</p><p><span class="math display">\[a_\lambda=\det(x_i^{\lambda_j})_{1\leqi,j\leq n}=\sum_{\sigma\inS_n}\text{sgn}(\sigma)X^{\sigma(\lambda)}.\]</span></p><div id="stembridge" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.1</span>.</span><span class="statement-spah"> </span><span class="math display">\[a_{\lambda+\rho}s_{\mu}=\sum_{T\in\mathrm{SSYT}(n,\mu)\text{and $T$ good}}a_{\lambda+c(T)+\rho}.\]</span></p></div><p>这个定理乍看起来从叙述到证明都很不直观，不过它的结论却非常重要，这就是Littlewood-Richardson 定律。下面这个证明有很深刻的来源（李代数的晶体图）。见</p><blockquote><p>A Concise Proof of the Littlewood-Richardson Rule, by John R.Stembridge.</p></blockquote><p><strong>证明</strong>：由于 <span class="math inline">\(s_\mu\)</span> 是对称多项式，因此对任何置换 <span class="math inline">\(\sigma\in S_n\)</span>，当 <span class="math inline">\(T\)</span> 跑遍 <span class="math inline">\(\mathrm{SSYT}(n,\mu)\)</span> 时，集合 <span class="math inline">\(\{c(T)\}\)</span> 与集合 <span class="math inline">\(\{\sigma(c(T))\}\)</span> 是相同的，所以 <span class="math display">\[s_{\mu}=\sum_{T\in\mathrm{SSYT}(n,\mu)} X^{c(T)} =\sum_{T\in\mathrm{SSYT}(n,\mu)} X^{\sigma(c(T))}.\]</span></p><p>于是利用定义有</p><p><span class="math display">\[\begin{aligned}a_{\lambda+\rho}s_\mu&amp;=\sum_{\sigma\inS_n}\text{sgn}(\sigma)X^{\sigma(\lambda+\rho)}s_\mu\\&amp;=\sum_{\sigma\inS_n}\text{sgn}(\sigma)\left(\sum_{T\in\mathrm{SSYT}(n,\,\mu)}X^{\sigma(\lambda+\rho+c(T))}\right)\\&amp;=\sum_{T\in\mathrm{SSYT}(n,\mu)}\sum_{\sigma\inS_n}\text{sgn}(\sigma)X^{\sigma(\lambda+\rho+c(T))}\\&amp;=\sum_{T\in\mathrm{SSYT}(n,\mu)}a_{\lambda+c(T)+\rho}.\end{aligned}\]</span></p><p>接下来，我们将借助 Bender-Knuth 对合，把求和项中坏的那些 <span class="math inline">\(T\)</span> 两两配对抵消掉，从而剩下的和项都是好的<span class="math inline">\(T\)</span>。</p><p>设 <span class="math inline">\(T\)</span> 是一个坏 Young 表，则存在<span class="math inline">\(j\)</span> 使得 <span class="math inline">\(\lambda+c(T_{\geq j})\)</span>不是一个分拆，在所有这样的 <span class="math inline">\(j\)</span>中，选取最大的那个。选好 <span class="math inline">\(j\)</span>以后，由于 <span class="math inline">\(\lambda+c(T_{\geq j})\)</span>不是分拆，因此存在 <span class="math inline">\(k\)</span> 使得 <span class="math display">\[\lambda_k+c_k(T_{\geq j}) &lt;\lambda_{k+1}+c_{k+1}(T_{\geq j}).\]</span> 在所有这样的 <span class="math inline">\(k\)</span> 中，选取最小的那个。</p><p>由于在 <span class="math inline">\(T\)</span> 的每一列中至多只有一个<span class="math inline">\(k\)</span> 以及至多只有一个 <span class="math inline">\(k+1\)</span>，所以差 <span class="math display">\[c_k(T_{\geq j}) - c_{k+1}(T_{\geq j})\]</span> 在<span class="math inline">\(j\)</span> 变动到 <span class="math inline">\(j+1\)</span> 时最多只会改变 1。从而差 <span class="math display">\[\lambda_k+c_k(T_{\geq j})-\lambda_{k+1}-c_{k+1}(T_{\geq j})\]</span> 也是如此。根据 <span class="math display">\[\begin{aligned}\lambda_k+c_k(T_{\geq j}) &amp;&lt; \lambda_{k+1}+c_{k+1}(T_{\geq j})\\\lambda_k+c_k(T_{\geq j+1}) &amp;\geq \lambda_{k+1}+c_{k+1}(T_{\geqj+1})\end{aligned}\]</span> 第一行（两端之差）是一个负整数，在至多改变 1的情况下，变成第二行的非负整数，只能是从 -1 变成 0。从而我们有 <span class="math display">\[\lambda_k+c_k(T_{\geqj})+1=\lambda_{k+1}+c_{k+1}(T_{\geqj}).\tag{1}\label{eq:assert}\]</span> 并且 <span class="math inline">\(T\)</span> 的第 <span class="math inline">\(j\)</span> 列有一个 <span class="math inline">\(k+1\)</span> 但是没有 <span class="math inline">\(k\)</span>。</p><p>现在对 <span class="math inline">\(T\)</span> 进行如下的变换：保持<span class="math inline">\(T_{\geq j}\)</span> 的部分不动，把 <span class="math inline">\(T_{&lt;j}\)</span> 的部分对数字 <span class="math inline">\(k\)</span> 和 <span class="math inline">\(k+1\)</span> 进行 Bender-Knuth 变换，得到一个Young 表 <span class="math inline">\(T^\ast\)</span> （不排除 <span class="math inline">\(T=T^\ast\)</span> 的可能）。不难验证 <span class="math inline">\(T^\ast\)</span> 也是半标准的：因为 Bender-Knuth对换不影响列严格递增性质，利用 <span class="math inline">\(T\)</span>的第 <span class="math inline">\(j\)</span> 列不含 <span class="math inline">\(k\)</span> 这一点，将 <span class="math inline">\(T_{&lt;j}\)</span> 的部分中某些 <span class="math inline">\(k\)</span> 换成 <span class="math inline">\(k+1\)</span> 也不会影响行的弱递增性质。<span class="math inline">\(T^\ast\)</span> 也是一个坏 Young 表且 <span class="math inline">\((T^\ast)^\ast =T\)</span> （因为 <span class="math inline">\(T^\ast_{\geq j}\)</span> 和 <span class="math inline">\(T_{\geq j}\)</span> 完全一样）。容易验证对换 <span class="math inline">\(s_k=(k,k+1)\)</span> 交换 <span class="math inline">\(c(T_{&lt; j})\)</span> 和 <span class="math inline">\(c(T^\ast_{&lt; j})\)</span> 的 <span class="math inline">\(k\)</span> 和 <span class="math inline">\(k+1\)</span> 位置： <span class="math display">\[s_kc(T_{&lt; j}) = c(T^\ast_{&lt; j}).\]</span>而 <span class="math inline">\((\ref{eq:assert})\)</span> 说明 <span class="math inline">\(s_k\)</span> 保持 <span class="math inline">\(\lambda+c(T_{\geq j}) + \rho\)</span> 不变，因此<span class="math display">\[s_k(\lambda+c(T)+\rho)=s_k(\lambda+c(T_{\geqj})+\rho)+s_kc(T_{&lt;j})=\lambda+c(T^\ast)+\rho.\]</span></p><p>于是若 <span class="math inline">\(T\ne T^\ast\)</span>，则两个行列式<span class="math inline">\(a_{\lambda+c(T)+\rho}\)</span> 和 <span class="math inline">\(a_{\lambda+c(T^\ast)+\rho}\)</span> 相差一个 <span class="math inline">\(k,k+1\)</span> 列的交换，从而它们的值抵消。在<span class="math inline">\(T=T^\ast\)</span> 的情形，矩阵的 <span class="math inline">\(k,k+1\)</span> 列是相同的，行列式自然是 0。<span class="math inline">\(\blacksquare\)</span></p><div id="bi-alternant-formula" class="statement sta_bi_alternant_formula plain unnumbered"><p><span class="statement-heading"><span class="statement-label">bi-alternant formula</span>.</span><span class="statement-spah"> </span> <span class="math display">\[s_{\mu}=\frac{a_{\mu+\rho}}{a_\rho}.\]</span></p></div><p><strong>证明</strong>：在定理中令 <span class="math inline">\(\lambda=\emptyset\)</span>，则只有唯一的一个形状为<span class="math inline">\(\mu\)</span> 的好 Young 表 <span class="math inline">\(T\)</span>，使得 <span class="math inline">\(c(T_{\geq j})\)</span> 对任何 <span class="math inline">\(j\)</span> 都是一个分拆，这个表必须是第一行都填1，第二行都填 2，…， 以此类推，从而 <span class="math inline">\(c(T)=\mu\)</span>，因此得证。<span class="math inline">\(\blacksquare\)</span></p><h1 id="钩长公式">钩长公式</h1><p>在完成前面的准备工作后，我们现在可以正式介绍钩长公式及其证明。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\lambda\vdash n\)</span>，<span class="math inline">\(F_\lambda\)</span> 是其 Ferrers 图，记 <span class="math inline">\(v=(i,j)\)</span> 为 <span class="math inline">\(F_\lambda\)</span> 中第 <span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 列位置的方格（只考虑那些有方格的位置）。我们计算那些与 <span class="math inline">\(v\)</span> 同行但是位置在 <span class="math inline">\(v\)</span> 的右边，以及与 <span class="math inline">\(v\)</span> 同列但是位置在 <span class="math inline">\(v\)</span> 的下方的方格的总数，<span class="math inline">\(v\)</span> 自己也算一个但是只算一次。这个数字称作<span class="math inline">\(v\)</span> 的钩子长度，记作 <span class="math inline">\(h_v\)</span>。</p></div><p>例如 <span class="math inline">\(\lambda=(5, 4, 3, 2, 1)\)</span> 的Ferrers 图中，<span class="math inline">\(v=(1, 1)\)</span> 的钩子长度<span class="math inline">\(h_v=5\)</span>。</p><table><colgroup><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"><col style="width: 20%"></colgroup><tbody><tr><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{\bullet}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(\phantom{\bullet}\)</span></td><td style="text-align: center;"><span class="math inline">\(\bullet\)</span></td><td style="text-align: center;"><span class="math inline">\(\bullet\)</span></td><td style="text-align: center;"><span class="math inline">\(\bullet\)</span></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"><span class="math inline">\(\phantom{\bullet}\)</span></td><td style="text-align: center;"><span class="math inline">\(\bullet\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"><span class="math inline">\(\phantom{\bullet}\)</span></td><td style="text-align: center;"><span class="math inline">\(\bullet\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;"><span class="math inline">\(\phantom{\bullet}\)</span></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>一般地，<span class="math inline">\((i,j)\)</span> 位置的方格的 hook长度为 <span class="math inline">\(\lambda_i + \lambda'_j - i - j +1\)</span>。</p><div id="hook-length-formula" class="statement sta_hook_length_formula plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Hooklength formula</span>.</span><span class="statement-spah"> </span><br></p><p>形状为 <span class="math inline">\(\lambda\)</span> 的标准 Young表的个数由以下公式给出： <span class="math display">\[|{\rmSYT}(\lambda)|=f_\lambda=\frac{n!}{\prod\limits_{v\inF_\lambda}h_v}.\]</span></p></div><div id="lemmaA" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mu_i=\lambda_i+r-i\)</span>，这里 <span class="math inline">\(r=l(\lambda)=\lambda_1',\,1\leq i\leqr\)</span>，则 <span class="math display">\[\prod_{v\in F_\lambda} h_v=\frac{\prod\limits_{i=1}^r\mu_i!}{\prod\limits_{i&lt;j}(\mu_i-\mu_j)}.\]</span></p><p>注意 <span class="math inline">\(\mu_i=h_{i1}\)</span> 正是第 1 列第<span class="math inline">\(i\)</span> 行方格的钩子长度。</p></div><p><a href="#lemmaA" title="引理 5.2">引理 5.2</a>的结论可以很容易由下面的 <a href="#lemmaB" title="引理 5.3">引理 5.3</a>得出：</p><div id="lemmaB" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.3</span>.</span><span class="statement-spah"> </span>对固定的 <span class="math inline">\(1\leq k\leq r\)</span>，<span class="math inline">\(F_\lambda\)</span> 的第 <span class="math inline">\(k\)</span> 行所有方格的钩子长度集合 <span class="math inline">\(\{h_{kj},1\leq j\leq\lambda_k\}\)</span> 与 <span class="math inline">\(\{\mu_k-\mu_i, k\leq i\leq r\}\)</span>不相交，且它们的并集恰好构成 <span class="math inline">\(\{0,1,\ldots,\mu_k\}\)</span>。因此，第 <span class="math inline">\(k\)</span> 行所有方格的钩子长度的乘积为 <span class="math display">\[\prod_{j=1}^{\lambda_k}h_{kj}=\frac{\mu_k!}{\prod\limits_{k&lt;i}(\mu_k-\mu_i)}.\]</span></p></div><p><a href="#lemmaB" title="引理 5.3">引理 5.3</a>的证明：这里的证明改编自 <span class="citation" data-cites="Macdonald2008">Macdonald (<a href="#ref-Macdonald2008" role="doc-biblioref">2008</a>)</span>。</p><p>我们从 <span class="math inline">\(F_\lambda\)</span>的左下角开始，沿着边界，每一步向右或者向上行走，直到第 <span class="math inline">\(k\)</span> 行最右边的方格右上角为止，总共要走<span class="math inline">\(h_{k1}+1\)</span> 步。将经过的边依次标号为<span class="math inline">\(0,1,\ldots,h_{k1}\)</span>。</p><figure><img src="/images/schur/hook_length_lemma.svg" class="fig" width="400" alt="图中只显示了 F_\lambda 第 k 行及以下的部分。向右走的步数等于第 k 行的方格个数，向上走的步数等于第 1 列中 \geq k 行的方格个数，所以总共走了 h_{k1}+1 步。"><figcaption aria-hidden="true">图中只显示了 <span class="math inline">\(F_\lambda\)</span> 第 <span class="math inline">\(k\)</span> 行及以下的部分。向右走的步数等于第<span class="math inline">\(k\)</span> 行的方格个数，向上走的步数等于第1 列中 <span class="math inline">\(\geq k\)</span>行的方格个数，所以总共走了 <span class="math inline">\(h_{k1}+1\)</span>步。</figcaption></figure><p>不难看出：</p><ul><li>所有竖直边的标号构成集合 <span class="math inline">\(\{h_{i1} \midk\leq i\leq r\}\)</span>，即图中第一列方格的钩子长度。</li><li>所有水平边的标号构成集合 <span class="math inline">\(\{h_{k1} -h_{kj}\mid 1\leq j\leq\lambda_k\}\)</span>。即 <span class="math inline">\(h_{k1}\)</span> 减去图中第一行（也是原 <span class="math inline">\(F_\lambda\)</span> 的第 <span class="math inline">\(k\)</span> 行）方格的钩子长度。</li></ul><p>于是我们有不交并 <span class="math display">\[\{0,1,\ldots,h_{k1}\}=\{h_{i1} \mid k\leq i\leqr\}\sqcup \{h_{k1} - h_{kj}\mid 1\leq j\leq\lambda_k\}.\]</span> 同时用<span class="math inline">\(h_{k1}\)</span> 减去两边的集合，得到不交并<span class="math display">\[\{0,1,\ldots,h_{k1}\}=\{h_{k1}-h_{i1} \midk\leq i\leq r\}\sqcup \{h_{kj}\mid 1\leq j\leq\lambda_k\}.\]</span></p><p>前者正是集合 <span class="math inline">\(\{\mu_k-\mu_i\mid k\leqi\leq r\}\)</span>，这就证明了 <a href="#lemmaB" title="引理 5.3">引理5.3</a>。<span class="math inline">\(\blacksquare\)</span></p><p>最后我们来完成钩长公式的证明：这里使用了一个小技巧：考虑关于无穷多个变元的对称多项式环<span class="math inline">\(\Lambda[x_1,\ldots,x_n,\ldots]\)</span>，任何<span class="math inline">\(k\)</span> 变元的 Schur 多项式都是 <span class="math inline">\(\Lambda\)</span> 中的元素。<span class="math inline">\(\Lambda\)</span> 到有理数域上的单变元形式幂级数环<span class="math inline">\(\mathbb{Q}[t]\)</span> 有一个同态 <span class="math inline">\(\theta\)</span>： <span class="math display">\[\theta(f) = \sum_{k=0}^\infty f_k\frac{t^k}{k!}.\]</span> 其中 <span class="math inline">\(f_k\)</span>是 <span class="math inline">\(f\)</span> 中单项式 <span class="math inline">\(x_1x_2\cdots x_k\)</span> 的系数。不难验证 <span class="math inline">\(\theta\)</span> 是 <span class="math inline">\(\Lambda\to \mathbb{Q}[t]\)</span> 的代数同态 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。</p><p>在齐次对称多项式 <span class="math inline">\(h_k\)</span> 中，其形如<span class="math inline">\(x_1x_2\cdots x_n\)</span> 的项只有一个，就是<span class="math inline">\(x_1x_2\cdotsx_k\)</span>，并且这一项的系数是 1，所以 <span class="math inline">\(\theta(h_k)=\frac{t^k}{k!}\)</span>。</p><p>我们再来分析 <span class="math inline">\(\theta\)</span> 作用在 <span class="math inline">\(n\)</span> 变元 Schur 多项式上的结果 <span class="math inline">\(\theta(s_\lambda(x_1,\ldots,x_n))\)</span>。这里我们要求<span class="math inline">\(\lambda\)</span> 满足 <span class="math inline">\(|\lambda|=n\)</span>，即 <span class="math inline">\(\lambda\)</span> 的 Ferrers 图恰好包含 <span class="math inline">\(n\)</span> 个方格。单项式 <span class="math inline">\(x_1x_2\cdots x_k\)</span> 在 <span class="math inline">\(s_\lambda(x_1,\ldots,x_n)\)</span>中的系数等于每个数字 <span class="math inline">\(\{1,2,\ldots,k\}\)</span>都恰好使用一次的不同填法的个数，这只能是 <span class="math inline">\(k=n\)</span> 且得到的是标准 Young 表，这样的填法有<span class="math inline">\(f_\lambda\)</span> 种，所以 <span class="math display">\[\theta(s_\lambda(x_1,\ldots,x_n))=f_\lambda\frac{t^n}{n!}.\]</span></p><p>在 Jacobi-Trudi 恒等式两边同时用 <span class="math inline">\(\theta\)</span> 作用，得到 <span class="math display">\[f_\lambda \frac{t^n}{n!}=\det\left(\frac{t^{\lambda_i-i+j}}{(\lambda_i-i+j)!} \right).\]</span> 取 <span class="math inline">\(t=1\)</span> 代入得 <span class="math display">\[f_\lambda = n!\cdot\det\left(\frac{1}{(\lambda_i-i+j)!}\right).\]</span>我们把这个行列式写出来： <span class="math display">\[f_\lambda =n!\cdot \det\begin{pmatrix}\frac{1}{\lambda_1!} &amp; \frac{1}{(\lambda_1+1)!} &amp; \cdots &amp;\frac{1}{(\lambda_1+r-1)!}\\\frac{1}{(\lambda_2-1)!} &amp; \frac{1}{\lambda_2!} &amp; \cdots &amp;\frac{1}{(\lambda_2+r-2)!}\\\cdots &amp; \cdots &amp;\cdots&amp;\cdots\\\frac{1}{(\lambda_r-r+1)!} &amp; \frac{1}{(\lambda_r-r+2)!} &amp; \cdots&amp; \frac{1}{\lambda_r!}\end{pmatrix}.\]</span> 它的最后一列恰好是 <span class="math inline">\(\{\mu_i!\mid 1\leq i\leqr\}\)</span>，提出来以后得到 <span class="math display">\[f_\lambda =\frac{n!}{\prod\limits_{i=1}^r\mu_i!}\cdot \det\begin{pmatrix}\mu_1^{\underline{r-1}}&amp; \mu_1^{\underline{r-2}} &amp; \cdots &amp;\mu_1^{\underline{0}}\\\mu_2^{\underline{r-1}} &amp; \mu_2^{\underline{r-2}} &amp; \cdots &amp;\mu_2^{\underline{0}}\\\cdots &amp; \cdots &amp;\cdots&amp;\cdots\\\mu_r^{\underline{r-1}}&amp; \mu_r^{\underline{r-2}} &amp; \cdots &amp;\mu_r^{\underline{0}}\end{pmatrix}=\frac{n!}{\prod\limits_{i=1}^r\mu_i!}\cdot\det(\mu_i^{\underline{r-j}}).\]</span>其中采用了类似 <span class="citation" data-cites="aigner07">M. Aigner(<a href="#ref-aigner07" role="doc-biblioref">2007</a>)</span> 中的记号<span class="math display">\[x^{\underline{k}}=x(x-1)\cdots(x-k+1).\]</span></p><p>不难证明 <span class="math inline">\(\det(\mu_i^{\underline{r-j}})\)</span>这个行列式与 Vandermonde 行列式 <span class="math inline">\(\det(\mu_i^{r-j})\)</span> 的值是一样的，都等于<span class="math inline">\(\prod\limits_{i&lt;j}(\mu_i-\mu_j)\)</span><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。于是 <span class="math display">\[f_\lambda =\frac{n!}{\prod\limits_{i=1}^r\mu_i!}\cdot\prod\limits_{i&lt;j}(\mu_i-\mu_j)= \frac{n!}{\prod\limits_{v\in F_\lambda}h_v}.\]</span>这就完成了钩长公式的证明。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-aigner07" class="csl-entry" role="listitem">Aigner, M. 2007. <em>A Course in Enumeration</em>. Graduate Texts inMathematics. Springer Berlin Heidelberg.</div><div id="ref-thebook" class="csl-entry" role="listitem">Aigner, Martin, and Gnter M. Ziegler. 2018. <em>Proofs from THEBOOK</em>. 6th ed. Springer Publishing Company, Incorporated.</div><div id="ref-Macdonald2008" class="csl-entry" role="listitem">Macdonald, I. G. 2008. <em>Symmetric Functions and HallPolynomials</em>. 2<sup>nd</sup> ed. Oxford science pub.</div><div id="ref-Stanley_Fomin_1999" class="csl-entry" role="listitem">Stanley, Richard P., and Sergey Fomin. 1999. <em>EnumerativeCombinatorics</em>. Vol. 2. Cambridge Studies in Advanced Mathematics.Cambridge University Press.</div></div><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>你可以直接手算验证 <span class="math inline">\(\theta\)</span>是代数同态。但这个同态背后还有更深的来历：记 <span class="math display">\[p_k=x_1^k+\cdots+x_n^k+\cdots\in\Lambda.\]</span><span class="math inline">\(p_k\)</span>叫做<strong>幂和对称多项式</strong>。对称多项式的基本定理有一个版本是说，任何<span class="math inline">\(f\in\Lambda\)</span> 可以唯一地写成关于<span class="math inline">\(\{p_k\mid k\geq1\}\)</span>的有理系数多项式： <span class="math display">\[f=g(p_1,p_2,\ldots).\]</span> 其中 <span class="math inline">\(g\)</span> 是关于无穷多个变元 <span class="math inline">\(x_1,\ldots,x_n\)</span>的有理系数多项式。考虑赋值映射 <span class="math display">\[\begin{aligned}{\rm ex}:\ \Lambda&amp;\mapsto\mathbb{Q}[t]\\g(p_1,p_2,\ldots) &amp;\to g(t, 0, 0,\ldots)\end{aligned}\]</span> 则 <span class="math inline">\({\rm ex}\)</span>是代数同态。<span class="math inline">\({\rm ex}\)</span> 实际上就是<span class="math inline">\(\theta\)</span>： <span class="math display">\[{\rm ex}(f) = \sum_{n\geq0}f_n\frac{t^n}{n!}.\]</span> 详情可以参考 <span class="citation" data-cites="Stanley_Fomin_1999">(<a href="#ref-Stanley_Fomin_1999" role="doc-biblioref">Stanley and Fomin 1999</a>)</span>。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>考虑 <span class="math inline">\(n\)</span> 个变元 <span class="math inline">\(X_1,\ldots,X_n\)</span> 的行列式 <span class="math inline">\(\det(X_i^{\underline{r-j}})\)</span>，这个多项式在<span class="math inline">\(X_i=X_j\)</span> 时是 0，所以它有因子 <span class="math inline">\(\prod_{1\leq i&lt;j\leqr}(X_i-X_j)\)</span>。另一方面它的行列式展开以后每一项次数都不超过 <span class="math inline">\(\sum_{i=1}^r(r-i)=\frac{r(r-1)}{2}\)</span>，所以比较次数即得它等于<span class="math inline">\(\prod_{1\leq i&lt;j\leq r}(X_i-X_j)\)</span>乘以一个常数。再比较 <span class="math inline">\(X_1^{r-1}X_2^{r-2}\cdots X_r^0\)</span>的系数（来自主对角线）即得这个常数是 1。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 计数组合学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>左 Artinian 环与 Wedderburn-Artin 定理</title>
      <link href="/wedderburn-artin-theorem/"/>
      <url>/wedderburn-artin-theorem/</url>
      
        <content type="html"><![CDATA[<p>Wedderburn-Artin 定理最早源于 1907 年 Wedderburn研究域上有限维结合代数的分类定理。在 Wedderburn考虑这个问题的时候，Killing 和 Cartan 等人已经完成了有限维复半单 Lie代数的分类工作，如果读者对有限维 Lie代数有所了解的话，可能已经知道任何有限维复 Lie 代数 <span class="math inline">\(L\)</span> 有一个极大可解理想 <span class="math inline">\(\mathrm{rad}(L)\)</span>，叫做 <span class="math inline">\(L\)</span> 的根 (radical)，去掉这个根的商代数<span class="math inline">\(L/\mathrm{rad}(L)\)</span>是半单代数，其上的双线性型 Killing型是非退化的，从而可以通过反复取正交补的方式将 <span class="math inline">\(L/\mathrm{rad}(L)\)</span>分解为一些单代数的直和，然后对单 Lie 代数的结构进行讨论得出其共有 9种不同的类型。Wedderburn 的思路自然受到了 Killing等人工作的启发，他采取了类似的套路：</p><p>对域 <span class="math inline">\(F\)</span> 上的有限维结合代数 <span class="math inline">\(A\)</span>：</p><ol type="1"><li>定义根理想 <span class="math inline">\(\mathrm{rad}(A)\)</span>。</li><li>转移到半单代数 <span class="math inline">\(A/\mathrm{rad}(A)\)</span>。</li><li>将 <span class="math inline">\(A/\mathrm{rad}(A)\)</span>分解为单代数的直和。</li><li>讨论单代数的结构。</li></ol><p>整个路线图如下所示：</p><p><img src="/images/wedderburn-artin/steps.svg" class="fig"></p><p>总之虽然有限维复李代数和结合代数结构相差很大，但它们的结构定理遵循了类似的套路：拿走可解/幂零的部分，剩下的部分是半单的，而半单是单的直和，于是最终归结为对单成分的结构进行讨论。</p><p>Wedderburn-Artin定理的过程比较长，不过在头脑中事先明确这条主线，理解整个证明并不是一件困难的事情。</p><p>本文将针对左 Artinian 环的情形证明 Wedderburn-Artin定理。我将采用上面 Wedderburn 的证明途径，而不是现在教科书上普遍使用的Jacobson 根方法。我主要参考了 Curtis 和 Reiner 的经典 <span class="citation" data-cites="curtis-reiner">(<a href="#ref-curtis-reiner" role="doc-biblioref">Curtis and Reiner1962</a>)</span>，Herstein 的精彩小书 <span class="citation" data-cites="herstein-rings">(<a href="#ref-herstein-rings" role="doc-biblioref">Herstein 1994</a>)</span>，以及林节玄的 <span class="citation" data-cites="Lam01">(<a href="#ref-Lam01" role="doc-biblioref">Lam 2001</a>)</span>。C&amp;R的书是个大部头，但它总是从最基本的概念讲起，叙述清楚易懂，对新手非常友好。Herstein的书则是另一种风格，主线简单，节奏很快，短短几章就讲到了中心单代数和Galois 上同调。林节玄的书风格则更为现代一些，我没有细读，不多评价。</p><span id="more"></span><div id="------" class="statement sta___ definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注意</span>：</span></p><ol type="1"><li>Wedderburn 对 <span class="math inline">\(\mathrm{rad}(A)\)</span>的定义方法只适用于像左 Artinian 环这样有特殊限制的环。现代普遍采用Jacobson 根 <span class="math inline">\(J(A)\)</span> 来定义 <span class="math inline">\(\mathrm{rad}(A)\)</span>。Jacobson根的好处是它对任意的含 1 结合环都有定义，而且在建立了关于 Jacobson根的事实后，证明 Wedderburn-Artin 定理相对采用 Wedderburn的途径要简洁很多。</li><li>定义 <span class="math inline">\(A\)</span>的半单性有两种定义方法：<span class="math inline">\(\mathrm{rad}(A)=(0)\)</span>或者完全可约性。后者是更常见的做法。在左 Artinian环的情形，这两种方法是等价的。</li></ol></div><h1 id="记号与约定">记号与约定</h1><ul><li><p>在本文中，<span class="math inline">\(R\)</span>总表示含乘法单位元的结合环。我们称 <span class="math inline">\(R\)</span> 是<strong>左 Artinian 环</strong>，如果<span class="math inline">\(R\)</span> 的左理想满足所谓的降链条件(Descending chain condition, DCC)，即对任何左理想 <span class="math inline">\(\{I_n\}_{n=1}^\infty\)</span> 组成的无穷序列 <span class="math display">\[I_1\supseteq I_2\supseteq \cdots \supseteqI_n\supseteq\cdots\]</span> 都必然存在正整数 <span class="math inline">\(N\)</span> 使得 <span class="math inline">\(I_N=I_{N+1}=\cdots\)</span>。左 Artinian环的另一种等价刻画是，任何由 <span class="math inline">\(R\)</span>的左理想组成的非空集合必有极小元。</p></li><li><p>如果一个左 <span class="math inline">\(R-\)</span> 模 <span class="math inline">\(M\)</span> 除了 <span class="math inline">\((0)\)</span> 和自身以外没有其它非平凡的子模，就称<span class="math inline">\(M\)</span>是<strong>不可约</strong>的。如果左理想 <span class="math inline">\(I\subseteq R\)</span> 作为左 <span class="math inline">\(R-\)</span> 模是不可约的，就称 <span class="math inline">\(I\)</span>是不可约左理想。非零的不可约左理想叫作<strong>极小左理想</strong>。</p></li></ul><h1 id="定义环-r-的根-mathrmradr">定义环 <span class="math inline">\(R\)</span> 的根 <span class="math inline">\(\mathrm{rad}(R)\)</span></h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.1</span>.</span><span class="statement-spah"> </span>我们称 <span class="math inline">\(R\)</span> 的左理想 <span class="math inline">\(I\)</span> 是幂零的，如果存在正整数 <span class="math inline">\(n\)</span> 使得 <span class="math inline">\(I^n=0\)</span>。</p></div><p>显然 <span class="math inline">\(I\)</span>幂零自动蕴含其元素都是幂零的：对任何 <span class="math inline">\(x\inI\)</span> 有 <span class="math inline">\(x^n=0\)</span>。但是反过来则未必对：<span class="math inline">\(I\)</span> 的每个元素都幂零并不能保证 <span class="math inline">\(I\)</span> 是幂零的。</p><p>前面提到，Wedderburn 的想法第一步是仿照 Lie 代数的情形定义环 <span class="math inline">\(R\)</span> 的根 <span class="math inline">\(\mathrm{rad}(R)\)</span>，它必须是一个双边理想，从而可以取商环<span class="math inline">\(R/\mathrm{rad}(R)\)</span>，<span class="math inline">\(R/\mathrm{rad}(R)\)</span>的根是平凡的。Wedderburn 的想法是将 <span class="math inline">\(\mathrm{rad}(R)\)</span> 定义为 <span class="math inline">\(R\)</span> 的极大幂零理想，即 <span class="math inline">\(R\)</span>的所有<strong>幂零左理想</strong>的和：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(R\)</span> 的所有幂零左理想的和记作 <span class="math inline">\(\mathrm{rad}(R)\)</span>。</p></div><p>然而对左 Artin 环来说，这个定义的合理性是需要澄清的：</p><ol type="1"><li><span class="math inline">\(\mathrm{rad}(R)\)</span>幂零吗？不难证明有限多个幂零左理想的和总是幂零的，但是无穷多个幂零左理想的和还幂零吗？</li><li><span class="math inline">\(\mathrm{rad}(R)\)</span>是双边理想吗？</li></ol><p>虽然这两点确实都成立，但是背后的原因并不直观。</p><p>这两个问题都可以用一个引理来解决，这个引理的证明颇有一点技巧性：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(e\in R\)</span> 满足 <span class="math inline">\(e\ne0\)</span> 且 <span class="math inline">\(e^2=e\)</span>，就称 <span class="math inline">\(e\)</span> 是一个幂等元。</p></div><div id="idempotent" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理2.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(R\)</span> 是左 Artinian 环。如果左理想 <span class="math inline">\(I\subseteq R\)</span>不是幂零的，则其必然包含一个幂等元。</p></div><p>我们把 <a href="#idempotent" title="引理 2.4">引理 2.4</a>的证明稍微放一放，先看看它是怎么解决上面的问题 1, 2 的。</p><p>记 <span class="math inline">\(\{I_\alpha\}\)</span> 是 <span class="math inline">\(R\)</span> 的全体幂零左理想组成的集合，则 <span class="math inline">\(\mathrm{rad}(R)\)</span> 中的元素都是 <span class="math inline">\(\{I_{\alpha}\}\)</span> 中元素的有限线性组合：<span class="math display">\[x =x_{\alpha_1}+x_{\alpha_2}+\cdots+x_{\alpha_k},\quad x_{\alpha_i}\inI_{\alpha_i}.\]</span></p><ol type="1"><li>如果 <span class="math inline">\(\mathrm{rad}(R)\)</span>不是幂零的，那么根据 <a href="#idempotent" title="引理 2.4">引理 2.4</a>它包含一个幂等元 <span class="math inline">\(e\)</span>，于是 <span class="math inline">\(e\)</span>可以表示为有限多个幂零元的和，从而也是幂零的，矛盾！</li><li><span class="math inline">\(\mathrm{rad}(R)\cdot R\)</span>是一个双边理想，而且它是幂零的： <span class="math display">\[(\mathrm{rad}(R)\cdot R)^i=\mathrm{rad}(R)\cdot(R\cdot \mathrm{rad}(R))^{i-1}\cdot R\subseteq \mathrm{rad}(R)^i\cdotR.\]</span> 特别它是一个幂零左理想，于是 <span class="math inline">\(\mathrm{rad}(R)\cdot R\subseteq\mathrm{rad}(R)\)</span>，从而 <span class="math inline">\(\mathrm{rad}(R)\)</span> 是双边理想。</li></ol><p><strong><a href="#idempotent" title="引理 2.4">引理 2.4</a>的证明</strong>：</p><p>我们会反复使用 DCC 降链条件，即任何由 <span class="math inline">\(R\)</span> 的左理想构成的非空集合必有最小元。</p><p>首先不妨假设 <span class="math inline">\(I\)</span>是「极小」非幂零的，即 <span class="math inline">\(I\)</span>本身不幂零，但 <span class="math inline">\(I\)</span>的任何非平凡左理想都是幂零的。否则我们考察所有包含在 <span class="math inline">\(I\)</span>内的、非幂零的左理想组成的集合，此集合包含 <span class="math inline">\(I\)</span> 所以非空，于是根据 DCC条件它包含一个极小元 <span class="math inline">\(I_1\)</span>，<span class="math inline">\(I_1\)</span> 不是幂零的，但是任何真包含于 <span class="math inline">\(I_1\)</span> 内的左理想都是幂零的。用 <span class="math inline">\(I_1\)</span> 代替 <span class="math inline">\(I\)</span>，故而可以假设 <span class="math inline">\(I\)</span> 是极小非幂零的。</p><p>由于 <span class="math inline">\(I^2\subseteq I\)</span>，<span class="math inline">\(I^2\)</span> 不可能是幂零的，否则 <span class="math inline">\(I\)</span> 就幂零了，所以 <span class="math inline">\(I^2=I\)</span>。我们考察所有满足如下条件的左理想<span class="math inline">\(L\)</span> 组成的集合 <span class="math inline">\(S\)</span>：</p><ol type="1"><li><span class="math inline">\(L\subseteq I\)</span>。</li><li><span class="math inline">\(IL\ne0\)</span>。</li></ol><p>显然 <span class="math inline">\(I\in S\)</span> 从而 <span class="math inline">\(S\)</span> 非空，于是 <span class="math inline">\(S\)</span> 包含一个极小元 <span class="math inline">\(L\)</span>。由于 <span class="math inline">\(IL\ne0\)</span> 所以存在 <span class="math inline">\(x\in L\)</span> 使得 <span class="math inline">\(Ix\ne 0\)</span>。由于 <span class="math inline">\(Ix\)</span> 是包含在 <span class="math inline">\(L\)</span> 内的一个左理想，而且 <span class="math inline">\(I(Ix)=Ix\ne0\)</span> 所以 <span class="math inline">\(Ix\)</span> 也在 <span class="math inline">\(S\)</span> 中，由 <span class="math inline">\(L\)</span> 的极小性有 <span class="math inline">\(Ix=L\)</span>。由 <span class="math inline">\(x\inL\)</span> 可知存在 <span class="math inline">\(a\in I\)</span> 满足<span class="math inline">\(x=ax\)</span>，从而 <span class="math display">\[x= ax = a^2x = \cdots.\]</span> 所以 <span class="math inline">\(a\)</span> 不可能是幂零的，并且 <span class="math inline">\((a^2-a)x=0\)</span>。我们断言 <span class="math inline">\(a^2-a\)</span> 是幂零的。为此进一步考虑包含在<span class="math inline">\(I\)</span> 内的左理想 <span class="math display">\[N = \{ u\in I\ |\ ux = 0\}.\]</span> 于是 <span class="math inline">\(Nx=0\)</span>，但 <span class="math inline">\(Ix\ne0\)</span>，所以 <span class="math inline">\(N\)</span> 真包含于 <span class="math inline">\(I\)</span> 内，所以 <span class="math inline">\(N\)</span>是幂零的，从而其每个元素都是幂零的，特别地 <span class="math inline">\(a^2-a\in N\)</span>是幂零的。我们断言存在一个多项式 <span class="math inline">\(p\)</span>使得 <span class="math inline">\(u=p(a)\)</span> 是一个幂等元。为此假设<span class="math inline">\((a^2-a)^k=0\)</span>，展开以后可得存在多项式<span class="math inline">\(q\)</span> 使得 <span class="math inline">\(a^k=a^{k+1}q(a)\)</span>，从而 （反复将等式右边的<span class="math inline">\(a^k\)</span> 替换为 <span class="math inline">\(a^{k+1}q(a)\)</span>） <span class="math display">\[a^k=a^kaq(a)=a^{k+2}q^2(a)=a^{k+3}q^3(a)=\cdots=a^{2k}q^{k}(a).\]</span>令 <span class="math inline">\(e=a^kq^k(a)\)</span>，则 <span class="math inline">\(a^k=a^ke\)</span>, 由于 <span class="math inline">\(a\)</span> 不是幂零的所以 <span class="math inline">\(e\ne0\)</span>。在 <span class="math inline">\(a^k=a^ke\)</span> 两边同乘以 <span class="math inline">\(q^k(a)\)</span> 得到 <span class="math inline">\(a^kq^k(a)=a^{k}q^{k}(a)e\)</span>，即 <span class="math inline">\(e=e^2\)</span>，从而 <span class="math inline">\(e\)</span> 是幂等元，这就证明了结论。<span class="math inline">\(\blacksquare\)</span></p><p>整理上述讨论，我们给出半单性的定义：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.5</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(R\)</span> 是左 Artinian 环，定义其根 <span class="math inline">\(\mathrm{rad}(R)\)</span> 为 <span class="math inline">\(R\)</span> 的所有幂零左理想之和，则 <span class="math inline">\(\mathrm{rad}(R)\)</span>是双边理想，且是幂零的。如果 <span class="math inline">\(\mathrm{rad}(R)=0\)</span>，即 <span class="math inline">\(R\)</span> 不含任何非零的幂零左理想，就称 <span class="math inline">\(R\)</span> 是<strong>半单</strong>的。</p></div><p>不难验证环 <span class="math inline">\(R/\mathrm{rad}(R)\)</span>不含非零的幂零左理想，从而它符合我们对半单性的定义。下面的任务就是对半单环进行讨论。</p><p><a href="#idempotent" title="引理 2.4">引理 2.4</a>有一个简单的推论，后面会用到。我把它写在这里：</p><div id="L-proj" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.6</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(R\)</span> 是半单左 Artinian 环，<span class="math inline">\(L\)</span> 是 <span class="math inline">\(R\)</span> 的极小左理想，<span class="math inline">\(e\in L\)</span> 是幂等元，则：</p><ol type="1"><li>对任何 <span class="math inline">\(R\)</span> 的左理想 <span class="math inline">\(I\supset L\)</span> 都有 <span class="math inline">\(Ie=L\)</span>。</li><li>对任何 <span class="math inline">\(x\in L\)</span> 有 <span class="math inline">\(xe=x\)</span>。</li></ol></div><p>这里 <span class="math inline">\(e\)</span> 的存在性由 <span class="math inline">\(R\)</span> 半单以及 <a href="#idempotent" title="引理 2.4">引理 2.4</a> 保证。这个结论的含义是，对 <span class="math inline">\(x\in R\)</span>，右乘 <span class="math inline">\(x\mapsto xe\)</span> 将 <span class="math inline">\(x\)</span> 投影到 <span class="math inline">\(L\)</span> 中。特别地，这个投影保持 <span class="math inline">\(L\)</span> 中的元素不动。</p><p><strong>证明</strong>：</p><ol type="1"><li>显然 <span class="math inline">\(Ie\subset L\)</span>，并且 <span class="math inline">\(e=e\cdot e\in Ie\)</span>，所以 <span class="math inline">\(Ie\ne (0)\)</span>，于是由 <span class="math inline">\(L\)</span> 是极小左理想可得 <span class="math inline">\(Ie=L\)</span>。</li><li>取 <span class="math inline">\(I=R\)</span> 即得 <span class="math inline">\(L=Re\)</span>，即 <span class="math inline">\(L\)</span> 中的任何元素 <span class="math inline">\(x\)</span> 都形如 <span class="math inline">\(x=ae,\,a\in R\)</span>。于是 <span class="math inline">\(xe=ae^2=ae=x\)</span>。<span class="math inline">\(\blacksquare\)</span></li></ol><h1 id="将半单环分解为单环的直和">将半单环分解为单环的直和</h1><p>我们将证明半单环总是可以分解为一些单环的直和（单环的含义后面会介绍），而且这种分解还是唯一的。如果用整数分解为素数乘积来类比的话，极小左理想相当于单个素因子，单环相当于某个素因子的幂。</p><p>我们首先来证明半单环的极小左理想具有直和补性质。首先是一个引理：</p><div id="ideal-decomp" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(R\)</span> 是半单环，<span class="math inline">\(L\subset I\)</span> 都是 <span class="math inline">\(R\)</span> 的左理想并且 <span class="math inline">\(L\)</span> 还是极小左理想，则存在 <span class="math inline">\(R\)</span> 的左理想 <span class="math inline">\(J\)</span> 满足 <span class="math inline">\(I=L\oplus J\)</span>。</p></div><p><strong>证明</strong>： 根据 <a href="#L-proj" title="推论 2.6">推论2.6</a>，设幂等元 <span class="math inline">\(e\in L\)</span> 满足 <span class="math inline">\(I=Le\)</span>。考虑 <span class="math inline">\(J=I(1-e)\)</span>，这也是一个包含在 <span class="math inline">\(I\)</span> 中的左理想。显然 <span class="math inline">\(I=Ie\oplus I(1-e)=L\oplus J\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="decompose-minimal" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.2</span>.</span><span class="statement-spah"> </span>半单环 <span class="math inline">\(R\)</span> 一定可以分解为有限个极小左理想的直和<span class="math inline">\(R=L_1\oplus\cdots\oplus L_n\)</span>。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(L_1\)</span> 是<span class="math inline">\(R\)</span> 的任一极小左理想，在 <a href="#ideal-decomp" title="引理 3.1">引理 3.1</a> 中取 <span class="math inline">\(L=L_1,I=R\)</span> 可得存在 <span class="math inline">\(R\)</span> 的左理想 <span class="math inline">\(J\)</span> 使得 <span class="math inline">\(R=L_1\oplus J\)</span>。如果 <span class="math inline">\(J\)</span> 非零，则它包含 <span class="math inline">\(R\)</span> 的某个极小左理想 <span class="math inline">\(L_2\)</span>。同样地 <span class="math inline">\(J\)</span> 可以进一步分解为 <span class="math inline">\(J=L_2\oplus K\)</span>。其中 <span class="math inline">\(K\)</span> 也是 <span class="math inline">\(R\)</span> 的左理想。这样继续分解下去，由于 <span class="math inline">\(R\)</span> 是左 Artinian环，这样的分解只能进行有限多次，所以 <span class="math display">\[R=L_1\oplus J =L_1\oplus L_2\oplus K = \cdots =L_1\oplus L_2\oplus\cdots\oplus L_n.\]</span> <span class="math inline">\(\blacksquare\)</span></p><p>我们接下来要把 <span class="math inline">\(R=\oplus_{i=1}^nL_i\)</span> 中所有同构于某个<span class="math inline">\(L_i\)</span>的极小左理想合起来，形成一个单环。这类似于在整数的素因子分解中把相同的素数的乘积合起来得到单一素因子的幂。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义3.3</span>.</span><span class="statement-spah"></span>如果两个极小左理想 <span class="math inline">\(L,L'\)</span>作为左 <span class="math inline">\(R-\)</span>模是同构的，就称它们是同构的，记作 <span class="math inline">\(L\congL'\)</span>。</p></div><p>我们先来说明极小左理想具有某种「正交性」：</p><div id="two-left-ideals" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.4</span>.</span><span class="statement-spah"> </span>两个极小左理想<span class="math inline">\(L\cong L'\)</span> 当且仅当 <span class="math inline">\(L'L\ne0\)</span>。特别地这个同构可以由右乘一个元素<span class="math inline">\(a\in L\)</span> 给出：<span class="math inline">\(L'=La\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(L'L\subset L\)</span>，它只能是 <span class="math inline">\((0)\)</span> 或者 <span class="math inline">\(L\)</span>，所以陈述 <span class="math inline">\(L'L\ne0\)</span> 等价于 <span class="math inline">\(L'L=L\)</span>。于是我们只要证明以下三点是等价的即可：</p><div class="statement simple plain unnumbered"><ol type="1"><li><span class="math inline">\(L\cong L'\)</span>。</li><li>存在 <span class="math inline">\(a\in L\)</span> 使得 <span class="math inline">\(L=L'a\)</span>。</li><li><span class="math inline">\(L'L = L\)</span>。</li></ol></div><p><span class="math inline">\(1\Rightarrow 2\)</span>： 设 <span class="math inline">\(\varphi: L\to L'\)</span> 是一个左 <span class="math inline">\(R-\)</span> 模同构，利用 <a href="#L-proj" title="推论 2.6">推论 2.6</a> 的结论，设 <span class="math inline">\(e\in L\)</span> 是幂等元，则对任何 <span class="math inline">\(x\in L\)</span> 都有 <span class="math inline">\(x=xe\)</span>，所以 <span class="math display">\[\varphi(x)=\varphi(xe)=x\varphi(e),\quad x\inL.\]</span> 即同构 <span class="math inline">\(\varphi\)</span> 由右乘<span class="math inline">\(a=\varphi(e)\)</span> 给出。</p><p><span class="math inline">\(2\Rightarrow 3\)</span>： 注意到 <span class="math inline">\(L'L\subset L\)</span> 和 <span class="math inline">\(L'L\supset L'a=L\)</span> 即可。</p><p><span class="math inline">\(3\Rightarrow 1\)</span>： 若 <span class="math inline">\(L'L=L\)</span>，则存在 <span class="math inline">\(a\in L\)</span> 使得 <span class="math inline">\(L'a\ne0\)</span>，而 <span class="math inline">\((0)\ne L'a\subset L\)</span>，所以 <span class="math inline">\(L'a=L\)</span>，于是 <span class="math inline">\(y\to ya\)</span> 给出了从 <span class="math inline">\(L'\)</span> 到 <span class="math inline">\(L\)</span> 的一个左 <span class="math inline">\(R-\)</span> 模同构。<span class="math inline">\(\blacksquare\)</span></p><div id="left-ideal" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论3.5</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(R=\oplus_{i=1}^n L_i\)</span> 是上面所述的将 <span class="math inline">\(R\)</span> 分解极小左理想的直和，则 <span class="math inline">\(R\)</span> 的任何极小左理想必然同构于某个 <span class="math inline">\(L_i\)</span>。</p></div><p><strong>证明</strong>：对任何极小左理想 <span class="math inline">\(L\)</span> 有 <span class="math inline">\(L=\oplus_{i=1}^nLL_i\)</span>，所以必然存在某个<span class="math inline">\(i\)</span> 使得 <span class="math inline">\(LL_i\ne0\)</span>，从而根据 <a href="#two-left-ideals" title="引理 3.4">引理 3.4</a> 有 <span class="math inline">\(L\cong L_i\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>对 <span class="math inline">\(R\)</span> 的任一极小左理想 <span class="math inline">\(L\)</span>，记 <span class="math inline">\(B_L\)</span> 为 <span class="math inline">\(R\)</span> 的所有同构于 <span class="math inline">\(L\)</span> 的极小左理想的和。我们来分析 <span class="math inline">\(B_L\)</span> 具有哪些性质。</p><div id="Bi-orth" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.6</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B_LB_{L'}\ne 0\)</span> 当且仅当 <span class="math inline">\(L\cong L'\)</span>。</p></div><p><strong>证明</strong>：由 <a href="#two-left-ideals" title="引理 3.4">引理 3.4</a> 这是显然的。<span class="math inline">\(\blacksquare\)</span></p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.7</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B_L\)</span> 是双边理想。</p></div><p><strong>证明</strong>：记 <span class="math inline">\(R =\oplus_{i=1}^nL_i\)</span> 为极小左理想的直和，于是 <span class="math inline">\(B_LR=\oplus_{i=1}^nB_LL_i\)</span>。右边每个 <span class="math inline">\(B_LL_i\)</span> 要么是 <span class="math inline">\((0)\)</span> (<span class="math inline">\(L_i\ncong L\)</span>)，要么等于 <span class="math inline">\(L_i\)</span> (<span class="math inline">\(L_i\congL\)</span>) 从而属于 <span class="math inline">\(B_L\)</span>，所以<span class="math inline">\(B_LR\subset B_L\)</span>，即 <span class="math inline">\(B_L\)</span> 是双边理想。<span class="math inline">\(\blacksquare\)</span></p><p>为简便以下记 <span class="math inline">\(B_i = B_{L_i}\)</span>。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.8</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B_L\)</span> 也有乘法单位元 （与 <span class="math inline">\(R\)</span> 的单位元未必相同）。</p></div><p><strong>证明</strong>：不妨设在 <span class="math inline">\(R =\oplus_{i=1}^nL_i\)</span> 中，<span class="math inline">\(\{L_1,\ldots,L_m\}\)</span> 是互不同构的，<span class="math inline">\(\{L_{m+1},\ldots, L_n\}\)</span> 中的任何一个都与<span class="math inline">\(\{L_1,\ldots, L_m\}\)</span>中的某一个同构，则 <span class="math inline">\(R=B_1+\cdots+B_m\)</span>。于是环 <span class="math inline">\(R\)</span> 的单位元可以表示为 <span class="math display">\[1 = e_1+\cdots + e_m,\quad e_i\in B_i.\]</span>对任何 <span class="math inline">\(x\in B_i\)</span>，利用 <span class="math inline">\(i\ne j\)</span> 时 <span class="math inline">\(B_iB_j=0\)</span> 有 <span class="math display">\[x=1\cdot x = e_1x+\cdots+e_mx = e_ix.\]</span> 同理也有 <span class="math inline">\(x=xe_i\)</span>。从而<span class="math inline">\(e_i\)</span> 是 <span class="math inline">\(B_i\)</span> 的乘法单位元。</p><p>根据 <a href="#left-ideal" title="推论 3.5">推论 3.5</a> 任何 <span class="math inline">\(B_L\)</span> 必然等于 <span class="math inline">\(\{B_1,\ldots,B_m\}\)</span>之一，所以也是有单位元的。<span class="math inline">\(\blacksquare\)</span></p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.9</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B_L\)</span> 也满足左理想的 DCC 降链条件。</p></div><p><strong>证明</strong>：只要说明 <span class="math inline">\(B_{L}\)</span> 的左理想 <span class="math inline">\(I\)</span> 也是 <span class="math inline">\(R\)</span> 的左理想即可：由于 <span class="math inline">\(e\)</span> 是 <span class="math inline">\(B_{L}\)</span> 的乘法单位元所以 <span class="math inline">\(I=eI\)</span>，于是 <span class="math inline">\(RI=ReI\subset B_{L}I\subset I\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>与这个引理的证明类似，我们可以得出 <span class="math inline">\(B_L\)</span> 的右理想 <span class="math inline">\(I\)</span> 也是 <span class="math inline">\(R\)</span> 的右理想。特别地 <span class="math inline">\(B_L\)</span> 的双边理想也是 <span class="math inline">\(R\)</span> 的双边理想。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.10</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B_L\)</span> 除了 (0)和自身外不含其它双边理想。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(D\)</span> 是<span class="math inline">\(B_L\)</span> 的非零双边理想，则 <span class="math inline">\(D\)</span> 也是 <span class="math inline">\(R\)</span> 的双边理想，从而其包含 <span class="math inline">\(R\)</span> 的某个极小左理想 <span class="math inline">\(L_1\)</span>，即<span class="math display">\[L_1\subset D \subset B_L.\]</span>由于 <span class="math inline">\(L_1B_L\supset L_1^2\ne0\)</span> 所以 <span class="math inline">\(L_1\cong L\)</span>。</p><p>由于对任意的 <span class="math inline">\(a\in R\)</span> 都有 <span class="math inline">\(L_1a\subset D\)</span>，根据 <a href="#two-left-ideals" title="引理 3.4">引理 3.4</a>，这些 <span class="math inline">\(L_1a\)</span> 跑遍所有与 <span class="math inline">\(L_1\)</span> 同构的极小左理想，从而 <span class="math inline">\(B_L\subset D\)</span>，于是 <span class="math inline">\(B_L=D\)</span>，即 <span class="math inline">\(B_L\)</span> 不含非平凡的双边理想。<span class="math inline">\(\blacksquare\)</span></p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.11</span>.</span><span class="statement-spah"> </span><span class="math inline">\(R = B_1\oplus\cdots\oplus B_m\)</span>。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(x_i\inB_i\)</span> 满足 <span class="math inline">\(x_1+\cdots+x_m=0\)</span>，两边同时乘以 <span class="math inline">\(B_i\)</span> 的单位元 <span class="math inline">\(e_i\)</span> 并利用 <a href="#Bi-orth" title="引理 3.6">引理 3.6</a> 可得 <span class="math inline">\(x_i=0\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.12</span>.</span><span class="statement-spah"> </span><span class="math inline">\(R\)</span> 的任何双边理想 <span class="math inline">\(I\)</span> 都可以表示为若干 <span class="math inline">\(B_i\)</span> 的直和。</p></div><p><strong>证明</strong>：由 <span class="math inline">\(R=\oplus_{i=1}^mB_i\)</span> 有 <span class="math inline">\(I=\oplus_{i=1}^m IB_i\)</span>。每个 <span class="math inline">\(IB_i\)</span> 都是 <span class="math inline">\(B_i\)</span> 中的双边理想，而我们已经证明了 <span class="math inline">\(B_i\)</span> 没有非平凡的双边理想，所以每个 <span class="math inline">\(IB_i\)</span> 要么等于 <span class="math inline">\(B_i\)</span>，要么等于 <span class="math inline">\((0)\)</span>，从而 <span class="math inline">\(I\)</span> 是一些 <span class="math inline">\(B_i\)</span> 的直和。<span class="math inline">\(\blacksquare\)</span></p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义3.13</span>.</span><span class="statement-spah"> </span>如果左 Artinian环 <span class="math inline">\(R\)</span> 除了 <span class="math inline">\((0)\)</span> 和自身外不含有其它的双边理想，就称<span class="math inline">\(R\)</span> 是<strong>单环</strong>。</p></div><p>显然单环的根都是 <span class="math inline">\((0)\)</span>，所以也是半单的。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.14</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(R\)</span> 是单环，则在同构意义下只有一种不可约左<span class="math inline">\(R-\)</span> 模，即 <span class="math inline">\(R\)</span> 的某个极小左理想。</p></div><p><strong>证明</strong>：显然 <span class="math inline">\(R\)</span>的所有极小左理想都是互相同构的。设 <span class="math inline">\(M\)</span> 是任一不可约左 <span class="math inline">\(R-\)</span> 模，则 <span class="math inline">\(R\)</span> 的某个极小左理想 <span class="math inline">\(L\)</span> 满足 <span class="math inline">\(LM\ne0\)</span>，从而存在 <span class="math inline">\(m\in M\)</span> 满足<span class="math inline">\(Lm\ne 0\)</span>，从而 <span class="math inline">\(Lm=M\)</span>。<span class="math inline">\(\phi\colon\ x\mapsto xm\)</span> 给出了 <span class="math inline">\(L\)</span> 到 <span class="math inline">\(M\)</span> 的 <span class="math inline">\(R-\)</span> 模同构。<span class="math inline">\(\blacksquare\)</span></p><p>至此我们已经把半单环 <span class="math inline">\(R\)</span>分解为了单环的直和： <span class="math display">\[R =B_1\oplus\cdots\oplus B_m.\]</span> 实际上这个分解还是唯一的，即若 <span class="math display">\[R = B'_1\oplus\cdots\oplus B'_l.\]</span>其中每个 <span class="math inline">\(B'_j\)</span> 是单环，并且是<span class="math inline">\(R\)</span> 的双边理想，则 <span class="math inline">\(m=l\)</span> 且适当重排以后有 <span class="math inline">\(B_i=B'_j\)</span>。（证明简单，略）</p><h1 id="单环的结构定理">单环的结构定理</h1><p>最终我们来到了单环的结构定理。在本节中，我们用 <span class="math inline">\(A\)</span> 来表示单环，以便与前面的半单环 <span class="math inline">\(R\)</span> 区分。</p><div id="w-a" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.1</span> <span class="statement-info">(Wedderburn-Artin)</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span>是单环，则存在除环 <span class="math inline">\(D\)</span> 使得 <span class="math inline">\(A\cong {\rm Mat}_n(D)\)</span>，这里 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(D\)</span> 由 <span class="math inline">\(A\)</span> 唯一确定。</p></div><p>我们先来验证 <span class="math inline">\({\rm Mat}_n(D)\)</span>是单环。记 <span class="math inline">\(e_{ij}\in {\rm Mat}_n(D)\)</span>是第 <span class="math inline">\((i,j)\)</span> 个分量为 1，其余位置都是0 的初等矩阵。</p><ol type="1"><li>恒等矩阵 <span class="math inline">\(I_n\)</span>是乘法单位元。</li><li><span class="math inline">\({\rm Mat}_n(D)\)</span>可以分解为极小左理想的直和 <span class="math display">\[{\rmMat}_n(D)={\rm Mat}_n(D)e_{11}\oplus\cdots {\rmMat}_n(D)e_{nn}.\]</span> 其中 <span class="math inline">\(\{e_{ii},\,1\leq i\leq n\}\)</span>是仅在对角线上第 <span class="math inline">\(i\)</span> 个元素为1，其余所有元素都为 0的矩阵，它们构成一组互相正交的幂等元，其和为单位矩阵。左理想 <span class="math inline">\(L_i={\rm Mat}_n(D)e_{ii}\)</span> 中的矩阵除了第<span class="math inline">\(i\)</span> 列以外，其余的列都是 0。<span class="math inline">\(L_i\)</span>是极小左理想是因为，对任何两个非零元素 <span class="math inline">\(x,y\in L_i\)</span>，我们总可以用初等行变换将<span class="math inline">\(x\)</span> 变成 <span class="math inline">\(y\)</span>，而初等行变换就是左乘一个 <span class="math inline">\({\rm Mat}_n(D)\)</span> 中的矩阵，所以任何非零元<span class="math inline">\(x\)</span> 都可以在 <span class="math inline">\({\rm Mat}_n(D)\)</span> 的左乘作用下生成整个 <span class="math inline">\(L_i\)</span>，所以 <span class="math inline">\(L_i\)</span> 确实是极小左理想。</li><li>这些极小左理想 <span class="math inline">\(L_i\,(1\leq i\leqn)\)</span> 是互相同构的。为此只要说明 <span class="math display">\[L_iL_j={\rm Mat}_n(D)e_{ii}\cdot {\rmMat}_n(D)e_{jj}\]</span> 不为 0 即可，而这个乘积包含 <span class="math inline">\(e_{ii}e_{ij}e_{jj}=e_{ij}\)</span>，当然不是0。</li></ol><p>下面回到 <a href="#w-a" title="定理 4.1">定理 4.1</a> 的证明。</p><p>大多数文献上对这一步的处理方式都是证明单环 <span class="math inline">\(A\)</span>和它的不可约模满足所谓的双重中心化子性质。我们先介绍大致的思路：</p><p>设 <span class="math inline">\(M\)</span> 是一个左 <span class="math inline">\(A-\)</span> 模，则 <span class="math inline">\(A\)</span> 在 <span class="math inline">\(M\)</span> 上的左乘给出了 <span class="math inline">\(A\to {\rm End}(M)\)</span> 的一个环同态，记 <span class="math inline">\(A\)</span> 在 <span class="math inline">\({\rmEnd}(M)\)</span> 中的同态像为 <span class="math inline">\(A_L\)</span>。由于 <span class="math inline">\(A\)</span> 是单环所以 <span class="math inline">\(A\cong A_L\)</span>。</p><p>记 <span class="math inline">\(D={\rm Hom}_A(M,M)\)</span> 为 <span class="math inline">\(M\)</span> 的 <span class="math inline">\(A-\)</span> 模自同态。<span class="math inline">\(D\)</span> 正是 <span class="math inline">\(A_L\)</span> 在 <span class="math inline">\({\rmEnd}(M)\)</span> 中的中心化子： <span class="math display">\[(am)d =a(md),\quad a\in A_L,\,m\in M,\,d\in D.\]</span> 值得注意的是，我们把<span class="math inline">\(A_L\)</span>的作用写在左边（这就是为什么用了 <span class="math inline">\(L\)</span>作为下标），<span class="math inline">\(D\)</span> 在 <span class="math inline">\(M\)</span> 上的作用写在右边：对任何 <span class="math inline">\(d\in D\)</span>，<span class="math inline">\(d\)</span> 在 <span class="math inline">\(M\)</span> 上的作用为 <span class="math inline">\(m\to md\)</span>。把 <span class="math inline">\(D\)</span>的作用写在右边有两个好处：一是可以避免后面在矩阵中使用讨厌的反环记号 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，二是这样一来 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(D\)</span> 交换就等价于说 <span class="math inline">\(M\)</span> 是一个 <span class="math inline">\((A,D)-\)</span> 双模。</p><p>进一步记 <span class="math inline">\(E={\rm Hom}_D(M,M)\)</span> 为<span class="math inline">\(D\)</span> 在 <span class="math inline">\({\rm End}(M)\)</span> 中的中心化子，<span class="math inline">\(E\)</span> 在 <span class="math inline">\(M\)</span> 上的作用写在左边。即 <span class="math inline">\(E\)</span> 由所有满足 <span class="math display">\[(fm)d = f(md),\quad f\in {\rm End}(M),\,m\inM,\,d\in D.\]</span> 的自同态 <span class="math inline">\(f\)</span>组成。显然 <span class="math inline">\(E\)</span> 是由 <span class="math inline">\(A_L\)</span> 在 <span class="math inline">\({\rmEnd}(M)\)</span> 中连续取两次中心化子得到的，且 <span class="math inline">\(A_L\subseteq E\)</span>。特别地，如果 <span class="math inline">\(A_L=E\)</span> 我们就称 <span class="math inline">\((A,M)\)</span>具有<strong>双重中心化子性质</strong>。</p><p>设 <span class="math inline">\(M\)</span> 是 <span class="math inline">\(A\)</span> 的一个极小左理想，从而 <span class="math inline">\(M\)</span> 也是不可约左 <span class="math inline">\(A-\)</span> 模。我们希望证明 <span class="math inline">\((A,M)\)</span> 具有双重中心化子性质。这时 <span class="math inline">\(D={\rm Hom}_A(M,M)\)</span> 是除环，<span class="math inline">\(M\)</span> 作为右 <span class="math inline">\(D-\)</span> 模是除环 <span class="math inline">\(D\)</span> 上的右向量空间。若 <span class="math inline">\((A,M)\)</span> 具有双重中心化子性质则 <span class="math inline">\(A\cong A_L\cong {\rm Hom}_D(M,M)\)</span>，即<span class="math inline">\(A\)</span> 同构于除环 <span class="math inline">\(D\)</span> 上的右向量空间 <span class="math inline">\(M\)</span> 上的所有 <span class="math inline">\(D-\)</span> 线性变换构成的环。特别地如果维数 <span class="math inline">\(\dim_D  M=n&lt;\infty\)</span>，则 <span class="math inline">\(A\cong {\rm Mat}_n(D)\)</span>，这就证明了Wedderburn-Artin 定理。</p><p>于是我们的思路就是先证明 <span class="math inline">\((A, M)\)</span>具有双重中心化子性质，再证明 <span class="math inline">\(\dim_DM&lt;\infty\)</span>。</p><p>注意到对左正则模 <span class="math inline">\(_AA\)</span> ，<span class="math inline">\((A, \,_AA)\)</span>是具有双重中心化子性质的。事实上很容易验证 <span class="math inline">\(A\)</span> 在自身上的左乘 <span class="math inline">\(A_L\)</span> 和右乘 <span class="math inline">\(A_R\)</span> 互为对方在 <span class="math inline">\({\rm End}(A)\)</span> 中的中心化子，所以 <span class="math inline">\((A,\, _AA)\)</span> 是具有双重中心化子性质的。</p><p>当 <span class="math inline">\(A\)</span> 是单环时，左正则模 <span class="math inline">\(_AA\)</span> 同构于 <span class="math inline">\(A\)</span> 的某个极小左理想 <span class="math inline">\(L\)</span> 的若干重直和：<span class="math inline">\(_AA\cong\oplus_{i=1}^nL\)</span>，所以我们只要证明这样的结论就好了：</p><div id="A-M" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理4.2</span>.</span><span class="statement-spah"> </span>设左 <span class="math inline">\(A-\)</span> 模 <span class="math inline">\(V,M\)</span> 满足 <span class="math inline">\(V=\oplus_{i=1}^n M\)</span>。若 <span class="math inline">\((A, V)\)</span> 具有双重中心化子性质，则 <span class="math inline">\((A, M)\)</span> 也具有双重中心化子性质。</p></div><p>注意这个引理中 <span class="math inline">\(A\)</span>可以是任意的环，不仅限于单环；<span class="math inline">\(M\)</span>也是任意的左 <span class="math inline">\(A-\)</span>模，不仅限于不可约模。</p><p><strong>证明</strong>：对任何 <span class="math inline">\(f\in E={\rmHom}_D(M, M)\)</span>，将其提升为 <span class="math inline">\(V\)</span>的一个自同态 <span class="math display">\[f^\ast: (m_1,m_2,\ldots,m_n)\to (f(m_1), f(m_2), \ldots, f(m_n)).\]</span> 我们希望证明 <span class="math inline">\(f^\ast \in {\rm Hom}_{D^\ast}(V, V)\)</span>，其中<span class="math inline">\(D^\ast={\rm Hom}_A(V,V)\)</span>，这样利用已知 <span class="math inline">\((A, V)\)</span>具有双重中心化子性质，可得 <span class="math inline">\(f^\ast\)</span>来自某个 <span class="math inline">\(a\in A\)</span> 在 <span class="math inline">\(V\)</span> 上的左乘，即对任何 <span class="math inline">\((m_1,m_2,\ldots,m_n)\)</span> 有 <span class="math display">\[ f^\ast(m_1,m_2,\ldots, m_n)=  (am_1,am_2,\ldots,am_n).\]</span> 只看第一个分量即得对任何 <span class="math inline">\(m\in M\)</span> 有 <span class="math inline">\(f(m)=am\)</span>，这就证明了结论。</p><p>为此我们只要注意到 <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> （一个简单的练习，细节见脚注） <span class="math display">\[D^\ast={\rm Hom}_A(\oplus_{i=1}^nM,\oplus_{i=1}^nM)\cong {\rm Mat}_n({\rm Hom}_A(M, M)) = {\rmMat}_n(D).\]</span> 换言之任何 <span class="math inline">\(\varphi\inD^\ast\)</span> 都形如 <span class="math inline">\(\varphi=(d_{ij})_{1\leq i,j\leq n}\)</span>，其中<span class="math inline">\(d_{ij}\in D={\rmHom}_A(M,M)\)</span>，所以验证 <span class="math inline">\(f^\ast\in{\rmHom}_{D^\ast}(V, V)\)</span> 变成了验证一串矩阵等式： <span class="math display">\[\begin{align*}(f^\ast(m_1,\ldots,m_n))\varphi&amp;=(f(m_1),\ldots,f(m_n))\varphi\\&amp;=(f(m_1),\ldots,f(m_n))\begin{pmatrix}d_{11}&amp;\cdots&amp;d_{1n}\\\vdots&amp;\ddots&amp;\vdots\\d_{n1}&amp;\cdots&amp;d_{nn}\end{pmatrix}\\&amp;=\left(\sum_{i=1}^nf(m_i)d_{i1},\ldots,\sum_{i=1}^nf(m_i)d_{in}\right)\\&amp;=\left(f(\sum_{i=1}^nm_id_{i1}),\ldots,f(\sum_{i=1}^nm_id_{in})\right)\\&amp;=f^\ast\left(\sum_{i=1}^nm_id_{i1},\ldots,\sum_{i=1}^nm_id_{in}\right)\\&amp;=f^\ast((m_1,\ldots,m_n)\varphi)\end{align*}\]</span></p><p>即 <span class="math inline">\(f^\ast \in {\rm Hom}_{D^\ast}(V,V)\)</span>，<a href="#A-M" title="引理 4.2">引理 4.2</a> 得证。<span class="math inline">\(\blacksquare\)</span></p><p>这样我们就证明了单环具有双重中心化子性质。我把结论明确写下来：</p><div id="double-centralizer" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是单环，<span class="math inline">\(M\)</span> 是不可约左 <span class="math inline">\(A-\)</span> 模。将除环 <span class="math inline">\(D={\rm Hom}_A(M,M)\)</span> 的作用写在 <span class="math inline">\(M\)</span> 右边，则 <span class="math inline">\(A\cong {\rm Hom}_D(M,M)\)</span>。特别地 <span class="math inline">\({\rm Hom}_D(M,M)\)</span> 也是单环。</p></div><p>我们还需要证明 <span class="math inline">\(\dim_DM&lt;\infty\)</span>。由于我们在 <a href="#double-centralizer" title="命题 4.3">命题 4.3</a> 中证明了 <span class="math inline">\({\rmHom}_D(M,M)\)</span> 是单环，所以 <span class="math inline">\(\dim_DM&lt;\infty\)</span> 的结论立刻可以由下面的命题得出：</p><div id="dim-D-finite" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(M\)</span> 是除环 <span class="math inline">\(D\)</span> 上的右向量空间，则 <span class="math inline">\(\dim_D M&lt;\infty\)</span> 当且仅当 <span class="math inline">\({\rm Hom}_D(M,M)\)</span> 是单环。</p></div><p><strong>证明</strong>：<span class="math inline">\(\Rightarrow\)</span>说的是除环上的矩阵环都是单环，这一点在前面已经讨论过了。只要再证明 <span class="math inline">\(\Leftarrow\)</span>。用反证法，如果 <span class="math inline">\(\dim_D M=\infty\)</span>，考虑 <span class="math inline">\({\rm Hom}_D(M,M)\)</span> 的子集 <span class="math display">\[I = \{ f\in {\rm Hom}_D(M,M) \mid \dim_D  {\rmim}(f) &lt;\infty\}.\]</span> 我们来验证 <span class="math inline">\(I\)</span> 是 <span class="math inline">\({\rmHom}_D(M,M)\)</span> 中非平凡的双边理想。</p><ol type="1"><li>由于 <span class="math inline">\(\dim_DM=\infty\)</span>，所以恒等映射不包含在 <span class="math inline">\(I\)</span> 中，所以 <span class="math inline">\(I\ne {\rm Hom}_D(M,M)\)</span>。</li><li>由于 <span class="math inline">\({\rm im}(f_1+f_2)\subset {\rmim}(f_1)+{\rm im}(f_2)\)</span>，所以 <span class="math inline">\(I\)</span> 对加法是封闭的。</li><li>设 <span class="math inline">\(f\in I,\,g\in {\rmHom}_D(M,M)\)</span>，则不难验证 <span class="math inline">\({\rmim}(fg)\)</span> 和 <span class="math inline">\({\rm im}(gf)\)</span>都是有限维的。</li><li><span class="math inline">\(I\ne(0)\)</span>。为此只要取 <span class="math inline">\(M\)</span> 的一组 <span class="math inline">\(D-\)</span> 基 <span class="math inline">\(\{e_\alpha\}\)</span>，并固定某个基元素 <span class="math inline">\(e_\beta\)</span>，规定 <span class="math display">\[f\colon\ \sum e_\alpha d_\alpha\mapsto e_\betad_\beta .\]</span> 即 <span class="math inline">\(f\)</span> 是到 <span class="math inline">\(e_\beta\)</span> 生成的一维子空间的投影。<span class="math inline">\(f\in I\)</span> 并且 <span class="math inline">\(f(e_\beta)=e_\beta\)</span> 不是零映射。</li></ol><p><span class="math inline">\(\blacksquare\)</span></p><p>最后我们来说明 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(D\)</span> 是唯一确定的，即若 <span class="math inline">\(n'\)</span> 和 <span class="math inline">\(D'\)</span> 使得 <span class="math inline">\(A\cong {\rm Mat}_n(D)\cong {\rmMat}_{n'}(D')\)</span>，则 <span class="math inline">\(n=n'\)</span> 且 <span class="math inline">\(D\cong D'\)</span>。从上面的证明中我们已经看到<span class="math inline">\(n\)</span> 是 <span class="math inline">\(A\)</span> 分解为极小左理想 <span class="math inline">\(M\)</span> 直和的重数，从而是唯一确定的。而除环<span class="math inline">\(D={\rm Hom}_A(M,M)\)</span>是其唯一不可约模的 <span class="math inline">\(A-\)</span>自同态环，所以也是唯一确定的。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-curtis-reiner" class="csl-entry" role="listitem">Curtis, C.W., and I. Reiner. 1962. <em>Representation Theory of FiniteGroups and Associative Algebras</em>. New York: Interscience Publishers,a division of John Wiley &amp; Sons.</div><div id="ref-herstein-rings" class="csl-entry" role="listitem">Herstein, I. N. 1994. <em>Noncommutative Rings</em>. Vol. 15. CarusMathematical Monographs. Mathematical Association of America,Washington, DC.</div><div id="ref-Lam01" class="csl-entry" role="listitem">Lam, T. Y. 2001. <em>A First Course in Noncommutative Rings</em>. Secondedition. Vol. 131. Graduate Texts in Mathematics. Springer-Verlag, NewYork.</div></div><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>除环上的向量空间与域上的向量空间的一个显著不同是：如果<span class="math inline">\(V\)</span> 是一个左 <span class="math inline">\(D-\)</span> 向量空间且 <span class="math inline">\(\dim _DV=n\)</span>，则其 <span class="math inline">\(D-\)</span> 自同态环 <span class="math inline">\({\rm End}_D(V)\cong {\rm Mat}_n(D^{\rmop})\)</span>，这里 <span class="math inline">\(D^{\rm op}\)</span> 是<span class="math inline">\(D\)</span> 的反环。但是如果 <span class="math inline">\(V\)</span> 是右 <span class="math inline">\(D-\)</span> 向量空间，并且把 <span class="math inline">\({\rm End}_D(V)\)</span> 在 <span class="math inline">\(V\)</span> 上的作用写在左边的话（即把 <span class="math inline">\(V\)</span> 看作是 <span class="math inline">\(({\rm End}_D(V), D)-\)</span> 双模），则 <span class="math inline">\({\rm End}_D(V)\cong {\rm Mat}_n(D)\)</span>。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>记 <span class="math inline">\(i_k\)</span> 是从 <span class="math inline">\(M\)</span> 到 <span class="math inline">\(\oplus_{i=1}^nM\)</span> 的第 <span class="math inline">\(k\)</span> 个分量的嵌入映射： <span class="math display">\[i_k: m\to(0, 0,\ldots, m,\ldots, 0).\]</span><span class="math inline">\(\pi_l\)</span> 是从 <span class="math inline">\(\oplus_{i=1}^nM\)</span> 的第 <span class="math inline">\(l\)</span> 个分量到 <span class="math inline">\(M\)</span> 的投影： <span class="math display">\[\pi_l: (m_1,\ldots,m_l,\ldots, m_n) \tom_l.\]</span> 对任何 <span class="math inline">\(\varphi\in {\rmHom}_A(\oplus_{i=1}^nM,\oplus_{i=1}^nM)\)</span>，<span class="math inline">\((m_1,\ldots,m_n)\varphi\)</span> 的第 <span class="math inline">\(j\)</span> 个分量当然就是 <span class="math inline">\((m_1,\ldots,m_n)\varphi\circ\pi_j\)</span>。进一步把左边的<span class="math inline">\((m_1,\ldots,m_n)\)</span> 拆成求和有 <span class="math display">\[(m_1,\ldots,m_n)\varphi\circ\pi_j=\left(\sum_{i=1}^nm_i\circi_i\right)\varphi\circ\pi_j=\sum_{i=1}^nm_i(i_i\circ\varphi\circ\pi_j)=\sum_{i=1}^nm_i\varphi_{ij}.\]</span>其中 <span class="math inline">\(\varphi_{ij}=i_i\circ\varphi\circ\pi_j\in{\rmHom}_A(M,M)\)</span>，注意 <span class="math inline">\(\varphi_{ij}\)</span> 是写在 <span class="math inline">\(m\)</span> 右边的，<span class="math inline">\(i_i\)</span> 先作用，其次是 <span class="math inline">\(\varphi\)</span>，最后是 <span class="math inline">\(\pi_j\)</span>。 这告诉我们 <span class="math inline">\((m_1,\ldots,m_n)\varphi\)</span> 的第 <span class="math inline">\(j\)</span> 个分量等于 <span class="math inline">\(\sum_{i=1}^nm_i\varphi_{ij}\)</span>，即下面的矩阵乘法等式成立：<span class="math display">\[(m_1,\ldots,m_n)\varphi=(m_1,\ldots,m_n)\begin{pmatrix}\varphi_{11}&amp;\cdots&amp;\varphi_{1n}\\\vdots&amp;\ddots&amp;\vdots\\\varphi_{n1}&amp;\cdots&amp;\varphi_{nn}\end{pmatrix}.\]</span>不难验证 <span class="math inline">\(\varphi\to(\varphi_{ij})\)</span>是一个从 <span class="math inline">\({\rmHom}_A(\oplus_{i=1}^nM,\oplus_{i=1}^nM)\)</span> 到 <span class="math inline">\({\rm Mat}_n(D)\)</span> 的同构。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 有限群表示与结合代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>不可能的密铺</title>
      <link href="/conway-tiling-group/"/>
      <url>/conway-tiling-group/</url>
      
        <content type="html"><![CDATA[<p>Conway 等人在论文 <span class="citation" data-cites="Conway1990">(<a href="#ref-Conway1990" role="doc-biblioref">Conway and Lagarias1990</a>)</span> 中提出了下面的问题：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>依次将 <span class="math inline">\(1,2,\ldots,n\)</span>个全等的正六边形摞在一起，得到的图案记作 <span class="math inline">\(T_n\)</span>，下图是 <span class="math inline">\(n=7\)</span> 的例子：</p><p><img src="/images/tilinggroup/region.svg" class="fig" width="300"></p><p>把三个连在一起、且对称中心在一条直线上的正六边形组成的图案叫做「骨头」，根据摆放的角度有三种不同的骨头：</p><p><img src="/images/tilinggroup/bones.svg" class="fig" width="480"></p><p>求证对任何 <span class="math inline">\(n\)</span>，<span class="math inline">\(T_n\)</span> 都不可能用若干骨头恰好密铺。</p></div><p>Conway等人的论文里面包含了好几个密铺的问题，上面这个问题只是其中一个。虽然这个问题的表述很简单，但它的解法并不“初等”。这里我称之为“”初等”的方法是染色法。染色法是最常用的论证不可能密铺的手段。它的基本思想是，用一个Abel 群（一般是有理数域 <span class="math inline">\(\mathbb{Q}\)</span>）给平面上每一个正六边形作标记，使得任何骨头覆盖的三个正六边形的标记之和为整数，但是整个区域所有正六边形标记之和不是整数，这样来得出矛盾。</p><p>然而，Conway等人在论文中借助“密铺的同调群”证明了染色方法在这个问题中是无法得出矛盾的。我简要地解释一下原因：染色方法可以成功的必要条件是<span class="math inline">\(T_n\)</span>对应的群元素在骨头生成的同调群中不是恒等元，从而无法被密铺。而这个问题中，<span class="math inline">\(T_n\)</span>对应的群元素在同调群中确实是恒等元（构造适当的 signed tiling即可）。所以染色法对这个问题无效！</p><p>Conway等人用“密铺的同伦群”给出了不可能密铺的证明。同伦群方法的基本思想是，我们仍然用一个群（未必是Abel群）的元素作标记，但是这次是给区域和瓷砖的<strong>边界</strong>作标记，来获得密铺的某种不变量，并说明<span class="math inline">\(T_n\)</span>的<strong>边界</strong>不满足这个不变量，从而导出矛盾。本文就来介绍这一证明。</p><span id="more"></span><hr><p>由于 <span class="math inline">\(T_n\)</span> 包含 <span class="math inline">\(n(n+1)/2\)</span> 个正六边形，因此 <span class="math inline">\(T_n\)</span> 可以被密铺的必要条件是 <span class="math inline">\(3\mid n(n+1)\)</span>，即 <span class="math inline">\(n\equiv0,2\pmod{3}\)</span>。如果对某个 <span class="math inline">\(n\equiv2\pmod{3}\)</span>，<span class="math inline">\(T_n\)</span> 可以被若干块骨头密铺，则 <span class="math inline">\(n+1\equiv0\pmod{3}\)</span>也可以：因为我们可以在下方补上 <span class="math inline">\((n+1)/3\)</span> 个水平方向的骨头，得到 <span class="math inline">\(T_{n+1}\)</span> 的一个密铺：</p><p><img src="/images/tilinggroup/addrow.svg" class="fig" width="300"></p><p>所以我们只要论证 <span class="math inline">\(n\equiv0\pmod{3}\)</span> 时 <span class="math inline">\(T_n\)</span> 无论如何都不可能被密铺即可。</p><p>首先我们考虑平面上由正六边形组成的无穷网格，对每条边根据其方向标上<span class="math inline">\(a,b,c\)</span> 之一，如下图所示：</p><figure id="Cayley-A"><img src="/images/tilinggroup/hexgrid.svg" class="fig" width="300" alt="A 的 Cayley 图 \mathcal{G}(A)"><figcaption aria-hidden="true"><span class="math inline">\(A\)</span> 的Cayley 图 <span class="math inline">\(\mathcal{G}(A)\)</span></figcaption></figure><p>这个图是群 <span class="math display">\[A=\langle a,b,c\mida^2=b^2=c^2=(abc)^2=1\rangle\]</span> 的 <a href="https://en.wikipedia.org/wiki/Cayley_graph">Cayley 图</a>，记作<span class="math inline">\(\mathcal{G}(A)\)</span>。由于 <span class="math inline">\(a,b,c\)</span> 都是 2 阶元，所以 <span class="math inline">\(\mathcal{G}(A)\)</span> 中的边都是无向的。</p><p>但是，我们并不打算在 <span class="math inline">\(A\)</span>中处理问题。相反我们考虑更大的自由群</p><p><span class="math display">\[F=\langle a,b,c\ |\a^2=b^2=c^2=1\rangle\]</span></p><p><span class="math inline">\(F\)</span> 同构于 3 个 <span class="math inline">\(\mathbb{Z}_2\)</span> 的自由积：<span class="math inline">\(F\cong\mathbb{Z}_2\ast\mathbb{Z}_2\ast\mathbb{Z}_2\)</span>。</p><p>设 <span class="math inline">\(D\)</span> 是 <span class="math inline">\(\mathcal{G}(A)\)</span> 中的单连通有限区域，边界为<span class="math inline">\(\partial D\)</span>，<span class="math inline">\(\partial D\)</span> 是一条简单闭路径。从 <span class="math inline">\(\partial D\)</span>上任一点出发，绕着边界逆时针一周可以得到此路径的对应的一个字 (word)<span class="math inline">\(\pi\in F\)</span>。</p><p>例如，从下图中标注的红色点出发时，<span class="math inline">\(T_n\)</span> 的边界字为 <span class="math inline">\(\pi=(ac)^n(ba)^n(cb)^n\)</span>：</p><p><img src="/images/tilinggroup/boundary.svg" class="fig" width="400"></p><p>从不同起点出发得到的边界字是不同的，但它们在 <span class="math inline">\(F\)</span>中都是互相共轭的。例如在下图中，设从蓝色出发点得到的字为 <span class="math inline">\(\pi'\)</span>，从红色点出发到蓝色点之间的字为<span class="math inline">\(w=(ac)^3\)</span>，则 <span class="math inline">\(\pi=w\pi'w^{-1}\)</span>，两种不同表示在 <span class="math inline">\(F\)</span> 中是共轭的。</p><p><img src="/images/tilinggroup/boundary2.svg" class="fig" width="400"></p><p>于是我们可以给出如下定义：</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(D\)</span> 是 <span class="math inline">\(\mathcal{G}(A)\)</span>中的单连通有限区域，定义其<strong>组合边界</strong> <span class="math inline">\([\partial D]\)</span> 为 <span class="math inline">\(F\)</span> 中的一个共轭类：<span class="math inline">\([\partial D]=\{ w\pi w^{-1} \mid w\inF\}\)</span>，其中 <span class="math inline">\(\pi\)</span> 是从 <span class="math inline">\(\partial D\)</span> 上任一点逆时针出发绕 <span class="math inline">\(D\)</span> 一圈得到的字。</p></div><p>对于骨头，我们也可以用类似的方式定义它们的边界字，如下图所示：</p><p><img src="/images/tilinggroup/label.svg" class="fig" width="600"></p><p>从红色标注的起点出发，逆时针绕着骨头一圈，得到的边界字分别是： <span class="math display">\[\begin{array}{l}w_1=(cb)^3a(cb)^3a,\\w_2=(ac)^3b(ac)^3b,\\w_3=(ba)^3c(ba)^3c.\end{array}\]</span></p><p>我们称 <span class="math inline">\(\{w_1,w_2,w_3\}\)</span> 在 <span class="math inline">\(F\)</span> 中生成的最小正规子群 <span class="math inline">\(T = \mathcal{N}(\langlew_1,w_2,w_3\rangle)\)</span>为这三种骨头的密铺群。由于正规子群包含其元素的所有共轭，所以无论怎样选取边界字，得到的结果都属于<span class="math inline">\(T\)</span>。</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span> <span class="statement-info">(<span class="citation" data-cites="Conway1990">(<a href="#ref-Conway1990" role="doc-biblioref">Conway and Lagarias 1990</a>, thm2.1)</span>)</span>.</span><span class="statement-spah"> </span><br>设 <span class="math inline">\(D\)</span>是平面上正六边形网格中的一个有限的、单连通的区域，则 <span class="math inline">\(D\)</span> 可以被若干骨头密铺的必要条件是 <span class="math inline">\([\partial D]\in T\)</span>。</p></div><p>这个定理是很直观的，证明思路也很简单，对密铺使用的骨头个数归纳即可。如果只用一块骨头就能密铺，结论显然成立。否则一定可以把密铺分成两个单连通的子密铺，使得整个密铺的边界字是这两个子密铺边界字的乘积，然后对每个子密铺使用归纳假设即可。<span class="math inline">\(\blacksquare\)</span></p><p>由于 <span class="math inline">\(T_n\)</span> 的边界字为 <span class="math inline">\(\pi=(ac)^n(ba)^n(cb)^n\)</span>，即 <span class="math inline">\(T_n\)</span> 的组合边界为 <span class="math inline">\([\partialT_n]=[\pi]\)</span>。所以任务归结为证明对任何 <span class="math inline">\(n\equiv0\pmod{3}\)</span> 有 <span class="math inline">\(\pi\notin T\)</span>。按 Conway的话说，这是把一个困难的问题翻译成了另一个困难的问题，证明最难的部分就在这里。</p><p>怎么证明群元素 <span class="math inline">\(\pi\)</span>不属于正规子群 <span class="math inline">\(T\)</span> 呢？Conway等人的思路是这样的：构造 <span class="math inline">\(F\)</span> 的子群<span class="math inline">\(J\)</span>，使得 <span class="math inline">\(T\subset J\)</span> 和 <span class="math inline">\(\pi\in J\)</span>，并构造 <span class="math inline">\(J\)</span> 到某个群 <span class="math inline">\(K\)</span> 的同态 <span class="math inline">\(\rho: J\to K\)</span>，使得 <span class="math inline">\(T\subset\ker\rho\)</span> 但 <span class="math inline">\(\pi\notin\ker\rho\)</span>，即同态 <span class="math inline">\(\rho\)</span> 可以区分 <span class="math inline">\(\pi\)</span> 和 <span class="math inline">\(T\)</span>，即得 <span class="math inline">\(\pi\notin T\)</span>。</p><p>Conway 等人构造的 <span class="math inline">\(J\)</span> 是 <span class="math inline">\(F\)</span> 的如下正规子群： <span class="math display">\[J=\mathcal{N}(\langle(cb)^3,(ac)^3,(ba)^3\rangle).\]</span></p><p><span class="math inline">\(J\)</span> 有个很棒的性质：商群 <span class="math display">\[T_0 = F/J = \langle a,b,c\ |\a^2=b^2=c^2=(cb)^3=(ac)^3=(ba)^3=1\rangle\]</span> 的 Cayley 图 <span class="math inline">\(\mathcal{G}(T_0)\)</span> 是平面图，如下所示：</p><figure><img src="/images/tilinggroup/hexgrid2.svg" class="fig" width="300" alt="T_0=F/J 的 Cayley 图，其中的正六边形有三种不同的类型，在每个顶点处相遇的三个正六边形类型互不相同。注意这个 Cayley 图与前面 A 的 Cayley 图的区别。"><figcaption aria-hidden="true"><span class="math inline">\(T_0=F/J\)</span> 的 Cayley图，其中的正六边形有三种不同的类型，在每个顶点处相遇的三个正六边形类型互不相同。注意这个Cayley 图与前面 <span class="math inline">\(A\)</span> 的 Cayley图的区别。</figcaption></figure><p>可见 <span class="math inline">\(\mathcal{G}(T_0)\)</span>的形状与前面 <a href="#Cayley-A"><span class="math inline">\(A\)</span>的 Cayley 图 <span class="math inline">\(\mathcal{G}(A)\)</span></a>是一样的，但二者的标号方式不同。<span class="math inline">\(\mathcal{G}(T_0)\)</span> 包含三种不同的正六边形<span class="math inline">\(C_1,C_2,C_3\)</span>，它们的边界字分别是<span class="math inline">\((cb)^3,(ac)^3,(ba)^3\)</span>，而 <span class="math inline">\(\mathcal{G}(A)\)</span> 只包含一种六边形。</p><p>我们来说明 <span class="math inline">\(\pi\)</span> 和 <span class="math inline">\(T\)</span> 都包含在 <span class="math inline">\(J\)</span> 中。为此只要验证它们在 <span class="math inline">\(T_0\)</span> 的 Cayley 图 <span class="math inline">\(\mathcal{G}(T_0)\)</span> 中都是闭路径即可。</p><p>第一种骨头的边界字 <span class="math inline">\(w_1\)</span>对应的路径如下：</p><p><img src="/images/tilinggroup/winding.svg" class="fig" width="300"></p><p>这个路径是从图中红点出发，<strong>逆时针</strong>绕左下方的正六边形一圈，再沿着标记为<span class="math inline">\(a\)</span>的边到达右上方的正六边形，<strong>顺时针</strong>绕着这个正六边形一圈，再沿着标记为<span class="math inline">\(a\)</span>的边回到起点。这是一条闭路径，所以 <span class="math inline">\(w_1\inJ\)</span>。同理 <span class="math inline">\(w_2,w_3\in J\)</span>，从而<span class="math inline">\(T\subset J\)</span>。</p><p>另一方面 <span class="math inline">\(\pi=(ac)^n(ba)^n(cb)^n\)</span>不过是绕着 <span class="math inline">\(C_1,C_2,C_3\)</span> 各自转了<span class="math inline">\(n/3\)</span> 圈，如下图所示：</p><p><img src="/images/tilinggroup/w_n.svg" class="fig" width="250"></p><p>所以确实有 <span class="math inline">\(T\subset J\)</span> 和 <span class="math inline">\(\pi\in J\)</span>。</p><p>现在我们来构造群同态 <span class="math inline">\(\rho:\J\to\mathbb{Z}^3\)</span>。任何 <span class="math inline">\(w\inJ\)</span> 都对应 Cayley 图 <span class="math inline">\(\mathcal{G}(T_0)\)</span> 中的一条闭曲线 <span class="math inline">\(\gamma\)</span>，我们规定 <span class="math inline">\(\rho(w)=(n_1,n_2,n_3)\in\mathbb{Z}^3\)</span>，其中<span class="math inline">\(n_i\)</span> 是 <span class="math inline">\(\gamma\)</span> 关于所有类型为 <span class="math inline">\(C_i\)</span> 的六边形的环绕数之和： <span class="math display">\[n_i=\sum_{h\in C_i}n(\gamma, h),\quad \text{where}n(\gamma,h)=\frac{1}{2\pi i}\int_{z\in\gamma}\frac{1}{z-h}\,\mathrm{d}z.\]</span> <span class="math inline">\(h\)</span> 在 <span class="math inline">\(C_i\)</span> 内的位置对结果没有影响，因为环绕数在<span class="math inline">\(\mathbb{C}\setminus\gamma\)</span>的每个连通分支上是常数。</p><p>由于 <span class="math inline">\(\gamma\)</span>的内部只包含有限多个六边形，<span class="math inline">\(\gamma\)</span>外部的六边形对上式的贡献都是 0，所以上面的求和只有有限多项。</p><p>我们来计算下每种骨头的环绕数。以边界字为 <span class="math inline">\(w_1\)</span> 的骨头为例：</p><p><img src="/images/tilinggroup/winding.svg" class="fig" width="300"></p><p>它关于两个 <span class="math inline">\(C_1\)</span>类型的正六边形分别逆时针和顺时针各转了一圈，合起来绕了 0圈；它没有环绕过 <span class="math inline">\(C_2\)</span> 和 <span class="math inline">\(C_3\)</span> 类型的正六边形，关于这俩的环绕数都是0，所以这块骨头对应的三元组是 <span class="math inline">\((0,0,0)\)</span>。对另外两种骨头也是如此。由于共轭的路径具有相同的环绕数，以及路径乘积（首尾相接）的环绕数等于各路径环绕数的和，所以<span class="math inline">\(T\)</span> 中任何元素对应的三元组都是 <span class="math inline">\((0,0,0)\)</span>。</p><p>然而我们上面已经看到 <span class="math inline">\(T_n\)</span>的边界字对应的路径是绕着 <span class="math inline">\(C_1,C_2,C_3\)</span> 分别顺时针转 <span class="math inline">\(n/3\)</span> 圈，其环绕数是 <span class="math inline">\((-n/3,-n/3,-n/3)\ne(0, 0, 0)\)</span>，这就说明了<span class="math inline">\(\pi\notin T\)</span>。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Conway1990" class="csl-entry" role="listitem">Conway, J. H, and J. C Lagarias. 1990. <span>“Tiling with Polyominoesand Combinatorial Group Theory.”</span> <em>Journal of CombinatorialTheory, Series A</em> 53 (2): 183–208. <a href="https://doi.org/10.1016/0097-3165(90)90057-4">https://doi.org/10.1016/0097-3165(90)90057-4</a>.</div></div>]]></content>
      
      
      <categories>
          
          <category> 几何群论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中心单代数的三个基本结论</title>
      <link href="/central-simple-algebra/"/>
      <url>/central-simple-algebra/</url>
      
        <content type="html"><![CDATA[<p>本文整理自我在讨论班上做的一次约两小时的报告，介绍中心单代数的三个基本结论：</p><ol type="1"><li>中心单代数对张量积运算是封闭的。</li><li>Noether-Skolem 定理。</li><li>双重中心化子定理。</li></ol><p>这些内容虽然经典，但不同教材的讲解方式差异很大，找到一个完全符合自己口味的不是件容易的事情。对初学者而言，一些名气很大的教材反而不见得友好。我当初念<span class="citation" data-cites="Jacobson_alg">(<a href="#ref-Jacobson_alg" role="doc-biblioref">Jacobson 1980</a>)</span>就感觉很抓狂。后来我查阅了不少教材后经过提炼整理得到了本文。我个人认为这是最直接清楚的讲法。</p><span id="more"></span><h1 id="中心单代数对张量积运算是封闭的">中心单代数对张量积运算是封闭的</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的一个有限维的结合代数，有乘法单位元<span class="math inline">\(\rm 1\)</span>。如果 <span class="math inline">\(A\)</span> 除了 <span class="math inline">\((0)\)</span> 和自身以外不含有其它的双边理想，就称<span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的<strong>单代数</strong>；进一步如果<span class="math inline">\(A\)</span> 的中心 <span class="math inline">\(Z(A)=F\cdot{\rm 1}\cong F\)</span>，就称 <span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的<strong>中心单代数</strong>。</p></div><p>中心单代数的典型例子是 <span class="math inline">\({\rmMat}_n(F)\)</span>，研究一般中心单代数的常见手段是建立它们与 <span class="math inline">\({\rm Mat}_n(F)\)</span> 之间的同态。</p><div id="A-otimes-B" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A,B\)</span> 是域 <span class="math inline">\(F\)</span> 上的两个中心单代数，则 <span class="math inline">\(A\otimes_F B\)</span> 也是中心单代数。</p></div><p><strong>证明</strong>：证明大致分三步：</p><p><strong>第一步：<span class="math inline">\(I\)</span> 必然包含形如<span class="math inline">\(1\otimes b\)</span> 的元素</strong></p><p>设 <span class="math inline">\(\dim B=m\)</span>，固定 <span class="math inline">\(B\)</span> 的一组基 <span class="math inline">\(\{b_1,\ldots,b_m\}\)</span>，则任何 <span class="math inline">\(x\in A\otimes B\)</span> 可以唯一地写成 <span class="math display">\[x= a_1\otimes b_1+a_2\otimesb_2+\cdots+a_m\otimes b_m,\quad a_i\in A.\]</span> 当然某些 <span class="math inline">\(a_i\)</span> 可以是 <span class="math inline">\(0\)</span>。我们称上面这个表达式中非零项的个数为<span class="math inline">\(x\)</span> 的长度。</p><p>设 <span class="math inline">\(I\ne(0)\)</span> 是 <span class="math inline">\(A\otimes B\)</span>的双边理想，取其中长度最小的非零元素 <span class="math inline">\(x\)</span>，不妨假设 <span class="math display">\[x= a_1\otimes b_1+a_2\otimesb_2+\cdots+a_r\otimes b_r,\quad 0&lt;r\leq m.\]</span> 于是每个 <span class="math inline">\(a_i\)</span> 都不是 <span class="math inline">\(0\)</span>，特别 <span class="math inline">\(a_1\ne0\)</span>。由于 <span class="math inline">\(A\)</span> 是单代数因此 <span class="math inline">\(A=Aa_1A\)</span> （即 <span class="math inline">\(a_1\)</span> 在 <span class="math inline">\(A\)</span> 中生成的双边理想），所以存在一组 <span class="math inline">\(\{c_j, d_j\mid 1\leq j\leq p\}\)</span> 满足 <span class="math display">\[1=\sum_{j=1}^p c_ja_1d_j.\]</span> 由于 <span class="math inline">\(I\)</span> 是双边理想因此每个 <span class="math display">\[(c_j\otimes 1)x(d_j\otimes 1)=(c_ja_1d_j)\otimesb_1+\cdots+(c_ja_rd_j)\otimes b_r\]</span> 都在 <span class="math inline">\(I\)</span> 中，当然它们的和 <span class="math display">\[\begin{aligned}x'&amp;=\left(\sum_{j=1}^p c_ja_1d_j\right)\otimes b_1 + \cdots +\left(\sum_{j=1}^p c_ja_rd_j\right)\otimes b_r \\&amp;=1\otimes b_1 + \cdots + \left(\sum_{j=1}^p c_ja_rd_j\right)\otimesb_r\end{aligned}\]</span> 也在 <span class="math inline">\(I\)</span>中。<span class="math inline">\(x'\)</span> 与 <span class="math inline">\(x\)</span> 有同样的长度但是形如 <span class="math inline">\(x'=1\otimesb_1+\cdots\)</span>，所以我们不妨一开始就假设在 <span class="math inline">\(x\)</span> 的表达式中有 <span class="math inline">\(a_1=1\)</span>。</p><p>任取 <span class="math inline">\(a\in A\)</span>，则 <span class="math display">\[(a\otimes 1)x -x(a\otimes1) =(aa_2-a_2a)\otimesb_2+\cdots+(aa_r-a_ra)\otimes b_r\in I.\]</span> 然而它的长度小于 <span class="math inline">\(r\)</span> 因此必须是 <span class="math inline">\(0\)</span>，即对每个 <span class="math inline">\(i=2,\ldots,r\)</span> 有 <span class="math inline">\(aa_i=a_ia\)</span>，由 <span class="math inline">\(a\)</span> 的任意性可知每个 <span class="math inline">\(a_i\)</span> 都属于 <span class="math inline">\(A\)</span> 的中心 <span class="math inline">\(Z(A)=F\)</span>，因此这些 <span class="math inline">\(a_i\)</span> 可以拿到 <span class="math inline">\(\otimes\)</span> 的右边去： <span class="math display">\[x=1\otimes b_1+\cdots+1\otimesa_rb_r=1\otimes(b_1+a_2b_2+\cdots+a_rb_r)\in I.\]</span> 注意由于 <span class="math inline">\(b_i\)</span> 是线性无关的所以 <span class="math inline">\(b=b_1+a_2b_2+\cdots+a_rb_r\ne0\)</span>。</p><p>总之我们证明了在 <span class="math inline">\(I\)</span>中存在一个形如 <span class="math inline">\(1\otimes b\)</span>的元素。</p><p><strong>第二步：<span class="math inline">\(A\otimes B\)</span>是单代数</strong></p><p>由 <span class="math inline">\(1\otimes b\in I\)</span> 且 <span class="math inline">\(B= BbB\)</span>，我们得出 <span class="math display">\[I\supset (1\otimes B)1\otimes b(1\otimesB)=1\otimes BbB=1\otimes B.\]</span> 从而 <span class="math display">\[I\supset (A\otimes1)(1\otimes B)=A\otimesB.\]</span> 这就证明了 <span class="math inline">\(I=A\otimesB\)</span>，即 <span class="math inline">\(A\otimes B\)</span>是单代数。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在上面的证明中，我们只用到了 <span class="math inline">\(A\)</span> 是中心单代数和 <span class="math inline">\(B\)</span> 是单代数作为条件，即只要 <span class="math inline">\(A,B\)</span>中一个是单代数，另一个是中心单代数，则 <span class="math inline">\(A\otimes B\)</span> 就是单代数。这个结论对 <span class="math inline">\(A,B\)</span> 都是单代数的情形是不成立的，比如<span class="math inline">\(\mathbb{C}\)</span> 是 <span class="math inline">\(\mathbb{R}\)</span> 上的单代数但不是中心单的，这时<span class="math inline">\(\mathbb{C}\otimes_\mathbb{R}\mathbb{C}\cong\mathbb{C}\oplus\mathbb{C}\)</span> 就不是单代数。</p></div><p><strong>第三步：<span class="math inline">\(Z(A\otimesB)=F\)</span></strong></p><div id="C-otimes-D" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A,B\)</span> 是域 <span class="math inline">\(F\)</span> 上的代数，<span class="math inline">\(R\subset A\)</span> 和 <span class="math inline">\(S\subset B\)</span> 分别是子代数，则 <span class="math inline">\(R\otimes S\)</span> 在 <span class="math inline">\(A\otimes B\)</span> 中的中心化子是 <span class="math inline">\(C_{A\otimes B}(R\otimes S)=C_A(R)\otimesC_B(S)\)</span>。也就是分别取 <span class="math inline">\(R,S\)</span>在 <span class="math inline">\(A,B\)</span>里的中心化子，然后作张量积。</p></div><p>特别地取 <span class="math inline">\(R=A,S=B\)</span> 我们有 <span class="math inline">\(Z(A\otimes B)=Z(A)\otimes Z(B)\)</span>。</p><p>当 <span class="math inline">\(A,B\)</span> 都是中心单代数时，由<span class="math inline">\(Z(A)\otimes Z(B)=F\otimes F\cong F(1\otimes1)\)</span> 即得 <a href="#A-otimes-B" title="定理 1.2">定理 1.2</a>结论。</p><p><a href="#C-otimes-D" title="引理 1.3">引理 1.3</a> 的证明：<span class="math inline">\(C_{A\otimes B}(R\otimes S)\supseteq C_A(R)\otimesC_B(S)\)</span> 是显然的，只要再证明反向的包含关系。</p><p>仍然固定 <span class="math inline">\(B\)</span> 的一组基 <span class="math inline">\(\{b_1,\ldots,b_m\}\)</span>，任何 <span class="math inline">\(z\in C_{A\otimes B}(R\otimes S)\)</span>可以唯一地写成 <span class="math display">\[z= a_1\otimes b_1+a_2\otimesb_2+\cdots+a_m\otimes b_m.\]</span> 由于 <span class="math inline">\(z\)</span> 和 <span class="math inline">\(R\otimesS\)</span> 交换，当然也就和 <span class="math inline">\(R\otimes1\)</span> 交换，所以对任何 <span class="math inline">\(r\in R\)</span>有 <span class="math display">\[(r\otimes1)z-z(r\otimes1)=\sum_{i=1}^m(ra_i-a_ir)\otimesb_i=0.\]</span></p><p>由于 <span class="math inline">\(b_i\)</span> 线性无关，因此每个<span class="math inline">\(ra_i=a_ir\)</span>，由 <span class="math inline">\(r\)</span> 的任意性有 <span class="math inline">\(a_i\in C_A(R)\)</span>。设 <span class="math inline">\(\{x_1,\ldots,x_k\}\)</span> 是 <span class="math inline">\(C_A(R)\)</span> 的一组基，再将每个 <span class="math inline">\(a_i\)</span> 表示为 <span class="math inline">\(\{x_1,\ldots,x_k\}\)</span> 的线性组合，我们得到<span class="math inline">\(z\)</span> 形如 <span class="math display">\[z=a_1\otimes b_1+a_2\otimes b_2+\cdots+a_m\otimesb_m=x_1\otimes b_1'+\cdots + x_kb_k'.\]</span> 其中每个 <span class="math inline">\(b_k'\in B\)</span>。进一步由于 <span class="math inline">\(z\)</span> 也和任何形如 <span class="math inline">\(1\otimes s,s\in S\)</span> 的元素交换，所以 <span class="math display">\[(1\otimes s)z-z(1\otimess)=\sum_{i=1}^kx_i\otimes (sb_i'-b_i's)=0.\]</span> 由于 <span class="math inline">\(x_i\)</span> 线性无关，所以每个 <span class="math inline">\(sb_i'-b_i's=0\)</span>，由 <span class="math inline">\(s\)</span> 的任意性可得 <span class="math inline">\(b_i'\in C_B(S)\)</span>。从而 <span class="math display">\[z=x_1\otimes b_1'+\cdots + x_rb_r'\inC_A(R)\otimes C_B(S).\]</span> 反向包含得证。<span class="math inline">\(\blacksquare\)</span></p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的中心单代数，<span class="math inline">\(\dim_F A=n\)</span>，则 <span class="math inline">\(A\otimes A^{\rm op}\cong{\rmMat}_n(F)\)</span>。</p></div><p>背后的道理很简单：<span class="math inline">\(A\)</span> 显然是 <span class="math inline">\((A,A)\)</span>- 双模，从而是一个左 <span class="math inline">\(A\otimes A^{\rm op}\)</span>- 模（回忆一下，<span class="math inline">\((R,S)\)</span>- 双模与左 <span class="math inline">\(R\otimes S^{\rm op}\)</span>-模是一回事），即存在代数同态 <span class="math display">\[A\otimesA^{\rm op}\to \mathrm{End}_F(A).\]</span> （<span class="math inline">\(M\)</span> 是左 <span class="math inline">\(R\)</span>- 模当且仅当存在环同态 <span class="math inline">\(R\to{\rm End}(M)\)</span>）</p><p>由 <a href="#A-otimes-B" title="定理 1.2">定理 1.2</a> 知道 <span class="math inline">\(A\otimes A^{\rm op}\)</span>是单代数从而这是一个单射，比较维数即得这是一个同构。</p><h1 id="noether-skolem-定理">Noether-Skolem 定理</h1><div id="N-S" class="statement sta_noether_skolem___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Noether-Skolem 定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span>是一个中心单代数，<span class="math inline">\(B\)</span> 是单代数，<span class="math inline">\(f,g\colon\ B\to A\)</span> 是从 <span class="math inline">\(B\)</span> 到 <span class="math inline">\(A\)</span> 的两个代数同态，则存在 <span class="math inline">\(u\in A^{\times}\)</span> 满足 <span class="math display">\[f(b) =u^{-1}g(b)u,\quad \forall b\in B.\]</span>特别的，我们得到中心单代数的自同构都是内自同构。</p></div><p>这个定理背后的想法不难，只是需要一点 Wedderburn-Artin半单代数理论的知识：对于一个单代数 <span class="math inline">\(B\)</span>，在同构意义下 <span class="math inline">\(B\)</span> 只有唯一的不可约模左 <span class="math inline">\(B\)</span>- 模 <span class="math inline">\(V\)</span>。任何左 <span class="math inline">\(B\)</span>- 模都可以分解为若干 <span class="math inline">\(V\)</span> 的直和。两个左 <span class="math inline">\(B\)</span>- 模 <span class="math inline">\(W,W'\)</span> 同构当且仅当它们作为 <span class="math inline">\(F\)</span>- 向量空间的维数相同： <span class="math display">\[W\cong W'\Leftrightarrow\dim_F W=\dim_FW'.\]</span> 所以判断两个 <span class="math inline">\(B\)</span>-模是否同构是很简单的，只看维数就行。</p><p>回到 <a href="#N-S" title="Noether-Skolem 定理">Noether-Skolem定理</a>。我们先处理 <span class="math inline">\(A={\rmMat}_n(F)\)</span> 的情形：我们可以在 <span class="math inline">\(F^n\)</span> 上定义两种不同的 <span class="math inline">\(B\)</span>- 模结构： <span class="math display">\[\begin{aligned}(B,\,\cdot)&amp;:\quad b\cdot x=f(b)x,\\(B,\,\circ)&amp;:\quad b\circ x=g(b)x.\end{aligned}\]</span> 由于 <span class="math inline">\(B\)</span>是单代数，同一个向量空间 <span class="math inline">\(F^n\)</span>上的不同左 <span class="math inline">\(B\)</span>-模结构必然是同构的，因此存在可逆线性变换 <span class="math inline">\(T:F^n\to F^n\)</span> 使得 <span class="math display">\[b\cdot (Tx)=T(b\circ x),\]</span> 即 <span class="math inline">\(f(b)=T^{-1}g(b)T\)</span>，因此在 <span class="math inline">\(A={\rm Mat}_n(F)\)</span> 的情形定理成立。</p><p>对于一般的情形，我们当然要向矩阵代数靠拢。考虑 <span class="math inline">\(A\otimes A^{\rm op}\)</span> 的两个单子代数 <span class="math inline">\(f(B)\otimes A^{\rm op}\)</span> 和 <span class="math inline">\(g(B)\otimes A^{\rm op}\)</span>。由于 <span class="math inline">\(A\otimes A^{\rm op}\cong{\rmMat}_n(F)\)</span>，根据我们刚刚证得的结论，存在可逆元 <span class="math inline">\(T \in (A\otimes A^{\rm op})^\times\)</span>满足对任何 <span class="math inline">\(b\otimes a^{\rm op}\)</span> 有<span class="math display">\[f(b)\otimes a^{\rm op}=T^{-1}(g(b)\otimesa^{\rm op})T. \tag{$\ast$}\label{ast}\]</span> 取 <span class="math inline">\(b=1\)</span> 代入上式有 <span class="math display">\[1\otimes a^{\rm op}=T^{-1}(1\otimes a^{\rmop})T.\]</span> 即 <span class="math inline">\(T\)</span> 与 <span class="math inline">\(1\otimes A^{\rm op}\)</span> 交换。于是根据 <a href="#C-otimes-D" title="引理 1.3">引理 1.3</a>，<span class="math inline">\(T\in A\otimes1\)</span>，从而存在 <span class="math inline">\(u\in A\)</span> 使得 <span class="math inline">\(T=u\otimes1\)</span>，<span class="math inline">\(T\in (A\otimes A^{\rm op})^\times\)</span> 说明<span class="math inline">\(u\in A^{\times}\)</span>，代入到 <span class="math inline">\(\ref{ast}\)</span> 中去即得 <span class="math inline">\(f(b)=u^{-1}g(b)u\)</span>。<span class="math inline">\(\blacksquare\)</span></p><h1 id="双重中心化子定理">双重中心化子定理</h1><div id="------------------------" class="statement sta_________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">双重中心化子定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span>是 <span class="math inline">\(F\)</span> 上的中心单代数，<span class="math inline">\(B\)</span> 是 <span class="math inline">\(A\)</span> 的单子代数，<span class="math inline">\(C\)</span> 是 <span class="math inline">\(B\)</span> 在 <span class="math inline">\(A\)</span> 中的中心化子： <span class="math display">\[C=C_A(B)=\{ c\in A:\ cb=bc,\ \forall b\inB\}.\]</span> 则以下结论成立：</p><ol type="1"><li><span class="math inline">\(C\)</span> 也是 <span class="math inline">\(A\)</span> 的单子代数。</li><li><span class="math inline">\(\dim_F A=(\dim_F B)(\dim_FC)\)</span>。</li><li><span class="math inline">\(C\)</span> 的中心化子是 <span class="math inline">\(B\)</span>。</li></ol></div><p><strong>证明</strong>：整个证明都包含在下图中 （<span class="math inline">\(i\)</span> 是嵌入映射）：</p><p><span class="math display">\[\require{amsCd}\begin{CD}B\otimes1 @&gt;{i}&gt;&gt; A\otimes\mathrm{End}_F(B) @&lt;{i}&lt;&lt;1\otimes l(B)\\@V{\rm centralizer}VV @. @VV{\rm centralizer}V \\C\otimes\mathrm{End}_F(B) @&gt;{i}&gt;&gt; A\otimes\mathrm{End}_F(B)@&lt;{i}&lt;&lt; A\otimes r(B)\end{CD}\]</span></p><p>我来解释：<span class="math inline">\(A\otimes\mathrm{End}_F(B)\)</span>是中心单代数，它有两个子代数 <span class="math inline">\(B\otimes1\)</span> 和 <span class="math inline">\(1\otimes l(B)\)</span>，这里<span class="math inline">\(l(B)\)</span> 是 <span class="math inline">\(B\)</span> 在自身上的左乘。它们都同构于单子代数<span class="math inline">\(B\)</span>，因此 Noether-Skolem定理断言它俩是共轭的，于是它俩在 <span class="math inline">\(A\otimes\mathrm{End}_F(B)\)</span>中的中心化子也是共轭的。利用 <a href="#C-otimes-D" title="引理 1.3">引理1.3</a> 的结论，对它俩在 <span class="math inline">\(A\otimes\mathrm{End}_F(B)\)</span>中分别求中心化子，得到 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span> 和 <span class="math inline">\(A\otimes r(B)\)</span> 是共轭的。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span><span class="math inline">\(l(B)\)</span> 在 <span class="math inline">\(\mathrm{End}_F(B)\)</span> 中的中心化子是 <span class="math inline">\(r(B)\)</span>，即 <span class="math inline">\(B\)</span> 在自身上的右乘。<span class="math inline">\(r(B)\)</span> 同构于 <span class="math inline">\(B\)</span> 的反环 <span class="math inline">\(B^{\rm op}\)</span>。</p></div><p>由 <a href="#A-otimes-B" title="定理 1.2">定理 1.2</a> <span class="math inline">\(A\otimes r(B)\)</span> 是单代数，于是 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span>也是单代数，从而 <span class="math inline">\(C\)</span> 必须是单代数（否则若 <span class="math inline">\(C\)</span> 有非平凡理想 <span class="math inline">\(I\)</span> 则 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span> 有理想 <span class="math inline">\(I\otimes\mathrm{End}_F(B)\)</span>），这证明了1。</p><p>由于 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span>和 <span class="math inline">\(A\otimes r(B)\)</span>共轭，所以它们的维数相等，即 <span class="math display">\[(\dim_F C)(\dim_F B)^2=(\dim_F A)(\dim_F B),\]</span> 从而 <span class="math inline">\((\dim_F C)(\dim_F B)=\dim_F A\)</span>，这证明了2。</p><p>最后设 <span class="math inline">\(C\)</span> 的中心化子为 <span class="math inline">\(C_A(C)\)</span>，对单子代数 <span class="math inline">\(C\)</span> 应用结论 2， <span class="math display">\[\dim_F C =\frac{\dim_F A}{\dim_FC_A(C)}=\frac{\dim_F A}{\dim_F B}.\]</span> 即 <span class="math inline">\(\dim_F C_A(C)=\dim_F B\)</span>。然而 <span class="math inline">\(B\subsetC_A(C)\)</span>，二者维数相同因此必然相等，3 得证。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Jacobson_alg" class="csl-entry" role="listitem">Jacobson, Nathan. 1980. <em>Basic Algebra. <span>II</span></em>. SanFrancisco, Calif.: W. H. Freeman; Co.</div></div>]]></content>
      
      
      <categories>
          
          <category> 有限群表示与结合代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实化与复化</title>
      <link href="/real-complex/"/>
      <url>/real-complex/</url>
      
        <content type="html"><![CDATA[<p>本文总结了一些关于向量空间的实化和复化的基础知识。</p><h1 id="实化">实化</h1><p>设 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span> 上的 <span class="math inline">\(n\)</span> 维向量空间，我们可以「忘掉」 <span class="math inline">\(V\)</span> 的复向量空间结构，把 <span class="math inline">\(V\)</span> 看作实向量空间，记作 <span class="math inline">\(V_{\mathbb{R}}\)</span> 以区别于 <span class="math inline">\(V\)</span>。即 <span class="math inline">\(V_\mathbb{R}\)</span> 与 <span class="math inline">\(V\)</span>作为加法群是一样的，但是数和向量的乘法限制在 <span class="math inline">\(\mathbb{R}\)</span> 上。<span class="math inline">\(V_{\mathbb{R}}\)</span> 是 <span class="math inline">\(2n\)</span> 维的。如果 <span class="math inline">\(\{e_i\}_{i=1}^n\)</span> 是 <span class="math inline">\(V\)</span> 的一组 <span class="math inline">\(\mathbb{C}\)</span>- 基，则 <span class="math inline">\(\{e_i,ie_i\}_{i=1}^n\)</span> 是 <span class="math inline">\(V_\mathbb{R}\)</span> 的一组 <span class="math inline">\(\mathbb{R}\)</span>- 基。<span class="math inline">\(V_{\mathbb{R}}\)</span> 叫做 <span class="math inline">\(V\)</span> 的<strong>实化</strong>。</p><p>但是 <span class="math inline">\(V_{\mathbb{R}}\)</span> 比一般的<span class="math inline">\(2n\)</span>维实向量空间还要多出一个结构，这个结构来自 <span class="math inline">\(V\)</span> 上虚数 <span class="math inline">\(i\)</span> 的乘法，它诱导了 <span class="math inline">\(V_\mathbb{R}\)</span> 上的 <span class="math inline">\(\mathbb{R}\)</span>- 线性变换 <span class="math inline">\(J\colon\ v\mapsto iv\)</span>。<span class="math inline">\(J\)</span> 满足 <span class="math inline">\(J^2=-1\)</span>。<span class="math inline">\(J\)</span> 叫做 <span class="math inline">\(V_{\mathbb{R}}\)</span>上的<strong>复结构</strong>。</p><p>反过来，给定一个偶数维的实向量空间 <span class="math inline">\(W\)</span> 以及 <span class="math inline">\(W\)</span> 上的一个复结构 <span class="math inline">\(J\)</span>，<span class="math inline">\(W\)</span>上可以自然地定义复向量空间结构：因为 <span class="math inline">\(J\)</span> 本质就是虚数 <span class="math inline">\(i\)</span> 的乘法，我们只要规定 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(W\)</span> 中向量的乘法为 <span class="math inline">\(iw=J ( w )\)</span>，然后扩展到 <span class="math inline">\(\mathbb{C}\)</span> 上即可： <span class="math display">\[( a+ib ) w = aw+bJ ( w ) ,\quada,b\in\mathbb{R},w\in W.\]</span> 我们用 <span class="math inline">\((W,J )\)</span> 表示这样得到的复向量空间。</p><blockquote><p><strong>总结</strong>：任何复向量空间 <span class="math inline">\(V\)</span> 可以等同于一个 <span class="math inline">\(2n\)</span> 维实向量空间 <span class="math inline">\(V_{\mathbb{R}}\)</span> 加上一个复结构 <span class="math inline">\(J\)</span>。</p></blockquote><h1 id="反线性映射">反线性映射</h1><p>设 <span class="math inline">\(V\)</span> 是复向量空间，记 <span class="math inline">\(\overline{V}\)</span> 是如下的向量空间：<span class="math inline">\(\overline{V}\)</span> 作为加法群和 <span class="math inline">\(V\)</span> 完全相同，但是复数与向量的乘法 <span class="math inline">\(\bullet\)</span> 定义为 <span class="math inline">\(c\bullet z=\overline{c}z\)</span>，其中右边的<span class="math inline">\(\overline{c}z\)</span> 是 <span class="math inline">\(V\)</span> 中的原始数乘。我们称 <span class="math inline">\(\overline{V}\)</span> 是 <span class="math inline">\(V\)</span> 的共轭空间。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(V,U\)</span>是复向量空间。如果映射 <span class="math inline">\(f\colon\ V\toU\)</span> 满足下面两个条件，就称 <span class="math inline">\(f\)</span>是 <a href="https://en.wikipedia.org/wiki/Antilinear_map">反线性</a>映射：</p><ol type="1"><li><span class="math inline">\(f\)</span> 是从 <span class="math inline">\(V\)</span> 到 <span class="math inline">\(U\)</span> 的加法群同态：<span class="math inline">\(f(v_1+v_2)=f(v_1)+f(v_2)\)</span> 对任何 <span class="math inline">\(v_1,v_2\in V\)</span> 成立。</li><li><span class="math inline">\(f(cv)=\overline{c}v\)</span> 对任何<span class="math inline">\(c\in\mathbb{C}\)</span> 和 <span class="math inline">\(v\in V\)</span> 成立。</li></ol></div><p>反线性映射是 <span class="math inline">\(\mathbb{R}\)</span>-线性的，但不是 <span class="math inline">\(\mathbb{C}\)</span>-线性的。</p><blockquote><p><strong>总结</strong>：<span class="math inline">\(V\to U\)</span>的反线性映射和 <span class="math inline">\(V\to\overline{U}\)</span> 的<span class="math inline">\(\mathbb{C}\)</span>- 线性映射是一回事。</p></blockquote><h1 id="复化">复化</h1><p>与实化相对应的操作是<strong>复化</strong>，即对给定的 <span class="math inline">\(\mathbb{R}\)</span>- 向量空间 <span class="math inline">\(W\)</span>，将其数乘扩展到 <span class="math inline">\(\mathbb{C}\)</span>上，使之成为一个复向量空间。我们将得到的复向量空间记作 <span class="math inline">\(W^\mathbb{C}\)</span> 以区别于 <span class="math inline">\(W\)</span>。</p><p>构造 <span class="math inline">\(W^\mathbb{C}\)</span>的标准方法是使用张量积，令 <span class="math inline">\(W^\mathbb{C}=\mathbb{C}\otimes_\mathbb{R}W\)</span>，<span class="math inline">\(W^\mathbb{C}\)</span> 中复数与向量的乘法定义为<span class="math display">\[c ( z\otimes w ) = cz\otimes w.\]</span><span class="math inline">\(W\)</span> 可以通过 <span class="math inline">\(w\to 1\otimes w\)</span> 等同于 <span class="math inline">\(W^\mathbb{C}\)</span> 的 <span class="math inline">\(\mathbb{R}\)</span>- 子空间 <span class="math inline">\(1\otimes W\)</span>。在这个等同下，<span class="math inline">\(W^\mathbb{C}\)</span> 中的向量都是 <span class="math inline">\(W\)</span> 中向量的 <span class="math inline">\(\mathbb{C}\)</span>- 线性组合： <span class="math display">\[\sum c_i\otimes w_i = \sum c_i(1\otimes w_i)\leftrightarrow \sum c_iw_i.\]</span> 这一点与我们关于「 将 <span class="math inline">\(W\)</span> 的数乘扩张到 <span class="math inline">\(\mathbb{C}\)</span> 」的直觉完全一致。于是 <span class="math inline">\(W\)</span> 的任何一组 <span class="math inline">\(\mathbb{R}\)</span>- 基同时也是 <span class="math inline">\(W^\mathbb{C}\)</span> 的一组 <span class="math inline">\(\mathbb{C}\)</span>- 基。特别地，<span class="math inline">\(W\)</span> 作为实向量空间的维数与 <span class="math inline">\(W^\mathbb{C}\)</span>作为复向量空间的维数相等。</p><p><span class="math inline">\(W^\mathbb{C}\)</span>可以分解为两个实子空间的直和 <span class="math display">\[W^\mathbb{C}=1\otimes W \oplus i\otimes W=1\otimes W \oplus i(1\otimes W)  .\]</span> 由于 <span class="math inline">\(W\)</span> 可以等同于 <span class="math inline">\(1\otimes W\)</span>，上式可以简写成 <span class="math inline">\(W^\mathbb{C}=W\oplus iW\)</span>。</p><p><span class="math inline">\(W^\mathbb{C}\)</span> 与一般的 <span class="math inline">\(n\)</span>维复向量空间相比也多出一个结构，叫做共轭。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>如果 <span class="math inline">\(\tau\colon\ V\to V\)</span>是反线性映射并且 <span class="math inline">\(\tau^2=1\)</span>，就称<span class="math inline">\(\tau\)</span>是一个<strong>共轭</strong>。</p></div><p>复数的共轭诱导了 <span class="math inline">\(\mathbb{C}\otimes_\mathbb{R}W\)</span> 上的共轭：<span class="math display">\[\tau ( c\otimes w ) =\overline{c}\otimesw,\quad c\in\mathbb{C}, w\in W.\]</span> <span class="math inline">\(\tau\)</span> 保持实子空间 <span class="math inline">\(1\otimes W\cong W\)</span> 不变。<span class="math inline">\(W\)</span> 可以理解为 <span class="math inline">\(V\)</span> 在共轭 <span class="math inline">\(\tau\)</span> 下的实部。</p><p>反过来，给定复向量空间 <span class="math inline">\(V\)</span>以及共轭 <span class="math inline">\(\tau\)</span>，我们可以还原出使得<span class="math inline">\(V=W^\mathbb{C}\)</span> 成立的实向量空间<span class="math inline">\(W\)</span> 来。<span class="math inline">\(W\)</span> 正是 <span class="math inline">\(\tau\)</span> 的不动点子空间 <span class="math inline">\(W=\{v\in V\mid \tau ( v ) =v\}\)</span>，即 <span class="math inline">\(\tau\)</span> 的 +1 特征子空间。相应地 <span class="math inline">\(iW\)</span> 是 <span class="math inline">\(\tau\)</span> 的 -1 特征子空间并且 <span class="math inline">\(V=W\oplus iW\)</span>。根据下面的命题，<span class="math inline">\(W\)</span> 的复化就是 <span class="math inline">\(V\)</span>。</p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(V\)</span>是有限维复向量空间，<span class="math inline">\(W\)</span> 是 <span class="math inline">\(V\)</span> 的 <span class="math inline">\(\mathbb{R}\)</span>- 子空间。若有 <span class="math inline">\(V=W\oplus iW\)</span> 成立，则 <span class="math inline">\(V\cong\mathbb{C}\otimes_\mathbb{R}W\)</span>。</p></div><p><strong>证明</strong>：考察如下的映射 <span class="math display">\[\begin{aligned}f\colon\  \mathbb{C}\otimes_\mathbb{R}W &amp; \to V\\c\otimes w &amp;\mapsto cw.\end{aligned}\]</span> 显然 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span>- 线性的。我们来验证 <span class="math inline">\(f\)</span> 是双射。</p><p>由于 <span class="math inline">\(V=W\oplus iW\)</span> 所以任何 <span class="math inline">\(v\in V\)</span> 可以写成 <span class="math inline">\(v=w_1+iw_2,\,w_1,w_2\in W\)</span>的形式。不难验证 <span class="math inline">\(f ( 1\otimes w_1 + i\otimesw_2 ) = w_1+iw_2\)</span> 所以 <span class="math inline">\(f\)</span>是满射。并且 <span class="math inline">\(f ( 1\otimes w_1 + i\otimes w_2) =0\)</span> 当且仅当 <span class="math inline">\(w_1+iw_2=0\)</span>，即 <span class="math inline">\(w_1=-iw_2\in W\cap iW= ( 0 )\)</span>，从而 <span class="math inline">\(w_1=w_2=0\)</span>，这说明 <span class="math inline">\(f\)</span> 也是单射。于是 <span class="math inline">\(f\)</span> 是同构。 <span class="math inline">\(\blacksquare\)</span></p><blockquote><p><strong>总结</strong>：复向量空间 <span class="math inline">\(V\)</span> 上的任何共轭 <span class="math inline">\(\tau\)</span> 都对应 <span class="math inline">\(V\)</span> 的一个实子空间 <span class="math inline">\(W\)</span>，使得 <span class="math inline">\(V\cong \mathbb{C}\otimes_{\mathbb{R}}W\)</span>。</p></blockquote><h1 id="先实化后复化">先实化后复化</h1><p>有了上面的准备，我们来分析将一个 <span class="math inline">\(n\)</span> 维复向量空间 <span class="math inline">\(V\)</span>，先实化再复化得到的 <span class="math display">\[(V_\mathbb{R})^\mathbb{C}=\mathbb{C}\otimes_\mathbb{R}V_\mathbb{R}\]</span>的结构。我其实可以直接写出结论来：</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.1</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(V\)</span> 是复向量空间，则我们有复向量空间的同构<span class="math display">\[\begin{aligned}(V_\mathbb{R})^\mathbb{C}&amp; \to V\oplus \overline{V}\\c\otimes v &amp;\mapsto (cv, \overline{c}v).\end{aligned}\]</span></p></div><p><strong>证明 1</strong>：不难验证所给的映射是 <span class="math inline">\(\mathbb{C}\)</span>- 线性的，并且把 <span class="math inline">\(1\otimes x + i\otimes y\)</span> 映射为 <span class="math inline">\((x+iy,x-iy)\)</span>。我们可以从 <span class="math inline">\((x+iy,x-iy)\)</span> 唯一地反解出 <span class="math inline">\(x,y\)</span> 来，所以这是一个线性同构。<span class="math inline">\(\blacksquare\)</span></p><p>上面的证明虽然简明了然，但是似乎没有揭示这个同构是怎么想出来的。特别是<span class="math inline">\(\overline{V}\)</span>的出现显得有些突兀。我们换一种方法来分析：找到合适的线性变换并分析它在<span class="math inline">\((V_\mathbb{R})^\mathbb{C}\)</span>上的作用。</p><p><strong>证明 2</strong>：记 <span class="math inline">\(J\)</span> 是<span class="math inline">\(V_\mathbb{R}\)</span> 的复结构，<span class="math inline">\(J\)</span> 不过是 <span class="math inline">\(i\)</span> 在 <span class="math inline">\(V\)</span> 上的乘法，但我们写成 <span class="math inline">\(J\)</span> 以区别与张量积 <span class="math inline">\(\mathbb{C}\otimes_\mathbb{R}V_\mathbb{R}\)</span>中左边的 <span class="math inline">\(\mathbb{C}\)</span>分量给出的乘法。<span class="math inline">\(J^\mathbb{C}=1\otimesJ\)</span> 是 <span class="math inline">\(\mathbb{C}\otimes_\mathbb{R}V_\mathbb{R}\)</span>上的 <span class="math inline">\(\mathbb{C}\)</span>- 线性变换且 <span class="math inline">\(( J^\mathbb{C})^2 = -1\)</span>。作为复向量空间<span class="math inline">\(( V_\mathbb{R})^\mathbb{C}\)</span>可以分解为 <span class="math inline">\(J^\mathbb{C}\)</span> 的 <span class="math inline">\(\pm i\)</span> 特征子空间的直和： <span class="math display">\[( V_\mathbb{R})^\mathbb{C}= V_+\oplusV_-.\]</span> 具体写出来，就是 <span class="math display">\[\begin{aligned}V_+ &amp;= \frac{1\otimes V_\mathbb{R}- i\otimes J(V_\mathbb{R})}{2}, \\V_- &amp;= \frac{1\otimes V_\mathbb{R}+ i\otimes J(V_\mathbb{R})}{2}.\end{aligned}\]</span></p><p>容易验证 <span class="math inline">\((V_\mathbb{R})^\mathbb{C}\)</span> 上的共轭 <span class="math inline">\(\tau\)</span> 交换 <span class="math inline">\(V_+\)</span> 和 <span class="math inline">\(V_-\)</span>，但 <span class="math inline">\(\tau\)</span> 是反线性的，所以 <span class="math inline">\(V_+\cong\overline{V_-}\)</span>，即二者互为共轭空间。</p><p>进一步我们断言有复向量空间的同构 <span class="math inline">\(V_+\cong (V_\mathbb{R}, J)\)</span>。考虑映射 <span class="math display">\[\begin{aligned}f\colon \ V_+  &amp; \to (V_\mathbb{R}, J)\\c\otimes v &amp;\mapsto cv.\end{aligned}\]</span> 这里右边的乘法 <span class="math inline">\(cv\)</span>理解为对 <span class="math inline">\(c=a+ib\)</span> 有 <span class="math inline">\(cv=av+bJ(v)\)</span>。</p><p><span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span>- 线性的，确实把 <span class="math inline">\(V_+\)</span> 映射到 <span class="math inline">\(V_\mathbb{R}\)</span>： <span class="math display">\[f\left(\frac{1\otimes v- i\otimes J(v)}{2}\right)= \frac{v-J^2(v)}{2}=v.\]</span> <span class="math inline">\(f\)</span>有逆映射 <span class="math display">\[\begin{aligned}f^{-1}\colon \ V_\mathbb{R}&amp; \to V_+\\v &amp;\mapsto \frac{1\otimes v- i\otimes J(v)}{2}.\end{aligned}\]</span> 所以 <span class="math inline">\(V_+\cong(V_\mathbb{R},J)\cong V\)</span>。至此我们就证明了 <span class="math display">\[(V_\mathbb{R})^\mathbb{C}\cong V\oplus\overline{V}.\]</span></p><p><span class="math inline">\(\blacksquare\)</span></p><p>这个同构也可以用下面的交换图来表示：</p><p><span class="math display">\[\require{amsCd}\begin{CD}\mathbb{C}\otimes_\mathbb{R}V_\mathbb{R}@&gt;{c\otimes v\,\to\,(cv,\,\overline{c}v)}&gt;&gt; (V,\overline{V})\\@V{\tau}VV  @VV{(u,\,v)\leftrightarrow (v,\,u)}V \\\mathbb{C}\otimes_\mathbb{R}V_\mathbb{R}@&gt;{c\otimes v\,\to\,(cv,\,\overline{c}v)}&gt;&gt; (V,\overline{V})\end{CD}\]</span> 其中 <span class="math inline">\((u,v)\leftrightarrow(v,u)\)</span> 是 <span class="math inline">\(\tau\)</span> 在 <span class="math inline">\(V\oplus\overline{V}\)</span>上诱导的共轭结构，它交换两个直和分量。</p><h1 id="线性变换的复化">线性变换的复化</h1><p>设 <span class="math inline">\(W\)</span> 是实向量空间，<span class="math inline">\(W^\mathbb{C}=\mathbb{C}\otimes_\mathbb{R}W\)</span>是复化，则任何 <span class="math inline">\(f\in\mathrm{Hom}_\mathbb{R}(W,W)\)</span>可以自然地扩展为 <span class="math display">\[f^\mathbb{C}=1\otimesf\in\mathrm{Hom}_\mathbb{C}(W^\mathbb{C},W^\mathbb{C}).\]</span> <span class="math inline">\(f^\mathbb{C}\)</span> 与 <span class="math inline">\(f\)</span> 有相同的矩阵。注意 <span class="math inline">\(f^\mathbb{C}\)</span> 与共轭 <span class="math inline">\(\tau\)</span>交换，因为它们作用在张量积的不同分量上。</p><p>反过来，我们想知道何时 <span class="math inline">\(g\in\mathrm{Hom}_\mathbb{C}(W^\mathbb{C},W^\mathbb{C})\)</span>是某个 <span class="math inline">\(f\in\mathrm{Hom}_\mathbb{R}(W,W)\)</span>的复化：<span class="math inline">\(g=f^\mathbb{C}\)</span>。一个必要条件当然是 <span class="math inline">\(g\)</span> 与共轭 <span class="math inline">\(\tau\)</span>交换。这个条件也是充分的。这是因为，我们有自然同构 <span class="math display">\[\mathrm{Hom}_\mathbb{C}(W^\mathbb{C},W^\mathbb{C})\cong\mathbb{C}\otimes\mathrm{Hom}_\mathbb{R}(W,W).\]</span> 所以 <span class="math inline">\(g\)</span> 可以写成如下的形式： <span class="math display">\[g=1\otimes f_1+i\otimes f_2,\quadf_1,f_2\in\mathrm{Hom}_\mathbb{R}(W,W).\]</span> <span class="math inline">\(g\)</span> 与 <span class="math inline">\(\tau\)</span> 交换说明 <span class="math inline">\(f_2\)</span> 作用在 <span class="math inline">\(W\)</span> 上是零变换，从而 <span class="math inline">\(g=1\otimes f_1\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hurwitz 平方和定理</title>
      <link href="/hurwitz-square-sum-theorem/"/>
      <url>/hurwitz-square-sum-theorem/</url>
      
        <content type="html"><![CDATA[<p>Hurwitz平方和定理是有限群表示论的一个精彩应用，本文是若干年前读书时的笔记。</p><span id="more"></span><h1 id="hurwitz-平方和定理">Hurwitz 平方和定理</h1><p>相信你对复数的乘法再熟悉不过了：设 <span class="math inline">\(z_1=x_1+y_1i,\,z_2=x_2+y_2i\)</span>是两个复数，则 <span class="math display">\[|z_1z_2|=|z_1|\cdot|z_2|.\]</span> 也就是 <span class="math display">\[(x_1^2+y_1^2)(x_2^2+y_2^2)=(x_1x_2-y_1y_2)^2+(x_1y_2+x_2y_1)^2.\]</span>1748 年 Euler 发现了如下的 4 平方和等式： <span class="math display">\[(x_1^2+x_2^2+x_3^2+x_4^2)(y_1^2+y_2^2+y_3^2+y_4^2)=z_1^2+z_2^2+z_3^2+z_4^2.\]</span>其中 <span class="math display">\[\begin{aligned}&amp;z_1=x_1y_1-x_2y_2-x_3y_3-x_4y_4,\\&amp;z_2=x_1y_2+x_2y_1+x_3y_4-x_4y_3,\\&amp;z_3=x_1y_3+x_3y_1-x_2y_4+x_4y_2,\\&amp;z_4=x_1y_4+x_4y_1+x_2y_3-x_3y_2.\end{aligned}\]</span> 4 平方和等式说的是在 Hamilton四元数体中范数仍然是乘性的。1848 年 Cayley 发现了八元数 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，从而导出了类似的 8平方和等式，当然具体写出来会很复杂，这里就按下不表了。</p><p>一般地，如果能在 <span class="math inline">\(n\)</span> 维 Euclidean空间 <span class="math inline">\(\mathbb{R}^n\)</span>上定义向量之间的乘法： <span class="math display">\[\mathbb{R}^n\times\mathbb{R}^n\rightarrow\mathbb{R}^n:(v,w)\rightarrowv\times w\]</span> 使得 <span class="math inline">\(v\times w\)</span>对 <span class="math inline">\(v,w\)</span>都是线性的，而且乘积的范数等于范数的乘积：<span class="math inline">\(|v\times w|=|v|\cdot |w|\)</span>，这里 <span class="math inline">\(|\cdot|\)</span> 是通常的 Euclidean范数，则我们就得到了一个 <span class="math inline">\(n\)</span>平方和等式。</p><p>在接下来的 50 年里，人们一直致力于寻找可能的 16平方和等式，但是都失败了，于是开始怀疑是否没有这样的等式成立。终于在1898 年 Hurwitz 证明了这样的结论：</p><div id="hurwitz----------------" class="unnumbered statement sta_hurwitz______ plain"><p><span class="statement-heading"><span class="statement-label">Hurwitz平方和定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(x=(x_1,\ldots,x_n)\)</span>, <span class="math inline">\(y=(y_1,\dots,y_n)\)</span> 为 <span class="math inline">\(\mathbb{R}^n\)</span> 中的向量。如果存在关于 <span class="math inline">\(x,y\)</span> 的双线性函数 <span class="math inline">\(z_1(x,y),\ldots,z_n(x,y)\)</span> 使得等式 <span class="math display">\[(x_1^2+\cdots+x_n^2)(y_1^2+\cdots+y_n^2)=z_1^2+\cdots+z_n^2\]</span>恒成立，那么 <span class="math inline">\(n=1,2,4,8\)</span>。</p></div><p>正如前面说过的，Huiwitz 平方和定理意味着在实数域 <span class="math inline">\(\mathbb{R}\)</span>，复数域 <span class="math inline">\(\mathbb{C}\)</span>，四元数 <span class="math inline">\(\mathbb{H}\)</span> 和八元数 <span class="math inline">\(\mathbb{O}\)</span> 中，元素的 Euclidean范数和向量的乘法是相容的，而在其它维数的 <span class="math inline">\(\mathbb{R}^n\)</span> 上是不可能定义与 Euclidean范数相容的向量乘法的。</p><p>Hurwitz本人的证明是纯线性代数的，线性代数的证明较为初等，不过步骤略长。1943 年Eckmann用有限群表示论的方法给了一个漂亮的证明，本文就来介绍这个证明。</p><h1 id="将问题转化为矩阵方程">将问题转化为矩阵方程</h1><p>设 <span class="math inline">\(z=(z_1,\ldots,z_n)\)</span>，则每个<span class="math inline">\(z_i\)</span> 关于 <span class="math inline">\(y\)</span> 都是线性的，因此存在 <span class="math inline">\(n\)</span> 阶矩阵 <span class="math inline">\(A\)</span> 满足 <span class="math inline">\(z=yA\)</span>，当然矩阵 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(x\)</span> 有关。于是 Hurwitz 定理中的等式变成<span class="math display">\[(x_1^2+x_2^2+\cdots+x_n^2)yy'=yAA'y'.\]</span>由于 <span class="math inline">\(y\)</span> 是不定元，因此 <span class="math display">\[AA'=(x_1^2+\cdots+x_n^2)I_n.\]</span>进一步，由于 <span class="math inline">\(A\)</span> 关于 <span class="math inline">\(x\)</span> 也是线性的，因此设 <span class="math inline">\(A=A_1x_1+\cdots+A_nx_n\)</span>，则 <span class="math display">\[AA'=\sum_{i=1}^nA_iA_i'x_i^2+\sum_{1\leqi&lt;j\leq n}(A_iA_j'+A_jA_i')x_ix_j.\]</span>从而我们得到一组矩阵方程 <span class="math display">\[A_iA_i'=I_n,\quadA_iA_j'+A_jA_i'=0\text{ for } i\ne j.\]</span> 进一步可以把<span class="math inline">\(A_n\)</span> 归一化为单位矩阵：令 <span class="math inline">\(Q_i=A_iA_n^{-1}\)</span>，于是 <span class="math inline">\(Q_1,\ldots,Q_{n-1}\)</span> 满足 <span class="math display">\[Q_i'=-Q_i,\quad Q_i^2=-I_n,\quadQ_iQ_j=-Q_jQ_i\text{ for } i\ne j.\]</span> 显然 <span class="math inline">\(n\)</span> 必须是偶数 （奇数阶反对称矩阵行列式都是0），而 <span class="math inline">\(n=2\)</span>的时候结论是成立的（复数域），所以下面我们都假定 <span class="math inline">\(n&gt;2\)</span>，于是 <span class="math inline">\(n\)</span> 的可能值为 <span class="math inline">\(4,6,8,\ldots\)</span>。</p><h1 id="用群表示论的工具得出矛盾">用群表示论的工具得出矛盾</h1><p>考虑这样一个抽象群 <span class="math inline">\(G\)</span>，它由元素<span class="math inline">\(a,g_1,\ldots,g_{n-1}\)</span>生成，且满足关系 <span class="math display">\[ a^2=1,\quad g_i^2=a,\quadg_ig_j=ag_jg_i\ \text{when}\ i\ne j.\]</span> 这里 <span class="math inline">\(a\)</span> 对应的是上面矩阵中的 <span class="math inline">\(-I_n\)</span>，<span class="math inline">\(g_i\)</span> 对应的上面矩阵中的 <span class="math inline">\(Q_i\)</span>。这个群的结构很好分析：</p><ul><li><span class="math inline">\(|G|=2^n\)</span>，每个元素形如 <span class="math inline">\(a^{e_0}g_1^{e_1}\cdotsg_{n-1}^{e_{n-1}}\)</span>，其中 <span class="math inline">\(e_i\in\{0,1\}\)</span>。</li><li><span class="math inline">\(G\)</span> 的中心 <span class="math inline">\(Z(G)=\{1,a,g_1g_2\cdots g_{n-1},ag_1g_2\cdotsg_{n-1}\}\)</span>。</li><li><span class="math inline">\(G\)</span> 的换位子群 <span class="math inline">\([G,G]=\{1,a\}\)</span>，从而 <span class="math inline">\(G\)</span> 有 <span class="math inline">\(|G/[G,G]|=2^{n-1}\)</span> 个线性表示。</li><li><span class="math inline">\(G\)</span>的任何非平凡共轭类都只有两个元素 <span class="math inline">\(\{g,ag\}\)</span>，从而 <span class="math inline">\(G\)</span> 有 <span class="math inline">\(2^{n-1}+2\)</span>个共轭类，从而其不可约复表示的个数也是 <span class="math inline">\(2^{n-1}+2\)</span>。</li></ul><p>于是我们知道 <span class="math inline">\(G\)</span> 有 <span class="math inline">\(2^{n-1}\)</span> 个一次表示，还有 2 个次数大于 1的表示，设它俩的次数分别是 <span class="math inline">\(f_1,f_2\)</span>，根据不可约表示次数的平方和等于<span class="math inline">\(G\)</span> 的阶，得到方程 <span class="math display">\[f_1^2+f_2^2 + 2^{n-1}=|G|=2^n.\]</span> 即 <span class="math inline">\(f_1^2+f_2^2=2^{n-1}\)</span>。再利用不可约表示的次数整除<span class="math inline">\(G\)</span> 的阶，知道 <span class="math inline">\(f_1\)</span> 和 <span class="math inline">\(f_2\)</span> 都是 2 的幂，这只有一种可能，就是<span class="math display">\[ f_1=f_2=2^{\frac{n}{2}-1}.\]</span></p><p>现在 Hurwitz 矩阵方程给出了 <span class="math inline">\(G\)</span>的一个 <span class="math inline">\(n\)</span>维表示，这个表示可以分解为若干不可约表示的直和，我们断言其中不含有一次表示，从而只能是若干个<span class="math inline">\(2^{\frac{n}{2}-1}\)</span>次表示的直和：这是因为元素 <span class="math inline">\(a\)</span>在这个表示下是 <span class="math inline">\(n\)</span> 阶矩阵 <span class="math inline">\(-I_n\)</span>，从而其在任何不变子空间上的作用都是乘以-1。但是任何一次表示都把 <span class="math inline">\(a\in [G,G]\)</span>映射为 1，矛盾！</p><p>于是 <span class="math inline">\(2^{\frac{n}{2}-1}\big|n\)</span>，设 <span class="math inline">\(n=2^r\cdot s\)</span>，其中<span class="math inline">\(s\)</span> 为奇数，则 <span class="math inline">\(\frac{n}{2}-1\leq r\)</span>，从而 <span class="math display">\[ 2^r\leq n\leq 2r+2.\]</span> 注意 <span class="math inline">\(n\)</span> 是偶数，所以只能是 <span class="math inline">\(n=4,6,8\)</span>，这就完成了 Hurwitz定理的证明。</p><h1 id="如果范数不是-euclidean-呢">如果范数不是 Euclidean 呢？</h1><p>我猜你很可能会提出进阶的问题：如果把 Euclidean 范数 <span class="math inline">\(|\cdot|\)</span> 换成一般的（非零）范数 <span class="math inline">\(N\)</span>，但是仍然要求 <span class="math inline">\(N(v\times w)=N(v)\cdotN(w)\)</span>，那么情况会如何呢？这个时候 “1, 2, 4, 8”定理仍然成立，但是根据是否存在 <span class="math inline">\(v\ne0\)</span> 使得 <span class="math inline">\(N(v)=0\)</span>，有两种可能：</p><ol type="1"><li>上面看到的 <span class="math display">\[\mathbb{R}\subset\mathbb{C}\subset \mathbb{H}\subset \mathbb{O}.\]</span> 对应任何 <span class="math inline">\(v\ne 0\)</span> 都有 <span class="math inline">\(N(v)\ne 0\)</span>；</li><li>而另一种可能是 <span class="math display">\[\mathbb{R}\subset\mathbb{R}\times\mathbb{R}\subset\mathrm{Mat}_2(\mathbb{R})\subset\mathbb{O}_s.\]</span> 其中 <span class="math inline">\(\mathbb{O}_s\)</span> 是可裂八元数 (splitoctonion)。对后面三个代数，<span class="math inline">\(N\)</span> 形如<span class="math inline">\(N(a,b)=|a|^2-|b|^2\)</span>，其中 <span class="math inline">\(a,b\)</span> 具有相同的维数。</li></ol><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/Octonion#History">https://en.wikipedia.org/wiki/Octonion#History</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 有限群表示与结合代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jordan 标准形</title>
      <link href="/jordan-canonical-form/"/>
      <url>/jordan-canonical-form/</url>
      
        <content type="html"><![CDATA[<p>Jordan标准形定理是线性代数中的基本定理，你可能会好奇，这么一个老掉牙的，在无数教材和讲义中都可以找到的定理，还能写出什么新意来呢？</p><p>理由有两个。第一个是我曾经在做助教给学生讲这个定理的时候，突然发现不知道该怎么启发他们为好。虽然我知道Jordan标准形定理的很多种证法，照念几个不在话下，但是感觉很不自然：为什么要引入Jordan块？这些块究竟代表了什么？怎么才能说清定理背后的想法，让学生觉得定理的成立是顺理成章的呢？于是我知道我对这个定理的理解还有模糊的地方。</p><p>第二个原因是 Jordan块有一个重要的代数性质是通常教材中不讲的，而这个性质是代数学中一类重要而常见的性质的雏形，这就是不可分解性。与之对应的是可对角化的线性变换的完全可约性。从一开始就让学生接触这些现象是有好处的。</p><span id="more"></span><h1 id="什么是-jordan-标准形">什么是 Jordan 标准形</h1><p>你肯定知道，整数环和多项式环有唯一因子分解定理：每个整数可以唯一地分解为素数的乘积，每个域上的多项式可以唯一地分解为不可约多项式的乘积。数学里面有很多这样的唯一分解定理，现在我们想问：有没有所谓的“线性变换的唯一分解定理”呢？可以猜测如果有这样的定理存在，那么大概可以表述为如下的样子：</p><div id="unique-1" class="statement sta____________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">线性变换的唯一分解定理</span>.</span><span class="statement-spah"> </span>（粗糙的版本）：设 <span class="math inline">\(V\)</span> 是域 <span class="math inline">\(F\)</span> 上的有限维向量空间，<span class="math inline">\(T\)</span> 是 <span class="math inline">\(V\)</span> 上的线性变换，则 <span class="math inline">\(T\)</span>可以唯一地分解为若干个「简单的」线性变换，而这些「简单的」线性变换本身不能再分解。</p></div><p>虽然这个表述还很不清楚，但是已经抓住了 Jordan 标准形的核心思想。</p><p>不过我们需要先说清楚，什么是线性变换的分解？什么是不可分解的线性变换？这就要借助直和的概念：</p><div class="statement simple plain unnumbered"><p>设 <span class="math inline">\(T\)</span> 是向量空间 <span class="math inline">\(V\)</span> 上的线性变换，如果 <span class="math inline">\(V\)</span> 可以分解为一些非平凡的子空间的直和<span class="math inline">\(V=V_1\oplus\cdots\oplusV_k\)</span>，使得每一个 <span class="math inline">\(V_i\)</span> 都是<span class="math inline">\(T\)</span>- 不变的子空间，则称 <span class="math inline">\(T\)</span> 是可以分解的；如果 <span class="math inline">\(V\)</span> 不存在这样的分解，则称 <span class="math inline">\(T\)</span> 是不可分解的线性变换。</p></div><p>现在我们可以比较准确的表述线性变换的唯一分解定理了：</p><div id="unique-2" class="statement sta____________-1 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">线性变换的唯一分解定理</span>.</span><span class="statement-spah"> </span>（修正的版本）：设 <span class="math inline">\(V\)</span> 是域 <span class="math inline">\(F\)</span> 上的有限维向量空间，<span class="math inline">\(T\)</span> 是 <span class="math inline">\(V\)</span> 上的线性变换，则 <span class="math inline">\(V\)</span> 可以分解为若干个 <span class="math inline">\(T\)</span>- 不变子空间的直和 <span class="math inline">\(V=V_1\oplus\cdots\oplus V_k\)</span>，<span class="math inline">\(T\)</span> 限制在每个 <span class="math inline">\(V_i\)</span>上是不可分解的线性变换。这个分解还是唯一的，即如果 <span class="math inline">\(V=W_1\oplus\cdots\oplus W_l\)</span>是另一种分解，则 <span class="math inline">\(k=l\)</span>且适当重排以后，对每个 <span class="math inline">\(i\)</span>，<span class="math inline">\(T\)</span> 在 <span class="math inline">\(V_i\)</span> 上的限制与 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(W_i\)</span> 上的限制是相似的。</p></div><p>这里有一个重要的问题需要说明：在一般的域上研究不可分解的线性变换是一个棘手的多的问题，这个问题的解决要用到Frobenius 有理标准形，而在复数域上问题就简单很多，这就是 Jordan标准形做的事情。在本文中我们都在复数域上讨论。</p><p>那么什么样的线性变换算是不可分解的线性变换呢？</p><p>最简单也是最重要的例子就是移位算子：假设 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(V\)</span> 的一组基 <span class="math inline">\(\{v_1,\cdots,v_n\}\)</span>的作用是一个向右的移位： <span class="math display">\[T:\quadv_n\rightarrow v_{n-1}\rightarrow\cdots\rightarrowv_1\rightarrow0.\]</span> 则称 <span class="math inline">\(T\)</span>是一个移位算子。<span class="math inline">\(T\)</span>在这组基下的矩阵为 <span class="math inline">\(J_0\)</span>: <span class="math display">\[(v_1, v_2, \ldots, v_n)J_0 = (0, v_1, \ldots,v_{n-1}),\quad J_0=\begin{pmatrix}0&amp;1&amp;&amp;\\ &amp;\ddots&amp;\ddots &amp;\\ &amp;&amp;0&amp;1\\&amp;&amp;&amp;0\end{pmatrix}.\]</span></p><p><span class="math inline">\(J_0\)</span> 叫做特征值为 0 的 Jordan块。注意 <span class="math inline">\(T\)</span> 是一个幂零算子：<span class="math inline">\(T^n=0\)</span>，它仅有唯一的特征值 0。</p><p>为什么 <span class="math inline">\(T\)</span> 是不可分解的？假设<span class="math inline">\(V=U\oplus W\)</span> 是两个非平凡 <span class="math inline">\(T\)</span>- 不变子空间的直和，则 <span class="math inline">\(T\)</span> 作为 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(W\)</span> 上的幂零线性变换必然各有一个特征值为 0的特征向量，因此齐次线性方程组 <span class="math inline">\(TX=0\)</span>的解空间至少包含两个线性无关的向量。但是 <span class="math inline">\(T\)</span> 的秩是 <span class="math inline">\(n-1\)</span>，所以 <span class="math inline">\(TX=0\)</span> 的解空间是 1维的，这就导致了矛盾。</p><p>现在我们做个小变化。把 <span class="math inline">\(T\)</span> 改成<span class="math inline">\(S=T+\lambdaI\,(\lambda\in\mathbb{C})\)</span>，<span class="math inline">\(S\)</span> 对应的矩阵 <span class="math display">\[J_\lambda=\begin{pmatrix}\lambda&amp;1&amp;&amp;\\&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\lambda&amp;1\\&amp;&amp;&amp;\lambda\end{pmatrix}\]</span>叫做特征值为 <span class="math inline">\(\lambda\)</span> 的 Jordan块。<span class="math inline">\(S\)</span>也是不可分解的线性变换，道理完全相同，它的秩是 <span class="math inline">\(n-1\)</span>，只有唯一的特征值 <span class="math inline">\(\lambda\)</span>，所以 <span class="math inline">\(V\)</span> 不可能分解成两个非平凡 <span class="math inline">\(S\)</span>- 不变子空间的直和。　</p><p>Jordan块是我们在线性变换的世界中找到的“原子”，是那些不能再分解的变换。那是不是每个线性变换都可以拆成若干个Jordan 块呢？答案是肯定的：</p><div id="jordan-canonical" class="unnumbered statement sta_jordan______ plain"><p><span class="statement-heading"><span class="statement-label">Jordan标准形定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span> 上有限维向量空间 <span class="math inline">\(V\)</span> 上的线性变换，则存在 <span class="math inline">\(V\)</span> 的一组基使得 <span class="math inline">\(T\)</span> 在这组基下的矩阵为 Jordan 块的直和：<span class="math display">\[T=J_{\lambda_1}\oplus\cdots\oplusJ_{\lambda_r}.\]</span>如果不在乎块的排列顺序，那么这种分解就是唯一的，即如果存在 <span class="math inline">\(V\)</span> 的另一组基使得 <span class="math inline">\(T\)</span> 的矩阵也是 Jordan 块的直和 <span class="math display">\[T=J_{\mu_1}\oplus\cdots\oplus J_{\mu_s},\]</span>则 <span class="math inline">\(r=s\)</span> 且适当重排后有 <span class="math inline">\(J_{\lambda_i}=J_{\mu_i}\)</span>。</p></div><h1 id="jordan-标准形定理的证明">Jordan 标准形定理的证明</h1><p>定理的结论包含存在性和唯一性两部分，我们先来处理存在性的证明。</p><h2 id="分解存在性-1转化为幂零的情形">分解存在性1：转化为幂零的情形</h2><p>我们之前提到了幂零的 Jordan 标准形 <span class="math inline">\(J_0\)</span>，它是最简单的 Jordan 标准形，只有<span class="math inline">\(n-1\)</span> 个 <span class="math inline">\(1\)</span> 在对角线上方，其余位置都是 <span class="math inline">\(0\)</span>。但实际上，任何线性变换都可以通过一个叫做<strong>准素分解定理（PrimaryDecomposition）</strong>的东西，拆成若干“只有单一特征值”的部分，每个部分再减去那个特征值，就成了幂零算子。所以本质上，Jordan标准形定理等价于证明“任何幂零线性变换总是可以分解为一些零特征值的 Jordan块的直和”。</p><div id="primary-decomposition" class="unnumbered statement sta_______ plain"><p><span class="statement-heading"><span class="statement-label">准素分解定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(T\)</span>的特征多项式为 <span class="math inline">\(f(x)\)</span>，且 <span class="math inline">\(f(x)\)</span> 在复数域上分解为一次因式的乘积 <span class="math display">\[f(x)=(x-\lambda_1)^{n_1}\cdots(x-\lambda_k)^{n_k},\]</span>这里的 <span class="math inline">\(\lambda_i\)</span> 互不相同。令 <span class="math inline">\(V_i=\mathrm{Ker}(T-\lambda_i I)^{n_i}\)</span>，则每个 <span class="math inline">\(V_i\)</span> 都是 <span class="math inline">\(T\)</span>- 不变子空间而且 <span class="math display">\[V=V_1\oplus\cdots\oplus V_m.\]</span></p></div><p><strong>证明</strong>：我们从一个简单的引理出发：</p><div id="coprime" class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(T\)</span> 是域 <span class="math inline">\(F\)</span> 上有限维向量空间 <span class="math inline">\(V\)</span> 上的线性变换，<span class="math inline">\(p(x),q(x)\in F[x]\)</span>是两个互素的多项式，且有 <span class="math inline">\(p(T)\cdotq(T)=0\)</span>。则 <span class="math inline">\(V=\mathrm{Ker}p(T)\oplus\mathrm{Ker}q(T)\)</span>。</p></div><p>引理的证明：由于 <span class="math inline">\(p(x),q(x)\)</span>是互素的多项式，所以存在多项式 <span class="math inline">\(s(x),t(x)\)</span> 满足 <span class="math display">\[s(x)p(x)+t(x)q(x)=1.\]</span> 即 <span class="math display">\[s(T)p(T)+t(T)q(T)=I.\]</span> 于是对任何 <span class="math inline">\(v\in V\)</span> 有 <span class="math display">\[v= \underbrace{s(T)p(T)v}_{\in\mathrm{Ker}q(T)} +\underbrace{t(T)q(T)v}_{\in\mathrm{Ker}p(T)}.\]</span> 这说明 <span class="math inline">\(V = \mathrm{Ker}p(T) +\mathrm{Ker}q(T)\)</span>。要验证这是直和，不妨设 <span class="math inline">\(v\in\mathrm{Ker}p(T)\cap\mathrm{Ker}q(T)\)</span>，则<span class="math inline">\(p(T)v=q(T)v=0\)</span>，于是 <span class="math display">\[v =s(T)p(T)v+t(T)q(T)v = 0.\]</span></p><p>把引理的结论反复应用在 <span class="math inline">\(f(x)\)</span>上即可得出准素分解定理。<span class="math inline">\(\blacksquare\)</span></p><h2 id="分解存在性-2证明幂零的情形">分解存在性 2：证明幂零的情形</h2><p>借助 <a href="#primary-decomposition" title="准素分解定理">准素分解定理</a>，我们把分解存在性转化为论证若<span class="math inline">\(N\)</span> 是某个向量空间 <span class="math inline">\(V\)</span> 上的幂零线性变换，则存在 <span class="math inline">\(V\)</span> 的一组基，使得 <span class="math inline">\(N\)</span> 在这组基下的矩阵是若干零特征值 Jordan块 <span class="math inline">\(J_0\)</span> 的和。注意一个 Jordan块对应的是一个链 <span class="math display">\[v\rightarrow Nv\rightarrow\cdots \rightarrow N^kv\rightarrow 0.\]</span>我们要证明存在若干条这样的互不相交的链，这些链所包含的全部非零向量构成<span class="math inline">\(V\)</span> 的一组基。</p><p>这一步的证明方法很多，但是相差不是很大，具体喜欢那种要看个人主观，这里介绍的是最简单也是最容易被初学者接受的一种。</p><p>对 <span class="math inline">\(V\)</span> 的维数 <span class="math inline">\(\dim V\)</span> 归纳，<span class="math inline">\(\dim V=1\)</span> 时显然结论成立。</p><p>现假设结论对所有维数小于 <span class="math inline">\(\dim V\)</span>的向量空间成立，考虑 <span class="math inline">\(V\)</span> 的像空间<span class="math inline">\(\mathrm{Im}(V)\)</span>。这是一个 <span class="math inline">\(N\)</span>- 不变子空间，且由于 <span class="math inline">\(N\)</span> 是幂零线性变换所以 <span class="math inline">\(\dim \mathrm{Im}(V)&lt;\dim V\)</span>，所以可以对<span class="math inline">\(\mathrm{Im}(V)\)</span> 使用归纳假设：存在<span class="math inline">\(\mathrm{Im}(V)\)</span>的一组基如下，它们构成 <span class="math inline">\(q\)</span>条不相交的链 <span class="math inline">\(\mathcal{O}_1,\cdots,\mathcal{O}_q\)</span>：</p><p><span class="math display">\[\begin{array}{l}&amp;v_{1,1}\rightarrowv_{1,2}\rightarrow\cdots\rightarrow v_{1,n_1}\rightarrow0.\\&amp;v_{2,1}\rightarrow v_{2,2}\rightarrow\cdots\rightarrowv_{2,n_2}\rightarrow 0.\\&amp;\cdots\\&amp; v_{q,1}\rightarrowv_{q,2}\rightarrow\cdots\rightarrow v_{q,n_q}\rightarrow0.\end{array}\]</span></p><p>由于 <span class="math inline">\(v_{i,1}\in \mathrm{Im}(V)\)</span>因此可以设 <span class="math inline">\(v_{i,1}=Nw_i\)</span>，从而我们得到一组更长的链（就是在前面加上一项）</p><p><span class="math display">\[\begin{array}{l}&amp;w_1\rightarrowv_{1,1}\rightarrow v_{1,2}\rightarrow\cdots\rightarrowv_{1,n_1}\rightarrow 0.\\&amp;w_2\rightarrow v_{2,1}\rightarrowv_{2,2}\rightarrow\cdots\rightarrow v_{2,n_2}\rightarrow0.\\&amp;\cdots\cdots\cdots\\&amp;w_q\rightarrow v_{q,1}\rightarrowv_{q,2}\rightarrow\cdots\rightarrow v_{q,n_q}\rightarrow0.\end{array}\]</span></p><p>那么这些新链包含的向量是否构成 <span class="math inline">\(V\)</span>的一组基？答案是我们还要补上一些在 <span class="math inline">\(V\)</span> 中长度是 1，但是在 <span class="math inline">\(\mathrm{Im}(V)\)</span> 中“消失”了的链：注意 <span class="math inline">\(\{v_{1,n_1},\cdots,v_{q,n_q}\}\)</span> 是 <span class="math inline">\(\mathrm{Ker}N\)</span> 中的线性无关元，但是 <span class="math inline">\(\mathrm{Ker}N\)</span>还可能有其它的基向量。将它们扩充为 <span class="math inline">\(\mathrm{Ker}N\)</span> 的一组基</p><p><span class="math display">\[\{ v_{1,n_1},\cdots,v_{q,n_1}\}\cup \{w_{q+1},\cdots,w_{K}\},\quad K=\dim\mathrm{Ker}N.\]</span></p><p>从而我们最终得到下面的链图：</p><p><span class="math display">\[\begin{array}{r}\mathbf{w_1}\rightarrowv_{1,1}\rightarrow v_{1,2}\rightarrow\cdots\rightarrowv_{1,n_1}\rightarrow 0.&amp;\\\mathbf{w_2}\rightarrow v_{2,1}\rightarrowv_{2,2}\rightarrow\cdots\rightarrow v_{2,n_2}\rightarrow0.&amp;\\\cdots\cdots\cdots&amp;\\\mathbf{w_q}\rightarrowv_{q,1}\rightarrow v_{q,2}\rightarrow\cdots\rightarrowv_{q,n_q}\rightarrow 0.&amp;\\\mathbf{w_{q+1}}\rightarrow0.&amp;\\\cdots\cdots&amp;\\\mathbf{w_K}\rightarrow0.\end{array}\]</span></p><p>你可以看到 <span class="math inline">\(w_{q+1},\ldots,w_K\)</span>正是那些在 <span class="math inline">\(V\)</span> 中长度为 1，但是在<span class="math inline">\(\mathrm{Im}(V)\)</span>中「消失」了的链。</p><p>最后只剩下验证这些向量确实构成 <span class="math inline">\(V\)</span>的一组基。显然这些向量一共有 <span class="math display">\[\dim\mathrm{Im}(V)+\dim\mathrm{Ker}N=\dim V\]</span>个，所以只要再说明它们是线性无关的。</p><p>假设有线性关系</p><p><span class="math display">\[\cdots+(c_0w_i+c_1v_{i,1}+\cdots+c_{n_i}v_{i,n_i})+\cdots+\sum_{j=q+1}^Kd_jw_j=0,\]</span></p><p>我们要说明出现在上式中的所有系数 <span class="math inline">\(c_i,d_j\)</span> 都是 0。左边用 <span class="math inline">\(N\)</span> 作用得到</p><p><span class="math display">\[\cdots+(c_0v_{i,1}+c_1v_{i,2}+\cdots+c_{n_i-1}v_{i,n_i})+\cdots=0.\]</span></p><p>这是一个关于 <span class="math inline">\(\mathrm{Im}(V)\)</span>的一组基的一个线性关系，于是 <span class="math inline">\(c_0=\cdots=c_{n_i-1}=0\)</span>，从而剩下的线性关系为</p><p><span class="math display">\[\cdots+c_{n_i}v_{i,n_i}+\cdots+\sum_{j=q+1}^Kd_jw_j=0.\]</span></p><p>而这是一个关于 <span class="math inline">\(\mathrm{Ker}N\)</span>的一组基的一个线性关系，于是 <span class="math inline">\(c_{n_i}=d_{q+1}=\cdots=d_K=0\)</span>，从而所有的系数都是0，这就完成了 Jordan 标准形存在性的证明。</p><h2 id="分解唯一性的证明">分解唯一性的证明</h2><p>要证明分解的唯一性，我们只要证明任何幂零线性变换 <span class="math inline">\(N\)</span> 分解为 Jordan 块的方式是唯一的。根据Jordan 标准形存在性的证明，我们有如下的链图： <span class="math display">\[\begin{array}{r}v_{1,1}\rightarrowv_{1,2}\rightarrow\cdots\rightarrow v_{1,n_1}\rightarrow0.&amp;\\v_{2,1}\rightarrow v_{2,2}\rightarrow\cdots\rightarrowv_{2,n_2}\rightarrow 0.&amp;\\\cdots\cdots&amp;\\ v_{q,1}\rightarrowv_{q,2}\rightarrow\cdots\rightarrow v_{q,n_q}\rightarrow0.\end{array}\]</span> 这里每个链代表一个 Jordan 块，按照 <span class="math inline">\(n_1\geq\cdots\geq n_q\)</span>的顺序排列。我们要证明链图中行数 <span class="math inline">\(q\)</span>和行的长度 <span class="math inline">\((n_1,\ldots,n_q)\)</span>都是唯一确定的，不依赖于基的选择。</p><p>我用一个具体的例子来说明：</p><p><span class="math display">\[\begin{array}{r}\bullet\rightarrow {\color{blue}{\bullet}}\rightarrow{\color{green}{\bullet}}\rightarrow{\color{red}{\bullet}}\rightarrow 0.\\{\color{blue}{\bullet}}\rightarrow{\color{green}{\bullet}}\rightarrow{\color{red}{\bullet}}\rightarrow0.&amp;\\{\color{green}{\bullet}}\rightarrow{\color{red}{\bullet}}\rightarrow0.&amp;\\{\color{red}{\bullet}}\rightarrow 0.\\{\color{red}{\bullet}}\rightarrow 0.\end{array}\]</span></p><p>注意到在链图中，从右边数起，从第 <span class="math inline">\(1\)</span> 到第 <span class="math inline">\(i\)</span> 列，都会被 <span class="math inline">\(N^i\)</span> 变成零向量。这些向量构成了 <span class="math inline">\(\mathrm{Ker}N^i\)</span>的一组基。例如在上面例子中，<span class="math inline">\(\{{\color{red}{\bullet}} \}\)</span> 的列构成了 <span class="math inline">\(\mathrm{Ker}N\)</span> 的一组基，<span class="math inline">\(\{ {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}\)</span> 的列构成了 <span class="math inline">\(\mathrm{Ker}N^2\)</span> 的一组基，等等。</p><p>于是我们有子空间的升链： <span class="math display">\[(0)\subset\underbrace{\mathrm{Ker}N}_{\{ {\color{red}{\bullet}} \}}\subset\underbrace{\mathrm{Ker}N^2}_{\{ {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}} \subset \underbrace{\mathrm{Ker}N^3}_{\{{\color{blue}{\bullet}}\mid {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}} \subset \underbrace{\mathrm{Ker}N^4}_{\{\bullet\mid {\color{blue}{\bullet}}\mid {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}}=V.\]</span> 不难看到右边的第 <span class="math inline">\(i\)</span> 列正好构成商空间 <span class="math inline">\(\mathrm{Ker}N^{i}/\mathrm{Ker}N^{i-1}\)</span>的一组基。 <span class="math display">\[\begin{aligned}\mathrm{Ker}N: \quad &amp;  \{ {\color{red}{\bullet}} \}\\\mathrm{Ker}N^2/\mathrm{Ker}N: \quad &amp; \{ {\color{green}{\bullet}}\}\\\mathrm{Ker}N^3/\mathrm{Ker}N^2: \quad &amp; \{ {\color{blue}{\bullet}}\}\\\mathrm{Ker}N^4/\mathrm{Ker}N^3=U/\mathrm{Ker}N^3: \quad &amp; \{\bullet \}\\\end{aligned}\]</span> 所以右边第 <span class="math inline">\(i\)</span> 列的长度等于<span class="math inline">\(\dim\mathrm{Ker}N^i -\dim\mathrm{Ker}N^{i-1}\)</span>。</p><p>另一方面右边第 <span class="math inline">\(i\)</span>列的长度还等于“长度 <span class="math inline">\(\geq i\)</span>的链的个数”。所以长度恰好等于 <span class="math inline">\(i\)</span>的链，即 <span class="math inline">\(i\)</span> 阶 Jordan 块的个数，等于<span class="math display">\[\begin{aligned}&amp;(\dim\mathrm{Ker}N^i -\dim\mathrm{Ker}N^{i-1})-(\dim\mathrm{Ker}N^{i+1} -\dim\mathrm{Ker}N^i)\\=&amp;\,2\dim\mathrm{Ker}N^i -\dim\mathrm{Ker}N^{i-1}-\dim\mathrm{Ker}N^{i+1}.\end{aligned}\]</span>这是一个由 <span class="math inline">\(N\)</span>完全确定的值。这就证明了分解的唯一性。</p><h1 id="进一步的思考">进一步的思考</h1><p>一个很有意思的问题是，给定</p><p><span class="math display">\[J_\lambda=\begin{pmatrix}\lambda&amp;1&amp;&amp;\\&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\lambda&amp;1\\&amp;&amp;&amp;\lambda\end{pmatrix}_{n\timesn}\]</span></p><p>为一个特征值 <span class="math inline">\(\lambda\)</span> 的 Jordan块，计算其 <span class="math inline">\(k\)</span> 次幂 <span class="math inline">\(J_\lambda^k\)</span> 的 Jordan 标准形。</p><p>当 <span class="math inline">\(\lambda\ne0\)</span> 时，</p><p><span class="math display">\[J_\lambda^k = \begin{pmatrix}\lambda^k&amp;k\lambda^{k-1}&amp;\ddots&amp;\\&amp;\lambda^k&amp;\ddots&amp;\ddots\\&amp;&amp;\ddots&amp;k\lambda^{k-1}\\&amp;&amp;&amp;\lambda^k\end{pmatrix}.\]</span></p><p>你知道怎样计算 <span class="math inline">\(J_\lambda^k\)</span>吗？记住这个技巧：把多项式 <span class="math inline">\(x^k\)</span> 在<span class="math inline">\(\lambda\)</span> 处 Taloy 展开：</p><p><span class="math display">\[x^k=(x-\lambda)^k+a_{k-1}(x-\lambda)^{k-1}+a_1(x-\lambda)+a_0,\]</span></p><p>然后代入即可。</p><p>和 Jordan 块不可分解性的证明完全一样，我们发现 <span class="math inline">\(J_\lambda^k-\lambda^k I\)</span> 的秩是 <span class="math inline">\(n-1\)</span>，因此方程组 <span class="math inline">\(J_\lambda^kX=\lambda^k X\)</span> 的解空间是 1维的，从而 <span class="math inline">\(J_\lambda^k\)</span>是不可分解的，因此其 Jordan 标准形只有一块，就是</p><p><span class="math display">\[\begin{pmatrix}\lambda^k&amp;1&amp;&amp;\\&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\lambda^k&amp;1\\&amp;&amp;&amp;\lambda^k\end{pmatrix}_{n\timesn}.\]</span></p><p>最有意思的情形发生在 <span class="math inline">\(\lambda=0\)</span>时，这个时候 Jordan 会均匀的碎裂为一些小的 Jordan 块的和。</p><p>这时 <span class="math inline">\(J_0\)</span> 是一个移位算子：</p><p><span class="math display">\[J_0:\quad v_n\rightarrowv_{n-1}\rightarrow \cdots \rightarrow v_1\rightarrow 0.\]</span></p><p>整个链只有一条。但是 <span class="math inline">\(J_0^k\)</span> 则是<span class="math inline">\(k\)</span> 步 <span class="math inline">\(k\)</span> 步地「跳」：</p><p><span class="math display">\[J_0^k:\quad \left\{\begin{array}{l}v_n\rightarrow v_{n-k}\rightarrow \cdots\rightarrow0,\\v_{n-1}\rightarrow v_{n-1-k}\rightarrow \cdots\rightarrow0,\\\cdots\\v_{n-k+1}\rightarrow v_{n-2k+1}\rightarrow \cdots\rightarrow 0.\end{array}\right.\]</span></p><p>所以 <span class="math inline">\(J_0^k\)</span> 有 <span class="math inline">\(k\)</span> 条链，每个链都是一个 Jordan 块，即<span class="math inline">\(J_0^k\)</span> 的标准形中有 <span class="math inline">\(k\)</span> 个 Jordan 块。设 <span class="math inline">\(n=qk+r\)</span>，这里 <span class="math inline">\(0\leq r&lt; k\)</span>，则这 <span class="math inline">\(k\)</span> 个 Jordan 块中有 <span class="math inline">\(r\)</span> 个是 <span class="math inline">\(q+1\)</span> 阶的，<span class="math inline">\(k-r\)</span> 个是 <span class="math inline">\(q\)</span> 阶的。</p><p>举个例子就明白了，一个 8 阶的 0 特征值 Jordan 块 <span class="math inline">\(J_0\)</span>，<span class="math inline">\(J_0^3\)</span> 的 Jordan标准形是什么样子的？这个时候 <span class="math inline">\(J_0^3\)</span>有 3 个链 <span class="math inline">\(\{v_8,v_5,v_2\}\)</span>, <span class="math inline">\(\{v_7,v_4,v_1 \}\)</span>, <span class="math inline">\(\{v_6,v_3\}\)</span>，所以 <span class="math inline">\(J_0^3\)</span> 的 Jordan 标准形有 2 个 3 阶的Jordan 块和 1 个 2 阶的 Jordan 块。</p><p>总结一下：零特征值的 Jordan块的高次幂一定会分裂，而且是尽可能均匀的分裂；非零特征值的 Jordan块的任意次幂都不会分裂。</p><p>一个不可约的代数结构，在某种限制或者扩张的意义下却能均匀的「碎裂」，这是代数学中一个常见而重要的现象。比如设<span class="math inline">\(f\)</span> 是一个有理数域 <span class="math inline">\(\mathbb{Q}\)</span> 上的不可约多项式，<span class="math inline">\(F\)</span> 是 <span class="math inline">\(\mathbb{Q}\)</span> 的一个正规扩域，则如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(F\)</span> 上是可约的，那么 <span class="math inline">\(f\)</span>必然分解成一些次数相同的多项式的乘积：</p><p><span class="math display">\[f=f_1f_2\cdots f_r,\quad \degf_1=\cdots=\deg f_r.\]</span></p><p>类似的现象还有代数数论中素理想的分解，群表示论中不可约表示（在诱导和限制下） 的分解，代数几何中不可约代数簇的分解等等。</p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>矩阵空间的子空间</title>
      <link href="/space-of-matrices/"/>
      <url>/space-of-matrices/</url>
      
        <content type="html"><![CDATA[<p>在数学里面经常可以提出这样一些问题：它们叙述起来很简单，答案看起来也很显然，但是要仔细证明却非常困难。即使是线性代数这样的「入门课」中也不缺少这样的问题：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>记域 <span class="math inline">\(\mathbb{F}\)</span> 上的全体 <span class="math inline">\(n\)</span> 阶矩阵构成的向量空间为 <span class="math inline">\({\rm Mat}_n(\mathbb{F})\)</span>，<span class="math inline">\(M\)</span> 是 <span class="math inline">\({\rmMat}_n(\mathbb{F})\)</span> 的子空间。</p><ol type="1"><li>如果 <span class="math inline">\(M\)</span>中所有矩阵关于矩阵乘法两两可以交换，那么 <span class="math inline">\(M\)</span> 的维数最大是多少？</li><li>如果 <span class="math inline">\(M\)</span> 中所有矩阵的秩都不超过<span class="math inline">\(r\)</span>，这里 <span class="math inline">\(0&lt;r&lt;n\)</span>，那么 <span class="math inline">\(M\)</span> 的维数最大是多少？</li><li>如果 <span class="math inline">\(M\)</span>中所有矩阵都是幂零的，那么 <span class="math inline">\(M\)</span>的维数最大是多少？</li><li>如果 <span class="math inline">\(M\)</span>中所有非零矩阵都是可逆矩阵，那么 <span class="math inline">\(M\)</span>的维数最大是多少？</li></ol></div><span id="more"></span><p>我是在几年前一个偶然的时刻自己想到了这几个问题，那个时候我已经本科毕业了，不是初学线性代数的新手了，但是苦思冥想了很久，结果一个也没做出来。我当时很惊讶，这么有趣而不平凡的问题居然在我身边潜伏了那么久而没有注意到。长久以来我们一直都是把各种习题集做的滚瓜烂熟，然后考试拿个高分就自以为学的很好了，很少自己去发现问题。我可以肯定的讲这几个问题在任何本科线性代数的教材中都没有提到，但是教材上不讲并不是我们无视它们的理由。于是我开始查阅资料，发现这四个问题的确是有难度的问题，要完全弄懂并不容易，但是这种探索本身就是一种令人难忘而愉悦的经历。</p><p>接下来将依次介绍前三个问题的解答，它们综合使用了各种各样的线性代数的技巧，这些技巧如果一步步拆开来，其实也很普通。总之这三个问题是对读者基本功的一次很好的检验。至于第四个问题嘛… 不会做很正常，会做才不正常。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>问题的提法中对域 <span class="math inline">\(\mathbb{F}\)</span>没有什么限制，实际上前三个问题的答案确实与域无关，只有第四个问题是例外。但是如果要让证明对任何域<span class="math inline">\(\mathbb{F}\)</span>都适用那就要花不少心思，旁生不少枝节。为了让文章读起来不那么晦涩，我适当放宽了域的条件，这样证明简明很多。</p></div><h1 id="交换子空间的最大维数">交换子空间的最大维数</h1><p>如果 <span class="math inline">\(M\)</span>中的矩阵两两可以交换，我们来猜猜 <span class="math inline">\(M\)</span>的维数最大可能多少。首先很容易想到所有的对角矩阵是两两交换的，而所有对角矩阵构成的子空间维数是<span class="math inline">\(n\)</span>，所以答案不会小于 <span class="math inline">\(n\)</span>。</p><p>但是实际上还可以更大，下面的构造是最优的：（<span class="math inline">\(N\)</span> 是任意子矩阵）</p><p><span class="math display">\[\begin{pmatrix}\lambdaI_m&amp;N\\0&amp;\lambda I_m\end{pmatrix}\ (n=2m),\quad\begin{pmatrix}\lambda I_m&amp;N\\0&amp;\lambda I_{m+1}\end{pmatrix}\(n=2m+1).\]</span></p><p>这个结论于 1905 年被 Schur 所证明：</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(M\)</span> 的维数最大为 <span class="math inline">\(\left[\frac{n^2}{4}\right]+1\)</span>，其中 <span class="math inline">\([\cdot]\)</span> 为高斯取整函数。</p></div><p><strong>证明</strong>：首先假设 <span class="math inline">\(\mathbb{F}\)</span> 是代数闭域。对 <span class="math inline">\(n\)</span> 归纳，<span class="math inline">\(n=1\)</span> 时结论显然成立，设小于 <span class="math inline">\(n\)</span> 的时候结论成立，来看 <span class="math inline">\(n\)</span> 的情形。</p><p>由于 <span class="math inline">\(\mathbb{F}\)</span> 是代数闭域且<span class="math inline">\(M\)</span>中的矩阵两两可以交换，因此存在可逆矩阵 <span class="math inline">\(P\in{\rm Mat}_n(\mathbb{F})\)</span> 使得 <span class="math inline">\(P^{-1}MP\)</span> 中的矩阵都是上三角的，而 <span class="math inline">\(M\)</span> 和 <span class="math inline">\(P^{-1}MP\)</span>是同构的空间，因此我们不妨一开始就假定 <span class="math inline">\(M\)</span> 中的矩阵都是上三角矩阵。</p><p>对任何 <span class="math inline">\(A\in M\)</span>，记 <span class="math inline">\(f(A)\)</span> 为 <span class="math inline">\(A\)</span> 左上角的 <span class="math inline">\(n-1\)</span> 阶子矩阵，<span class="math inline">\(g(A)\)</span> 为 <span class="math inline">\(A\)</span> 右下角的 <span class="math inline">\(n-1\)</span> 阶子矩阵，则 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 都是从 <span class="math inline">\({\rmMat}_n(\mathbb{F})\)</span> 到 <span class="math inline">\({\rmMat}_{n-1}(\mathbb{F})\)</span> 的线性映射。<span class="math inline">\(f(M)\)</span> 和 <span class="math inline">\(g(M)\)</span> 都是 <span class="math inline">\({\rm Mat}_{n-1}(\mathbb{F})\)</span>的乘法交换子空间，因此由归纳假设 <span class="math display">\[\dimf(M)\leq\left[\frac{(n-1)^2}{4}\right]+1,\quad \dimg(M)\leq\left[\frac{(n-1)^2}{4}\right]+1.\]</span></p><p>不难看出 <span class="math inline">\(\ker f\)</span> 中的元素形如<span class="math inline">\(\begin{pmatrix}\mathbf{0}_{n\times(n-1)}&amp;\alpha\end{pmatrix}\)</span>，<span class="math inline">\(\ker g\)</span> 中的元素形如 <span class="math inline">\(\begin{pmatrix}\beta'\\\mathbf{0}_{(n-1)\timesn}\end{pmatrix}\)</span>。这里 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> 都是 <span class="math inline">\(n\times1\)</span> 向量，两者交换说明 <span class="math inline">\(\beta'\alpha=0\)</span>。设 <span class="math inline">\((\beta_1',\ldots,\beta_s')\)</span> 取自<span class="math inline">\(\ker g\)</span>的一组基并且排成行矩阵的形式，即设 <span class="math display">\[L=\left(\begin{array}{c}\beta_1'\\\beta_2' \\\vdots\\\beta_s' \\\end{array}\right),\]</span>则<span class="math inline">\(\ker f\)</span> 中的元素都是齐次方程组 <span class="math inline">\(LX=0\)</span> 的解，因此 <span class="math inline">\(\dim\ker f+\dim\ker g\leq n\)</span>，从而 <span class="math display">\[\begin{align*} \dim M&amp;=\dim \ker f+\dimf(M)=\dim\ker g+\dim g(M)\\&amp;\leq\frac{\dim\ker f+\dim\kerg}{2}+\left[\frac{(n-1)^2}{4}\right]+1\\&amp;\leq\frac{n}{2}+\left[\frac{(n-1)^2}{4}\right]+1.\end{align*}\]</span>这时需要分情况讨论：不论 <span class="math inline">\(n=2k\)</span>是偶数还是 <span class="math inline">\(n=2k+1\)</span> 是奇数，我们总有<span class="math display">\[\frac{n}{2}+\left[\frac{(n-1)^2}{4}\right]+1 &lt;k^2 + 2,\]</span> 因此 <span class="math inline">\(\dim M\leq k^2+1\leq\left[\frac{n^2}{4}\right]+1\)</span>。</p><p>在 <span class="math inline">\(\mathbb{F}\)</span>不是代数闭域的情形，显然答案不会超过 <span class="math inline">\(\left[\frac{n^2}{4}\right]+1\)</span>，但是我们开头的构造的例子是在<span class="math inline">\(\mathbb{F}\)</span>内的，它取到了这个最大值，因此结论依然成立。<span class="math inline">\(\blacksquare\)</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>有更简单的方式可以得出 <span class="math inline">\(\dim\ker f +\dim\ker g\leq n\)</span>。利用内积 <span class="math inline">\((\alpha,\beta) = \beta'\alpha\)</span> 是非退化的双线性型，以及 <span class="math inline">\(\ker f\)</span> 和 <span class="math inline">\(\ker g\)</span> 在这个双线性型下互相正交即可。</p></div><h1 id="m-中矩阵秩都不超过-r-时-m-的最大维数"><span class="math inline">\(M\)</span> 中矩阵秩都不超过 <span class="math inline">\(r\)</span> 时 <span class="math inline">\(M\)</span> 的最大维数</h1><p>第二个问题的答案比较好猜，就是 <span class="math inline">\(rn\)</span>，取所有后 <span class="math inline">\(n-r\)</span> 行元素均为 0的矩阵构成的向量空间即可，但是不太好证明。</p><p>证明的困难之处在于这个域 <span class="math inline">\(\mathbb{F}\)</span> 是任意的，如果 <span class="math inline">\(\mathbb{F}\)</span> 是实数域或者复数域这样有“内积” 的性质比较好的域，那么证明就简单很多。我们接下来就假定 <span class="math inline">\(\mathbb{F}\)</span>是实数域，对于一般的情形我把它留给</p><blockquote><p>H.landers 1962, On spaces of linear transformation of boundedrank.</p></blockquote><p>首先可以不妨假设 <span class="math inline">\(M\)</span>中存在一个形如 <span class="math display">\[A=\begin{pmatrix}I_r&amp;0\\0&amp;0\end{pmatrix}\]</span>的矩阵 （想一想，为什么？），于是我们有下面的结论：</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理2.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(M\)</span> 中的矩阵都形如 <span class="math display">\[\begin{pmatrix}B_{11}&amp;B_{12}\\B_{21}&amp;0\end{pmatrix}.\]</span>这里 <span class="math inline">\(B_{11}\)</span> 是 <span class="math inline">\(r\times r\)</span> 矩阵，且 <span class="math inline">\(B_{21}B_{12}=0\)</span>。</p></div><p>引理的证明：对任意的 <span class="math inline">\(B\in M\)</span>，将<span class="math inline">\(B\)</span> 分块为 <span class="math display">\[B=\begin{pmatrix}B_{11}&amp;B_{12}\\B_{21}&amp;B_{22}\end{pmatrix},\]</span>对任何实数 <span class="math inline">\(t\)</span>，<span class="math inline">\(tA+B\)</span> 仍然是 <span class="math inline">\(M\)</span> 中的矩阵，其秩不超过 <span class="math inline">\(r\)</span>，所以其任何 <span class="math inline">\(r+1\)</span> 阶子式必为 <span class="math inline">\(0\)</span>，即 <span class="math display">\[\Delta(t)=\begin{vmatrix}tI_r+B_{11}&amp;\beta_j\\\alpha_i&amp;b_{ij}\end{vmatrix}=0.\]</span>这里 <span class="math inline">\(b_{ij}\)</span> 表示<span class="math inline">\(B_{22}\)</span> 的第 <span class="math inline">\((i,j)\)</span> 个元素，<span class="math inline">\(\alpha_i\)</span> 表示 <span class="math inline">\(B_{21}\)</span> 的第 <span class="math inline">\(i\)</span> 行， <span class="math inline">\(\beta_j\)</span> 表示 <span class="math inline">\(B_{12}\)</span> 的第 <span class="math inline">\(j\)</span> 列。</p><p><span class="math inline">\(\Delta(t)\)</span> 是关于 <span class="math inline">\(t\)</span> 的多项式，由于它必须恒等于 <span class="math inline">\(0\)</span>，所以首项 <span class="math inline">\(t^r\)</span> 的系数 <span class="math inline">\(b_{ij}=0\)</span>，从而由 <span class="math inline">\((i, j)\)</span> 的任意性有 <span class="math inline">\(B_{22}=0\)</span>。下面来求它的 <span class="math inline">\(t^{r-1}\)</span> 次项系数。</p><p>存在无穷多个实数 <span class="math inline">\(t\)</span> 使得矩阵<span class="math inline">\(tI_r+B_{11}\)</span> 可逆，对这些 <span class="math inline">\(t\)</span> 利用行列式的 <a href="https://en.wikipedia.org/wiki/Schur_complement">Schur 补公式</a>有 <span class="math display">\[\begin{align*}\Delta(t)&amp;=|tI_r+B_{11}|\cdot(0-\alpha_i(tI_r+B_{11})^{-1}\beta_j)\\&amp;=-\alpha_i(tI_r+B_{11})^\ast\beta_j.\end{align*}\]</span>这里 <span class="math inline">\((tI_r+B_{11})^\ast\)</span> 表示矩阵<span class="math inline">\(tI_t+B_{11}\)</span> 的伴随矩阵。</p><p>由于 <span class="math inline">\(\Delta(t)=-\alpha_i(tI_r+B_{11})^\ast\beta_j\)</span>两边都是关于 <span class="math inline">\(t\)</span>的多项式，而且对无穷多个 <span class="math inline">\(t\)</span>它们相等，因此必然是恒等式。注意在伴随矩阵 <span class="math inline">\((tI_r+B_{11})^\ast\)</span> 的各个元素中，<span class="math inline">\(t^{r-1}\)</span> 项只出现在对角线上，且系数都是<span class="math inline">\(1\)</span>，因此 <span class="math inline">\(\Delta(t)\)</span> 的 <span class="math inline">\(r-1\)</span> 次项系数为 <span class="math inline">\(-\alpha_i\beta_j=0\)</span>，因此 <span class="math inline">\(B_{21}B_{12}=0\)</span>，引理成立。</p><p>现在考虑 <span class="math inline">\({\rm Mat}_n(\mathbb{R})\)</span>的子空间 <span class="math display">\[J=\left\{\begin{pmatrix}0&amp;P\\P'&amp;Q\end{pmatrix}\midP\in {\rm Mat}_{r\times(n-r)}(\mathbb{R}),\, Q\in {\rmMat}_{n-r}(\mathbb{R})\right\}.\]</span></p><p>不难看出 <span class="math inline">\(M+J\)</span> 是直和，从而 <span class="math inline">\(\dim M+\dim J\leq n^2\)</span>，再由 <span class="math inline">\(\dim J=n(n-r)\)</span> 即得 <span class="math inline">\(\dim M\leq rn\)</span>。</p><p>注意这里利用了实数域内积的正定性： 实矩阵 <span class="math inline">\(P'P=0\)</span> 当且仅当 <span class="math inline">\(P=0\)</span>，对复数域的情形可以用厄米特内积代替。对一般的域<span class="math inline">\(\mathbb{F}\)</span> 是没有内积的概念的，但是我们有迹函数 <span class="math display">\[{\rmMat}_n(\mathbb{F})\times {\rm Mat}_n(\mathbb{F})\rightarrow\mathbb{F}:\quad (A,B)\rightarrow\mathrm{tr}(AB).\]</span>这个非退化的双线性型可以代替内积，只是论证略麻烦。</p><h1 id="m-中矩阵都是幂零矩阵"><span class="math inline">\(M\)</span>中矩阵都是幂零矩阵</h1><p>这种情形答案也是很好猜的：所有严格上三角矩阵组成的子空间，其维数是<span class="math inline">\(n(n-1)/2\)</span>。</p><p>我们在 <span class="math inline">\({\rmchar}\,\mathbb{F}\ne2\)</span> 的条件下讨论。（当然特征是 2结论是一样的，不过证明要绕点弯路）</p><p>首先是一个小小的引理，它的证明很简单，这里省略。</p><div id="niltrace" class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>如果 <span class="math inline">\(A,B,A+B\)</span>都是幂零矩阵，则 <span class="math inline">\(\mathrm{tr}(AB)=0\)</span>。</p><p>（提示：展开 <span class="math inline">\(\mathrm{tr}(A+B)^2=0\)</span>）</p></div><p>其次我们需要迹函数的一些性质：<span class="math inline">\((A,B)\rightarrow\mathrm{tr}(AB)\)</span> 是一个<span class="math inline">\({\rm Mat}_n(\mathbb{F})\)</span>上的非退化的双线性函数，即如果某个 <span class="math inline">\(A\in{\rmMat}_n(\mathbb{F})\)</span> 使得对任何 <span class="math inline">\(B\in{\rm Mat}_n(\mathbb{F})\)</span> 有 <span class="math inline">\(\mathrm{tr}(AB)=0\)</span> 成立的话，则 <span class="math inline">\(A=0\)</span>。</p><p>设 <span class="math inline">\(V\)</span> 是 <span class="math inline">\({\rm Mat}_n(\mathbb{F})\)</span> 的子空间，定义<span class="math inline">\(V\)</span> 在迹函数下的正交补空间 <span class="math inline">\(V^{\bot}\)</span> 为</p><p><span class="math display">\[V^{\bot}=\{ B\in{\rmMat}_n(\mathbb{F})\mid \mathrm{tr}(AB)=0,\ \forall A\inV\}.\]</span></p><p>虽然未必有 <span class="math inline">\(V\capV^{\bot}=(0)\)</span>，但是总是有 <span class="math display">\[\dimV+\dim V^{\bot}=\dim{\rm Mat}_n(\mathbb{F})=n^2.\]</span>（这是非退化双线性型的基本结论）</p><p>记 <span class="math inline">\(M_1\)</span> 是 <span class="math inline">\(M\)</span>中所有严格上三角矩阵组成的子空间；取子空间 <span class="math inline">\(N\subset M\)</span> 使得 <span class="math inline">\(M=M_1\oplus N\)</span>，则 <span class="math inline">\(N\)</span> 中的非零矩阵都不是上三角矩阵，否则若<span class="math inline">\(A\in N\)</span> 是上三角矩阵，而 <span class="math inline">\(A\)</span>又是幂零矩阵，那么就必须是严格上三角矩阵，从而 <span class="math inline">\(A\in M_1\)</span>，这与 <span class="math inline">\(M_1\)</span> 和 <span class="math inline">\(N\)</span> 是直和矛盾。</p><p>设 <span class="math inline">\(U\)</span> 是 <span class="math inline">\({\rm Mat}_n(\mathbb{F})\)</span>中所有上三角矩阵组成的向量空间，则 <span class="math inline">\(U+N\)</span> 是直和。</p><p>记 <span class="math inline">\(M_1^{\bot}\)</span> 是 <span class="math inline">\(M_1\)</span> 在 <span class="math inline">\(\mathrm{tr}(,)\)</span>下的正交补。由于上三角矩阵和严格上三角矩阵的乘积是严格上三角矩阵，严格上三角矩阵的迹为0，因此 <span class="math inline">\(U\subset M_1^{\bot}\)</span>。</p><p>把 <a href="#niltrace" title="引理">引理</a> 用在 <span class="math inline">\(A\in M_1\)</span> 和 <span class="math inline">\(B\in N\)</span> 上我们得到 <span class="math inline">\(N\subset M_1^{\bot}\)</span>。然而我们已经说明了<span class="math inline">\(U+N\)</span> 是直和，因此 <span class="math inline">\(U\oplus N\subset M_1^{\bot}\)</span>，从而 <span class="math display">\[\dim U+\dim N\leq n^2-\dim M_1.\]</span> 注意<span class="math inline">\(\dim U=\frac{n(n+1)}{2}\)</span>，这就推出<span class="math display">\[\dim M=\dim N+\dim M_1\leq\frac{n(n-1)}{2}.\]</span> 实际上可以证明如果 <span class="math inline">\(\dim M=\frac{n(n-1)}{2}\)</span>，则存在可逆矩阵<span class="math inline">\(P\)</span> 使得 <span class="math inline">\(P^{-1}MP\)</span>都是严格上三角矩阵，不过这需要更复杂的分析，本文就不再写了。</p><h1 id="m-中的非零矩阵都是可逆矩阵"><span class="math inline">\(M\)</span> 中的非零矩阵都是可逆矩阵</h1><p>最后这个问题是最重要的一个，也是最难回答的一个，如果你自己做不出来也不用灰心，这是Adams 在 1962 年的论文 <a href="http://www.ams.org/journals/bull/1962-68-01/S0002-9904-1962-10693-4/S0002-9904-1962-10693-4.pdf">Vectorfields on spheres</a> 中证明的经典结论，这篇论文也是代数 K-理论的开山之作。</p><p>首先这个问题的答案依赖于域 <span class="math inline">\(\mathbb{F}\)</span>。在复数域上，如果 <span class="math inline">\(M\)</span> 的维数大于1，从中任取两个线性无关的矩阵 <span class="math inline">\(A,B\)</span>，则对任何复数 <span class="math inline">\(t\)</span>，<span class="math inline">\(A+tB\)</span>是非零矩阵因而可逆，这显然不可能，因此 <span class="math inline">\(M\)</span> 的维数只能是 1 （比如取所有形如 <span class="math inline">\(\lambda I_n\)</span> 的矩阵）。</p><p>在实数域上，答案是非常难以猜到的，叫做 Radon-Hurwitz 数：设 <span class="math inline">\(n=2^ab\)</span>，<span class="math inline">\(b\)</span> 是奇数，<span class="math inline">\(a=c+4d\)</span>，<span class="math inline">\(0\leqc&lt;4\)</span>，定义 <span class="math inline">\(\rho(n)=2^c+8d\)</span>，则 <span class="math inline">\(M\)</span> 的维数最大是 <span class="math inline">\(\rho(n)\)</span>。</p><p>证明这个结论分两步，首先用代数 K- 理论的知识证明 <span class="math inline">\(M\)</span> 的维数不会超过 <span class="math inline">\(\rho(n)\)</span>，然后用 Clifford代数的表示构造一个维数为 <span class="math inline">\(\rho(n)\)</span>的子空间。整个过程要用到非常多的数学知识以至于要完整写下来需要一本书的篇幅，这是本文力所不及的。</p><h1 id="结语">结语</h1><p>其实类似的问题还可以提出更多，比如 <span class="math inline">\(M\)</span> 中的非零矩阵的秩都不小于 <span class="math inline">\(r\)</span>，这里 <span class="math inline">\(0&lt;r&lt;n\)</span> 是个给定的正整数，那么 <span class="math inline">\(M\)</span> 的维数最大是多少？（答案仍然和Radon-Hurwitz数有关）你可以试着自己提出一些这样的问题，然后尝试给出它们的解答，遇到困难再去查阅资料，相信一定会有收获的。</p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>国际象棋棋盘的多米诺骨牌密铺</title>
      <link href="/Pfaffian-and-chessboard-tiling/"/>
      <url>/Pfaffian-and-chessboard-tiling/</url>
      
        <content type="html"><![CDATA[<p>下面的问题与统计物理中的 Dimer 格点模型有关：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>用 <span class="math inline">\(1\times2\)</span> 的多米诺骨牌密铺一张 <span class="math inline">\(8\times8\)</span>的国际象棋棋盘，有多少种不同的方法？</p></div><p>下图是其中一种：</p><p><img src="/images/pfaff/chessboard.svg" class="fig"></p><p>答案是 12988816，非常大的一个数字，显然不可能是逐个枚举数出来的。1961年德国物理学家 Kasteleyn借助线性代数的工具首先解决了这个问题，本文就来介绍他的方法。</p><span id="more"></span><h1 id="反对称矩阵的-pfaffian">反对称矩阵的 Pfaffian</h1><p>我们从一个线性代数的结论说起，先来看一个 4 阶反对称矩阵的行列式：</p><p><span class="math display">\[\det\begin{pmatrix}0&amp;a_{12}&amp;a_{13}&amp;a_{14}\\-a_{12}&amp;0&amp;a_{23}&amp;a_{24}\\-a_{13}&amp;-a_{23}&amp;0&amp;a_{34}\\-a_{14}&amp;-a_{24}&amp;-a_{34}&amp;0\end{pmatrix}=(a_{12}a_{34}-a_{13}a_{24}+a_{14}a_{23})^2.\]</span>你发现了什么？这个反对称矩阵的行列式是一个多项式的平方，而且观察右边每个单项式的下标你发现，它们分别是<span class="math inline">\(\{(12),(34)\}\)</span>，<span class="math inline">\(\{(14),(23)\}\)</span>，<span class="math inline">\(\{(13),(24)\}\)</span>，恰好跑遍集合 <span class="math inline">\(\{1,2,3,4\}\)</span> 的所有匹配！</p><p>这个结论不是偶然的，实际上对任何 <span class="math inline">\(2n\)</span> 阶反对称矩阵 <span class="math inline">\(A\)</span>，<span class="math inline">\(A\)</span>的行列式都可以表示为一个多项式的平方，这个多项式叫做 Pfaffian多项式，记作 <span class="math inline">\(\mathrm{pf}(A)\)</span>。<span class="math inline">\(\mathrm{pf}(A)\)</span> 中的单项式与集合 <span class="math inline">\([2n]=\{1,2,\ldots,2n\}\)</span>的匹配一一对应。</p><p>那么奇数阶反对称矩阵呢？它们的行列式都是 0，所以不考虑它们。</p><p>我们来给出 <span class="math inline">\(\mathrm{pf}(A)\)</span>的定义：考虑一种把 <span class="math inline">\([2n]\)</span>两两配对（从而分成 <span class="math inline">\(n\)</span> 对）的方式：<span class="math display">\[\pi =(i_1,j_1)(i_2,j_2)\cdots(i_n,j_n).\]</span> <span class="math inline">\(\pi\)</span> 叫做集合 <span class="math inline">\([2n]\)</span>的一个匹配，它可以用一个置换来表示，仍然记作 <span class="math inline">\(\pi\)</span>： <span class="math display">\[\pi=\begin{pmatrix}1&amp;2&amp;3&amp;4&amp;\cdots&amp;2n-1&amp;2n\\i_1&amp;j_1&amp;i_2&amp;j_2&amp;\cdots&amp;i_n&amp;j_n\end{pmatrix}.\]</span>定义 <span class="math inline">\(\pi\)</span> 的权为 <span class="math display">\[\mathrm{wt}(\pi)=\text{sgn}(\pi)\cdota_\pi.\]</span> 其中 <span class="math inline">\(\text{sgn}(\pi)\)</span> 就是置换 <span class="math inline">\(\pi\)</span> 的符号，偶置换时为 <span class="math inline">\(+1\)</span>，奇置换时为 <span class="math inline">\(-1\)</span>， <span class="math display">\[a_\pi=a_{i_1j_1}a_{i_2j_2}\cdotsa_{i_nj_n}.\]</span> 于是 <span class="math inline">\(\mathrm{wt}(\pi)\)</span> 是一个次数为 <span class="math inline">\(n\)</span> 的单项式。</p><p>但是，<span class="math inline">\(\mathrm{wt}(\pi)\)</span>的定义是合理无歧义的吗？注意一个匹配 <span class="math inline">\(\pi\)</span>可以有多种不同的置换表示：你可以按任意的顺序排列这些 <span class="math inline">\((i_k,j_k)\)</span> 对，或是交换某一对中 <span class="math inline">\(i_k\)</span> 和 <span class="math inline">\(j_k\)</span>的位置。不难验证，这些改变不会影响乘积 <span class="math inline">\(\mathrm{wt}(\pi)\)</span>。比如把某个 <span class="math inline">\((i_k,j_k)\)</span> 改写成 <span class="math inline">\((j_k,i_k)\)</span>，那么 <span class="math inline">\(\text{sgn}(\pi)\)</span> 和 <span class="math inline">\(a_\pi\)</span> 都同时变号，乘积不变。总之 <span class="math inline">\(\mathrm{wt}(\pi)\)</span> 的定义只与匹配 <span class="math inline">\(\pi\)</span> 有关，并不依赖于具体置换的选择。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(\mathcal{M}_{2n}\)</span> 为 <span class="math inline">\([2n]\)</span> 的所有匹配组成的集合，矩阵 <span class="math inline">\(A\)</span> 的 Pfaffian 多项式 <span class="math inline">\(\text{pf}(A)\)</span> 定义为 <span class="math display">\[\text{pf}(A) =\sum_{\pi\in\mathcal{M}_{2n}}\mathrm{wt}(\pi).\]</span></p></div><p>现在我们可以叙述本节的主要结论了：</p><div id="pfaff" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(2n\)</span> 阶反对称矩阵，则 <span class="math inline">\(\det A=[\text{pf}(A)]^2\)</span>。</p></div><p><strong>证明</strong>：根据行列式的定义， <span class="math display">\[\det A=\sum_{\sigma\inS_{2n}}\text{sgn}(\sigma)a_{\sigma}=\sum_{\sigma\inS_{2n}}\text{sgn}(\sigma) a_{1\sigma(1)}a_{2\sigma(2)}\cdots.\]</span></p><p>回忆任何置换 <span class="math inline">\(\sigma\)</span>都可以表示为若干不相交的轮换的乘积： <span class="math display">\[\sigma= (i_1i_2\cdots i_k)(j_1j_2\cdots j_l)\cdots.\]</span> 设 <span class="math inline">\(\mathcal{E}_{2n}\)</span> 为所有轮换的长度 <span class="math inline">\(k,l,\cdots\)</span>都是偶数的那些置换组成的集合，我们要证明在上述行列式的求和中，<span class="math inline">\(\sigma\)</span> 只跑遍 <span class="math inline">\(\mathcal{E}_{2n}\)</span>，不属于 <span class="math inline">\(\mathcal{E}_{2n}\)</span>的那些置换整体对行列式的贡献为 0。</p><p>分两种情况：</p><ol type="1"><li>如果 <span class="math inline">\(\sigma\)</span>包含一个不动点：<span class="math inline">\(\sigma(i)=i\)</span>，则由于<span class="math inline">\(a_{i\sigma(i)}=0\)</span> 从而 <span class="math inline">\(\sigma\)</span> 对行列式的贡献为 0。</li><li>如果 <span class="math inline">\(\sigma\)</span>没有不动点，但是包含长度为奇数的轮换，选择其中含有最小元素的那个，设为<span class="math inline">\(C=(i_1i_2\cdots i_k)\)</span>，这里 <span class="math inline">\(k\)</span> 为奇数且大于等于 3。定义置换 <span class="math inline">\(\sigma'\)</span> 如下：<span class="math inline">\(\sigma'\)</span> 的其它轮换与 <span class="math inline">\(\sigma\)</span> 完全相同，只是把 <span class="math inline">\(C\)</span> 整个倒过来变成 <span class="math inline">\((i_k\cdots i_2i_1)\)</span>。显然 <span class="math inline">\(\sigma'\)</span> 对应的和项与 <span class="math inline">\(\sigma\)</span> 抵消，而且如果对 <span class="math inline">\(\sigma'\)</span> 执行此操作又会回到 <span class="math inline">\(\sigma\)</span>。于是所有没有不动点，而且包含长度是奇数的轮换的置换可以两两配对抵消。</li></ol><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span><span class="math inline">\(\sigma=(1\,3)(2\,4\,6)(5\,7\,8)(9\,10)\)</span> 有2 个长度为奇数的轮换 <span class="math inline">\((246)\)</span> 和 <span class="math inline">\((578)\)</span>，最小的元素 <span class="math inline">\(2\)</span> 出现在 <span class="math inline">\((2\,4\,6)\)</span> 中，所以 <span class="math inline">\(\sigma'=(1\,3)(6\,4\,2)(5\,7\,8)(9\,10)\)</span>。</p></div><p>这就证明了在行列式的求和中，<span class="math inline">\(\sigma\)</span>只跑遍那些轮换分解长度都是偶数的置换。</p><p>于是为了证明 <span class="math inline">\(\det A=[{\rmpf}(A)]^2\)</span>，只要证明 <span class="math display">\[\sum_{\pi\in\mathcal{M}_{2n}}\sum_{\pi'\in\mathcal{M}_{2n}}{\rmwt}(\pi){\rm wt}(\pi')=\sum_{\sigma\in\mathcal{E}_{2n}}{\rmsgn}(\sigma) a_\sigma.\]</span></p><p>为此我们来证明存在双射 <span class="math display">\[\mathcal{M}_{2n}\times\mathcal{M}_{2n}\rightarrow \mathcal{E}_{2n}:\quad(\pi,\pi')\rightarrow \sigma.\]</span>而且这个双射还保持权的相等，即 <span class="math display">\[\mathrm{wt}(\pi)\cdot\mathrm{wt}(\pi')=\text{sgn}(\sigma)a_{\sigma}.\]</span>这样就证明了定理。</p><p>对任何两个匹配 <span class="math inline">\((\pi,\pi')\in\mathcal{M}_{2n}\times\mathcal{M}_{2n}\)</span>，我们把它俩画在同一张图上，图的顶点集合就是<span class="math inline">\([2n]\)</span>，<span class="math inline">\(\pi\)</span> 的边染成红色，<span class="math inline">\(\pi'\)</span> 的边染成蓝色。这样得到一个 2-正则图，每个顶点恰有一条红色和一条蓝边与之相邻。这个图一定可以表示为若干条不相交的回路的并<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，在每个回路中，红蓝边交错出现，因此每个回路的长度都是偶数。</p><p>设 <span class="math inline">\(C\)</span> 是这样的一条回路，<span class="math inline">\(i_1\)</span> 是 <span class="math inline">\(C\)</span> 中最小的元素，从 <span class="math inline">\(i_1\)</span> 出发，沿着红色的边，即 <span class="math inline">\(\pi\)</span> 的方向绕 <span class="math inline">\(C\)</span> 一圈： <span class="math display">\[i_1\,{\color{red}{\xrightarrow{\pi}}}\,i_2\,{\color{blue}{\xrightarrow{\pi'}}}\,i_3\,{\color{red}{\xrightarrow{\pi}}}\,\cdots\,{\color{blue}{\xrightarrow{\pi'}}}\,i_1.\]</span>这样得到了一个轮换 <span class="math inline">\((i_1i_2\cdotsi_k)\)</span>。对每个回路都这样做，我们就得到了一组轮换，与 <span class="math inline">\((\pi,\pi')\)</span> 对应的置换 <span class="math inline">\(\sigma\)</span>就定义为所有这些轮换的乘积。由于这些回路互不相交，这些轮换两两交换，所以我们不必关心它们相乘的顺序，任何顺序都给出同样的<span class="math inline">\(\sigma\)</span>。</p><p>逆映射也很显然，对任何 <span class="math inline">\(\sigma\in\mathcal{E}_{2n}\)</span>，在 <span class="math inline">\(\sigma\)</span> 的每个轮换 <span class="math inline">\(C\)</span> 中，找到最小的 <span class="math inline">\(i_1\in C\)</span>，设 <span class="math inline">\(C=(i_1i_2\cdots i_k)\)</span>，那么依次规定 <span class="math display">\[i_1\,{\color{red}{\xrightarrow{\pi}}}\,i_2\,{\color{blue}{\xrightarrow{\pi'}}}\,i_3\,{\color{red}{\xrightarrow{\pi}}}\,\cdots\,{\color{blue}{\xrightarrow{\pi'}}}\,i_1.\]</span>即可。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>下面是将 <span class="math inline">\(2n=12\)</span>，<span class="math inline">\(\sigma=(1\,3\,4\,5\,7\,10)(2\,6\,9\,8)(11\,12)\)</span>对应到两个匹配 <span class="math inline">\(\pi,\pi'\)</span>的示意图：</p><p><img src="/images/pfaff/matching.svg" class="fig" width="500"></p></div><p>最后我们来验证这个对应保持权的相等：设 <span class="math inline">\(\sigma\)</span> 的轮换分解式为 <span class="math display">\[\sigma=(i_1i_2\cdots i_{2k-1}i_{2k})(j_1j_2\cdotsj_{2l-1}j_{2l})\cdots.\]</span> 其中 <span class="math inline">\(i_1,j_1,\ldots\)</span>是每个轮换中最小的元素。于是 <span class="math display">\[\pi=\begin{pmatrix}1&amp;2&amp;\cdots&amp;2k-1&amp;2k&amp;2k+1&amp;2k+2&amp;\cdots\\i_1&amp;i_2&amp;\cdots&amp;i_{2k-1}&amp;i_{2k}&amp;j_1&amp;j_2&amp;\cdots\end{pmatrix}.\]</span><span class="math display">\[\pi'=\begin{pmatrix}1&amp;2&amp;\cdots&amp;2k-1&amp;2k&amp;2k+1&amp;2k+2&amp;\cdots\\i_2&amp;i_3&amp;\cdots&amp;i_{2k}&amp;i_1&amp;j_2&amp;j_3&amp;\cdots\end{pmatrix}.\]</span></p><p>容易验证 <span class="math inline">\(a_\pia_{\pi'}=a_\sigma\)</span> 以及 <span class="math inline">\(\pi'=\sigma\cdot\pi\)</span>，从而 <a href="#pfaff" title="定理 1.1">定理 1.1</a> 得证。</p><h1 id="平面图的-pfaffian-定向">平面图的 Pfaffian 定向</h1><p>Pfaffian 多项式的结论启发我们可以用它来计算一个图 <span class="math inline">\(G\)</span> 的所有匹配的个数。</p><p>设 <span class="math inline">\(G\)</span> 有 <span class="math inline">\(2n\)</span> 个顶点。首先给 <span class="math inline">\(G\)</span> 的边任意定向，得到一个简单有向图 <span class="math inline">\(\overrightarrow{G}\)</span>。写出 <span class="math inline">\(\overrightarrow{G}\)</span> 的邻接矩阵 <span class="math inline">\(A=(a_{ij})\)</span>：</p><p><span class="math display">\[a_{ij}=\begin{cases}1&amp; i\rightarrowj,\\-1&amp; j\rightarrow i,\\ 0&amp;\text{else}.\end{cases}\]</span></p><p>则 <span class="math inline">\(A\)</span> 是一个反对称矩阵且</p><p><span class="math display">\[\detA=\left(\sum_{\pi\in\mathcal{M}_{2n}}\mathrm{wt}(\pi)\right)^2=\left(\sum_{\pi\in\mathcal{M}_{2n}}\text{sgn}(\pi)a_{i_1j_1}a_{i_2j_2}\cdotsa_{i_nj_n}\right)^2.\]</span></p><p>这里 <span class="math inline">\(\pi=(i_1,j_1)(i_2,j_2)\cdots(i_n,j_n)\)</span>跑遍集合 <span class="math inline">\([2n]\)</span> 的所有匹配。由于每个<span class="math inline">\(a_{ij}\)</span> 的取值是 <span class="math inline">\(\pm1\)</span> 或者 <span class="math inline">\(0\)</span>，所以 <span class="math inline">\(\mathrm{wt}(\pi)\)</span> 的值也是 <span class="math inline">\(\pm1\)</span> 或者 <span class="math inline">\(0\)</span>，并且 <span class="math inline">\(\mathrm{wt}(\pi)\ne0\)</span> 当且仅当对每个 <span class="math inline">\(1\leq k\leq n\)</span>，<span class="math inline">\(i_k\)</span> 和 <span class="math inline">\(j_k\)</span> 在 <span class="math inline">\(G\)</span> 中是相邻的，即 <span class="math inline">\(\pi\)</span> 给出 <span class="math inline">\(G\)</span> 的一个匹配。于是 <span class="math inline">\(G\)</span> 的所有匹配与 <span class="math inline">\(\mathrm{pf}(A)\)</span>中的非零项一一对应。不幸的是，这些非零项有 +1 有-1，把它们直接加起来得到的可不是 <span class="math inline">\(G\)</span>的所有匹配的个数。但是我们可以这样想： 能否通过适当的定向 <span class="math inline">\(G\)</span>，即适当给 <span class="math inline">\(a_{ij}\)</span> 赋以 +1 或者 -1，使得每一个非零的<span class="math inline">\(\mathrm{wt}(\pi)\)</span> 都同为 +1 或者同为-1？如果可以，那么<span class="math inline">\(\sqrt{|\det A|}\)</span>就是要求的匹配的个数。</p><p>回忆在证明 <a href="#pfaff" title="定理 1.1">定理 1.1</a>时，我们有结论 <span class="math display">\[\mathrm{wt}(\pi)\cdot\mathrm{wt}(\pi')=\text{sgn}(\sigma)a_{\sigma}.\]</span>要使得所有非零的 <span class="math inline">\(\mathrm{wt}(\pi)\)</span>都同为 +1 或者同为 -1，只要让每个非零的 <span class="math inline">\(\text{sgn}(\sigma)a_{\sigma}\)</span> 都等于 1即可。设 <span class="math inline">\(\sigma\)</span> 是一个使得 <span class="math inline">\(a_\sigma\ne0\)</span> 的置换且 <span class="math inline">\(\sigma\)</span> 的轮换分解为 <span class="math inline">\(\sigma=C_1\cdots C_l\)</span>，这里每个 <span class="math inline">\(C_i\)</span> 的长度都是偶数，则 <span class="math display">\[\text{sgn}(\sigma)=(-1)^l,\quada_\sigma=a_{C_1}\cdots a_{C_l}.\]</span> 这里规定 <span class="math inline">\(C_i=(i_1i_2\cdots i_k)\)</span> 时 <span class="math inline">\(a_{C_i}=a_{i_1i_2}\cdotsa_{i_ki_1}\)</span>。如果我们能够使得每个 <span class="math inline">\(a_{C_i}=-1\)</span>，那么就有 <span class="math display">\[\text{sgn}(\sigma)\cdot a_\sigma = (-1)^l\cdot(-1)^l=1.\]</span> 而 <span class="math inline">\(a_{C_i}\)</span> 等于-1 意味着，当在 <span class="math inline">\(\overrightarrow{G}\)</span>中沿着回路 <span class="math display">\[i_1\rightarrow i_2\rightarrow\cdots \rightarrow i_k\rightarrow i_1\]</span> 绕 <span class="math inline">\(C_i\)</span> 一圈时，有奇数条边在与 <span class="math inline">\(\overrightarrow{G}\)</span>的定向一致（由于轮换长度 <span class="math inline">\(k\)</span>是偶数，这也等价于有奇数条边与 <span class="math inline">\(\overrightarrow{G}\)</span> 的定向相反）。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(G\)</span> 是有限图。如果 <span class="math inline">\(G\)</span> 的一个回路 <span class="math inline">\(C\)</span> 的长度是偶数，且删除 <span class="math inline">\(C\)</span> 后剩下的部分仍然存在匹配，就称 <span class="math inline">\(C\)</span> 是一个好的回路。如果 <span class="math inline">\(G\)</span> 的一个定向 <span class="math inline">\(\overrightarrow{G}\)</span> 使得 <span class="math inline">\(G\)</span>的所有好的回路都是奇定向的，即沿着回路的任一方向行走都有奇数条边的定向与行走方向一致，就称<span class="math inline">\(\overrightarrow{G}\)</span> 是一个 Pfaffian定向。</p></div><p>对一般的图，找到其 Pfaffian定向是困难的事，但是对平面图却很简单。这就是下面的定理：</p><div id="Kasteleyn" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span> <span class="statement-info">(Kasteleyn)</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(G\)</span>是一个简单平面图，则可以给 <span class="math inline">\(G\)</span>的边适当定向，使得当逆时针沿着 <span class="math inline">\(G\)</span>的每个面行走时（外部的无穷区域不算），都有奇数条边与行走方向一致，这种定向就是<span class="math inline">\(G\)</span> 的 Pfaffian 定向。</p></div><p><strong>证明</strong>：我们首先说明存在这样的定向，使得 <span class="math inline">\(G\)</span>的每个面都是奇定向的。对面的个数归纳：<span class="math inline">\(f=0\)</span>，则 <span class="math inline">\(G\)</span> 是一个树，任何定向都是 Pfaffian定向。设结论对有 <span class="math inline">\(f-1\)</span>个面的简单有向图成立，对有 <span class="math inline">\(f&gt;1\)</span>个面的图 <span class="math inline">\(G\)</span>，找到一条内部面与外部区域相邻的边 <span class="math inline">\(e\)</span>，删去 <span class="math inline">\(e\)</span> 得到的是一个有 <span class="math inline">\(f-1\)</span>个面的有向图，由归纳假设，可以让每个面都是奇定向，然后把 <span class="math inline">\(e\)</span> 补回去，并适当在 <span class="math inline">\(e\)</span>的两种可能的定向中选择一个使得最后这个面也是奇定向的即可。</p><p>其次我们要说明这样的定向是 Pfaffian 定向，即对 <span class="math inline">\(G\)</span> 中任意好的回路 <span class="math inline">\(C\)</span>，当绕着 <span class="math inline">\(C\)</span>的内部逆时针行走一圈时，有奇数条边的定向与行走方向一致。</p><p>设 <span class="math inline">\(C\)</span> 长度为 <span class="math inline">\(l\)</span>，<span class="math inline">\(C\)</span>内部有 <span class="math inline">\(p\)</span> 个顶点，<span class="math inline">\(q\)</span> 条边，<span class="math inline">\(r\)</span> 个面，<span class="math inline">\(C\)</span> 上逆时针定向的边的个数为 <span class="math inline">\(c\)</span>，内部的第 <span class="math inline">\(i\)</span> 个面 (<span class="math inline">\(1\leqi\leq r\)</span>) 上逆时针定向的边的个数为 <span class="math inline">\(c_i\)</span>。</p><p>绕着所有面都逆时针走一圈，遇到的与行走方向定向相同的边的个数是 <span class="math inline">\(\sum\limits_{i=1}^rc_i=c+q\)</span>，这是因为<span class="math inline">\(C\)</span> 内部的 <span class="math inline">\(q\)</span>条边都被走了两次，一次逆时针，一次顺时针，因此都被计算了一次；而 <span class="math inline">\(C\)</span> 上的边只有逆时针定向的那些边（一共有<span class="math inline">\(c\)</span> 条）被计算了一次。</p><p>由于每个 <span class="math inline">\(c_i\)</span> 都是奇数，因此<span class="math display">\[r\equiv c+q\ (\text{mod}\ 2).\]</span></p><p>另一方面对 <span class="math inline">\(C\)</span> 包含的区域用 Euler定理，得到 <span class="math display">\[(p+l)-(q+l)+r=1.\]</span> 从而<span class="math inline">\(p\)</span> 与 <span class="math inline">\(c\)</span> 奇偶性相反，但是 <span class="math inline">\(p\)</span> 是偶数，这是因为删去 <span class="math inline">\(C\)</span> 以后仍然存在匹配说明 <span class="math inline">\(C\)</span> 的内部和外部各有偶数个顶点，因此 <span class="math inline">\(c\)</span> 是奇数，这就证明了定理。</p><h1 id="棋盘的多米诺骨牌密铺的计数">棋盘的多米诺骨牌密铺的计数</h1><p>回到文章开始的问题。</p><p>设棋盘的大小为 <span class="math inline">\(m\times n\)</span>，<span class="math inline">\(m\)</span> 是行数。这里 <span class="math inline">\(m,n\)</span>必须至少有一个是偶数，我们这里假定列数 <span class="math inline">\(n\)</span> 是偶数。</p><p>把棋盘的每个方格看作图 <span class="math inline">\(G\)</span>的顶点，两个方格对应的顶点 <span class="math inline">\(u,v\)</span> 在<span class="math inline">\(G\)</span>中相邻当且仅当它们有公共的边，这样就得到一个有 <span class="math inline">\(mn\)</span> 个顶点的平面图。棋盘的多米诺密铺与<span class="math inline">\(G\)</span>的完美匹配是一一对应的：密铺中的每个骨牌恰好盖住两个相邻的方格，这两个方格匹配在了一起。</p><p>为了求出 <span class="math inline">\(G\)</span>的完美匹配个数，只要标记出 <span class="math inline">\(G\)</span> 的一个Pfaffian 定向，写出对应的邻接矩阵，然后求出行列式，再开平方即可。</p><p>Pfaffian 定向是很容易找的，如下图所示：</p><figure><img src="/images/pfaff/pfaff.svg" width="300" alt="m\times n 网格图的 Pfaffian 定向"><figcaption aria-hidden="true"><span class="math inline">\(m\timesn\)</span> 网格图的 Pfaffian 定向</figcaption></figure><p>下一步是写出这个定向图的邻接矩阵。我们按照从第一行开始，每一行从左到右的顺序给顶点排序。设<span class="math display">\[B_n=\begin{pmatrix}0&amp;1&amp;0&amp;&amp;\\-1&amp;0&amp;1&amp;&amp;\\&amp;-1&amp;0&amp;1&amp;\\&amp;&amp;&amp;\ddots&amp;1\\&amp;&amp;&amp;-1&amp;0\end{pmatrix}_{n\timesn}.\]</span> 则邻接矩阵为 <span class="math display">\[L(m,n)=\begin{pmatrix}B_n&amp;I_n&amp;&amp;&amp;\\-I_n&amp;-B_n&amp;I_n&amp;&amp;\\&amp;-I_n&amp;B_n&amp;&amp;\\&amp;&amp;&amp;\ddots&amp;I_n\\&amp;&amp;&amp;-I_n&amp;(-1)^{m-1}B_n\end{pmatrix}_{m\timesm}.\]</span></p><p>我把求邻接矩阵的详细过程放在后面的附录中。下面先来求 <span class="math inline">\(L(m,n)\)</span> 的行列式。</p><p>适当给 <span class="math inline">\(L(m,n)\)</span>的行列变号，可以得到 <span class="math display">\[\det L(m,n)=\det(B_n\otimes I_m-I_n\otimes C_m).\]</span> 其中 <span class="math display">\[C_m=\begin{pmatrix}0&amp;1&amp;0&amp;&amp;\\1&amp;0&amp;1&amp;&amp;\\&amp;1&amp;0&amp;1&amp;\\&amp;&amp;&amp;\ddots&amp;1\\&amp;&amp;&amp;1&amp;0\end{pmatrix}_{m\timesm}.\]</span> 这个变号步骤并不显然，我们需要选择 <span class="math inline">\(L(m,n)\)</span> 的一些行列变号，使得对角线上的每个<span class="math inline">\(-B_n\)</span> 所在的行列恰好有一次变号，每个<span class="math inline">\(B_n\)</span>所在的行列要变号两次，要么不变。具体规则是这样的：由于 <span class="math inline">\(-B_n\)</span> 出现在 <span class="math inline">\(L(m,n)\)</span> 对角线上的 <span class="math inline">\(2,4,6,\ldots,\)</span> 位置上，我们选择：</p><ol type="1"><li>将所有形如 <span class="math inline">\(4k+2\)</span>的<strong>列</strong>变号；</li><li>将所有形如 <span class="math inline">\(4k\)</span>的<strong>行</strong>变号；</li><li>将所有形如 <span class="math inline">\(4k+3\)</span>的<strong>行和列</strong>同时变号；</li></ol><p>这样显然可以把对角线上都变成 <span class="math inline">\(B_n\)</span>。对每个位于次对角线上 <span class="math inline">\((i-1, i)\)</span> 位置的 <span class="math inline">\(I_n\)</span>，</p><ul><li>如果 <span class="math inline">\(i=4k+2\)</span>，则 <span class="math inline">\((i-1,i)=(4k+1, 4k+2)\)</span>，根据 1它改变了一次符号；</li><li>如果 <span class="math inline">\(i=4k\)</span>，则 <span class="math inline">\((i-1,i)=(4k-1, 4k)\)</span>，根据 2, 3它改变了三次符号；</li><li>如果 <span class="math inline">\(i=4k+1\)</span>，则 <span class="math inline">\((i-1,i)=(4k, 4k+1)\)</span>，根据 2它改变了一次符号；</li><li>如果 <span class="math inline">\(i=4k+3\)</span>，则 <span class="math inline">\((i-1,i)=(4k+2, 4k+3)\)</span>，根据 1, 3它改变了三次符号。</li></ul><p>总之 <span class="math inline">\(I_n\)</span> 都会变成 <span class="math inline">\(-I_n\)</span>。类似地所有 <span class="math inline">\(-I_n\)</span> 均保持不变。</p><p>剩下的就是线性代数中求特征值的部分，需要一些关于矩阵张量积的知识，这里就不展开写了，大致逻辑是这样的：设<span class="math inline">\(B_n\)</span> 的特征值为 <span class="math inline">\(\lambda_1,\ldots,\lambda_n\)</span>，<span class="math inline">\(C_m\)</span> 的特征值为 <span class="math inline">\(\mu_1,\ldots,\mu_m\)</span>，则 <span class="math inline">\(B_n\otimes I_m- I_n\otimes C_m\)</span> 的 <span class="math inline">\(mn\)</span> 个特征值为 <span class="math inline">\(\{\lambda_i-\mu_j, 1\leq i\leq n, 1\leq j\leqm\}\)</span>，所以 <span class="math display">\[\det(B_n\otimes I_m-I_n\otimes C_m) = \prod_{i=1}^n\prod_{j=1}^m(\lambda_i-\mu_j).\]</span><span class="math inline">\(B_n\)</span> 和 <span class="math inline">\(C_m\)</span>的特征值的计算应该是线性代数课程中行列式部分的常见的习题，我把具体的计算步骤放在附录中，最终结果是<span class="math display">\[\sqrt{|\det L(m,n)|}=\prod_{k=1}^m\prod_{l=1}^n(4\cos^2\frac{k\pi}{m+1}+4\cos^2\frac{l\pi}{n+1})^{\frac{1}{4}}.\]</span>此即为要求的完美匹配的个数。</p><h1 id="未尽的讨论">未尽的讨论</h1><p>我们已经得到了一个关于 <span class="math inline">\(m\times n\)</span>棋盘的多米诺骨牌密铺的漂亮的表达式，事情可以结束了吗？其实还没有，这个表达式虽然很漂亮，但是我们没法用它来具体计算匹配个数的值（一堆三角函数的乘积怎么算？）。那应该怎么办呢？我把后面的故事留给<span class="citation" data-cites="aigner07">(<a href="#ref-aigner07" role="doc-biblioref">Aigner 2007, sec. 10.1</a>)</span>。</p><h1 id="附录">附录</h1><h2 id="求邻接矩阵-lmn-的具体步骤">求邻接矩阵 <span class="math inline">\(L(m,n)\)</span> 的具体步骤</h2><p>将 <span class="math inline">\(L(m,n)\)</span> 简写为 <span class="math inline">\(L=L(m,n)\)</span>。把网格图 <span class="math inline">\(G\)</span> 的顶点标记如下：</p><p><span class="math display">\[\begin{matrix}(1,1)&amp;(1,2)&amp;\cdots&amp;(1,n)\\(2,1)&amp;(2,2)&amp;\cdots&amp;(2,n)\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\(m,1)&amp;(m,2)&amp;\cdots&amp;(m, n)\end{matrix}\]</span></p><p>对这些顶点排序，首先是第一行从左到右，然后是第二行从左到右，等等：<span class="math display">\[(1,1)&lt;(1,2)&lt;\cdots&lt;(1,n)&lt;(2,1)&lt;\cdots&lt;(2,n)&lt;\cdots&lt;(m,1)&lt;\cdots&lt;(m,n).\]</span></p><p><span class="math inline">\(L\)</span> 是 <span class="math inline">\(mn\times mn\)</span> 阶矩阵，它的行和列分别由<span class="math inline">\((i,j)_{\begin{smallmatrix}1\leq i\leqm\\1\leq j\leq n\end{smallmatrix}}\)</span> 和 <span class="math inline">\((i',j')_{\begin{smallmatrix}1\leqi'\leq m\\1\leq j'\leq n\end{smallmatrix}}\)</span> 标记。<span class="math inline">\(L\)</span> 可以划分成 <span class="math inline">\(m\times m\)</span> 个子块，每个子块是 <span class="math inline">\(n\times n\)</span> 阶的，其中位于 <span class="math inline">\((i,i')\)</span> 处的子块对应的矩阵是 <span class="math inline">\((L_{(i,j)(i',j')})_{1\leq j,j'\leqn}\)</span>： <span class="math display">\[\begin{array}{c|c|c}&amp;(i',1), \cdots,(i',j'),\cdots, (i',n)&amp;\\ &amp;\hline&amp;\qquad\\(i,1)&amp;&amp;\\\vdots&amp;&amp;\\(i,j)&amp;\ast&amp;\\\vdots&amp;&amp;\\(i,n)&amp;&amp;\\&amp;\hline&amp;\qquad\\ &amp;&amp;\end{array}\]</span></p><p>注意到 <span class="math inline">\((i,j)\)</span> 和 <span class="math inline">\((i',j')\)</span>之间有边相连当且仅当：</p><ol type="1"><li><span class="math inline">\(i=i'\)</span> 且 <span class="math inline">\(j'=j\pm1\)</span>；</li><li><span class="math inline">\(i'=i\pm1\)</span> 且 <span class="math inline">\(j=j'\)</span>。</li></ol><p>这说明 <span class="math inline">\(L\)</span>在除去对角线以及两侧的次对角线以外的位置都是 0。</p><p>在情形 1 中，由于水平的边（红色和绿色）是交替改变方向的，所以 <span class="math display">\[L_{(i,j)(i,j+1)} = (-1)^{i-1} \text{ for } 1\leqi\leq m \text{ and } 1\leq j\leq n-1.\]</span> 这说明 <span class="math inline">\(L\)</span> 对角线上的第 <span class="math inline">\(i\)</span> 个子块是 <span class="math inline">\((-1)^{i-1}B_n\)</span>，其中 <span class="math display">\[B_n=\begin{pmatrix}0&amp;1&amp;0&amp;&amp;\\-1&amp;0&amp;1&amp;&amp;\\&amp;-1&amp;0&amp;1&amp;\\&amp;&amp;&amp;\ddots&amp;1\\&amp;&amp;&amp;-1&amp;0\end{pmatrix}_{n\timesn}.\]</span> 即 <span class="math inline">\(L\)</span> 形如 <span class="math display">\[\begin{pmatrix}B_n &amp;\ast&amp;&amp;&amp;\\\ast&amp; -B_n &amp;\ast&amp;&amp;\\&amp;\ast&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\ddots&amp;\ddots&amp; \ast\\&amp;&amp;&amp;\ast&amp;(-1)^{m-1}B_n\end{pmatrix}.\]</span> 在情形 2中，由于竖直的边（蓝色）是恒定向下的，所以 <span class="math display">\[L_{(i,j),(i+1,j)}  = 1  \text{ for } 1\leq i\leqm-1 \text{ and } 1\leq j\leq n.\]</span> 这说明 <span class="math inline">\(L\)</span> 右上方次对角线上的 <span class="math inline">\((i,i+1)\)</span> 位置的子块都是 <span class="math inline">\(I_n\)</span>。再结合 <span class="math inline">\(L\)</span> 是反对称的，下方次对角线上都是 <span class="math inline">\(-I_n\)</span>，所以 <span class="math inline">\(L\)</span> 形如 <span class="math display">\[\begin{pmatrix}B_n &amp;I_n&amp;&amp;&amp;\\-I_n&amp; -B_n &amp;I_n&amp;&amp;\\&amp;-I_n&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\ddots&amp;\ddots&amp; I_n\\&amp;&amp;&amp;-I_n&amp;(-1)^{m-1}B_n\end{pmatrix}.\]</span></p><p>此即为 <span class="math inline">\(G\)</span> 的邻接矩阵。</p><h2 id="求-b_n-和-c_m-的特征值">求 <span class="math inline">\(B_n\)</span> 和 <span class="math inline">\(C_m\)</span> 的特征值</h2><p>我们以 <span class="math display">\[C_m=\begin{pmatrix}0&amp;1&amp;0&amp;&amp;\\1&amp;0&amp;1&amp;&amp;\\&amp;1&amp;0&amp;1&amp;\\&amp;&amp;&amp;\ddots&amp;1\\&amp;&amp;&amp;1&amp;0\end{pmatrix}.\]</span>为例来说明怎样求它的特征值，<span class="math inline">\(B_n\)</span>的求解是类似的。</p><p>我们需要求出其特征多项式</p><p><span class="math display">\[f_m(\lambda) =\det\begin{pmatrix}\lambda&amp;-1&amp;0&amp;&amp;\\-1&amp;\lambda&amp;-1&amp;&amp;\\&amp;-1&amp;\lambda&amp;-1&amp;\\&amp;&amp;&amp;\ddots&amp;-1\\&amp;&amp;&amp;-1&amp;\lambda\end{pmatrix}.\]</span></p><p>按第一行展开可得递推关系</p><p><span class="math display">\[f_m = \lambda f_{m-1} -f_{m-2},\]</span></p><p>结合初始条件 <span class="math inline">\(f_0=1, f_1=\lambda\)</span>（初始条件可以从 <span class="math inline">\(m=2\)</span>的情形展开确定） 可得</p><p><span class="math display">\[f_m(\lambda) =\frac{1}{\sqrt{\lambda^2-4}}\left[\left(\frac{\lambda+\sqrt{\lambda^2-4}}{2}\right)^{m+1}-\left(\frac{\lambda-\sqrt{\lambda^2-4}}{2}\right)^{m+1}\right].\]</span></p><p>由此不难确定 <span class="math inline">\(C_m\)</span> 的 <span class="math inline">\(m\)</span> 个特征值为 <span class="math inline">\(2\cos\dfrac{k\pi}{m+1},k=1,\ldots,m.\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-aigner07" class="csl-entry" role="listitem">Aigner, M. 2007. <em>A Course in Enumeration</em>. Graduate Texts inMathematics. Springer Berlin Heidelberg.</div></div><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>提示：从任一顶点 <span class="math inline">\(x\)</span>出发沿着红边到达顶点 <span class="math inline">\(y\)</span>，再从 <span class="math inline">\(y\)</span> 出发沿着蓝边到达顶点 <span class="math inline">\(z\)</span>，再从 <span class="math inline">\(z\)</span> 出发沿着红边到达顶点 <span class="math inline">\(w\)</span>，这样一直继续下去肯定会回到某个访问过的点，从而形成一个回路。拿掉这个回路以后剩下的图每个顶点的度数仍然是偶数，所以可以继续重复这个过程。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 计数组合学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>平面分拆的 Macmahon 公式</title>
      <link href="/macmahon-formula-plane-partitions/"/>
      <url>/macmahon-formula-plane-partitions/</url>
      
        <content type="html"><![CDATA[<div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>假设你家的浴室地面是一个边长为 <span class="math inline">\(a\times b\times c\)</span> 的平行六边形（<span class="math inline">\(a,b,c\)</span> 都是正整数），每个内角都是 120度。你订购了一批边长为 1的菱形瓷砖用来铺满整个浴室地面。问：有多少种不同的方法？</p><p><img src="/images/macmahon/hexagon.svg" class="fig" width="400"></p></div><p>你可以试着数一数。但你很快就会放弃，因为只要很小的 <span class="math inline">\(a,b,c\)</span> 就可以数到让你怀疑人生。</p><p>下图是一种密铺的示例：</p><p><img src="/images/macmahon/planepartition.svg" class="fig" width="400"></p><span id="more"></span><p>我们观察这张图，想象在空间中鸟瞰它，发现它很像是在墙角“堆箱子”。不仅如此，箱子的堆放方式还满足规律：从墙角开始，沿着两侧墙壁的方向，箱子的高度是递减的。</p><p>我们把可以把这个堆箱子的方式对应到一个 <span class="math inline">\(a\)</span> 行 <span class="math inline">\(b\)</span> 列的矩阵，其中 <span class="math inline">\(a_{ij}\)</span> 表示地面上第 <span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 列位置箱子的高度（习惯上空白位置的 0不写出来）：</p><table><tbody><tr><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p><span class="math inline">\(A\)</span> 有如下特点：</p><blockquote><ul><li><span class="math inline">\(A\)</span>的每一行从左到右，每一列从上到下都是递减的。</li><li><span class="math inline">\(a_{ij}\)</span> 都是介于 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(c\)</span>之间的整数（箱子的高度不能超过天花板的高度 <span class="math inline">\(c\)</span>）。</li></ul></blockquote><p>我们把矩阵 <span class="math inline">\(A\)</span> 叫做一个参数为<span class="math inline">\((a,b,c)\)</span>的受限制的<strong>平面分拆</strong>。</p><p>每个受限制的平面分拆都对应一种堆箱子的方式，从而对应六边形的一个菱形密铺。这个对应是一一的。较真的读者可能会说：“且慢，你这只是从视觉直观上看出来菱形密铺和堆箱子是一一对应的，这不够严格吧？”没错，严格的证明是可以有的，但是这里我们的目的是欣赏一处数学奇趣，不必搞得那么学究。</p><p>总之，我们把开头的密铺问题转化为平面分拆的计数问题：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>满足如下两个条件的 <span class="math inline">\(a\)</span> 行 <span class="math inline">\(b\)</span> 列矩阵有多少个？</p><ol type="1"><li>元素都是 <span class="math inline">\([0,c]\)</span>之间的非负整数；</li><li>每一行从左到右，每一列从上到下都是递减的。</li></ol></div><p>设答案为 <span class="math inline">\(M(a,b,c)\)</span>，则我们有一个非常令人吃惊的表达式：</p><div id="macmahon" class="unnumbered statement sta_macmahon___ plain"><p><span class="statement-heading"><span class="statement-label">Macmahon 公式</span>.</span><span class="statement-spah"> </span><br></p><p><span class="math display">\[M(a,b,c)=\prod_{i=1}^a\prod_{j=1}^b\prod_{k=1}^c\frac{i+j+k-1}{i+j+k-2}.\]</span></p></div><p>这不是一个开玩笑的公式——它几乎像是出现在某本炼金术手册里的。居然是一个完美整洁的分数连乘积，给出一个三维堆箱子问题的答案！话说光看这个表达式，你可能根本不会觉得它是一个整数！</p><p>虽然问题看起来很初等，但是答案的复杂暗示我们它并不像看起来那么容易。接下来你会看到，用一个巧妙的方法可以把问题转化为求一个行列式的值。</p><h1 id="不相交的路径组">不相交的路径组</h1><p>我们知道在平面上从原点 <span class="math inline">\((0,0)\)</span>出发，每次向右或者向上移动一个单位的距离，到达点 <span class="math inline">\((b,a)\)</span> 的路径个数是组合数 <span class="math inline">\(\binom{a+b}{b}\)</span>，这样的一条路径叫做 Gauss路径。</p><p>每个平面分拆的矩阵 <span class="math inline">\(A\)</span> 都对应<span class="math inline">\(c\)</span> 条这样的路径，其中第 <span class="math inline">\(k\)</span> 条路径是高度为 <span class="math inline">\(k\,(1\leq k\leq c)\)</span>的那一层的「等高线」：</p><figure><img src="/images/macmahon/paths-on-cubes.svg" class="fig" width="400" alt="我们把每一层都画出来（你也可以想象是洪水上涨时每一层的水痕）："><figcaption aria-hidden="true">我们把每一层都画出来（你也可以想象是洪水上涨时每一层的水痕）：</figcaption></figure><p>我们把这些路径投影到 2D，和矩阵 <span class="math inline">\(A\)</span> 画在一起。从最下方的路径开始，第 <span class="math inline">\(i\)</span> 条路径对应的是矩阵中 <span class="math inline">\(\geq i\)</span> 的那些方格构成的区域的边界：</p><p><img src="/images/macmahon/gauss_path.svg" class="fig" width="500"></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在上图中，我稍微移动了各个路径的位置，使得它们容易在视觉中区分，所以导致看起来它们的起点和终点是不同的。实际上它们都是从<span class="math inline">\((0,0)\)</span> 到 <span class="math inline">\((b,a)\)</span> 的 Gauss 路径。</p></div><p>注意 <span class="math inline">\(A\)</span>的行和列满足递降关系，这个递降关系反映在这 <span class="math inline">\(c\)</span>条路径上就是，对任何两条路径，它们可以有接触点或者重合的边，但彼此不能穿过对方。</p><p>接下来我们做一件小把戏：对每个 <span class="math inline">\(i\)</span>，把第 <span class="math inline">\(i\)</span> 条路径整体往 <span class="math inline">\((-1,1)\)</span> 方向平移 <span class="math inline">\(i-1\)</span>单位。这就让路径们完全不相交了。如下图所示：</p><p><img src="/images/macmahon/nonintersecting_paths.gif" id="nonintersect-anim" class="fig" width="550"></p><p>在平移后，第 <span class="math inline">\(i\)</span> 条路径的起点是<span class="math inline">\(A_i=(1-i,i-1)\)</span>，终点是 <span class="math inline">\(B_i=(b+1-i,a-1+i)\)</span>。我们把这样的 <span class="math inline">\(c\)</span>条路径组成的集合称之为一个不相交的路径组。</p><p>我再强调一次，不相交的路径组是指任何两条路径之间没有公共点，避免一切交叉和接触。</p><p>反过来对每一个这样的不相交的路径组，我们也很容易还原出对应的平面分拆来。</p><p>于是我们的问题又进一步转化为</p><div id="paths-problem" class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{A_i=(1-i,i-1)\}\)</span> 和 <span class="math inline">\(\{B_j=(b+1-j,a-1+j)\}\)</span>是平面上两组顶点集，计算所有不相交路径组 <span class="math inline">\(\mathcal{P}=\{p_i,1\leq i\leq c\}\)</span>的数目，其中 <span class="math inline">\(p_i\)</span> 是从 <span class="math inline">\(A_i\)</span> 出发到 <span class="math inline">\(B_i\)</span> 的 Gauss 路径。</p></div><p>这听起来像是某种城市道路或者管线设计问题。神奇的是，这个计数问题的答案，居然藏在一个行列式中。</p><h1 id="gessel-viennot-的巧妙方法">Gessel-Viennot 的巧妙方法</h1><p>考虑 <span class="math inline">\(c\times c\)</span> 的矩阵 <span class="math inline">\(M\)</span>，其元素 <span class="math inline">\(m_{ij}\)</span> 是从 <span class="math inline">\(A_i\)</span> 出发到达 <span class="math inline">\(B_j\)</span> 的所有 Gauss 路径的数目。注意，现在Gauss 路径不再必须是从 <span class="math inline">\(A_i\)</span> 走到<span class="math inline">\(B_i\)</span>，而是可以走到任何 <span class="math inline">\(B_j\)</span>。由于 <span class="math inline">\(A_i\)</span> 坐标为 <span class="math inline">\((1-i,i-1)\)</span>，<span class="math inline">\(B_j\)</span> 坐标为 <span class="math inline">\((b+1-j,a-1+j)\)</span>，所以 <span class="math display">\[m_{ij}=\binom{a+b}{b+i-j}.\]</span> 其中如果<span class="math inline">\(b+i-j&lt;0\)</span> 则规定 <span class="math inline">\(m_{ij}=0\)</span>。因为这时 <span class="math inline">\(B_j\)</span> 的横坐标在 <span class="math inline">\(A_i\)</span> 的左边，这种 Gauss路径根本不存在。</p><p>现在，奇迹要发生了：</p><div id="gessel-viennot-------" class="unnumbered statement sta_gessel_viennot___ plain"><p><span class="statement-heading"><span class="statement-label">Gessel-Viennot 引理</span>.</span><span class="statement-spah"> </span><br></p><p>记 <span class="math inline">\(\mathcal{A}=\{A_i,1\leq i\leqc\}\)</span> 和 <span class="math inline">\(\mathcal{B}=\{B_j,1\leqj\leq c\}\)</span> 是 <a href="#paths-problem" title="问题中所述">问题中所述</a>的两个顶点集，则所有不相交路径组的个数为 <span class="math display">\[\det M=\det_{1\leq i,j\leqc}\left(\left(\begin{array}{c}a+b\\b+i-j\end{array}\right)\right).\]</span></p></div><p>这个结论乍一看可太不可思议了，行列式的几何意义不是平行多面体的有向体积吗？怎么突然成了计数工具？要揭示这个魔法背后的秘密，我们得先看看上面的行列式真正干了什么。</p><p><strong>证明</strong>：对 <span class="math inline">\(c\)</span>元组上的任一置换 <span class="math inline">\(\sigma\inS_c\)</span>，记路径组 <span class="math inline">\(\mathcal{P}_\sigma=\{p_i:A_i\rightarrowB_{\sigma(i)},1\leq i\leq c\}\)</span>。</p><p>把 <span class="math inline">\(\det M\)</span>按照行列式的定义展开。由于 <span class="math inline">\(m_{i\sigma(i)}\)</span> 是从 <span class="math inline">\(A_i\)</span> 到 <span class="math inline">\(B_{\sigma(i)}\)</span> 的 Gauss 路径的个数，所以<span class="math display">\[m_{i\sigma(i)} = \sum_{p_i:A_i\toB_{\sigma(i)}}1.\]</span> 于是</p><p><span class="math display">\[\begin{aligned}\detM&amp;=\sum_{\sigma}\mathrm{sgn}(\sigma)m_{1\sigma(1)}\cdotsm_{c\sigma(c)}\\&amp;=\sum_{\sigma}\mathrm{sgn}(\sigma)\left(\sum_{p_1:A_1\toB_{\sigma(1)}}1\right)\cdots\left(\sum_{p_c:A_c\toB_{\sigma(c)}}1\right).\end{aligned}\]</span></p><p>其中 <span class="math inline">\(\sigma\)</span> 跑遍对称群 <span class="math inline">\(S_c\)</span>。<span class="math inline">\(\mathrm{sgn}(\sigma)\)</span> 是置换 <span class="math inline">\(\sigma\)</span> 的符号，偶置换时为 <span class="math inline">\(+1\)</span>，奇置换时为 <span class="math inline">\(-1\)</span>。</p><p>我们考虑如下的项：</p><p><span class="math display">\[\left(\sum_{p_1:A_1\toB_{\sigma(1)}}1\right)\cdots\left(\sum_{p_c:A_c\toB_{\sigma(c)}}1\right).\]</span></p><p>把它展开会得到很多个 1，每个 1 对应一个路径组 <span class="math inline">\(\mathcal{P}_\sigma\)</span>，因此</p><p><span class="math display">\[\detM=\sum_{\sigma,\mathcal{P}_\sigma}\text{sgn}(\sigma).\tag{$\ast$}\label{eq:det}\]</span></p><p>这个求和是对每个置换 <span class="math inline">\(\sigma\)</span>，跑遍所有可能的路径组 <span class="math inline">\(P_\sigma\)</span>。<span class="math inline">\(P_\sigma\)</span>可以是相交的路径组，也可以是不相交的路径组。</p><p>奇妙的是，所有那些相交的路径组对应的项最后都会互相抵消，剩下的只有不相交的路径组！</p><p>让我们看看这个抵消是怎么发生的。设 <span class="math inline">\(\mathcal{P}=\mathcal{P}_\sigma\)</span>是一个相交的路径组，我们构造与之抵消的路径组 <span class="math inline">\(\mathcal{P}'\)</span> 如下：</p><ol type="1"><li>在 <span class="math inline">\(\mathcal{P}\)</span>的所有交点中，选择位于最“东北”方向的那一个，将其记作 <span class="math inline">\(C\)</span>。</li><li>选择最大的 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(p_i\)</span> 经过 <span class="math inline">\(C\)</span>，再选择最大的 <span class="math inline">\(j&lt;i\)</span> 使得 <span class="math inline">\(p_j\)</span> 也经过 <span class="math inline">\(C\)</span>。</li><li>交换 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(p_j\)</span> 在 <span class="math inline">\(C\)</span>点之后的部分，保持路径组其它部分不动。记得到的新路径组为 <span class="math inline">\(\mathcal{P}'\)</span>。</li></ol><p>直观上，你可以想象两个人分别从 <span class="math inline">\(A_i\)</span> 和 <span class="math inline">\(A_j\)</span> 出发沿着路径 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(p_j\)</span> 前往目的地 <span class="math inline">\(B_{\sigma(i)}\)</span> 和 <span class="math inline">\(B_{\sigma(j)}\)</span>。当他们到达 <span class="math inline">\(C\)</span>时同时调转路线，沿着对方剩下的路径前往对方的目的地。</p><p><img src="/images/macmahon/gessel_viennot.svg" class="fig" width="550"></p><p>这个新路径组 <span class="math inline">\(\mathcal{P}'\)</span>对应的置换 <span class="math inline">\(\sigma'\)</span> 与 <span class="math inline">\(\sigma\)</span> 相差一个对换 <span class="math inline">\((ij)\)</span>，因此 <span class="math inline">\(\mathrm{sgn}(\sigma')=-\mathrm{sgn}(\sigma)\)</span>。不仅如此，如果对<span class="math inline">\(\mathcal{P}'\)</span>也按照上述规则寻找与之抵消的路径组的话，找到的路径仍然是 <span class="math inline">\(\mathcal{P}\)</span>，这就构成了一个漂亮的“湮灭配对”：相交的路径组成对出现，符号相反，相加为零。</p><p>于是我们可以把 <span class="math inline">\((\ref{eq:det})\)</span>改写为 <span class="math display">\[\detM=\sum_{\sigma,\,\mathcal{P}_\sigma \text{non-intersecting}}\mathrm{sgn}(\sigma).\]</span></p><p>但是注意，不相交的路径组只有在 <span class="math inline">\(\sigma=1\)</span> 时才可能发生，即每个 <span class="math inline">\(A_i\)</span> 的目的地必须是 <span class="math inline">\(B_i\)</span>。你可以很容易从前面的图中看出来。所以我们进一步得到<span class="math display">\[\det M=\sum_{\sigma=1\text{ and } \mathcal{P}_\sigma \text{non-intersecting}}1.\]</span> 这正是所求的不相交路径组的个数。<span class="math inline">\(\blacksquare\)</span></p><h1 id="dodgsons-condensation-method">Dodgson’s condensation method</h1><p>为了求出行列式的值，我们介绍一个古老的方法：Dodgson’scondensation。这是一个递归求解行列式的方法：设 <span class="math inline">\(A\)</span> 是一个 <span class="math inline">\(n\times n\)</span> 矩阵，用 <span class="math inline">\(A_i^j\)</span> 表示删去 <span class="math inline">\(A\)</span> 的第 <span class="math inline">\(i\)</span> 行和第 <span class="math inline">\(j\)</span> 列后剩下的 <span class="math inline">\(n-1\)</span> 阶矩阵，用 <span class="math inline">\(A_{1,n}^{1,n}\)</span> 表示删去 <span class="math inline">\(A\)</span> 的第 1 行第 1 列和第 <span class="math inline">\(n\)</span> 行第 <span class="math inline">\(n\)</span> 列后剩下的 <span class="math inline">\(n-2\)</span> 阶矩阵，则我们有恒等式</p><p><span class="math display">\[\det A\cdot \det A_{1,n}^{1,n}=\detA_1^1\det A_n^n-\det A_1^n\det A_n^1.\]</span></p><p>用一个形象的图片描述：</p><p><img src="/../images/macmahon/dodgson.svg" class="fig" width="450"></p><p>这个结论的证明不难，可以见 <a href="http://en.wikipedia.org/wiki/Dodgson_condensation">维基百科</a>，这里就不再写了。</p><p>我们对 <span class="math inline">\(c\)</span> 归纳来证明</p><div id="macmahon-thm" class="unnumbered statement sta_macmahon___-1 plain"><p><span class="statement-heading"><span class="statement-label">Macmahon 公式</span>.</span><span class="statement-spah"> </span><br></p><p><span class="math display">\[\det_{1\leq i,j\leqc}\left(\left(\begin{array}{c}a+b\\b+i-j\end{array}\right)\right)=\prod_{i=1}^a\prod_{j=1}^b\prod_{k=1}^c\frac{i+j+k-1}{i+j+k-2}.\]</span></p></div><p>首先你需要对 <span class="math inline">\(c=1\)</span> 和 <span class="math inline">\(c=2\)</span> 的情形手算验证（略繁琐，不过只是一个2 阶矩阵），设 <span class="math inline">\(M_c(a, b)\)</span>为所求的行列式，注意到</p><p><span class="math display">\[\begin{cases}(M_c(a,b))_1^1=M_{c-1}(a,b),\\(M_c(a,b))_n^n=M_{c-1}(a,b),\\(M_c(a,b))_1^n=M_{c-1}(a-1,b+1),\\(M_c(a,b))_n^1=M_{c-1}(a+1,b-1),\\(M_c(a,b))^{1,n}_{1,n}=M_{c-2}(a,b).\end{cases}\]</span></p><p>然后应用归纳假设即可。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>问题的 <span class="math inline">\(q-\)</span> 计数版本也可以用Gessel-Viennot 引理来做，只是行列式的求值略复杂。其实也可以用 <a href="https://arxiv.org/abs/math/9902004">Krattenthaler 公式</a>来计算，不过那个方法不是我们要讲的。</p></div><h1 id="番外话">番外话</h1><p>说点八卦的东西。Dodgson 是 19世纪的英国数学家，细心点的读者可能注意到这位老兄的名字实在让人不敢恭维：Dodgson,dog…son？大概他也知道自己的名字难登大雅之堂，所以他给自己取了一个很好听的笔名：LewisCarroll（路易斯·卡罗尔）。</p><p>你对这个名字没有印象么？那好，我们继续说说他的轶事。这位老兄虽然名字略俗，受过的教育可不含糊，是牛津大学的数学教授，也算上层社会体面人物，但是按照今天的话说，是个不折不扣的怪蜀黍，对萝莉有着特别的喜爱，尤其喜爱给她们拍裸照，所以后人基本认定他是一个恋童癖大叔。他曾经专门为邻居家的女儿写了一部童话来哄她开心，这就是大名鼎鼎的《爱丽斯漫游奇境记》。虽然创作动机不纯，但是这部童话非常精彩，以至于当时的英国女王都变成了他的粉丝。女王命令手下的大臣把Dodgson的全部著作都搜集呈上来，于是大臣献上了一本厚厚的《符号逻辑》，当然结果你猜得到的…</p><p>时光一转到了 20 世纪 80 年代，三位数学家 William Mills，David Robbins和 Howard Rumsey 在研究计算行列式的快速数值算法时，受 Dodgson算法的启发，发现了交错符号矩阵猜想。这是计数组合学里面最精彩的猜想之一。我向你推荐Bressoud 的书 <span class="citation" data-cites="Bressoud1999">(<a href="#ref-Bressoud1999" role="doc-biblioref">Bressoud1999</a>)</span>，我保证里面的故事和《爱丽丝漫游奇境记》一样奇妙 …</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Bressoud1999" class="csl-entry" role="listitem">Bressoud, David M. 1999. <em>Proofs and Confirmations: The Story of theAlternating-Sign Matrix Conjecture</em>. Spectrum. Cambridge UniversityPress.</div></div>]]></content>
      
      
      <categories>
          
          <category> 计数组合学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Aztec 钻石图的完美匹配与多米诺洗牌算法</title>
      <link href="/domino-shuffling/"/>
      <url>/domino-shuffling/</url>
      
        <content type="html"><![CDATA[<p><strong>2021/03/15 更新</strong>：刚得知 Youtube 上的博主 mathologer制作了一期非常精彩的节目，介绍 Aztec钻石图与多米诺洗牌算法，非常值得一看！</p><iframe width="640" height="360" src="https://www.youtube.com/embed/Yy7Q8IWNfHM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><hr><p><strong>2021/01/01 更新</strong>：2021 年的第一天，有人在 Shadertoy上放了一个精彩的动画，演示多米诺洗牌算法的步骤：</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/Wldyzj?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><hr><p>Aigner 和 Ziegler 所著的 <a href="https://en.wikipedia.org/wiki/Proofs_from_THE_BOOK">Proofs fromthe book</a> （中文译版《数学天书中的证明》）是一本非常精彩的数学读物，其中包含了 40余个著名的数学问题和它们的巧妙解答。这些问题并不深奥，但也绝非没有受过严格数学训练的人所能欣赏，其中往往包含了相当的洞察力和聪明才智，读起来让人神清气爽，大叹数学之妙。</p><p>然而读完这本书的人恐怕都会有意犹未尽的感觉：这就没啦？我还没看够呢！</p><p>有一个问题我想是非常适合放在这本书里的，我也非常期待能在未来的版本中看到它，这就是Aztec 钻石图的多米诺铺砌的计数问题。这个问题完美符合该书选题的标准：</p><ol type="1"><li>表述初等，不需要太多的背景知识就能能理解。</li><li>内涵丰富。Aztec钻石图是当前代数组合学中一个热点问题，它与交错符号矩阵、表示论、概率论、统计力学都有着深刻而奇妙的联系，有许多悬而未决的问题有待解决。</li><li>有多种令人拍案叫绝的解答，每个解答都不平凡，要么需要深刻的数学知识，要么需要开很大的脑洞。</li></ol><p>我来介绍一下这个问题：</p><span id="more"></span><p>依次把 <span class="math inline">\(2,4,\ldots,2n\)</span>个单位正方形对称地摞在一起，放在 <span class="math inline">\(x\)</span>轴上方，然后关于 <span class="math inline">\(x\)</span>轴对称地反射过去，得到的图形叫做 <span class="math inline">\(n\)</span>阶的 Aztec 钻石图，记作 <span class="math inline">\(\mathrm{AZ}(n)\)</span>。下图显示的是 <span class="math inline">\(\mathrm{AZ}(10)\)</span>：</p><figure><img src="/images/aztec/azgraph.svg" width="350" alt="\mathrm{AZ}(10)"><figcaption aria-hidden="true"><span class="math inline">\(\mathrm{AZ}(10)\)</span></figcaption></figure><p>用 1x2 的多米诺骨牌不重叠不遗漏地盖住这些方格，可以得到 Aztec钻石图的一个多米诺骨牌铺砌。下图显示的是 <span class="math inline">\(\mathrm{AZ}(10)\)</span> 的一种可能的铺砌：</p><figure><img src="/images/aztec/az10.svg" width="350" alt="\mathrm{AZ}(10) 的一种铺砌"><figcaption aria-hidden="true"><span class="math inline">\(\mathrm{AZ}(10)\)</span> 的一种铺砌</figcaption></figure><p>可以看到图中出现了四种不同颜色的骨牌，为什么这样染色后面会解释。</p><p>我们的问题是：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span><span class="math inline">\(\mathrm{AZ}(n)\)</span>总共有多少种不同的多米诺骨牌铺砌？</p></div><p>这里不考虑铺砌的对称性，比如全部用水平的骨牌铺砌和全部用竖直的骨牌铺砌是两种不同的铺砌。</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>如何在 <span class="math inline">\(\mathrm{AZ}(n)\)</span>的所有铺砌中等概率地随机任选一种？</p></div><p>第一个问题的答案是 <span class="math inline">\(2^{n(n+1)/2}\)</span>，这个表达式很简洁，这暗示这个问题也应该有一个简洁的解答（确实如此）。</p><p>第二个问题的答案叫做多米诺洗牌算法，正是本文要介绍的。</p><p>Aztec 钻石图多米诺铺砌的计数问题最早由 Elkies、Kuperberg、Propp 和Larson 在论文 <span class="citation" data-cites="dominoshuffling">(<a href="#ref-dominoshuffling" role="doc-biblioref">Elkies et al.1991</a>)</span> 中进行了深入的研究，在这篇文章中他们一共给出了 4种不同的解答。时至今日人们发现的解法已经超过一打，不幸的是没有一种可以算是「简单的」，但其中最精彩的仍然要数Elkies 等人论文中的第四个解法：洗牌算法。后来 Propp 在另一篇文章 <span class="citation" data-cites="spidermove">(<a href="#ref-spidermove" role="doc-biblioref">Propp 2001</a>)</span>中用图变换的方式重新表述了这个算法，并同时解决了在给定边的权重情况下对铺砌随机取样的问题。本文就来介绍Propp 的方法。</p><h1 id="洗牌算法">洗牌算法</h1><p>理解洗牌算法的第一个关键是理解骨牌的定向。</p><p>把 <span class="math inline">\(\mathbb{Z}^2\)</span>看做一张无穷大的国际象棋棋盘，每个方格染成黑白两色之一，相邻方格的颜色是不同的，于是每个骨牌都恰好覆盖一个黑方格和一个白方格。</p><p>乍看起来，骨牌只有水平或者竖直两种不同的类型，其实不然，骨牌有<code>N</code>、<code>S</code>、<code>W</code>、<code>E</code>（北南西东）四种不同的类型，认识到这一点非常重要。下面介绍怎样定义和区分骨牌的类型。</p><p>如果棋盘上一个 <span class="math inline">\(2\times2\)</span>的正方形区域的左上角的方格是黑色的，我们就称这是一个<strong>黑方块</strong>，如下图所示：</p><figure><img src="/images/aztec/block.svg" width="100" alt="黑方块"><figcaption aria-hidden="true">黑方块</figcaption></figure><p>类似地可以定义<strong>白方块</strong>为左上角方格为白色的 2x2正方形区域。</p><p>对一张骨牌 <span class="math inline">\(d\)</span>，它必然落在唯一的一个黑方块 <span class="math inline">\(B\)</span> 中。规定 <span class="math inline">\(d\)</span> 的移动规则为：把 <span class="math inline">\(d\)</span> 移动到它在 <span class="math inline">\(B\)</span> 中对面的位置上，根据 <span class="math inline">\(d\)</span> 的移动方向规定其定向分别为<code>N</code>、<code>S</code>、<code>W</code>、<code>E</code>。如下图所示：</p><figure><img src="/images/aztec/orientation.svg" width="400" alt="不同定向的骨牌的移动规则"><figcaption aria-hidden="true">不同定向的骨牌的移动规则</figcaption></figure><p>注意到在移动以后，定向为 <code>N/S</code> 的骨牌变成了定向为<code>S</code> 的骨牌，定向为 <code>S</code> 的骨牌变成了定向为<code>N</code> 的骨牌，对 <code>E</code>, <code>W</code>类型的骨牌亦然。</p><p>设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(\mathrm{AZ}(n)\)</span>的一个多米诺铺砌，如果一个黑方块 <span class="math inline">\(B\)</span>恰好包含 <span class="math inline">\(T\)</span>中一对平行放置的骨牌，就称 <span class="math inline">\(B\)</span> 是<span class="math inline">\(T\)</span>的一个<strong>坏方块</strong>。在一个坏方块中，两个骨牌的定向是互相朝着对方的。</p><p>把 <span class="math inline">\(\mathrm{AZ}(n)\)</span>放在棋盘上，使得其最上方一行的最左边的方格是白色，规定 <span class="math inline">\(\mathrm{AZ}(n)\)</span> 的对称中心为原点。设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(\mathrm{AZ}(n)\)</span>的任一铺砌，如下图所示。图中根据骨牌的定向<code>N</code>、<code>S</code>、<code>W</code>、<code>E</code>将其染成了红、黄、绿、蓝四种颜色。我还画出了一个大小为 <span class="math inline">\(\mathrm{AZ}(n+1)\)</span> 的背景区域。</p><figure><img src="/images/aztec/step0.svg" width="350" alt="\mathrm{AZ}(10) 的一个铺砌 T"><figcaption aria-hidden="true"><span class="math inline">\(\mathrm{AZ}(10)\)</span> 的一个铺砌 <span class="math inline">\(T\)</span></figcaption></figure><ol type="1"><li><p>移走所有坏方块中的骨牌，这一操作叫做「删除」(deletion)。上图中的铺砌在删除后的结果如下图所示：</p><figure><img src="/images/aztec/step1.svg" width="350" alt="从 T 中移走坏方块中的骨牌"><figcaption aria-hidden="true">从 <span class="math inline">\(T\)</span>中移走坏方块中的骨牌</figcaption></figure></li><li><p>将剩下的骨牌按照其定向各自移动一步，这一操作叫做「移动」(sliding)：</p><figure><img src="/images/aztec/step2.svg" width="350" alt="移动剩下的骨牌"><figcaption aria-hidden="true">移动剩下的骨牌</figcaption></figure><p>可以看到，这些剩下的骨牌分布在更大一些的 <span class="math inline">\(\mathrm{AZ}(n+1)\)</span>的区域内，而且不会出现骨牌重叠的情况。</p></li><li><p>可以证明在移动结束后 <span class="math inline">\(\mathrm{AZ}(n+1)\)</span>中的空白部分可以唯一地表示为若干不相交的黑方块的并，对每个这样的黑方块，任意用一对水平的或者是竖直的骨牌将其填充，就得到了<span class="math inline">\(\mathrm{AZ}(n+1)\)</span>的一个铺砌。这一操作叫做「生成 」(creation)。上图中的空白区域可以表示为14 个不相交的黑方块的并，因此一共有 <span class="math inline">\(2^{14}\)</span>种不同的生成方式，其中一种如下：</p><figure><img src="/images/aztec/step3.svg" width="350" alt="将每个黑方块用一对水平或竖直的骨牌填充，结果是一个 \mathrm{AZ}(n+1) 的铺砌"><figcaption aria-hidden="true">将每个黑方块用一对水平或竖直的骨牌填充，结果是一个<span class="math inline">\(\mathrm{AZ}(n+1)\)</span>的铺砌</figcaption></figure></li></ol><p>于是从 <span class="math inline">\(\mathrm{AZ}(n)\)</span>的任一铺砌出发，经过删除、移动、生成三次操作后，可以得到 <span class="math inline">\(\mathrm{AZ}(n+1)\)</span>的一个铺砌。这个步骤就叫做洗牌。</p><div id="------" class="statement sta___ definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注意</span>：</span><span class="statement-spah"> </span>算法开始时要求 <span class="math inline">\(\mathrm{AZ}(n)\)</span>最左上边的方格是白色，但是经过一次洗牌操作后，得到的 <span class="math inline">\(\mathrm{AZ}(n+1)\)</span>的铺砌最左上边的方格是黑色。如果我们想从这个 <span class="math inline">\(\mathrm{AZ}(n+1)\)</span> 的铺砌继续洗牌得到 <span class="math inline">\(\mathrm{AZ}(n+2)\)</span>的铺砌的话，就要翻转棋盘的染色。否则我们又会回到一个 <span class="math inline">\(\mathrm{AZ}(n)\)</span> 的铺砌。</p></div><p>用 GIF 动图演示这个过程：</p><p><img src="/images/aztec/dominoshuffling.gif" class="fig"></p><p>上图演示的是从 1 阶 Aztec 钻石图的一个随机铺砌出发，反复地执行删除-&gt; 移动 -&gt; 生成 -&gt; 删除 -&gt; 移动 -&gt; … 的步骤，最终生成 30阶 Aztec 钻石图的随机铺砌。其中每次生成之后都翻转棋盘的染色。</p><p><strong>算法中最难的部分是证明在第二步移动结束后，<span class="math inline">\(\mathrm{AZ}(n+1)\)</span>区域中的空白部分可以表示为不相交的黑方块的并</strong>。Elkies等人的原证明很简单，但是给人的感觉不够优雅和本质。这个算法用 Propp论文中介绍的图变换的角度更容易看清楚。</p><h1 id="蜘蛛移动">蜘蛛移动</h1><p>多米诺铺砌实质上是图的完美匹配：考虑图 <span class="math inline">\(G_n\)</span>，<span class="math inline">\(G_n\)</span> 的顶点与 <span class="math inline">\(\mathrm{AZ}(n)\)</span>中的方格一一对应，两个顶点相邻当且仅当它们对应的方格在 <span class="math inline">\(\mathrm{AZ}(n)\)</span> 中有公共的边，于是 <span class="math inline">\(\mathrm{AZ}(n)\)</span> 的多米诺铺砌与 <span class="math inline">\(G_n\)</span> 的完美匹配 (perfect matching)一一对应。</p><figure><img src="/images/aztec/matching.svg" width="350" alt="将 \mathrm{AZ}(n) 视作一个二分图 G_n"><figcaption aria-hidden="true">将 <span class="math inline">\(\mathrm{AZ}(n)\)</span> 视作一个二分图 <span class="math inline">\(G_n\)</span></figcaption></figure><p>现在问题转化为求 <span class="math inline">\(G_n\)</span>的完美匹配的个数，基本的想法是权函数。</p><p>设 <span class="math inline">\(G\)</span> 是一个简单平面图，<span class="math inline">\(G\)</span> 的每条边 <span class="math inline">\(e\)</span> 有一个权值 <span class="math inline">\(w(e)\)</span>，<span class="math inline">\(w(e)\)</span> 是一个变量，比如 <span class="math inline">\(x,y,z,w\)</span>。对 <span class="math inline">\(G\)</span> 的一个完美匹配 <span class="math inline">\(\pi\)</span>，定义 <span class="math inline">\(\pi\)</span> 的权值 <span class="math inline">\(w(\pi)\)</span> 为 <span class="math inline">\(\pi\)</span> 中所有边的权值的乘积：</p><p><span class="math display">\[w(\pi)=\prod_{e\in\pi}w(e).\]</span></p><p>并定义 <span class="math inline">\(G\)</span> 的权函数 <span class="math inline">\(w(G)\)</span> 为 <span class="math inline">\(G\)</span> 的所有完美匹配的权值的和： <span class="math display">\[w(G)=\sum_{\pi}w(\pi).\]</span></p><p>如果 <span class="math inline">\(w(e)\)</span> 对所有的边 <span class="math inline">\(e\)</span> 都是 1，那么 <span class="math inline">\(w(G)\)</span> 就是 <span class="math inline">\(G\)</span> 的完美匹配的个数。但是一般情况下 <span class="math inline">\(w(e)\)</span> 是未定元，所以 <span class="math inline">\(w(G)\)</span>是一个包含未定元的多元函数。但是只要求出了 <span class="math inline">\(w(G)\)</span> 的表达式，把其中所有变元都赋值为1，就得到了 <span class="math inline">\(G\)</span>的完美匹配的个数。</p><p>能求出权函数来当然是一件好事，因为权函数里面包含了图的非常多的信息，可以帮助我们计算出许多其它感兴趣的量来。比如说指定一条边<span class="math inline">\(e^\ast\)</span>，问 <span class="math inline">\(G\)</span> 有多少个匹配不包含 <span class="math inline">\(e^\ast\)</span>？为此只要令 <span class="math inline">\(w(e^\ast)=0\)</span>，其它的边 <span class="math inline">\(e\ne e^\ast\)</span> 的权值保持为1，代入权函数中即可。</p><p>看起来求出图的权函数是一个比直接计算其完美匹配的个数更复杂的问题，那为什么我们要舍近求远呢？权函数方法的奥秘在哪里呢？</p><p>这就是关键所在：对于一个复杂的图，我们想通过一些「手术」或者「变换」把它变成简单一些的图，比如删去一些顶点和边，或者把其中的一部分用一个新图去替换。这些变换通常会改变图的完美匹配的个数，但是权函数却在变换前后保持某种递推关系从而可以求解出来。这种操作我们其实都见到过，高中物理中电网络的各种等效电路替换（如<span class="math inline">\(Y-\Delta\)</span> 变换）就是图变换。</p><p>Propp 使用的图变换基于下面的蜘蛛引理：</p><div id="spider-move" class="unnumbered statement sta_____ plain"><p><span class="statement-heading"><span class="statement-label">蜘蛛移动</span>.</span><span class="statement-spah"> </span>假设图 <span class="math inline">\(G\)</span>的某个局部是一个正方形，如下图左边所示：</p><figure><img src="/images/aztec/spidermove.svg" width="500" alt="蜘蛛移动"><figcaption aria-hidden="true">蜘蛛移动</figcaption></figure><p>这里正方形的四个顶点记作 <span class="math inline">\(ABCD\)</span>，四条边权值分别为 <span class="math inline">\(x,y,z,w\)</span>。虚线表示它们可能与 <span class="math inline">\(G\)</span> 的其它部分相连。</p><p>现在我们保持 <span class="math inline">\(G\)</span>其它的部分不动，将正方形 <span class="math inline">\(ABCD\)</span>替换为一个新的局部图，如上图右边所示。新局部的正方形部分四条边的权值分别是<span class="math inline">\(z/\Delta,w/\Delta,x/\Delta,y/\Delta\)</span>，其中<span class="math inline">\(\Delta =xz+yw\)</span>。多出来的四条边的权值都是 1。记替换后则得到的新图为 <span class="math inline">\(G'\)</span>，则 <span class="math inline">\(G'\)</span> 与原图 <span class="math inline">\(G\)</span> 的权函数的关系为 <span class="math display">\[w(G)=w(G')\cdot\Delta.\]</span></p></div><p><strong>证明</strong>：对 <span class="math inline">\(G\)</span>的任一匹配 <span class="math inline">\(\pi\)</span>，有三种可能：</p><ol type="1"><li><span class="math inline">\(ABCD\)</span> 正好匹配成两对；</li><li><span class="math inline">\(ABCD\)</span>中有两个匹配在一起，另外两个与外部匹配；</li><li><span class="math inline">\(ABCD\)</span> 互不匹配，即它们不含 <span class="math inline">\(\pi\)</span> 的边。</li></ol><p>设 <span class="math inline">\(Q\)</span> 是 <span class="math inline">\(\pi\)</span> 在除去正方形 <span class="math inline">\(ABCD\)</span>后剩下部分的权。依次讨论这三种可能：</p><ol type="1"><li><p>若 <span class="math inline">\(\pi\)</span>属于第一类情形，则有两种可能：<span class="math inline">\(\{A,B\},\{C,D\}\)</span> 或者 <span class="math inline">\(\{A,D\},\{B,C\}\)</span>。我们把这两种可能对应到 <span class="math inline">\(G'\)</span> 的一个匹配 <span class="math inline">\(\pi^\ast\)</span>，如下图所示：</p><figure><img src="/images/aztec/case1.svg" width="500" alt="情形 1"><figcaption aria-hidden="true">情形 1</figcaption></figure><p><span class="math inline">\(\pi\)</span> 的两种可能性的权分别是 <span class="math inline">\(xzQ\)</span> 和 <span class="math inline">\(ywQ\)</span>，和是 <span class="math inline">\(\Delta Q\)</span>；<span class="math inline">\(\pi^\ast\)</span> 的权是 <span class="math inline">\(Q\)</span>，变换后的权值是变换前的 <span class="math inline">\(1/\Delta\)</span>。</p></li><li><p>若 <span class="math inline">\(\pi\)</span>属于第二类情形，则不妨设顶点 <span class="math inline">\(\{A,B\}\)</span> 匹配（另外三种可能的情形是 <span class="math inline">\(\{B,C\}\)</span>，<span class="math inline">\(\{C,D\}\)</span>，<span class="math inline">\(\{A,D\}\)</span>，分析是类似的），则 <span class="math inline">\(\pi\)</span> 可以唯一地对应到 <span class="math inline">\(G'\)</span> 的一个匹配 <span class="math inline">\(\pi^\ast\)</span>，如下图所示：</p><figure><img src="/images/aztec/case2.svg" width="500" alt="情形 2"><figcaption aria-hidden="true">情形 2</figcaption></figure><p><span class="math inline">\(\pi\)</span> 的权是 <span class="math inline">\(xQ\)</span>，<span class="math inline">\(\pi^\ast\)</span> 的权是 <span class="math inline">\(xQ/\Delta\)</span>，变换后的权值仍然是变换前的<span class="math inline">\(1/\Delta\)</span>。</p></li><li><p>若 <span class="math inline">\(\pi\)</span> 属于第三类情形，则<span class="math inline">\(\pi\)</span> 可以映射为 <span class="math inline">\(G'\)</span> 中的两个匹配 <span class="math inline">\(\pi^\ast_1,\pi^\ast_2\)</span>：</p><figure><img src="/images/aztec/case3.svg" width="500" alt="情形 3"><figcaption aria-hidden="true">情形 3</figcaption></figure><p><span class="math inline">\(\pi\)</span> 的权是 <span class="math inline">\(Q\)</span>，<span class="math inline">\(\pi^\ast_1,\pi^\ast_2\)</span> 的权分别是 <span class="math inline">\(xzQ/\Delta^2\)</span> 和 <span class="math inline">\(ywQ/\Delta^2\)</span>，它们的和是 <span class="math inline">\(Q/\Delta\)</span>，仍然是变换前的 <span class="math inline">\(1/\Delta\)</span>。</p></li></ol><p>于是 <span class="math inline">\(G\)</span>的匹配可以划分为不相交的三个子集 <span class="math inline">\(X_1,X_2,X_3\)</span>，它们分别对应上面列出的三种情形。相应地<span class="math inline">\(G'\)</span>的匹配也可以分为三个不相交的子集 <span class="math inline">\(Y_1,Y_2,Y_3\)</span>。<span class="math inline">\(X_1\)</span> 中每两个对应 <span class="math inline">\(Y_1\)</span> 中的一个，<span class="math inline">\(X_2\)</span> 和 <span class="math inline">\(Y_2\)</span> 一一对应，<span class="math inline">\(X_3\)</span> 中每一个对应 <span class="math inline">\(Y_3\)</span> 中的两个。在这个对应下 <span class="math inline">\(Y_i\)</span> 中所有匹配的权之和 <span class="math inline">\(w(Y_i)=w(X_i)/\Delta\)</span>，从而 <span class="math inline">\(w(G')=\sum_{i=1}^3w(Y_i)=w(G)/\Delta\)</span>。</p><p>下面这个引理在下节会用到，它的证明非常简单，所以我省略它的证明。</p><div id="contraction" class="unnumbered statement sta_____-1 plain"><p><span class="statement-heading"><span class="statement-label">顶点收缩</span>.</span><span class="statement-spah"></span>如果某个顶点只有两个邻居，并且它和这两个邻居之间的边的权值都是1，则我们可以将这个顶点以及它的两个邻居收缩为一个顶点。这样得到的新图与原图有同样的权函数。如下图所示：</p><figure><img src="/images/aztec/contraction.svg" width="400" alt="顶点收缩"><figcaption aria-hidden="true">顶点收缩</figcaption></figure></div><h1 id="用图变换求解计数问题">用图变换求解计数问题</h1><p>我们用蜘蛛移动的技巧来计算 <span class="math inline">\(G_n\)</span>的权函数 <span class="math inline">\(w(G_n)\)</span>满足的递推关系。</p><p>把 <span class="math inline">\(\mathbb{Z}^2\)</span>的顶点间隔染成黑白两色。如果一个 <span class="math inline">\(2\times2\)</span>的方块的左上角的顶点是黑色，就称它是一个「<strong>胞腔</strong>」。胞腔就是前面洗牌算法中的「黑方块」。对每个胞腔的四条边，从右侧开始顺时针依次标记其权重为<span class="math inline">\(x,y,z,w\)</span>。</p><p>我们从 <span class="math inline">\(G_{n-1}\)</span> 开始。下图是<span class="math inline">\(G_2\,(n=3)\)</span> 的例子：</p><figure><img src="/images/aztec/G1.svg" width="250" alt="G_2"><figcaption aria-hidden="true"><span class="math inline">\(G_2\)</span></figcaption></figure><p>然后我们给 <span class="math inline">\(G_{n-1}\)</span>外侧装饰上一些边，把它变成一个更大的图 <span class="math inline">\(G_n^{(1)}\)</span>。<span class="math inline">\(G_n^{(1)}\)</span> 包含 <span class="math inline">\(G_n\)</span> 作为子图，但是又比 <span class="math inline">\(G_n\)</span>多出一些蓝色的边。这些蓝色的边权值都是 1。<span class="math inline">\(G_n^{(1)}\)</span>的匹配在这些装饰的边处是限制死的，必须包含蓝色的边，所以 <span class="math inline">\(G_n^{(1)}\)</span> 和 <span class="math inline">\(G_{n-1}\)</span> 的权函数完全相同：</p><figure><img src="/images/aztec/G2.svg" width="350" alt="G_n^{(1)} 是 G_2 的扩展，二者的权函数相同"><figcaption aria-hidden="true"><span class="math inline">\(G_n^{(1)}\)</span> 是 <span class="math inline">\(G_2\)</span> 的扩展，二者的权函数相同</figcaption></figure><p>对 <span class="math inline">\(G_n^{(1)}\)</span>在各个胞腔处分别使用 <a href="#spider-move" title="蜘蛛移动">蜘蛛移动</a>，得到图 <span class="math inline">\(G_n^{(2)}\)</span>：</p><figure><img src="/images/aztec/G3.svg" width="350" alt="对 G_n^{(1)} 使用蜘蛛移动后得到 G_n^{(2)}"><figcaption aria-hidden="true">对 <span class="math inline">\(G_n^{(1)}\)</span> 使用蜘蛛移动后得到 <span class="math inline">\(G_n^{(2)}\)</span></figcaption></figure><p>由于我们总共对 <span class="math inline">\(n^2\)</span>个胞腔使用了蜘蛛移动，因此 <span class="math inline">\(G_n^{(2)}\)</span> 的权函数是 <span class="math display">\[w(G_n^{(2)})=\frac{w(G_n^{(1)})}{\Delta^{n^2}} =\frac{w(G_{n-1})}{\Delta^{n^2}}.\]</span></p><p>对 <span class="math inline">\(G_n^{(2)}\)</span> 使用 <a href="#contraction" title="顶点收缩">顶点收缩</a>，我们得到了 <span class="math inline">\(G_n^{(3)}\)</span>：</p><figure><img src="/images/aztec/G4.svg" width="350" alt="对 G_n^{(2)} 使用顶点收缩得到 G_n^{(3)}"><figcaption aria-hidden="true">对 <span class="math inline">\(G_n^{(2)}\)</span> 使用顶点收缩得到 <span class="math inline">\(G_n^{(3)}\)</span></figcaption></figure><p>顶点收缩不改变权函数，所以 <span class="math display">\[w(G_n^{(3)})= w(G_n^{(2)}) = \frac{w(G_{n-1})}{\Delta^{n^2}}.\]</span></p><p><span class="math inline">\(G_n^{(3)}\)</span> 作为图和 <span class="math inline">\(G_n\)</span>是一样的，但是每个胞腔四条边的权值变成了 <span class="math inline">\(x/\Delta,y/\Delta,z/\Delta,w/\Delta\)</span>，因此其权函数为<span class="math inline">\(w(G_n)/\Delta^{n(n+1)}\)</span>（因为 <span class="math inline">\(G_n\)</span> 的每个匹配都包含 <span class="math inline">\(n(n+1)\)</span> 条边，是 <span class="math inline">\(G_n\)</span>的顶点个数的一半）。从而我们用两种方法得到了 <span class="math inline">\(G_n^{(3)}\)</span> 的权函数，即 <span class="math display">\[\frac{w(G_{n-1})}{\Delta^{n^2}}=\frac{w(G_n)}{\Delta^{n(n+1)}}.\]</span>也就是 <span class="math inline">\(w(G_n)=\Delta^nw(G_{n-1})\)</span>。这就是 <span class="math inline">\(\{w(G_n)\}\)</span> 满足的递推关系。</p><p>由初始条件 <span class="math inline">\(w(G_1)=\Delta\)</span> 可得<span class="math inline">\(w(G_n)=\Delta^{n(n+1)/2}\)</span>。特别令<span class="math inline">\(w=x=y=z=1\)</span> 我们就得到 <span class="math inline">\(\mathrm{AZ}(n)\)</span> 的多米诺铺砌的个数为 <span class="math inline">\(2^{n(n+1)/2}\)</span>。</p><h1 id="从图变换的角度看洗牌算法">从图变换的角度看洗牌算法</h1><p>最后我们从图变换的角度解释为什么洗牌算法是正确的。你会看到，洗牌算法的三个操作步骤恰好对应<a href="#spider-move" title="蜘蛛移动">蜘蛛移动</a> 中的三种情形。</p><p>在下图中，胞腔是深色，匹配的边是红色。三个胞腔 I, II, III 分别对应 <a href="#spider-move" title="蜘蛛移动">蜘蛛移动</a> 的三种情形：I包含匹配的两条边；II 包含匹配的一条边；III 不含匹配的边。</p><figure><img src="/images/aztec/trans1.svg" width="350" alt="注意看，I, II, III 三个胞腔将分别对应蜘蛛移动中的三种情形，即洗牌算法的三个步骤。"><figcaption aria-hidden="true">注意看，I, II, III三个胞腔将分别对应蜘蛛移动中的三种情形，即洗牌算法的三个步骤。</figcaption></figure><p>蜘蛛移动就是删掉原始 <span class="math inline">\(\mathbb Z^2\)</span>的所有边，在每个黑方块的内部塞进去一个小正方形，形成一个嵌套的结构（左下图的阴影正方形），并且修改这个嵌套结构的匹配。这个操作对不同的黑方块是完全隔离的，它们互不影响。</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr><td style="text-align: center;">只有红色边和虚线边属于新图</td><td style="text-align: center;">拿走 <span class="math inline">\(\mathbb{Z}^2\)</span> 的边后的效果</td></tr><tr><td style="text-align: center;"><img src="/images/aztec/trans2.svg" width="350"></td><td style="text-align: center;"><img src="/images/aztec/trans3.svg" width="350"></td></tr></tbody></table><p>所有这些新塞进去的小正方形，它们通过原图的顶点连在一起。使用顶点收缩把它们捏在一起，我们得到了<span class="math inline">\(\mathbb{Z}^2\)</span>的一个新匹配。如下图所示：</p><figure><img src="/images/aztec/trans4.svg" width="350" alt="收缩后的效果，注意 I, II, II 三个胞腔中匹配的变化"><figcaption aria-hidden="true">收缩后的效果，注意 I, II, II三个胞腔中匹配的变化</figcaption></figure><p>与原匹配相比，I 中的边「删除」了，II 中的边「移动」到了对面，III中「生成」了两条新边，正好与洗牌算法一致。同时胞腔的染色发生了翻转，即白方块和黑方块互换了颜色。</p><p>Gemini 3 pro 给这个操作打了一个形象的比喻：</p><div class="statement simple plain unnumbered"><p>每个细胞（黑方块）内部先复制出一套核心（小正方形），然后细胞壁（旧顶点）溶解，新的核心连接起来形成了新的组织。</p></div><h1 id="结语">结语</h1><p>Aztec钻石图背后有许多有趣而深刻的数学，即便是计数这样看似初等的问题也有许多奥妙在里面，比如还有基于graph condensation 的证明、转化为不相交路径组计数的证明、利用 <span class="math inline">\({\rm GL}_n(\mathbb{C})\)</span>的表示等精彩的证明，它们背后的思想已经广泛应用在计数组合学的许多问题中。借用丘吉尔的一句话作为结尾：“Nowthis is not the end. It is not even the beginning of the end. But it is,perhaps, the end of the beginning”。</p><p>顺便一提，演示多米诺算法的 GIF 动图是我学习 Python的第一个正式程序，从开始看语法到写出最初的粗糙版本花了一周左右的时间。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-dominoshuffling" class="csl-entry" role="listitem">Elkies, Noam, Greg Kuperberg, Michael Larsen, and James Propp. 1991.<span>“Alternating Sign Matrices and Domino Tilings.”</span> <em>J.Algebraic Combin. 1 (1992), No. 2, 111–132; J. Algebraic Combin. 1(1992), No. 3, 219-234</em>, June. <a href="https://arxiv.org/abs/math/9201305v1">https://arxiv.org/abs/math/9201305v1</a>.</div><div id="ref-spidermove" class="csl-entry" role="listitem">Propp, James. 2001. <span>“Generalized Domino-Shuffling.”</span><em>Theoret. Comput. Sci. 303, No. 2-3, 267–301, Tilings of the Plane(2003).</em>, November. <a href="https://arxiv.org/abs/math/0111034v2">https://arxiv.org/abs/math/0111034v2</a>.</div></div>]]></content>
      
      
      <categories>
          
          <category> 计数组合学 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>Coxeter 群语言正则的证明</title>
      <link href="/coxeter-automatic/bak.html"/>
      <url>/coxeter-automatic/bak.html</url>
      
        <content type="html"><![CDATA[<div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.1</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha,\beta\in\Phi\)</span> 满足 <span class="math inline">\(|(\alpha,\beta)|&lt;1\)</span>，则必然有 <span class="math inline">\((\alpha,\beta)=\cos(p\pi/q)\)</span>，其中 <span class="math inline">\(p,q\)</span> 是互素的正整数，而且反射 <span class="math inline">\(r_\alpha,r_\beta\)</span> 生成的子群是有限群。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(|(\alpha,\beta)|&lt;1\)</span>，则内积 <span class="math inline">\((\,,)\)</span> 限制在 <span class="math inline">\(\alpha,\beta\)</span> 张成的二维子空间 <span class="math inline">\(U=\mathop{\mathrm{span}}{\{\alpha,\beta\}}\)</span>上是正定的。</p><p>我们可以不妨假定 <span class="math inline">\(\alpha\)</span>是正根，以及 <span class="math inline">\(\beta=\alpha_s\)</span>是单根。设 <span class="math display">\[\alpha = c_s\alpha_s +\sum_{t\ne s }c_t\alpha_t.\]</span> 由于 <span class="math inline">\(\alpha\)</span> 不可能是 <span class="math inline">\(\alpha_s\)</span> 的正倍数，所以 <span class="math inline">\(\gamma=\alpha - c_s\alpha_s\ne0\)</span>。</p><p>注意到如果 <span class="math inline">\(a,b\in\mathbb{R}\)</span> 使得<span class="math inline">\(a\gamma+b\alpha_s\in\Phi\)</span>，则 <span class="math inline">\(a,b\)</span> 必须同时非负，或者同时非正。如果<span class="math inline">\(\alpha,\beta\)</span> 所夹的角度是 <span class="math inline">\(\pi\)</span> 的无理数倍，那么 <span class="math inline">\((r_\alpha s)\)</span> 是 <span class="math inline">\(U\)</span> 上角度为 <span class="math inline">\(\pi\)</span> 的无理数倍的旋转，它的各次幂 <span class="math inline">\(\{(r_\alpha s)^n,n=0,1,\ldots,\}\)</span> 会将<span class="math inline">\(\alpha\)</span> 映射为 <span class="math inline">\(U\)</span>中单位圆周上稠密的集合，特别地必然有某个 <span class="math inline">\(k\)</span> 使得 <span class="math inline">\((r_\alpha s)^k\alpha\)</span> 位于区域 <span class="math inline">\(\{a\gamma+b\alpha_s\mid a &gt; 0,b&lt;0\}\)</span> 中，这与此区域不包含任何根矛盾。所以 <span class="math inline">\(\alpha,\beta\)</span> 所夹的角度必须是 <span class="math inline">\(\pi\)</span> 的有理数倍，形如 <span class="math inline">\(p\pi/q\)</span>，从而 <span class="math inline">\(r_\alpha,r_\beta\)</span> 生成的子群 <span class="math inline">\(D\)</span> 在 <span class="math inline">\(U\)</span> 上的作用是一个二面体群。另一方面 <span class="math inline">\((\,,)\)</span> 限制在 <span class="math inline">\(U\)</span> 上是正定的，所以 <span class="math inline">\(V=U\oplus U^\bot\)</span>。而 <span class="math inline">\(D\)</span> 作用在 <span class="math inline">\(U^\bot\)</span> 上是平凡的，所以 <span class="math inline">\(D\)</span> 在全空间上的作用也是二面体群。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义0.2</span>.</span><span class="statement-spah"> </span>对任何正根 <span class="math inline">\(\alpha\in\Phi^+\)</span>，定义其深度为 <span class="math display">\[\mathrm{dp}(\alpha)=\min\{\,l(w) \midw\alpha\in\Phi^-\,\}.\]</span> 对两个正根 <span class="math inline">\(\alpha,\beta\)</span>，定义 <span class="math inline">\(\alpha\preceq\beta\)</span> 当且仅当存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(\beta=w\alpha\)</span> 并且 <span class="math display">\[\mathrm{dp}(\beta)=\mathrm{dp}(\alpha)+l(w).\]</span>如果 <span class="math inline">\(\alpha\preceq\beta\)</span> 且 <span class="math inline">\(\alpha\ne\beta\)</span> 我们记为 <span class="math inline">\(\alpha\prec\beta\)</span>。</p></div><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\preceq\)</span> 是 <span class="math inline">\(\Phi^+\)</span> 上的偏序。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span> 使得 <span class="math inline">\(\alpha\prec\beta\)</span>，则必然有 <span class="math inline">\(\mathrm{dp}(\beta)&gt;\mathrm{dp}(\alpha)\)</span>，即<span class="math inline">\(\preceq\)</span> 是反对称的。我们只要再证明<span class="math inline">\(\preceq\)</span> 是传递的。</p><p>设 <span class="math inline">\(\alpha,\beta,\gamma\in\Phi^+\)</span>满足 <span class="math inline">\(\alpha\preceq\beta\)</span> 和 <span class="math inline">\(\beta\preceq\gamma\)</span>，我们来证明 <span class="math inline">\(\alpha\preceq\gamma\)</span>。为此我们设 <span class="math display">\[\begin{aligned}\beta &amp;= u\alpha, &amp;\mathrm{dp}(\beta) - \mathrm{dp}(\alpha) =l(u).\\\gamma &amp;= v\beta, &amp;\mathrm{dp}(\gamma) - \mathrm{dp}(\beta) =l(v).\\\end{aligned}\]</span> 显然 <span class="math inline">\(\gamma=vu\alpha\)</span> 且<span class="math inline">\(\mathrm{dp}(\gamma)-\mathrm{dp}(\alpha)=l(u)+l(v)\)</span>。只要再证明 <span class="math inline">\(l(uv)=l(u)+l(v)\)</span> 即可。</p><p>设 <span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(w\alpha\in\Phi^-\)</span> 且 <span class="math inline">\(l(w)=\mathrm{dp}(\alpha)\)</span>。于是 <span class="math display">\[\gamma=vu\alpha\Rightarrowu^{-1}v^{-1}\gamma=\alpha \Rightarrowwu^{-1}v^{-1}\gamma\in\Phi^-.\]</span> 从而 <span class="math inline">\(l(wu^{-1}v^{-1})\geq\mathrm{dp}(\gamma)\)</span>。</p><p>另一方面 <span class="math display">\[l(wu^{-1}v^{-1})\leql(w)+(l(u)+l(v))=\mathrm{dp}(\alpha)+(\mathrm{dp}(\gamma)-\mathrm{dp}(\alpha))=\mathrm{dp}(\gamma).\]</span>所以 <span class="math inline">\(l(wu^{-1}v^{-1})=\mathrm{dp}(\gamma)\)</span>，特别地上式中所有的不等号都是等号，于是<span class="math inline">\(l(wu^{-1}v^{-1})=l(w)+l(u)+l(v)\)</span>，从而必然有 <span class="math inline">\(l(uv)=l(u)+l(v)\)</span>。<span class="math inline">\(\blacksquare\)</span>。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha_s\)</span> 是单根，<span class="math inline">\(\alpha\ne\alpha_s\)</span> 是正根，则 <span class="math display">\[\mathrm{dp}(s\alpha)=\begin{cases}\mathrm{dp}(\alpha)-1&amp; \text{if } (\alpha,\alpha_s)&gt;0,\\\mathrm{dp}(\alpha) &amp;\text{if } (\alpha,\alpha_s)=0.\\\mathrm{dp}(\alpha)+1 &amp; \text{if }(\alpha,\alpha_s)&lt;0.\end{cases}\]</span></p></div><p>第二条是显然的，而第三条可以由第一条得出：只要对 <span class="math inline">\(s\alpha\)</span>应用第一条的结论即可。所以我们只需要证明第一条。</p><p>首先取 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(l(w)=\mathrm{dp}(\alpha)\)</span> 且 <span class="math inline">\(w\alpha\in\Phi^-\)</span>。</p><ol type="1"><li><p>如果 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>，则<span class="math inline">\(l(ws)&lt;l(w)\)</span>，并且 <span class="math inline">\(ws\)</span> 满足 <span class="math inline">\((ws)(s\alpha)&lt;0\)</span>，所以 <span class="math inline">\(\mathrm{dp}(s\alpha)\leql(ws)=l(w)-1\)</span>，从而 <span class="math inline">\(\mathrm{dp}(s\alpha)=l(w)-1\)</span>。</p></li><li><p>如果 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>，则<span class="math inline">\(w(s\alpha)\)</span> 是负根，并且 <span class="math display">\[\begin{align*}w(s\alpha)&amp;=w(\alpha - 2(\alpha,\alpha_s)\alpha_s)\\&amp;=w\alpha-cw\alpha_s (c&gt;0)\end{align*}\]</span> 由于 <span class="math inline">\(\alpha\ne\alpha_s\)</span>是不同的正根，所以它们不共线，从而 <span class="math inline">\(w\alpha\)</span> 和 <span class="math inline">\(w\alpha_s\)</span>也不共线，于是上式是两个不共线的负根的和，所以任何单反射不能将 <span class="math inline">\(w(s\alpha)\)</span> 变成正根。取 <span class="math inline">\(t\in S\)</span> 使得 <span class="math inline">\(l(tw)&lt;l(w)\)</span>，则 <span class="math inline">\((tw)(s\alpha)\)</span> 仍然是负根，所以 <span class="math inline">\(\mathrm{dp}(s\alpha)\leql(tw)=l(w)-1\)</span>，结论仍然得证。</p></li></ol><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.5</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha\preceq\beta\)</span>，则存在序列 <span class="math display">\[\alpha=\alpha_0\preceq\alpha_1\preceq\cdots\preceq\alpha_k=\beta\]</span>使得对每个 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(\mathrm{dp}(\alpha_{i+1})=\mathrm{dp}(\alpha_i)+1\)</span>。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(w=s_k\cdotss_1\)</span> 满足 <span class="math inline">\(\beta=w\alpha\)</span> 且<span class="math inline">\(l(w)=\mathrm{dp}(\beta)-\mathrm{dp}(\alpha)\)</span>，考虑<span class="math inline">\(\alpha_i=s_i\cdots s_1\alpha\)</span>，其中<span class="math inline">\(\alpha_0=\alpha\)</span>，<span class="math inline">\(\alpha_k=\beta\)</span>。从 <span class="math inline">\(\alpha_0\)</span> 到 <span class="math inline">\(\alpha_k\)</span> 经过了 <span class="math inline">\(k=l(w)\)</span> 次单反射，depth 增加了 <span class="math inline">\(l(w)\)</span>，但上面的引理告诉我们每次单反射depth 至多增加 1，所以只能是每一项的 depth 都比前一项增加了1，即得结论。</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.6</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha\preceq\beta\)</span>，且 <span class="math inline">\(\alpha=\sum c_s\alpha_s,\, \beta=\sumd_s\alpha_s\)</span>，则对每个 <span class="math inline">\(s\)</span> 有<span class="math inline">\(c_s\leq d_s\)</span>。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(\beta=s\alpha\)</span> 则 <span class="math inline">\(\alpha,\beta\)</span> 只有在 <span class="math inline">\(\alpha_s\)</span> 项的系数不同。又 <span class="math inline">\((\alpha,\alpha_s)&lt;0\)</span> 所以 <span class="math inline">\(d_s&gt;c_s\)</span> 得证。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义0.7</span>.</span><span class="statement-spah"> </span>对 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span>，如果对任何 <span class="math inline">\(w\in W\)</span> 都有 <span class="math inline">\(w\alpha\in\Phi^-\Rightarroww\beta\in\Phi^-\)</span>，我们就称 <span class="math inline">\(\alpha\)</span> 支配 <span class="math inline">\(\beta\)</span>，记作 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>。</p></div><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.8</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span> 且 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>，则：</p><ol type="1"><li><span class="math inline">\((\alpha,\beta)&gt;0\)</span>。</li><li>若 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\beta\)</span> 是正根，则 <span class="math inline">\(w\alpha\,\mathrm{dom}\,w\beta\)</span>。</li><li>若 <span class="math inline">\(\alpha\prec\alpha'\)</span> 则<span class="math inline">\(\alpha'\)</span>不是极小根。换句话说，若一个根是极小根，则在偏序 <span class="math inline">\(\preceq\)</span> 下小于它的根也都是极小根。</li><li><span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>，等号当且仅当<span class="math inline">\(\alpha=\beta\)</span> 时成立。</li></ol></div><p><strong>证明</strong>：</p><ol type="1"><li><p><span class="math inline">\(r_\alpha\)</span> 满足 <span class="math inline">\(r_\alpha\alpha=-\alpha\in\Phi^-\)</span>，所以<span class="math inline">\(r_\alpha\beta=\beta-2(\alpha,\beta)\alpha&lt;0\)</span>，这必须<span class="math inline">\((\alpha,\beta)&gt;0\)</span> 才行。</p></li><li><p>显然。</p></li><li><p>只要对 <span class="math inline">\(\mathrm{dp}(\alpha')=\mathrm{dp}(\alpha)+1\)</span>进行证明即可。这时存在单反射 <span class="math inline">\(s\)</span> 使得<span class="math inline">\(\alpha'=s\alpha\)</span>，并且 <span class="math inline">\((\alpha_s,\alpha)&lt;0\)</span>。根据 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span> 和 <span class="math inline">\((\alpha,\beta)&gt;0\)</span> 说明 <span class="math inline">\(\beta\ne\alpha_s\)</span>，从而 <span class="math inline">\(s\beta\)</span> 是正根，从而 <span class="math inline">\(\alpha'=s\alpha\,\mathrm{dom}\,s\beta\)</span>不是极小根。</p></li><li><p><span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>显然意味着 <span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>。设<span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\alpha=-\alpha_s\)</span> 是某个负的单根，则<span class="math inline">\(w\beta\in\Phi^-\)</span>。注意这时 <span class="math inline">\(w^{-1}\alpha_s=-\alpha&lt;0\)</span>，所以 <span class="math inline">\(l(sw)&lt;l(w)\)</span>。</p><ul><li><p>若 <span class="math inline">\(sw\beta\in\Phi^+\)</span>，则由<span class="math inline">\(w\beta&lt;0\)</span> 可知 <span class="math inline">\(w\beta=-\alpha_s\)</span>，再结合 <span class="math inline">\(w\alpha=-\alpha_s\)</span> 可得 <span class="math inline">\(\alpha=\beta\)</span>。</p></li><li><p>若 <span class="math inline">\(sw\beta\in\Phi^-\)</span>，则<span class="math inline">\(\mathrm{dp}(\beta)\leql(sw)&lt;\mathrm{dp}(\alpha)\)</span>。</p></li></ul></li></ol><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.9</span>.</span><span class="statement-spah"> </span>在有限 Coxeter群中，所有根都是极小根。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(w_0\)</span>是最长元，则 <span class="math inline">\(\alpha\to -w_0(\alpha)\)</span>置换 <span class="math inline">\(\Phi^+\)</span>。我们来验证这个置换保持每个正根的深度不变：若<span class="math inline">\(w\alpha&lt;0\)</span>，则 <span class="math inline">\(w_0w\alpha&gt;0\)</span>，从而 <span class="math inline">\((w_0ww_0)-w_0\alpha&lt;0\)</span>，这说明 <span class="math inline">\(\mathrm{dp}(-w_0\alpha)\geql(w_0ww_0)=l(w)\)</span>。对 <span class="math inline">\(-w_0\alpha\)</span> 应用此结论可得 <span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(-w_0\alpha)\)</span>。从而二者相等。</p><p>另一方面我们来验证它翻转 <span class="math inline">\(\,\mathrm{dom}\,\)</span> 这个偏序：若 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>，则 <span class="math display">\[\begin{align*}w\alpha&lt;0&amp;\Rightarrow w\beta&lt;0\\&amp;\Downarrow\\w\beta &gt; 0&amp;\Rightarrow w\alpha&gt;0\\&amp;\Downarrow\\ww_0\beta &gt; 0&amp;\Rightarrow ww_0\alpha&gt;0\\&amp;\Downarrow\\w(-w_0\beta) &lt; 0&amp;\Rightarrow w(-w_0\alpha)&lt;0\\\end{align*}\]</span> 即确实有 <span class="math inline">\(-w_0\beta\,\mathrm{dom}\,-w_0\alpha\)</span>。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.10</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span> 的充要条件是<span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>且 <span class="math inline">\((\alpha,\beta)\geq1\)</span>。</p></div><p><strong>证明</strong>：我们只考虑 <span class="math inline">\(\alpha\ne\beta\)</span> 的情形即可。</p><p><span class="math inline">\(\Rightarrow\)</span>：只要再证明 <span class="math inline">\((\alpha,\beta)\geq1\)</span>。用反证法，若不然，则<span class="math inline">\(0&lt;(\alpha,\beta)&lt;1\)</span>，从而<span class="math inline">\(r_\alpha,r_\beta\)</span>生成一个有限二面体群 <span class="math inline">\(D\)</span>。由于在有限群中没有支配关系，所以存在<span class="math inline">\(w\in D\)</span> 使得 <span class="math inline">\(w\alpha\in\Phi^-,\,w\beta\in\Phi^+\)</span>。这与<span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>矛盾。</p><p><span class="math inline">\(\Leftarrow\)</span>：我们先考虑 <span class="math inline">\(\beta=\alpha_s\)</span> 是一个单根的情形。由于<span class="math inline">\(\alpha\ne\beta\)</span> 所以 <span class="math inline">\(s\alpha\)</span> 仍然是正根。我们发现 <span class="math display">\[(\alpha,s\alpha)=(\alpha,\alpha-2(\alpha,\alpha_s)\alpha_s)=1-2(\alpha,\alpha_s)^2\leq-1.\]</span> 所以有无穷多个形如 <span class="math inline">\(a\alpha+b\alpha_s\)</span> 的正根，其中 <span class="math inline">\(a,b&gt;0\)</span>。</p><p>用反证法，如果 <span class="math inline">\(\alpha\)</span> 不支配<span class="math inline">\(\beta=\alpha_s\)</span>，则存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\alpha\in\Phi^-\)</span> 但 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>。由于 <span class="math display">\[w(s\alpha)=w\alpha -2(\alpha,\alpha_s)w\alpha_s\]</span> 是负根 <span class="math inline">\(w\alpha\)</span> 减去正根 <span class="math inline">\(w\alpha_s\)</span>的一个正倍数，必然仍然是负根。于是 <span class="math inline">\(\{\alpha,s\alpha\}\subsetN(w)\)</span>，从而所有形如 <span class="math inline">\(\{a\alpha+bs\alpha\mid a,b&gt;0\}\)</span>的根都在 <span class="math inline">\(N(w)\)</span> 中，这与 <span class="math inline">\(|N(w)|=l(w)&lt;\infty\)</span> 矛盾。</p><p>对 <span class="math inline">\(\beta\)</span> 是一般正根的情形，取<span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\beta\in\Delta\)</span>，<span class="math inline">\(l(w)=\mathrm{dp}(\beta)-1\)</span>。由于 <span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>所以 <span class="math inline">\(w\alpha\)</span> 仍然是正根，当然就有<span class="math inline">\(\mathrm{dp}(w\alpha)\geq\mathrm{dp}(w\beta)=1\)</span>和 <span class="math inline">\((w\alpha,w\beta)=(\alpha,\beta)\geq1\)</span>。根据上面的证明，<span class="math inline">\(w\alpha\,\mathrm{dom}\,w\beta\)</span>，所以 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.11</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\lambda,\mu\)</span> 是正根，且 <span class="math inline">\(s_\lambda,s_\mu\)</span>生成一个无限群，则下面三种情况必居其一：</p><ol type="1"><li><span class="math inline">\(\lambda\,\mathrm{dom}\,\mu\)</span>.</li><li><span class="math inline">\(\mu\,\mathrm{dom}\,\lambda\)</span>.</li><li><span class="math inline">\(s_\mu\lambda\,\mathrm{dom}\,\mu\)</span>且 <span class="math inline">\(s_\lambda\mu\,\mathrm{dom}\,\lambda\)</span>.</li></ol></div><p><strong>证明</strong>：<span class="math inline">\(s_\lambda,s_\mu\)</span> 生成一个无限群说明 <span class="math inline">\(|(\lambda,\mu)|\geq1\)</span>。如果 <span class="math inline">\((\lambda,\mu)\geq1\)</span> 那么 <span class="math inline">\(\lambda,\mu\)</span> 中 depth更大的那一个支配另一个。</p><p>如果 <span class="math inline">\((\lambda,\mu)\leq-1\)</span>我们来证明 <span class="math inline">\(s_\mu\lambda\,\mathrm{dom}\,\mu\)</span>，<span class="math inline">\(s_\lambda\mu\,\mathrm{dom}\,\lambda\)</span>的论证是一样的。注意到这时 <span class="math inline">\((s_\mu\lambda,\mu)=-(\lambda,\mu)\geq1\)</span>，所以只要再证明 <span class="math inline">\(\mathrm{dp}(s_\mu\lambda)\geq\mathrm{dp}(\mu)\)</span> 即可。</p><p>设 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w(s_\mu\lambda)&lt;0\)</span> 且 <span class="math inline">\(l(w)=\mathrm{dp}(s_\mu\lambda)\)</span>，我们来证明必有一个长度<span class="math inline">\(l(w')\leq l(w)\)</span> 的元素 <span class="math inline">\(w'\)</span> 使得 <span class="math inline">\(w'\mu&lt;0\)</span>，从而 <span class="math inline">\(\mathrm{dp}(s_\mu\lambda)\geq\mathrm{dp}(\mu)\)</span>。</p><p>首先若 <span class="math inline">\(w\mu&lt;0\)</span> 则可以取 <span class="math inline">\(w'=w\)</span>。否则若 <span class="math inline">\(w\mu&gt;0\)</span>，我们来计算 <span class="math display">\[w(s_\mu\lambda)=w\lambda-2(\mu,\lambda)w\mu.\]</span>我们知道这是一个负根，而且它是 <span class="math inline">\(w\lambda\)</span> 加上正根 <span class="math inline">\(w\mu\)</span> 的正倍数，所以必须 <span class="math inline">\(w\lambda&lt;0\)</span>，从而 <span class="math inline">\(l(ws_\lambda)&lt;l(w)\)</span>。</p><p>进一步我们计算 <span class="math display">\[(ws_\lambda)\mu=w\mu-2(\mu,\lambda)w\lambda.\]</span>我们来证明 <span class="math inline">\((ws_\lambda)\mu\)</span>是一个负根，从而 <span class="math inline">\(\mathrm{dp}(\mu)\leql(ws_\lambda)&lt;l(w)=\mathrm{dp}(s_\mu\lambda)\)</span>。</p><p>若不然，记 <span class="math inline">\(c=-2(\mu,\lambda)\geq2\)</span>，若 <span class="math inline">\((ws_\lambda)\mu=w\mu+cw\lambda&gt;0\)</span>，乘以<span class="math inline">\(c\)</span> 得到 <span class="math inline">\(cw\mu+c^2w\lambda\)</span>是正根的非负线性组合（未必还是根），根据上面 <span class="math inline">\(w\lambda+cw\mu&lt;0\)</span>，减去后者得到 <span class="math inline">\((c^2-1)w\lambda\)</span> 是正根的非负线性组合，但<span class="math inline">\(c^2-1\geq 3\)</span>，这与 <span class="math inline">\(w\lambda&lt;0\)</span> 矛盾。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.12</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span> 满足 <span class="math inline">\(\beta\preceq\alpha\)</span>，并且 <span class="math inline">\(\alpha\)</span> 是极小根。进一步设 <span class="math inline">\(\alpha_s\in\Delta\)</span> 满足 <span class="math inline">\((\beta,\alpha_s)\leq-1\)</span>，则 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> 的 <span class="math inline">\(\alpha_s\)</span> 项的系数相等。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(\beta\preceq\gamma\preceq\alpha\)</span> 使得<span class="math inline">\(\gamma\)</span> 是偏序 <span class="math inline">\(\preceq\)</span> 下最大的与 <span class="math inline">\(\beta\)</span> 有相同的 <span class="math inline">\(\alpha_s\)</span> 项系数。如果 <span class="math inline">\(\gamma\ne\alpha\)</span>，则存在 <span class="math inline">\(t\)</span> 使得 <span class="math inline">\(\gamma\prec t\gamma\preceq\alpha\)</span>。由<span class="math inline">\(\gamma\)</span> 的极大性可得 <span class="math inline">\(s=t\)</span>。</p><p>但是 <span class="math inline">\(\gamma-\beta=\sum_{t\nes}c_t\alpha_t\)</span>，且每个 <span class="math inline">\(c_t\geq0\)</span>。因此 <span class="math display">\[(s\gamma,\alpha_s)=(\gamma,-\alpha_s)=-(\beta,\alpha_s)-\sum_{t\ner}c_t(\alpha_t,\alpha_s)\geq1.\]</span> 于是 <span class="math inline">\(s\gamma\,\mathrm{dom}\,\alpha_s\)</span>不是极小根，从而 <span class="math inline">\(\alpha\succeqs\gamma\)</span> 也不是极小根。矛盾！所以 <span class="math inline">\(\gamma=\alpha\)</span>，从而命题得证。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.13</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi\)</span> 满足 <span class="math inline">\(|(\alpha,\beta)|\leq 1\)</span>，则这样的 <span class="math inline">\((\alpha,\beta)\)</span> 只有有限多个值。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(|(\alpha,\beta)|&lt;1\)</span> 则 <span class="math inline">\(r_\alpha,r_\beta\)</span> 生成的子群 <span class="math inline">\(D\)</span> 是有限的，所以存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(wDw^{-1}\)</span> 属于某个有限的标准椭圆子群 <span class="math inline">\(W_J\)</span>，特别地，<span class="math inline">\(r_\alpha r_\beta\)</span> 的阶 <span class="math inline">\(m\)</span> 应该整除 <span class="math inline">\(W_J\)</span> 的阶，从而 <span class="math inline">\((\alpha,\beta)\)</span> 形如 <span class="math inline">\(\cos(a\pi/m)\)</span>，其中 <span class="math inline">\(0\leq a\leq 2m\)</span> 而且 <span class="math inline">\(m\)</span>是某个有限标准椭圆子群的阶的因子。由于这样的子群是有限的，所以这样的<span class="math inline">\(\cos\)</span> 值也是有限的。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.14</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha=\sum a_s\alpha_s\)</span> 和 <span class="math inline">\(\beta=\sum b_s\alpha_s\)</span> 都是正根。进一步设<span class="math inline">\(S=I\cup J\)</span> 使得</p><ol type="1"><li>对任何 <span class="math inline">\(t\in I\)</span> 有 <span class="math inline">\((\alpha,\alpha_t)=(\beta,\beta_t)\)</span>。</li><li><span class="math inline">\(c_t=b_t\)</span> 对任何 <span class="math inline">\(t\in J\)</span> 成立。</li></ol><p>则 <span class="math inline">\((\alpha,\beta)=1\)</span>。</p></div><p>注意这里 <span class="math inline">\(I\)</span> 或者 <span class="math inline">\(J\)</span> 允许有一个是空集。</p><p><strong>证明</strong>：我们有 <span class="math inline">\(\alpha-\beta=\sum_{s\inI}(a_s-b_s)\alpha_s\)</span>，所以 <span class="math display">\[(\alpha,\alpha-\beta)=\sum_{s\inI}(a_s-b_s)(\alpha,\alpha_s)=\sum_{s\inI}(a_s-b_s)(\beta,\alpha_s)=(\beta,\alpha-\beta).\]</span> 即 <span class="math inline">\((\alpha,\beta)=1\)</span>。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理0.15</span>.</span><span class="statement-spah"></span>极小根集合是有限的。</p></div><p><strong>证明</strong>：我们来证明极小根的深度是有上界的。设 <span class="math inline">\(\beta\)</span> 是一个深度为 <span class="math inline">\(d\)</span> 的极小根，<span class="math inline">\(\beta_1\prec\cdots\prec\beta_d=\beta\)</span>是一个序列满足 <span class="math inline">\(\mathrm{dp}(\beta_i)=i\)</span>，则每个 <span class="math inline">\(\beta_i\)</span> 都是极小根。</p><p>记 <span class="math inline">\(J_i=\{\gamma\in\Delta \mid (\gamma,\beta_i)\geq-1\}\)</span>。我们来证明 <span class="math inline">\(\{J_i,1\leq i\leq d\}\)</span>是递降的，并且最终会降为空集。</p><p>对 <span class="math inline">\(1\leq i\leq d\)</span>，若 <span class="math inline">\(\gamma\notin J_i\)</span>，则 <span class="math inline">\(\gamma\)</span> 在所有 <span class="math inline">\(\beta_j(j\geq i)\)</span> 中的系数都相同。</p><p>设 <span class="math inline">\(\beta_i=\sum c_s\alpha_s,\,\beta_j=\sum d_s\alpha_s\)</span>，则 <span class="math inline">\(0\leqc_s\leq d_s\)</span> 且 <span class="math inline">\(c_\gamma=d_\gamma\)</span>。注意到 <span class="math inline">\((\beta_j,\gamma)=\sum_{s\in\Delta}d_s(\alpha_s,\gamma)\leq \sum_{s\in\Delta}c_s(\alpha_s, \gamma)=(\beta_i,\gamma)&lt;-1\)</span>。所以 <span class="math inline">\(\gamma\not\inJ_j\)</span>。即 <span class="math inline">\(\{J_i\}\)</span>确实是递降的。</p><p>设 <span class="math inline">\(J_i=\cdots=J_i=J\)</span> 对某个 <span class="math inline">\(i&lt;j\)</span> 成立。对任何 <span class="math inline">\(\gamma\in J\)</span> 和 <span class="math inline">\(i\leq k\leq j\)</span>，由于 <span class="math inline">\(\beta_k\)</span> 不能支配 <span class="math inline">\(\gamma\)</span>，所以 <span class="math inline">\(-1\leq (\beta,\gamma)\leq 1\)</span>，等于 1当且仅当 <span class="math inline">\(\beta=\gamma\)</span>。于是 <span class="math inline">\((\beta_k,\gamma)\in\mathcal{C}(S)\)</span>。于是如果<span class="math inline">\(j-i&gt;|\mathcal{C}(S)|^{|S|}\)</span>那么必然存在 <span class="math inline">\(i\leq m &lt; n\leq j\)</span>使得 <span class="math inline">\((\beta_m, J)=(\beta_n,J)\)</span>。（鸽笼原理，<span class="math inline">\(\beta\)</span>和一个单根的内积有 <span class="math inline">\(|c|\)</span>种不同的可能值，和所有单根的内积共有 <span class="math inline">\(c^{|S|}\)</span> 种不同的可能值）。</p><p>但是如果 <span class="math inline">\(\gamma\not\in J\)</span>，则<span class="math inline">\(\gamma\)</span> 在 <span class="math inline">\(\beta_m,\beta_n\)</span>中的系数相同，所以根据前面的引理 <span class="math inline">\((\beta_m,\beta_n)=1\)</span>，但这导致 <span class="math inline">\(\beta_n \,\mathrm{dom}\,\beta_m\)</span>，所以如果<span class="math inline">\(j-i&gt;c^{|S|}\)</span> 时 <span class="math inline">\(J_j\)</span> 必须比 <span class="math inline">\(J_i\)</span> 严格地小，所以整个链的长度有限，即<span class="math inline">\(d\)</span> 有限。</p><blockquote><p><strong>引理</strong>：设 <span class="math inline">\(\gamma\)</span>不是极小根，<span class="math inline">\(u,v\in W\)</span> 使得 <span class="math inline">\(u\gamma, v^{-1}\gamma\)</span> 都是单根，则 <span class="math inline">\(l(uv)\ne l(u)+l(v)\)</span>。</p></blockquote><p>证明：设 <span class="math inline">\(u\gamma=\alpha_s,v^{-1}\gamma=\alpha_t\)</span>，则<span class="math inline">\(\gamma\in N(su)\capN(tv^{-1})\)</span>。又设 <span class="math inline">\(\gamma\,\mathrm{dom}\,\beta\)</span>，则 <span class="math inline">\(\beta\in N(su)\cap N(tv^{-1})\)</span>。但是 <span class="math inline">\(u\beta\ne u\gamma=\alpha_s\)</span>，所以 <span class="math inline">\(su\beta\in\Phi^-\)</span> 说明 <span class="math inline">\(u\beta\in\Phi^-\)</span>。同理 <span class="math inline">\(v^{-1}\beta\in\Phi^-\)</span>，所以 <span class="math inline">\(N(u)\cap N(v^{-1})\)</span>非空，所以引理得证。</p><hr><p>设 <span class="math inline">\(\Sigma\)</span>是所有极小根组成的集合，则 <span class="math inline">\(|\Sigma|&lt;\infty\)</span> 是有限集。</p><p>定义状态机如下：</p><p>一个状态 <span class="math inline">\(S_i\subset\Sigma\)</span>是极小根的子集。转移 <span class="math inline">\(S_i\xrightarrow{s}S_{i+1}\)</span> 为：</p><ol type="1"><li>如果 <span class="math inline">\(s\in S_i\)</span> 则 <span class="math inline">\(S_i\xrightarrow{s}\mathrm{NO}\)</span>。</li><li>如果 <span class="math inline">\(s\notin S_i\)</span> 则 <span class="math inline">\(S_i\xrightarrow{s} (sS_i\cup \{\alpha_s\}\cup\{s\alpha_t,t&lt;s\})\cap\Sigma\)</span>。</li></ol><p>我们来证明这个状态机识别语言 <span class="math inline">\(\mathcal{L}\)</span>。</p><p>为方便我们记 <span class="math inline">\(\mathcal{R}_i=\{\alpha_s\in\Delta,s&lt;i\}\)</span> 是那些字典序下小于 <span class="math inline">\(\alpha_i\)</span> 的单根组成的集合。</p><p>假设 <span class="math inline">\(s_1\cdots s_l\in\mathcal{L}\)</span>，但是 <span class="math inline">\(s_1\cdotss_{l+1}\notin \mathcal{L}\)</span> 当且仅当 <span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。其中 <span class="math inline">\(S_i\subset\Sigma\)</span> 是状态机读入 <span class="math inline">\(s_i\)</span> 以后的状态。</p><p>我们来证明对任何 <span class="math inline">\(k\leq l\)</span> 有<span class="math display">\[S_k\subset\{(s_k\cdots s_{i+1})\alpha_i\mid1\leq i\leq l\}\cup\cup_{i=1}^{k}(s_k\cdotss_i)\cdot\mathcal{R}_i.\]</span> 首先 <span class="math inline">\(k=1\)</span> 时 <span class="math inline">\(S_1=\{\alpha_1\}\)</span>，</p><p>由于下一步读入 <span class="math inline">\(s_{l+1}\)</span>的时候是拒绝态，所以 <span class="math inline">\(\alpha_{l+1}\)</span>也属于上面的集合。</p><ul><li><p>如果 <span class="math inline">\(\alpha_{l+1}\in \{(s_l\cdotss_{i+1})\alpha_i\mid 1\leq i\leq l\}\)</span>，则 <span class="math inline">\(s_1\cdots s_ls_{l+1}\)</span> 不是既约的，所以不在<span class="math inline">\(\mathcal{L}\)</span> 中。</p></li><li><p>如果 <span class="math inline">\(\alpha_{l+1}\notin \{(s_l\cdotss_{i+1})\alpha_i\mid 1\leq i\leq l\}\)</span>，则 <span class="math inline">\(s_1\cdots s_ls_{l+1}\)</span> 是既约的，但是 <span class="math inline">\(\alpha_{l+1}\)</span> 形如 <span class="math inline">\(s_l\cdots s_{i}\alpha_r(r&lt;i)\)</span>，所以<span class="math inline">\(s_1\cdotss_{l+1}\notin\mathcal{L}\)</span>。</p></li></ul><p>反之，我们要证明如果 <span class="math inline">\(\mathcal{L}\)</span>拒绝一个字 <span class="math inline">\(w=s_1\cdots s_n\)</span>，设<span class="math inline">\(l\)</span> 是使得 <span class="math inline">\(\mathcal{L}\)</span> 接受 <span class="math inline">\(w\)</span> 的最大位置，则必有 <span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。用反证法，设 <span class="math inline">\(\alpha_{l+1}\notin S_l\)</span>。</p><ul><li><p>如果 <span class="math inline">\(s_1\cdots s_{l+1}\)</span>不是既约的，则存在 <span class="math inline">\(1\leq i\leq l\)</span>使得 <span class="math inline">\(\alpha_{l+1}=s_l\cdotss_{i+1}\alpha_i\)</span>。于是 <span class="math inline">\(l\)</span>在集合 <span class="math inline">\(\{i\leq k\leq l \mid (s_k\cdotss_{i+1})\alpha_i\notin S_k\}\)</span> 中。设 <span class="math inline">\(j\)</span> 是此集合的最小元素，<span class="math inline">\(\beta=s_j\cdots s_{i+1}\alpha_i\)</span>。由于<span class="math inline">\(\alpha_i\in S_i\)</span>，所以 <span class="math inline">\(j&gt;i\)</span>。于是 <span class="math inline">\(s_{j-1}\cdots s_{i+1}\alpha_i\inS_{j-1}\)</span>，<span class="math inline">\(\beta\ins_jS_{j-1}\)</span>。由于 <span class="math inline">\(s_j\cdotS_{j-1}\cap\Sigma\subset S_j\)</span> 这说明 <span class="math inline">\(\beta\)</span> 不是极小根。注意到 <span class="math inline">\((s_{i+1}\cdots s_j)\beta=\alpha_i\)</span> 和<span class="math inline">\((s_{j+1}\cdotss_l)^{-1}\beta=\alpha_{l+1}\)</span>，根据上面的引理 <span class="math inline">\(l(s_{r+1}\cdots s_l)\ne l-i\)</span>，这与 <span class="math inline">\(s_1\cdots s_l\in\mathcal{L}\)</span> 矛盾，所以<span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。</p></li><li><p>如果 <span class="math inline">\(s_1\cdots s_{l+1}\)</span>既约但不属于 <span class="math inline">\(\mathcal{L}\)</span>，则 <span class="math inline">\(\alpha_{l+1}=(s_l\cdotss_{i+1})\alpha_s(s&lt;i)\)</span>。设 <span class="math inline">\(i\leqj\leq l\)</span> 使得 <span class="math inline">\(\beta=(s_js_{j-1}\cdots s_i)\alpha_s\notinS_j\)</span>。如果 <span class="math inline">\(j\ne i\)</span>，则由于<span class="math inline">\(\{s_i\alpha_r\mid r&lt;i\}\cap\Sigma\subsetS_i\)</span> 这说明 <span class="math inline">\(\beta\)</span>不是极小根。若 <span class="math inline">\(j&gt;i\)</span> 同样可得<span class="math inline">\(\beta\)</span>不是极小根。于是根据上面同样的论证得出矛盾。</p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>欢迎来到 <strong>赵亮</strong>的个人网站。这个网站记录了我过去十几年零零散散写的一些关于数学和编程的文章。限于本人水平，其中难免有错误，还请读者不吝指正。</p><p>这个博客使用 <a href="https://hexo.io/">hexo</a> 搭建，<a href="https://pandoc.org/">Pandoc</a> 渲染，<a href="https://github.com/dialoa/statement">statement</a>生成自动编号的定理环境。主题修改自 <a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism">raytaylorism</a>。</p><p>转载文章和图片注明出处即可。所有代码均采用 <a href="https://opensource.org/licenses/MIT">MIT LICENSE</a>。</p><p><a href="/privacy">隐私政策</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群语言正则的证明</title>
      <link href="/coxeter-automatic/index.html"/>
      <url>/coxeter-automatic/index.html</url>
      
        <content type="html"><![CDATA[<div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义0.1</span>.</span><span class="statement-spah"> </span>对任何正根 <span class="math inline">\(\alpha\in\Phi^+\)</span>，定义其深度为 <span class="math display">\[\mathrm{dp}(\alpha)=\min\{\,l(w) \midw\alpha\in\Phi^-\,\}.\]</span> 对两个正根 <span class="math inline">\(\alpha,\beta\)</span>，定义 <span class="math inline">\(\alpha\preceq\beta\)</span> 当且仅当存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(\beta=w\alpha\)</span> 并且 <span class="math display">\[\mathrm{dp}(\beta)=\mathrm{dp}(\alpha)+l(w).\]</span>如果 <span class="math inline">\(\alpha\preceq\beta\)</span> 且 <span class="math inline">\(\alpha\ne\beta\)</span> 我们记为 <span class="math inline">\(\alpha\prec\beta\)</span>。</p></div><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha_s\)</span> 是单根，<span class="math inline">\(\beta\ne\alpha_s\)</span> 是正根，则 <span class="math display">\[\mathrm{dp}(s\beta)=\begin{cases}\mathrm{dp}(\beta)-1 &amp; \text{if } (\beta,\alpha_s)&gt;0,\\\mathrm{dp}(\beta)   &amp; \text{if } (\beta,\alpha_s)=0.\\\mathrm{dp}(\beta)+1 &amp; \text{if } (\beta,\alpha_s)&lt;0.\end{cases}\]</span></p></div><p>第二条是显然的，而第三条可以由第一条得出：只要对 <span class="math inline">\(s\alpha\)</span>应用第一条的结论即可。所以我们只需要证明第一条。</p><p>首先取 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(l(w)=\mathrm{dp}(\beta)\)</span> 且 <span class="math inline">\(w\beta\in\Phi^-\)</span>。</p><ol type="1"><li><p>如果 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>，则<span class="math inline">\(l(ws)=l(w)-1\)</span>。由于 <span class="math inline">\((ws)(s\beta)=w\beta&lt;0\)</span>，所以 <span class="math display">\[\mathrm{dp}(s\beta)\leq l(ws)=l(w)-1.\]</span>从而 <span class="math inline">\(\mathrm{dp}(s\beta)=l(w)-1=\mathrm{dp}(\beta)-1\)</span>。</p></li><li><p>如果 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>，则<span class="math display">\[w(s\beta)=w(\beta -2(\beta,\alpha_s)\alpha_s)=w\beta-cw\alpha_s (c&gt;0).\]</span> 可见<span class="math inline">\(w(s\beta)\)</span> 是负根。由于 <span class="math inline">\(\beta\ne\alpha_s\)</span>是不同的正根，所以它们不共线，从而 <span class="math inline">\(w\beta\)</span> 和 <span class="math inline">\(w\alpha_s\)</span>也不共线，于是上式是两个不共线的负根的和，所以任何单反射不能将 <span class="math inline">\(w(s\beta)\)</span> 变成正根。取 <span class="math inline">\(t\in S\)</span> 使得 <span class="math inline">\(l(tw)&lt;l(w)\)</span>，则 <span class="math inline">\(tw(s\beta)\)</span> 仍然是负根，所以 <span class="math display">\[\mathrm{dp}(s\beta)\leql(tw)=l(w)-1=\mathrm{dp}(\beta)-1.\]</span> 结论仍然得证。<span class="math inline">\(\blacksquare\)</span></p></li></ol><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.3</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha\preceq\beta\)</span>，则存在序列 <span class="math display">\[\alpha=\alpha_0\preceq\alpha_1\preceq\cdots\preceq\alpha_k=\beta\]</span>使得对每个 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(\mathrm{dp}(\alpha_{i+1})=\mathrm{dp}(\alpha_i)+1\)</span>。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(w=s_k\cdotss_1\)</span> 满足 <span class="math inline">\(\beta=w\alpha\)</span> 且<span class="math inline">\(l(w)=\mathrm{dp}(\beta)-\mathrm{dp}(\alpha)\)</span>，考虑<span class="math inline">\(\alpha_i=s_i\cdots s_1\alpha\)</span>，其中<span class="math inline">\(\alpha_0=\alpha\)</span>，<span class="math inline">\(\alpha_k=\beta\)</span>。从 <span class="math inline">\(\alpha_0\)</span> 到 <span class="math inline">\(\alpha_k\)</span> 经过了 <span class="math inline">\(k=l(w)\)</span> 次单反射，depth 增加了 <span class="math inline">\(l(w)\)</span>，但上面的引理告诉我们每次单反射depth 至多增加 1，所以只能是每一项的 depth 都比前一项增加了1，即得结论。</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.4</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha\preceq\beta\)</span>，且 <span class="math inline">\(\alpha=\sum c_s\alpha_s,\, \beta=\sumd_s\alpha_s\)</span>，则对每个 <span class="math inline">\(s\)</span> 有<span class="math inline">\(c_s\leq d_s\)</span>。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(\beta=s\alpha\)</span> 则 <span class="math inline">\(\alpha,\beta\)</span> 只有在 <span class="math inline">\(\alpha_s\)</span> 项的系数不同。又 <span class="math inline">\((\alpha,\alpha_s)&lt;0\)</span> 所以 <span class="math inline">\(d_s&gt;c_s\)</span> 得证。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义0.5</span>.</span><span class="statement-spah"> </span>对 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span>，如果对任何 <span class="math inline">\(w\in W\)</span> 都有 <span class="math inline">\(w\alpha\in\Phi^-\Rightarroww\beta\in\Phi^-\)</span>，我们就称 <span class="math inline">\(\alpha\)</span> 支配 <span class="math inline">\(\beta\)</span>，记作 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>。</p></div><p>由于 <span class="math inline">\(w\alpha\in\Phi^-\)</span> 等价于<span class="math inline">\((w\alpha,\mathcal{D})=(\alpha,w^{-1}\mathcal{D})&lt;0\)</span>，所以这个定义也可以表述为： <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span> 当且仅当<span class="math inline">\((\alpha, w\mathcal{D})&lt;0\Rightarrow(\beta, w\mathcal{D})&lt;0\)</span> 对任何 <span class="math inline">\(w\in W\)</span> 成立。即任何落在镜子 <span class="math inline">\(\alpha\)</span> 背面的房间，也必然落在镜子 <span class="math inline">\(\beta\)</span> 的背面。这意味着镜子 <span class="math inline">\(\beta\)</span> 完全挡在镜子 <span class="math inline">\(\alpha\)</span> 和基本区域 <span class="math inline">\(\mathcal{D}\)</span> 之间，任何从 <span class="math inline">\(\mathcal{D}\)</span> 出发走到 <span class="math inline">\(\alpha\)</span> 背面的路径都必须先穿过 <span class="math inline">\(\beta\)</span>。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.6</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span> 且 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>，则：</p><ol type="1"><li><span class="math inline">\((\alpha,\beta)&gt;0\)</span>。</li><li>若 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\beta\)</span> 是正根，则 <span class="math inline">\(w\alpha\,\mathrm{dom}\,w\beta\)</span>。</li><li>若 <span class="math inline">\(\alpha\prec\alpha'\)</span> 则<span class="math inline">\(\alpha'\)</span>不是极小根。换句话说，若一个根是极小根，则在偏序 <span class="math inline">\(\preceq\)</span> 下小于它的根也都是极小根。</li><li><span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>，等号当且仅当<span class="math inline">\(\alpha=\beta\)</span> 时成立。</li></ol></div><p><strong>证明</strong>：</p><ol type="1"><li><p><span class="math inline">\(r_\alpha\)</span> 满足 <span class="math inline">\(r_\alpha\alpha=-\alpha\in\Phi^-\)</span>，所以<span class="math inline">\(r_\alpha\beta=\beta-2(\alpha,\beta)\alpha&lt;0\)</span>，这必须<span class="math inline">\((\alpha,\beta)&gt;0\)</span> 才行。</p></li><li><p>显然。</p></li><li><p>只要对 <span class="math inline">\(\mathrm{dp}(\alpha')=\mathrm{dp}(\alpha)+1\)</span>进行证明即可。这时存在单反射 <span class="math inline">\(s\)</span> 使得<span class="math inline">\(\alpha'=s\alpha\)</span>，并且 <span class="math inline">\((\alpha_s,\alpha)&lt;0\)</span>。<span class="math inline">\((\alpha,\beta)&gt;0\)</span> 说明 <span class="math inline">\(\beta\ne\alpha_s\)</span>，从而 <span class="math inline">\(s\beta\)</span> 是正根，从而 <span class="math inline">\(\alpha'=s\alpha\,\mathrm{dom}\,s\beta\)</span>不是极小根。</p></li><li><p><span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>显然意味着 <span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>。设<span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\alpha=-\alpha_s\)</span> 是某个负的单根，则<span class="math inline">\(w\beta\in\Phi^-\)</span>。注意这时 <span class="math inline">\(w^{-1}\alpha_s=-\alpha&lt;0\)</span>，所以 <span class="math inline">\(l(sw)&lt;l(w)\)</span>。</p><ul><li><p>若 <span class="math inline">\(sw\beta\in\Phi^+\)</span>，则由<span class="math inline">\(w\beta&lt;0\)</span> 可知 <span class="math inline">\(w\beta=-\alpha_s\)</span>，再结合 <span class="math inline">\(w\alpha=-\alpha_s\)</span> 可得 <span class="math inline">\(\alpha=\beta\)</span>。</p></li><li><p>若 <span class="math inline">\(sw\beta\in\Phi^-\)</span>，则<span class="math inline">\(\mathrm{dp}(\beta)\leql(sw)&lt;\mathrm{dp}(\alpha)\)</span>。</p></li></ul></li></ol><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.7</span>.</span><span class="statement-spah"> </span>在有限 Coxeter群中，所有根都是极小根。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(w_0\)</span>是最长元，则 <span class="math inline">\(\alpha\to -w_0(\alpha)\)</span>置换 <span class="math inline">\(\Phi^+\)</span>。我们来验证这个置换保持每个正根的深度不变：若<span class="math inline">\(w\alpha&lt;0\)</span>，则 <span class="math inline">\(w_0w\alpha&gt;0\)</span>，从而 <span class="math inline">\((w_0ww_0)(-w_0\alpha)&lt;0\)</span>，这说明 <span class="math inline">\(\mathrm{dp}(-w_0\alpha)\leql(w_0ww_0)=l(w)\)</span>。对 <span class="math inline">\(-w_0\alpha\)</span> 应用此结论可得 <span class="math inline">\(\mathrm{dp}(\alpha)\leq\mathrm{dp}(-w_0\alpha)\)</span>。从而二者相等。</p><p>另一方面我们来验证它翻转 <span class="math inline">\(\,\mathrm{dom}\,\)</span> 这个偏序：若 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>，则 <span class="math display">\[\begin{aligned}w\alpha&lt;0&amp;\Rightarrow w\beta&lt;0\\&amp;\Downarrow\\w\beta &gt; 0&amp;\Rightarrow w\alpha&gt;0\\&amp;\Downarrow\\ww_0\beta &gt; 0&amp;\Rightarrow ww_0\alpha&gt;0\\&amp;\Downarrow\\w(-w_0\beta) &lt; 0&amp;\Rightarrow w(-w_0\alpha)&lt;0\\\end{aligned}\]</span> 即确实有 <span class="math inline">\(-w_0\beta\,\mathrm{dom}\,-w_0\alpha\)</span>。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.8</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span> 的充要条件是<span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>且 <span class="math inline">\((\alpha,\beta)\geq1\)</span>。</p></div><p><strong>证明</strong>：我们只考虑 <span class="math inline">\(\alpha\ne\beta\)</span> 的情形即可。</p><p><span class="math inline">\(\Rightarrow\)</span>：只要再证明 <span class="math inline">\((\alpha,\beta)\geq1\)</span>。用反证法，若不然，则<span class="math inline">\(0&lt;(\alpha,\beta)&lt;1\)</span>，从而<span class="math inline">\(r_\alpha,r_\beta\)</span>生成一个有限二面体群 <span class="math inline">\(D\)</span>。由于在有限群中没有支配关系，所以存在<span class="math inline">\(w\in D\)</span> 使得 <span class="math inline">\(w\alpha\in\Phi^-,\,w\beta\in\Phi^+\)</span>。这与<span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>矛盾。</p><p><span class="math inline">\(\Leftarrow\)</span>：我们先考虑 <span class="math inline">\(\beta=\alpha_s\)</span> 是一个单根的情形。由于<span class="math inline">\(\alpha\ne\beta\)</span> 所以 <span class="math inline">\(s\alpha\)</span> 仍然是正根。我们发现 <span class="math display">\[(\alpha,s\alpha)=(\alpha,\alpha-2(\alpha,\alpha_s)\alpha_s)=1-2(\alpha,\alpha_s)^2\leq-1.\]</span> 所以有无穷多个形如 <span class="math inline">\(a\alpha+b\alpha_s\)</span> 的正根，其中 <span class="math inline">\(a,b&gt;0\)</span>。</p><p>用反证法，如果 <span class="math inline">\(\alpha\)</span> 不支配<span class="math inline">\(\beta=\alpha_s\)</span>，则存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\alpha\in\Phi^-\)</span> 但 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>。由于 <span class="math display">\[w(s\alpha)=w\alpha -2(\alpha,\alpha_s)w\alpha_s\]</span> 是负根 <span class="math inline">\(w\alpha\)</span> 减去正根 <span class="math inline">\(w\alpha_s\)</span>的一个正倍数，必然仍然是负根。于是 <span class="math inline">\(\{\alpha,s\alpha\}\subsetN(w)\)</span>，从而所有形如 <span class="math inline">\(\{a\alpha+bs\alpha\mid a,b&gt;0\}\)</span>的根都在 <span class="math inline">\(N(w)\)</span> 中，这与 <span class="math inline">\(|N(w)|=l(w)&lt;\infty\)</span> 矛盾。</p><p>对 <span class="math inline">\(\beta\)</span> 是一般正根的情形，取<span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\beta\in\Delta\)</span>，<span class="math inline">\(l(w)=\mathrm{dp}(\beta)-1\)</span>。由于 <span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>所以 <span class="math inline">\(w\alpha\)</span> 仍然是正根，当然就有<span class="math inline">\(\mathrm{dp}(w\alpha)\geq\mathrm{dp}(w\beta)=1\)</span>和 <span class="math inline">\((w\alpha,w\beta)=(\alpha,\beta)\geq1\)</span>。根据上面的证明，<span class="math inline">\(w\alpha\,\mathrm{dom}\,w\beta\)</span>，所以 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.9</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\lambda,\mu\)</span> 是正根，且 <span class="math inline">\(s_\lambda,s_\mu\)</span>生成一个无限群，则下面三种情况必居其一：</p><ol type="1"><li><span class="math inline">\(\lambda\,\mathrm{dom}\,\mu\)</span>.</li><li><span class="math inline">\(\mu\,\mathrm{dom}\,\lambda\)</span>.</li><li><span class="math inline">\(s_\mu\lambda\,\mathrm{dom}\,\mu\)</span>且 <span class="math inline">\(s_\lambda\mu\,\mathrm{dom}\,\lambda\)</span>.</li></ol></div><p><strong>证明</strong>：<span class="math inline">\(s_\lambda,s_\mu\)</span> 生成一个无限群说明 <span class="math inline">\(|(\lambda,\mu)|\geq1\)</span>。如果 <span class="math inline">\((\lambda,\mu)\geq1\)</span> 那么 <span class="math inline">\(\lambda,\mu\)</span> 中 depth更大的那一个支配另一个。</p><p>如果 <span class="math inline">\((\lambda,\mu)\leq-1\)</span>我们来证明 <span class="math inline">\(s_\mu\lambda\,\mathrm{dom}\,\mu\)</span>，<span class="math inline">\(s_\lambda\mu\,\mathrm{dom}\,\lambda\)</span>的论证是一样的。注意到这时 <span class="math inline">\((s_\mu\lambda,\mu)=-(\lambda,\mu)\geq1\)</span>，所以只要再证明 <span class="math inline">\(\mathrm{dp}(s_\mu\lambda)\geq\mathrm{dp}(\mu)\)</span> 即可。</p><p>设 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w(s_\mu\lambda)&lt;0\)</span> 且 <span class="math inline">\(l(w)=\mathrm{dp}(s_\mu\lambda)\)</span>，我们来证明必有一个长度<span class="math inline">\(l(w')\leq l(w)\)</span> 的元素 <span class="math inline">\(w'\)</span> 使得 <span class="math inline">\(w'\mu&lt;0\)</span>，从而 <span class="math inline">\(\mathrm{dp}(s_\mu\lambda)\geq\mathrm{dp}(\mu)\)</span>。</p><p>首先若 <span class="math inline">\(w\mu&lt;0\)</span> 则可以取 <span class="math inline">\(w'=w\)</span>。否则若 <span class="math inline">\(w\mu&gt;0\)</span>，我们来计算 <span class="math display">\[w(s_\mu\lambda)=w\lambda-2(\mu,\lambda)w\mu.\]</span>我们知道这是一个负根，而且它是 <span class="math inline">\(w\lambda\)</span> 加上正根 <span class="math inline">\(w\mu\)</span> 的正倍数，所以必须 <span class="math inline">\(w\lambda&lt;0\)</span>，从而 <span class="math inline">\(l(ws_\lambda)&lt;l(w)\)</span>。</p><p>进一步我们计算 <span class="math display">\[(ws_\lambda)\mu=w\mu-2(\mu,\lambda)w\lambda.\]</span>我们来证明 <span class="math inline">\((ws_\lambda)\mu\)</span>是一个负根，从而 <span class="math inline">\(\mathrm{dp}(\mu)\leql(ws_\lambda)&lt;l(w)=\mathrm{dp}(s_\mu\lambda)\)</span>。</p><p>若不然，记 <span class="math inline">\(c=-2(\mu,\lambda)\geq2\)</span>，若 <span class="math inline">\((ws_\lambda)\mu=w\mu+cw\lambda&gt;0\)</span>，乘以<span class="math inline">\(c\)</span> 得到 <span class="math inline">\(cw\mu+c^2w\lambda\)</span>是正根的非负线性组合（未必还是根），根据上面 <span class="math inline">\(w\lambda+cw\mu&lt;0\)</span>，减去后者得到 <span class="math inline">\((c^2-1)w\lambda\)</span> 是正根的非负线性组合，但<span class="math inline">\(c^2-1\geq 3\)</span>，这与 <span class="math inline">\(w\lambda&lt;0\)</span> 矛盾。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.10</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span> 满足 <span class="math inline">\(\beta\preceq\alpha\)</span>，并且 <span class="math inline">\(\alpha\)</span> 是极小根。进一步设 <span class="math inline">\(\alpha_s\in\Delta\)</span> 满足 <span class="math inline">\((\beta,\alpha_s)\leq-1\)</span>，则 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> 的 <span class="math inline">\(\alpha_s\)</span> 项的系数相等。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(\beta\preceq\gamma\preceq\alpha\)</span> 使得<span class="math inline">\(\gamma\)</span> 是偏序 <span class="math inline">\(\preceq\)</span> 下最大的与 <span class="math inline">\(\beta\)</span> 有相同的 <span class="math inline">\(\alpha_s\)</span> 项系数。如果 <span class="math inline">\(\gamma\ne\alpha\)</span>，则存在 <span class="math inline">\(t\)</span> 使得 <span class="math inline">\(\gamma\prec t\gamma\preceq\alpha\)</span>。由<span class="math inline">\(\gamma\)</span> 的极大性可得 <span class="math inline">\(s=t\)</span>。</p><p>但是 <span class="math inline">\(\gamma-\beta=\sum_{t\nes}c_t\alpha_t\)</span>，且每个 <span class="math inline">\(c_t\geq0\)</span>。因此 <span class="math display">\[(s\gamma,\alpha_s)=(\gamma,-\alpha_s)=-(\beta,\alpha_s)-\sum_{t\ner}c_t(\alpha_t,\alpha_s)\geq1.\]</span> 于是 <span class="math inline">\(s\gamma\,\mathrm{dom}\,\alpha_s\)</span>不是极小根，从而 <span class="math inline">\(\alpha\succeqs\gamma\)</span> 也不是极小根。矛盾！所以 <span class="math inline">\(\gamma=\alpha\)</span>，从而命题得证。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.11</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi\)</span> 满足 <span class="math inline">\(|(\alpha,\beta)|\leq 1\)</span>，则这样的 <span class="math inline">\((\alpha,\beta)\)</span> 只有有限多个值。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(|(\alpha,\beta)|&lt;1\)</span> 则 <span class="math inline">\(r_\alpha,r_\beta\)</span> 生成的子群 <span class="math inline">\(D\)</span> 是有限的，所以存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(wDw^{-1}\)</span> 属于某个有限的标准椭圆子群 <span class="math inline">\(W_J\)</span>，特别地，<span class="math inline">\(r_\alpha r_\beta\)</span> 的阶 <span class="math inline">\(m\)</span> 应该整除 <span class="math inline">\(W_J\)</span> 的阶，从而 <span class="math inline">\((\alpha,\beta)\)</span> 形如 <span class="math inline">\(\cos(a\pi/m)\)</span>，其中 <span class="math inline">\(0\leq a\leq 2m\)</span> 而且 <span class="math inline">\(m\)</span>是某个有限标准椭圆子群的阶的因子。由于这样的子群是有限的，所以这样的<span class="math inline">\(\cos\)</span> 值也是有限的。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.12</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha=\sum a_s\alpha_s\)</span> 和 <span class="math inline">\(\beta=\sum b_s\alpha_s\)</span> 都是正根。进一步设<span class="math inline">\(S=I\cup J\)</span> 使得</p><ol type="1"><li>对任何 <span class="math inline">\(t\in I\)</span> 有 <span class="math inline">\((\alpha,\alpha_t)=(\beta,\beta_t)\)</span>。</li><li><span class="math inline">\(c_t=b_t\)</span> 对任何 <span class="math inline">\(t\in J\)</span> 成立。</li></ol><p>则 <span class="math inline">\((\alpha,\beta)=1\)</span>。</p></div><p>注意这里 <span class="math inline">\(I\)</span> 或者 <span class="math inline">\(J\)</span> 允许有一个是空集。</p><p><strong>证明</strong>：我们有 <span class="math inline">\(\alpha-\beta=\sum_{s\inI}(a_s-b_s)\alpha_s\)</span>，所以 <span class="math display">\[(\alpha,\alpha-\beta)=\sum_{s\inI}(a_s-b_s)(\alpha,\alpha_s)=\sum_{s\inI}(a_s-b_s)(\beta,\alpha_s)=(\beta,\alpha-\beta).\]</span> 即 <span class="math inline">\((\alpha,\beta)=1\)</span>。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理0.13</span>.</span><span class="statement-spah"></span>极小根集合是有限的。</p></div><p><strong>证明</strong>：我们来证明极小根的深度是有上界的。设 <span class="math inline">\(\beta\)</span> 是一个深度为 <span class="math inline">\(d\)</span> 的极小根，<span class="math inline">\(\beta_1\prec\cdots\prec\beta_d=\beta\)</span>是一个序列满足 <span class="math inline">\(\mathrm{dp}(\beta_i)=i\)</span>，则每个 <span class="math inline">\(\beta_i\)</span> 都是极小根。</p><p>记 <span class="math inline">\(J_i=\{\gamma\in\Delta \mid (\gamma,\beta_i)\geq-1\}\)</span>。我们来证明 <span class="math inline">\(\{J_i,1\leq i\leq d\}\)</span>是递降的，并且最终会降为空集。</p><p>对 <span class="math inline">\(1\leq i\leq d\)</span>，若 <span class="math inline">\(\gamma\notin J_i\)</span>，则 <span class="math inline">\(\gamma\)</span> 在所有 <span class="math inline">\(\beta_j(j\geq i)\)</span> 中的系数都相同。</p><p>设 <span class="math inline">\(\beta_i=\sum c_s\alpha_s,\,\beta_j=\sum d_s\alpha_s\)</span>，则 <span class="math inline">\(0\leqc_s\leq d_s\)</span> 且 <span class="math inline">\(c_\gamma=d_\gamma\)</span>。注意到 <span class="math inline">\((\beta_j,\gamma)=\sum_{s\in\Delta}d_s(\alpha_s,\gamma)\leq \sum_{s\in\Delta}c_s(\alpha_s, \gamma)=(\beta_i,\gamma)&lt;-1\)</span>。所以 <span class="math inline">\(\gamma\not\inJ_j\)</span>。即 <span class="math inline">\(\{J_i\}\)</span>确实是递降的。</p><p>设 <span class="math inline">\(J_i=\cdots=J_i=J\)</span> 对某个 <span class="math inline">\(i&lt;j\)</span> 成立。对任何 <span class="math inline">\(\gamma\in J\)</span> 和 <span class="math inline">\(i\leq k\leq j\)</span>，由于 <span class="math inline">\(\beta_k\)</span> 不能支配 <span class="math inline">\(\gamma\)</span>，所以 <span class="math inline">\(-1\leq (\beta,\gamma)\leq 1\)</span>，等于 1当且仅当 <span class="math inline">\(\beta=\gamma\)</span>。于是 <span class="math inline">\((\beta_k,\gamma)\in\mathcal{C}(S)\)</span>。于是如果<span class="math inline">\(j-i&gt;|\mathcal{C}(S)|^{|S|}\)</span>那么必然存在 <span class="math inline">\(i\leq m &lt; n\leq j\)</span>使得 <span class="math inline">\((\beta_m, J)=(\beta_n,J)\)</span>。（鸽笼原理，<span class="math inline">\(\beta\)</span>和一个单根的内积有 <span class="math inline">\(|c|\)</span>种不同的可能值，和所有单根的内积共有 <span class="math inline">\(c^{|S|}\)</span> 种不同的可能值）。</p><p>但是如果 <span class="math inline">\(\gamma\not\in J\)</span>，则<span class="math inline">\(\gamma\)</span> 在 <span class="math inline">\(\beta_m,\beta_n\)</span>中的系数相同，所以根据前面的引理 <span class="math inline">\((\beta_m,\beta_n)=1\)</span>，但这导致 <span class="math inline">\(\beta_n \,\mathrm{dom}\,\beta_m\)</span>，所以如果<span class="math inline">\(j-i&gt;c^{|S|}\)</span> 时 <span class="math inline">\(J_j\)</span> 必须比 <span class="math inline">\(J_i\)</span> 严格地小，所以整个链的长度有限，即<span class="math inline">\(d\)</span> 有限。</p><blockquote><p><strong>引理</strong>：设 <span class="math inline">\(\gamma\)</span>不是极小根，<span class="math inline">\(u,v\in W\)</span> 使得 <span class="math inline">\(u\gamma, v^{-1}\gamma\)</span> 都是单根，则 <span class="math inline">\(l(uv)\ne l(u)+l(v)\)</span>。</p></blockquote><p>证明：设 <span class="math inline">\(u\gamma=\alpha_s,v^{-1}\gamma=\alpha_t\)</span>，则<span class="math inline">\(\gamma\in N(su)\capN(tv^{-1})\)</span>。又设 <span class="math inline">\(\gamma\,\mathrm{dom}\,\beta\)</span>，则 <span class="math inline">\(\beta\in N(su)\cap N(tv^{-1})\)</span>。但是 <span class="math inline">\(u\beta\ne u\gamma=\alpha_s\)</span>，所以 <span class="math inline">\(su\beta\in\Phi^-\)</span> 说明 <span class="math inline">\(u\beta\in\Phi^-\)</span>。同理 <span class="math inline">\(v^{-1}\beta\in\Phi^-\)</span>，所以 <span class="math inline">\(N(u)\cap N(v^{-1})\)</span>非空，所以引理得证。</p><hr><p>设 <span class="math inline">\(\Sigma\)</span>是所有极小根组成的集合，则 <span class="math inline">\(|\Sigma|&lt;\infty\)</span> 是有限集。</p><p>定义状态机如下：</p><p>一个状态 <span class="math inline">\(S_i\subset\Sigma\)</span>是极小根的子集。转移 <span class="math inline">\(S_i\xrightarrow{s}S_{i+1}\)</span> 为：</p><ol type="1"><li>如果 <span class="math inline">\(s\in S_i\)</span> 则 <span class="math inline">\(S_i\xrightarrow{s}\mathrm{NO}\)</span>。</li><li>如果 <span class="math inline">\(s\notin S_i\)</span> 则 <span class="math inline">\(S_i\xrightarrow{s} (sS_i\cup \{\alpha_s\}\cup\{s\alpha_t,t&lt;s\})\cap\Sigma\)</span>。</li></ol><p>我们来证明这个状态机识别语言 <span class="math inline">\(\mathcal{L}\)</span>。</p><p>为方便我们记 <span class="math inline">\(\mathcal{R}_i=\{\alpha_s\in\Delta,s&lt;i\}\)</span> 是那些字典序下小于 <span class="math inline">\(\alpha_i\)</span> 的单根组成的集合。</p><p>假设 <span class="math inline">\(s_1\cdots s_l\in\mathcal{L}\)</span>，但是 <span class="math inline">\(s_1\cdotss_{l+1}\notin \mathcal{L}\)</span> 当且仅当 <span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。其中 <span class="math inline">\(S_i\subset\Sigma\)</span> 是状态机读入 <span class="math inline">\(s_i\)</span> 以后的状态。</p><p>我们来证明对任何 <span class="math inline">\(k\leq l\)</span> 有<span class="math display">\[S_k\subset\{(s_k\cdots s_{i+1})\alpha_i\mid1\leq i\leq l\}\cup\cup_{i=1}^{k}(s_k\cdotss_i)\cdot\mathcal{R}_i.\]</span> 首先 <span class="math inline">\(k=1\)</span> 时 <span class="math inline">\(S_1=\{\alpha_1\}\)</span>，</p><p>由于下一步读入 <span class="math inline">\(s_{l+1}\)</span>的时候是拒绝态，所以 <span class="math inline">\(\alpha_{l+1}\)</span>也属于上面的集合。</p><ul><li><p>如果 <span class="math inline">\(\alpha_{l+1}\in \{(s_l\cdotss_{i+1})\alpha_i\mid 1\leq i\leq l\}\)</span>，则 <span class="math inline">\(s_1\cdots s_ls_{l+1}\)</span> 不是既约的，所以不在<span class="math inline">\(\mathcal{L}\)</span> 中。</p></li><li><p>如果 <span class="math inline">\(\alpha_{l+1}\notin \{(s_l\cdotss_{i+1})\alpha_i\mid 1\leq i\leq l\}\)</span>，则 <span class="math inline">\(s_1\cdots s_ls_{l+1}\)</span> 是既约的，但是 <span class="math inline">\(\alpha_{l+1}\)</span> 形如 <span class="math inline">\(s_l\cdots s_{i}\alpha_r(r&lt;i)\)</span>，所以<span class="math inline">\(s_1\cdotss_{l+1}\notin\mathcal{L}\)</span>。</p></li></ul><p>反之，我们要证明如果 <span class="math inline">\(\mathcal{L}\)</span>拒绝一个字 <span class="math inline">\(w=s_1\cdots s_n\)</span>，设<span class="math inline">\(l\)</span> 是使得 <span class="math inline">\(\mathcal{L}\)</span> 接受 <span class="math inline">\(w\)</span> 的最大位置，则必有 <span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。用反证法，设 <span class="math inline">\(\alpha_{l+1}\notin S_l\)</span>。</p><ul><li><p>如果 <span class="math inline">\(s_1\cdots s_{l+1}\)</span>不是既约的，则存在 <span class="math inline">\(1\leq i\leq l\)</span>使得 <span class="math inline">\(\alpha_{l+1}=s_l\cdotss_{i+1}\alpha_i\)</span>。于是 <span class="math inline">\(l\)</span>在集合 <span class="math inline">\(\{i\leq k\leq l \mid (s_k\cdotss_{i+1})\alpha_i\notin S_k\}\)</span> 中。设 <span class="math inline">\(j\)</span> 是此集合的最小元素，<span class="math inline">\(\beta=s_j\cdots s_{i+1}\alpha_i\)</span>。由于<span class="math inline">\(\alpha_i\in S_i\)</span>，所以 <span class="math inline">\(j&gt;i\)</span>。于是 <span class="math inline">\(s_{j-1}\cdots s_{i+1}\alpha_i\inS_{j-1}\)</span>，<span class="math inline">\(\beta\ins_jS_{j-1}\)</span>。由于 <span class="math inline">\(s_j\cdotS_{j-1}\cap\Sigma\subset S_j\)</span> 这说明 <span class="math inline">\(\beta\)</span> 不是极小根。注意到 <span class="math inline">\((s_{i+1}\cdots s_j)\beta=\alpha_i\)</span> 和<span class="math inline">\((s_{j+1}\cdotss_l)^{-1}\beta=\alpha_{l+1}\)</span>，根据上面的引理 <span class="math inline">\(l(s_{r+1}\cdots s_l)\ne l-i\)</span>，这与 <span class="math inline">\(s_1\cdots s_l\in\mathcal{L}\)</span> 矛盾，所以<span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。</p></li><li><p>如果 <span class="math inline">\(s_1\cdots s_{l+1}\)</span>既约但不属于 <span class="math inline">\(\mathcal{L}\)</span>，则 <span class="math inline">\(\alpha_{l+1}=(s_l\cdotss_{i+1})\alpha_s(s&lt;i)\)</span>。设 <span class="math inline">\(i\leqj\leq l\)</span> 使得 <span class="math inline">\(\beta=(s_js_{j-1}\cdots s_i)\alpha_s\notinS_j\)</span>。如果 <span class="math inline">\(j\ne i\)</span>，则由于<span class="math inline">\(\{s_i\alpha_r\mid r&lt;i\}\cap\Sigma\subsetS_i\)</span> 这说明 <span class="math inline">\(\beta\)</span>不是极小根。若 <span class="math inline">\(j&gt;i\)</span> 同样可得<span class="math inline">\(\beta\)</span>不是极小根。于是根据上面同样的论证得出矛盾。</p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（七）：极小根与正则语言性质</title>
      <link href="/coxeter-groups/coxeter-automata.html"/>
      <url>/coxeter-groups/coxeter-automata.html</url>
      
        <content type="html"><![CDATA[<div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.1</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha,\beta\in\Phi\)</span> 满足 <span class="math inline">\(|(\alpha,\beta)|&lt;1\)</span>，则必然有 <span class="math inline">\((\alpha,\beta)=\cos(p\pi/q)\)</span>，其中 <span class="math inline">\(p,q\)</span> 是互素的正整数，而且反射 <span class="math inline">\(s_\alpha,s_\beta\)</span>生成的二面体群是有限群。</p></div><p><strong>证明</strong>：由已知，内积限制在二维平面 <span class="math inline">\(U=\mathrm{span}{\{\alpha,\beta\}}\)</span>上是正定的。所以 <span class="math inline">\(V=U\oplusU^\bot\)</span>。</p><p>我们可以不妨假定 <span class="math inline">\(\alpha\)</span>是正根，以及 <span class="math inline">\(\beta=\alpha_s\)</span>是单根。设 <span class="math display">\[\alpha = c_s\alpha_s +\sum_{t\ne s }c_t\alpha_t.\]</span> 由于 <span class="math inline">\(\alpha\)</span> 不可能与 <span class="math inline">\(\beta=\alpha_s\)</span> 共线，所以 <span class="math inline">\(\gamma=\alpha - c_s\alpha_s\in U\)</span> 且 <span class="math inline">\(\gamma\ne0\)</span>。</p><p>注意到如果 <span class="math inline">\(a,b\in\mathbb{R}\)</span> 使得<span class="math inline">\(a\gamma+b\alpha_s\in\Phi\)</span>，则 <span class="math inline">\(a,b\)</span> 必须同时非负，或者同时非正。如果<span class="math inline">\(\alpha,\beta\)</span> 所夹的角度是 <span class="math inline">\(\pi\)</span> 的无理数倍，那么 <span class="math inline">\(s_\alpha s_\beta\)</span> 是 <span class="math inline">\(U\)</span> 上角度为 <span class="math inline">\(\pi\)</span> 的无理数倍的旋转，它的各次幂会将<span class="math inline">\(\alpha\)</span> 映射为 <span class="math inline">\(U\)</span>中单位圆周上稠密的集合，特别地必然有某个 <span class="math inline">\(k\)</span> 使得 <span class="math inline">\((s_\alpha s_\beta)^k\alpha\)</span> 位于扇形区域<span class="math inline">\(\{a\gamma+b\alpha_s\mid a &gt; 0,b&lt;0\}\)</span> 中，这与此区域不包含任何根矛盾。所以 <span class="math inline">\(\alpha,\beta\)</span> 所夹的角度必须是 <span class="math inline">\(\pi\)</span> 的有理数倍，形如 <span class="math inline">\(p\pi/q\)</span>，从而 <span class="math inline">\(s_\alpha,s_\beta\)</span> 生成一个有限二面体群<span class="math inline">\(D\)</span>。又因为 <span class="math inline">\(D\)</span> 作用在 <span class="math inline">\(U^\bot\)</span> 上是平凡的，所以 <span class="math inline">\(D\)</span> 在全空间上的作用也是有限二面体群。<span class="math inline">\(\blacksquare\)</span></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（一）：抽象 Coxeter 群与几何实现</title>
      <link href="/coxeter-groups/geometric-realization.html"/>
      <url>/coxeter-groups/geometric-realization.html</url>
      
        <content type="html"><![CDATA[<h1 id="抽象-coxeter-群">抽象 Coxeter 群</h1><p>设 <span class="math inline">\(S\)</span> 是一个集合，一个基于 <span class="math inline">\(S\)</span> 的 Coxeter 矩阵 <span class="math inline">\(M=(m_{s,t})_{s,t\in S}\)</span>是一个对称矩阵，其对角线上都是 1，非对角线元素取值于 <span class="math inline">\(\{2,3,\ldots,\infty\}\)</span>。<span class="math inline">\(|S|\)</span> 叫做 <span class="math inline">\(M\)</span> 的秩 (rank)。在这个系列中我们只考虑<span class="math inline">\(|S|&lt;\infty\)</span> 的情形。</p><p>矩阵 <span class="math inline">\(M\)</span> 确定了一个有限表现群<span class="math inline">\(W\)</span>，其生成元为集合 <span class="math inline">\(S\)</span>，群表现如下： <span class="math display">\[W = \langle s\in S\ |\ (st)^{m_{s,t}}=1\ {\rmif}\ m_{s,t}&lt;\infty\rangle.\]</span></p><p>也就是说，<span class="math inline">\(S\)</span>满足以下的生成关系：</p><ol type="1"><li>对任何 <span class="math inline">\(s\in S\)</span> 有 <span class="math inline">\(s^2=1\)</span>。</li><li>对任何 <span class="math inline">\(s\ne t\)</span> 且 <span class="math inline">\(m_{s,t}&lt;\infty\)</span>有<strong>辫关系</strong> (braid relation) <span class="math display">\[\overbrace{sts\cdots}^{m_{s,t}}=\overbrace{tst\cdots}^{m_{s,t}}\]</span>成立。（当 <span class="math inline">\(m_{s,t}=\infty\)</span>时不引入任何关系）</li></ol><p>我们称 <span class="math inline">\((W, S)\)</span> 是一个<strong>Coxeter 系</strong>，<span class="math inline">\(W\)</span>是一个<strong>有限生成 Coxeter 群</strong>。</p><span id="more"></span><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>我们总是用 <span class="math inline">\((W,S)\)</span> 来表示一个Coxeter 群。即在提到一个 Coxeter 群 <span class="math inline">\(W\)</span> 时，需要同时指明其生成元集合 <span class="math inline">\(S\)</span>。这是因为，可能存在不同的集合 <span class="math inline">\(S\)</span>，它们给出同一个 <span class="math inline">\(W\)</span>。但是像长度函数 <span class="math inline">\(l(w)\)</span>、根系、Bruhat序这些重要的概念，只有在指定生成元集 <span class="math inline">\(S\)</span> 的前提下才有意义。</p></div><p>用 Coxeter 矩阵或者群表现来描述 Coxeter群还是太不方便了。我们可以用一个有限图 <span class="math inline">\(\Gamma\)</span> 更直观地表示 <span class="math inline">\((W,S)\)</span>，<span class="math inline">\(\Gamma\)</span> 叫做 <span class="math inline">\((W,S)\)</span> 的 <strong>Coxeter图</strong>：</p><ul><li><span class="math inline">\(\Gamma\)</span> 的顶点集是 <span class="math inline">\(S\)</span>。</li><li>如果 <span class="math inline">\(m_{s,t}\ne 2\)</span>，就在顶点<span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 之间连一条边，并且给这条边标上记号<span class="math inline">\(m_{s,t}\)</span>。</li><li>但是如果 <span class="math inline">\(m_{s,t}=3\)</span>的话，就省略这个记号不写。</li></ul><p>此外如果 <span class="math inline">\(\Gamma\)</span> 是连通的，就称<span class="math inline">\((W,S)\)</span>是<strong>不可约的</strong>。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>Coxeter 矩阵 <span class="math display">\[\begin{pmatrix}1 &amp;4 &amp; 2\\4&amp;1&amp;3\\2&amp;3&amp;1\end{pmatrix}\]</span> 对应的Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是</p><figure><img src="/images/coxeter/cube43.svg" class="fig" width="120" alt="正方体对称群 (4,3) 的 Coxeter 图，注意标号 3 省略了"><figcaption aria-hidden="true">正方体对称群 <span class="math inline">\((4,3)\)</span> 的 Coxeter 图，注意标号 3省略了</figcaption></figure><p><span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(W\)</span>是不可约的。这个群是三维正方体的对称群：</p><video src="/images/coxeter/cube.mp4" width="300" controls=""></video><p>去掉最后一个顶点，前两个顶点构成二面体群 <span class="math inline">\(D_4\)</span>，<span class="math inline">\(D_4\)</span>是正四边形的对称群，对应正方体的每个面是正四边形；去掉第一个顶点，后两个顶点构成二面体群<span class="math inline">\(D_3\)</span>，<span class="math inline">\(D_3\)</span> 是正三角形的对称群，对应每个顶点处有3 个面相遇。</p></div><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>设 <span class="math inline">\(m\geq4\)</span> 是正整数，Coxeter矩阵 <span class="math display">\[\begin{pmatrix}1 &amp; m &amp;2\\m&amp;1&amp;2\\2&amp;2&amp;1\end{pmatrix}\]</span> 对应的 Coxeter 图<span class="math inline">\(\Gamma\)</span> 是</p><p><img src="/images/coxeter/prism.svg" class="fig" width="120"></p><p><span class="math inline">\(\Gamma\)</span> 有两个连通分支，所以<span class="math inline">\(W\)</span>是可约的。这个群是三维空间中棱柱的对称群，前两个相邻的顶点给出二面体群<span class="math inline">\(D_m\)</span>，它负责在 <span class="math inline">\(xy\)</span> 平面内生成正 <span class="math inline">\(m\)</span> 边形；最后的孤立顶点在 <span class="math inline">\(z\)</span>轴方向上将多边形作反射形成棱柱结构：</p><video src="/images/coxeter/prism-6.mp4" width="300" controls=""></video></div><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>Coxeter 矩阵 <span class="math display">\[\begin{pmatrix}1 &amp;3 &amp; 4\\3&amp;1&amp;\infty\\4&amp;\infty&amp;1\end{pmatrix}\]</span>对应的 Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是</p><figure id="3-4-inf"><img src="/images/coxeter/3-4-inf.svg" width="120" alt="三角形群 \Delta(3,4,\infty) 的 Coxeter 图 \Gamma，注意标号 3 被省略了"><figcaption aria-hidden="true">三角形群 <span class="math inline">\(\Delta(3,4,\infty)\)</span> 的 Coxeter 图 <span class="math inline">\(\Gamma\)</span>，注意标号 <span class="math inline">\(3\)</span> 被省略了</figcaption></figure><p><span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(W\)</span>是不可约的。这个群给出的是双曲空间中的密铺：</p><p><img src="/images/coxeter/parallel.png" class="fig" width="250"></p></div><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>Coxeter 矩阵 <span class="math display">\[\begin{pmatrix}1 &amp;5 &amp; 2 &amp;2\\5&amp;1&amp;3&amp;2\\2&amp;3&amp;1&amp;4\\2&amp;2&amp;4&amp;1\end{pmatrix}\]</span>对应的 Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是</p><p><img src="/images/coxeter/534.svg" id="534" class="fig" width="180"></p><p><span class="math inline">\(W\)</span>是不可约的。这个群给出的是三维双曲空间中的密铺：</p><p><img src="/images/coxeter/534-1000.jpg" class="fig" width="500"></p><p>去掉最后一个顶点，前三个顶点给出正十二面体的对称群 <span class="math inline">\((5,3)\)</span>，说明这个密铺由正十二面体组成；去掉第一个顶点，剩下三个顶点给出正方体的对称群<span class="math inline">\((3,4)\cong(4,3)\)</span>，说明每个顶点处有 8个正十二面体相遇。</p></div><p>我们主要关心 <span class="math inline">\(\Gamma\)</span>不可约的情形。因为如果 <span class="math inline">\(\Gamma=\Gamma_1\cup\cdots\cup\Gamma_k\,(k&gt;1)\)</span>包含多个连通分支的话，那么对任何 <span class="math inline">\(s\in\Gamma_i\)</span> 和 <span class="math inline">\(t\in\Gamma_j\)</span> 有 <span class="math inline">\(m_{s,t}=2\)</span>，即 <span class="math inline">\(st=ts\)</span>，于是 <span class="math inline">\(\Gamma_i\)</span> 中的生成元与 <span class="math inline">\(\Gamma_j\)</span> 中的生成元两两交换，这时 <span class="math inline">\(W\)</span> 有直积分解 <span class="math display">\[W=W_1\times\cdots\times W_k.\]</span> 其中 <span class="math inline">\(W_1,\ldots,W_k\)</span> 分别是子图 <span class="math inline">\(\Gamma_1,\ldots,\Gamma_k\)</span> 对应的 Coxeter群。所以我们只要研究 <span class="math inline">\(\Gamma\)</span>不可约的情形即可。</p><p>还有一种给 <span class="math inline">\(\Gamma\)</span>的边标号的方式，叫做 Vinberg 记号，它允许给 <span class="math inline">\(m_{s,t}=\infty\)</span> 的边用 <span class="math inline">\(\leq-1\)</span>的实数作为标号。比如像下面这样：</p><p><img src="/images/coxeter/level2.svg" id="level2" class="fig" width="120"></p><p>该图表示的抽象 Coxeter 群和前面的 <a href="#3-4-inf"><span class="math inline">\(\Delta(3,4,\infty)\)</span></a> 相同，但其中 <span class="math inline">\(\infty\)</span> 边的标号变成了 <span class="math inline">\(-1.1\)</span>。我后面会解释，这种标号方式其实是指定了几何实现中两个镜面的「双曲距离」。我们在后文介绍Boyd-Maxwell 球堆时也会采用这种记号。</p><p>Coxeter 图除了直观上的好处外，还能传达更多信息。比如，当 <span class="math inline">\(\Gamma\)</span> 包含回路，或者包含某个度数 <span class="math inline">\(\geq4\)</span> 的顶点时，我们可以立刻知道 <span class="math inline">\((W,S)\)</span> 一定是无限群 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.2.7</a>)</span>。更进一步，一个 Coxeter 群是否能够产生 Boyd-Maxwell球堆，也完全可以从其 Coxeter 图中读出来。</p><h1 id="长度函数">长度函数</h1><p>对 <span class="math inline">\(W\)</span> 中的任一元素 <span class="math inline">\(w\)</span>，存在许多种不同的方式将 <span class="math inline">\(w\)</span> 表示为 <span class="math inline">\(S\)</span>中生成元的乘积。在所有这些表示中，长度最短者叫做 <span class="math inline">\(w\)</span> 的<strong>既约表示</strong>：即，如果<span class="math inline">\(w=s_1s_2\cdots s_k\)</span> 是一个长度为<span class="math inline">\(k\)</span> 的表示，且 <span class="math inline">\(w\)</span> 不存在任何长度小于 <span class="math inline">\(k\)</span> 的表示，就称该表示是 <span class="math inline">\(w\)</span>的既约表示。既约表示未必唯一，但它们都具有相同的长度。定义 <span class="math inline">\(l(w)\)</span> 为 <span class="math inline">\(w\)</span> 的任意一个既约表示的长度。</p><p><span class="math inline">\(l(w)\)</span> 具有如下的性质：</p><ol type="1"><li><span class="math inline">\(l(xy)\leq l(x) + l(y)\)</span>。</li><li><span class="math inline">\(l(w) = l(w^{-1})\)</span>。</li><li><span class="math inline">\(l(w)=0\)</span> 当且仅当 <span class="math inline">\(w=1\)</span>。</li><li><span class="math inline">\(l(ws)=l(w)\pm 1\)</span>，其中 <span class="math inline">\(w\in W, s\in S\)</span>。</li></ol><p>前三点都是显然的，只有 4 需要证明。显然 <span class="math inline">\(|l(ws)-l(w)|\leq 1\)</span>，所以只要说明 <span class="math inline">\(l(ws)\)</span> 和 <span class="math inline">\(l(s)\)</span>不相等即可。这一步需要用到自由群的泛性质：</p><p>设 <span class="math inline">\(F\)</span> 是由集合 <span class="math inline">\(S\)</span> 生成的 <a href="https://en.wikipedia.org/wiki/Free_group">自由群</a>，定义群同态<span class="math inline">\({\rm sgn}: F\to{\pm1}\)</span> 如下：对<span class="math inline">\(F\)</span> 的每个生成元 <span class="math inline">\(s\in S\)</span> 规定 <span class="math inline">\({\rm sgn}(s)=-1\)</span>，然后将此映射扩充为 <span class="math inline">\(F\)</span> 到 <span class="math inline">\({\pm1}\)</span> 的群同态。容易验证 <span class="math inline">\((W,S)\)</span>的所有生成关系都属于这个同态的核，因此根据 <a href="https://en.wikipedia.org/wiki/Free_group#Universal_property">自由群的泛性质</a>，<span class="math inline">\({\rm sgn}\)</span> 诱导了一个从 <span class="math inline">\((W,S)\)</span> 到 <span class="math inline">\({\pm1}\)</span> 的群同态。若 <span class="math inline">\(w=s_1s_2\cdots s_k\)</span> 是 <span class="math inline">\(w\)</span> 的任一既约表示，则 <span class="math display">\[{\rm sgn}(w)={\rm sgn}(s_1){\rmsgn}(s_2)\cdots{\rm sgn}(s_k)=(-1)^k=(-1)^{l(w)}.\]</span> 从而 <span class="math inline">\({\rm sgn}(ws)={\rm sgn}(w){\rm sgn}(s)=-{\rmsgn}(w)\)</span>，这说明 <span class="math inline">\(l(ws)\nel(w)\)</span>，从而第 4 条成立。</p><h1 id="几何实现">几何实现</h1><p>抽象 Coxeter群是通过生成元和生成关系定义的，直接从这种定义出发研究群结构是非常困难的。本节将介绍如何将一个抽象的Coxeter群实现为内积空间中的正交反射群，从而可以使用几何、线性代数等多种工具来研究它。</p><p>设 <span class="math inline">\((W,S)\)</span> 是一个 Coxeter系，<span class="math inline">\(M=(m_{s,t})_{s,t\in S}\)</span> 是Coxeter 矩阵。令 <span class="math inline">\(V\)</span> 是一个维数为<span class="math inline">\(n=|S|\)</span> 的实向量空间，其一组基为<span class="math inline">\(\{\alpha_s \mid s\in S\}\)</span>。我们规定<span class="math inline">\(V\)</span> 上的内积 <span class="math inline">\((\cdot,\cdot)\)</span> 如下：</p><p><span class="math display">\[(\alpha_s,\alpha_t)=\begin{cases}1 &amp; s=t,\\-\cos(\pi/m_{s,t}) &amp; m_{s,t}&lt;\infty,\\-a_{s,t} &amp; m_{s,t}=\infty.\end{cases}\]</span> 这里 <span class="math inline">\(a_{s,t}=a_{t,s}\geq1\)</span> 是实数，它对应的是<span class="math inline">\(\infty\)</span> 边的 Vinberg 记号。不同的<span class="math inline">\(s,t\)</span> 对可以使用不同的 <span class="math inline">\(a_{s,t}\)</span>。</p><p>根据定义 <span class="math inline">\((\alpha_s,\alpha_s)=1\)</span>，即每个 <span class="math inline">\(\alpha_s\)</span> 都是单位向量。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span><span class="math inline">\(a_{s,t}=1\)</span> 表示 Euclidean空间中两个平行的镜面（或者双曲空间中两个平行的镜面）；<span class="math inline">\(a_{s,t}&gt;1\)</span>表示双曲空间中两个超平行的镜面；<span class="math inline">\(2\leqm_{s,t}&lt;\infty\)</span> 表示两个相交的镜面。</p><p>下图显示了对前面的 <a href="#3-4-inf"><span class="math inline">\(\Delta(3,4,\infty)\)</span></a> 群，对标号为 <span class="math inline">\(\infty\)</span> 的边取 <span class="math inline">\(a_{s,t}=1.15\)</span> 时给出的效果：</p><p><img src="/images/coxeter/hypparallel.png" class="fig" width="250"></p><p>你可以看到每个三角形都不再是封闭的，它们的墙壁中有两条「超平行」的测地线，这两条测地线交点落在双曲空间的外面。</p></div><p>内积 <span class="math inline">\((\cdot,\cdot)\)</span> 未必是通常的Euclidean 内积，即它未必是正定的。但我们最关心的情形有三种：</p><ol type="1"><li>如果 <span class="math inline">\((\cdot,\cdot)\)</span>是正定的，就称 <span class="math inline">\((\cdot,\cdot)\)</span>是<strong>有限</strong>型的；</li><li>如果 <span class="math inline">\((\cdot,\cdot)\)</span>是半正定的，但不是正定的，就称 <span class="math inline">\((\cdot,\cdot)\)</span>是<strong>仿射</strong>型的；</li><li>如果 <span class="math inline">\((\cdot,\cdot)\)</span> 的符号是<span class="math inline">\((n-1, 1)\)</span>，就称 <span class="math inline">\((\cdot,\cdot)\)</span>是<strong>双曲</strong>型的。</li></ol><p>除此之外的情况，统称为<strong>不定</strong>型。</p><p>给定 <span class="math inline">\(s\in S\)</span>，定义 <span class="math inline">\(V\)</span> 上的反射 <span class="math inline">\(\rho_s\)</span> 为 <span class="math display">\[\rho_s(v) = v -2(v,\alpha_s)\alpha_s ,\quad v\inV.\]</span> 容易验证，<span class="math inline">\(\rho_s\)</span>满足以下性质：</p><ol type="1"><li><span class="math inline">\(\rho_s(\alpha_s)=-\alpha_s\)</span>；</li><li><span class="math inline">\(\rho_s\)</span> 保持超平面 <span class="math inline">\(\{v\in V\mid (v,\alpha_s)=0\}\)</span>上的点不动；</li><li><span class="math inline">\(\rho_s\)</span> 保持 <span class="math inline">\((\cdot,\cdot)\)</span> 不变：<span class="math inline">\((\rho_s(u),\rho_s(v)) = (u,v),\,\forall u,v\inV\)</span>。</li></ol><p>因此 <span class="math inline">\(\rho_s\in \mathrm{O}(V)\)</span>是以 <span class="math inline">\(\alpha\)</span>为法向量的镜面反射。</p><p>我们来证明 <span class="math inline">\(s\to\rho_s\)</span>实际上给出了 <span class="math inline">\((W,S)\)</span> 到 <span class="math inline">\(\mathrm{O}(V)\)</span>的群同态，从而得到了一个线性表示 <span class="math display">\[\rho:W\to\rho(W)\leqslant\mathrm{O}(V)\]</span> 为此，只需验证 <span class="math inline">\(\{\rho_s\mid s\in S\}\)</span> 满足与 <span class="math inline">\((W,S)\)</span>相同的生成关系即可，这样根据商群的泛性质，即得存在群同态 <span class="math inline">\(W\to\mathrm{O}(V)\)</span> 将每个 <span class="math inline">\(s\)</span> 映射到 <span class="math inline">\(\rho_s\)</span>。即我们只要证明：</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\((\rho_s\rho_t)^{m_{s,t}}=1\)</span> 对任何 <span class="math inline">\(s,t\in S\)</span> 成立。</p></div><p>这个结论的证明在 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.5.3</a>)</span> 和 <span class="citation" data-cites="Howlett-note">(<a href="#ref-Howlett-note" role="doc-biblioref">Howlett 1996</a>)</span>中都可以找到，但我更喜欢 Howlett 的做法，把 rank 2情形的根系具体的算出来。这是最简单，但又非平凡的根系的例子，熟悉它的重要性怎么强调也不为过。</p><p><strong>证明</strong>：当 <span class="math inline">\(s=t\)</span>时所证即为 <span class="math inline">\(\rho_s^2=1\)</span>，由于 <span class="math inline">\(\rho_s\)</span> 是反射这当然是成立的。</p><p>下设 <span class="math inline">\(s\ne t\)</span>，记 <span class="math inline">\(V_{s,t}={\rmspan}\{\alpha_s,\alpha_t\}\)</span>，并记 <span class="math inline">\(V_{s,t}^\perp\)</span> 是 <span class="math inline">\(V_{s,t}\)</span> 在 <span class="math inline">\((\cdot,\cdot)\)</span> 下的正交补。不难验证 <span class="math inline">\(\rho_s\)</span> 和 <span class="math inline">\(\rho_t\)</span> 限制在 <span class="math inline">\(V_{s,t}^\perp\)</span> 上都是恒等变换。</p><p>注意，未必有 <span class="math inline">\(V=V_{s,t}\oplusV_{s,t}^\perp\)</span> 成立，因为 <span class="math inline">\((\cdot,\cdot)\)</span> 可能是退化的。但是如果<span class="math inline">\((\cdot,\cdot)\)</span> 限制在 <span class="math inline">\(\mid_{V_{s,t}}\)</span> 是非退化的，那么就有 <span class="math inline">\(V=V_{s,t}\oplus V_{s,t}^\perp\)</span>就成立。这是双线性型的基本结论。</p><p>我们来计算 <span class="math inline">\(\sigma=\rho_s\rho_t\)</span>的阶。记 <span class="math inline">\(m=m_{s,t}\)</span>，分情况讨论：</p><div id="rank2-roots" class="plain"></div><p><strong>1. <span class="math inline">\(m&lt;\infty\)</span></strong></p><p>这时 <span class="math inline">\((\cdot,\cdot)\)</span> 限制在 <span class="math inline">\(V_{s,t}\)</span> 上的 Gram 矩阵是 <span class="math display">\[\begin{pmatrix}1&amp;-\cos\theta\\-\cos\theta&amp;1\end{pmatrix},\quad\theta=\frac{\pi}{m}.\]</span> 这个矩阵是正定的，从而 <span class="math inline">\((\cdot,\cdot)\mid_{V_{s,t}}\)</span> 非退化，从而<span class="math inline">\(V=V_{s,t}\oplus V_{s,t}^\perp\)</span>成立，而 <span class="math inline">\(\sigma\)</span> 限制在正交补 <span class="math inline">\(V_{s,t}^\perp\)</span> 上是恒等变换，因此 <span class="math inline">\(\sigma\)</span> 在 <span class="math inline">\(V\)</span> 上的阶就等于它在 <span class="math inline">\(V_{s,t}\)</span> 上的阶。</p><p>为了简化记号，令 <span class="math inline">\(a_k=\sin(k\theta)/\sin\theta\)</span>，直接计算如下： <span class="math display">\[\begin{aligned}&amp;\alpha_s\xrightarrow{\ \rho_t\}a_1\alpha_s+a_2\alpha_t\xrightarrow{\ \rho_s\}a_3\alpha_s+a_2\alpha_t\xrightarrow{\ \rho_t\}a_3\alpha_s+a_4\alpha_t\xrightarrow{\ \rho_s\ }\cdots\\&amp;\alpha_t\xrightarrow{\ \rho_s\}a_2\alpha_s+a_1\alpha_t\xrightarrow{\ \rho_t\}a_2\alpha_s+a_3\alpha_t\xrightarrow{\ \rho_s\}a_4\alpha_s+a_3\alpha_t\xrightarrow{\ \rho_t\ }\cdots\end{aligned}\]</span> 这两个链的周期都是 <span class="math inline">\(2m\)</span>，因为它们的第 <span class="math inline">\(2m+1\)</span> 项各自回到了初始状态： <span class="math display">\[\begin{aligned}a_{2m+1}\alpha_s+a_{2m}\alpha_t&amp;=\dfrac{\sin(2m+1)\theta}{\sin\theta}\alpha_s+\dfrac{\sin(2m)\theta}{\sin\theta}\alpha_t=\alpha_s,\\a_{2m}\alpha_s+a_{2m+1}\alpha_t&amp;=\dfrac{\sin(2m)\theta}{\sin\theta}\alpha_s+\dfrac{\sin(2m+1)\theta}{\sin\theta}\alpha_t=\alpha_t.\end{aligned}\]</span> 因此 <span class="math inline">\(\sigma\)</span>的阶等于 <span class="math inline">\(m\)</span>。</p><p><strong>2. <span class="math inline">\(m=\infty\)</span></strong></p><p>这时未必有 <span class="math inline">\(V=V_{s,t}\oplusV_{s,t}^\perp\)</span>。但我们可以证明 <span class="math inline">\(\sigma\)</span> 在 <span class="math inline">\(V_{s,t}\)</span> 上的阶是无穷，那么自然它在 <span class="math inline">\(V\)</span> 上的阶也是无穷。</p><p>设 <span class="math inline">\(\theta\geq0\)</span> 使得 <span class="math inline">\(a_{s,t}=\cosh\theta\)</span>。记 <span class="math inline">\(b_k=\sinh(k\theta)/\sinh\theta\)</span>，直接计算：<span class="math display">\[\begin{aligned}&amp;\alpha_s\xrightarrow{\ \rho_t\}b_1\alpha_s+b_2\alpha_t\xrightarrow{\ \rho_s\}b_3\alpha_s+b_2\alpha_t\xrightarrow{\ \rho_t\}b_3\alpha_s+b_4\alpha_t\xrightarrow{\ \rho_s\ }\cdots\\&amp;\alpha_t\xrightarrow{\ \rho_s\}b_2\alpha_s+b_1\alpha_t\xrightarrow{\ \rho_t\}b_2\alpha_s+b_3\alpha_t\xrightarrow{\ \rho_s\}b_4\alpha_s+b_3\alpha_t\xrightarrow{\ \rho_t\ }\cdots\end{aligned}\]</span> 当 <span class="math inline">\(a_{s,t}=1\)</span> 时 <span class="math inline">\(\theta=0\)</span>，<span class="math inline">\(b_k\)</span> 应当理解为 <span class="math inline">\(\lim_{\theta\to0}\sinh(k\theta)/\sinh(\theta)=k\)</span>。</p><p>这两个链条永不重复，所以 <span class="math inline">\(\sigma\)</span>的阶是无穷。</p><p>至此命题得证。<span class="math inline">\(\blacksquare\)</span></p><p>后面我们会看到，<span class="math inline">\(W\xrightarrow{\rho}\rho(W)\)</span>实际上是群同构，这样就把抽象的 Coxeter 群 <span class="math inline">\(W\)</span> 实现为具体的反射群 <span class="math inline">\(\rho(W)\)</span>。研究 <span class="math inline">\(\rho(W)\)</span> 并不会丢失 <span class="math inline">\(W\)</span> 的信息。</p><p>最后是一个记号的简化：把 <span class="math inline">\(w\in W\)</span>在 <span class="math inline">\(V\)</span> 上的作用记为 <span class="math inline">\(wv\,\colon=\rho(w)(v)\)</span>。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Howlett-note" class="csl-entry" role="listitem">Howlett, Robert B. 1996. <span>“Introduction to Coxeter Groups.”</span><a href="https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html">https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html</a>.</div><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（六）：Boyd-Maxwell 球堆</title>
      <link href="/coxeter-groups/Boyd-Maxwell.html"/>
      <url>/coxeter-groups/Boyd-Maxwell.html</url>
      
        <content type="html"><![CDATA[<p>本文的内容主要来自 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>)</span> 和<span class="citation" data-cites="Maxwell89">(<a href="#ref-Maxwell89" role="doc-biblioref">Maxwell 1989</a>)</span>，并修复了一些错误。Maxwell在 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>, pp81)</span> 中写到：</p><div class="statement simple plain unnumbered"><p>When <span class="math inline">\(\Gamma\)</span> is hyperbolic, thecone</p><p><span class="math display">\[\{v\in V\mid (v,v)\leq0\}\]</span></p><p>has two connected components (after deleting 0), which are also theequivalent classes for the relation <span class="math display">\[u\simv\Leftrightarrow (u,v)\leq0.\]</span></p></div><p>这显然是错误的，因为如果 <span class="math inline">\(u\)</span> 是light-like 的向量，<span class="math inline">\(u\)</span> 和 <span class="math inline">\(-u\)</span> 属于不同的分支。这个错误导致后面 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>, prop 3.1)</span>的证明需要作一些修改。详情见下面的 <a href="#thm-sphere-packing" title="定理 5.6">定理 5.6</a>。</p><span id="more"></span><h1 id="射影模型">射影模型</h1><p>设 <span class="math inline">\(V=\mathbb{R}^{n+1,1}\)</span> 是 <span class="math inline">\(n+2\)</span> 维 Lorentzian 空间，<span class="math inline">\(\{e_1,e_2,\ldots,e_{n+2}\}\)</span>是一组标准正交基，对应的 Gram 矩阵为 <span class="math inline">\(\left(\begin{smallmatrix}I_{n+1} &amp;\\ &amp;-1\end{smallmatrix}\right)\)</span>。令 <span class="math display">\[e_0=\frac{e_{n+2}-e_{n+1}}{2},\quade_\infty=\frac{e_{n+2}+e_{n+1}}{2}.\]</span> 则 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span> 也构成<span class="math inline">\(V\)</span> 的一组基，内积在这组新基下的 Gram矩阵为 <span class="math display">\[\begin{pmatrix}0&amp;&amp;&amp;-\frac{1}{2}\\&amp;I_n&amp;&amp;\\-\frac{1}{2}&amp;&amp;&amp;0\end{pmatrix}.\]</span>任何 <span class="math inline">\(v,w\in V\)</span> 可以表示为： <span class="math display">\[\begin{aligned}v&amp;=ae_0 + \mathbf{x}+ be_\infty,\\w&amp;=ce_0 + \mathbf{y}+ de_\infty.\end{aligned}\]</span> 其中 <span class="math inline">\(\mathbf{x},\mathbf{y}\in\mathrm{span}\{e_1,\ldots,e_n\},\,a,b\in\mathbb{R}\)</span>。则<span class="math inline">\(v,w\)</span> 之间的内积为 <span class="math display">\[(v,w) = (\mathbf{x}, \mathbf{y}) -\frac{ad+bc}{2}.\]</span> 使用 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span>这组基在处理 <span class="math inline">\(\mathbb{R}^n\)</span>中的球时更方便一些。</p><p>记 <span class="math inline">\([v]\)</span> 为向量 <span class="math inline">\(v\in\mathbb{R}^{n+1,1}\)</span> 在射影空间 <span class="math inline">\(\mathrm{P}(\mathbb{R}^{n+1,1})\)</span>中的等价类。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>定义光锥 (lightcone/null cone) 为 <span class="math display">\[\mathbb{L}^{n+1}= \{v\in\mathbb{R}^{n+1,1}\mid(v,v)=0\}.\]</span> 以及 <span class="math display">\[\mathrm{P}(\mathbb{L}^{n+1})=\{[v]\midv\in\mathbb{L}^{n+1}\setminus\{0\}\}.\]</span> <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span> 是 <span class="math inline">\(\mathbb{L}^{n+1}\)</span>中所有直线组成的集合。</p></div><p>熟知 <span class="math inline">\(\overline{\mathbb{R}^n}=\mathbb{R}^n\cup\{\infty\}\)</span>和 <span class="math inline">\(\mathbb{R}^{n+1}\)</span> 中的单位球<span class="math inline">\(S^n=\{x_1^2+x_2^2+\cdots+x_{n+1}^2=1\}\)</span>在球极投影下是一一对应的（北极点为 <span class="math inline">\(e_{n+1}\)</span>）。</p><figure><img src="/images/coxeter/stereo-projection.svg" width="400" alt="S^2 到 \overline{\mathbb{R}^2} 的球极投影，by Keenan Crane"><figcaption aria-hidden="true"><span class="math inline">\(S^2\)</span>到 <span class="math inline">\(\overline{\mathbb{R}^2}\)</span>的球极投影，by Keenan Crane</figcaption></figure><p>我们将看到，<span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span> 同时与 <span class="math inline">\(\overline{\mathbb{R}^n}\)</span> 和 <span class="math inline">\(S^n\)</span> 一一对应，并且当 <span class="math inline">\(\mathbf{x}\in\overline{\mathbb{R}^n}\)</span> 和<span class="math inline">\(\mathbf{y}\in S^n\)</span>在球极投影下对应时，它们在 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>对应中同一个点。</p><div class="statement simple plain unnumbered"><p><span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span><strong>的第一种参数化表示</strong><br></p><p>我们在 <span class="math inline">\(\{e_1,\ldots,e_{n+2}\}\)</span>这组基下计算。</p><p>设 <span class="math inline">\(\mathbf{y}=y_1e_1+\cdots+y_{n+1}e_{n+1}\in\mathbb{R}^{n+1}\)</span>，则<span class="math display">\[\mathbf{y}\in S_n\Leftrightarrow|\mathbf{y}|=1\Leftrightarrow\mathbf{y}+e_{n+2}\in\mathbb{L}^{n+1}.\]</span> 即我们有一一映射： <span class="math display">\[\begin{aligned}S^n&amp;\mapsto S^n_1\\\mathbf{y}&amp;\mapsto \mathbf{y}+e_{n+2}.\end{aligned}\]</span> 其中 <span class="math inline">\(S^n_1\)</span>是平面 <span class="math inline">\(y_{n+2}=1\)</span> 与 <span class="math inline">\(\mathbb{L}^{n+1}\)</span> 相交给出的截线。由于<span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>中每个元素在 <span class="math inline">\(S^n_1\)</span>中有唯一代表元，所以 <span class="math display">\[\jmath\colon\S^n\to\mathrm{P}(\mathbb{L}^{n+1}): \mathbf{y}\to[\mathbf{y}+e_{n+2}],\]</span> 是一一对应，此即为 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>的第一种参数化表示。</p></div><div id="second-param" class="statement simple plain unnumbered"><p><span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span><strong>的第二种参数化表示</strong><br></p><p>我们在 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span>这组基下计算。对 <span class="math inline">\([v]\in\mathrm{P}(\mathbb{L}^{n+1})\)</span>：</p><ul><li>如果 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(e_0\)</span> 分量不为 0，则 <span class="math inline">\(v\)</span> 形如 <span class="math display">\[v=e_0+ \mathbf{x}+ be_\infty,\quad\mathbf{x}\in\mathrm{span}\{e_1,\ldots,e_n\}.\]</span> 由于 <span class="math inline">\(v\in\mathbb{L}^{n+1}\)</span> 所以 <span class="math inline">\(b=|\mathbf{x}|^2\)</span>，即 <span class="math inline">\(v=e_0 + \mathbf{x}+|\mathbf{x}|^2e_\infty\)</span>。</li><li>如果 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(e_0\)</span> 分量等于 0，则 <span class="math inline">\(v\)</span> 形如 <span class="math display">\[v=\mathbf{x}+be_\infty,\quad\mathbf{x}\in\mathrm{span}\{e_1,\ldots,e_n\}.\]</span> <span class="math inline">\(v\in\mathbb{L}^{n+1}\)</span> 说明 <span class="math inline">\(\mathbf{x}=0\)</span>，从而 <span class="math inline">\([v] = [(0,0,b)]=[e_\infty]\)</span>。</li></ul><p>于是我们可以定义如下从 <span class="math inline">\(\overline{\mathbb{R}^n}\)</span> 到 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span> 的一一对应:<span class="math display">\[\imath(\mathbf{x})=\begin{cases}[e_0 + \mathbf{x}+|\mathbf{x}|^2e_\infty] &amp; \mathbf{x}\in\mathbb{R}^n,\\[e_\infty] &amp; \mathbf{x}= \infty.\end{cases}\]</span> 此即为 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>的第二种参数化表示。</p></div><figure><img src="/images/coxeter/Horosphere.svg" class="fig" width="500" alt="红色的圆是超平面 (\cdot, e_{n+2})=1 与光锥的截线，可以通过将 S^n 沿着 e_{n+2} 平移一个单位得到；\overline{\mathbb{R}^n} 对应蓝色的 horosphere，它是超平面 (\cdot, e_0)=\frac{1}{2} 与光锥的截线。e_\infty 不在 horosphere 上"><figcaption aria-hidden="true">红色的圆是超平面 <span class="math inline">\((\cdot, e_{n+2})=1\)</span>与光锥的截线，可以通过将 <span class="math inline">\(S^n\)</span> 沿着<span class="math inline">\(e_{n+2}\)</span> 平移一个单位得到；<span class="math inline">\(\overline{\mathbb{R}^n}\)</span> 对应蓝色的horosphere，它是超平面 <span class="math inline">\((\cdot,e_0)=\frac{1}{2}\)</span> 与光锥的截线。<span class="math inline">\(e_\infty\)</span> 不在 horosphere 上</figcaption></figure><p>设 <span class="math inline">\(\mathbf{y}=y_1e_1+\cdots+y_{n+1}e_{n+1}\inS^n\)</span>，<span class="math inline">\(\mathbf{y}\)</span> 在以 <span class="math inline">\(e_{n+1}\)</span> 为北极的球极投影下对应的点是<span class="math display">\[\mathbf{x}=\begin{cases}\sum\limits_{i=1}^n\dfrac{y_i}{1-y_{n+1}}e_i &amp; y_{n+1}\ne1,\\\infty &amp; y_{n+1}=1.\end{cases}\]</span> 我们来验证 <span class="math inline">\(\jmath(\mathbf{y})=\imath(\mathbf{x})\)</span>，即：<span class="math display">\[[\mathbf{y}+ e_{n+2}] = \begin{cases}[e_0 +\mathbf{x}+ |\mathbf{x}|^2e_\infty] &amp; y_{n+1}\ne1\\[e_\infty] &amp; y_{n+1}=1.\end{cases}.\]</span></p><ul><li><p><span class="math inline">\(y_{n+1}=1\)</span> 时 <span class="math inline">\(\mathbf{y}=e_{n+1}\)</span> 从而 <span class="math inline">\(\mathbf{y}+e_{n+2}=e_{n+1}+e_{n+2}=2e_\infty\)</span>，显然与 <span class="math inline">\(e_\infty\)</span> 射影等价。</p></li><li><p><span class="math inline">\(y_{n+1}\ne 1\)</span> 时，由 <span class="math inline">\(\mathbf{y}\in S^n\)</span> 可得 <span class="math inline">\(\sum_{i=1}^ny_i^2=1-y_{n+1}^2\)</span>，从而 <span class="math display">\[|\mathbf{x}|^2=\frac{\sum_{i=1}^ny_i^2}{(1-y_{n+1})^2}= \frac{1+y_{n+1}}{1-y_{n+1}}.\]</span> 把 <span class="math inline">\(\mathbf{y}+e_{n+2}\)</span> 转化为 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span>这组基下的表示： <span class="math display">\[\mathbf{y}+e_{n+2} =(1-y_{n+1})e_0+\sum_{i=1}^ny_ie_i + (1+y_{n+1})e_\infty.\]</span> 从而<span class="math display">\[[\mathbf{y}+e_{n+2}] =\left[e_0+\sum_{i=1}^n\frac{y_i}{1-y_{n+1}}e_i+\frac{1+y_{n+1}}{1-y_{n+1}}e_\infty\right] = [e_0 + \mathbf{x}+|\mathbf{x}|^2e_\infty].\]</span></p></li></ul><h1 id="球面">球面</h1><p>记 <span class="math inline">\(\mathcal{S}=\{v\in\mathbb{R}^{n+1,1}\mid(v,v)=1\}\)</span> 是所有 space-like 的单位向量组成的集合。我们来建立<span class="math inline">\(\mathbb{R}^n\)</span> 中的球（包括超平面）和<span class="math inline">\(\mathcal{S}\)</span> 之间的一一对应。</p><p>设 <span class="math inline">\(B(\mathbf{a},r)=\{\mathbf{x}\in\mathbb{R}^n\mid|x-\mathbf{a}|=|r|\}\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span> 中以 <span class="math inline">\(\mathbf{a}\)</span> 为中心，半径为 <span class="math inline">\(r\ne 0\)</span> 的球，它将 <span class="math inline">\(\mathbb{R}^n\)</span>分成有界和无界两个连通分支。我们允许 <span class="math inline">\(r\)</span> 是负数以区分 <span class="math inline">\(B\)</span> 的内部和外部：</p><ul><li><span class="math inline">\(r&gt;0\)</span> 时 <span class="math inline">\(B\)</span> 的内部是满足 <span class="math inline">\(|\mathbf{x}-\mathbf{a}|&lt; r\)</span>的有界分支；</li><li><span class="math inline">\(r&lt;0\)</span> 时 <span class="math inline">\(B\)</span> 的内部是满足 <span class="math inline">\(|\mathbf{x}-\mathbf{a}|&gt;|r|\)</span>的无界分支。</li></ul><p>把 <span class="math inline">\(\mathbf{a}\)</span> 看作 <span class="math inline">\(\mathrm{span}\{e_1,\ldots,e_n\}\cong\mathbb{R}^n\)</span>中的点，记 <span class="math display">\[k = \frac{e_0 + \mathbf{a}+(|\mathbf{a}|^2 - r^2)e_\infty}{r}.\]</span> 不难验证 <span class="math inline">\((k,k)=1\)</span>，因此 <span class="math inline">\(k\in\mathcal{S}\)</span>。</p><p>对 <span class="math inline">\(\mathbf{x}\in\mathbb{R}^n\)</span>，根据 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span> 的 <a href="#second-param" title="第二种">第二种</a> 参数化表示，有 <span class="math display">\[(\imath(\mathbf{x}),k)=\frac{r^2-|\mathbf{x}-\mathbf{a}|^2}{2r}.\]</span></p><p>于是：</p><ul><li><span class="math inline">\(\mathbf{x}\in B\)</span> 当且仅当 <span class="math inline">\((\imath(\mathbf{x}),k)=0\)</span>；</li><li><span class="math inline">\(\mathbf{x}\)</span> 落在 <span class="math inline">\(B\)</span> 的内部当且仅当 <span class="math inline">\((\imath(\mathbf{x}),k)&gt;0\)</span>。</li></ul><p>鉴于此，我们也把 <span class="math inline">\(B\)</span> 的内部叫做<span class="math inline">\(B\)</span>的<strong>正半空间</strong>，<span class="math inline">\(k\)</span>是指向 <span class="math inline">\(B\)</span>的正半空间的单位法向量。</p><p>注意到 <span class="math inline">\(\imath(\mathbf{x})\)</span> 和<span class="math inline">\(\jmath(\mathbf{x})\)</span>只差一个正的倍数，所以 <span class="math inline">\(\mathbf{x}\inB\)</span> 等价于 <span class="math inline">\((\jmath(\mathbf{x}),k)=0\)</span>。<span class="math inline">\(V\)</span> 中所有形如 <span class="math inline">\((\jmath(\mathbf{x}),k)=0\,(\mathbf{x}\in\mathbb{R}^n)\)</span>的点构成 <span class="math inline">\(S^n_1\)</span> 与超平面 <span class="math inline">\(k^\bot\)</span> 的截线。</p><p>设 <span class="math inline">\(H(\mathbf{n},d)=\{\mathbf{x}\in\mathbb{R}^n\mid(\mathbf{x},\mathbf{n})=d\}\)</span> 是超平面，<span class="math inline">\(\mathbf{n}\)</span> 是 <span class="math inline">\(B\)</span> 的单位法向量。我们将 <span class="math inline">\(H(\mathbf{n},d)\)</span> 对应到 <span class="math display">\[k=\mathbf{n}+ 2d e_\infty.\]</span>不难验证同样有 <span class="math inline">\(k\in\mathcal{S}\)</span>，并且对 <span class="math inline">\(\mathbf{x}\in\mathbb{R}^n\)</span> 有 <span class="math display">\[(\imath(\mathbf{x}),k)=(\mathbf{x},\mathbf{n})-d.\]</span>于是：</p><ul><li><span class="math inline">\(\mathbf{x}\in B\)</span> 当且仅当 <span class="math inline">\((\imath(\mathbf{x}),k)=0\)</span>；</li><li><span class="math inline">\(\mathbf{x}\)</span> 属于 <span class="math inline">\(B\)</span> 的正半空间当且仅当 <span class="math inline">\((\imath(\mathbf{x}),k)&gt;0\)</span>。</li></ul><p>反过来，任意 <span class="math inline">\(k\in\mathcal{S}\)</span>都唯一对应 <span class="math inline">\(\mathbb{R}^n\)</span>中的某个球或者超平面。具体方法是将 <span class="math inline">\(k\)</span> 表示为 <span class="math display">\[k=be_\infty+\mathbf{a}+ce_\infty\in\mathcal{S},\quadb,c\in\mathbb{R}.\]</span> 并根据 <span class="math inline">\(b\)</span>是否等于 0 将 <span class="math inline">\(k\)</span> 对应为球 <span class="math inline">\(B(\mathbf{a}/b ,1/b)\)</span> 或者超平面 <span class="math inline">\(H(\mathbf{a}, c/2)\)</span> 即可。</p><h1 id="球面的-seperation">球面的 seperation</h1><p>设 <span class="math inline">\(B_1(\mathbf{a}_1,r_1),\,B_2(\mathbf{a}_2,r_2)\)</span>是两个球，它们对应的 <span class="math inline">\(\mathcal{S}\)</span>-向量分别是 <span class="math display">\[\begin{aligned}k_1&amp;=\frac{1}{r_1}e_0 + \frac{\mathbf{a}_1}{r_1} +\frac{|\mathbf{a}_1|^2-r_1^2}{r_1}e_\infty,\\k_2&amp;=\frac{1}{r_2}e_0 + \frac{\mathbf{a}_2}{r_2} +\frac{|\mathbf{a}_2|^2-r_2^2}{r_2}e_\infty.\\\end{aligned}.\]</span> 直接计算验证可以得到 <span class="math display">\[(k_1,k_2)=\frac{r_1^2+r_2^2 -|\mathbf{a}_1-\mathbf{a}_2|^2}{2r_1r_2}.\]</span> 我们称内积 <span class="math inline">\((k_1,k_2)\)</span> 为 <span class="math inline">\(B_1\)</span> 和 <span class="math inline">\(B_2\)</span> 的 <strong>seperation</strong>。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span> <span class="statement-info">(<span class="citation" data-cites="ratcliffe">(见 <a href="#ref-ratcliffe" role="doc-biblioref">Ratcliffe 2006, vol. 149, sec.3.2</a>)</span>)</span>：</span><span class="statement-spah"> </span>在Lorentzinian 内积下，两个 space-like 的单位向量 <span class="math inline">\(k_1,k_2\)</span> 之间的内积有如下解释：</p><ol type="1"><li>若 <span class="math inline">\(|(k_1,k_2)|\leq1\)</span>，则 <span class="math inline">\((k_1,k_2)=\cos\theta\)</span>，其中 <span class="math inline">\(\theta\)</span> 是两条以 <span class="math inline">\(x,y\)</span> 为切向量的测地线之间的夹角；</li><li>若 <span class="math inline">\(|(k_1,k_2)|&gt;1\)</span>，则 <span class="math inline">\((k_1,k_2)=\pm\cosh\eta\)</span>，其中 <span class="math inline">\(\eta\)</span> 是以 <span class="math inline">\(x,y\)</span>为法向量的两个超平面之间的双曲距离。</li></ol></div><p>根据内积 <span class="math inline">\((k_1,k_2)\)</span>的大小，可以判断球体之间的位置关系：</p><ol type="1"><li>当 <span class="math inline">\(|(k_1,k_2)|\leq1\)</span>时两球相交或者相切，这时 <span class="math inline">\((k_1,k_2)=\cos\theta\)</span>，<span class="math inline">\(\theta\)</span>是两个球面交点处的内法向量夹角（用外法向量也可以，因为同时将内法向量变成外法向量，夹角的余弦不变）。特别地，<span class="math inline">\((k_1,k_2)=-1\)</span> 时两球外切，<span class="math inline">\((k_1,k_2)=1\)</span> 时两球内切。</li><li>当 <span class="math inline">\(|(k_1,k_2)|&gt;1\)</span>时两球既不相交也不相切，这时 <span class="math inline">\(|(k_1,k_2)|=\cosh\eta\)</span>，<span class="math inline">\(\eta\)</span> 是 <span class="math inline">\(k_1,k_2\)</span>对应的双曲空间中测地线的距离。两球在 <span class="math inline">\((k_1,k_2)&lt;-1\)</span> 时没有公共的内部，在<span class="math inline">\((k_1,k_2)&gt;1\)</span>时一个完全包含另一个。</li></ol><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=\cos\theta(\ell_1,\ell_2)\)</span></td><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=\cosh d(\ell_1,\ell_2)\)</span></td></tr><tr><td style="text-align: center;"><img src="/images/coxeter/image0.jpg" width="150"></td><td style="text-align: center;"><img src="/images/coxeter/image1.jpg" width="150"></td></tr><tr><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=-\cosh d(\ell_1,\ell_2)\)</span></td><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=-\cosh d(\ell_1,\ell_2)\)</span></td></tr><tr><td style="text-align: center;"><img src="/images/coxeter/image2.jpg" width="150"></td><td style="text-align: center;"><img src="/images/coxeter/image3.jpg" width="150"></td></tr></tbody></table><p>上述结论同样适用于球面和超平面的情形。例如设 <span class="math inline">\(B_1\)</span> 是球面，<span class="math inline">\(B_2\)</span> 是超平面，<span class="math inline">\(k_2=\mathbf{n}+2de_\infty\)</span>，则 <span class="math display">\[(k_1,k_2)=\frac{(\mathbf{a}_1,\mathbf{n})-d}{r_1}.\]</span>此时： + 若 <span class="math inline">\(B_1,B_2\)</span> 相交，则 <span class="math inline">\((k_1,k_2)\)</span> 等于 <span class="math inline">\(B_1\)</span> 在交点处的内法向量和 <span class="math inline">\(B_2\)</span> 的法向量 <span class="math inline">\(\mathbf{n}\)</span> 夹角的余弦； + 若不相交，则<span class="math inline">\((k_1,k_2)\)</span> 是 <span class="math inline">\(B_1\)</span> 的球心到 <span class="math inline">\(B_2\)</span> 的有向距离除以 <span class="math inline">\(r_1\)</span>。</p><p>类似地当 <span class="math inline">\(B_1,B_2\)</span>都是超平面时，<span class="math inline">\((k_1,k_2)=(\mathbf{n}_1,\mathbf{n}_2)\)</span>是它们法向量夹角的余弦。</p><div id="suff-for-disjoint" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(B_1,B_2\)</span> 是两个球，且 <span class="math inline">\(B_1,B_2\)</span> 的内部不相交。设 <span class="math inline">\(k_1,k_2\)</span> 分别是它们对应的 space-like的单位向量，则 <span class="math inline">\((k_1,k_2)\leq-1\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个命题反过来是不对的。</p></div><p><strong>证明</strong>：<span class="math inline">\(B_1\)</span> 和<span class="math inline">\(B_2\)</span> 内部不相交有如下几种可能：</p><ol type="1"><li><span class="math inline">\(B_1,B_2\)</span> 都是球，半径 <span class="math inline">\(r_1,r_2\)</span> 都大于 0，并且 <span class="math inline">\(r_1+r_2 \geq|\mathbf{a}_1-\mathbf{a}_2|\)</span>。</li><li><span class="math inline">\(B_1,B_2\)</span> 都是球，半径 <span class="math inline">\(r_1&gt;0,\, r_2&lt;0\)</span>，且 <span class="math inline">\(B_1\)</span> 位于 <span class="math inline">\(B_2\)</span> 另一侧的有界区域，即 <span class="math inline">\(-r_2-r_1\geq|\mathbf{a}_1-\mathbf{a}_2|\)</span>。</li><li><span class="math inline">\(B_1\)</span> 是球，其半径 <span class="math inline">\(r_1&gt;0\)</span>；<span class="math inline">\(B_2\)</span> 是超平面，且 <span class="math inline">\(B_1\)</span> 位于 <span class="math inline">\(B_2\)</span> 的负半空间，从而其球心 <span class="math inline">\(\mathbf{a}_1\)</span> 到 <span class="math inline">\((\mathbf{n},\mathbf{x})=d\)</span> 的有向距离<span class="math inline">\(\leq-r_1\)</span>，即 <span class="math inline">\((\mathbf{a}_1,\mathbf{n})-d\leq-r_1\)</span>。</li><li><span class="math inline">\(B_1,B_2\)</span>是互相平行的超平面，且法向量相反的，即 <span class="math inline">\((\mathbf{n}_1,\mathbf{n}_2)=-1\)</span>。</li></ol><p>不难验证这些都可以推出 <span class="math inline">\((k_1,k_2)\leq-1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><h1 id="球的反演">球的反演</h1><p>这一节读者可以参考 <span class="citation" data-cites="Iversen_1992">(<a href="#ref-Iversen_1992" role="doc-biblioref">Iversen 1992, sec. I.7</a>)</span>。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义4.1</span>.</span><span class="statement-spah"> </span>关于球 <span class="math inline">\(B(\mathbf{a}, r)\)</span> 的反演定义为 <span class="math display">\[\begin{aligned}\tau\colon\ \overline{\mathbb{R}^n}&amp;\mapsto\overline{\mathbb{R}^n}\\\tau(\mathbf{x})&amp;=\frac{r^2}{|\mathbf{x}-\mathbf{a}|^2}(\mathbf{x}-\mathbf{a})+\mathbf{a}.\end{aligned}\]</span></p></div><p><span class="math inline">\(\tau\)</span> 是 <span class="math inline">\(\overline{\mathbb{R}^n}\)</span> 中关于球面镜<span class="math inline">\(B\)</span> 的反射，它保持 <span class="math inline">\(B\)</span> 的表面不动，将 <span class="math inline">\(B\)</span> 的内部映射为外部（反之亦然），并且<span class="math inline">\(\tau^2=1\)</span>。</p><p><img src="/images/coxeter/sphere-inversion.svg" class="fig" width="400"></p><p>我们来说明 <span class="math inline">\(\tau\)</span> 可以实现为 <span class="math inline">\(\mathrm{P}(\mathbb{R}^{n+1,1})\)</span>中的射影正交变换。</p><p>设 <span class="math inline">\(B(\mathbf{a},r)\)</span> 对应 <span class="math inline">\(k\in\mathcal{S}\)</span>，考察以 <span class="math inline">\(k\)</span> 为法向量的镜面反射 <span class="math display">\[\begin{aligned}\rho\colon\ \mathbb{R}^{n+1,1}&amp;\mapsto\mathbb{R}^{n+1,1}\\\rho(v) &amp;= v - 2(v,k)k.\end{aligned}\]</span> 则 <span class="math inline">\(\rho\)</span> 是<span class="math inline">\(\mathbb{R}^{n+1,1}\)</span>上的正交变换，从而也给出 <span class="math inline">\(\mathrm{P}(\mathbb{R}^{n+1,1})\)</span>上的射影变换。</p><p>注意 <span class="math inline">\(\rho\)</span>保持光锥的两个分支不变，即 <span class="math inline">\(\rho(\mathcal{Q}_\pm)\subset\mathcal{Q}_\pm\)</span>。这是因为，如果<span class="math inline">\(v\in\mathcal{Q}_+\)</span>，则 <span class="math inline">\((v,v)\leq0\)</span>，并且 <span class="math inline">\((v, \rho(v)) = (v,v) -2(v,k)^2\leq0\)</span>。若不等号严格成立，自然有 <span class="math inline">\(v\sim\rho(v)\)</span>。若等号成立，则 <span class="math inline">\((v,v)=(v,k)=0\)</span>，从而 <span class="math inline">\(\rho(v)=v\)</span>。</p><p>我们来计算 <span class="math inline">\(\rho\)</span> 作用在 <span class="math inline">\(\imath(\mathbf{x})\,(\mathbf{x}\in\mathbb{R}^n)\)</span>上的效果：（注意 <span class="math inline">\((\imath(\mathbf{x}),k)=\frac{r^2-|\mathbf{x}-\mathbf{a}|^2}{r}\)</span>）<span class="math display">\[\begin{aligned}\begin{pmatrix}1\\\mathbf{x}\\ |\mathbf{x}|^2\end{pmatrix}&amp;\xrightarrow{\rho}\begin{pmatrix}1\\\mathbf{x}\\ |\mathbf{x}|^2\end{pmatrix}-\frac{r^2-|\mathbf{x}-\mathbf{a}|^2}{r}\begin{pmatrix}\frac{1}{r}\\\frac{\mathbf{a}}{r}\\\frac{|\mathbf{a}|-r^2}{r}\end{pmatrix}\\&amp;=\begin{pmatrix}\frac{|\mathbf{x}-\mathbf{a}|^2}{r^2}\\\mathbf{x}+\left(\frac{|\mathbf{x}-\mathbf{a}|^2-r^2}{r^2}\right)\mathbf{a}\\\ast \end{pmatrix}\\&amp;\stackrel{+}{\sim}\begin{pmatrix}1\\\mathbf{a}+\frac{r^2}{|\mathbf{x}-\mathbf{a}|^2}(\mathbf{x}-\mathbf{a})\\\ast \end{pmatrix}\\&amp;=\begin{pmatrix}1\\\tau(\mathbf{x})\\ |\tau(\mathbf{x})|^2\end{pmatrix}.\end{aligned}\]</span> 这里我们不用关心 <span class="math inline">\(\ast\)</span> 是什么，中间的 <span class="math inline">\(\stackrel{+}{\sim}\)</span>表示两个向量<strong>正</strong>射影等价。</p><p>于是我们有如下的交换图：</p><p><span class="math display">\[\require{amsCd}\begin{CD}\overline{\mathbb{R}^n}@&gt;{\imath}&gt;&gt;\mathrm{P}(\mathbb{L}^{n+1})\\@V{\tau}VV  @VV{\rho}V \\\overline{\mathbb{R}^n}@&gt;{\imath}&gt;&gt;\mathrm{P}(\mathbb{L}^{n+1})\end{CD}\]</span></p><p>进一步，将任意球 <span class="math inline">\(B'\)</span> 关于<span class="math inline">\(B\)</span> 作反演也可以通过 <span class="math inline">\(\rho\)</span> 来计算。设 <span class="math inline">\(k'\)</span> 是 <span class="math inline">\(B'\)</span> 对应的 space-like 的单位向量，则<span class="math inline">\(\rho(k')\)</span> 也是 space-like的单位向量，从而 <span class="math inline">\(\rho(k')\)</span>对应某个球 <span class="math inline">\(B''\)</span>。根据上面的交换图有 <span class="math inline">\(\rho\imath=\imath\tau\)</span>，于是 <span class="math display">\[\mathbf{x}\in B'\Leftrightarrow(\imath(\mathbf{x}), k')=0\Leftrightarrow(\rho\imath(\mathbf{x}), \rho(k'))=0\Leftrightarrow(\imath\tau(\mathbf{x}), \rho(k'))=0\Leftrightarrow \tau(\mathbf{x})\in B''.\]</span> 即关于 <span class="math inline">\(B\)</span> 的反演 <span class="math inline">\(\tau\)</span> 将 <span class="math inline">\(B'\)</span> 映射为 <span class="math inline">\(B''\)</span>。</p><h1 id="双曲球堆">双曲球堆</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.1</span>.</span><span class="statement-spah"> </span>如果非空集合<span class="math inline">\(\mathcal{P}\subset \mathcal{S}\)</span>满足对任意 <span class="math inline">\(k\nek'\in\mathcal{P}\)</span> 有 <span class="math inline">\((k,k')\leq -1\)</span>，则称 <span class="math inline">\(\mathcal{P}\)</span>是一个<strong>球堆</strong>。</p></div><p>如果 <span class="math inline">\(\mathcal{P}\)</span> 形如 <span class="math inline">\(\mathcal{P}=\{k,-k\}\)</span>，就称 <span class="math inline">\(\mathcal{P}\)</span>是平凡的，因为它由一个球的内部和外部组成。否则就称 <span class="math inline">\(\mathcal{P}\)</span> 是非平凡球堆。<span class="math inline">\(-\mathcal{P}=\{-k\mid k\in\mathcal{P}\}\)</span>也是球堆，它是通过翻转 <span class="math inline">\(\mathcal{P}\)</span>中每个球的内部和外部得到的。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.2</span>.</span><span class="statement-spah"> </span>记超平面 <span class="math inline">\(\{v\in V\mid (v,e_{n+2})=1\}\)</span> 与 <span class="math inline">\(\mathcal{Q}_+\)</span> 的“截面”为 <span class="math display">\[\mathcal{H}= \{v\in \mathcal{Q}_+\mid (v,e_{n+2})=1\}.\]</span> 给定 <span class="math inline">\(k\inS\)</span>，定义球帽 <span class="math display">\[C_k =\{v\in\mathcal{H}\mid (v,k)\geq0\}.\]</span></p></div><p>根据定义球帽总是位于同一个分支 <span class="math inline">\(\mathcal{Q}_+\)</span> 中，因此 <span class="math inline">\(u\sim v\)</span> 对所有 <span class="math inline">\(u\in C_k,v\in C_{k'}\)</span> 成立。</p><p>下面的引理告诉我们，如果 <span class="math inline">\(v\)</span>严格落在 <span class="math inline">\(C_k\)</span>的内部，则我们可以稍微“扰动” <span class="math inline">\(v\)</span>，得到无限多个落在 <span class="math inline">\(C_k\)</span> 中的 time-like 的向量。</p><div id="perturb" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span> 是球堆，<span class="math inline">\(k\in\mathcal{P}\)</span>。设 <span class="math inline">\(v\in C_k\)</span> 满足 <span class="math inline">\((v,k)=a&gt;0\)</span>。则对任何 <span class="math inline">\(0&lt;t\leq a\)</span>，<span class="math inline">\(u=v-tk\)</span> 都满足：</p><ol type="1"><li><span class="math inline">\(u\)</span> 是 time-like 的并且 <span class="math inline">\(u\sim v\)</span>；</li><li><span class="math inline">\((u,k)&gt;0\)</span>。</li></ol><p>从而 <span class="math inline">\(u\)</span> 的某个正倍数 <span class="math inline">\(u'\in C_k\)</span>。进一步，如果 <span class="math inline">\(k'\ne k\in\mathcal{P}\)</span> 满足 <span class="math inline">\(v\in C_k\cap C_{k'}\)</span>，则同样有 <span class="math inline">\(u'\in C_k\cap C_{k'}\)</span>。</p></div><p><strong>证明</strong>：直接计算可得：</p><p><span class="math display">\[\begin{aligned}(u,u)&amp;=(v,v)-2at + t^2 \leq -2at+t^2 &lt; 0,\\(u,v)&amp;=(v,v)-at \leq at&lt;0.\end{aligned}\]</span> 即 <span class="math inline">\(u\)</span> 是time-like 的并且 <span class="math inline">\(u\sim v\)</span>，从而<span class="math inline">\(u\)</span> 的某个正倍数 <span class="math inline">\(u'\in \mathcal{H}\)</span>。又因为 <span class="math inline">\((u,k)=a-t\geq0\)</span>，所以也有 <span class="math inline">\((u',k)\geq0\)</span>，从而 <span class="math inline">\(u'\in C_k\)</span>。</p><p>如果存在 <span class="math inline">\(k'\nek\in\mathcal{P}\)</span> 使得 <span class="math inline">\(v\inC_{k'}\)</span>，则 <span class="math inline">\((v,k')\geq0\)</span>，从而 <span class="math display">\[(u,k')=(v,k') - t(k,k')\geqt&gt;0.\]</span> 于是 <span class="math inline">\((u',k')\geq0\)</span>，所以 <span class="math inline">\(u'\)</span> 也属于 <span class="math inline">\(C_{k'}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="contain-time-like" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span> 是球堆且 <span class="math inline">\(k_1\nek_2\in\mathcal{P}\)</span>。则以下三点等价：</p><ol type="1"><li><span class="math inline">\(|C_{k_1}\capC_{k_2}|&gt;1\)</span>；</li><li>存在 <span class="math inline">\(v\in C_{k_1}\cap C_{k_2}\)</span>且 <span class="math inline">\(v\)</span> 是 time-like 的；</li><li>存在 <span class="math inline">\(v\in C_{k_1}\cap C_{k_2}\)</span>使得不等式 <span class="math inline">\((v,k_1)&gt;0\)</span> 和 <span class="math inline">\((v,k_2)&gt;0\)</span> 至少有一个成立。</li></ol></div><p><strong>证明</strong>：首先由 <span class="math inline">\((k_1+k_2,k_1+k_2)=2+2(k_1,k_2)\leq0\)</span> 可知<span class="math inline">\(k_1+k_2\)</span> 是 time/light-like 的。</p><p><span class="math inline">\(1\Rightarrow 2\)</span>：设 <span class="math inline">\(u\ne v\in C_{k_1}\cap C_{k_2}\)</span>，则 <span class="math inline">\(u,v\)</span> 不共线，从而 <span class="math inline">\((u,v)&lt;0\)</span>。记 <span class="math inline">\(z=u+v\)</span>，<span class="math inline">\(z\)</span> 是 time-like 的，并且 <span class="math inline">\(z\)</span> 的某个正倍数 <span class="math inline">\(z'\)</span> 属于 <span class="math inline">\(\mathcal{H}\)</span>。<span class="math inline">\(z'\)</span> 即为所求。</p><p><span class="math inline">\(2\Rightarrow 3\)</span>：设 <span class="math inline">\(v\in C_{k_1}\cap C_{k_2}\)</span> 是 time-like的，则 <span class="math inline">\((v,k_1)\geq0,\,(v,k_2)\geq0\)</span>。我们断言这两个不等式至少有一个是严格的。若不然，则<span class="math inline">\((v,k_1+k_2)=0\)</span>。然而 <span class="math inline">\(k_1+k_2\)</span> 是 time/light-like 的，而 <span class="math inline">\(v\)</span> 是 time-like 的，这不可能。</p><p><span class="math inline">\(3\Rightarrow 1\)</span>：不妨设 <span class="math inline">\(a=(v,k_1)&gt;0\)</span>。根据 <a href="#perturb" title="引理 5.3">引理 5.3</a>，对任何 <span class="math inline">\(t\in(0,a]\)</span> 我们都可以得到对应的 <span class="math inline">\(u'\in C_k\capC_{k'}\)</span>。不难看到不同的 <span class="math inline">\(t\)</span> 给出的 <span class="math inline">\(u'\)</span> 互不相同，于是 <span class="math inline">\(|C_{k_1}\cap C_{k_2}|=\infty &gt; 1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="disjoint-pair" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.5</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span> 是球堆且 <span class="math inline">\(k_1\ne k_2\in\mathcal{P}\)</span>，则集合 <span class="math inline">\(C_{k_1}\cap C_{k_2}\)</span> 和 <span class="math inline">\(C_{-k_1}\cap C_{-k_2}\)</span>中必有一个至多只包含一个点。并且当这两个集合中的某个恰好只含一个点时，此点与<span class="math inline">\(k_1+k_2\)</span> 共线，并且有 <span class="math inline">\((k_1,k_2)=-1\)</span> 成立。</p></div><p><strong>证明</strong>： 若 <span class="math inline">\(C_{k_1}\capC_{k_2}\)</span> 和 <span class="math inline">\(C_{-k_1}\capC_{-k_2}\)</span> 均不为空，取 <span class="math inline">\(u\inC_{k_1}\cap C_{k_2}\)</span>，<span class="math inline">\(v\inC_{-k_1}\cap C_{-k_2}\)</span>，则 <span class="math display">\[(u,k_1+k_2)\geq0,\quad (v,k_1+k_2)\leq0.\]</span>如果上面两个不等号都是严格成立的，则 <span class="math inline">\(u\not\sim k_1+k_2\)</span> 但是 <span class="math inline">\(v\sim k_1+k_2\)</span>，这与 <span class="math inline">\(u\sim v\)</span>矛盾。所以至少有一个等号是成立的，即 <span class="math inline">\(u,v\)</span> 之中必有一个与 <span class="math inline">\(k_1+k_2\)</span> 共线，并且 <span class="math inline">\(k_1+k_2\)</span> 是 light-like 的向量。由此可得<span class="math inline">\((k_1,k_2)=-1\)</span> 并且 <span class="math inline">\(|C_{k_1}\cap C_{k_2}|\leq1\)</span> 和 <span class="math inline">\(|C_{-k_1}\cap C_{-k_2}|\leq1\)</span>中至少有一个成立。</p><p>如果这两个集合，不妨设为 <span class="math inline">\(C_{k_1}\capC_{k_2}\)</span>，恰好只有一个点。记这个点为 <span class="math inline">\(u\)</span>。如果 <span class="math inline">\(u\)</span> 与 <span class="math inline">\(k_1+k_2\)</span> 不共线的话，则必有 <span class="math inline">\((u,k_1+k_2)&gt;0\)</span>，从而 <span class="math inline">\((u,k_1)\)</span> 和 <span class="math inline">\((u,k_2)\)</span> 中至少有一个大于 0。根据 <a href="#contain-time-like" title="引理 5.4">引理 5.4</a> 有 <span class="math inline">\(|C_k\cap C_{k'}|=\infty\)</span>，矛盾。所以<span class="math inline">\(u\)</span> 必然与 <span class="math inline">\(k_1+k_2\)</span> 共线。<span class="math inline">\(\blacksquare\)</span></p><div id="thm-sphere-packing" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.6</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span>是非空集合，则下面两点是等价的：</p><ol type="1"><li><span class="math inline">\(\mathcal{P}\)</span>是一个非平凡的球堆。</li><li>对 <span class="math inline">\(\mathcal{P}\)</span> 或者 <span class="math inline">\(-\mathcal{P}\)</span> 之一，其包含的任何两个球帽<span class="math inline">\(C_k\)</span> 和 <span class="math inline">\(C_{k'}\)</span> 至多有一个公共点。</li></ol></div><p><strong>证明</strong>：</p><p>1 <span class="math inline">\(\Rightarrow\)</span> 2：根据 <a href="#disjoint-pair" title="引理 5.5">引理 5.5</a>，不妨设 <span class="math inline">\(k_1,k_2\in\mathcal{P}\)</span> 使得 <span class="math inline">\(|C_{k_1}\capC_{k_2}|\leq1\)</span>，我们要证明对任何 <span class="math inline">\(k\ne k'\in\mathcal{P}\)</span> 同样有 <span class="math inline">\(|C_k\cap C_{k'}|\leq1\)</span>。如果 <span class="math inline">\(\{k,k'\}=\{k_1,k_2\}\)</span>结论显然成立，所以不妨设 <span class="math inline">\(k\notin\{k_1,k_2\}\)</span>。用反证法，若 <span class="math inline">\(|C_k\cap C_{k'}|&gt;1\)</span>，根据 <a href="#contain-time-like" title="引理 5.4">引理 5.4</a>，存在 time-like的向量 <span class="math inline">\(v\in C_k\cap C_{k'}\)</span>。令<span class="math inline">\(w=k_1-(k_1,k_2)k_2\)</span>，则有 <span class="math display">\[(w,w)=1-(k_1,k_2)^2\leq0,\quad (w, k)&lt;0,\quad(w, k')\leq0.\]</span> 我们来证明 <span class="math inline">\(v\simw\)</span>。若如此，则 <span class="math inline">\(w\)</span>的某个正倍数 <span class="math inline">\(w'\in\mathcal{H}\)</span>，并且 <span class="math display">\[(w',-k)&gt;0,\quad(w',-k')\geq0.\]</span> 从而由 <a href="#contain-time-like" title="引理 5.4">引理 5.4</a> 有 <span class="math inline">\(|C_{-k}\capC_{-k'}|&gt;1\)</span>，与 <a href="#disjoint-pair" title="引理 5.5">引理 5.5</a> 矛盾。由于 <span class="math inline">\(v\)</span> 是 time-like 的，我们只要证明有 <span class="math inline">\((v,w)\leq0\)</span> 成立即可。利用 <span class="math display">\[(v,w)=(v, k_1) - (v,k_2)(k_1,k_2) =(v-(v,k_2)k_2, k_1).\]</span> 并记 <span class="math inline">\(u=v-(v,k_2)k_2\)</span>，问题转化为证明 <span class="math inline">\((u,k_1)\leq0\)</span>。计算可得 <span class="math display">\[\begin{aligned}(u,k_2) &amp;= (v,k_2) - (v,k_2)(k_2,k_2)=0,\\(u,u)&amp;=(u,v)-(v,k_2)(u,k_2) = (u,v),\\(u,v)&amp;=(v,v)-(v,k_2)^2 \leq (v,v)&lt;0.\end{aligned}\]</span> 即 <span class="math inline">\(u\)</span> 是 time-like 的且<span class="math inline">\(u\sim v\)</span>。于是 <span class="math inline">\(u\)</span> 的某个正倍数 <span class="math inline">\(u'\)</span> 属于 <span class="math inline">\(\mathcal{H}\)</span>。如果 <span class="math inline">\((u,k_1)&gt;0\)</span> 的话则 <span class="math inline">\(u'\)</span> 是 time-like 的向量且满足 <span class="math inline">\((u',k_1)&gt;0\)</span> 和 <span class="math inline">\((u',k_2)=0\)</span>，从而 <span class="math inline">\(u'\in C_{k_1}\cap C_{k_2}\)</span>。但根据 <a href="#contain-time-like" title="引理 5.4">引理 5.4</a> 这会导致 <span class="math inline">\(|C_{k_1}\cap C_{k_2}|&gt;1\)</span>，矛盾。因此<span class="math inline">\((u,k_1)\leq0\)</span>。</p><p>2 <span class="math inline">\(\Rightarrow\)</span> 1: 不妨设 <span class="math inline">\(\mathcal{P}\)</span>中任何两个球帽至多只有一个交点。对 <span class="math inline">\(k_1\nek_2\in\mathcal{P}\)</span>，<span class="math inline">\(U=\mathrm{span}\{k_1,k_2\}\)</span> 肯定不是space-like 的，否则 <span class="math inline">\(U^\bot=k_1^\bot\capk_2^\bot\)</span> 是 time-like 的，则存在 time-like 的向量 <span class="math inline">\(v\)</span> 满足 <span class="math inline">\((v,k_1)=(v,k_2)=0\)</span>。给 <span class="math inline">\(v\)</span> 乘以适当实数后可以使得 <span class="math inline">\(v\in\mathcal{H}\)</span>，从而 <span class="math inline">\(v\in C_{k_1}\cap C_{k_2}\)</span>，这与 <a href="#contain-time-like" title="引理 5.4">引理 5.4</a> 矛盾。所以 <span class="math inline">\(U\)</span> 不是 space-like 的，即 <span class="math inline">\(|(k_1,k_2)|\geq1\)</span>。如果 <span class="math inline">\((k_1,k_2)\geq1\)</span>，则 <span class="math inline">\(C_{k_1}\cap C_{-k_2}\)</span> 和 <span class="math inline">\(C_{-k_1}\cap C_{k_2}\)</span>中必有一个至多只包含一个点，不妨设 <span class="math inline">\(|C_{k_1}\cap C_{-k_2}|\leq1\)</span>。但是根据已知<span class="math inline">\(C_{k_1}\cap C_{k_2}\)</span>也至多只包含一个点，从而 <span class="math inline">\(C_{k_1}\)</span>作为二者的并至多只有一个点，矛盾。所以只能是 <span class="math inline">\((k_1,k_2)\leq-1\)</span>，从而 <span class="math inline">\(\mathcal{P}\)</span> 是球堆。 <span class="math inline">\(\blacksquare\)</span></p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.7</span>.</span><span class="statement-spah"> </span>记 <span class="math inline">\(\Omega_r=\{\omega\in\Omega\mid(\omega,\omega)&gt;0\}\)</span> 是所有实权组成的集合，<span class="math inline">\(\mathcal{C}_r=\mathrm{cone}(\Omega_r)\)</span>是由所有实权生成的凸锥。</p></div><div id="real-cone-closure" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.8</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(W\)</span> 是不可约、双曲的，且 level 大于等于2，则 <span class="math inline">\(\overline{\mathcal{C}_r}= \overline{\mathcal{C} }\)</span>。</p></div><p><strong>证明</strong>：只要证明 <span class="math inline">\(\overline{\mathcal{C}_r}\)</span>包含那些非实的基本权 <span class="math inline">\((\omega_s,\omega_s)\leq 0\)</span> 即可。若如此，则 <span class="math inline">\(\overline{\mathcal{C}_r}\)</span> 包含全部基本权<span class="math inline">\(\Delta^\ast\)</span>，从而也包含 <span class="math inline">\(\mathrm{cone}(\Delta^\ast)=\overline{\mathcal{D}}\)</span>，再结合<span class="math inline">\(\overline{\mathcal{C}_r}\)</span> 是 <span class="math inline">\(W\)</span>- 不变的，即得 <span class="math inline">\(\overline{\mathcal{C}_r}\)</span> 包含 <span class="math inline">\(\bigcup\limits_{w\inW}w\overline{\mathcal{D}}=\mathcal{C}\)</span>，从而包含 <span class="math inline">\(\overline{ \mathcal{C} }\)</span>。</p><p>设 <span class="math inline">\(\omega_s\)</span>是任一非实的基本权，记 <span class="math inline">\(I=S-\{s\}\)</span>，<span class="math inline">\(W_I\)</span> 为标准椭圆子群。分情况讨论：</p><p><span class="math inline">\(\color{blue}(\omega_s,\omega_s)&lt;0\)</span></p><p>这时 <span class="math inline">\(\omega_s\)</span> 是 time-like的，其正交补 <span class="math inline">\(V_I=\mathrm{span}\{\alpha_t\midt\ne s\}\)</span> 是 space-like 的，从而 <span class="math inline">\(W_I\)</span> 是有限群。任取一个实的基本权 <span class="math inline">\((\omega_t,\omega_t)&gt;0\,(t\in I)\)</span> 并考虑<span class="math display">\[v = \sum_{w\in W_I}w(\omega_t).\]</span>显然 <span class="math inline">\(v\in\overline{\mathcal{C}_r}\)</span>，并且 <span class="math inline">\(W_I\)</span> 保持 <span class="math inline">\(v\)</span> 不动。特别地对任何 <span class="math inline">\(t\in I\)</span> 都有 <span class="math inline">\(t(v)=v\)</span>。这是 <span class="math inline">\(n-1\)</span>个独立的线性约束，其解空间是一维的，所以 <span class="math inline">\(v\)</span> 和 <span class="math inline">\(\omega_s\)</span> 共线：存在 <span class="math inline">\(a\in\mathbb{R}\)</span> 使得 <span class="math inline">\(v=a\omega_s\)</span>。两边同时与 <span class="math inline">\(\alpha_s\)</span> 作内积得到 <span class="math display">\[a = (\alpha_s,v)=\sum_{w\inW_I}(\alpha_s,w(\omega_t))=\sum_{w\in W_I}(w^{-1}(\alpha_s),\omega_t)=\sum_{w\in W_I}(w(\alpha_s), \omega_t).\]</span> 对任何 <span class="math inline">\(w\in W_I\)</span>，<span class="math inline">\(w\alpha_s=\alpha_s+\sum_{i\inI}c_i\alpha_i\)</span> 仍然是正根，所有的系数 <span class="math inline">\(c_i\)</span> 都非负。所以上式右边的每一项 <span class="math display">\[(w(\alpha_s), \omega_t)=\sum_{i\inI}c_i(\alpha_i, w_t) = c_t\geq0.\]</span> 我们来选择一个特殊的 <span class="math inline">\(w\in W_I\)</span> 使得 <span class="math inline">\(c_t&gt;0\)</span>：由于 <span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(\Gamma\)</span> 中存在一条从 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(t\)</span> 的路径 <span class="math inline">\(s\sim s_1\sim\cdots\sim s_m=t\)</span>，其中每个<span class="math inline">\(s_i\,(i\geq1)\in I\)</span>且互不相同。不难验证对 <span class="math inline">\(w=s_m\cdots s_1\inW_I\)</span>，<span class="math inline">\(w\alpha_s\)</span> 的系数<span class="math inline">\(c_t&gt;0\)</span>，所以 <span class="math inline">\(a\)</span> 严格大于 0，从而 <span class="math inline">\(\omega_s=v/a\in\overline{\mathcal{C}_r}\)</span>。</p><p><span class="math inline">\(\color{blue}(\omega_s,\omega_s)=0\)</span></p><p>这个情形要麻烦一些。这时 <span class="math inline">\(\omega_s\)</span> 的正交补 <span class="math inline">\(\omega_s^\bot\)</span> 是 light-like 的，即子图<span class="math inline">\(\Gamma\setminus\{s\}\)</span> 是仿射的。所以<span class="math inline">\(\Gamma\setminus\{s\}\)</span>由一些仿射或者有限的连通成分组成，由于内积是双曲的，这些连通成分中有且恰有一个是仿射的。任取一个实的基本权<span class="math inline">\((\omega_t,\omega_t)&gt;0\,(t\inI)\)</span>，分两种情况：</p><ol type="1"><li><p>如果 <span class="math inline">\(\omega_t\)</span>属于某个有限型的连通成分 <span class="math inline">\(Y\)</span>，类似上面的讨论，<span class="math inline">\(v\)</span> 是 <span class="math inline">\(\omega_s\)</span> 的某个正倍数，从而 <span class="math inline">\(\omega_s\in\overline{\mathcal{C}_r}\)</span>。</p></li><li><p>如果 <span class="math inline">\(\omega_t\)</span>属于某个仿射型的连通成分 <span class="math inline">\(X\)</span>，记<span class="math inline">\(\Gamma_1=X\cup \{s\}\)</span>，<span class="math inline">\(Y=\Gamma\setminus\Gamma_1\)</span>，则 <span class="math inline">\(Y\)</span> 是有限型，并且 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 互不连通（它们必然通过 <span class="math inline">\(s\)</span> 连在一起），从而 <span class="math display">\[\omega_s = \underbrace{(\omega_s,\omega_s)}_{=0}\alpha_s + \sum_{t\ne s} (\omega_s,\omega_t)\alpha_t=\sum_{t\in X} (\omega_s,\omega_t)\alpha_t + \sum_{t\inY} (\omega_s,\omega_t)\alpha_t=v_1+v_2.\]</span> 这里 <span class="math inline">\(v_1\)</span> 和 <span class="math inline">\(v_2\)</span> 是正交的。于是 <span class="math display">\[(\omega_s, \omega_s)=0\Rightarrow(v_1+v_2,v_1+v_2)=0\Rightarrow (v_1,v_1) + (v_2,v_2) = 0.\]</span> 由于<span class="math inline">\(V_X\)</span> 是不可约仿射的，<span class="math inline">\(V_Y\)</span> 是有限的，所以 <span class="math inline">\(v_2=0\)</span>，并且 <span class="math inline">\(\mathbb{R}v_1=\mathrm{rad}(V_X)\)</span>。从而<span class="math inline">\(\omega_s=v_1\)</span>，并且 <span class="math inline">\(\mathbb{R}\omega_s=\mathrm{rad}(V_X)\)</span>。<span class="math inline">\(\omega_s\)</span> 表示为 <span class="math inline">\(\{\alpha_i\mid i\in X\}\)</span>的线性组合时，所有的系数 <span class="math inline">\((\omega_s,\omega_i)\)</span>系数都是非零且同号的。我们断言它们都小于 0。实际上在 <span class="math display">\[\omega_s=\sum_{i\in X}(\omega_s,\omega_i)\alpha_i\]</span> 两边同时用 <span class="math inline">\(\alpha_s\)</span> 作内积有 <span class="math display">\[1=\sum_{i\in X} (\omega_s,\omega_i)\underbrace{(\alpha_s,\alpha_i)}_{\leq0}.\]</span> 所以必须所有<span class="math inline">\((\omega_s, \omega_i)&lt;0\)</span>。<br>于是 <span class="math inline">\(\Gamma_1\)</span> 满足 <a href="/coxeter-groups/level/#ideal-vertex">这个结论</a> 的条件（取 <span class="math inline">\(I=X,\,p=\omega_t,\,\omega_s=\omega_s\)</span>代入），从而我们得到 <span class="math display">\[\omega_s\in\overline{\mathrm{cone}(\bigcup_{w\in W_X}w(\omega_t))}\subset\overline{\mathcal{C}_r}.\]</span> <span class="math inline">\(\blacksquare\)</span></p></li></ol><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.9</span>.</span><span class="statement-spah"> </span>规定 <span class="math inline">\(\hat{\Omega}_r=\{\hat{\omega}\mid\omega\in\Omega_r\}\)</span>，其中 <span class="math inline">\(\hat{\omega}=\omega/\sqrt{(\omega,\omega)}\)</span>是将 <span class="math inline">\(\omega\)</span>归一化得到的单位向量。</p></div><div id="max-packing" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.10</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(W\)</span> 是双曲的，则 <span class="math inline">\(\hat{\Omega}_r\)</span> 是非平凡的球堆当且仅当<span class="math inline">\(\Gamma\)</span> 的 level 是 2，这时 <span class="math inline">\(\hat{\Omega}_r\)</span> 还是极大球堆。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(\Gamma\)</span>的 level 是 2，则 <a href="/coxeter-groups/level#level-12"><span class="math inline">\(\Omega_r\)</span>中的元素两两分离</a>，将其归一化后得到的 <span class="math inline">\(\hat{\Omega}_r\)</span> 仍然两两分离，所以 <span class="math inline">\(\hat{\Omega}_r\)</span> 的元素两两之间的内积 <span class="math inline">\(\leq -1\)</span>，从而 <span class="math inline">\(\hat{\Omega}_r\)</span>给出一个球堆。由于基本权是线性无关的，<span class="math inline">\(\hat{\Omega}_r\)</span>显然是非平凡的球堆。如果存在某个 space-like 的向量 <span class="math inline">\(k\)</span> 满足 <span class="math inline">\((k,k)=1\)</span> 且 <span class="math inline">\(k\)</span> 对应的 <span class="math inline">\(C_k\)</span> 与 <span class="math inline">\(\hat{\Omega}_r\)</span>中的任何球都没有公共内部的话，则有 <span class="math inline">\((k,\hat{\omega})\leq -1\)</span> 对任何 <span class="math inline">\(\hat{\omega}\in\hat{\Omega}_r\)</span>成立，自然就有 <span class="math inline">\((k,\omega)&lt;0\)</span>对任何 <span class="math inline">\(\omega\in\Omega_r\)</span> 成立，从而<span class="math inline">\((k,y)\leq0\)</span> 对任何 <span class="math inline">\(y\in\overline{\mathcal{C}_r}=\mathrm{cone}(\Omega_r)\)</span>成立。根据 <a href="#real-cone-closure" title="定理 5.8">定理5.8</a>，<span class="math inline">\(\overline{\mathcal{C}_r}=\overline{\mathcal{C} }\)</span>，这意味着 <span class="math inline">\((k,y)\leq0\)</span> 对任何 <span class="math inline">\(y\in\mathcal{C}\)</span> 成立，即 <span class="math inline">\(-k\in\mathcal{C}^\ast\)</span>。由于 <a href="/coxeter-groups/tits-cone/#dual-cone-nonspace">对偶锥 <span class="math inline">\(\mathcal{C}^\ast\)</span> 中的向量范数 <span class="math inline">\(\leq0\)</span></a>，<span class="math inline">\((k,k)=(-k,-k)\leq0\)</span>，这与 <span class="math inline">\((k,k)=1\)</span> 矛盾。这就证明了 level 2 时 <span class="math inline">\(\Omega_r\)</span> 是极大球堆。</p><p>反之若 <span class="math inline">\(\hat{\Omega}_r\)</span>是一个非平凡球堆，则 <span class="math inline">\(W\)</span> 的 level必然大于 1，且所有的实权之间两两分离。于是任何两个基本权生成的二维子空间<span class="math inline">\(\mathrm{span}\{\omega_i,\omega_j\}\)</span>都是 time-like 或者 light-like 的。又由于 <span class="math inline">\(W\)</span> 是双曲的，从而 <span class="math inline">\(\Gamma\setminus\{i,j\}\)</span> 是 space-like 或者light-like 的，所以 <span class="math inline">\(\Gamma\)</span> 的 level只能是 2。<span class="math inline">\(\blacksquare\)</span></p><h1 id="计算例子">计算例子</h1><p>本节我们来介绍怎样用程序实际绘制一个二维的 Boyd-Maxwell 球堆。</p><p>以 <span class="math inline">\(K_4\)</span>完全图为例，每条边的标号是 4：</p><p><img src="/images/coxeter/K4.svg" id="K4" class="fig" width="150"></p><p>这个群的 rank 是 4，level 是 2，所以给出的是 <span class="math inline">\(\mathbb{R}^2\)</span> 上的二维极大球堆。</p><p>单根系 <span class="math inline">\(\Delta=\{\alpha_i\}_{i=1}^4\)</span> 满足 <span class="math inline">\((\alpha_i,\alpha_i)=1\)</span>，它们对应 4个虚球。前面已经介绍了，以 <span class="math inline">\(\alpha_i\)</span>为法向量的单反射 <span class="math inline">\(s_i\)</span> 对应关于 <span class="math inline">\(B_i\)</span> 的反演变换，它们生成了 <span class="math inline">\((W,S)\)</span>。</p><p>由于删掉 <span class="math inline">\(K_4\)</span>的任何顶点后，剩下的是双曲三角群 <span class="math inline">\(\Delta(4,4,4)\)</span>，所以基本权 <span class="math inline">\(\Delta^\ast = \{\omega_i\}_{i=1}^4\)</span>都是实的。归一化以后 <span class="math inline">\(\{\hat{\omega}_i\}_{i=1}^4\)</span> 给出 4个互相分离的实球。由于 <span class="math inline">\(i\ne j\)</span> 时<span class="math inline">\((\alpha_i,\omega_j)=0\)</span>，所以 <span class="math inline">\(\alpha_i\)</span> 和 <span class="math inline">\(\hat{\omega}_j\)</span> 正交。又因为 <span class="math inline">\((\alpha_i,\omega_i)=1\)</span>，以及 <span class="math inline">\(\omega_i\)</span> 满足 <span class="math inline">\(0&lt;(\omega_i,\omega_i)\leq1\)</span>，所以归一化以后<span class="math inline">\((\alpha_i,\hat{\omega}_i)\geq1\)</span>，即球<span class="math inline">\(\alpha_i\)</span> 和 <span class="math inline">\(\hat{\omega}_i\)</span> 有包含关系。我们要求对每个<span class="math inline">\(i\)</span>，实球 <span class="math inline">\(\hat{\omega}_i\)</span> 包含在虚球 <span class="math inline">\(\alpha_i\)</span>的内部（即正半空间）。这是因为在计算时，我们要反复将平面上的点关于 <span class="math inline">\(\{\alpha_i\}\)</span> 作反演，直到它落入基本区域<span class="math inline">\(\overline{\mathcal{D}}\)</span>为止，然后判断这个最终位置属于哪个实球。所以我们一定要让虚球 <span class="math inline">\(\alpha_i\)</span> 包含实球 <span class="math inline">\(\hat{\omega_i}\)</span>。</p><p>将 <span class="math inline">\(W\)</span> 作用在实球 <span class="math inline">\(\{C_i\}\)</span>上，得到的所有球即为所要绘制的球堆 <span class="math inline">\(\mathcal{P}=\bigcup_{w\in W,\,1\leq i\leq4}w(\hat{\omega}_i)\)</span>。</p><p>我们按照如下步骤来分别计算 <span class="math inline">\(\{\alpha_i\}\)</span> 和 <span class="math inline">\(\{\hat{\omega}_j\}\)</span>：</p><ol type="1"><li>第一个实球 <span class="math inline">\(\hat{\omega}_1\)</span>总是可以取为单位球 <span class="math inline">\(B(\mathbf{0},1)\)</span>。<strong>并且 <span class="math inline">\(\hat{\omega}_1\)</span>是无界球</strong>。由于实球之间互不相交，所以 <span class="math inline">\(\hat{\omega}_2,\hat{\omega}_3,\hat{\omega}_4\)</span>都落在单位球内。</li><li>两个虚球 <span class="math inline">\(\alpha_3,\alpha_4\)</span>可以取为过原点的两条直线，法向量分别为 <span class="math display">\[\begin{aligned}\mathbf{n}_3&amp;=(1, 0),\\\mathbf{n}_4&amp;=(-\cos\frac{\pi}{m_{3,4}},\sin\frac{\pi}{m_{3,4}})=(-\cos\frac{\pi}{4},\sin\frac{\pi}{4}).\end{aligned}\]</span></li><li>第二个虚球 <strong><span class="math inline">\(\alpha_2=B(\mathbf{a}_2,r_2)\)</span>是一个无界球</strong>，即 <span class="math inline">\(r_2&lt;0\)</span>。我们可以认为 <span class="math inline">\(r_2&gt;0\)</span>，但是在列方程时将 <span class="math inline">\(B\)</span> 与其它球的内积取负：<ul><li>由 <span class="math inline">\(\alpha_2\)</span> 与 <span class="math inline">\(\hat{\omega}_1\)</span> 正交可得 <span class="math inline">\(|\mathbf{a}_2|^2=r_2^2+1\)</span>；</li><li>计算 <span class="math inline">\(\alpha_2\)</span> 与 <span class="math inline">\(\alpha_3,\alpha_4\)</span> 的夹角可得（注意 <span class="math inline">\(\cos\)</span> 前面没有负号了） <span class="math display">\[\begin{aligned}\frac{(\mathbf{a}_2,\mathbf{n}_3)}{r_2}&amp;=\cos\frac{\pi}{m_{23}}=\cos\frac{\pi}{4},\\\frac{(\mathbf{a}_2,\mathbf{n}_4)}{r_2}&amp;=\cos\frac{\pi}{m_{24}}=\cos\frac{\pi}{4}.\end{aligned}\]</span></li></ul>由这三个方程可以解出 <span class="math inline">\(\mathbf{a}_2\)</span>和 <span class="math inline">\(r_2\)</span>。</li><li>第一个虚球 <strong><span class="math inline">\(\alpha_1=B(\mathbf{a}_1,r_1)\)</span>也是一个无界球</strong>，即 <span class="math inline">\(r_1&lt;0\)</span>。我们同样认为 <span class="math inline">\(r_1&gt;0\)</span>，并在列方程时将它与其它球的内积取负：<ul><li>计算 <span class="math inline">\(\alpha_1\)</span> 与 <span class="math inline">\(\alpha_3,\alpha_4\)</span> 夹角可得 <span class="math display">\[\begin{aligned}\frac{(\mathbf{a}_1,\mathbf{n}_3)}{r_1}&amp;=\cos\frac{\pi}{m_{13}}=\cos\frac{\pi}{4},\\\frac{(\mathbf{a}_1,\mathbf{n}_4)}{r_1}&amp;=\cos\frac{\pi}{m_{14}}=\cos\frac{\pi}{4}.\end{aligned}\]</span></li><li>计算 <span class="math inline">\(\alpha_1\)</span> 与 <span class="math inline">\(\alpha_2\)</span> 夹角可得 <span class="math display">\[\frac{r_1^2+r_2^2-|\mathbf{a}_1-\mathbf{a}_2|^2}{2r_1r_2}=-\cos\frac{\pi}{m_{12}}=-\cos\frac{\pi}{4}.\]</span>注意由于 <span class="math inline">\(\alpha_1,\alpha_2\)</span>都是无界球，所以负号又回来了。</li></ul>由这三个方程可以得到一个二次方程，解出的 <span class="math inline">\(r_1\)</span>有两个值，我们取较小的那一个。（原因在后面解释）</li><li>我们还剩下三个实球 <span class="math inline">\(\hat{\omega}_2,\hat{\omega}_3,\hat{\omega}_4\)</span>需要解出。<span class="math inline">\(\hat{\omega}_2\)</span> 需要和<span class="math inline">\(\alpha_3,\alpha_4\)</span>正交，所以它是一个以原点为中心的球，而它又要和 <span class="math inline">\(\alpha_1\)</span> 正交，所以 <span class="math inline">\(\hat{\omega}_2\)</span> 的半径为 <span class="math inline">\(\sqrt{|\mathbf{a}_1|^2-r_1^2}\)</span>。</li><li><span class="math inline">\(\hat{\omega}_3\)</span> 与 <span class="math inline">\(\alpha_1,\alpha_2,\alpha_4\)</span>正交，这可以得到三个方程。联立解出 <span class="math inline">\(\hat{\omega}_3\)</span>。</li><li><span class="math inline">\(\hat{\omega}_4\)</span> 与 <span class="math inline">\(\alpha_1,\alpha_2,\alpha_3\)</span>正交，也可以得到三个方程，联立解出 <span class="math inline">\(\hat{\omega}_4\)</span>。</li></ol><p>结果如下图所示，单根 <span class="math inline">\(\alpha_i\)</span>对应的虚球用虚线绘制，<span class="math inline">\(\hat{\omega}_i\)</span>对应的实球用实线绘制，同样的 <span class="math inline">\(i\)</span>使用同样的颜色。上标 <span class="math inline">\(\ast\)</span>表示该球以无界区域为内部。所以我们有三个无界的球 <span class="math inline">\(\alpha_1,\alpha_2,\omega_1\)</span>。</p><p><img src="/images/coxeter/compute_example_K4.svg" class="fig" width="500"></p><p>注意到关于 <span class="math inline">\(\hat{\omega}_1\)</span>的反演保持虚球 <span class="math inline">\(\alpha_2,\alpha_3,\alpha_4\)</span>不变，因为它们都与 <span class="math inline">\(\hat{\omega}_1\)</span>正交；同时将 <span class="math inline">\(\alpha_1\)</span>变成另一个关于 <span class="math inline">\(\hat{\omega}_1\)</span>对称的球 <span class="math inline">\(\gamma_1\)</span>。反演变换是保角的，所以 <span class="math inline">\(\{\gamma_1,\alpha_2,\alpha_3,\alpha_4\}\)</span>也是一组夹角符合要求的镜面球，但是包含关系发生了改变，变成了 <span class="math inline">\(\gamma_1\)</span> 包含在 <span class="math inline">\(\hat{\omega}_1\)</span>的内部。这是错误的。这就是为什么前面求解 <span class="math inline">\(\alpha_1\)</span>的半径时我们要取那个较小的解（这两个解给出的球心形如 <span class="math inline">\(r_1\mathbf{x}\)</span> 和 <span class="math inline">\(r_2\mathbf{x}\,(\mathbf{x}\in\mathbb{R}^2)\)</span>，所以半径较小者一定在单位球内部）。</p><p>我们再举一个只有一个实权的例子：</p><p><img src="/images/coxeter/337.svg" id="337" class="fig" width="250"></p><p>这个群只有第一个顶点是实的，所以整个球堆完全由一个实球 <span class="math inline">\(\hat{\omega}_1\)</span> 生成：</p><p><img src="/images/coxeter/compute_example_337.svg" class="fig" width="500"></p><p>具体的计算步骤可以参考 shadertoy 动画代码中的注释：</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/WdGBz3?gui=true&amp;t=0&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><p>可以看到，每个实球都呈现一个二维的 Poincaré密铺图案。这很好理解，因为如果 <span class="math inline">\(\omega_i\)</span> 是实权，记 <span class="math inline">\(I=S\setminus\{i\}\)</span>，则实球 <span class="math inline">\(\hat{\omega}_i\)</span> 与虚球 <span class="math inline">\(\{\alpha_j\mid j\in I \}\)</span>都正交，这些虚球在 <span class="math inline">\(\hat{\omega}_1\)</span>中围成一个测地三角形，关于这个三角形三条边的反射生成的群是标准椭圆子群<span class="math inline">\(W_I\)</span>。<span class="math inline">\(W_I\)</span> 保持 <span class="math inline">\(\hat{\omega}_i\)</span>不动，同时将测地三角形映射为 <span class="math inline">\(\hat{\omega}_i\)</span> 中的双曲密铺。在前面 <a href="#K4"><span class="math inline">\(K_4\)</span> 的例子</a> 中，有 4个初始实球，它们每一个都呈现 <span class="math inline">\(\Delta(4,4,4)\)</span> 的双曲密铺；在 <a href="#337"><span class="math inline">\({\rm\color{red}o\color{red}}-{\rm o}-{\rmo}\overset{7}{-}{\rm o}\)</span> 的例子</a> 中，只有一个初始实球，它呈现<span class="math inline">\(\Delta(2,3,7)\)</span> 的双曲密铺。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Iversen_1992" class="csl-entry" role="listitem">Iversen, Birger. 1992. <span>“Hyperbolic Geometry.”</span> In. LondonMathematical Society Student Texts. Cambridge University Press.</div><div id="ref-Maxwell82" class="csl-entry" role="listitem">Maxwell, George. 1982. <span>“Sphere Packings and Hyperbolic ReflectionGroups.”</span> <em>Journal of Algebra</em> 79 (1): 78–97. <a href="https://doi.org/10.1016/0021-8693(82)90318-0">https://doi.org/10.1016/0021-8693(82)90318-0</a>.</div><div id="ref-Maxwell89" class="csl-entry" role="listitem">———. 1989. <span>“Wythoff’s Construction for Coxeter Groups.”</span><em>Journal of Algebra</em> 123 (2): 351–77. <a href="https://doi.org/10.1016/0021-8693(89)90051-3">https://doi.org/10.1016/0021-8693(89)90051-3</a>.</div><div id="ref-ratcliffe" class="csl-entry" role="listitem">Ratcliffe, John G. 2006. <em>Foundations of Hyperbolic Manifolds</em>.Second. Vol. 149. Graduate Texts in Mathematics. Springer.</div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（五）：Coxeter 群的 level</title>
      <link href="/coxeter-groups/level.html"/>
      <url>/coxeter-groups/level.html</url>
      
        <content type="html"><![CDATA[<p>本文主要改写自 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>)</span>和<span class="citation" data-cites="Maxwell89">(<a href="#ref-Maxwell89" role="doc-biblioref">Maxwell1989</a>)</span>，介绍 Coxeter 群的 level 的概念，并证明 level 等于 1 或2 的群都是双曲的。</p><p>在本文中，我们总假定 <span class="math inline">\((\cdot,\cdot)\)</span> 是非退化的，从而我们可以将<span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 等同起来。在这种情况下，根系、<a href="/coxeter-groups/tits-cone/#fundamental-weights">基本权</a> <span class="math inline">\(\Delta^\ast\)</span>、Tits 锥 <span class="math inline">\(\mathcal{C}\)</span> 都在 <span class="math inline">\(V\)</span> 中。<span class="math inline">\(\Delta^\ast\)</span> 满足 <span class="math inline">\((\alpha_s,\omega_t)=\delta_{st}\,(\forall s,t\inS)\)</span>。</p><p>我先介绍两个关于 <span class="math inline">\(\Delta=\{\alpha_s\mids\in S\}\)</span> 和 <span class="math inline">\(\Delta^\ast=\{\omega_s\mid s\in S\}\)</span>之间关系的显然等式，这样下文用到它们时就不必再重复说明。</p><p>固定 <span class="math inline">\(s\in S\)</span>，设 <span class="math display">\[\omega_s = \sum_{t\in S}c_t\alpha_t,\quadc_t\in\mathbb{R}.\]</span> 两边同时与 <span class="math inline">\(\omega_t\)</span> 作内积，可得 <span class="math inline">\(c_t=(\omega_s,\omega_t)\)</span>，于是 <span class="math display">\[\omega_s = \sum_{t\inS}(\omega_s,\omega_t)\alpha_t=(\omega_s,\omega_s)\alpha_s + \sum_{t\nes} (\omega_s,\omega_t)\alpha_t.\tag{I}\label{eq:idI}\]</span>这是第一个恒等式。</p><p>进一步，在 <span class="math inline">\((\ref{eq:idI})\)</span> 两边与<span class="math inline">\(\alpha_s\)</span> 作内积，可得 <span class="math display">\[1=\sum_{t\inS}(\omega_s,\omega_t)\cdot(\alpha_s,\alpha_t)=(\omega_s,\omega_s)+\sum_{t\nes}(\omega_s,\omega_t)\cdot(\alpha_s,\alpha_t).\tag{II}\label{eq:idII}\]</span>这是第二个恒等式。</p><h1 id="level-的定义">level 的定义</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span> <span class="statement-info">(<span class="citation" data-cites="Maxwell82">Maxwell (<a href="#ref-Maxwell82" role="doc-biblioref">1982</a>)</span>)</span>.</span><span class="statement-spah"> </span><span class="math inline">\((W,S)\)</span> 的 level 定义为最小的非负整数 <span class="math inline">\(l\)</span>，使得在 <span class="math inline">\(\Gamma\)</span> 中删去任何 <span class="math inline">\(l\)</span>个顶点后，剩下的每个连通分支都是有限或者仿射的。</p></div><span id="more"></span><p>根据定义，有限和仿射 Coxeter 群的 level 都是0（因为不需要删去任何顶点）。</p><p>下面是几个 level 大于 0 的例子：</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span></p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr><td style="text-align: center;">level=1</td><td style="text-align: center;">level=2</td><td style="text-align: center;">level=3</td></tr><tr><td style="text-align: center;"><img src="/images/coxeter/level1.svg" class="fig" width="120"></td><td style="text-align: center;"><img src="/images/coxeter/level2.svg" class="fig" width="120"></td><td style="text-align: center;"><img src="/images/coxeter/level3.svg" class="fig" width="120"></td></tr></tbody></table><ul><li>左图：三条边标号是 <span class="math inline">\((3,3,7)\)</span>，是双曲的；删去任何一个顶点后，剩下的是一个有限二面体群，因此level = 1。</li><li>中图：三条边标号（采用了 Vinberg 记号）是 <span class="math inline">\((3, 4,-1.1)\)</span>，删去红色顶点后，剩下的两个顶点构成一个双曲群，说明 level&gt; 1；删去任何两个顶点的话只剩一个顶点，当然是有限的，因此 level =2。</li><li>右图：删去两个红色顶点以后，剩下的两个顶点构成一个 Vinberg记号下的双曲群，说明 level &gt;2；删去任何三个顶点以后只剩一个顶点，当然是有限的，所以 level = 3。</li></ul></div><div id="level-l" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\Gamma\)</span> 是连通的，且 level 等于 <span class="math inline">\(l\)</span>，则在 <span class="math inline">\(\Gamma\)</span> 中删去任何 <span class="math inline">\(l+1\)</span>个顶点后，剩下的每个连通成分都是有限的。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(l\)</span>归纳。当 <span class="math inline">\(l=0\)</span>时，由于在一个有限或者仿射的连通图中删去任何一个顶点后剩下的一定是有限子图<span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.2.6</a>)</span>，所以结论成立。设结论对所有小于 <span class="math inline">\(l\)</span> 的正整数成立，考虑 <span class="math inline">\(l\)</span> 的情形。用反证法。</p><p>假设从 <span class="math inline">\(\Gamma\)</span> 中删去 <span class="math inline">\(|U|=l+1\)</span>个顶点后，剩下的部分包含一个仿射的连通分支 <span class="math inline">\(Y\)</span>。由于 <span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(Y\)</span> 必然和某个 <span class="math inline">\(u\in U\)</span> 有边相连。</p><p>考虑从 <span class="math inline">\(\Gamma\)</span> 中，删去 <span class="math inline">\(U\setminus\{u\}\)</span> 这 <span class="math inline">\(l\)</span> 个顶点后得到的子图。由于 <span class="math inline">\(\Gamma\)</span> 的 level 是 <span class="math inline">\(l\)</span>，所以这个子图每个分支都是有限或者仿射的。令<span class="math inline">\(C\)</span> 是包含 <span class="math inline">\(Y\cup\{u\}\)</span> 的连通分支，则 <span class="math inline">\(C\)</span> 是不可约仿射的。但是从 <span class="math inline">\(C\)</span> 中删除 <span class="math inline">\(u\)</span> 后仍然包含仿射子图 <span class="math inline">\(Y\)</span>，这与 <span class="math inline">\(l=0\)</span> 的情形矛盾，所以结论得证。<span class="math inline">\(\blacksquare\)</span></p><h1 id="level-1-是双曲的">Level 1 是双曲的</h1><p>本节来证明 level 等于 1 的群都是双曲的。</p><p>首先是一个定义：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.1</span>.</span></p><ul><li>如果 <span class="math inline">\(v\in V\)</span> 满足 <span class="math inline">\((v, v)&gt;0\)</span>，我们就称 <span class="math inline">\(v\)</span> 是<strong>实的</strong>。</li><li>如果 <span class="math inline">\(u,v\in V\)</span> 满足 <span class="math inline">\((u,v)\leq 0\)</span> 且 <span class="math inline">\(u,v\)</span> 张成的二维子空间 <span class="math inline">\(\mathrm{span}\{u,v\}\)</span><strong>不是正定</strong>的，就称 <span class="math inline">\(u,v\)</span> 是<strong>分离</strong>的(disjoint)。</li></ul></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在 <span class="math inline">\((\cdot,\cdot)\)</span> 是Lorentzian 内积时，<span class="math inline">\(v\)</span> 是实的等价于<span class="math inline">\(v\)</span> 是 space-like 的。</p></div><div id="lemma-uv" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理2.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\Gamma\)</span> 的 level 大于等于1，并且不是双曲的，则 <span class="math inline">\(V\)</span>中存在两个互相正交的向量 <span class="math inline">\(u,v\)</span> 满足<span class="math inline">\((u,u)&lt;0\)</span> 和 <span class="math inline">\((v,v)=0\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(\Gamma\)</span> 的 level 大于等于 1，所以 <span class="math inline">\((\cdot,\cdot)\)</span>不可能是正定或者半正定的，显然也不可能是负定/半负定的（因为所有根的范数都是1），所以 <span class="math inline">\((\cdot,\cdot)\)</span>的正负惯性指数都非 0。如果 <span class="math inline">\(W\)</span>不是双曲的，那么有两种可能：</p><ol type="1"><li><span class="math inline">\((\cdot,\cdot)\)</span> 的负惯性指数是 1且 <span class="math inline">\(\mathrm{rad}(V)\ne\{0\}\)</span>。</li><li><span class="math inline">\((\cdot,\cdot)\)</span>的负惯性指数至少是 2。</li></ol><p>情形 1 可以取 <span class="math inline">\(V\)</span>的一组正交基包含两个向量 <span class="math inline">\(u,v\)</span> 满足<span class="math inline">\((u, u)=-1\)</span> 和 <span class="math inline">\((v,v)=0\)</span>。情形 2 可以取 <span class="math inline">\(V\)</span> 的一组正交基包含三个向量 <span class="math inline">\(x,y,z\)</span> 满足 <span class="math inline">\((x,x)=1\)</span> 和 <span class="math inline">\((y, y)=(z,z)=-1\)</span>，然后取 <span class="math inline">\(u=z\)</span> 和 <span class="math inline">\(v=x+y\)</span>，则 <span class="math inline">\(u,v\)</span> 正交且 <span class="math inline">\((u,u)=-1,\,(v,v)=0\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="level-1" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.3</span> <span class="statement-info">(<span class="citation" data-cites="Maxwell82">Maxwell (<a href="#ref-Maxwell82" role="doc-biblioref">1982</a>)</span>)</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\Gamma\)</span> 的 level 是 1，则 <span class="math inline">\(\Gamma\)</span> 是双曲的。所有的 <a href="/coxeter-groups/tits-cone#fundamental-weights">基本权</a>都不是实的并且两两分离。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>当 <span class="math inline">\(|S|=4\)</span> 时，level 1 的Coxeter 群给出了三维双曲空间中的<strong>紧</strong> (compact)和<strong>仿紧</strong> (paracompact)的蜂巢结构。基本权不是实的意味着所有的权都不是实的，即蜂巢的顶点全部位于双曲空间的内部或者边界上。维基百科的<a href="https://en.wikipedia.org/wiki/Uniform_honeycombs_in_hyperbolic_space">这个页面</a>上列出了所有紧和仿紧的蜂巢。</p></div><p><strong>证明</strong>：首先注意到 <span class="math inline">\(\Gamma\)</span> 的 level 是 1 蕴含了 <span class="math inline">\(\Gamma\)</span> 是连通的，若不然，设 <span class="math inline">\(\Gamma=\Gamma_1\cup\cdots\cup\Gamma_k\)</span>有多个连通分支，则每个 <span class="math inline">\(\Gamma_i\)</span>作为删去其它分支后剩下的子图，都应该是有限或者仿射的，但这导致 <span class="math inline">\(\Gamma\)</span> 的 level 是 0，矛盾。</p><p>我们需要证明三件事情：</p><ol type="1"><li>内积 <span class="math inline">\((\cdot,\cdot)\)</span> 的惯性指数是<span class="math inline">\((n-1, 1)\)</span>；</li><li>任何基本权 <span class="math inline">\(\omega_s\)</span> 满足 <span class="math inline">\((\omega_s,\omega_s)\leq0\)</span>；</li><li>任何两个基本权 <span class="math inline">\(\omega_s,\omega_t\)</span> 满足 <span class="math inline">\((\omega_s,\omega_t)\leq0\)</span>并且它们生成的二维子空间 <span class="math inline">\(\mathrm{span}\{\omega_i,\omega_j\}\)</span>不是正定的。</li></ol><p><strong>1. 证明 <span class="math inline">\((\cdot,\cdot)\)</span>是双曲的</strong>。</p><p>用反证法，如果 <span class="math inline">\(\Gamma\)</span> 的 level是 1 但不是双曲的，则根据 <a href="#lemma-uv" title="引理 2.2">引理2.2</a> 我们可以取两个正交的非零向量 <span class="math inline">\(u,v\)</span> 满足 <span class="math inline">\((u,u)&lt;0,\, (v,v)=0\)</span>。</p><p>我们有如下两个断言（证明见 <a href="#appendixA">附录 A</a>）：</p><div id="assetA" class="statement sta___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">断言</span>.</span><span class="statement-spah"></span><br></p><ol type="1"><li>若向量 <span class="math inline">\(u=\sum_{s\in S} u_s\alpha_s\)</span> 满足 <span class="math inline">\((u,u)&lt;0\)</span>，则所有 <span class="math inline">\(u_s\)</span> 非零且同号。</li><li>若向量 <span class="math inline">\(v=\sum_{s\in S} v_s\alpha_s\)</span> 满足 <span class="math inline">\((v,v)=0\)</span>，则至多一个 <span class="math inline">\(v_s\)</span> 为零，其余同号。</li></ol></div><p>取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(v_s\ne 0\)</span>，则 <span class="math inline">\(u'=v_su-u_sv\)</span> 满足 <span class="math inline">\((u',u')=v_s^2(u,u)&lt;0\)</span>，且 <span class="math inline">\(u'\)</span> 的 <span class="math inline">\(\alpha_s\)</span> 项系数 <span class="math inline">\(u'_s=0\)</span>，这与断言 1 矛盾。所以 <span class="math inline">\(\Gamma\)</span> 是双曲的。</p><p><strong>2. 证明 <span class="math inline">\((\omega_s,\omega_s)\leq0\)</span></strong></p><p>由 <span class="math inline">\(\Gamma\)</span> 的 level 是 1可得删除任意一个顶点 <span class="math inline">\(s\)</span> 后的子图<span class="math inline">\(\Gamma \setminus\{s\}\)</span>是有限或仿射的，即子空间 <span class="math inline">\(\omega_s^\perp =\mathrm{span}\{\alpha_t \mid t \ne s\}\)</span>是正定或者半正定的。由于刚刚已经证明了 <span class="math inline">\((\cdot,\cdot)\)</span> 是双曲的，所以 <span class="math inline">\(\omega_s\)</span> 不是 space-like 的，即 <span class="math inline">\((\omega_s, \omega_s) \leq 0\)</span>。于是任何<span class="math inline">\(\omega_s\,(s\in S)\)</span> 都不是实的。</p><p><strong>3. 证明 <span class="math inline">\((\omega_s,\omega_t)\leq0\)</span> 且 <span class="math inline">\(\mathrm{span}\{\omega_i,\omega_j\}\)</span>非正定</strong></p><p>由于 <span class="math inline">\((\omega_s,\omega_s)\leq0\)</span>，结合恒等式<span class="math inline">\((\ref{eq:idI})\)</span> 和 <a href="#assetA" title="断言">断言</a> 我们有：</p><ol type="1"><li>如果 <span class="math inline">\((\omega_s,\omega_s)&lt;0\)</span>，则所有的 <span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span> 都小于0。</li><li>如果 <span class="math inline">\((\omega_s,\omega_s)=0\)</span>，则所有的 <span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span> 都不为 0且同号。根据恒等式 <span class="math inline">\((\ref{eq:idII})\)</span>不难确定它们都小于 0。</li></ol><p>总之对任何 <span class="math inline">\(s\ne t\)</span> 都有 <span class="math inline">\((\omega_s,\omega_t)&lt;0\)</span>。进一步，考虑二维子空间<span class="math inline">\(U_{s,t}={\rmspan}\{\omega_s,\omega_t\}\)</span>，其正交补是 <span class="math inline">\(U_{s,t}^\bot=\mathrm{span}\{\alpha_{k}\mid k\nes,t\}\)</span>，根据 <a href="#level-l" title="定理 1.2">定理 1.2</a><span class="math inline">\(U_{s,t}^\bot\)</span> 是 space-like 的，说明<span class="math inline">\(U_{s,t}\)</span> 是 time-like 的，从而 <span class="math inline">\(\{\omega_s,\omega_t\}\)</span> 是分离的。</p><p>综上，三点均得证，定理成立。<span class="math inline">\(\blacksquare\)</span></p><div id="level-1-tits" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.4</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(W\)</span> 的 level 为 1，则 Tits 锥的闭包 <span class="math inline">\(\overline{ \mathcal{C} }\)</span> 等于 <span class="math inline">\(\mathcal{Q}_+\)</span> 或者 <span class="math inline">\(\mathcal{Q}_-\)</span> 之一。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个结论告诉我们在 level 1 时空间的边界上没有球堆。</p></div><p><strong>证明</strong>：由于 level 1 是双曲的，根据 <a href="/coxeter-groups/three-geometries#tits-closure">双曲情形 Tits锥的结论</a>，<span class="math inline">\(\mathcal{C}\)</span> 包含<span class="math inline">\(\mathcal{N}_+,\mathcal{N}_-\)</span>之一，不妨设 <span class="math inline">\(\mathcal{C}\supset\mathcal{N}_+\)</span>，则 <span class="math inline">\(\overline{ \mathcal{C} }\supset\overline{\mathcal{N}_+ }=\mathcal{Q}_+\)</span>。为了证明反向包含关系，只要证<span class="math inline">\(\overline{ \mathcal{C}}\subset\mathcal{Q}\)</span> 和 <span class="math inline">\(\overline{\mathcal{C} }\cap\mathcal{Q}_-=\{0\}\)</span>。</p><p>根据 <a href="#level-1" title="定理 2.3">定理 2.3</a>，所有的基本权<span class="math inline">\(\{\omega_s\}\)</span>都不是实的且两两分离。设 <span class="math inline">\(x=\sum_{s\inS}c_s\omega_s\,(c_s\geq0)\)</span> 是 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 中任意一点，则<span class="math display">\[(x,x)=\sum_{s,t\inS}c_sc_t\underbrace{(\omega_s,\omega_t)}_{\leq0}\leq0.\]</span> 即 <span class="math inline">\(\overline{\mathcal{D}}\subset\mathcal{Q}\)</span>。<span class="math inline">\(W\)</span> 作为正交变换群保持 <span class="math inline">\(\mathcal{Q}\)</span> 不变，所以 <span class="math inline">\(\mathcal{C}=\bigcup\limits_{w\inW}w\overline{\mathcal{D}}\subset\mathcal{Q}\)</span>，从而 <span class="math inline">\(\overline{ \mathcal{C}}\subset\mathcal{Q}\)</span>。</p><p>再来说明 <span class="math inline">\(\overline{ \mathcal{C}}\cap\mathcal{Q}_-=\{0\}\)</span>。若存在 <span class="math inline">\(v\in\overline{ \mathcal{C}}\cap\mathcal{Q}_-\)</span> 且 <span class="math inline">\(v\ne0\)</span>，取某个 <span class="math inline">\(u\in\mathcal{N}_+\)</span> 使得 <span class="math inline">\(u,v\)</span> 线性无关，<a href="/coxeter-groups/three-geometries/#connected-component-dot">则<span class="math inline">\(u,v\)</span> 的某个正线性组合是 space-like的</a>，此向量仍在 <span class="math inline">\(\overline{ \mathcal{C}}\)</span> 中，这与 <span class="math inline">\(\overline{ \mathcal{C}}\subset\mathcal{Q}\)</span> 矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 id="处理-level-2-的基本技巧">处理 level 2 的基本技巧</h1><p>在上一节的基础上，我们进一步讨论 level 2 的 Coxeter群，并证明它们同样是双曲的。由于接下来的证明较为复杂，细节较多，读者阅读时可能会感到吃力。因此，我借鉴编程中的“模块化”思路，先解释一下接下来的核心思想。</p><p>我们处理 level 2 的情形的基本策略是转化为 level 1 的情形。设 <span class="math inline">\(\Gamma\)</span> 是 level 为 2 的 Coxeter图，取一个实的基本权 <span class="math inline">\((\omega_s,\omega_s)&gt;0\)</span>，则子图 <span class="math inline">\(\Gamma\setminus\{s\}\)</span> 的 level 是 1。记<span class="math inline">\(I = S\setminus\{s\}\)</span>，<span class="math inline">\(W_I\)</span> 是标准椭圆子群，此时有 <span class="math display">\[V_I=\omega_s^\bot=\mathrm{span}\{\alpha_t\midt\ne s\}.\]</span> <span class="math inline">\(W_I\)</span> 在 <span class="math inline">\(V_I\)</span> 上作用的基本区域的闭包是 <span class="math display">\[\overline{\mathcal{D}}_I= \{v\in V_I\mid (v,\alpha_t)&gt;0,\, \forall t\in I\}=\mathrm{cone}(\{\omega_t\mid t\inI\}).\]</span></p><p>根据 <a href="#level-1-tits" title="推论 2.4">推论 2.4</a>，<span class="math inline">\(\overline{\mathcal{D}}_I\)</span> 包含在 <span class="math inline">\(\mathcal{Q}_I=\{v\in V_I\mid (v,v)\leq0\}\)</span>的上下两个分支之一中，所以任何 <span class="math inline">\(x,y\in\overline{\mathcal{D}}_I\)</span>之间的内积小于等于 0： <span class="math display">\[(x,y)\leq0, \quad\forall x,y\in \overline{\mathcal{D}}_I.\]</span> 特别地，对任何 <span class="math inline">\(x\in\overline{\mathcal{D}}_I\)</span> 有 <span class="math display">\[(x,x)\leq0 \text{ and } (x,\omega_t)\leq0\text{for all }t\in I.\]</span> 于是对 <span class="math inline">\(v\inV\)</span>，如果它在 <span class="math inline">\(V_I\)</span> 上的投影<span class="math inline">\(v_I\)</span> 满足 <span class="math inline">\(v_I\in\overline{\mathcal{D}}_I\)</span>，那么我们就可以利用上面的关系得出关于<span class="math inline">\(v\)</span> 的信息来。</p><div id="observeA" class="statement sta____a definition unnumbered"><p><span class="statement-heading"><span class="statement-label">观察A</span>：</span><span class="statement-spah"> </span>取 <span class="math inline">\(v=\alpha_s\)</span>，<span class="math inline">\(\alpha_s'=\alpha_s-\omega_s/(\omega_s,\omega_s)\)</span>是 <span class="math inline">\(\alpha_s\)</span> 在 <span class="math inline">\(\omega_s^\bot=V_I\)</span> 上的投影，则对任何<span class="math inline">\(t\in I\)</span> 有 <span class="math display">\[(\alpha_s',\alpha_t)=(\alpha_s,\alpha_t)\leq0.\]</span> 这说明 <span class="math inline">\(-\alpha_s'\in\overline{\mathcal{D}}_I\)</span>，于是我们有<span class="math display">\[\begin{aligned}&amp;(\alpha_s',\alpha_s')=1-\frac{1}{(\omega_s,\omega_s)}\leq0,\\&amp;(-\alpha_s',\omega_t)=\frac{(\omega_s,\omega_t)}{(\omega_s,\omega_s)}\leq0\text{ for all }t\in I.\end{aligned}\]</span> 整理即得 <span class="math inline">\(0&lt;(\omega_s,\omega_s)\leq1\)</span>，以及 <span class="math inline">\((\omega_s,\omega_t)\leq0\)</span> 对任何 <span class="math inline">\(t\in I\)</span> 成立。</p></div><p>真不错！我们轻松得到了一个关于 level 2 情形实的基本权 <span class="math inline">\(\omega_s\)</span> 的重要结论。</p><div id="observeB" class="statement sta____b definition unnumbered"><p><span class="statement-heading"><span class="statement-label">观察B</span>：</span><span class="statement-spah"> </span>设 <span class="math inline">\(v\in\mathcal{C}\)</span> 是 Tits 锥中一点，则<span class="math inline">\(v\)</span> 可以写成 <span class="math inline">\(v=wx\,(w\inW,x\in\overline{\mathcal{D}})\)</span>。其在 <span class="math inline">\(V_I\)</span> 上的投影为 <span class="math display">\[v_I = v -\frac{(v,\omega_s)}{(\omega_s,\omega_s)}\omega_s.\]</span> 由于 <span class="math inline">\((v-v_I)\perp V_I\)</span>，所以对任何 <span class="math inline">\(\alpha_k\,(k\ne i)\)</span> 有 <span class="math display">\[(v_I,\alpha_k)=(v,\alpha_k)=(wx,\alpha_k)=(x,w^{-1}\alpha_k).\]</span> 为了保证让 <span class="math inline">\(v_I\)</span> 落在 <span class="math inline">\(\overline{\mathcal{D}}_I\)</span>中，我们需要让这些 <span class="math inline">\((x,w^{-1}\alpha_k)\geq0\)</span>。由于 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，所以只要让每个<span class="math inline">\(w^{-1}\alpha_k\,(k\in I)\)</span>都是负根，也就是让 <span class="math inline">\(l(s_kw)&lt;l(w)\)</span>即可。</p><p>总结起来就是，如果对任何 <span class="math inline">\(k\in I\)</span>有 <span class="math inline">\(l(s_kw)&lt;l(w)\)</span>，那么就有 <span class="math inline">\(v_I\in\overline{\mathcal{D}}_I\)</span> 成立。</p></div><p>这个例子看起来附加了比较强的条件，但是它确实会在后面用到。</p><h1 id="level-2-也是双曲的">Level 2 也是双曲的</h1><div id="level-2" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.1</span>.</span><span class="statement-spah"> </span>level 等于 2的群都是双曲的，所有的基本权 <span class="math inline">\(\{\omega_s\mids\in S\}\)</span> 两两分离。<span class="math inline">\(\omega_s\)</span> 是实的当且仅当 <span class="math inline">\(T\setminus\{s\}\)</span> 的 level 等于1，且对这样的 <span class="math inline">\(\omega_s\)</span> 有 <span class="math inline">\(0&lt;(\omega_s,\omega_s)\leq 1\)</span>。</p></div><p><strong>证明</strong>：我们先来证明 <span class="math inline">\(\Gamma\)</span> 是双曲的。</p><p>如果 <span class="math inline">\(|\Gamma|=3\)</span>，<span class="math inline">\(\Gamma\)</span> 的 level 是 2 说明其必然有一条边的Vinberg 标号小于 -1。不妨设 <span class="math inline">\((\cdot,\cdot)\)</span> 的 Gram 矩阵形如 <span class="math display">\[\begin{pmatrix}1&amp;a&amp;b\\a&amp;1&amp;c\\b&amp;c&amp;1\end{pmatrix}.\]</span>其中 <span class="math inline">\(a,\,b,\,c\leq0\)</span> 且 <span class="math inline">\(a &lt; -1\)</span>。这个矩阵的行列式是 <span class="math display">\[1-a^2 + 2bc(a+1)-(b+c)^2&lt;0.\]</span>由于矩阵的迹等于 3，所以其符号必然是 <span class="math inline">\((2,1)\)</span>，从而是双曲的。</p><p>再处理 <span class="math inline">\(|\Gamma|\geq4\)</span>的情形。仍然根据 <a href="#lemma-uv" title="引理 2.2">引理 2.2</a>，如果<span class="math inline">\(\Gamma\)</span>不是双曲的，则可以取两个非零且正交的向量 <span class="math inline">\(u,v\)</span> 满足 <span class="math inline">\((u,u)&lt;0,\,(v, v)=0\)</span>。</p><p>我们也有如下两个断言（证明见 <a href="#appendixB">附录 B</a> ）：</p><div id="assetB" class="statement sta___-1 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">断言</span>.</span><span class="statement-spah"></span><br></p><ol type="1"><li>若向量 <span class="math inline">\(u=\sum_{s\in S} u_s\alpha_s\)</span> 满足 <span class="math inline">\((u,u)&lt;0\)</span>，则除去至多一个系数 <span class="math inline">\(u_j\)</span> 之外，其它的 <span class="math inline">\(u_s\,(s\ne j)\)</span> 都非零且同号。</li><li>若向量 <span class="math inline">\(v=\sum_{s\in S} v_s\alpha_s\)</span> 满足 <span class="math inline">\((v,v)=0\)</span>，则除了断言 1的情形之外，还有一种情形是 <span class="math inline">\(v_s\)</span>中有两个是 0，其余的非零且同号。</li></ol></div><p>由于 <span class="math inline">\((u,u)&lt;0\)</span> 和 <span class="math inline">\((v,v)=0\)</span>，所以 <span class="math inline">\(\{u_s\}\)</span> 中至多一个是 0，<span class="math inline">\(\{v_s\}\)</span> 中至多两个是 0，而 <span class="math inline">\(|\Gamma|\geq4\)</span>，所以存在下标 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(u_i,\,v_i\)</span> 均不为 0。通过适当取 <span class="math inline">\(\pm v\)</span> 可以不妨设 <span class="math inline">\(v_i&lt;0\)</span>。<span class="math inline">\(u'=v_iu-u_iv\)</span> 仍然满足 <span class="math inline">\(u'\perp v\)</span> 和 <span class="math inline">\((u',u')&lt;0\)</span>，但是系数 <span class="math inline">\(u'_i=0\)</span>，用 <span class="math inline">\(u'\)</span> 作为 <span class="math inline">\(u\)</span> 可以不妨设 <span class="math inline">\(u\)</span> 的系数 <span class="math inline">\(u_i=0\)</span>。再进一步调整 <span class="math inline">\(\pm u\)</span> 可以使得其它 <span class="math inline">\(u_s&gt;0\,(s\ne i)\)</span>。</p><p>记 <span class="math inline">\(J=\{j\in S\mid u_j\ne0 \text{ and}v_j\ne 0\}\)</span>。分情况讨论：</p><ul><li><p><span class="math inline">\(|J|\geq 2\)</span>：</p><p>这时必然存在 <span class="math inline">\(j,k\in J\)</span> 使得 <span class="math inline">\(a=v_j/u_j &lt; v_k/u_k\)</span>。<span class="math inline">\(u'=au-v\)</span> 是 time-like 的，其系数 <span class="math inline">\(u'_i=-v_i&gt;0\)</span>，<span class="math inline">\(u'_j=0\)</span>，<span class="math inline">\(u'_k\leq 0\)</span>，与断言 1 矛盾。</p></li><li><p><span class="math inline">\(|J|\leq1\)</span>：</p><p>这时必有 <span class="math inline">\(|\Gamma|=4\)</span> 且 <span class="math inline">\(v\)</span> 形如 <span class="math inline">\(v=v_i\alpha_i +v_j\alpha_j\)</span>。如下表所示：</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(i\)</span></th><th style="text-align: center;"><span class="math inline">\(j\)</span></th><th style="text-align: center;"><span class="math inline">\(k\)</span></th><th style="text-align: center;"><span class="math inline">\(m\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(u\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(&lt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(\ne0\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td><td style="text-align: center;"><span class="math inline">\(0\)</span></td></tr></tbody></table><p><span class="math inline">\(\mathrm{span}\{\alpha_i,\alpha_j\}\)</span>是仿射的（它包含 <span class="math inline">\(v\)</span>，不可能是有限的），从而 <span class="math inline">\((\alpha_i,\alpha_j)=-1\)</span> 且 <span class="math inline">\(v_i=v_j\)</span>。不妨将 <span class="math inline">\(v\)</span> 缩放为 <span class="math inline">\(v=\alpha_i+\alpha_j\)</span>。</p><p>设 <span class="math inline">\(u=u_j\alpha_j+u_k\alpha_k+u_m\alpha_m\)</span>，由<span class="math inline">\((u,v)=0\)</span> 可得 <span class="math display">\[(u_j\alpha_j+u_k\alpha_k+u_m\alpha_m,v)=(u_k\alpha_k+u_m\alpha_m, \alpha_i+\alpha_j)=0,\]</span> 由于 <span class="math inline">\(\{\alpha_k,\alpha_m\}\)</span> 和 <span class="math inline">\(\{\alpha_i,\alpha_j\}\)</span>之间的内积都小于等于 0，而 <span class="math inline">\(u_k,u_m\)</span>大于 0，这说明 <span class="math display">\[(\alpha_k,\alpha_i) =(\alpha_k,\alpha_j) =(\alpha_m, \alpha_i)=(\alpha_m,\alpha_j)=0.\]</span> 即 <span class="math inline">\(\{i,j\}\)</span> 与 <span class="math inline">\(\{k,m\}\)</span>是不连通的，与 <span class="math inline">\(\Gamma\)</span>连通矛盾。</p></li></ul><p>至此我们证明了当 <span class="math inline">\(\Gamma\)</span> 的 level等于 2 时是双曲的。</p><p>我们接下来证明所有的基本权 <span class="math inline">\(\{\omega_s\}\)</span>是两两分离的。我们先来说明不论 <span class="math inline">\((\omega_s,\omega_s)\)</span>的符号如何，它与其它的基本权 <span class="math inline">\(\omega_t\,(t\nes)\)</span> 的内积满足 <span class="math inline">\((\omega_s,\omega_t)\leq0\)</span>。</p><p>分情况讨论：</p><ul><li>如果 <span class="math inline">\((\omega_s,\omega_s)&gt;0\)</span>，由 <a href="#observeA" title="观察 A">观察 A</a> 的讨论即得。</li><li>如果 <span class="math inline">\((\omega_s,\omega_s)\leq0\)</span>，则根据 <span class="math inline">\((\ref{eq:idII})\)</span>，<span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span>中必须至少有一个严格小于 0，从而根据 <a href="#assetB" title="断言">断言</a>，在 <span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span>中至多有一个为正。但我们将证明这不可能。否则不妨设 <span class="math inline">\(k\ne s\)</span> 使得 <span class="math inline">\((\omega_s,\omega_k)&gt;0\)</span>。在 <span class="math inline">\((\ref{eq:idI})\)</span> 两边用 <span class="math inline">\(\alpha_k\)</span> 内积得到 <span class="math display">\[0=(\omega_s,\omega_s)(\alpha_s,\alpha_k)+\sum_{t\ne s,k} (\omega_s,\omega_t)(\alpha_t,\alpha_k) +(\omega_s,\omega_k).\]</span> 上面的和项前两个都非负，最后一个大于0，矛盾。所以所有的 <span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span>都非正。</li></ul><p>又因为对任何 <span class="math inline">\(s,t\)</span>，<span class="math inline">\(\Gamma\setminus\{s,t\}\)</span>是有限或者仿射的，所以其正交补，即 <span class="math inline">\(\{\omega_s,\omega_t\}\)</span>张成的二维子空间不是正定的，从而 <span class="math inline">\(\{\omega_s\}\)</span> 之间是两两分离的。<span class="math inline">\(\blacksquare\)</span></p><h1 id="level-1-2-等价于双曲和分离">level = 1, 2 等价于双曲和分离</h1><div id="level-12" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.1</span>.</span><span class="statement-spah"></span>下面两点是等价的：</p><ol type="1"><li><span class="math inline">\(\Gamma\)</span> 的 level 等于 1 或2；</li><li><span class="math inline">\(\Gamma\)</span>是双曲的，且任何两个权都互相分离。</li></ol></div><p><strong>证明</strong>：</p><p><span class="math inline">\(1\Rightarrow 2\)</span>：只要再证明对任何<span class="math inline">\(w\in W\)</span>，以及两个基本权 <span class="math inline">\(\omega_i,\,\omega_j\)</span>，如果有 <span class="math inline">\(\omega_i\ne w(\omega_j)\)</span>，则 <span class="math inline">\((\omega_i,w(\omega_j))\leq0\)</span>，并且二维子空间<span class="math inline">\(\{\omega_i,w(\omega_j)\}\)</span>不是正定的。</p><p>对 <span class="math inline">\(l(w)\)</span> 归纳：<span class="math inline">\(l(w)=0\)</span> 的情形在 <a href="#level-1" title="定理 2.3">定理 2.3</a> 和 <a href="#level-2" title="定理 4.1">定理 4.1</a> 中已经证明。下面假设 <span class="math inline">\(l(w)&gt;0\)</span>，且结论对所有长度 <span class="math inline">\(&lt;l(w)\)</span> 的元素成立。</p><ol type="1"><li><p>如果存在 <span class="math inline">\(k\ne i\)</span> 使得 <span class="math inline">\(l(s_kw)&lt;l(w)\)</span>，则由于反射 <span class="math inline">\(s_k\)</span> 是正交变换，并且保持 <span class="math inline">\(\omega_i\)</span> 不动，有 <span class="math display">\[(\omega_i,s_kw(\omega_j))\xrightarrow{\ s_k\ }(\omega_i,w(\omega_j)).\]</span>由归纳假设左边是分离的，从而右边也是分离的。</p></li><li><p>如果对任何 <span class="math inline">\(k\ne i\)</span> 都有 <span class="math inline">\(l(s_kw)&gt;l(w)\)</span>，则 <span class="math inline">\(w\)</span> 的任一既约表示必然以 <span class="math inline">\(s_i\)</span> 开头，即 <span class="math inline">\(w\)</span> 形如 <span class="math inline">\(w=s_iw'\)</span> 且 <span class="math inline">\(l(w)&gt;l(w')\)</span>。从而 <span class="math display">\[(\omega_i,w(\omega_j))\xrightarrow{\ s_i\}(\omega_i-2\alpha_i, w'(\omega_j)) =(\omega_i,w'(\omega_j))-2(\alpha_i,w'(\omega_j)).\]</span></p><ul><li>如果 <span class="math inline">\(\omega_i\new'(\omega_j)\)</span>，则由归纳假设上面第一项 <span class="math inline">\((\omega_i,w'(\omega_j))\leq0\)</span>。第二项由于 <span class="math display">\[l(s_iw')&gt;l(w')\Rightarroww'^{-1}\alpha_i\in\Phi^+\Rightarrow (w'^{-1}\alpha_i,\omega_j)\geq0 \Rightarrow (\alpha_i, w'(\omega_j))\geq0.\]</span>所以 <span class="math inline">\((\omega_i,w(\omega_j))\leq0\)</span>成立。</li><li>如果 <span class="math inline">\(\omega_i=w'(\omega_j)\)</span>，则 <span class="math inline">\(w(\omega_j)=s_iw'(\omega_j)=s_i(\omega_i)\)</span>，于是<span class="math display">\[(\omega_i, w(\omega_j))=(\omega_i,s_i(\omega_i))\xrightarrow{\ s_i\}(\omega_i-2\alpha_i,\omega_i)=(\omega_i, \omega_i)-2 &lt;0.\]</span>其中最后一个不等号是利用了 <a href="#level-1" title="定理 2.3">定理2.3</a> 和 <a href="#level-2" title="定理 4.1">定理 4.1</a> 的结论：若<span class="math inline">\(\Gamma\)</span> 的 level 是 1 则 <span class="math inline">\((\omega_i, \omega_i)\leq0\)</span>，若 <span class="math inline">\(\Gamma\)</span> 的 level 是 2 则 <span class="math inline">\((\omega_i,\omega_i)\leq 1\)</span>。</li></ul><p>我们已经证明了 <span class="math inline">\((\omega_i,w(\omega_j))\)</span> 总是 <span class="math inline">\(\leq0\)</span> 的。还需要说明 <span class="math inline">\(\mathrm{span}\{\omega_i,w(\omega_j)\}\)</span>不是正定的。记 <span class="math inline">\(U=\mathrm{span}\{\omega_i,w(\omega_j)\}\)</span>。用反证法，如果<span class="math inline">\(U\)</span> 是正定的，则 <span class="math inline">\((\omega_i,\omega_i)&gt;0\)</span> 是实的。记 <span class="math display">\[v_I = w(\omega_j) -\frac{(\omega_i,w(\omega_j))}{(\omega_i,\omega_i)} \omega_i\]</span> 是<span class="math inline">\(w(\omega_j)\)</span> 在 <span class="math inline">\(\omega_i^\bot\)</span> 上的投影，则 <span class="math inline">\(v_I\in U\)</span> 是 space-like 的向量。但是根据<a href="#observeB" title="观察 B">观察 B</a> 中的讨论，<span class="math inline">\(v_I\in\overline{\mathcal{D}}_I\)</span>，从而<span class="math inline">\((v_I, v_I)\leq0\)</span>，矛盾。</p></li></ol><p><span class="math inline">\(2\Rightarrow 1\)</span>：由于内积 <span class="math inline">\((\cdot,\cdot)\)</span> 是双曲的，而子空间 <span class="math inline">\(\mathrm{span}\{\omega_i,\omega_j\}\)</span>不是正定的，所以其正交补是正定或者半正定的。于是 <span class="math inline">\(\Gamma\setminus\{i,j\}\)</span>是有限或者仿射的，从而 <span class="math inline">\(\Gamma\)</span> 的level 等于 1 或 2。</p><h1 id="一个技术性命题">一个技术性命题</h1><p>下面这个命题仅会在后面 Boyd-Maxwell球堆的一个细分情形中使用一次，但是它的论证颇为不易，所以我把它放在这里。</p><div id="ideal-vertex" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题6.1</span> <span class="statement-info">(<span class="citation" data-cites="Maxwell89">(<a href="#ref-Maxwell89" role="doc-biblioref">Maxwell 1989</a>, proposition5.15)</span>)</span>.</span><span class="statement-spah"> </span><br></p><p>设 <span class="math inline">\((W,S)\)</span> 是不可约 Coxeter群，<span class="math inline">\(s\in S\)</span>，<span class="math inline">\(I=S\setminus\{s\}\)</span>，并且有如下条件成立：</p><ol type="1"><li><span class="math inline">\((\omega_s,\omega_s)=0\)</span>。</li><li>标准椭圆子群 <span class="math inline">\(W_I\)</span>是不可约、仿射的。</li><li>对任何 <span class="math inline">\(i\in I\)</span> 有 <span class="math inline">\((\omega_s,\omega_i)&lt;0\)</span>。</li></ol><p>则对任意 <span class="math inline">\(p\in\overline{\mathcal{D}}\)</span> 都有 <span class="math inline">\(\omega_s\in\overline{ \mathrm{cone}(\bigcup_{w\inW_I}wp) }\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>由于 <span class="math inline">\(\bigcup_{w\in W_I}wp\)</span>是无限集，<span class="math inline">\(\mathrm{cone}(\bigcup_{w\inW_I}wp)\)</span> 未必是闭集，因此闭包记号不可少。</p><p>当 <span class="math inline">\(W\)</span> 的 level 是 1 时，若 <span class="math inline">\(\omega_s\)</span>是一个位于双曲空间边界上的理想顶点，则命题的条件都满足。这时 <span class="math inline">\(W_I\)</span> 是经过 <span class="math inline">\(\omega_s\)</span>的那些镜面生成的标准椭圆子群，<span class="math inline">\(W_I\)</span>会把基本区域无限压缩到 <span class="math inline">\(\omega_s\)</span>附近，如下图所示：</p><p><img src="/images/coxeter/ideal-vertex.jpg" class="fig" width="350"></p></div><p><strong>证明</strong>：由已知 <span class="math inline">\(V_I=\mathrm{span}\{\alpha_i\mid i\in I\}\)</span>是仿射的，并且 <span class="math inline">\(\mathrm{rad}(V_I)\)</span>是一维的。由恒等式 <span class="math inline">\((\ref{eq:idI})\)</span>：<span class="math display">\[\omega_s = \sum_{i\inI}(\omega_s,\omega_i)\,\alpha_i\in V_I.\]</span> 因此 <span class="math inline">\(\mathrm{rad}(V_I)=\mathbb{R}\omega_s\)</span>。于是<span class="math inline">\(W_I\)</span> 固定 <span class="math inline">\(\omega_s\)</span>，即 <span class="math display">\[\mathbb{R}\omega_s\xrightarrow{\ W_I\, -\, 1\ }0.\]</span> <span class="math inline">\(W_I\)</span> 同样作用在商空间<span class="math inline">\(V_I/\mathbb{R}\omega_s\)</span>上，此作用给出了一个同态 <span class="math inline">\(W_I\to\mathrm{GL}(V_I/\mathbb{R}\omega_s)\)</span>。令<span class="math inline">\(K\)</span> 为此同态的核，则对任何 <span class="math inline">\(w\in K\)</span>， <span class="math display">\[w(v+ \mathbb{R}\omega_s) = v + \mathbb{R}\omega_s,\quad v\in V_I.\]</span>即 <span class="math inline">\(wv-v\in\mathbb{R}\omega_s\)</span>，从而<span class="math display">\[V_I\xrightarrow{\ K - 1\}\mathbb{R}\omega_s\xrightarrow{\ W_I\, -\, 1\ } 0.\]</span> 由于 <span class="math inline">\(K\leqslant W_I\)</span>，所以 <span class="math display">\[V_I\xrightarrow{\ K - 1\}\mathbb{R}\omega_s\xrightarrow{\ K-1\ }0.\]</span> 即 <span class="math inline">\((K-1)^2V_I\equiv0\)</span>。</p><p>进一步，对 <span class="math inline">\(w\in K\)</span>，<span class="math inline">\(w\)</span> 是一些 <span class="math inline">\(I\)</span> 中生成元的乘积，所以 <span class="math inline">\(w\alpha_s\)</span> 形如 <span class="math inline">\(w\alpha_s=\alpha_s+\sum\limits_{i\inI}c_i\alpha_i\)</span>，所以 <span class="math inline">\((w-1)\alpha_s\in V_I\)</span>，从而 <span class="math inline">\(w-1\)</span> 将整个 <span class="math inline">\(V\)</span> 也映入 <span class="math inline">\(V_I\)</span>，于是 <span class="math display">\[V\xrightarrow{\ K-1\ } V_I\xrightarrow{\ K - 1\}\mathbb{R}\omega_s\xrightarrow{\ K-1\ }0.\]</span> 即 <span class="math inline">\((K-1)^2V\subset\mathbb{R}\omega_s\)</span>，<span class="math inline">\((K-1)^3V\equiv0\)</span>。</p><p>取 <span class="math inline">\(w\in K\)</span> 且 <span class="math inline">\(w\ne 1\)</span> <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，并记 <span class="math inline">\(A=w-1\)</span>，由 <span class="math inline">\(V_I\xrightarrow{A}\mathbb{R}\omega_s\)</span> 可知<span class="math display">\[A\alpha_i = \lambda_i\omega_s,\quad i\inI,\,\lambda_i\in\mathbb{R}.\]</span> 由于 <span class="math inline">\(w\)</span> 不是 <span class="math inline">\(V_I\)</span> 上的恒等变换，所以至少对一个 <span class="math inline">\(i\in I\)</span> 有 <span class="math inline">\(\lambda_i\ne0\)</span>。</p><p>对 <span class="math inline">\(p\in V\)</span>，设 <span class="math inline">\(Ap=u\in V_I\)</span>。利用 <span class="math display">\[(p,\alpha_i)=(wp,w\alpha_i)=(p+Ap,\alpha_i+A\alpha_i).\]</span>代入 <span class="math inline">\(Ap=u\)</span> 和 <span class="math inline">\(A\alpha_i=\lambda_i\omega_s\)</span>，化简可得<span class="math display">\[(u,\alpha_i)+\lambda_i(p,\omega_s)=0,\qquad\forall i\in I.\]</span> 记 <span class="math inline">\(u=\sum_{j\in I}x_j\alpha_j\,(x_j\in\mathbb{R})\)</span>，<span class="math inline">\(x=(x_i)_{i\in I}\)</span>，<span class="math inline">\(\lambda=(\lambda_i)_{i\in I}\)</span>，则 <span class="math display">\[G x = -(p,\omega_s)\lambda.\]</span> 其中 <span class="math inline">\(G=(\alpha_i,\alpha_j)_{i,j\in I}\)</span> 是 <span class="math inline">\(V_I\)</span> 上的 Gram 矩阵。这是一个关于 <span class="math inline">\(x\)</span> 的线性方程组，由于 <span class="math inline">\(G\)</span>是半正定但不是正定的，所以我们不能直接把 <span class="math inline">\(G\)</span> 的逆矩阵写在右边。但是我们可以用 <span class="math inline">\(G\)</span> 的 Moore-Penrose 将 <span class="math inline">\(x\)</span> 表示为： <span class="math display">\[x= -(p,\omega_s)G^+\lambda.\]</span> 于是 <span class="math display">\[A^2p=A(u)=\sum_{j\in I} x_jA(\alpha_j)=\sum_{j\inI}x_j\lambda_j\omega_s = -(p,\omega_s)\,\lambda^\top G^+\lambda\\omega_s.\]</span> 我们断言有 <span class="math inline">\(a=\lambda^\topG^+\lambda&gt; 0\)</span> 成立。不过这个断言的证明我们放在后面。</p><p>至此我们证明了 <span class="math inline">\(A^2p = -a(p,\omega_s)\omega_s\)</span> 且 <span class="math inline">\(a&gt;0\)</span>。我们来确定 <span class="math inline">\((p,\omega_s)\)</span> 的符号。这里要用到 <span class="math inline">\(p\in\overline{\mathcal{D}}=\mathrm{cone}(\Delta^\ast)\)</span>的条件。如果 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(\omega_s\)</span> 的正倍数，显然 <span class="math inline">\(\omega_s\in\overline{ \mathrm{cone}(\bigcup_{w\inW_I}wp) }\)</span>，命题自然成立。所以我们可以假设 <span class="math inline">\(p\)</span> 与 <span class="math inline">\(\omega_s\)</span> 不共线。设 <span class="math inline">\(p=\sum_{t\in S}c_t\omega_t\,(c_t\geq0)\)</span>，则至少有一个 <span class="math inline">\(t\ne s\)</span> 满足 <span class="math inline">\(c_t&gt;0\)</span>。于是 <span class="math display">\[(\omega_s,p)=\sum_{t\ne s}\underbrace{c_t}_{\geq0\text{ 且至少有一个 } &gt;0}\ \cdot\\underbrace{(\omega_s,\omega_t)}_{\text{已知 }&lt;0}&lt;0.\]</span> 从而<span class="math inline">\(b=-a(\omega_s,p)&gt;0\)</span>。由 <span class="math inline">\(A^3=0\)</span> 与二项式展开： <span class="math display">\[w^N p=(1+A)^N p=p+N Ap+\binom{N}{2}A^2p.\]</span>代入 <span class="math inline">\(A^2p = b\omega_s\)</span> 有 <span class="math display">\[\lim_{N\to\infty}\frac{w^Np}{\binom{N}{2}b}=\omega_s.\]</span>即得所证。</p><p>最后我们来补上 <span class="math inline">\(\lambda^\topG^+\lambda&gt;0\)</span> 的证明。为此我们只要说明有 <span class="math inline">\(\lambda\in\mathrm{im}G\)</span> 即可。由于 <span class="math inline">\(\ker G\)</span> 是一维的。设 <span class="math inline">\(\omega_s = \sum_{i\in I}z_i\alpha_i\)</span>，则易见 <span class="math inline">\(\ker G\)</span>由单个向量 <span class="math inline">\(z=(z_i)_{i\in I}\)</span>生成。</p><p>另一方面在 <span class="math inline">\(\omega_s = \sum_{i\in I}z_i\alpha_i\)</span> 两边用 <span class="math inline">\(A\)</span>作用，有 <span class="math display">\[0=A\omega_s = \sum_{i\inI}z_iA\alpha_i=\sum_{i\in I}z_i\lambda_i\omega_s=(\lambda^\topz)\omega_s.\]</span> 于是 <span class="math inline">\(\lambda^\topz=0\)</span>，即 <span class="math inline">\(\lambda\perp z = \kerG\)</span>，从而 <span class="math inline">\(\lambda\in{\rmim}(G)\)</span>。</p><p><span class="math inline">\(\blacksquare\)</span></p><h1 id="附录">附录</h1><h2 id="appendixA">level 1 情形断言的证明</h2><p>首先是断言 1 的证明。记</p><p><span class="math display">\[I_+=\{s\in S\mid u_s&gt;0\},\quadI_-=\{s\in S\mid u_s&lt;0\},\quad I_0=\{s\in S\mid u_s=0\}.\]</span>并记 <span class="math inline">\(u_+=\sum_{s\inI_+}u_s\alpha_s\)</span>，<span class="math inline">\(u_-=\sum_{t\inI_-}u_t\alpha_t\)</span>，则 <span class="math inline">\(u=u_++u_-\)</span> 且 <span class="math display">\[(u,u)=(u_+,u_+) + (u_-,u_-) +2(u_+,u_-)&lt;0.\]</span> 但是注意到 <span class="math display">\[(u_+,u_-)=\sum_{s\in I_+}\sum_{t\inI_-}\underbrace{u_s}_{&gt;0}\underbrace{u_t}_{&lt;0}\underbrace{(\alpha_s,\alpha_t)}_{\leq0}\geq0.\]</span> 所以 <span class="math inline">\((u_+, u_+) &lt; 0\)</span>和 <span class="math inline">\((u_-, u_-)&lt;0\)</span>至少有一个成立，不妨设 <span class="math inline">\((u_+,u_+)&lt;0\)</span>。如果 <span class="math inline">\(|I_-\cupI_0|\geq1\)</span>，那么 <span class="math inline">\(I_+\)</span>作为真子图包含 time-like 的向量 <span class="math inline">\(u_+\)</span>，这与 <span class="math inline">\(\Gamma\)</span> 的 level 等于 1 矛盾。所以 <span class="math inline">\(I=I_+\)</span>，即所有系数 <span class="math inline">\(u_s\)</span> 都大于 0。相应地如果是 <span class="math inline">\((u_-,u_-)&lt;0\)</span> 的话则所有 <span class="math inline">\(u_s\)</span> 都小于 0。</p><p>对断言 2 我们仍然采用类似的记号，记 <span class="math inline">\(v_+=\sum_{s\in I_+}v_s\alpha_s\)</span>，<span class="math inline">\(v_-=\sum_{t\in I_-}v_t\alpha_t\)</span>，则同样有<span class="math inline">\((v_+,v_-)\geq0\)</span>。</p><p>如果 <span class="math inline">\(|I_0|\geq2\)</span>，那么 <span class="math inline">\((v, v)=0\)</span> 说明删除 <span class="math inline">\(I_0\)</span> 以后得到的子图不是有限的，这与 <span class="math inline">\(\Gamma\)</span> 的 level 是 1 和 <a href="#level-l" title="定理 1.2">定理 1.2</a> 矛盾。所以 <span class="math inline">\(|I_0|\leq 1\)</span>。</p><p>如果 <span class="math inline">\(I_+,\,I_-\)</span>都非空，则它们作为真子图是仿射/有限的。于是 <span class="math inline">\((v_+, v_+)\geq0,(v_-, v_-)\geq0\)</span>。然而<span class="math display">\[0=(v, v) = (v_+,v_+) + (v_-,v_-) +2(v_+,v_-).\]</span> 三个非负数的和等于 0，只能是 <span class="math inline">\((v_+,v_+) = (v_-,v_-) =(v_+,v_-)=0\)</span>。现在分情况讨论：</p><ol type="1"><li>如果 <span class="math inline">\(|I_0|=1\)</span>，那么删掉 <span class="math inline">\(I_-\cup I_0\)</span> 会至少删掉两个顶点，但 <span class="math inline">\((v_+,v_+)=0\)</span> 说明 <span class="math inline">\(I_+\)</span> 不是有限的，与 <span class="math inline">\(\Gamma\)</span> 的 level 是 1 和 <a href="#level-l" title="定理 1.2">定理 1.2</a> 矛盾。</li><li>如果 <span class="math inline">\(I_0=\emptyset\)</span>，则 <span class="math inline">\(S=I_+\cup I_-\)</span>。然而 <span class="math inline">\((v_+,v_-)=\sum_{s\in I_+,\,t\inI_-}v_sv_t(\alpha_s,\alpha_t)=0\)</span> 说明对任何 <span class="math inline">\(s\in I_+,\,t\in I_-\)</span> 有 <span class="math inline">\((\alpha_s,\alpha_t)=0\)</span>，从而 <span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 互不连通，这与 <span class="math inline">\(\Gamma\)</span> 连通矛盾。</li></ol><p>总之 <span class="math inline">\(|I_0|\leq1\)</span>，并且 <span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 必有一个是空集，断言 2 得证。</p><h2 id="appendixB">level 2 情形断言的证明</h2><p><strong>断言 1 的证明</strong>。记 <span class="math inline">\(I_+,I_-,I_0\)</span> 如前。<span class="math inline">\((u,u)&lt;0\)</span> 和 <span class="math inline">\((u_+,u_-)\geq0\)</span> 说明 <span class="math inline">\((u_+, u_+) &lt; 0\)</span> 和 <span class="math inline">\((u_-, u_-)&lt;0\)</span> 至少有一个成立。不妨设<span class="math inline">\((u_+,u_+)&lt;0\)</span>。由 level 2 可得<span class="math inline">\(|I_-\cup I_0|\leq1\)</span>。即除去至多一个系数之外，其它的系数均非 0 且同号。断言 1得证。</p><p><strong>断言 2 的证明</strong>。同样记 <span class="math inline">\(I_+,I_-,I_0\)</span> 如前。</p><ul><li><p><span class="math inline">\(I_0=\emptyset\)</span>。如果有 <span class="math inline">\(|I_+|\geq2\)</span> 和 <span class="math inline">\(|I_-|\geq2\)</span>，则 level 2 导致 <span class="math display">\[(v_+,v_+)\geq0,\quad (v_-,v_-)\geq0.\]</span>再结合 <span class="math inline">\((v,v)=0\)</span> 和 <span class="math inline">\((v_+,v_-)\geq0\)</span> 可得 <span class="math display">\[(v_+, v_+) = (v_-,v_-)=(v_+,v_-)=0.\]</span> 但<span class="math inline">\((v_+,v_-)=\sum_{s\in I_+}\sum_{t\inI_-}v_sv_t(\alpha_s,\alpha_t)=0\)</span> 说明 <span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 将 <span class="math inline">\(S\)</span> 分为两个互不联通的子集，与 <span class="math inline">\(\Gamma\)</span>不可约矛盾。所以如果系数均非零，则至多只能有一个与其它异号。</p></li><li><p><span class="math inline">\(I_0\ne\emptyset\)</span>。<span class="math inline">\((v,v)=0\)</span> 和 <a href="#level-l" title="定理 1.2">定理 1.2</a> 说明 <span class="math inline">\(|I_0|\leq2\)</span>。我们来证明这时 <span class="math inline">\(I_+,I_-\)</span>之中必有一个是空集。即剩下的非零系数都同号。若不然，由于 <span class="math inline">\(|\Gamma|\geq4\)</span>，所以 <span class="math inline">\(|I_+|\geq2\)</span> 和 <span class="math inline">\(|I_-|\geq2\)</span> 至少有一个成立。不妨设 <span class="math inline">\(|I_+|\geq2\)</span>，则 <span class="math inline">\(I_-\)</span> 作为删除 <span class="math inline">\(|I_+\cup I_0|\geq3\)</span>个顶点得到的子图是有限型的，于是 <span class="math inline">\((v_-,v_-)&gt;0\)</span>。<span class="math inline">\(I_+\)</span> 作为删除 <span class="math inline">\(|I_-\cup I_0|\geq2\)</span>个顶点得到的子图是有限或者仿射的，于是 <span class="math inline">\((v_+,v_+)\geq0\)</span>。这同样与 <span class="math inline">\((v,v)=0\)</span> 和 <span class="math inline">\((v_+,v_-)\geq0\)</span> 矛盾。</p></li></ul><p>至此断言 2 得证，从而定理得证。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div><div id="ref-Maxwell82" class="csl-entry" role="listitem">Maxwell, George. 1982. <span>“Sphere Packings and Hyperbolic ReflectionGroups.”</span> <em>Journal of Algebra</em> 79 (1): 78–97. <a href="https://doi.org/10.1016/0021-8693(82)90318-0">https://doi.org/10.1016/0021-8693(82)90318-0</a>.</div><div id="ref-Maxwell89" class="csl-entry" role="listitem">———. 1989. <span>“Wythoff’s Construction for Coxeter Groups.”</span><em>Journal of Algebra</em> 123 (2): 351–77. <a href="https://doi.org/10.1016/0021-8693(89)90051-3">https://doi.org/10.1016/0021-8693(89)90051-3</a>.</div></div><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>解释下为什么在 <span class="math inline">\(K\)</span>中一定可以找到一个非平凡的元素。由于 <span class="math inline">\(W_I\)</span> 是不可约仿射的，<span class="math inline">\(\mathrm{rad}(V_I)=\mathbb{R}\omega_s\)</span>，<span class="math inline">\((\cdot,\cdot)\)</span> 在 <span class="math inline">\(V_I/\mathbb{R}\omega_s\)</span>上诱导的内积是正定的。商群 <span class="math inline">\(W_I/K\)</span> 是<span class="math inline">\(V_I/\mathbb{R}\omega_s\)</span>中的反射群，并且保持这个正定内积不变，所以根据 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec. 6.4</a>)</span> 的结论，<span class="math inline">\(W_I/K\)</span> 是有限群。由于 <span class="math inline">\(W_I\)</span> 是无限群，所以 <span class="math inline">\(K\)</span> 也是无限群。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记</title>
      <link href="/coxeter-groups/index.html"/>
      <url>/coxeter-groups/index.html</url>
      
        <content type="html"><![CDATA[<ol type="1"><li><a href="geometric-realization">几何实现</a></li><li><a href="root-system">根系</a></li><li><a href="tits-cone">Tits 锥及其对偶</a></li><li><a href="three-geometries">有限、仿射、双曲三种情形的 Tits锥</a></li><li><a href="level">Coxeter 群的 level</a></li><li><a href="Boyd-Maxwell">Boyd-Maxwell 球堆</a></li><li><a href="coxeter-automata">Coxeter 群的极小根与正则语言性质</a></li></ol>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（二）：根系</title>
      <link href="/coxeter-groups/root-system.html"/>
      <url>/coxeter-groups/root-system.html</url>
      
        <content type="html"><![CDATA[<p>我们先简要回顾 <a href="/coxeter-groups/geometric-realization/">第一篇笔记</a>的核心内容。</p><p>设 <span class="math inline">\((W,S)\)</span> 是一个 Coxeter系。我们在该文中将其实现为一个实向量空间 <span class="math inline">\(V\)</span> 上的正交反射群，方式如下：</p><ol type="1"><li>取 <span class="math inline">\(n=|S|\)</span> 维实向量空间 <span class="math inline">\(V\)</span>，并设其一组基为 <span class="math inline">\(\{\alpha_s\mid s\in S\}\)</span>；</li><li>定义 <span class="math inline">\(V\)</span> 上的内积 <span class="math inline">\((\cdot,\cdot)\)</span>；</li><li>对每个生成元 <span class="math inline">\(s\in S\)</span> 在 <span class="math inline">\(V\)</span> 上的作用是以 <span class="math inline">\(\alpha_s\)</span> 为法向量的反射 <span class="math inline">\(\rho_s\)</span>；</li><li>最后，我们证明了 <span class="math inline">\(\rho\,\colon\W\to\mathrm{O}(V)\)</span> 是群同态。</li></ol><p>但是我们还有一个未完成的工作：证明 <span class="math inline">\(\rho\)</span>是同构。本文会完成它。此外我还会介绍一些关于根系的知识。如果你直接翻到本文后面，会看到我罗列了很多关于根系的推论。这并不是我在故意掉书袋，这些推论每一条后面都会用到。不过读者初次阅读时只要大致浏览它们即可，等后面用到时再跳转过来查看细节。</p><span id="more"></span><h1 id="根系">根系</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>我们称集合 <span class="math display">\[\Phi=W\cdot\Delta=\{w\alpha_s\mid w\in W, \,\alpha_s\in\Delta\}\]</span> 为 <span class="math inline">\((W,S)\)</span> 的<strong>根系</strong>，任何 <span class="math inline">\(\lambda\in\Phi\)</span>叫做根向量，简称为<strong>根</strong>。<span class="math inline">\(\Delta\)</span> 叫做<strong>单根系</strong>，<span class="math inline">\(\Delta\)</span>中的元素叫做<strong>单根</strong>。</p></div><p>我们可以立刻观察到以下几点：</p><ul><li>每个根 <span class="math inline">\(\lambda=w\alpha_s\)</span>都是内积 <span class="math inline">\((\cdot,\cdot)\)</span>下的单位向量，因为群 <span class="math inline">\(W\)</span>的作用保持内积；</li><li>若 <span class="math inline">\(\alpha, \beta \in \Phi\)</span>共线，则 <span class="math inline">\(\alpha = \pm\beta\)</span>。这是因为它们都是单位向量，<span class="math inline">\(\alpha = k\beta\Rightarrow k^2 = 1\)</span>。</li></ul><p>由于 <span class="math inline">\(\Delta\)</span> 构成 <span class="math inline">\(V\)</span> 的一组基，所以每个根 <span class="math inline">\(\Phi\in\lambda\)</span> 都是单根的线性组合： <span class="math display">\[\lambda = \sum_{s\in S}c_s\alpha_s,\quadc_s\in\mathbb{R}.\]</span> 如果上面的所有系数 <span class="math inline">\(c_s\)</span> 都非负，就称 <span class="math inline">\(\lambda\)</span>是<strong>正根</strong>；若所有系数 <span class="math inline">\(c_s\)</span> 都非正，就称 <span class="math inline">\(\lambda\)</span>是<strong>负根</strong>。正根和负根组成的集合分别记作 <span class="math inline">\(\Phi^+\)</span> 和 <span class="math inline">\(\Phi^-\)</span>。显然 <span class="math inline">\(\Phi^+\cap\Phi^-=\emptyset\)</span>。</p><p>这就引出了一个问题：每个根都必然是正根或者负根吗？即是否有 <span class="math inline">\(\Phi=\Phi^+\cup\Phi^-\)</span>成立？虽然答案是肯定的，但这并不显然。为此我们需要一个关键引理。这个引理的证明有点长，但是它非常重要，Coxeter群的几乎所有性质的证明多少都会用到它。在引入它之前，我们需要做一点小小的准备。</p><p>设 <span class="math inline">\(I\subseteq S\)</span>，<span class="math inline">\(I\)</span> 中的生成元在 <span class="math inline">\((W,S)\)</span> 中生成一个子群 <span class="math inline">\(W_I \leqslant (W,S)\)</span>，<span class="math inline">\(W_I\)</span> 叫做<strong>标准椭圆子群</strong>。记<span class="math inline">\(l_I(\cdot)\)</span> 是 <span class="math inline">\(W_I\)</span> 上的长度函数，则显然对任何 <span class="math inline">\(w\in W_I\)</span> 有 <span class="math inline">\(l(w)\leq l_I(w)\)</span> 成立（因为 <span class="math inline">\(W_I\)</span> 中的既约表示放到 <span class="math inline">\(W\)</span>中可能不是既约的）。我们后面会证明其实有 <span class="math inline">\(l_I=l\mid_{W_I}\)</span>。</p><p>现在请出我们的重要引理：</p><div id="key-lemma" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(s\in S,\, w\in W\)</span>，则</p><ol type="1"><li><span class="math inline">\(l(ws) &gt; l(w)\)</span> 当且仅当 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>。</li><li><span class="math inline">\(l(ws) &lt; l(w)\)</span> 当且仅当 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>。</li></ol></div><p><strong>证明</strong>：这里 1 和 2 是等价的：如果 1 成立，则</p><p><span class="math display">\[\begin{align*}l(ws)&lt;l(w)&amp;\Leftrightarrow l((ws)s) &gt; l(ws)\\&amp;\Leftrightarrow ws(\alpha_s)\in\Phi^+\\&amp;\Leftrightarrow w(-\alpha_s)\in\Phi^+\\&amp;\Leftrightarrow w\alpha_s\in\Phi^-.\end{align*}\]</span></p><p>所以只需要证明 1 即可。</p><p>我们先证明充分性：若 <span class="math inline">\(l(ws)&gt;l(w)\)</span> 则 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>。</p><p>对 <span class="math inline">\(l(w)\)</span> 归纳：<span class="math inline">\(l(w)=0\)</span> 时 <span class="math inline">\(w=1\)</span>，结论显然成立。下面设结论对所有长度小于<span class="math inline">\(l(w)\)</span> 的元素成立。</p><p>我们总是可以取 <span class="math inline">\(t\in S\)</span> 使得 <span class="math inline">\(l(wt)&lt;l(w)\)</span>，比如 <span class="math inline">\(t\)</span> 取为 <span class="math inline">\(w\)</span> 的某个既约表达式的最后一项。由于 <span class="math inline">\(l(ws)&gt;l(w)\)</span>，故 <span class="math inline">\(t\ne s\)</span>。令 <span class="math inline">\(I=\{s,t\}\)</span>，定义集合 <span class="math display">\[A = \{(x,x_I)\in W\times W_I\midw=xx_I,\,l(w)=l(x)+l_I(x_I)\}.\]</span> 由于 <span class="math inline">\((wt,t)\in A\)</span> 所以 <span class="math inline">\(A\)</span> 非空。取 <span class="math inline">\((v,v_I)\in A\)</span> 使得 <span class="math inline">\(l(v)\)</span> 是最小的，则 <span class="math display">\[l(v)\leq l(wt)=l(w)-1.\]</span> 我们断言对任何<span class="math inline">\(u\in I\)</span> 都有 <span class="math inline">\(l(vu)&gt;l(v)\)</span>。若不然，则 <span class="math inline">\(l(vu)=l(v)-1\)</span>，于是 <span class="math display">\[\begin{align*}l(w)&amp;=l(vu\cdot uv_I)\leq l(vu) + l(uv_I) = (l(v) -1) + l(uv_I)\\&amp;\leq (l(v) -1) + l_I(uv_I)\\&amp;\leq (l(v) -1) + (l_I(v_I) + 1)\\&amp; = l(v) + l_I(v_I)=l(w).\end{align*}\]</span> 于是所有的不等号都是等式，从而 <span class="math inline">\((vu,uv_I)\in A\)</span>，但这与 <span class="math inline">\((v,v_I)\)</span> 的选择矛盾。所以不论 <span class="math inline">\(u=s\)</span> 或是 <span class="math inline">\(u=t\)</span> 都有 <span class="math inline">\(l(vu)&gt;l(v)\)</span>。</p><p>由于 <span class="math inline">\(l(v)\leq l(w)-1\)</span>所以根据归纳假设 <span class="math inline">\(v\alpha_s,\,v\alpha_t\)</span>都是正根。如果我们能够证明 <span class="math inline">\(v_I\alpha_s\)</span> 是 <span class="math inline">\(\alpha_s\)</span> 和 <span class="math inline">\(\alpha_t\)</span> 的非负线性组合：<span class="math display">\[v_I\alpha_s = a\alpha_s + b\alpha_t,\quada,\,b\geq0.\]</span> 则 <span class="math display">\[w\alpha_s=vv_I\alpha_s=v(a\alpha_s +b\alpha_t)=av\alpha_s + bv\alpha_t\in\Phi^+.\]</span>这就证明了结论。</p><p>注意到 <span class="math inline">\(v_I\in W_I\)</span>的任何既约表示都是 <span class="math inline">\(s,t\)</span>的交错乘积，而且不能以 <span class="math inline">\(s\)</span> 结尾，否则<span class="math inline">\(l_I(v_Is)=l_I(v_I)-1\)</span>，从而 <span class="math display">\[l(ws)=l(vv_Is)\leq l(v) + l(v_Is)\leql(v)+l_I(v_Is)=l(v)+l_I(v_I)-1=l(w)-1.\]</span> 这与 <span class="math inline">\(l(ws) &gt; l(w)\)</span> 矛盾！</p><p>于是 <span class="math inline">\(v_I\)</span> 形如 <span class="math inline">\(v_I=st\cdots t\)</span> 或者 <span class="math inline">\(v_I=ts\cdots t\)</span>，问题归结为分析这样的<span class="math inline">\(v_I\)</span> 在 <span class="math inline">\(\alpha_s\)</span> 上的作用。我们在 <a href="/coxeter-groups/geometric-realization#rank2-roots">前文</a>中已经有过计算：</p><ol type="1"><li><span class="math inline">\(m=m_{s,t}&lt;\infty\)</span> 时，<span class="math inline">\(W_I\)</span> 是有限二面体群 <span class="math inline">\(D_m\)</span>。<span class="math inline">\(W_I\)</span> 中所有长度 <span class="math inline">\(\leq m-1\)</span> 且以 <span class="math inline">\(t\)</span> 结尾的元素罗列如下（包含恒等元）：<span class="math display">\[1,\ t,\ st,\ \ldots,\ \overbrace{\ast\cdotsst}^{m-1}.\]</span> 它们作用在 <span class="math inline">\(\alpha_s\)</span> 上给出如下链条的前 <span class="math inline">\(m\)</span> 项： <span class="math display">\[\alpha_s\xrightarrow{\ t\ }\dfrac{\sin\theta}{\sin\theta}\alpha_s+\dfrac{\sin2\theta}{\sin\theta}\alpha_t\xrightarrow{\ s\ }\dfrac{\sin3\theta}{\sin\theta}\alpha_s+\dfrac{\sin2\theta}{\sin\theta}\alpha_t\xrightarrow{\ t\ }\cdots\]</span> 其中<span class="math inline">\(\theta=\pi/m\)</span>。这 <span class="math inline">\(m\)</span> 项都是 <span class="math inline">\(\alpha_s,\alpha_t\)</span> 的非负线性组合。</li></ol><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>以 <span class="math inline">\(m=5\)</span> 为例，所有 <span class="math inline">\(m\)</span> 个正根都位于 <span class="math inline">\(\alpha_s,\alpha_t\)</span> 张成的楔形区域内：</p><figure><img src="/images/coxeter/finite2d.svg" width="400" alt="m=5 的例子"><figcaption aria-hidden="true"><span class="math inline">\(m=5\)</span>的例子</figcaption></figure><p>从 <span class="math inline">\(\alpha_s\)</span>一侧开始，这些正根形如 <span class="math display">\[\dfrac{\sink\theta}{\sin\theta}\alpha_s+\dfrac{\sin(k-1)\theta}{\sin\theta}\alpha_t,\quad k=1,2,\ldots,m.\]</span> 从 <span class="math inline">\(\alpha_t\)</span> 一侧开始，它们形如 <span class="math display">\[\dfrac{\sin(k-1)\theta}{\sin\theta}\alpha_s+\dfrac{\sink\theta}{\sin\theta}\alpha_t,\quad k=1,2,\ldots,m.\]</span> 当 <span class="math inline">\(k\)</span> 跑遍 <span class="math inline">\(1,\ldots,m\)</span> 时，第一个序列从 <span class="math inline">\(\alpha_s\)</span> 开始过渡到 <span class="math inline">\(\alpha_t\)</span>，第二个序列从 <span class="math inline">\(\alpha_t\)</span> 开始过渡到 <span class="math inline">\(\alpha_s\)</span>。它们最接近的位置是在 <span class="math inline">\(k=\lfloor(m+1)/2\rfloor\)</span> 处（<span class="math inline">\(m\)</span> 为奇数时重合）。这两个序列的前 <span class="math inline">\(\lfloor(m+1)/2\rfloor\)</span>项合起来正好给出全部 <span class="math inline">\(m\)</span> 个正根。这<span class="math inline">\(m\)</span> 个正根可以通过将 <span class="math inline">\(1,t,st,\ldots,\overbrace{\ast\cdotsst}^{m-1}\)</span> 这 <span class="math inline">\(m\)</span>个元素作用在 <span class="math inline">\(\alpha_s\)</span> 上得到。</p></div><ol start="2" type="1"><li><span class="math inline">\(m=m_{s,t}=\infty\)</span> 时，记 <span class="math inline">\(\cosh\theta=a_{s,t}\,(\theta\geq0)\)</span>，则<span class="math display">\[\alpha_s\xrightarrow{\ t\ }\dfrac{\sinh\theta}{\sinh\theta}\alpha_s+\dfrac{\sinh2\theta}{\sinh\theta}\alpha_t\xrightarrow{\ s\ }\dfrac{\sinh3\theta}{\sinh\theta}\alpha_s+\dfrac{\sinh2\theta}{\sinh\theta}\alpha_t\xrightarrow{\ t\ }\cdots\]</span>每一项都是 <span class="math inline">\(\alpha_s,\alpha_t\)</span>的非负线性组合。</li></ol><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>当 <span class="math inline">\(\theta=0\)</span> 时，<span class="math inline">\(W_I\)</span>是一维直线上两个平行镜面生成的（仿射）反射群（包含了平移），它可以处理成二维平面上的线性反射群：</p><p><img src="/images/coxeter/affine2d.svg" class="fig" width="500"></p><p>当 <span class="math inline">\(\theta&gt;0\)</span> 时，<span class="math inline">\(W_I\)</span>是双曲空间中两个超平行的镜面生成的双曲反射群，它也可以处理成二维平面上的线性反射群：</p><p><img src="/images/coxeter/hyperbolic2d.svg" class="fig" width="400"></p></div><p>必要性的证明：</p><p>我们要证明若 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>则 <span class="math inline">\(l(ws)&gt;l(w)\)</span>。若不然，则 <span class="math inline">\(l(w)=l(wss)&gt;l(ws)\)</span>，从而由充分性的证明知道<span class="math inline">\(ws\alpha_s\in\Phi^+\)</span>，即 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>，矛盾！至此关键引理得证。<span class="math inline">\(\blacksquare\)</span></p><p>从 <a href="#key-lemma" title="引理 1.2">引理 1.2</a>出发我们可以得到许多重要推论：</p><div id="faithful" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(w\in W\)</span> 满足对任何 <span class="math inline">\(v\in V\)</span> 都有 <span class="math inline">\(wv=v\)</span>，则 <span class="math inline">\(w\)</span> 必然是恒等元。换言之，表示 <span class="math inline">\(\rho: W\to{\rm O}(V)\)</span> 是忠实的。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(w\ne1\)</span>，则存在 <span class="math inline">\(s\in S\)</span> 使得<span class="math inline">\(l(ws)&lt;l(w)\)</span>，从而 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>，这与 <span class="math inline">\(w\alpha_s=\alpha_s\)</span> 矛盾。<span class="math inline">\(\blacksquare\)</span></p><div id="pos-neg" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.4</span>.</span><span class="statement-spah"></span>每个根不是正根就是负根，即 <span class="math inline">\(\Phi=\Phi^+\cup\Phi^-\)</span>。</p></div><p><strong>证明</strong>：任取 <span class="math inline">\(\lambda \in\Phi\)</span>，则存在 <span class="math inline">\(w \in W\)</span> 与<span class="math inline">\(s \in S\)</span> 使得 <span class="math inline">\(\lambda = w\alpha_s\)</span>。若 <span class="math inline">\(l(ws) &gt; l(w)\)</span>，则 <span class="math inline">\(\lambda \in \Phi^+\)</span>，否则 <span class="math inline">\(\lambda \in \Phi^-\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="simple-ref" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.5</span>.</span><span class="statement-spah"> </span>任何单反射 <span class="math inline">\(s\)</span> 置换 <span class="math inline">\(\Phi^+\setminus\{\alpha_s\}\)</span>中的正根，同时将 <span class="math inline">\(\alpha_s\)</span> 变为<span class="math inline">\(-\alpha_s\)</span>。</p></div><p><strong>证明</strong>：对任一正根 <span class="math inline">\(\lambda\ne\alpha_s\in\Phi^+\)</span>，<span class="math inline">\(\lambda\)</span> 不可能与 <span class="math inline">\(\alpha_s\)</span> 共线，所以其作为单根的线性组合<span class="math inline">\(\lambda=\sum_{t\in S}c_t\alpha_t\)</span>中必有某个 <span class="math inline">\(t\ne s\)</span> 使得 <span class="math inline">\(c_t&gt;0\)</span>，于是 <span class="math inline">\(s\lambda=\lambda-2(\lambda,\alpha_s)\alpha_s\)</span>的 <span class="math inline">\(\alpha_t\)</span>分量保持不动仍然为正，于是根据 <a href="#pos-neg" title="推论 1.4">推论1.4</a> <span class="math inline">\(s\lambda\)</span> 仍然是正根。<span class="math inline">\(\blacksquare\)</span></p><div id="lw-nw" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.6</span>.</span><span class="statement-spah"> </span>对 <span class="math inline">\(w\in W\)</span>，定义 <span class="math inline">\(N(w)\)</span> 为被 <span class="math inline">\(w\)</span> 变成负根的那些正根组成的集合： <span class="math display">\[N(w)=\{\lambda\in\Phi^+\midw\lambda\in\Phi^-\}.\]</span> 则 <span class="math inline">\(|N(w)|=l(w)\)</span>。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(l(w)\)</span>归纳。<span class="math inline">\(l(w)=0\)</span> 时 <span class="math inline">\(w=1\)</span>，结论成立。若 <span class="math inline">\(l(w)&gt;0\)</span>，取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(w=w's\)</span> 且 <span class="math inline">\(l(w')&lt;l(w)\)</span>。由 <a href="#key-lemma" title="引理 1.2">引理 1.2</a>，<span class="math inline">\(\alpha_s\in N(w)\)</span> 但是 <span class="math inline">\(\alpha_s\notin N(w')\)</span>。</p><p>对任何正根 <span class="math inline">\(\lambda\ne\alpha_s\)</span>，<span class="math inline">\(s\lambda\)</span> 仍然是正根。由恒等式 <span class="math display">\[w'\lambda\in\Phi^- \Leftrightarroww(s\lambda)\in\Phi^-\]</span> 可得 <span class="math inline">\(\lambda\leftrightarrow s\lambda\)</span> 给出了<span class="math inline">\(N(w')\)</span> 和 <span class="math inline">\(N(w)\setminus\{\alpha_s\}\)</span>之间的一一对应，即 <span class="math display">\[N(w)=s\cdotN(w')\cup\{\alpha_s\}.\]</span> 从而由归纳假设 <span class="math display">\[|N(w)|=|N(w')|+1=l(w')+1=l(w).\]</span><span class="math inline">\(\blacksquare\)</span></p><div id="nw-zero-means-identity" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.7</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(w(\Phi^+)\subseteq\Phi^+\)</span>，则 <span class="math inline">\(w=1\)</span>。</p></div><p><strong>证明</strong>：根据 <a href="#lw-nw" title="推论 1.6">推论1.6</a> 有 <span class="math inline">\(l(w)=|N(w)|=0\)</span>，从而<span class="math inline">\(w=1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="w-phi-both-finite-infinite" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.8</span>.</span><span class="statement-spah"> </span><span class="math inline">\(|W|&lt;\infty\)</span> 当且仅当 <span class="math inline">\(|\Phi|&lt;\infty\)</span>。</p></div><p><strong>证明</strong>：如果 <span class="math inline">\(W\)</span>是有限群，由于 <span class="math inline">\(\Phi=W\cdot\Delta\)</span>，<span class="math inline">\(|\Phi|\leq |W|\cdot|\Delta|\)</span> 也是有限的。</p><p>反之若 <span class="math inline">\(|\Phi|&lt;\infty\)</span>，由于<span class="math inline">\(W\)</span> 保持 <span class="math inline">\(\Phi\)</span> 不变，所以 <span class="math inline">\(W\)</span> 置换地作用在 <span class="math inline">\(\Phi\)</span> 上，即有 <span class="math inline">\(W\)</span> 到置换群 <span class="math inline">\(S_{|\Phi|}\)</span> 的同态 <span class="math inline">\(W\xrightarrow{\varphi} S_{|\Phi|}\)</span>。<a href="#nw-zero-means-identity" title="推论 1.7">推论 1.7</a> 说明 <span class="math inline">\(\varphi\)</span> 是嵌入，从而 <span class="math inline">\(W\)</span> 也是有限的。<span class="math inline">\(\blacksquare\)</span></p><div id="longest" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.9</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(W\)</span> 是一个有限群，则存在唯一的元素 <span class="math inline">\(w_0\)</span>，<span class="math inline">\(w_0\)</span> 是 <span class="math inline">\(W\)</span> 中长度最大者，它交换 <span class="math inline">\(\Phi^+\)</span> 和 <span class="math inline">\(\Phi^-\)</span>：<span class="math inline">\(w_0(\Phi^+)=\Phi^-\)</span>，且 <span class="math inline">\(w_0\)</span> 是一个对合：<span class="math inline">\(w_0^2=1\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(W\)</span>有限所以存在一个长度最大的元素 <span class="math inline">\(w_0\)</span>，对任何 <span class="math inline">\(s\in S\)</span> 只能有 <span class="math inline">\(l(w_0s)&lt;l(w)\)</span>，从而 <span class="math inline">\(w_0\alpha_s\in\Phi^-\)</span>，从而 <span class="math inline">\(w_0\)</span> 把 <span class="math inline">\(\Phi^+\)</span> 变为 <span class="math inline">\(\Phi^-\)</span>。</p><p>进一步 <span class="math inline">\(w_0^2\)</span> 仍然把 <span class="math inline">\(\Phi^+\)</span> 映射为 <span class="math inline">\(\Phi^+\)</span>，所以由 <a href="#nw-zero-means-identity" title="推论 1.7">推论 1.7</a> <span class="math inline">\(w_0^2=1\)</span>，因此 <span class="math inline">\(w_0\)</span> 是一个对合。</p><p>如果存在 <span class="math inline">\(w_1\ne w_0\)</span> 使得 <span class="math inline">\(l(w_1)=l(w_0)\)</span> 的话，则 <span class="math inline">\(w_1\)</span> 也满足 <span class="math inline">\(w_1(\Phi^+)=\Phi^-\)</span>，从而 <span class="math inline">\(w_0^{-1}w_1\)</span> 保持 <span class="math inline">\(\Phi^+\)</span> 不变，根据 <a href="#nw-zero-means-identity" title="推论 1.7">推论 1.7</a> 有 <span class="math inline">\(w_0^{-1}w_1=1\)</span>，即 <span class="math inline">\(w_0=w_1\)</span>。所以这样的 <span class="math inline">\(w_0\)</span> 是唯一的。<span class="math inline">\(\blacksquare\)</span></p><div id="remain-positive-root" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.10</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(I\subsetneqq S\)</span> 是真子集，<span class="math inline">\(\lambda\in \Phi^+\setminus\Phi^+_I\)</span>是正根，则对任何 <span class="math inline">\(w\in W_I\)</span>，<span class="math inline">\(w\lambda\)</span> 仍然是正根。</p></div><p><strong>证明</strong>：<span class="math inline">\(w\lambda\)</span>是 <span class="math inline">\(\lambda\)</span> 和 <span class="math inline">\(\{\alpha_t\mid t\in I\}\)</span>中向量的线性组合： <span class="math display">\[w\lambda=\lambda +\sum_{t\in I}c_t\alpha_t.\]</span> <span class="math inline">\(\lambda\in\Phi^+\setminus\Phi^+_I\)</span> 说明将<span class="math inline">\(\lambda\)</span>表示为单根的线性组合时，其至少有一项 <span class="math inline">\(\alpha_s\,(s\notin I)\)</span> 的系数大于 0，从而<span class="math inline">\(w\lambda\)</span> 的 <span class="math inline">\(\alpha_s\)</span> 项的系数也大于 0，所以 <span class="math inline">\(w\lambda\)</span> 必然是正根。<span class="math inline">\(\blacksquare\)</span></p><div id="lI-equals-l" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.11</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(w\in W_I\)</span>，则其任何既约表示 <span class="math inline">\(w=s_1\cdots s_k\)</span> 中，每个 <span class="math inline">\(s_i\in I\)</span>，特别地 <span class="math inline">\(l_I(w)=l(w)\)</span>。</p></div><p><strong>证明</strong>：从右到左依次验证 <span class="math inline">\(s_k,\ldots,s_1\in I\)</span>。记 <span class="math inline">\(s=s_k\)</span>。由于 <span class="math inline">\(w\in W_I\)</span> 所以 <span class="math inline">\(w\alpha_s\)</span> 是 <span class="math inline">\(\alpha_s\)</span> 和一些 <span class="math inline">\(\{\alpha_t\mid t\in I\}\)</span> 的线性组合：<span class="math display">\[w\alpha_s=\alpha_s+\sum_{t\in I}c_t\alpha_t.\]</span> 由于 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span> 所以必然有某个 <span class="math inline">\(t\in I\)</span> 使得 <span class="math inline">\(s=t\)</span>，即 <span class="math inline">\(s\inI\)</span>。对 <span class="math inline">\(ws=s_1\cdots s_{k-1}\inW_I\)</span> 重复此论证即得每个 <span class="math inline">\(s_i\inI\)</span>。<span class="math inline">\(\blacksquare\)</span></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（四）：有限、仿射、双曲三种情形的 Tits 锥</title>
      <link href="/coxeter-groups/three-geometries.html"/>
      <url>/coxeter-groups/three-geometries.html</url>
      
        <content type="html"><![CDATA[<p>本文主要参考了 <span class="citation" data-cites="Howlett1997">(<a href="#ref-Howlett1997" role="doc-biblioref">Howlett, Rowley, and Taylor1997</a>)</span>。</p><p>书接 <a href="coxeter-groups-tits-cone">上回</a>，我们来研究内积<span class="math inline">\((\cdot,\cdot)\)</span>分别是有限、仿射和双曲三种情形时，Tits 锥 <span class="math inline">\(\mathcal{C}\)</span> 和对偶锥 <span class="math inline">\(\mathcal{C}^\ast\)</span> 的结构。</p><span id="more"></span><h1 id="有限">有限</h1><p>一个熟知的结论是，内积 <span class="math inline">\((\cdot,\cdot)\)</span> 是正定的当且仅当 <span class="math inline">\((W,S)\)</span> 是有限群 <span class="citation" data-cites="Humphreys90">(见 <a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.6.4</a>)</span>。我这里略过对此结论的证明（否则篇幅会拉的太长）。我们来证明这还等价于：</p><div id="finite-tits-V" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 是有限群当且仅当 Tits 锥 <span class="math inline">\(\mathcal{C}=V^\ast\)</span>。</p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>: <span class="math inline">\(W\)</span> 是有限群说明 <span class="math inline">\(\Phi\)</span> 也是有限的，从而对任何 <span class="math inline">\(x\in V^\ast\)</span> 都有 <span class="math inline">\(|\mathrm{Neg}(x)|\leq|\Phi^+|&lt;\infty\)</span>，从而 <span class="math inline">\(x\in\mathcal{C}\)</span>。</p><p><span class="math inline">\(\Leftarrow\)</span>: 由 <span class="math inline">\(\mathcal{C}=V^\ast\)</span> 可得 <span class="math inline">\(-\mathcal{D}\in\mathcal{C}\)</span>。对任何 <span class="math inline">\(x\in-\mathcal{D}\)</span>，我们都有 <span class="math inline">\(\Phi^+\subseteq \mathrm{Neg}(x)\)</span>，根据 <a href="/coxeter-groups/tits-cone/#tits-neg-finite">Tits锥的刻画</a>，<span class="math inline">\(|\Phi^+|=|\mathrm{Neg}(x)|&lt;\infty\)</span>，<a href="/coxeter-groups/root-system/#w-phi-both-finite-infinite">从而<span class="math inline">\(W\)</span> 是有限群</a>。</p><p><span class="math inline">\(\blacksquare\)</span></p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>在下图中，<span class="math inline">\(W\)</span> 是正二十面体群<span class="math inline">\(H_3\)</span>，红色的锥是基本区域，它在 <span class="math inline">\(W\)</span> 的作用下铺满了整个空间，所以 <span class="math inline">\(\mathcal{C}=\mathbb{R}^3\)</span>。<span class="math inline">\(\mathcal{C}\)</span>与球面的交给出球面上的密铺。如果用直线而不是球面上的弧连接顶点的话，得到的是正二十面体。</p><p><img src="/images/coxeter/Tits_finite.png" class="fig" width="350"></p></div><h1 id="无限群的-tits-锥">无限群的 Tits 锥</h1><p>在仿射和双曲的情形，Coxeter 群都是无限群。我们来介绍一点关于无限Coxeter 群 Tits 锥的一般结论。</p><div id="phi-J-finite" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题2.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(W\)</span> 是不可约 Coxeter 群。如果存在 <span class="math inline">\(J\subsetneqq S\)</span> 使得 <span class="math inline">\(\Phi\setminus\Phi_J\)</span> 是有限集，则 <span class="math inline">\(W\)</span> 必然是有限群。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(J\subsetneqqS\)</span>，所以可以设 <span class="math inline">\(S\setminusJ=\{s_1,\ldots,s_r\}\,(r\geq1)\)</span>。由于 <span class="math inline">\(\Gamma\)</span> 是连通的，任何 <span class="math inline">\(s\in S\)</span> 都可以通过某条路径与 <span class="math inline">\(S\setminus J\)</span> 中的顶点相连。记 <span class="math inline">\(d(s)\)</span> 是顶点 <span class="math inline">\(s\)</span> 与 <span class="math inline">\(S\setminus J\)</span> 之间的最短距离，将 <span class="math inline">\(S\)</span> 按如下方式重新排序为 <span class="math inline">\(S=\{s_1,\ldots,s_n\}\)</span>： <span class="math display">\[S =\underbrace{\overbrace{\{s_1,\ldots,s_r\}}^{d(s)=0}}_{S\setminusJ}\cup\underbrace{\overbrace{\{s_{r+1},\ldots,s_{r+k}\}}^{d(s)=1},\overbrace{\{s_{r+k+1},\ldots\}}^{d(s)=2},\cdots}_{J}\,.\]</span></p><p>记 <span class="math inline">\(\Phi_i^+\)</span> 是所有可以由 <span class="math inline">\(\{\alpha_i,\ldots,\alpha_n\}\)</span> 张成，且<span class="math inline">\(\alpha_i\)</span> 项系数不为 0的正根组成的集合： <span class="math display">\[\Phi_i^+=\{\lambda\in\Phi^+\mid\lambda=\sum_{j=i}^nc_j\alpha_j,\c_i\ne 0\}.\]</span> 不难看出有 <span class="math inline">\(\Phi^+=\Phi_1^+\sqcup\cdots\sqcup\Phi^+_n\)</span>，以及<span class="math inline">\(\Phi^+\setminus\Phi_J^+=\Phi_1^+\cup\cdots\cup\Phi^+_r\)</span>。由已知<span class="math inline">\(\Phi\setminus\Phi_J\)</span> 是有限的，所以<span class="math inline">\(\Phi_1^+,\ldots,\Phi^+_r\)</span>都是有限的。</p><p>我们用归纳法依次论证 <span class="math inline">\(\Phi^+_{r+1},\ldots,\Phi^+_{n}\)</span>也都是有限集：设 <span class="math inline">\(r+1\leq i\leq n\)</span>且已知对所有 <span class="math inline">\(j&lt;i\)</span>，<span class="math inline">\(\Phi_1^+,\ldots,\Phi^+_j\)</span> 都是有限集，现在考察 <span class="math inline">\(\Phi^+_i\)</span>，注意必然有 <span class="math inline">\(d(s_i)\geq1\)</span>，所以存在 <span class="math inline">\(j&lt;i\)</span> 使得 <span class="math inline">\(d(s_j)&lt;d(s_i)\)</span> 且 <span class="math inline">\(s_j\sim s_i\)</span>。</p><p>我们发现：</p><ol type="1"><li><span class="math inline">\(s_j\Phi_i^+\)</span>的元素都是正根。这是因为用 <span class="math inline">\(s_j\)</span>作用不改变 <span class="math inline">\(\Phi^+_i\)</span> 中元素的 <span class="math inline">\(\alpha_i\)</span> 项系数；</li><li><span class="math inline">\(s_j\Phi_i^+\subset\Phi^+_j\)</span>。这是因为若<span class="math inline">\(\lambda=\sum_{k\geqi}c_k\alpha_k\in\Phi^+_i\)</span>，则 <span class="math display">\[s_j\lambda=\lambda-2\left(\sum_{k\geqi}c_k(\alpha_k,\alpha_j)\right)\alpha_j.\]</span> 上面每一项 <span class="math inline">\(c_k(\alpha_k,\alpha_j)\)</span> 都非正，且由于顶点<span class="math inline">\(s_i,s_j\)</span> 相邻所以 <span class="math inline">\(c_i(\alpha_i,\alpha_j)&lt;0\)</span>。所以 <span class="math inline">\(s_j\lambda\)</span> 的 <span class="math inline">\(\alpha_j\)</span> 项系数严格大于 0。</li></ol><p>于是 <span class="math inline">\(|\Phi_i^+|\leq |\Phi^+_j|\)</span>也是有限集。从而所有 <span class="math inline">\(\Phi^+_1,\ldots,\Phi^+_n\)</span> 都是有限集，从而<span class="math inline">\(\Phi\)</span> 也是有限的。所以 <span class="math inline">\(W\)</span> 是有限群，命题得证。<span class="math inline">\(\blacksquare\)</span></p><p><a href="#phi-J-finite" title="命题 2.1">命题 2.1</a>有如下的推论：</p><div id="tits-cone-pointed" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(W\)</span> 不可约且无限，则 <span class="math inline">\(\mathcal{C}\cap-\mathcal{C}=\{0\}\)</span>，即<span class="math inline">\(\mathcal{C}\)</span> 是点锥 (pointedcone)。</p></div><p><strong>证明</strong>：根据 <span class="math display">\[\mathcal{C}\cap-\mathcal{C}=\bigcup_{w_1,w_2\inW}w_1\overline{\mathcal{D}}\cap w_2(-\overline{\mathcal{D}}).\]</span>若 <span class="math inline">\(\mathcal{C}\cap-\mathcal{C}\ne\{0\}\)</span>则存在 <span class="math inline">\(x\ne0\in\overline{\mathcal{D}}\)</span> 和 <span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(-wx\in\overline{\mathcal{D}}\)</span>。令 <span class="math display">\[J=\{s\in S\mid \langle\alpha_s,\,x\rangle=0\}.\]</span> 由于 <span class="math inline">\(x\ne0\)</span>，所以 <span class="math inline">\(J\subsetneqq S\)</span>是真子集。</p><p>对任何 <span class="math inline">\(\lambda\in\Phi^+\setminus\Phi^+_J\)</span>，显然<span class="math inline">\(\langle\lambda,\,x\rangle&gt;0\)</span>，并且对这样的 <span class="math inline">\(\lambda\)</span> 有 <span class="math display">\[\langle w\lambda,\,-wx\rangle = \langle\lambda,\,-x\rangle&lt;0.\]</span> 而 <span class="math inline">\(-wx\in\overline{\mathcal{D}}\)</span>，所以 <span class="math inline">\(w\lambda\)</span> 是负根，即 <span class="math inline">\(\Phi^+\setminus\Phi^+_J\subset\mathrm{Neg}(w)\)</span>。于是<span class="math display">\[|\Phi^+\setminus\Phi^+_J|\leq|\mathrm{Neg}(w)|=l(w)&lt;\infty.\]</span> 由 <a href="#phi-J-finite" title="命题 2.1">命题 2.1</a>，<span class="math inline">\(W\)</span>是有限群，这与已知矛盾。<span class="math inline">\(\blacksquare\)</span></p><div id="dual-cone-non-trivial" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(W\)</span> 不可约且无限，则对偶锥 <span class="math inline">\(\mathcal{C}^\ast\ne\{0\}\)</span>。</p></div><p><strong>证明</strong>：用反证法，若不然，则 <span class="math inline">\(\overline{\mathcal{C}}=\mathcal{C}^{\ast\ast}=V^\ast\)</span>是全空间。由于一个凸集的内点和它的闭包的内点集相同（证明见这个 <a href="/papers/sCONVs.pdf">附件</a>），所以 <span class="math inline">\(\mathcal{C}=V\)</span>，这与 <a href="#tits-cone-pointed" title="推论 2.2">推论 2.2</a> 的结论 <span class="math inline">\(\mathcal{C}\)</span> 是点锥矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 id="仿射">仿射</h1><p>在本节中，我们需要用到不可约仿射 Coxeter 群的一些基本事实 <span class="citation" data-cites="Humphreys90">(见 <a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, secs. 2.6, 6.5</a>)</span>。</p><div id="affine-facts" class="statement simple plain unnumbered"><p>设 <span class="math inline">\(W\)</span> 是不可约、仿射 Coxeter群，则：</p><ol type="1"><li><span class="math inline">\(\mathrm{rad}(V)\)</span> 的维数是1，它由一个向量 <span class="math inline">\(\delta=\sum_{s\inS}z_s\alpha_s\)</span> 生成，其中每个 <span class="math inline">\(z_s&gt;0\)</span>。</li><li><span class="math inline">\(\delta\)</span> 的坐标 <span class="math inline">\(z=(z_1,\ldots,z_s)^T\)</span> 满足 <span class="math inline">\(Az=z^TAz=0\)</span>，其中 <span class="math inline">\(A=((\alpha_s, \alpha_t))_{s,t\in S}\)</span>是内积 <span class="math inline">\((\cdot,\cdot)\)</span> 的 Gram矩阵。</li><li>对所有 <span class="math inline">\(w\in W\)</span> 有 <span class="math inline">\(w\delta=\delta\)</span>。</li><li><span class="math inline">\(A\)</span> 的任何 <span class="math inline">\(\leq n-1\)</span> 阶主子式都是正定的。</li></ol></div><p>我们花点笔墨解释下这几个性质的含义。回忆 <span class="math inline">\(W\)</span> 称作仿射是指内积 <span class="math inline">\((\cdot,\cdot)\)</span>是半正定但不是正定的。这个定义中似乎没有要求 <span class="math inline">\((\cdot,\cdot)\)</span> 的惯性指数中有几个0，但是上面的 1, 2 告诉我们，在 <span class="math inline">\(W\)</span>不可约的前提下，<span class="math inline">\((\cdot,\cdot)\)</span>的符号中有且只有一个 0，并且 <span class="math inline">\(\mathrm{rad}(V)\)</span> 可以由一个向量 <span class="math inline">\(\delta\)</span> 生成，并且 <span class="math inline">\(\delta\)</span> 的所有系数都大于 0。</p><p>4 说的是对任何 <span class="math inline">\(I\subsetneqqS\)</span>，标准椭圆子群 <span class="math inline">\(W_I\)</span>都是有限群；或者等价地，从 <span class="math inline">\(W\)</span> 的Coxeter 图 <span class="math inline">\(\Gamma\)</span>中删去至少一个顶点以后，剩下的子图是有限的。</p><div id="tits-cone-affine" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.1</span>.</span><span class="statement-spah"></span>在仿射的情形，<span class="math inline">\(\mathcal{C}^\ast\)</span> 是一条射线：<span class="math inline">\(\mathcal{C}^\ast=\mathbb{R}_{\geq0}\delta\)</span>。<span class="math inline">\(\mathcal{C}\)</span> 是以 <span class="math inline">\(\delta\)</span> 为法向量的半空间加上原点：<span class="math inline">\(\mathcal{C}=\{0\}\cup\{\delta &gt;0\}\)</span>。</p></div><p><strong>证明</strong>：根据 <a href="#dual-cone-non-trivial" title="推论 2.3">推论 2.3</a> 可知 <span class="math inline">\(\mathcal{C}^\ast\ne\{0\}\)</span>。结合 <a href="/coxeter-groups/tits-cone/#dual-cone-nonspace"><span class="math inline">\(\mathcal{C}^\ast\)</span> 中的向量范数 <span class="math inline">\(\leq0\)</span></a> 以及 <span class="math inline">\((\cdot,\cdot)\)</span> 半正定可得 <span class="math inline">\(\mathcal{C}^\ast\subseteq\mathbb{R}\delta\)</span>。又因为<a href="/coxeter-groups/tits-cone/#tits-cone-dual-pointed"><span class="math inline">\(\mathcal{C}^\ast\)</span> 是点锥</a>，所以 <span class="math inline">\(\mathcal{C}^\ast\)</span> 等于 <span class="math inline">\(\mathbb{R}_{\geq0}\delta\)</span> 或者 <span class="math inline">\(\mathbb{R}_{\leq0}\delta\)</span> 之一。由于 <a href="/coxeter-groups/tits-cone/#tits-cone-dual"><span class="math inline">\(\mathcal{C}^\ast\subset\mathrm{cone}(\Delta)\)</span></a>，以及<span class="math inline">\(\delta\)</span> 是 <span class="math inline">\(\Delta\)</span> 的正线性组合，所以只能是 <span class="math inline">\(\mathcal{C}^\ast=\mathbb{R}_{\geq0}\delta\)</span>。</p><p>再来分析 <span class="math inline">\(\mathcal{C}\)</span>。取对偶得到<span class="math inline">\(\overline{\mathcal{C}}=\mathcal{C}^{\ast\ast}=\{\delta\geq0\}\)</span>。由于一个凸集的内点和它的闭包的内点集相同，所以<span class="math inline">\(\mathcal{C}^\circ=\{\delta&gt;0\}\)</span>，于是<span class="math display">\[\{\delta&gt;0\}\subset\mathcal{C}\subset\overline{\mathcal{C} }=\{\delta\geq0\}.\]</span></p><p>对任何 <span class="math inline">\(x\in\{\delta=0\}\)</span>，若<span class="math inline">\(x\in\mathcal{C}\)</span>，则存在 <span class="math inline">\(w\in W\)</span> 和 <span class="math inline">\(y\in\overline{\mathcal{D}}\)</span> 使得 <span class="math inline">\(x=wy\)</span>。于是 <span class="math display">\[0= \langle \delta,\,x\rangle=\langle \delta,\,wy\rangle=\langlew^{-1}\delta,\,y\rangle=\langle \delta,\,y\rangle=\sum_{s\inS}z_s\langle \alpha_s,\,y\rangle.\]</span> 然而每个 <span class="math inline">\(z_s&gt;0\)</span>，并且由于 <span class="math inline">\(y\in\overline{\mathcal{D}}\)</span> 所以每个 <span class="math inline">\(\langle\alpha_s,\,y\rangle\geq0\)</span>，这只能是 <span class="math inline">\(\langle \alpha_s,\,y\rangle=0\)</span> 对所有<span class="math inline">\(\alpha_s\in\Delta\)</span> 成立，这导致<span class="math inline">\(y=0\)</span>，从而 <span class="math inline">\(x=0\)</span>，所以超平面 <span class="math inline">\(\{\delta=0\}\)</span> 中属于 <span class="math inline">\(\mathcal{C}\)</span> 的只有 0。这就证明了 <span class="math inline">\(\mathcal{C}=\{0\}\cup\{\delta&gt;0\}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>在下图中，<span class="math inline">\(W\)</span> 是仿射 <span class="math inline">\(\widetilde{A}_2\)</span>，红色的锥是基本区域，它在<span class="math inline">\(W\)</span> 的作用下铺满了整个上半空间，所以<span class="math inline">\(\mathcal{C}=\{z&gt;0\}\cup\{0\}\)</span>。<span class="math inline">\(\mathcal{C}\)</span> 与平面 <span class="math inline">\(z=1\)</span> 的交给出二维的 Euclidean 密铺。</p><p><img src="/images/coxeter/Tits_affine.png" class="fig" width="350"></p></div><h1 id="双曲">双曲</h1><p>双曲的情形 Tits 锥的结构较为复杂，通常难以完整刻画。</p><p>我们先介绍一些关于 Lorentzian 内积的基础知识，详见 <span class="citation" data-cites="ratcliffe">(<a href="#ref-ratcliffe" role="doc-biblioref">Ratcliffe 2006, vol. 149, chap. 3</a>)</span>。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义4.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(V\)</span> 是一个 Lorentzian 空间。我们称 <span class="math inline">\(v\in V\)</span> 是</p><ol type="1"><li>space-like 的，如果 <span class="math inline">\((v,v)&gt;0\)</span>；</li><li>light-like 的，如果 <span class="math inline">\((v,v)=0\)</span>；</li><li>time-like 的，如果 <span class="math inline">\((v,v)&lt;0\)</span>。</li></ol></div><p>这个定义也可以推广到 <span class="math inline">\(V\)</span>的子空间中：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义4.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(U\subset V\)</span> 是一个子空间，我们称 <span class="math inline">\(U\)</span> 是</p><ol type="1"><li>space-like 的，如果 <span class="math inline">\((\cdot,\cdot)\mid_U\)</span> 是正定的；</li><li>light-like 的，如果 <span class="math inline">\((\cdot,\cdot)\mid_U\)</span>是半正定的，但不是正定的；</li><li>time-like 的，如果 <span class="math inline">\(U\)</span> 包含time-like 的向量。</li></ol></div><p>由于 Lorentzian 内积是非退化的，所以对任何子空间 <span class="math inline">\(U\)</span> 都有 <span class="math inline">\(\dim U+ \dim U^\bot=n\)</span> 成立。</p><p>下面的命题是关于二次型知识的简单练习，我省略它们的证明。</p><div id="orth-complement-lorentzian" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.3</span>.</span></p><ol type="1"><li><span class="math inline">\(U\)</span> 是 space-like 的当且仅当<span class="math inline">\(U^\bot\)</span> 是 time-like 的；</li><li><span class="math inline">\(U\)</span> 是 light-like 的当且仅当<span class="math inline">\(U^\bot\)</span> 是 light-like 的。</li></ol></div><div id="lorentzinian-decomposition"></div><p>取 <span class="math inline">\(z\)</span> 是任一满足 <span class="math inline">\((z,z)=-1\)</span> 的 time-like的向量，则正交补空间 <span class="math inline">\(z^\perp\)</span> 是space-like 的，并且 <span class="math inline">\(V=\mathbb{R}z\oplusz^\perp\)</span>。任何 <span class="math inline">\(v\in V\)</span>可以写成 <span class="math inline">\(v = x + cz\,(x\inz^\perp,c\in\mathbb{R})\)</span> 的形式。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义4.4</span>.</span><span class="statement-spah"> </span>定义 <span class="math inline">\(\mathcal{Q}=\{v\in V\mid (v,v)\leq 0\}\)</span>是所有非 space-like 的向量组成的集合。</p></div><p><span class="math inline">\(\mathcal{Q}\)</span> 包含上、下两个分支<span class="math inline">\(\mathcal{Q}_+,\,\mathcal{Q}_-\)</span>，它们分别由<span class="math inline">\(\mathcal{Q}\)</span> 中满足 <span class="math inline">\(c\geq0\)</span> 和 <span class="math inline">\(c\leq0\)</span> 的点组成。<span class="math inline">\(\mathcal{Q}_+=-\mathcal{Q}_-\)</span> 并且 <span class="math inline">\(\mathcal{Q}_+\cap\mathcal{Q}_-=\{0\}\)</span>。</p><p><img src="/images/coxeter/hyperboloid.svg" class="fig" width="350"></p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义4.5</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(u,v\in\mathcal{Q}\)</span> 是两个非零向量，用记号<span class="math inline">\(u\sim v\)</span> 表示 <span class="math inline">\(u,v\)</span> 属于同一个分支，即同时属于 <span class="math inline">\(\mathcal{Q}_+\)</span> 或者 <span class="math inline">\(\mathcal{Q}_-\)</span>；用 <span class="math inline">\(u\not\sim v\)</span> 表示它们属于不同的分支。</p></div><div id="connected-component-dot" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.6</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(u,v\in \mathcal{Q}-\{0\}\)</span>。</p><ol type="1"><li>如果 <span class="math inline">\(u\sim v\)</span> 则 <span class="math inline">\((u,v)\leq0\)</span>。</li><li><span class="math inline">\((u,v)=0\)</span> 当且仅当 <span class="math inline">\(u,v\)</span> 是共线的 light-like 的向量。</li><li>如果 <span class="math inline">\(u,v\)</span> 中至少有一个是time-like 的向量，则 <span class="math inline">\(u\sim v\)</span>当且仅当 <span class="math inline">\((u,v)&lt;0\)</span>。</li><li>若 <span class="math inline">\(u\in\mathcal{Q}_+,\,v\in\mathcal{Q}_-\)</span>线性无关，则存在 <span class="math inline">\(a,b&gt;0\)</span> 使得<span class="math inline">\(au + bv\)</span> 是 space-like 的。</li></ol></div><p><strong>证明</strong>：</p><p>设 <span class="math inline">\(u=x+cz,\, v=y+dz\)</span>，其中 <span class="math inline">\(x,y\in z^\perp\)</span>。则 <span class="math inline">\((x,x)\leq c^2\)</span>，<span class="math inline">\((y,y)\leq d^2\)</span>。</p><ol type="1"><li>若 <span class="math inline">\(u\sim v\)</span>，则 <span class="math inline">\(c,d\)</span> 同正或者同负。由于 <span class="math inline">\(z^\bot\)</span> 是正定子空间，由 Cauchy-Schwartz不等式有 <span class="math display">\[(u,v)=(x,y)-cd\leq\sqrt{(x,x)\cdot (y,y)}-cd \leq\sqrt{c^2d^2}-cd=|cd|-cd=0.\]</span></li><li>若 <span class="math inline">\((u,v)=0\)</span> 且 <span class="math inline">\(u,v\)</span> 不共线，令 <span class="math inline">\(U=\mathrm{span}\{u,v\}\)</span>，则对 <span class="math inline">\(U\)</span> 中的任何向量 <span class="math inline">\(w=au+bv\,(a,b\in\mathbb{R})\)</span> 有 <span class="math display">\[(w,w)=a^2(u,u) + b^2(v,v)\leq0.\]</span> 即 <span class="math inline">\(U\)</span> 不包含 space-like 的向量。这与 <span class="math inline">\(\dim U=2\)</span> 和 Lorentzian 空间的 Sylvester符号是 <span class="math inline">\((n-1,1)\)</span> 矛盾，所以 <span class="math inline">\(u,v\)</span> 必须共线且都是 light-like的。反方向是显然的。</li><li><span class="math inline">\(\Rightarrow\)</span>：结合 1, 2两点即得。<span class="math inline">\(\Leftarrow\)</span>：如果 <span class="math inline">\(u\not\sim v\)</span> 则 <span class="math inline">\(u\sim -v\)</span>，由 1 有 <span class="math inline">\((u,-v)\leq0\)</span>，从而 <span class="math inline">\((u,v)\geq0\)</span>，矛盾。</li><li>由已知 <span class="math inline">\(c&gt;0,\,d&lt;0\)</span>。取<span class="math inline">\((-d)u + cv\in z^\perp\)</span> 即可。<span class="math inline">\(\blacksquare\)</span></li></ol><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义4.7</span>.</span><span class="statement-spah"> </span>记 <span class="math inline">\(\mathcal{N}_+\)</span> 和 <span class="math inline">\(\mathcal{N}_-\)</span> 为 <span class="math inline">\(\mathcal{N}=\{v\in V\mid (v,v)&lt;0\}\)</span>的两个连通分支。<span class="math inline">\(\mathcal{N}_+\)</span> 和<span class="math inline">\(\mathcal{N}_-\)</span> 分别是 <span class="math inline">\(\mathcal{Q}_+\)</span> 和 <span class="math inline">\(\mathcal{Q}_-\)</span> 的内部。</p></div><p>由于 Lorentzinian 内积是非退化的，所以我们可以把 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 等同起来，这样 <span class="math inline">\(\mathcal{C}\)</span> 和 <span class="math inline">\(\mathcal{C}^\ast\)</span> 都是 <span class="math inline">\(V\)</span> 的子集。我们将证明，这时 Tits 锥的闭包<span class="math inline">\(\overline{ \mathcal{C} }\)</span> 必然包含<span class="math inline">\(\mathcal{Q}_+,\,\mathcal{Q}_-\)</span>中的一个，同时与另一个的交仅为 <span class="math inline">\(\{0\}\)</span>。</p><p>首先根据 <a href="/coxeter-groups/tits-cone/#dual-cone-nonspace">前文结论</a>，<span class="math inline">\(\mathcal{C}^\ast\)</span>中任意两个向量之间的内积都非正，特别地对任何 <span class="math inline">\(v\in\mathcal{C}^\ast\)</span> 有 <span class="math inline">\((v,v)\leq0\)</span>，所以 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}\)</span>。</p><div id="dual-cone-trivial-intersection" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.8</span>.</span><span class="statement-spah"> </span>在 <span class="math inline">\(W\)</span> 不可约且双曲的情形，<span class="math inline">\(\mathcal{C}^\ast\cap\mathcal{Q}_+,\,\mathcal{C}^\ast\cap\mathcal{Q}_-\)</span> 中必有一个是<span class="math inline">\(\{0\}\)</span>。</p></div><p>这个结论应该是很直观的，如果 <span class="math inline">\(\mathcal{C}^\ast\)</span> 同时包含 <span class="math inline">\(\mathcal{Q}_+,\mathcal{Q}_-\)</span>中的非零向量的话，由于 <span class="math inline">\(\mathcal{C}^\ast\)</span>是点锥，这两个向量必然不共线，从而它们的非负线性组合可以给出 space-like的向量，这与 <span class="math inline">\(\mathcal{C}^\ast\)</span> 不含space-like 的向量矛盾。</p><p><strong>证明</strong>：若不然，设 <span class="math inline">\(u\in\mathcal{C}^\ast\cap\mathcal{Q}_+,\,v\in\mathcal{C}^\ast\cap\mathcal{Q}_-\)</span> 是非零向量，由于 <span class="math inline">\(\mathcal{C}^\ast\)</span> 是点锥，所以 <span class="math inline">\(u,v\)</span> 线性无关。根据 <a href="#connected-component-dot" title="命题 4.6">命题 4.6</a>，<span class="math inline">\(u,v\)</span> 的正线性组合中包含 space-like的向量，这与 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}\)</span>矛盾。<span class="math inline">\(\blacksquare\)</span></p><div id="dual-cone-belongs-branch" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论4.9</span>.</span><span class="statement-spah"></span>在双曲的情形，必有 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_+\)</span> 或者<span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_-\)</span>之一成立。</p></div><p><strong>证明</strong>：结合 <a href="#dual-cone-trivial-intersection" title="命题 4.8">命题 4.8</a> 和 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}=\mathcal{Q}_+\cup\mathcal{Q}_-\)</span>即得。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-closure" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论4.10</span>.</span><span class="statement-spah"></span>在双曲的情形，如果 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_+\)</span> 则<span class="math inline">\(\mathcal{C}\supset\mathcal{N}_-\)</span>。反之若 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_-\)</span> 则<span class="math inline">\(\mathcal{C}\supset\mathcal{N}_+\)</span>。</p></div><p><strong>证明</strong>：首先注意到对任何 <span class="math inline">\(x\in\mathcal{Q}_+\)</span> 和 <span class="math inline">\(y\in\mathcal{Q}_-\)</span> 有 <span class="math inline">\((x,y)\geq0\)</span>，所以 <span class="math inline">\(\mathcal{Q}_+\)</span> 和 <span class="math inline">\(\mathcal{Q}_-\)</span>互相包含在对方的对偶锥中。</p><p>由 <a href="#dual-cone-belongs-branch" title="推论 4.9">推论4.9</a>，不妨设 <span class="math inline">\(\mathcal{C}^\ast\subseteq\mathcal{Q}_+\)</span>，<a href="/coxeter-groups/tits-cone/#dual-dual-cone">取对偶以后有</a> <span class="math display">\[\overline{\mathcal{C}}=\mathcal{C}^{\ast\ast}\supseteq\mathcal{Q}_+^\ast\supseteq\mathcal{Q}_-.\]</span>由于凸集的内点等于其闭包的内点，所以 <span class="math display">\[\mathcal{C}^\circ=(\overline{ \mathcal{C}})^\circ\supset\mathcal{Q}_-^\circ=\mathcal{N}_-.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>以双曲群 <span class="math inline">\((7,3)\)</span>为例，红色的锥是 <span class="math inline">\(\overline{\mathcal{D}}\)</span>，Tits 锥 <span class="math inline">\(\mathcal{C}=\mathcal{N}_+\)</span>。取 <span class="math inline">\(\mathcal{C}\)</span> 与 hyperboloid的交给出双曲密铺。</p><p><img src="/images/coxeter/Tits_hyperbolic.png" class="fig" width="350"></p><p>注意这里光锥是理想边界，光锥上的点（除 <span class="math inline">\(0\)</span>以外）无法经过有限次反射变换到基本区域中，所以理想边界不属于 <span class="math inline">\(\mathcal{C}\)</span>。即 <span class="math inline">\(\mathcal{C}\subsetneqq\mathcal{Q}_+\)</span>。</p></div><h1 id="总结">总结</h1><p>下面的表格总结了有限、仿射、双曲三种情形 <span class="math inline">\(\mathcal{C}\)</span> 和 <span class="math inline">\(\mathcal{C}^\ast\)</span> 的结论：</p><table><tbody><tr><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\mathcal{C}\)</span></td><td style="text-align: center;"><span class="math inline">\(\mathcal{C}^\ast\)</span></td></tr><tr><td style="text-align: center;">有限</td><td style="text-align: center;"><span class="math inline">\(V^\ast\)</span></td><td style="text-align: center;"><span class="math inline">\(\{0\}\)</span></td></tr><tr><td style="text-align: center;">仿射</td><td style="text-align: center;"><span class="math inline">\(\{\delta&gt;0\}\cup\{0\}\)</span></td><td style="text-align: center;"><span class="math inline">\(\mathbb{R}_{\geq0}\delta\)</span></td></tr><tr><td style="text-align: center;">双曲</td><td style="text-align: center;">点锥，包含 <span class="math inline">\(\mathcal{N}_+,\mathcal{N}_-\)</span> 之一</td><td style="text-align: center;">点锥，属于 <span class="math inline">\(\mathcal{Q}_+,\mathcal{Q}_-\)</span> 之一</td></tr></tbody></table><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Howlett1997" class="csl-entry" role="listitem">Howlett, Robert B., Peter Rowley, and D. E. Taylor. 1997. <span>“OnOuter Automorphism Groups of Coxeter Groups.”</span> <em>ManuscriptaMathematica</em> 93: 499–513. <a href="https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/HowRowTay/1996-26.html">https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/HowRowTay/1996-26.html</a>.</div><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div><div id="ref-ratcliffe" class="csl-entry" role="listitem">Ratcliffe, John G. 2006. <em>Foundations of Hyperbolic Manifolds</em>.Second. Vol. 149. Graduate Texts in Mathematics. Springer.</div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Indra&#39;s pearls 中英双语对照</title>
      <link href="/indra/index.html"/>
      <url>/indra/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="扉页">扉页</h1><figure><img src="/images/indra/inner-cover.jpg" class="fig" width="400" alt="The ancient Buddhist dream of Indra’s Net 佛教古老的因陀罗网想象"><figcaption aria-hidden="true">The ancient Buddhist dream of Indra’s Net佛教古老的因陀罗网想象</figcaption></figure><div class="statement simple plain unnumbered"><p>In the heaven of the great god Indra is said to be a vast andshimmering net, finer than a spider’s web, stretching to the outermostreaches of space. Strung at the each intersection of its diaphanousthreads is a reflecting pearl. Since the net is infinite in extent, thepearls are infinite in number. In the glistening surface of each pearlare reflected all the other pearls, even those in the furthest cornersof the heavens. In each reflection, again are reflected all theinfinitely many other pearls, so that by this process, reflections ofreflections continue without end.</p></div><p>在印度教主神因陀罗的梵天之中，悬有一张璀璨绝伦的珍珠宝网，其纤细更胜蛛丝，绵延至宇宙的终极边际。这轻若云烟的罗网间，每一经纬交汇处皆垂缀明珠，因法界无尽，故明珠无量。每颗宝珠的莹润光华中，俱现十方世界一切珠影，纵使远在梵天极隅之珠亦纤毫毕现。更妙者，珠中所映万千珠影，复现重重无尽珠光，如镜镜相照，光光互摄，遂成华严玄境，映现大千世界之无穷法界。</p><p><strong>Cover picture</strong>: A mathematically generated pictureforetold in the Buddhist myth of Indra’s net? We sometimes call theseKlein Bubbles. The smallest ones are sehr klein.</p><div id="------------" class="statement sta_____ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">封面图片</span>.</span><span class="statement-spah"></span>这幅由数学生成的瑰丽图案，是否暗合了佛教因陀罗网的古老寓言？我们称之为”克莱因泡泡”，其中最小的泡泡在德语中恰被称作“sehr klein”　（“意为极小”）。</p></div><h1 id="前言">前言</h1><h2 id="这是什么类型的书">这是什么类型的书？</h2><div class="statement simple plain unnumbered"><p>This is a book about serious mathematics, but one which we hope willbe enjoyed by as wide an audience as possible. It is the story of ourcomputer aided explorations of a family of unusually symmetrical shapes,which arise when two spiral motions of a very special kind are allowedto interact. These shapes display intricate ‘fractal’ complexity onevery scale from very large to very small. Their visualisation formspart of a century-old dream conceived by the great German geometer FelixKlein. Sometimes the interaction of the two spiral motions is quiteregular and harmonious, sometimes it is total disorder and sometimes andthis is the most intriguing case - it has layer upon layer of structureteetering on the very brink of chaos.</p></div><p>这是一本关于严谨数学的著作，但我们希望尽可能多的读者都能从中获得乐趣。本书讲述了我们借助计算机，对一类具有非同寻常对称性的图形进行探索的过程。这些图形源自两种特殊螺旋运动的相互作用，展现出在从宏观到微观各个尺度上都极为复杂的“分形”结构。它们的可视化工作实现了德国伟大几何学家菲利克斯·克莱因一个百年前的数学梦想。有时候，这两种螺旋运动的相互作用是规律而和谐的；有时则是完全无序的，最引人入胜的是它们在秩序与混乱的临界状态下，层层结构交织，令人着迷。</p><div class="statement simple plain unnumbered"><p>As we progressed in our explorations, the pictures that our computerprograms produced were so striking that we wanted to tell our tale in amanner which could be appreciated beyond the narrow confines of a smallcircle of specialists. You can get a foretaste of their variety bytaking a look at the Road Map on the final page. Mathematicians oftenuse the word ‘beautiful’ in talking about their proofs and ideas, but inthis case our judgment has been confirmed by a number of unbiassed anddefinitely non-mathematical people. The visual beauty of the pictures isa veneer which covers a core of important and elegant mathematicalideas; it has been our aspiration to convey some of this inneraesthetics as well. There is no religion in our book but we were amazedat how our mathematical constructions echoed the ancient Buddhistmetaphor of Indra’s net, spontaneously creating reflections withinreflections, worlds without end.</p></div><p>随着我们探索的深入，计算机程序生成的几何图像展现出令人震撼的数学美感，这促使我们渴望以一种超越专业圈子，为更广泛读者所欣赏的方式来讲述这个故事。读者可以通过书末的“探索路线图”先睹为快，感受这些图像的多样风貌。</p><p>数学家在谈论他们的证明理念时常常使用“美”这个词，但这一次，不只是我们这样认为——许多并不具数学背景的外行人也认同这些图像具有非凡的美感。图像的视觉美只是一层表面，它所覆盖的内核是重要而优雅的数学思想；我们也希望能够传达这种深层次的美。</p><p>虽然本书并不涉及宗教，但我们惊讶地发现，我们的数学结构与佛教“因陀罗网”这一古老隐喻之间产生了意外的共鸣，层层反射自发地衍生出无尽的宇宙。</p><div class="statement simple plain unnumbered"><p>Most mathematics is accessible, as it were, only by crawling througha long tunnel in which you laboriously build up your vocabulary andskills as you abstract your understanding of the world. The mathematicsbehind our pictures, though, turned out not to need too much in the wayof preliminaries. So long as you can handle high school algebra withconfidence, we hope everything we say is understandable. Indeed giventime and patience, you should be able to make programs to create newpictures for yourself. And if not, then browsing through the figuresalone should give a sense of our journey. Our dream is that this bookwill reveal to our readers that mathematics is not alien and remote butjust a very human exploration of the patterns of the world, one whichthrives on play and surprise and beauty.</p></div><p>大多数数学的学习过程就像是在一条漫长的隧道中缓慢前行。在这个过程中，你不断积累词汇和技巧，一步步抽象出对世界的理解。然而，本书图像背后的数学却并不需要太多前置知识。只要你能自信地掌握高中代数，我们相信你能理解书中的所有内容。事实上，若有足够的时间和耐心，你应该能编写程序，自己创造新的图像。即使不这样，仅仅浏览这些图像，也能感受到我们这段旅程的魅力。我们的梦想是通过这本书让读者意识到，数学并非遥远而陌生的事物，而是人类探索世界规律的一种方式，是对世界中各种模式的追寻，它源于游戏、惊喜与美的激发。</p><h2 id="我们是如何开始写它的">我们是如何开始写它的？</h2><div id="david-m----s-story" class="statement sta_david_m__s_story plain unnumbered"><p><span class="statement-heading"><span class="statement-label">DavidM.’s story</span>.</span><span class="statement-spah"> </span>This bookhas been over twenty years in the writing. The project began when BenoitMandelbrot visited Harvard in 1979/80, in the midst of his explorationsof complex iteration - the ‘fractals’ known as Julia sets - and the nowfamous ‘Mandelbrot Set’. He had also looked at some nineteenth centuryfigures produced by infinite repetitions of simple reflections incircles, a prototypical example of which had fascinated Felix Klein.David W. and I pooled our expertise and began to develop these ideasfurther in the Kleinian context. The computer rapidly began producingpictures like the ones you will find throughout the book.</p></div><p><strong>戴维·芒福德（DavidMumford）的故事</strong>。本书的写作历时二十余年。项目的起点可以追溯到1979/80 年，当时贝努瓦·曼德布罗特（Benoit B.Mandelbrot）正在访问哈佛大学。彼时他正在探索复迭代系统——即后来被称为朱利亚集的“分形”以及如今广为人知的“曼德布洛特集合”。在此期间，曼德布罗特还研究了一些19世纪的图形，这些图形是通过圆反射的无限迭代所生成的，其中一个原型曾经让菲利克斯·克莱因（FelixKlein）深感着迷。大卫·怀特（DavidW.）和我结合了各自的专业知识，开始在克莱因群的框架下进一步发展这些想法。计算机很快就生成了类似本书中随处可见的那些图像。</p><div class="statement simple plain unnumbered"><p>What to do with the pictures? Two thoughts surfaced: the first wasthat they were unpublishable in the standard way. There were notheorems, only very suggestive pictures. They furnished convincingevidence for many conjectures and lures to further exploration, buttheorems were the coin of the realm and the conventions of that daydictated that journals only publish theorems. The second thought wasequally daunting: here was a piece of real mathematics that we couldexplain to our non-mathematical friends. This dangerous temptationprevailed, but it turned out to be much, much more difficult than weimagined.</p></div><p>这些图像该如何处理呢？我脑海中浮现出两个念头：首先，它们无法以传统方式发表。它们没有定理，只有一些极具启发性的图像。虽然它们为许多猜想提供了令人信服的证据，也为进一步探索指引了方向，但定理才是数学界通行的“硬通货”，而当时的惯例是，期刊只发表包含定理的文章。</p><p>第二个念头同样令人生畏：这是一段真正的数学内容，而我们竟然可以把它讲给非数学背景的朋友听。这种危险的诱惑最终占了上风，但我们很快发现，这远比我们想象的要困难得多。</p><div class="statement simple plain unnumbered"><p>We persevered off and on for a decade. One thing held us back:whenever we got together, it was so much more fun to produce morefigures than to write what Dave W. named in his computer TheBook. I havefond memories of traipsing through sub-zero degree gales to thebunker-like supercomputer in Minneapolis to push our calculations stillfurther. The one loyal believer in the project was our ever-faithful andpatient editor, David Tranah. However, things finally took off whenCaroline was recruited a bit more than a decade ago. It took a while tolearn how to write together, not to mention spanning the gulfs betweenour three warring operating systems. But our publisher, our families andour friends told us in the end that enough was enough.</p></div><p>我们断断续续坚持了十年。最大的障碍是，每次见面时，大家都觉得创作新图比写David W. 在他的电脑里命名为 “The Book”的那本书要有趣得多。我至今仍清晰记得，在明尼阿波利斯刺骨的寒风中，我们跋涉到堡垒般的超级计算机中心，只为将计算推向新的极限。始终对这个项目抱有信心的，是我们忠诚而耐心的编辑David Tranah。但真正的转折点，是十多年前 Caroline的加入。我们花了好一阵子才学会如何一起写作，更别提如何在三个“势不两立”的操作系统之间架起桥梁。不过最终，我们的出版商、家人和朋友都对我们说：够了，该收尾了。</p><div class="statement simple plain unnumbered"><p>You know that ‘word problem’ you hated the most in elementary school?The one about ditch diggers. Ben digs a ditch in 4 hours, Ned in 5 andTed in 6. How long do they take to dig it together? The textbook willtell you 1 hour, 37 minutes and 17 seconds. Baloney! We have uncoveredincontrovertable evidence that the right answer is hours. This is a deepprinciple involving not merely mathematics but sociology, psychology,and economics. We have a remarkable proof of this but even CambridgeUniversity Press’s generous margin allowance is too small to containit.</p></div><p>你还记得你小学时最讨厌的那道“应用题”吗？就是关于挖沟工人的那题。Ben 4小时能挖完一条沟，Ned 需要 5 小时，Ted 要 6小时。那他们一起挖，要多久才能挖完？课本会告诉你答案是 1 小时 37 分 17秒。胡说八道！我们已经通过实践得到了确凿的证据，真正的耗时应该是 4 + 5 +6 = 15小时。这背后蕴藏着一个深刻的原理，不仅仅涉及数学，还牵扯到社会学、心理学和经济学。我们有一个精彩绝伦的证明过程，但即使是剑桥大学出版社那慷慨的版面，也无法容纳它。</p><div id="david-w----s-story" class="statement sta_david_w__s_story plain unnumbered"><p><span class="statement-heading"><span class="statement-label">DavidW.’s story</span>.</span><span class="statement-spah"> </span>This is abook of a thousand beginnings and for a long time apparently no end. Forme, though, the first beginning was in 1979 when my friend and fellowgrad student at Harvard Mike Stillman told me about a problem that histeacher David Mumford had described to him: Take two very simpletransformations of the plane and apply all possible combinations ofthese transformations to a point in the plane. What does the resultingcollection of points look like?</p><p>Of course, the thing was not just to think about the shapes but toactually draw them with the computer. Mike knew I was interested indiscrete groups, and we shared a common interest in programming. Also,thanks to another friend and grad student Max Benson, I was alerted to avery nice C library for drawing on the classic Tektronix 4014 graphicsterminal. The only missing ingredient was happily filled by a curiousfeature of a Harvard education: I had passed my qualifying exams, andthen I had nothing else to do except write my doctoral thesis. I have avery distinct memory of feeling like I had a lot of time on my hands. Astime has passed, I have been astonished to discover that that was thelast time I felt that way.</p></div><p><strong>David W.的故事</strong>。这是一本拥有千百种开端、却似乎长久没有结局的书。对我来说，最初的开端是在1979 年，那时我在哈佛的朋友、也是研究生同学的 Mike Stillman跟我讲了一个问题，这是他的老师 David Mumford描述给他的：取平面上的两种非常简单的变换，将这些变换以各种可能的组合作用在平面上的某个点上。最终得到的这一系列点组成的集合，会是什么样子呢？</p><p>当然，事情不仅仅是思考这些图形的形状，而是要真正用计算机把它们画出来。Mike知道我对离散群感兴趣，我们在编程方面也有共同爱好。此外，多亏了另一位朋友兼研究生Max Benson 的提醒，我发现了一个非常棒的 C 语言库，可以在经典的 Tektronix4014图形终端上进行绘图。最后一个缺失的要素，恰好被哈佛教育中一个颇为特别的安排所填补：我已经通过了资格考试，接下来除了写博士论文之外，几乎没有其他事可做。我清楚地记得当时有一种“手头时间充裕”的感觉。随着时间流逝，我愈发惊讶地意识到，那竟然是我最后一次有那种感觉。</p><div class="statement simple plain unnumbered"><p>Anyway, as a complete lark, I tagged along with David M. while hebuilt a laboratory of computer programs to visualize Kleinian groups. Itwas a mathematical joy-ride. As it so happened, in the summer of 1980 ,there was a great opportunity to share the results of these computerexplorations with the world at the historic Bowdoin College conferencein which Thurston presented his revolutionary results inthree-dimensional topology and hyperbolic geometry. We arranged for aTektronix terminal to be set up in Maine, and together with anacoustically coupled modem at the blazing speed of 300 bits per seconddisplayed several limit sets. The reaction to the limit curves wigglingtheir way across the screen was very positive, and severalmathematicians there also undertook the construction of various computerprograms to study different aspects of Kleinian groups.</p><p>That left us with the task of writing an explanation of ouralgorithms and computations. However, at that point it was certainlypast time for me to complete my thesis. Around 1981, I had the very goodfortune of chatting with a new grad student at Harvard by the name ofCurt McMullen who had intimate knowledge of the computer systems at theThomas J. Watson Research Center of IBM, thanks to summer positionsthere. After roping Curt in, and at the invitation and encouragement ofBenoit Mandelbrot, Curt and David M. made a set of extremely highquality and beautiful black-and-white graphics of limit sets. I wouldlike to express my gratitude for Curt’s efforts of that time and hisfriendship over the years; he has had a deep influence on my own effortson the project.</p></div><p>总之，出于一种完全随性的心态，我跟着 David M.一起参与了一个项目，他正在构建一个用于可视化 Kleinian群的计算机程序实验室。这段经历堪称一次数学上的狂欢之旅。恰巧在 1980年夏天，出现了一个极好的机会，可以在一场意义非凡的会议上向世人展示这些计算机探索的成果——那就是在鲍登学院（BowdoinCollege）举办的历史性会议上，Thurston发表了他在三维拓扑和双曲几何方面的革命性成果。我们设法在缅因州安装了一台Tektronix 终端，并通过一台声耦合调制解调器，以惊人的 300比特每秒的速度，展示了多个极限集。当这些极限曲线在屏幕上蜿蜒浮现时，反响非常热烈。与会的几位数学家也纷纷投身其中，开始构建各类计算机程序，以研究Kleinian 群的不同方面。</p><p>接下来，我们需要撰写一份关于我们算法和计算过程的说明。然而，那时我确实已经到了必须完成论文的最后期限了。大约在1981 年，我非常幸运地结识了哈佛的一位新晋研究生 CurtMcMullen，他因为暑期曾在 IBM 的 Thomas J. Watson研究中心工作，对那里的计算机系统非常熟悉。在 Benoit Mandelbrot的邀请与鼓励下，我拉上了 Curt 一起参与项目，Curt 和 David M.一同制作了一组非常高质量且精美的极限集黑白图像。在此，我要感谢 Curt当时的辛勤付出，以及多年来给予我的友谊；他对我在这个项目上的努力产生了深远的影响。</p><div class="statement simple plain unnumbered"><p>Unfortunately, as we moved on to new and separate institutions, withvarying computing facilities, it was difficult to maintain the programsand energy to pursue this project. I would like to acknowledge theencouragement I received from many people including my friend BillGoldman while we were at M.I.T., Peter Tatian and James Russell, whoworked with me while they were undergraduates at M.I.T., Al Marden andthe staff of the Geometry Center, Charles Matthews, who worked with meat Oklahoma State, and many other mathematicians in the Kleinian groupscommunity. I would also like to thank Jim Cogdell and the SouthwesternBell Foundation for some financial support in the final stages. Theserious and final beginning of this book took place when Caroline agreedto contribute her own substantial research work in this area and herexpository gifts, and also step into the middle between the first andthird authors to at least moderate their tendency to keep programmingduring our sporadic meetings to find the next cool picture. At last, weactually wrote some text.</p></div><p>遗憾的是，随着我们各自前往新的、彼此独立的机构，计算设施也各不相同，这使得我们难以维持继续推进这个项目所需的程序和热情。我想对许多人表达感谢，他们给予了我鼓励，包括我在麻省理工时的朋友比尔·戈德曼，以及在本科期间与我一同工作的彼得·塔廷和詹姆斯·拉塞尔，还有几何中心的艾尔·马登和工作人员，曾与我在俄克拉荷马州立大学共事的查尔斯·马修斯，以及许多来自克莱因群研究领域的数学家。我还要感谢吉姆·科格德尔和西南贝尔基金会在本书最后阶段给予的一些资金支持。</p><p>这本书真正意义上的严肃开端，是在卡罗琳同意贡献她在该领域的重要研究成果和她出色的讲解才能之后。同时，她还在第一作者和第三作者之间起到了“缓冲”作用——至少能抑制他们在我们偶尔聚会时总想继续编程、寻找下一幅炫酷图像的冲动。最终，我们终于开始真正动笔写作了。</p><div class="statement simple plain unnumbered"><p>We have witnessed a revolution in computing and graphics during theyears of this project, and it has been difficult to keep pace. I wouldalso like to thank the community of programmers around the world forcreating such wonderful free software such as TEX, Gnu Emacs, X Windowsand Linux, without which it would have been impossible to bring thisproject to its current end.</p><p>During the years of this project, the most momentous endings andbeginnings of my life have happened, including the loss of my motherElizabeth, my father William, and my grandmother and family’s matriarchElizabeth, as well as the birth of my daughters Julie and Alexandra. Ioffer my part in these pictures and text in the hope of new beginningsfor those who share our enjoyment of the human mind’s beautiful capacityto puzzle through things. Programming these ideas is both vexing andimmensely fun. Every little twiddle brings something fascinating tothink about. But for now I’ll end.</p></div><p>在这个项目进行的这些年里，我们见证了计算和图形领域的一场革命，步伐之快令人难以跟上。我也想感谢全球程序员社区，他们创造了如此出色的免费软件，如TeX、Gnu Emacs、X Windows 和Linux。没有这些软件，这个项目根本无法走到今天这一步。</p><p>在这个项目进行的岁月里，我人生中最重大的结束与开始也相继发生了：我失去了母亲伊丽莎白、父亲威廉、祖母兼家族的女族长伊丽莎白，也迎来了我两个女儿朱莉和亚历山德拉的出生。我献上这些图画与文字，是希望在新的开始中，与同样热爱人类思维之美的人们分享这份乐趣。将这些思想转化为程序既令人头疼，又妙趣横生。每一个微小的调整，都会带来值得深思的趣味。不过，现在，我将告一段落。</p><div id="caroline---s-story" class="statement sta_caroline_s_story plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Caroline’s story</span>.</span><span class="statement-spah"> </span>I first saw some of David M. and DavidW.’s pictures in the mid-80s, purloined by my colleague David Epstein onone of his periodic visits to the Geometry Center in Minneapolis. I wasstruck by how pretty they were - they reminded me of the kind of lacework called tatting, which in another lifetime I would have liked tomake myself.</p><p>I presumed that everyone else understood all about the pictures, anddidn’t pay too much attention, until a little while later Linda Keen andI were looking round for a new project. I had spent many years workingon Fuchsian groups (see Chapter 6), and was wanting something whichwould lead me in to the Kleinian realm where at that time it was all go,developing Thurston’s wonderful new ideas about three-dimensionalnon-Euclidean geometry (see Chapter 12). By that time, I had somehow gothold of Dave W.’s preprint which described the explorations reported inChapter 9. I suggested to Linda that it might fit the bill.</p></div><p><strong>卡罗琳的故事</strong>。我第一次看到 David M. 和 David W.的一些图像是在 80 年代中期，那是我同事 David Epstein去明尼阿波利斯的几何中心定期访问时偷偷带回来的。我被这些图像的美丽深深吸引——它们让我想起一种叫做梭编（tatting）的蕾丝工艺，如果我换一种人生路径，或许也会喜欢亲手做这种东西。</p><p>我原以为其他人都已经完全理解这些图像的意义，因此起初也没有太在意。直到后来，我和Linda Keen 正在寻找一个新的研究课题。当时我已经在 Fuchs 群（见第 6章）上工作了很多年，想要转向 Kleinian群的研究领域——那时这个领域正如火如荼地发展，围绕 Thurston提出的关于三维非欧几何的奇妙新思想（见第 12章）。那时，我不知怎么搞到了一份 Dave W. 的预印本，里面描述了第 9章中提到的探索。我于是向 Linda 提议：或许我们可以从这里入手。</p><div class="statement simple plain unnumbered"><p>The first year was one of frustration, staring at pictures like theones in Chapter 9 without being able to get any real handle on what wasgoing on. Then one morning one of us woke up with an idea. We tried afew hand calculations and it seemed promising, so we asked Dave W. todraw us a picture of what we called the ‘real trace rays’. What cameback was a rudimentary version of the last picture in this book the onewe have called ‘The end of the rainbow’. For me it was more like ‘Thebeginning of the rainbow’, one of the defining moments of mymathematical life. Here we were, having made a total shot in the dark,having no idea what the rays could mean, but knowing they had absolutelyno right to be arranged in such a nice way. It was obvious we hadstumbled on something important, and from that moment, I was hooked.</p><p>For another year we struggled to fit the rays into the onemathematical straight-jacket we could think of, but it just didn’t quitework. One day, I ran into Curt McMullen and mentioned to him what wewere playing with. ‘Real trace’, he pondered, ‘That’s the convex hullboundary’.’ And with that clue, we were off. What Curt had told us wasthat to understand the two dimensional pictures we had to look inthreedimensional non-Euclidean space, real Thurston stuff, as you mightsay. Finally we were able to verify at least most of the two Dave’sconjectures theoretically.</p></div><p>第一年充满了挫败感，我们盯着第 9章那样的图看了许久，却始终无法真正理解其中的奥秘。直到某天早上，我们中的一个人突然灵光一现。我们做了一些手工计算，结果看起来很有希望，于是就请Dave W. 帮我们画一张图，描绘我们所说的“真实迹线射线”（real tracerays）。他给我们画回来的，是本书最后一幅图的雏形——我们称之为“彩虹的尽头”。对我而言，那更像是“彩虹的起点”，是我数学生涯中一个具有决定性意义的时刻。那时我们完全是摸着黑前进，根本不知道这些射线意味着什么，但我们清楚它们绝不可能如此巧妙地排列在一起。这太不可思议了，我们知道自己撞上了某个重要的东西。就在那一刻，我被彻底吸引住了。</p><p>接下来的一年里，我们努力尝试将这些射线纳入我们所能想到的某种数学框架中，但始终无法完美契合。某天，我碰巧遇到CurtMcMullen，并向他提起我们正在研究的东西。“真实迹线？”他若有所思地说，“那是凸包的边界。”有了这个提示，我们一下子豁然开朗。Curt告诉我们，若想理解这些二维图像，我们需要在三维的非欧几里得空间中去观察——说得直白点，就是研究真正的Thurston 理论。从那以后，我们终于能够在理论上验证 Dave提出的两个猜想中的大部分内容了。</p><div class="statement simple plain unnumbered"><p>When the 19th century mathematician Mary Somerville received a letterinviting her to make a translation, with commentary, of Laplace’s greatbook Mécanique Céléste, she was so surprised she almost returned theletter thinking there must have been some mistake. I suppose I wasn’tquite so surprised to get a letter from David M. asking me to help themwrite about their pictures, but it wasn’t quite an everyday occurrenceeither. Although I may perhaps write another book, I am unlikely everagain to have the chance to work on one which will be so much troubleand so much fun.</p><p>And don’t think this book is the end of the story. If you flickthrough you will see cartoons of a rather portly character gluing uppieces of rubber into things like doughnuts. In fact all our presenttale revolves about ‘one-holed doughnuts with a puncture’. For the lastfew years, I have been trying to understand what happens when thedoughnuts acquire more holes. The main thing I can report is - it’s alot more complicated! But the same wonderful structures, yet moreintricate and inviting, are out there waiting to be tamed.</p><p>I would like to thank the EPSRC for the generous support of a SeniorResearch Fellowship, which has recently allowed me to devote much timeto both the mathematical and literary aspects of this challengingproject.</p></div><p>当当 19世纪的数学家玛丽·萨默维尔收到一封信，邀请她翻译并评论拉普拉斯的巨著《天体力学》时，她惊讶得几乎要退回信件，认为一定是出了什么差错。我想，我收到大卫·M.写信邀请我帮忙为他们的图片撰文时，虽说没有那么惊讶，但这绝非日常小事。尽管我或许还会写另一本书，但恐怕再也不会有机会参与一本既如此费神又如此有趣的书了。</p><p>不过别以为这本书就讲完了全部的故事。如果你随手翻一翻，会看到一位略显圆润的角色，正在把橡胶片粘成类似甜甜圈的东西。事实上，我们整个故事都围绕着“打了一个洞的单孔甜甜圈”展开。过去几年里，我一直在试图理解当甜甜圈获得更多洞时会发生什么。我目前唯一能汇报的是——事情会复杂得多！但同样奇妙的结构，更加错综复杂且引人入胜，依然在那里，等着我们去驾驭。</p><p>我衷心感谢英国工程与自然科学研究委员会（EPSRC）的慷慨资助，这使我近期能够投入大量时间，专注于这个充满挑战的项目中的数学与文学两个方面。</p><h2 id="读者指南">读者指南</h2><div class="statement simple plain unnumbered"><p>This is a book which can be read on many levels. Like mostmathematics books, it builds up in sequence, but the best way to read itmay be skipping around, first skimming through to look at the pictures,then dipping in to the text to get the gist and finally a return tounderstand some of the details. We have tried to make the first part ofeach chapter relatively simple, giving the essence of the ideas andpostponing the technicalities until later. The more technical parts ofthe discussion have been relegated to the Notes and can be skipped asdesired. Material important for later reference is displayed inBoxes.</p><p>The first two chapters, on Euclidean symmetries and complex numbersrespectively, contain material which may be partially familiar to manyreaders. We have aimed to present it in a form suited to our viewpoint,at the same time introducing as clearly as possible and withcomplementary graphics the mathematical terminology which will be usedthroughout the book. Chapter 3 introduces the basic double spiral maps,called Möbius symmetries, on which all of our later constructions rest.From then on, we build up ever more complicated ways in which a pair ofMöbius maps can interact, generating more and more convoluted andintricate fractals, until in Chapters 10 and 11 we actually reach thefrontiers of current research. The entire development is summarised inthe Road Map on the final page.</p></div><p>这是一本可以从多个层次阅读的书。像大多数数学书一样，它是按顺序逐步展开的，但最佳的阅读方式可能是跳跃式阅读：先快速浏览一遍，看一下插图，然后跳入文本抓住大意，最后再回头理解一些细节。我们尽力让每一章的前半部分相对简单，传达思想的精髓，技术性的内容则推迟到后面再讲。更为技术性的部分被放在了注释中，可以根据需要跳过。对以后参考很重要的内容会以框框的形式展示。</p><p>前两章分别讨论了欧几里得对称性和复数，内容对于许多读者来说可能部分熟悉。我们旨在以符合我们视角的形式呈现这些内容，同时尽可能清晰地引入并配以补充图形，介绍本书中将使用的数学术语。第三章介绍了基本的双螺旋映射，称为莫比乌斯对称性，所有后续构建都基于此。从这一章开始，我们逐步构建出越来越复杂的莫比乌斯映射对相互作用的方式，生成越来越复杂、精巧的分形，直到第十章和第十一章，我们实际上达到了当前研究的前沿。整个发展过程在最后一页的路线图中进行了总结。</p><div class="statement simple plain unnumbered"><p>Words which have a precise mathematical meaning are in bold face thefirst time they appear. We have not always spelled out the intricaciesof the precise mathematical definition, but we have also tried not tosay anything which is mathematically incorrect. We have used a smallamount of our own terminology, but in so far as possible have stuck tostandard usage. Non-professional readers will therefore have to forgiveus such terms as quasifuchsian and modular group, while readers with amathematical training should be able to follow what we mean.</p><p>The book is written as a guide to actually coding the algorithmswhich we have used to generate the figures. A vast set of furtherexplorations is possible for those readers who invest the time toprogram. This is prime hacking country! Because we hope for a widevariety of readers with many different platforms at their disposal, wehave sketched each step in ‘pseudo-code’, the universal programmingpidgin.</p></div><p>具有精确数学含义的数学术语在首次出现时以粗体显示。我们并不总是详细阐述这些数学定义的复杂性，但我们也尽量避免说出任何数学上不正确的内容。我们使用了一些自己的术语，但尽可能遵循标准用法。因此，非专业读者可能需要原谅我们使用诸如准富克斯群（quasifuchsian）和模群（modulargroup）等术语，而具有数学背景的读者应该能够理解我们的意思。</p><p>本书的目的是作为编写实际算法的指南，这些算法用于生成我们所展示的图形。对于那些愿意投入时间编程的读者来说，仍有大量的进一步探索空间。这是编程爱好者的天堂！由于我们希望能吸引各种平台上的读者，我们已经以“伪代码”形式勾画了每个步骤，这是编程的通用语言。</p><div class="statement simple plain unnumbered"><p>Inevitably we have suppressed a good deal of relevant mathematics andanyone wishing to pursue these ideas seriously will doubtless sooner orlater have to resort to more technical works. Actually there are no veryaccessible books about Kleinian group limit sets’, but there are plentyof texts which discuss the basics of symmetry and complex numbers. Somecomplex analysis books touch on Möbius maps and there is more in modernbooks on two-dimensional hyperbolic geometry. In the later part of thebook we have cited a rather random collection of recent research paperswhich have important bearing on our work. These are absolutely not meantto be exhaustive, but should serve to help professional readers findtheir way round the literature.</p><p>Finally our Projects need some comment. They can be ignored: wearen’t going to grade them or supply answers! Rather, we intend them as‘explorations’ to tempt you if you enjoy the material and want to takeit further. Some are fairly straightforward extensions or elucidationsof material in the text and some involve open-ended questions for whichthere is no definite answer. A few are definitely research problems.Others again explain details which are needed for full understanding orverification of the more technical points in our story. We have to leaveit to the reader to pick and choose which ones suit their taste andmathematical experience.</p></div><p>不可避免地，我们压缩了许多相关的数学内容，任何希望深入研究这些想法的人无疑迟早都需要参考更专业的著作。实际上，关于克莱因群极限集的可读性强的书籍并不多，但有许多书籍讨论了对称性和复数的基础知识。一些复分析的书籍会涉及莫比乌斯变换，现代的二维双曲几何书籍则有更多的相关内容。在本书后部分，我们列举了一些与我们工作密切相关的近期研究论文。这些引用绝不是详尽无遗的，但应该能够帮助专业读者在文献中找到方向。</p><p>最后，我们的项目需要做些说明。它们可以被忽略：我们不会给它们打分或提供答案！相反，我们将其作为“探索”，如果你喜欢这些内容并希望深入了解，它们将激发你的兴趣。有些项目是对书中材料的简单扩展或阐述，有些则是开放性问题，没有确切答案。少数是明确的研究问题。还有一些则是解释书中更技术性内容的细节，帮助理解或验证我们的故事中的关键点。我们只能留给读者自己选择，决定哪些项目适合他们的兴趣和数学经验。</p><h2 id="致谢">致谢</h2><div class="statement simple plain unnumbered"><p>We thank especially our cartoonist Larry Gonick for his uncannyability to translate a complicated three-dimensional manipulation intoan immediately evident cartoon. For historical background we areindebted to the St.&nbsp;Andrews History of Maths web site, tempered withmany erudite details and healthy doses of scholarly scepticism from ourfriends David Fowler and Paddy Patterson. (All remaining errors, are, ofcourse, our own.) Klein’s own book Entwicklung der Mathematikim 19.Jahrhundert has also been an important source. We have read the Hua-YenSutra in the translation The Flower Ornament Scripture by Thomas Cleary,Shambhala Publications, 1993, and quotations are reproduced here withthanks. We should like to thank the Mathematics Departments of Brown,Oklahoma State, Warwick, Harvard and Minnesota for their hospitality. Weshould like to thank the NSF through its grant to the Geometry Centerand EPSRC from their Public Understanding of Science budget forfinancial support. Finally we should like to thank our publisher DavidTranah of Cambridge University Press, without whose constant proddingand encouragement this book would almost certainly never have seen thelight of day.</p></div><p>我们特别感谢我们的漫画家 LarryGonick，他拥有将复杂的三维操作转化为一目了然的漫画的神奇能力。关于历史背景，我们要感谢圣安德鲁斯数学历史网站，并且我们特别感谢我们的朋友David Fowler 和 Paddy Patterson提供了许多博学的细节和健康的学术怀疑态度。（当然，所有剩余的错误都是我们自己的。）Klein的《19世纪数学发展》一书也是一个重要的参考来源。我们阅读了 Thomas Cleary翻译的《华严经》，由 Shambhala出版社于1993年出版，引用的内容在此谨表示感谢。我们还要感谢布朗大学、俄克拉荷马州立大学、沃里克大学、哈佛大学和明尼苏达大学的数学系对我们的热情接待。感谢美国国家科学基金会（NSF）通过其对几何中心的资助，以及英国工程与物理学研究委员会（EPSRC）从其公共科学传播预算中提供的资助。最后，我们要感谢剑桥大学出版社的出版人David Tranah，如果没有他不断的督促和鼓励，这本书几乎不可能问世。</p><h1 id="the-glowing-gasket">7 The glowing gasket</h1><figure id="fig-7.1"><img src="/images/indra/fig-7.1.jpg" class="fig" width="600" alt="Figure 7.1. The Apollonian gasket. The lacy web in the two pictures is the same: on the left, it is drawn in the complex plane and, on the right, on the sphere. As you might imagine, many people have tried calculating the Hausdorff dimension of the gasket. Curt McMullen has found the most accurate value, which is estimated as about 1.305688. 图 7.1. 阿波罗尼奥斯垫片。两幅图中的蕾丝网状结构是相同的：左边是在复平面上绘制的，右边是在球面上绘制的。你可能已经猜到，许多人都曾尝试计算该垫片的豪斯多夫维数。柯特·麦克马伦（Curt McMullen）给出了目前最精确的估计值，约为 1.305688。"><figcaption aria-hidden="true">Figure 7.1. The Apollonian gasket. Thelacy web in the two pictures is the same: on the left, it is drawn inthe complex plane and, on the right, on the sphere. As you mightimagine, many people have tried calculating the Hausdorff dimension ofthe gasket. Curt McMullen has found the most accurate value, which isestimated as about 1.305688.<br>图 7.1.阿波罗尼奥斯垫片。两幅图中的蕾丝网状结构是相同的：左边是在复平面上绘制的，右边是在球面上绘制的。你可能已经猜到，许多人都曾尝试计算该垫片的豪斯多夫维数。柯特·麦克马伦（CurtMcMullen）给出了目前最精确的估计值，约为 1.305688。</figcaption></figure><div class="statement simple plain unnumbered"><p>The lacy web in Figure 7.1 is called the Apollonian gasket. Usually,it is constructed by a simple geometric procedure, dating back to thosemost famous of geometers, the ancient Greeks. We shall start byexplaining the traditional construction, but as we shall discloseshortly, the gasket also represents another remarkable way in which theSchottky dust can congeal. The pictures you see here were actually alldrawn using a refinement of the DFS algorithm for tangent Schottkycircles.</p></div><p><a href="#fig-7.1">图 7.1</a>中的镂空结构被称为阿波罗尼奥斯分形。其构造基于一种简单的几何方法，可追溯至古希腊著名的几何学家。我们将首先解释传统的构造方法，但稍后也会揭示，这个分形结构同样展现了肖特基尘埃凝聚的另一种独特形式。此处所见的所有图像，实际上都是通过一种改进版的DFS 算法绘制的，该算法专门用于处理相切肖特基圆的情况。</p><div class="statement simple plain unnumbered"><p>The starting point of the traditional construction is a chain ofthree non-overlapping disks, each tangent to both of the others. Aregion between three tangent disks is a ‘triangle’ with circular arcsfor sides. This shape is often called an ideal triangle: the sides aretangent at each of the three vertices so the angle between them is zerodegrees.</p><p>The gasket is activated by the fact that in the middle of each idealtriangle there is always a unique ‘inscribed disk’ or incircle, tangentto the three outer circles. It is really better to think of the gasketas a construction on the sphere. Insides and outsides don’t matter anymore, so we may as well start with any three mutually tangent circles.You can see lots of disks and incircles in Figure 7.2.</p></div><p>传统构造的起点是三个互不重叠且两两相切的圆盘，呈链状排列。三个相切圆盘围成的区域，形状类似一个以圆弧为边的“三角形”。这种几何图形通常被称为理想三角形：由于其三条边在顶点处相切，因此每个顶点的夹角恰为零度。阿波罗尼奥斯垫片的构造正是由这一特性触发的：每个理想三角形的中心都有且仅有一个内切圆，它同时与这三个外接圆相切。更直观的理解方式是将这一构造置于球面上来考察。这样一来，“内外”之分已无意义，因此我们大可从任意三个两两相切的圆开始。在<a href="#fig-7.2">图 7.2</a>中，你会看到许多这样的圆盘及其内切圆结构。</p><figure id="fig-7.2"><img src="/images/indra/fig-7.2.jpg" class="fig" width="600" alt="Figure 7.2. Activating the gasket. On the top left, the three largest disks which activate the gasket are shown in blue. One of the three disks appears as the outer blue region which frames the picture, because it contains the point \infty, the North Pole on the Riemann sphere. On the top right, two of the disks are tangent at \infty, so that you see them in the picture as parallel blue strips. Removing the blue circles leaves two red ideal triangles. Inside each ideal triangle is an incircle, coloured yellow. Below, we see more levels of incircles. 图 7.2. 激活垫片。左上图中，标出的三个最大圆盘以蓝色呈现，正是它们激活了垫片。其中一个圆盘显示为环绕整幅图像的外部蓝色区域，这是因为它包含了点 \infty，即黎曼球面上的北极点。右上图中，其中两个圆盘在 \infty 处相切，因此在图中呈现为两条平行的蓝色带状区域。当我们移除这些蓝色圆盘后，图中便显现出两个红色的理想三角形。每个理想三角形内部都嵌有一个黄色内切圆。下方图示进一步展示了更深层次的内切圆结构。"><figcaption aria-hidden="true">Figure 7.2. Activating the gasket. On thetop left, the three largest disks which activate the gasket are shown inblue. One of the three disks appears as the outer blue region whichframes the picture, because it contains the point <span class="math inline">\(\infty\)</span>, the North Pole on the Riemannsphere. On the top right, two of the disks are tangent at <span class="math inline">\(\infty\)</span>, so that you see them in thepicture as parallel blue strips. Removing the blue circles leaves twored ideal triangles. Inside each ideal triangle is an incircle, colouredyellow. Below, we see more levels of incircles.<br>图 7.2.激活垫片。左上图中，标出的三个最大圆盘以蓝色呈现，正是它们激活了垫片。其中一个圆盘显示为环绕整幅图像的外部蓝色区域，这是因为它包含了点<span class="math inline">\(\infty\)</span>，即黎曼球面上的北极点。右上图中，其中两个圆盘在<span class="math inline">\(\infty\)</span>处相切，因此在图中呈现为两条平行的蓝色带状区域。当我们移除这些蓝色圆盘后，图中便显现出两个红色的理想三角形。每个理想三角形内部都嵌有一个黄色内切圆。下方图示进一步展示了更深层次的内切圆结构。</figcaption></figure><div class="statement simple plain unnumbered"><p>In the figure, we show two initial configurations of three tangentblue disks. When you take out the three blue disks you are left with twored ideal triangles. Each red ideal triangle has a yellow incircle. Seehow each yellow incircle divides the red triangle into three moretriangles.</p></div><p>在图中，我们展示了三个相切的蓝色圆盘的两种初始排布。当你移除这三个蓝色圆盘后，会留下两个红色的理想三角形。每个红色理想三角形各含一个黄色内切圆。仔细观察这些黄色的内切圆如何将红色三角形进一步分割为三个子三角形。</p><div class="statement simple plain unnumbered"><p>For repetitive people (a necessary quality in this subject, you mightsay), it is only natural to draw the incircles in these new triangles,resulting, of course, in even more triangles of the same kind. Thebottom frame shows this subdivision carried out twice more, with greenand then even smaller purple disks. In The Cat in the Hat Comes Back,’the cat takes off his hat to reveal Little Cat, who then removes his hatand releases Little Cat, who then uncovers Little Cat, and so on. Nowimagine there are not one but three new cats inside each cat’s hat. Thatgives a good impression of the explosive proliferation of these tinyideal triangles. Carry out this process to infinity, and Voom, theApollonian Gasket appears.</p></div><p>对于那些乐此不疲的人（或许正是研究这一主题的必备素质），在新三角形中继续绘制内切圆简直是顺理成章的事。这当然会催生出更多相似的三角形。下方的子图展示了这种细分过程再重复两次的结果——先是绿色圆盘，接着是更小的紫色圆盘，密密层层地堆叠起来。这让我想起《戴帽子的猫又来了》中的情节——大猫摘下帽子，露出一只小猫；小猫摘下自己的帽子，又冒出一只更小的小猫；接着更小的小猫再摘帽……如此反复，仿佛无穷无尽。现在，试着想象每顶帽子里不是藏着一只，而是三只小猫，那你就能体会这些微型理想三角形是如何爆炸式增长的了。让这一过程无限延续，砰——阿波罗尼奥斯分形便瞬间跃然眼前。</p><div class="statement simple plain unnumbered"><p>The Apollonian gasket is indeed very pretty, but the reason forintroducing it here is that, remarkably, it is also the limit set of aSchottky group made by pairing tangent circles. Exactly the sameintricate mathematical object can created by completely different means!You can see better how this works in the beautiful glowing version inFigure 7.3. The solid red circles in this picture are the initialSchottky circles in a very special configuration which we will look atclosely in the next section. The glowing yellow limit set can berecognized as the same as the Apollonian gasket of Figure 7.1. Thepicture was made by pairing four tangent circles arranged in theconfiguration shown in Figure 7.4. The four circles are tangent not onlyin a chain; there are also extra tangencies between <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span>, and between <span class="math inline">\(C_b\)</span> and <span class="math inline">\(C_B\)</span>.</p></div><p>阿波罗尼奥斯分形确实非常美丽，但我们在此介绍它的原因是：令人惊讶的是，它也是由切圆配对生成的肖特基群的极限集。这一精妙的数学对象，竟然能通过完全不同的方式构造出来！您可以通过<a href="#fig-7.3">图 7.3</a>中的荧光渲染图，看到这一过程是如何运作的。图中的实心红色圆环是以一种特殊配置排列的初始肖特基圆（具体分析请参见下一节），其荧黄色的极限集与<a href="#fig-7.1">图 7.1</a>中的阿波罗尼奥斯垫片完全一致。这幅图像是通过配对四个相切圆生成的，排列方式如<a href="#fig-7.4">图 7.4</a>所示：这些圆不仅形成了链式相切的关系，而且在 <span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span>、<span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 之间还存在额外的切点。</p><figure id="fig-7.3"><img src="/images/indra/fig-7.3.jpg" width="600" alt="Figure 7.3. (Overleaf.) The glowing gasket. This picture was created by applying the generating transformations a,A,b,B to the chain of four solid red disks bounding the black ideal triangles. At higher levels, the image circles tone from red to orange to yellow, through green to blue, finally cycling back to red. Don’t let the picture fool you - the red circles are not the circles which activate the gasket in the traditional construction. The ones which appear in the traditional construction are the ‘dual’ circles with the yellow glow. 图 7.3. 荧光垫片。此图像是通过对围绕黑色理想三角形的四个实心红色圆盘施加生成变换 a,A,b,B 而生成的。在更高的层级中，图像中的圆环色调从红色渐变为橙色、黄色，接着是绿色，再到蓝色，最终循环回红色。需要特别注意的是：图中的红色圆并非传统阿波罗尼奥斯构造中激活垫片的圆——在传统构造中，起激活作用的是发出黄色光辉的“对偶圆”。"><figcaption aria-hidden="true">Figure 7.3. (Overleaf.) The glowinggasket. This picture was created by applying the generatingtransformations <span class="math inline">\(a,A,b,B\)</span> to thechain of four solid red disks bounding the black ideal triangles. Athigher levels, the image circles tone from red to orange to yellow,through green to blue, finally cycling back to red. Don’t let thepicture fool you - the red circles are not the circles which activatethe gasket in the traditional construction. The ones which appear in thetraditional construction are the ‘dual’ circles with the yellowglow.<br>图 7.3.荧光垫片。此图像是通过对围绕黑色理想三角形的四个实心红色圆盘施加生成变换<span class="math inline">\(a,A,b,B\)</span>而生成的。在更高的层级中，图像中的圆环色调从红色渐变为橙色、黄色，接着是绿色，再到蓝色，最终循环回红色。需要特别注意的是：图中的红色圆并非传统阿波罗尼奥斯构造中激活垫片的圆——在传统构造中，起激活作用的是发出黄色光辉的“对偶圆”。</figcaption></figure><div class="statement simple plain unnumbered"><p>As you iterate the pairing transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, the extra tangency proliferates, withthe effect that inside each disk <span class="math inline">\(D\)</span>you see three further Schottky disks tangent to <span class="math inline">\(D\)</span> and each of the other two. In ourversion, the circles have been coloured depending on their level,starting with red at the first or lowest level, gradually changing toyellow, green and then blue. The small yellow and blue circles pile up,highlighting the limit set with a mysterious glow.</p></div><p>当你不断迭代配对变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>时，额外的切点会迅速增殖。几何上，这表现为：在每个圆盘 <span class="math inline">\(D\)</span>内部，都会涌现出三个新的肖特基子圆盘——它们不仅与 <span class="math inline">\(D\)</span>相切，而且两两之间也彼此相切。在我们的可视化方案中，圆盘根据迭代的层级依次着色——最底层从红色起步，逐步过渡到黄色、绿色、蓝色。随着黄色和蓝色的小圆盘层层堆叠，极限集被一圈神秘的光晕所笼罩，愈发清晰而引人入胜。</p><div class="statement simple plain unnumbered"><p>In this chapter, we shall be exploring various features of thegasket. Notwithstanding the extra tangency, it turns out that each limitpoint is still associated to exactly one or two infinite words in thegenerators <span class="math inline">\(a,b,A\)</span> and <span class="math inline">\(B\)</span>. You will be able to make your ownversion of the glowing gasket by running our DFS algorithm for the groupgenerated by the transformations <span class="math inline">\(a\)</span>and <span class="math inline">\(b\)</span>. The algorithm draws thiscomplicated lacework as a continuous curve, which is hard to imagineuntil you see it in progress on a computer screen. The curve snakes itsway through the gasket, apparently leaving one region for quite a whileuntil finally weaving its way back. Animation is the true reward ofsuccessfully implementing the program we have been learning tobuild.</p></div><p>在本章中，我们将深入探索垫片结构的各种特性。尽管存在额外的相切关系，但事实证明，每个极限点仍然对应于生成元<span class="math inline">\(a, b, A, B\)</span>所构成的一至两个无限字。通过运行我们为变换群 <span class="math inline">\(\langle a,b\rangle\)</span>特别设计的深度优先搜索（DFS）算法，你将能够制作出自己专属的发光垫片。该算法将这种复杂的镂空结构绘制成一条连续的曲线——这种奇妙的生成过程，唯有在计算机屏幕上亲眼目睹，方能真正感受到其变幻莫测之美。曲线如同灵蛇般在gasket中蜿蜒穿梭，仿佛要彻底离开某个区域，却又在某个时刻悄然折返。成功实现我们精心构建的程序后，最令人欣喜的收获正是这些跃然屏上的动态演绎。</p><div id="apollonius--circa-250-200-bc" class="statement sta_apollonius__circa_250_200_bc plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Apollonius, circa 250-200 BC</span>.</span><span class="statement-spah"> </span><br></p><p>Apollonius, known to his contemporaries as the Great Geometer, livedin Perga, now part of Turkey. One of the giants of Greek mathematics, hewas famed for his 8 volume treatise Conics which studied ellipses,hyperbolas and parabolas as sections of a cone by a plane at variousangles. His writings swiftly became standard texts in the ancient world.Many are now lost and we know them only through mention in othercommentaries, among them works on regular solids, irrational numbers,and approximations to <span class="math inline">\(\pi\)</span>. Ptolemycredits Apollonius with the theory of epicycles on which he based histheory of planetary motion.</p><p>One of Apollonius’ lost works is a book called Tangencies, reportedto provide methods of constructing circles tangent to various othercombinations of lines and circles, for example finding a circle tangentto two given lines and another circle. You can think of the problem offinding the incircle of an ideal triangle in this way. The mostdifficult problem, that of constructing the two circles tangent to threeother given disjoint circles, was probably not solved in ancient times,however Sir Isaac Newton wrote down a proof. According to Pappus,Tangencies gave a formula for the radius of the incircle to an idealtriangle in terms of the radii of the circles which bound its threesides. Be that as it may, exactly such a formula was described byDescartes in 1643, and a version was known in eighteenth century Japan.In fact this formula seems to have been rediscovered many times, mostrecently by Sir Frederick Soddy, in whose honour the incircles aresometimes known as Soddy circles. Awarded the Nobel prize in 1921, forthe discovery of isotopes, Soddy had a natural interest in how to packspherical atoms of differing size.</p><p>Soddy was so taken with the formula that he published it in theunusual form of a poem, which appeared in the journal Nature in 1936.The central part is contained in the middle verse quoted at the head ofthis chapter. For those who feel more comfortable with symbols, supposethe radii of the chain of three circles are <span class="math inline">\(a,b\)</span> and <span class="math inline">\(c\)</span>, and that the incircle has radius <span class="math inline">\(d\)</span>. Soddy’s formula is: <span class="math display">\[\left(\frac{1}{a}+\frac{1}{b}+\frac{1}{c}+\frac{1}{d}\right)^2=2\left(\frac{1}{a^2}+\frac{1}{b^2}+\frac{1}{c^2}+\frac{1}{d^2}\right).\]</span></p><p>阿波罗尼奥斯，被同时代人誉为伟大的几何学家，生活在佩尔加，即现今土耳其的一部分。作为希腊数学的巨擘之一，他因八卷本专著《圆锥曲线论》而闻名，该著作研究了椭圆、双曲线和抛物线作为平面以不同角度切割圆锥所得截面的性质。其著作迅速成为古代世界的标准教材。许多作品现已遗失，我们仅通过其他评论中的提及了解它们，其中包括关于正多面体、无理数及对<span class="math inline">\(\pi\)</span>的近似值的研究。托勒密将本轮理论归功于阿波罗尼奥斯，这一理论成为他行星运动学说的基础。</p><p>阿波罗尼奥斯遗失的著作之一名为《切触》，据记载，该书提供了构建与各种直线和圆组合相切的圆的方法，例如寻找与两条给定直线及另一个圆相切的圆。你可以将寻找理想三角形内切圆的问题视为此类问题。最难的难题，即构建与三个给定且互不相交的圆相切的两个圆，在古代可能并未解决，然而艾萨克·牛顿爵士记录了一个证明。根据帕普斯的说法，《切触》给出了一个公式，用于计算理想三角形内切圆的半径，该半径与限定其三条边的圆的半径有关。尽管如此，笛卡尔在1643 年确实描述了这样一个公式，且在 18世纪的日本也已知晓其版本。实际上，这个公式似乎被多次重新发现，最近一次是由弗雷德里克·索迪爵士完成的。为了纪念他，内切圆有时被称为索迪圆。索迪因发现同位素而于1921 年获得诺贝尔奖，他对如何排列不同大小的球形原子自然产生了兴趣。</p><p>索迪对这个公式深深着迷，以至于他以一首诗的形式将其发表，这首诗出现在1936年的《自然》杂志上。其核心部分包含在本章开头引用的中间诗句中。对于那些更偏好使用符号的读者，假设三个连锁圆的半径分别为<span class="math inline">\(a, b\)</span> 和 <span class="math inline">\(c\)</span>，内切圆的半径为 <span class="math inline">\(d\)</span>。索迪的公式为：</p><p><span class="math display">\[\left(\frac{1}{a}+\frac{1}{b}+\frac{1}{c}+\frac{1}{d}\right)^2=2\left(\frac{1}{a^2}+\frac{1}{b^2}+\frac{1}{c^2}+\frac{1}{d^2}\right).\]</span></p></div><h2 id="generating-the-gasket-生成垫片">Generating the gasket生成垫片</h2><div class="statement simple plain unnumbered"><p>The configuration of tangent circles which produced the gasket isshown in the right frame of Figure 7.4. The picture has been arranged sothat <span class="math inline">\(C_a\)</span> goes through <span class="math inline">\(\infty\)</span>, hence it appears in the figure asa straight line. In addition, <span class="math inline">\(C_A\)</span>and <span class="math inline">\(C_a\)</span> are tangent at 0 and <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> are tangent at <span class="math inline">\(-i\)</span>. You can see how this picture is madeby creating extra tangencies among a kissing chain of four circles bycomparing with the nearby arrangement of four circles in the left handframe.</p></div><p>生成垫片的相切圆配置如 <a href="#fig-7.4">图 7.4</a>右图所示。图中特意令圆 <span class="math inline">\(C_a\)</span> 经过<span class="math inline">\(\infty\)</span>，从而它在图中呈现为一条直线。此外，我们令圆<span class="math inline">\(C_A\)</span> 与 <span class="math inline">\(C_a\)</span> 在原点 0 处相切，圆 <span class="math inline">\(C_B\)</span> 与 <span class="math inline">\(C_b\)</span> 在<span class="math inline">\(-i\)</span>处相切。通过与左边图中四个圆的排列进行对比，可以清晰观察到右图通过在四圆相切链中引入额外切点形成的特殊结构。</p><figure id="fig-7.4"><img src="/images/indra/fig-7.4.jpg" class="fig" width="600" alt="Figure 7.4. The right frame shows the starting configuration of tangent Schottky circles which produces the glowing gasket. The red circles C_a and C_A are paired by the transformation a and the blue circles C_B and C_b by b. Using notation from the last chapter, the tangency points P,Q,R and S are at 1,-1,-0.2-0.4i and 0.2-0.4i respectively. On the left is a nearby Schottky configuration of circles which are not quite tangent and a and b are loxodromic. This is similar to the configuration shown in frame (vi) of Figure 6.10. The centre frame is an intermediate stage where a is parabolic but b is not. 图 7.4. 右图展示了生成发光垫片的相切 Schottky 圆的初始配置。红色圆 C_a 与 C_A 通过变换 a 配对，蓝色圆 C_B 与 C_b 通过变换 b 配对。根据前一章的记号，切点 P, Q, R, S 分别位于坐标 1, -1, -0.2-0.4i 和 0.2-0.4i 处。左图展示了一个相似的 Schottky 圆配置，其中圆未完全相切，且变换 a 和 b 均为斜航的。该配置与 图 6.10 (vi) 中的结构相似。中间图呈现了过渡状态，其中变换 a 是抛物线型的，而 b 不是。"><figcaption aria-hidden="true">Figure 7.4. The right frame shows thestarting configuration of tangent Schottky circles which produces theglowing gasket. The red circles <span class="math inline">\(C_a\)</span>and <span class="math inline">\(C_A\)</span> are paired by thetransformation <span class="math inline">\(a\)</span> and the bluecircles <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> by <span class="math inline">\(b\)</span>. Using notation from the last chapter,the tangency points <span class="math inline">\(P,Q,R\)</span> and <span class="math inline">\(S\)</span> are at <span class="math inline">\(1,-1,-0.2-0.4i\)</span> and <span class="math inline">\(0.2-0.4i\)</span> respectively. On the left is anearby Schottky configuration of circles which are not quite tangent and<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are loxodromic. This is similar to theconfiguration shown in frame (vi) of Figure 6.10. The centre frame is anintermediate stage where <span class="math inline">\(a\)</span> isparabolic but <span class="math inline">\(b\)</span> is not.<br>图 7.4. 右图展示了生成发光垫片的相切 Schottky 圆的初始配置。红色圆 <span class="math inline">\(C_a\)</span> 与 <span class="math inline">\(C_A\)</span> 通过变换 <span class="math inline">\(a\)</span> 配对，蓝色圆 <span class="math inline">\(C_B\)</span> 与 <span class="math inline">\(C_b\)</span> 通过变换 <span class="math inline">\(b\)</span> 配对。根据前一章的记号，切点 <span class="math inline">\(P, Q, R, S\)</span> 分别位于坐标 <span class="math inline">\(1, -1, -0.2-0.4i\)</span> 和 <span class="math inline">\(0.2-0.4i\)</span> 处。左图展示了一个相似的Schottky 圆配置，其中圆未完全相切，且变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 均为斜航的。该配置与 <a href="#fig-6.10">图 6.10</a> (vi)中的结构相似。中间图呈现了过渡状态，其中变换 <span class="math inline">\(a\)</span> 是抛物线型的，而 <span class="math inline">\(b\)</span> 不是。</figcaption></figure><div class="statement simple plain unnumbered"><p>The generating matrices for the gasket are quite simple: <span class="math display">\[a=\begin{pmatrix}1&amp;0\\-2i&amp;1\end{pmatrix}\quad\text{and}\quadb=\begin{pmatrix}1-i&amp;1\\1&amp;1+i\end{pmatrix}.\]</span></p><p>We shall have more to say about how we arrived at these particularformulas later on. Note that <span class="math inline">\(\mathop{\mathrm{Tr}}{a}=\mathop{\mathrm{Tr}}{b}=2\)</span>,so <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are parabolic. Looking at thearrangement of Schottky circles in Figure 7.4, you see the fixed pointof <span class="math inline">\(a\)</span> is 0, the tangency point ofthe circles <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span>. In Figure 7.3, you can see twochains of tangent circles nesting down on 0 from above and below. Thesame phenomenon occurs at <span class="math inline">\(-i\)</span>, thetangency point of <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> and the fixed point of <span class="math inline">\(b\)</span>. Notwithstanding extra tangencies, thegenerators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> still pair opposite circles in theinitial tangent chain <span class="math inline">\(C_a,C_b,C_A\)</span>and <span class="math inline">\(C_B\)</span>. This means that fornesting circles we still need the commutator condition <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB}=2\)</span>, which isnot hard to check.</p></div><p>生成该垫片的矩阵非常简单：</p><p><span class="math display">\[a=\begin{pmatrix}1&amp;0\\-2i&amp;1\end{pmatrix}\quad\text{and}\quadb=\begin{pmatrix}1-i&amp;1\\1&amp;1+i\end{pmatrix}.\]</span></p><p>关于这两个特定的矩阵，我们稍后会详细解释它们的推导过程。值得注意的是，由于<span class="math inline">\(\mathop{\mathrm{Tr}}{a}=\mathop{\mathrm{Tr}}{b}=2\)</span>，因此<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 都是抛物型变换。观察 <a href="#fig-7.4">图 7.4</a> 中 Schottky 圆的排列，可以发现 <span class="math inline">\(a\)</span> 的不动点是原点 0，即圆 <span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span> 的切点。在 <a href="#fig-7.3">图7.3</a> 中，你可以看到两条相切的圆链从上下两侧分别向 0点逐渐嵌套收缩。相同的现象也出现在 <span class="math inline">\(-i\)</span> 处，这既是圆 <span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 的切点，也是变换 <span class="math inline">\(b\)</span> 的不动点。尽管存在额外的切点，生成元<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 依然将初始的相切链 <span class="math inline">\(C_a,C_b,C_A,C_B\)</span>中的圆配对。这意味着要实现圆链的无穷嵌套，我们仍需满足交换子条件 <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB}=2\)</span>，而这一迹值条件并不难验证。</p><div class="statement simple plain unnumbered"><p>We have been speaking as if there is only one Apollonian gasket, butcould we not get different gaskets by starting with different tangentchains? Not really, because it turns out that any chain of three tangentcircles can be conjugated to any other three. As you can work out inProject 7.1, this stems from the fact that there is always a Möbius mapcarrying any three points to any other three. Since the gasket isactivated by its initial ideal triangle, and since the procedure at eachstep consists in adding incircles, a Möbius map which conjugates oneideal triangle to another carries the whole gasket along in itswake.</p><p>This explains why it makes sense to talk about the Apollonian gasket,because up to conjugation by Möbius maps there is really only one.</p></div><p>我们此前的讨论似乎一直都默认了阿波罗尼奥斯垫片是独一无二的，但如果我们从不同的初始相切圆链出发，难道不会得到不同的垫片吗？答案是否定的。事实上，任何由三个相切圆组成的链，都可以通过某个莫比乌斯变换转化为另一组（事先给定的）相切圆链。如<a href="#proj-7.1">项目 7.1</a>中的推导所示，这一结论的根本原因在于：在复平面上，任意三个不同点总能通过某个莫比乌斯变换映射到任意其它三点。由于垫片的构造源于其初始理想三角形，而每一步的操作都是添加内切圆，因此将一个理想三角形共轭到另一个理想三角形的莫比乌斯变换，会将整个垫片一同带动并映射过去。</p><p>这就解释了为什么谈论“阿波罗尼奥斯垫片”是有意义的，因为在莫比乌斯变换的共轭意义下，归根结底，阿波罗尼奥斯垫片只有一个。</p><figure id="fig-7.5"><img src="/images/indra/fig-7.5.jpg" width="600" alt="Figure 7.5. The strip gasket. This shows the gasket as it appears when we conjugate so that the extra tangency point of C_b and C_B is at \infty. Any parabolic with a fixed point at \infty is a Euclidean translation, in this case b(z)=z+2, which explains the translational symmetry along the infinite strip. 图 7.5. 带状垫片。图中展示了当我们进行共轭变换，使得 C_b 和 C_B 的额外切点位于 \infty 处时，垫片的样貌。任何以 \infty 为不动点的抛物型变换都是欧几里得平移，在本例中为 b(z)=z+2，这解释了沿着无限带的平移对称性。"><figcaption aria-hidden="true">Figure 7.5. The strip gasket. This showsthe gasket as it appears when we conjugate so that the extra tangencypoint of <span class="math inline">\(C_b\)</span> and <span class="math inline">\(C_B\)</span> is at <span class="math inline">\(\infty\)</span>. Any parabolic with a fixed pointat <span class="math inline">\(\infty\)</span> is a Euclideantranslation, in this case <span class="math inline">\(b(z)=z+2\)</span>,which explains the translational symmetry along the infinitestrip.<br>图 7.5. 带状垫片。图中展示了当我们进行共轭变换，使得 <span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 的额外切点位于 <span class="math inline">\(\infty\)</span> 处时，垫片的样貌。任何以 <span class="math inline">\(\infty\)</span>为不动点的抛物型变换都是欧几里得平移，在本例中为 <span class="math inline">\(b(z)=z+2\)</span>，这解释了沿着无限带的平移对称性。</figcaption></figure><p>另一个著名的垫片版本可以在 <a href="#fig-7.5">图 7.5</a>中看到。为了得到这个，我们进行了共轭，使得 <span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span> 在 0 处相切，因此它们是垂直线。映射<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 现在在 <span class="math inline">\(0\)</span> 处有一个固定点。该群的生成元为：</p><p><span class="math display">\[a=\begin{pmatrix}2&amp;-i\\-i&amp;0\end{pmatrix}\quad\text{and}\quadb=\begin{pmatrix}1&amp;2\\0&amp;1\end{pmatrix}.\]</span></p><h2 id="pinching-tiles">Pinching tiles</h2><figure id="fig-7.6"><img src="/images/indra/fig-7.6.jpg" width="600" alt="Figure 7.6. Dr.&nbsp;Stickler meets Apollonius. Placing Dr.&nbsp;Stickler in the Apollonian gasket, we let the group of symmetries carry him around. He appears exactly in those disks which were pink in Figure 7.4. If we had started him off in a white one, his images would fill the white disks instead. The symmetry a is parabolic and on both sides of its fixed point 0, circles of Sticklers are streaming out. A startling feature is the circle of Sticklers streaming out from and into 1. Every alternate Stickler is standing on his head! The upright Sticklers are just powers of abAB (which fixes 1) applied to the Stickler standing on the right hand horizontal axis, while the upside down ones are the images of this same Stickler under (abAB)^nA. 图 7.6. Stickler 博士邂逅阿波罗尼奥斯分形。我们将 Stickler 博士置于阿波罗尼奥斯垫片中，然后让对称群带他四处转转。结果，他恰好出现在 图 7.4 里那些粉红色的圆盘中。若是他最初出现在某个白色圆盘中，那么他的身影就会填满所有的白色圆盘。对称 a 是抛物型的，在它的不动点 0 的两侧，成群的 Stickler 博士正沿着圆圈向外扩散。最令人惊奇的是，在坐标 1 附近，竟然出现了一圈 Stickler 博士首尾相连、双向流动的奇妙图案。更绝的是，相邻的 Stickler 博士还头朝上、头朝下交替出现。那些站得笔直的 Stickler 博士，是通过不断对右侧水平轴上那位 Stickler 施加变换 (abAB)^n（该变换以 1 为不动点）得到的。而那些倒立的 Stickler 博士，则是这位 Stickler 在变换 (abAB)^nA 作用下的映射结果。"><figcaption aria-hidden="true">Figure 7.6. Dr.&nbsp;Stickler meetsApollonius. Placing Dr.&nbsp;Stickler in the Apollonian gasket, we let thegroup of symmetries carry him around. He appears exactly in those diskswhich were pink in Figure 7.4. If we had started him off in a white one,his images would fill the white disks instead. The symmetry <span class="math inline">\(a\)</span> is parabolic and on both sides of itsfixed point 0, circles of Sticklers are streaming out. A startlingfeature is the circle of Sticklers streaming out from and into 1. Everyalternate Stickler is standing on his head! The upright Sticklers arejust powers of <span class="math inline">\(abAB\)</span> (which fixes 1)applied to the Stickler standing on the right hand horizontal axis,while the upside down ones are the images of this same Stickler under<span class="math inline">\((abAB)^nA\)</span>.<br>图 7.6. Stickler 博士邂逅阿波罗尼奥斯分形。我们将 Stickler博士置于阿波罗尼奥斯垫片中，然后让对称群带他四处转转。结果，他恰好出现在<a href="#fig-7.4">图 7.4</a>里那些粉红色的圆盘中。若是他最初出现在某个白色圆盘中，那么他的身影就会填满所有的白色圆盘。对称<span class="math inline">\(a\)</span> 是抛物型的，在它的不动点 0的两侧，成群的 Stickler 博士正沿着圆圈向外扩散。最令人惊奇的是，在坐标 1附近，竟然出现了一圈 Stickler博士首尾相连、双向流动的奇妙图案。更绝的是，相邻的 Stickler博士还头朝上、头朝下交替出现。那些站得笔直的 Stickler博士，是通过不断对右侧水平轴上那位 Stickler 施加变换 <span class="math inline">\((abAB)^n\)</span>（该变换以 1为不动点）得到的。而那些倒立的 Stickler 博士，则是这位 Stickler 在变换<span class="math inline">\((abAB)^nA\)</span>作用下的映射结果。</figcaption></figure><div class="statement simple plain unnumbered"><p>Figure 7.6 is a wonderful picture of what happened when we introducedDr.&nbsp;Stickler to Apollonius! It is a pretty intricate arrangement, solet’s take a bit of time understanding what has happened to the tiles.To get a grasp on the situation, look back at the three pictures inFigure 7.4, and watch the progression across the three frames. On theleft the limit set is a loop or quasicircle, so the ordinary set - whatis left when you take away the limit set - has two parts, a pink insideand a white outside. In the central picture, the pink part has collapsedinto a myriad of tangent disks, and the red Schottky circles <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span> touch at 0. On the right, the gasketgroup, the ‘horns’ of the pink region have also come together, causingthe white outside to fracture into disks as well. Notice how the memoryof which was inside and which was outside still persists, because whatwere the ‘inside’ disks are pink while the ‘outside’ ones are white.</p></div><p><a href="#fig-7.6">图 7.6</a> 是一幅精彩的画面，生动展现了当我们邀请Stickler博士探索阿波罗尼奥斯分形时所发生的奇妙事情！图中的结构相当复杂，因此我们不妨花些时间，仔细剖析图案的变化。要理解这一过程，不妨回顾<a href="#fig-7.4">图 7.4</a>的三幅子图，并观察这三帧之间的演变：左图中的极限集是一个回路或拟圆，因此普通集（即去掉极限集后剩下的部分）分为粉色的内部和白色的外部。中间的图中，粉色区域已收缩成无数相切的圆盘，而红色的肖特基圆<span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span> 在 0处相切。右图则展示了垫片群，其中粉色区域的“触角”也汇聚在一起，使得白色外部区域也裂解成圆盘。令人惊奇的是，尽管整体结构支离破碎，内外区域仍清晰保留着原始的记忆——曾经“内部”的圆盘依旧是粉色，而“外部”的圆盘依旧是白色。</p><div class="statement simple plain unnumbered"><p>In each picture, the initial Schottky circles are blue and red. Watchthem to follow the fate of the tiles. On the left, as usual for akissing Schottky group, they surround the central inner four sided tile.If we transported this tile around by the group, we would see atessellation　of the pink region similar to the one in Figure 6.6.(There is also an outer tile, the region outside the four Schottkycircles, which as usual you can see more clearly by imagining it on theRiemann sphere.) The inner and outer parts of the ordinary set areinvariant under the group, so if you apply any transformation of thegroup to any tile in the pink region ‘inside’ the limit set, you getanother tile which is also ‘inside’.</p></div><p>在每幅图中，最初的 Schottky圆分别是蓝色和红色。仔细观察它们的变化，有助于追踪瓷砖的去向。在左图中，和典型的“亲吻”Schottky群一样，这些圆环绕着中央的四边形瓷砖。如果我们将这块瓷砖沿着群的变换移动开来，就会在粉色区域中形成类似于<a href="#fig-6.6">图 6.6</a>的镶嵌图案（此外，还有一个外部瓷砖，即位于四个 Schottky圆之外的区域，通常，通过在黎曼球面上想象它的位置，可以更清楚地看到它的轮廓）。普通集的内部和外部在群作用下各自保持不变，因此，如果对极限集“内部”粉色区域中的某块瓷砖施加群中的某个变换，得到的仍会是另一块位于“内部”的瓷砖。</p><div class="statement simple plain unnumbered"><p>In the central picture, where <span class="math inline">\(a\)</span>has become parabolic, the inner tile has been pinched into two halves.Each half-tile is an ideal triangle, with two red sides and one blue.You should think of this pair of triangles as one composite two-parttile. Moved around by the group, the composite tile will cover all thepink circles. There is an outer tile in this picture too, which (on theRiemann sphere) remains in one piece.</p><p>On the right, in the gasket group, both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> have been pinched so that now <span class="math inline">\(C_b\)</span> and <span class="math inline">\(C_B\)</span> also tuch at <span class="math inline">\(-i\)</span>. Now there are four basic half-tiles.The two pink ones will produce a tiling of the pink circles and thewhite ones will make a tiling of the white circles. In the glowinggasket picture, these four tiles are black. The upper two ‘horizontal’ideal triangles are the remnants of the inner Schottky tile, while thelower ‘vertical’ triangle is a remnant of the outer one. If you lookcarefully, you can just see its twin peeping out in the bottom centre ofthe page.</p></div><p>在中央的图片中，<span class="math inline">\(a\)</span>已变成了抛物型，内部的瓷砖被挤压成了两半。每个半瓷砖都是一个理想三角形，带有两条红边和一条蓝边。你可以把这对三角形视作一个由两部分组成的复合瓷砖。通过群的作用，这个复合瓷砖将覆盖所有的粉色圆盘。图中还有一个外部瓷砖，它在黎曼球面上依然保持完整。</p><p>在右侧的垫片图中，<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 都被挤压变形，使得 <span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 现在也在 <span class="math inline">\(-i\)</span>处相切。此时出现了四个基本的半瓷砖。两块粉色的会铺满粉色圆盘，而两块白色的则会铺满白色圆盘。在那幅发光的垫片图中，这四块瓷砖都呈现为黑色。上方的两个“水平”理想三角形是内部Schottky瓷砖的残迹，而下方的“垂直”三角形则是外部瓷砖的残迹。仔细观察，你会在页面底部中央隐约发现它的孪生兄弟正悄悄探出头来。</p><div class="statement simple plain unnumbered"><p>Now we can go back to the picture of Dr.&nbsp;Stickler meeting Apollonius.The party is taking place in the remnants of the ‘pink’ circles. If youcompare with the half-tiles in Figure 7.4, something rather odd hashappened to Dr.&nbsp;Stickler - when the original tile split in two, his headended up in the green half-tile and his feet in the blue one.Fortunately, there is a transformation of the group (namely <span class="math inline">\(B\)</span>) which carries the blue Stickler to thegreen one, moving the blue half-tile containing the blue feet to theyellow half-tile containing the green feet. Had we not pointed out hisdifficulties you might not even have noticed that anything was wrong.After gluing the yellow half-tile to the green halftile, the relieved(but still slightly greenish) Dr.&nbsp;Stickler stands reunited in a new andcomplete tile whose images under the group map to all the Sticklers inthe picture.</p></div><p>现在我们可以回到 Stickler博士与阿波罗尼奥斯相遇的画面。聚会正在“粉色”圆圈的残迹中举行。对照 <a href="#fig-7.4">图 7.4</a> 中的半瓷砖，你会发现 Stickler博士身上发生了一件相当奇怪的事——当原始瓷砖裂成两半时，原始瓷砖裂成两半时，他的头跑到了绿色半瓷砖里，而他的脚却留在了蓝色半瓷砖上。幸好，群中有一个变换（即<span class="math inline">\(B\)</span>）可以将蓝色的 Stickler 带到绿色Stickler的位置，把装着蓝色脚丫的蓝色半瓷砖挪到装着绿色脚丫的黄色半瓷砖上。要不是我们特意指出这种窘况，你可能根本没发现哪里不对劲。等到黄色半瓷砖和绿色半瓷砖粘合完毕，那位如释重负（却仍然带着一丝“绿意”）的Stickler博士终于又完整地站在了一块崭新的瓷砖上。通过群的映射，这块瓷砖的影像铺展开来，构成了画面中所有Stickler 博士的身影。</p><h2 id="and-pinching-surfaces">And pinching surfaces</h2><div class="statement simple plain unnumbered"><p>What happened to the tiles in the last section, has, of course, alsoan interpretation in terms of surfaces. Looking back to the picture onp.&nbsp;190 which showed how tiles were glued up in a kissing Schottky group,we can work out what happens when we bring the four circles together tomake the gasket. It takes a bit of stretching and squeezing to do this,which we have illustrated in Figure 7.7.</p><p>The result, shown in the last panel, is our old friend the pretzelwith three circles pinched to points or cusps: the waist as in the lastchapter and, in addition, loops around the top and bottom tori. Both topand bottom are now ‘spheres’ with three cusps or punctures each. Onepair of cusps on each sphere are joined together like ‘horns’, and thesetwo ‘horned spheres’ are themselves joined together at the last twocusps.</p></div><p>上一节中瓷砖的演变过程，当然也可以从曲面角度得到诠释。回顾第 190页展示的亲吻 Schottky群的基本域粘合过程的示意图，我们可以推导出当将四个圆粘合为垫片群时会发生什么。这一过程需要一些拉伸和压缩，我们在<a href="#fig-7.7" title="图 7.7">图 7.7</a> 中进行了直观展示。</p><p>最终结果呈现于最后一幅示意图中，正是我们熟悉的三叶椒盐脆饼造型——三个圆周被压缩为尖点（cusp）：其中一个是上一章提到的“腰部”尖点，另外两个则是围绕顶部和底部的环面。此时，顶部与底部都变成了各自有三个尖点（或称穿孔）的”球面”。每个球面上的一对尖点像”犄角”一样连接在一起，而这两个“带角球面”则通过它们剩下的两个尖点相互连接。</p><div class="statement simple plain unnumbered"><p>The gasket group is called doubly cusped because we have pinched twoextra loops, <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. It is also sometimes called maximallycusped, because, after all this squeezing, there are no more curves leftto pinch. In Chapter 9, we shall see that you can make many variants ofthe gasket group by imposing more complicated relationships between thecurves we choose to pinch on the top and bottom halves of the pinchedpretzel.</p></div><p>垫片群被称为双尖群，因为我们挤压了两个额外的环路 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>。它也常被称为“极大尖群”，因为经过这般操作后，已不存在可供进一步挤压的曲线。在第九章中我们将看到，通过在挤压后的椒盐卷曲曲面（pretzel）的上下半部之间，对选定挤压曲线施加更复杂的关联约束，可以构造出多种垫片群的变体。</p><div id="fig-7.7" class="statement simple plain unnumbered"><p>Figure 7.7. Pinching curves. How gluing up the gasket configurationof tangent circles leads to a pair of triply-punctured spheres. The<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> curves we have to shrink are are marked<span class="math inline">\(L\)</span> and <span class="math inline">\(M\)</span>. Instead of pulling the upper and lowerpartially glued-up cylinders logether right away, as we did in Figure6.16, it now takes some effort first to twist them relative to eachother in such a way that when we glue-up, the dotted loops are in theirproper position ready to be shrunk.</p><p>图 7.7.捏合曲线。如何通过粘合垫片的切圆得到一对带有三穿孔球面。需要收缩的 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 曲线分别标记为 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span>。与 <a href="#fig-6.16">图 6.16</a>中直接粘合上下圆柱体的操作不同，此时需要先使两者相对扭转，确保粘合时虚线环处于正确位置以便后续收缩。</p><figure><img src="/images/indra/fig-7.7-1.jpg" width="200" alt="BEGIN WITH A PLANE WITH FOUR HOLES, EACH OF WHICH JUST TOUCHES THREE OTHERS, WHAT HAPPENS WHEN WE GLUE A TO a (THE SMALL ONE) AND B TO b? 从一个带有四个孔的平面开始，每个孔都与另外三个孔相切。当我们将 A 粘合到 a（较小的孔），并将 B 粘合到 b 时，会发生什么？"><figcaption aria-hidden="true">BEGIN WITH A PLANE WITH FOUR HOLES, EACHOF WHICH JUST TOUCHES THREE OTHERS, WHAT HAPPENS WHEN WE GLUE <span class="math inline">\(A\)</span> TO <span class="math inline">\(a\)</span> (THE SMALL ONE) AND <span class="math inline">\(B\)</span> TO <span class="math inline">\(b\)</span>?<br>从一个带有四个孔的平面开始，每个孔都与另外三个孔相切。当我们将 <span class="math inline">\(A\)</span> 粘合到 <span class="math inline">\(a\)</span>（较小的孔），并将 <span class="math inline">\(B\)</span> 粘合到 <span class="math inline">\(b\)</span> 时，会发生什么？</figcaption></figure><figure><img src="/images/indra/fig-7.7-2.jpg" width="200" alt="FIRST PULL a AWAY FROM A AND B AWAY FROM b ALONG THE ARCS L AND M. HOW WE SEE A DISTORTED BUT FAMILIAR PICTURE: ABab. 首先，沿弧线 L 将 a 从 A 处拉开，沿弧线 M 将 B 从 b 处拉开。此时会呈现一个扭曲但熟悉的图案：ABab。"><figcaption aria-hidden="true">FIRST PULL a AWAY FROM A AND B AWAY FROMb ALONG THE ARCS <span class="math inline">\(L\)</span> AND <span class="math inline">\(M\)</span>. HOW WE SEE A DISTORTED BUT FAMILIARPICTURE: <span class="math inline">\(ABab\)</span>.<br>首先，沿弧线 <span class="math inline">\(L\)</span> 将 <span class="math inline">\(a\)</span> 从 <span class="math inline">\(A\)</span> 处拉开，沿弧线 <span class="math inline">\(M\)</span> 将 <span class="math inline">\(B\)</span> 从 <span class="math inline">\(b\)</span>处拉开。此时会呈现一个扭曲但熟悉的图案：<span class="math inline">\(ABab\)</span>。</figcaption></figure><figure><img src="/images/indra/fig-7.7-3.jpg" width="200" alt="ADO THE POINT AT INFINITY TO WRAP UP THE PLANE. 通过添加无穷远点使平面闭合。"><figcaption aria-hidden="true">ADO THE POINT AT INFINITY TO WRAP UP THEPLANE.<br>通过添加无穷远点使平面闭合。</figcaption></figure><figure><img src="/images/indra/fig-7.7-4.jpg" width="200" alt="STRETCH TO MAKE THIS FAMILIAR SURFACE. NOTE ARCS L AND M. 拉伸形成我们熟悉的曲面。注意观察弧线 L 和 M。"><figcaption aria-hidden="true">STRETCH TO MAKE THIS FAMILIAR SURFACE.NOTE ARCS <span class="math inline">\(L\)</span> AND <span class="math inline">\(M\)</span>.<br>拉伸形成我们熟悉的曲面。注意观察弧线 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span>。</figcaption></figure><figure><img src="/images/indra/fig-7.7-5.jpg" width="200" alt="NOW SOMETHING STRANGE: PULL TOGETHER THE TOP HALVES OF A AND a AND THE BOTTOM HALVES OF B AND b. 进行奇怪的操作：将 A 和 a 的上半部分、B 和 b 的下半部分别拉到一起。"><figcaption aria-hidden="true">NOW SOMETHING STRANGE: PULL TOGETHER THETOP HALVES OF <span class="math inline">\(A\)</span> AND <span class="math inline">\(a\)</span> AND THE BOTTOM HALVES OF <span class="math inline">\(B\)</span> AND <span class="math inline">\(b\)</span>.<br>进行奇怪的操作：将 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(a\)</span> 的上半部分、<span class="math inline">\(B\)</span> 和 <span class="math inline">\(b\)</span> 的下半部分别拉到一起。</figcaption></figure><figure><img src="/images/indra/fig-7.7-6.jpg" width="200" alt="GUE TOP OF A TO TOP of a, BOTTOM OF B TO BOTTOM OF b. 将 A 的顶部和 a 的顶部粘在一起，将 B 的底部和 b 的底部粘在一起。"><figcaption aria-hidden="true">GUE TOP OF <span class="math inline">\(A\)</span> TO TOP of <span class="math inline">\(a\)</span>, BOTTOM OF <span class="math inline">\(B\)</span> TO BOTTOM OF <span class="math inline">\(b\)</span>.<br>将 <span class="math inline">\(A\)</span> 的顶部和 <span class="math inline">\(a\)</span> 的顶部粘在一起，将 <span class="math inline">\(B\)</span> 的底部和 <span class="math inline">\(b\)</span> 的底部粘在一起。</figcaption></figure><figure><img src="/images/indra/fig-7.7-7.jpg" width="200" alt="NOW JOIN THE REST OF A TO a ANP B TO b. 继续完成 A 与 a、B 与 b 剩余部分的粘合。"><figcaption aria-hidden="true">NOW JOIN THE REST OF <span class="math inline">\(A\)</span> TO <span class="math inline">\(a\)</span> ANP <span class="math inline">\(B\)</span> TO <span class="math inline">\(b\)</span>.<br>继续完成 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(a\)</span>、<span class="math inline">\(B\)</span>与 <span class="math inline">\(b\)</span> 剩余部分的粘合。</figcaption></figure><figure><img src="/images/indra/fig-7.7-8.jpg" width="200" alt="FINALLY, SHORTEN THE ARCS L AND M … 最终收缩弧线 L 和 M …"><figcaption aria-hidden="true">FINALLY, SHORTEN THE ARCS <span class="math inline">\(L\)</span> AND <span class="math inline">\(M\)</span> …<br>最终收缩弧线 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span> …</figcaption></figure><figure><img src="/images/indra/fig-7.7-9.jpg" width="200" alt="UNTIL EACH ARC SHRINKS TO A POINT, MAKING TWO TRIPLY-PUNCTURED SPHERES. 直至每个弧线都坍缩为一点，形成两个三穿孔球面。"><figcaption aria-hidden="true">UNTIL EACH ARC SHRINKS TO A POINT, MAKINGTWO TRIPLY-PUNCTURED SPHERES.<br>直至每个弧线都坍缩为一点，形成两个三穿孔球面。</figcaption></figure></div><h2 id="tiling-the-inner-disks">Tiling the inner disks</h2><div class="statement simple plain unnumbered"><p>Figure 7.6 is made up of lots of disks full of Dr.&nbsp;Sticklers, eachtiled by ideal triangles shown in grey. These disks are the remnants ofthe pink region in Figure 7.4. For most of the rest of this chapter, weshall be occupied with the tiling of just one of these disks. The sametiling fills out the insides of each of the glowing circles in Figure7.3. The group of symmetries which goes with this very special disktessellation is called the modular group and has been the well-spring ofa huge body of mathematics.</p></div><p><a href="#fig-7.6">图 7.6</a> 由无数布满 Sticklers博士身影的圆盘构成，每个圆盘都被灰色的理想三角形所镶嵌。这些圆盘正是 <a href="#fig-7.4">图 7.4</a>中粉色区域的遗迹。在本章接下来的大部分篇幅里，我们将专注于研究其中一个圆盘的密铺结构。同样的密铺图案也出现在<a href="#fig-7.3">图 7.3</a>中每个发光圆圈的内部。这种独特的圆盘镶嵌的对称群称为模群，它一直是众多数学成果的源泉。</p><div class="statement simple plain unnumbered"><p>Since the tiling in each disk is the same, we may as well focus onthe large disk through -1 and 0, shown in yellow in Figure 7.8. Tounderstand how these ideal triangle tiles cover the yellow disk we needto find the subgroup of all the transformations in the gasket groupwhich map the inside of this disk to itself. This subgroup (which is ofcourse also a group in its own right), or any of its conjugates, is whatwe call the modular group. The basic tile is made up of two idealtriangles, the ones coloured green and yellow in Figure 7.6. The twotriangles together form one of our familiar four-sided pinched-off tileswith four circular arc sides. Moved around by the modular group, theytile the whole yellow disk.</p></div><p>由于每个圆盘中的密铺方式相同，我们可以将注意力集中在通过 -1 和 0的大圆盘上，这在 <a href="#fig-7.8">图 7.8</a>中以黄色部分表示。为了理解这些理想三角形如何覆盖黄色圆盘，我们需要找出垫片群中所有将圆盘内部映射到自身的变换子群。这个子群（显然，它本身也是一个群），或者它的任何共轭子群，便是我们所称的模群。基本的瓷砖由两个理想三角形组成，即<a href="#fig-7.6">图 7.6</a>中绿色和黄色的三角形。这两个三角形合在一起，构成了我们熟悉的四边弧形瓷砖。通过模群的作用，它们密铺了整个黄色圆盘。</p><figure id="fig-7.8"><img src="/images/indra/fig-7.8.jpg" width="600" alt="Figure 7.8. The set-up of tangent circles for the modular subgroup. The left frame is just to get oriented. The red circles C_A and C_a, together with the level 2 green circles B(C_a)=C_{Ba} and B(C_A)=C_{BA} form the boundary of the new four-sided tile. The arrows show how a pairs C_A to C_a and b pairs C_B to C_b. The boundary of the yellow disk is the limit set of the modular group generated by a and BAb. 图 7.8. 模群的切线圆配置。左侧子图仅用于帮助定位。红色圆圈 C_A 和 C_a，以及二级绿色圆圈 B(C_a)=C_{Ba} 和 B(C_A)=C_{BA} 共同构成了新四边形瓷砖的边界。箭头指示了变换 a 如何将 C_A 和 C_a 配对，变换 b 如何将 C_B 和 C_b 配对。黄色圆盘的边界是由 a 和 BAb 生成的模群的极限集。"><figcaption aria-hidden="true">Figure 7.8. The set-up of tangent circlesfor the modular subgroup. The left frame is just to get oriented. Thered circles <span class="math inline">\(C_A\)</span> and <span class="math inline">\(C_a\)</span>, together with the level 2 greencircles <span class="math inline">\(B(C_a)=C_{Ba}\)</span> and <span class="math inline">\(B(C_A)=C_{BA}\)</span> form the boundary of thenew four-sided tile. The arrows show how <span class="math inline">\(a\)</span> pairs <span class="math inline">\(C_A\)</span> to <span class="math inline">\(C_a\)</span> and <span class="math inline">\(b\)</span> pairs <span class="math inline">\(C_B\)</span> to <span class="math inline">\(C_b\)</span>. The boundary of the yellow disk isthe limit set of the modular group generated by <span class="math inline">\(a\)</span> and <span class="math inline">\(BAb\)</span>.<br>图 7.8. 模群的切线圆配置。左侧子图仅用于帮助定位。红色圆圈 <span class="math inline">\(C_A\)</span> 和 <span class="math inline">\(C_a\)</span>，以及二级绿色圆圈 <span class="math inline">\(B(C_a)=C_{Ba}\)</span> 和 <span class="math inline">\(B(C_A)=C_{BA}\)</span>共同构成了新四边形瓷砖的边界。箭头指示了变换 <span class="math inline">\(a\)</span> 如何将 <span class="math inline">\(C_A\)</span> 和 <span class="math inline">\(C_a\)</span> 配对，变换 <span class="math inline">\(b\)</span> 如何将 <span class="math inline">\(C_B\)</span> 和 <span class="math inline">\(C_b\)</span> 配对。黄色圆盘的边界是由 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(BAb\)</span> 生成的模群的极限集。</figcaption></figure><div class="statement simple plain unnumbered"><p>We worked out the labels of the boundary circles <span class="math inline">\(C_a, C_A, C_{BA}\)</span> and <span class="math inline">\(C_{Ba}\)</span> in Figure 7.8 of the four-sidedtile by going to part of the level-two Schottky chain for the gasketgroup. (You may find it easiest to check the arrangement in a picturelike the left frame of Figure 7.4 without all the extra gaskettangencies first.) Notice the four tangency points of these circles areall on the boundary of the yellow disk. As you can see, the four circlesform a new chain of tangent circles. As usual, <span class="math inline">\(a\)</span> pairs <span class="math inline">\(C_A\)</span> to <span class="math inline">\(C_a\)</span>. In addition, <span class="math inline">\(BAb\)</span> pairs <span class="math inline">\(C_{Ba}\)</span> to <span class="math inline">\(C_{BA}\)</span> because:</p><p><span class="math display">\[BAb\left(C_{Ba}\right) =BAb\left(B\left(C_a\right)\right) = BA\left(C_a\right) =B\left(C_A\right) = C_{BA}.\]</span></p><p>Inside the gasket group we have found another mini-chain of fourtangent circles, together with a pair of transformations which matchthem together in pairs!</p></div><p>我们通过研究垫片群的二级 Schottky 链的局部结构，确定了 <a href="#fig-7.8">图 7.8</a> 中四边形瓷砖的边界圆 <span class="math inline">\(C_a,C_A,C_{BA}\)</span> 和 <span class="math inline">\(C_{Ba}\)</span> 的标签。（建议首先参考 <a href="#fig-7.4">图 7.4</a>左图中圆的排列，暂时忽略所有额外的垫片切点，会更容易理解）。值得注意的是，这些圆的四个切点全部位于黄色圆盘的边界上。正如你所见，这四个圆形成了一个新的切圆链。按照惯例，变换<span class="math inline">\(a\)</span> 将圆 <span class="math inline">\(C_A\)</span> 和 <span class="math inline">\(C_a\)</span> 配对。此外，变换 <span class="math inline">\(BAb\)</span> 将圆 <span class="math inline">\(C_{Ba}\)</span> 和 <span class="math inline">\(C_{BA}\)</span> 配对，原因如下： <span class="math display">\[BAb\left(C_{Ba}\right) =BAb\left(B\left(C_a\right)\right) = BA\left(C_a\right) =B\left(C_A\right) = C_{BA}.\]</span>在垫片群中，我们发现了一个由四个相切圆组成的迷你链，以及一对将它们成对匹配的变换！</p><div class="statement simple plain unnumbered"><p>This construction shows that the modular group is a new kind of‘necklace group’, made by disregarding all the rest of the gasket andlooking only at the disks produced by acting with <span class="math inline">\(a\)</span> and <span class="math inline">\(BAb\)</span> on the four circles which bound thenew tile. The new group is generated by the transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(BAb\)</span>. Indeed in Figure 7.3, you canactually pick out chains of image disks nicely shrinking down onto theglowing limit circle through -1 and 0 . The only difference from thekissing Schottky groups we met in the last chapter is that the twogenerators pair not opposite circles but adjacent ones. As we shallexplain in more detail on p.&nbsp;213 ff., the image circles shrink because<span class="math inline">\(a,BAb\)</span> and their product <span class="math inline">\(aBAb\)</span> are all parabolic.</p></div><p>这一构造表明，模群是一种新型的“项链群”，它是通过忽略垫片的其余部分，仅关注由变换<span class="math inline">\(a\)</span> 和 <span class="math inline">\(BAb\)</span>作用于新瓷砖边界的四个圆所产生的圆盘而形成的。这个新群由变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(BAb\)</span> 生成。实际上，在 <a href="#fig-7.3">图 7.3</a>中，你可以清晰地看到一串映像圆盘，它们逐渐缩小并收敛到经过点 -1 和 0的发光极限圆上。这与上一章讨论的“接吻式 Schottky群”的唯一关键时，这两个生成元配对的不是相对的圆，而是相邻的圆。正如我们将在第213 页及以后章节中详细解释的那样，这些映像圆之所以缩小，是因为 <span class="math inline">\(a,BAb\)</span> 以及它们的乘积 <span class="math inline">\(aBAb\)</span> 都是抛物型变换。</p><div class="statement simple plain unnumbered"><p>The same pattern of pairing circles is repeated all over the gasket.Every pink disk is the image of the yellow one under some element in thegasket group, which conjugates our modular group to another ‘modulargroup’ acting in the new disk. The white disks are different from thepink ones, because you can never get from pink to white usingtransformations in the gasket group. However you can still find a chainof four tangent circles matched in the same pattern, as described in <a href="#proj-7.4">Project 7.4</a>.</p></div><p>在垫片的每一个局部区域，都能观察到完全相同的圆配对模式。每个粉色圆盘均可视为黄色圆盘经垫片群中某个变换作用后的像——这个变换元素会将我们原本的模群共轭到一个新的”模群”，而新模群将作用在对应的粉色圆盘上。白色圆盘与粉色圆盘存在本质区别：垫片群中的任意变换都无法将粉色圆盘映射为白色圆盘。不过，我们仍能找到四个相切圆构成的配对链，其模式与前文所述完全一致（具体构造方法详见项目7.4）。</p><div class="statement simple plain unnumbered"><p>You might well imagine that we should be set to repeat everything wedid in the last chapter. By taking four tangent circles and pairing themin this new pattern we should presumably get a whole new lot ofquasifuchsian groups. Not so! It turns out that the rigours imposed byspecifying that the two generators and their product are all parabolicactually ‘freeze’ the group. Without any mention of circle chains, weprove in Note 7.1 the remarkable fact that all groups made with pairingconditions like this are, up to conjugation, ‘the same’. What this meansin more detail is this. Suppose that <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are any two parabolic Möbiustransformations with the property that <span class="math inline">\(UV\)</span> is also parabolic, and such that thefixed points <span class="math inline">\({\rm Fix}\,U\)</span> and <span class="math inline">\({\rm Fix}\,V\)</span> of <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are not the same. Then there is alwaysa conjugating map <span class="math inline">\(M\)</span> such that:<span class="math display">\[MUM^{-1} = \begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix}, \quadMVM^{-1} = \begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}.\]</span> This explains why there are so many circles in the gasketgroup, and why you get an identical tiling pattern in each one.</p></div><p>你或许会认为我们需要完全重复上一章的研究过程。通过选取四个相切圆并采用这种新配对模式，我们理应会得到一大堆新的拟富克斯群。然而事实并非如此！事实证明，要求两个生成元及其乘积均为抛物型变换的刚性条件，实质上”冻结”了群的结构。我们在注记7.1中不涉及任何圆链概念，证明了如下引人注目的结论：所有满足此类配对条件的群在共轭意义下都是”相同”的。具体而言，设<span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 是任意两个抛物型莫比乌斯变换，满足<span class="math inline">\(UV\)</span> 仍为抛物型，且两者的不动点 ${},U$与 <span class="math inline">\({\rm Fix}\,V\)</span>$互异，则必存在共轭变换 <span class="math inline">\(M\)</span> 使得：</p><p><span class="math display">\[MUM^{-1} = \begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix}, \quadMVM^{-1} = \begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}.\]</span>这解释了垫片群中为什么有如此多的圆圈，以及每个圆内部都会呈现完全相同的密铺图案。</p><div id="note-7-1--uniqueness-of-the-modular-group" class="statement sta_note_7_1__uniqueness_of_the_modular_group definition unnumbered"><p><span class="statement-heading"><span class="statement-label">Note7.1: Uniqueness of the modular group</span>：</span><span class="statement-spah"> </span><br></p><p><strong>注 7.1：模群的唯一性</strong></p><p>Suppose that <span class="math inline">\(U\)</span>, <span class="math inline">\(V\)</span> and <span class="math inline">\(UV\)</span> are all parabolic (and therefore notthe identity!) and the fixed point of <span class="math inline">\(U\)</span> is <span class="math inline">\(z_U\)</span> and the fixed point of <span class="math inline">\(V\)</span> is <span class="math inline">\(z_V\)</span>. We are trying to conjugate <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> to the generators of the modular group.We have seen that we can find a Möbius transformation <span class="math inline">\(M\)</span> that maps <span class="math inline">\(z_U\)</span> to <span class="math inline">\(0\)</span> and <span class="math inline">\(z_V\)</span> to <span class="math inline">\(\infty\)</span>. Conjugating our originaltransformations <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> by <span class="math inline">\(M\)</span> arranges that <span class="math inline">\(MUM^{-1}(0) = 0\)</span> and <span class="math inline">\(MVM^{-1}(\infty) = \infty\)</span>, and still thetwo transformations <span class="math inline">\(MUM^{-1}\)</span> and<span class="math inline">\(MVM^{-1}\)</span> are parabolic. Since wecan simultaneously conjugate them in this way, we may just as wellassume the original transformations <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> have fixed points <span class="math inline">\(0\)</span> and <span class="math inline">\(\infty\)</span>, respectively.</p><p>A parabolic transformation that fixes <span class="math inline">\(\infty\)</span> is always conjugate to any other,up to a minus sign. (See Chapter 3.) Let’s arrange by conjugation andpossibly multiplying by -1 that <span class="math inline">\(V\)</span>corresponds to the matrix <span class="math inline">\(\begin{pmatrix} 1&amp; 2 \\ 0 &amp; 1 \end{pmatrix}\)</span>.　Now all that’s left is<span class="math inline">\(U\)</span>. Since <span class="math inline">\(U(0)=0\)</span>, after again possibly multiplyingby -1, we can conclude that the matrix of <span class="math inline">\(U\)</span> is <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix}\]</span> for some number <span class="math inline">\(x\)</span>.</p><p>That brings us to the last hypothesis that <span class="math inline">\(UV\)</span> is parabolic. Let’s multiply thisout:</p><p><span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix} \begin{pmatrix} 1&amp; 2 \\ 0 &amp; 1 \end{pmatrix} = \begin{pmatrix} 1 &amp; 2 \\ x&amp; 1+2x \end{pmatrix}.\]</span></p><p>The trace of <span class="math inline">\(UV\)</span> under theseassumptions is <span class="math inline">\(2 + 2x\)</span>. This is<span class="math inline">\(\pm 2\)</span> for precisely two values of<span class="math inline">\(x\)</span>, namely, <span class="math inline">\(x = -2\)</span> and <span class="math inline">\(x= 0\)</span>. In the latter case, <span class="math inline">\(U\)</span>is the identity, which we are definitely excluding. That means <span class="math inline">\(x = -2\)</span>, and we have shown that <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are simultaneously conjugate to <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix} \text{ and }\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}.\]</span> (We may have to multiply one or both matrices by -1 to arrangethat they both have trace 2.)</p><p>假设 <span class="math inline">\(U\)</span>, <span class="math inline">\(V\)</span> 和 <span class="math inline">\(UV\)</span>均为抛物型变换（因此不是恒等变换！），且 <span class="math inline">\(U\)</span> 的不动点是 <span class="math inline">\(z_U\)</span>，<span class="math inline">\(V\)</span> 的不动点是 <span class="math inline">\(z_V\)</span>。我们的目标是将 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span>共轭变换为模群的生成元。我们已经看到，可以找到一个莫比乌斯变换 <span class="math inline">\(M\)</span>，它将 <span class="math inline">\(z_U\)</span> 映射到 <span class="math inline">\(0\)</span>，<span class="math inline">\(z_V\)</span> 映射到 <span class="math inline">\(\infty\)</span>。通过 <span class="math inline">\(M\)</span> 对原变换 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 进行共轭后，新变换 <span class="math inline">\(MUM^{-1}\)</span> 将保持 0 不变，<span class="math inline">\(MVM^{-1}\)</span> 将保持 <span class="math inline">\(\infty\)</span>不变，且两者仍为抛物型变换。既然这种共轭可同步完成，我们不妨直接假设原变换<span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 的不动点分别是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>。</p><p>固定 <span class="math inline">\(\infty\)</span>的抛物型变换在相差一个符号的意义下彼此共轭（参见第3章）。通过适当共轭及可能的符号调整，可以使<span class="math inline">\(V\)</span> 对应于矩阵 <span class="math inline">\(\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1\end{pmatrix}\)</span>。此时仅需确定 <span class="math inline">\(U\)</span> 的形式。由于 <span class="math inline">\(U(0) = 0\)</span>，经可能的符号调整后，<span class="math inline">\(U\)</span> 的矩阵必为： <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix}\quad(x\in\mathbb{C}).\]</span> 接下来验证 <span class="math inline">\(UV\)</span>的抛物型条件。计算其乘积：</p><p><span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix} \begin{pmatrix} 1&amp; 2 \\ 0 &amp; 1 \end{pmatrix} = \begin{pmatrix} 1 &amp; 2 \\ x&amp; 1+2x \end{pmatrix}.\]</span> 此时 <span class="math inline">\(UV\)</span> 的迹是 <span class="math inline">\(2 + 2x\)</span>。抛物型变换的迹需满足 <span class="math inline">\(|\mathop{\mathrm{Tr}}|=2\)</span>，这恰好对 <span class="math inline">\(x\)</span> 的两个值成立，即 <span class="math inline">\(x = -2\)</span> 和 <span class="math inline">\(x =0\)</span>。当 <span class="math inline">\(x=0\)</span> 时，<span class="math inline">\(U\)</span> 退化为恒等变换（已排除），因此必有<span class="math inline">\(x=−2\)</span>。由此可知 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 可共轭于矩阵：</p><p><span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix} \text{ and }\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}\]</span></p><p>（必要时可对其中一个或两个矩阵取负，以确保其迹均为 2）</p></div><h2 id="the-modular-group-of-arithmetic">The modular group ofarithmetic</h2><div class="statement simple plain unnumbered"><p>The result just discussed shows that the modular group is conjugateto a very famous group of great importance in number theory. It is madeby arranging the four Schottky circles with their tangency points at<span class="math inline">\(-1,0,1\)</span> and <span class="math inline">\(\infty\)</span>. You can see these, coloured redand green, in the left frame of Figure 7.9. Since one of the tangencypoints is the point at infinity, two of the circles show up as greenvertical lines. These green lines are paired by <span class="math inline">\(b=\begin{pmatrix}1&amp;2\\0&amp;1\end{pmatrix}\)</span>,while the two red circles tangent at 0 are paired by <span class="math inline">\(a=\begin{pmatrix}1&amp;0\\-2&amp;1\end{pmatrix}\)</span>.Notice how <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> match adjacent circles in the chain inexactly the pattern of the red and green arrows in Figure 7.8. In fact,as you can easily calculate, <span class="math inline">\(ab\)</span> isthe parabolic transformation <span class="math inline">\(\begin{pmatrix}1&amp;2\\-2&amp;-3\end{pmatrix}\)</span>.</p></div><p>刚刚讨论的结果表明，模群与一个在数论中极为著名且重要的群是共轭的。这个群是通过排列四个肖特基圆生成的，其切点分别位于<span class="math inline">\(-1, 0, 1\)</span> 和 <span class="math inline">\(\infty\)</span>。在 <a href="#fig-7.9">图 7.9</a>的左图中，这些圆分别以红绿两色呈现。由于其中一个切点是无穷远点，因此有两个圆在图中呈现为绿色的垂直直线。这两条绿色直线由变换<span class="math inline">\(b=\begin{pmatrix}1&amp;2\\0&amp;1\end{pmatrix}\)</span>配对，而在原点 0 处相切的两个红色圆则通过变换 <span class="math inline">\(a=\begin{pmatrix}1&amp;0\\-2&amp;1\end{pmatrix}\)</span>配对。请注意，变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 对相邻圆的配对方式，恰好与 <a href="#fig-7.8">图 7.8</a>中红绿箭头所示的模式完全一致。事实上，通过简单的计算即可验证，<span class="math inline">\(ab\)</span> 是抛物型变换 <span class="math inline">\(\begin{pmatrix}1&amp;2\\-2&amp;-3\end{pmatrix}\)</span>。</p><figure id="fig-7.9"><img src="/images/indra/fig-7.9.jpg" width="600" alt="Figure 7.9. The modular tessellation of the upper half plane. The left frame shows the tiling or tessellation of the upper half plane by ideal triangles belonging to the smaller modular group coming from pairing tangent circles, while the right frame shows the richer tessellation associated to the full modular group with its added symmetries. Each tile on the left is subdivided into twelve tiles on the right. 图 7.9. 上半平面的模群密铺。左图展示了通过配对相切圆生成的子模群对应的理想三角形密铺结构；右图则展示具有完整模群对称性的更加精细的密铺。左侧的每个瓷砖在右侧被细分为十二个小瓷砖。"><figcaption aria-hidden="true">Figure 7.9. The modular tessellation ofthe upper half plane. The left frame shows the tiling or tessellation ofthe upper half plane by ideal triangles belonging to the smaller modulargroup coming from pairing tangent circles, while the right frame showsthe richer tessellation associated to the full modular group with itsadded symmetries. Each tile on the left is subdivided into twelve tileson the right.<br>图 7.9.上半平面的模群密铺。左图展示了通过配对相切圆生成的子模群对应的理想三角形密铺结构；右图则展示具有完整模群对称性的更加精细的密铺。左侧的每个瓷砖在右侧被细分为十二个小瓷砖。</figcaption></figure><div class="statement simple plain unnumbered"><p>It is no coincidence that the entries of these three matrices areintegers. The right frame of Figure 7.9 is a more complicated picturewhich shows all the symmetries of the tiling on the left. Each idealtriangle has been subdivided into three hatched and three unhatchedsub-triangles. (The sub-triangles are not quite ideal, because only oneof their angles is 0 .) The group of symmetries of this more complicatedtiling is, from the point of view of Möbius maps, the simplest group ofall: just the set of all <span class="math inline">\(2\times 2\)</span>matrices <span class="math inline">\(\begin{pmatrix}p&amp;q\\r&amp;s\end{pmatrix}\)</span>with integer entries <span class="math inline">\(p,q,r\)</span> and<span class="math inline">\(s\)</span> and determinant <span class="math inline">\(ps-qr\)</span> equal to 1. To distinguish from thegroup of the left frame, we sometimes call it the full modular group.The matrices in the (smaller) modular group of the left picture are justthose matrices with integer entries for which <span class="math inline">\(q\)</span> and <span class="math inline">\(r\)</span> are even and <span class="math inline">\(p\)</span> and <span class="math inline">\(s\)</span> are odd.</p></div><p>这三个矩阵的元素都是整数，此现象绝非偶然。<a href="#fig-7.9">图7.9</a>右侧的复杂图像完整呈现了左侧密铺图案的所有对称性。每个理想三角形都被剖分为三个阴影子三角形和三个非阴影子三角形。（这些子三角形并不完全是理想的，因为它们只有一个角为0）。从莫比乌斯变换的角度来看，这个更复杂的密铺结构的对称群是最简单的：即所有元素为整数且行列式<span class="math inline">\(ps-qr\)</span> 等于 1 的 <span class="math inline">\(2\times2\)</span> 矩阵 <span class="math inline">\(\begin{pmatrix}p&amp;q\\r&amp;s\end{pmatrix}\)</span>构成的集合。为了与左图的对称群区分开来，该群常被称为全模群。而左侧密铺对应的（较小）模群则由满足特殊同余条件的整数矩阵构成——其<span class="math inline">\(q\)</span> 与 <span class="math inline">\(r\)</span> 元素都是偶数，<span class="math inline">\(p\)</span> 与 <span class="math inline">\(s\)</span> 元素都是奇数。</p><div class="statement simple plain unnumbered"><p>There is a very beautiful connection between the modular tessellationand fractions: the points where the ideal triangles meet the real axisare exactly the rational numbers. Although it is something of adigression here, we want to take the time to explain the pattern, whichturns out to be indispensible when we come to map making in Chapter9.</p></div><p>模镶嵌与有理数之间有着极为精妙的联系：理想三角形与实轴交点恰恰是有理数。虽然这一内容在此略显偏离主题，但我们希望花些时间来阐明这个规律，因为它在第9 章的制图过程中将变得至关重要。</p><figure id="fig-7.10"><img src="/images/indra/fig-7.10.jpg" width="600" alt="Figure 7.10. The modular tiling from our ancestral home. The tessellation generated by the full modular group, conjugated over to the unit disk. This beautiful rendition is Figure 35 in Vol. 1 of Vorlesungen äber elliptischen Modulfunctionen by Klein and Fricke. 图 7.10. 来自我们祖居的模密铺。由完整模群生成的镶嵌图案，经共轭映射到单位圆盘上。这幅美丽的图像是克莱因和弗里克所著《椭圆模函数讲义》第一卷中的图 35。"><figcaption aria-hidden="true">Figure 7.10. The modular tiling from ourancestral home. The tessellation generated by the full modular group,conjugated over to the unit disk. This beautiful rendition is Figure 35in Vol. 1 of Vorlesungen äber elliptischen Modulfunctionen by Klein andFricke.<br>图 7.10.来自我们祖居的模密铺。由完整模群生成的镶嵌图案，经共轭映射到单位圆盘上。这幅美丽的图像是克莱因和弗里克所著《椭圆模函数讲义》第一卷中的图35。</figcaption></figure><div class="statement simple plain unnumbered"><p>Figure 7.11 shows the first few levels in the modular tessellation.The basic tile is the four-sided region, called an ideal quadrilateral,which was bounded by the coloured lines in Figure 7.9. Images of thisideal quadrilateral are shown bounded by solid arcs. The dotted arcsdivide them into the two ideal triangles which we saw, half hatched andhalf white, on the left in Figure 7.9. As the group acts on the basictile, we get more and more smaller and smaller tiles nesting down to thereal axis. The vertices of all these tiles meet the real axis in pointswhich are all fractions. Several things can be read off from a carefulexamination of this intricate pattern:</p><ul><li>All vertices of the tiles are rational numbers <span class="math inline">\(p/q\)</span>.</li><li>If <span class="math inline">\(r/s\)</span> and <span class="math inline">\(p/q\)</span> are two vertices of the same tile,then <span class="math inline">\(ps - rq = \pm 1\)</span>.</li><li>If <span class="math inline">\(r/s &lt; p/q\)</span> are the outertwo vertices of a tile, then the third vertex between them is <span class="math inline">\((r + p)/(s + q)\)</span>.</li></ul><p>Check this out! For instance, between <span class="math inline">\(2/3\)</span> and <span class="math inline">\(1/2\)</span>, we get <span class="math inline">\((2 + 1)/(3 + 2)\)</span>, that is <span class="math inline">\(3/5\)</span>.</p></div><p><a href="#fig-7.11">图 7.11</a>展示了模镶嵌的前几个层级。基本瓷砖是一个四边形，称为理想四边形，它由 <a href="#fig-7.9">图 7.9</a>中的彩色线条围成。实线弧显示了这个理想四边形的图像，而虚线弧将其分割成两个理想三角形，这两个三角形可以在<a href="#fig-7.9">图 7.9</a>的左侧看到，一半是阴影，一半是空白。随着群对基本瓷砖的作用，我们得到越来越多、越来越小的瓷砖，逐层嵌套，直至延伸到实轴。所有这些瓷砖的顶点都与实轴相交，这些交点都是分数。仔细观察这个复杂的图案，我们可以得出以下几个结论：</p><ul><li>所有瓷砖的顶点都是有理数 <span class="math inline">\(p/q\)</span>。</li><li>如果 <span class="math inline">\(r/s\)</span> 和 <span class="math inline">\(p/q\)</span> 是同一瓷砖的两个顶点，则 <span class="math inline">\(ps - rq = \pm 1\)</span>。</li><li>如果 <span class="math inline">\(r/s &lt; p/q\)</span>是同一瓷砖的两个外顶点，那么它们之间的第三个顶点是 <span class="math inline">\((r + p)/(s + q)\)</span>。</li></ul><p>验证一下吧！比如，在 <span class="math inline">\(2/3\)</span> 和<span class="math inline">\(1/2\)</span> 之间，我们得到 <span class="math inline">\((2 + 1)/(3 + 2)\)</span>，即 <span class="math inline">\(3/5\)</span>。</p><div class="statement simple plain unnumbered"><p>It’s easy to see why this happens. As we have seen, a typical matrixin the modular group will look like</p><p><span class="math display">\[M = \begin{pmatrix} p &amp; q \\ r &amp;s \end{pmatrix}\]</span></p><p>where <span class="math inline">\(p, q, r\)</span> and <span class="math inline">\(s\)</span> are integers and <span class="math inline">\(ps - rq = 1\)</span>. If <span class="math inline">\(M\)</span> acts on the vertices of the initialtriangle with vertices <span class="math inline">\(0 = 0/1, 1 =1/1\)</span> and <span class="math inline">\(\infty = 1/0\)</span>, thenwe get the new triangle with vertices <span class="math inline">\(M(0) =r/s, M(\infty) = p/q\)</span> and <span class="math inline">\(M(1) = (p+ r)/(q + s)\)</span>. Assuming all four entries are positive, we have<span class="math inline">\(r/s &lt; (p + r)/(q + s) &lt; p/q\)</span>(you can see this by multiplying out). This is just what we found inFigure 7.11. If <span class="math inline">\(p, q, r, s\)</span> are notall positive, there are half a dozen other cases in which the order ofthe points <span class="math inline">\(M(0), M(1)\)</span> and <span class="math inline">\(M(\infty)\)</span> is different but we get thesame result. The same thing happens if we start from the other triangle<span class="math inline">\(M(-1), M(0), M(\infty)\)</span>.</p></div><p>这个现象不难理解。我们知道，模群中的一个典型矩阵可以表示为 <span class="math display">\[M = \begin{pmatrix} p &amp; q \\ r &amp; s\end{pmatrix},\]</span> 其中 <span class="math inline">\(p, q,r\)</span> 和 <span class="math inline">\(s\)</span> 是整数，且满足<span class="math inline">\(ps - rq = 1\)</span>。如果矩阵 <span class="math inline">\(M\)</span>作用于初始三角形的顶点，该初始三角形的顶点分别是 <span class="math inline">\(0 = 0/1, 1 = 1/1\)</span> 和 <span class="math inline">\(\infty =1/0\)</span>，那么变换后的新三角形的顶点将变成 <span class="math inline">\(M(0) = r/s, M(\infty) = p/q\)</span> 和 <span class="math inline">\(M(1) = (p + r)/(q + s)\)</span>。假设 <span class="math inline">\(p,q,r,s\)</span> 都是正数，我们可以验证不等式<span class="math inline">\(r/s &lt; (p + r)/(q + s) &lt; p/q\)</span>成立（通过乘法可轻松验证）。这正是 <a href="#fig-7.11">图 7.11</a>所示的情况。如果 <span class="math inline">\(p, q, r, s\)</span>并非全为正数，还有几种不同的情形，此时点 <span class="math inline">\(M(0), M(1), M(\infty)\)</span>的顺序可能会改变，但结果仍然一致。类似地，若从另一个三角形 <span class="math inline">\(M(-1), M(0), M(\infty)\)</span>出发，也会得到相同的结论。</p><div class="statement simple plain unnumbered"><p>Any two fractions <span class="math inline">\(r/s\)</span> and <span class="math inline">\(p/q\)</span> such that <span class="math inline">\(ps - qr = \pm 1\)</span> are called neighbours.Thus any two vertices of an ideal triangle in the modular tessellationare neighbours. If <span class="math inline">\(p/q\)</span> is afraction, then, as we explain in Project 7.5, the process of finding itsneighbours is essentially Euclid’s two thousand year old algorithm forfinding the highest common factor of two numbers, surely one of the mostuseful and clever algorithms of all time. The rule for finding the‘next’ point <span class="math inline">\(\frac{p+r}{q+s}\)</span>between two neighbours is every student’s dream of what addition offractions should be. This simple form of fraction ‘addition’ issometimes called Farey addition’, which one might want to symbolise witha funny symbol like:</p><p><span class="math display">\[\frac{p}{q} \oplus \frac{r}{s} = \frac{p + r}{q + s}\]</span></p><p>Farey addition gives a neat way of organising the rational numbers.Instead of the usual way of arranging them in increasing order (which isdifficult, because you never know which one should come ‘next’),fractions can be described by a sequence of left or right moves,reflecting the choice at each stage of whether we choose the new pair ofneighbours to the right, or the pair of neighbours to the left.</p></div><p>任何两个分数 <span class="math inline">\(r/s\)</span> 和 <span class="math inline">\(p/q\)</span>，若满足 <span class="math inline">\(ps - qr = \pm1\)</span>，则称它们为邻居。因此，模群镶嵌中的理想三角形的任意两个顶点都是邻居。如果<span class="math inline">\(p/q\)</span> 是一个分数，那么正如我们在项目7.5中所解释的那样，寻找其邻居的过程，本质上就是欧几里得两千年前发明的最大公约数算法——这无疑是人类历史上最实用、最巧妙的算法之一。计算两个邻居之间“下一个”点<span class="math inline">\(\frac{p+r}{q+s}\)</span>的规则，正是每个学生心目中理想的分数加法方式。这种简单的分数“加法”有时被称为“法雷加法”（Fareyaddition），人们或许会用一个有趣的符号来表示它，比如： <span class="math display">\[\frac{p}{q} \oplus \frac{r}{s} = \frac{p + r}{q + s}\]</span></p><p>法雷加法提供了一种巧妙的方式来组织有理数。不像按递增顺序排列那样麻烦（毕竟你很难确定下一个该是谁），分数可以通过一系列左移或右移的操作来描述，这正对应了我们在每一步中选择将新的邻居对放置在左边还是右边的决定。</p><div class="statement simple plain unnumbered"><p>For positive fractions, the starting point are the two fractions<span class="math inline">\(0/1\)</span> and <span class="math inline">\(1/0\)</span>, which we can regard as specialhonourary neighbours because they are connected by a side of our initialtriangle, the vertical imaginary axis. Farey addition gives thein-between fraction <span class="math inline">\(0/1\oplus1/0=1/1\)</span>.</p><p>Now we have a choice: go to the ‘left’ and look in the intervalbetween 0 and 1, or go to the ‘right’ and look in the interval between 1and <span class="math inline">\(\infty\)</span>. Suppose we are aimingfor the fraction <span class="math inline">\(3/5\)</span>. Then we turnto the left and apply the Farey addition <span class="math inline">\(0/1\oplus 1/1 = 1/2\)</span>. At the next stage, we choose the rightinterval and Farey add to get <span class="math inline">\(1/2 \oplus 1/1= 2/3\)</span>. Finally, we choose the left interval and Farey add <span class="math inline">\(1/2 \oplus 2/3 = 3/5\)</span>. An exactly similarprocedure could be applied to home in on any fraction <span class="math inline">\(p/q\)</span>. Our choice of left-right turns is adriving map: <span class="math inline">\(3/5\)</span> is given by theinstructions ‘left, right, left’. This arrangement of fractions andsequence of right-left moves is closely related to a way of writingfractions as what are called continued fractions, explained in Note7.2.</p></div><p>对于正分数，我们的起点是两个特殊的分数：<span class="math inline">\(0/1\)</span> 和 <span class="math inline">\(1/0\)</span>。我们不妨将它们视作“荣誉邻居”，因为它们由初始三角形的一条边——垂直的虚轴——连接在一起。利用Farey 加法，我们可以在它们之间找到一个中间分数：<span class="math inline">\(0/1 \oplus 1/0 = 1/1\)</span>。</p><p>接下来，我们需要做出选择：向“左”走，查看 0 到 1之间的区间；还是向“右”走，查看 1 到 <span class="math inline">\(\infty\)</span> 之间的区间。假设我们的目标是分数<span class="math inline">\(3/5\)</span>。那么我们选择向左，执行 Farey加法：<span class="math inline">\(0/1 \oplus 1/1 =1/2\)</span>。在下一步，我们转向右侧区间，并执行 Farey 加法得到：<span class="math inline">\(1/2 \oplus 1/1 =2/3\)</span>。最后，我们再次选择左侧区间，进行 Farey 加法：<span class="math inline">\(1/2 \oplus 2/3 = 3/5\)</span>。</p><p>通过完全相同的步骤，我们可以找到任意分数 <span class="math inline">\(p/q\)</span>。我们每次选择向左或向右的决策就像一张“导航图”：例如，分数<span class="math inline">\(3/5\)</span>对应的指令是“左、右、左”。这种分数的排列方式和左右转向的序列，与将分数表示为连分数的写法密切相关，详见注释7.2。</p><h2 id="the-pairing-pattern-of-the-modular-group">The pairing pattern ofthe modular group</h2><div class="statement simple plain unnumbered"><p>The modular group is a new kind of ‘necklace group’. It is still madeby pairing four tangent circles, and the only difference from thekissing Schottky groups we met in the last chapter is that thegenerators pair not opposite circles but adjacent ones. Whenever we havean arrangement of paired tangent circles like this, something like thenecklace condition on p.&nbsp;168 must still be true, but because we arepairing the circles in a different pattern, we can expect that differentelements must be parabolic to cause the image circles to shrink.</p></div><p>模群是一种新型的“项链群”。它同样由四个相切的圆配对构成，不同之处在于，生成元这次配对的不是相对的圆，而是相邻的圆。每当我们遇到这样的相切圆配对排列时，类似于第168页提到的“项链条件”仍然必须成立。不过，由于这次采用了不同的配对模式，我们可以预见，只有某些不同的元素变成抛物型时，映像圆才会缩小。</p><div class="statement simple plain unnumbered"><p>With the notation of the figure beside Box 20, we have <span class="math inline">\(a(P) = R\)</span> and <span class="math inline">\(b(R) = P\)</span>, so that the four tangencypoints of the circles are <span class="math inline">\(S =\text{Fix}(a)\)</span>, <span class="math inline">\(Q =\text{Fix}(b)\)</span>, <span class="math inline">\(P =\text{Fix}(ba)\)</span>, and <span class="math inline">\(R =\text{Fix}(ab)\)</span>. By similar reasoning to that in Chapter 6, inorder for the image circles near <span class="math inline">\(S\)</span>and <span class="math inline">\(Q\)</span> to shrink, the generators<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> must be parabolic. Moreover, <span class="math inline">\(ba\)</span> must also be parabolic, to make thecircles shrink at <span class="math inline">\(P\)</span>. Notice that<span class="math inline">\(ab\)</span> and <span class="math inline">\(ba\)</span> are conjugate (since <span class="math inline">\(b(ab)b^{-1} = ba\)</span>), so saying that <span class="math inline">\(ab\)</span> or <span class="math inline">\(ba\)</span> must be parabolic is really one andthe same thing. The wonderful thing is, that as we proved in Note 7.1,all groups with these three elements parabolic are automaticallyconjugate. This is so important to us that we summarize it in Box20.</p><p>Because the pattern of pairing circles is different, so is thearrangement in which the labelled circles are laid down in the plane.The Schottky circles in Figure 7.11 are labelled according to our usualrules, so for example, <span class="math inline">\(C_{ba}\)</span> stillmeans the image of circle <span class="math inline">\(C_a\)</span> underthe map <span class="math inline">\(b\)</span>. However, if you lookcarefully, you will see that the order of the circles along the line isnot the same as our original order round the boundary of the word treeon p.&nbsp;104. The labels can be read off in their correct order from therevised version in Figure 7.12. (To see this you will have to twiddlethe diagram around so the arrows from the vertex you are interested inare pointing ‘down’ rather than ‘up’.) There is a subtle difference fromour original word tree, because there the cyclic order round a vertexwas <span class="math inline">\(a,B,A,b\)</span> while now it is <span class="math inline">\(a,A,b,B\)</span>. The ramifications of thisseemingly minor change propagate down the tree.</p></div><p>根据盒 20 旁的图示，我们有 <span class="math inline">\(a(P) =R\)</span> 且 <span class="math inline">\(b(R) =P\)</span>，因此四个切点分别是：<span class="math inline">\(S =\text{Fix}(a)\)</span>, <span class="math inline">\(Q =\text{Fix}(b)\)</span>, <span class="math inline">\(P =\text{Fix}(ba)\)</span> 和 <span class="math inline">\(R =\text{Fix}(ab)\)</span>。类似于第 6 章的推理，为了使靠近 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(Q\)</span> 的映像圆缩小，生成元 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 必须是抛物型的。此外，<span class="math inline">\(ba\)</span> 也必须是抛物型的，才能确保圆在 <span class="math inline">\(P\)</span> 处缩小。需要注意的是，<span class="math inline">\(ab\)</span> 和 <span class="math inline">\(ba\)</span> 是共轭的（因为 <span class="math inline">\(b(ab)b^{-1} = ba\)</span>），因此说 <span class="math inline">\(ab\)</span> 或 <span class="math inline">\(ba\)</span>必须是抛物型的，实际上是同一回事。奇妙的是，正如我们在注释 7.1中所证明的，所有包含这三个抛物型元素的群自动共轭。这一点对我们来说非常重要，因此我们在图20 中专门进行了总结。</p><p>由于配对圆的模式不同，标记圆在平面上的排列方式也随之改变。<a href="#fig-7.11">图 7.11</a> 中的 Schottky圆仍按照我们通常的规则标记，例如，<span class="math inline">\(C_{ba}\)</span> 依然表示圆 <span class="math inline">\(C_a\)</span> 在映射 <span class="math inline">\(b\)</span>下的像。然而，如果你仔细观察，就会发现这些圆沿着直线的排列顺序与我们最初在边界上的顺序并不相同。</p><h1 id="playing-with-parameters">Playing with parameters</h1><div class="statement simple plain unnumbered"><p>I could spin a web if I tried.’ said Wilbur, boasting. ‘Ive justnever tried.’</p><p>‘Let’s see you do it,’ said Charlotte…</p><p>‘OK.’ replied Wilhur. ‘You coach me and I’t’ spin one. It must be alot of fun to spill a web. How do I start?</p><p>“要是我愿意，我也能织网。”威尔伯吹嘘道，“只是我从来没试过。”</p><p>“那你来织一个给我们看看吧。”夏洛特说。</p><p>“好啊。”威尔伯答道，“你来指导我，我就织一个。织网一定很好玩。我该怎么开始呢？”</p></div><div class="statement simple plain unnumbered"><p>As any mathematician who has revealed his (or her) occupation to aneighbour on a plane flight has discovered, most people associatemathematics with something akin to the more agonizing forms of medievaltorture. It seems indeed unlikely that mathematics would be done at all,were it not that a few people discover the play that lies at its heart.Most published mathematics appears long after the play is done, cloakedin lengthy technicalities which obscure the original fun. The book inhand is unfortunately scarcely an exception. Never mind; after a fairlydetailed introduction to the art of creating tilings and fractal limitsets out of two very carefully chosen Möbius maps, we are finally set toembark on some serious mathematical play. The greatest rewards will bereaped by those who invest the time to set up their own programs andjoin us charting mathematical territory which is still only partiallyexplored.</p></div><p>正如任何一位曾在飞机上向邻座透露自己职业的数学家都会发现的那样，大多数人对数学的印象，似乎与某种中世纪酷刑的痛苦体验无异。倘若不是有少数人发现了数学的核心妙趣，数学恐怕早已无人问津。大多数已发表的数学成果，往往是在趣味探索结束许久之后才浮出水面的，而那些冗长繁复的技术细节，往往掩盖了最初的乐趣。遗憾的是，手头的这本书也未能完全例外。不过，别担心——在颇为详尽地介绍了如何用两个精心挑选的莫比乌斯变换来构造密铺图案和分形极限集之后，我们终于可以开始一场真正的数学探险了。那些愿意投入时间亲手编写程序、与我们一道探索这片尚未完全揭示的数学版图的读者，定将收获最丰厚的回报。</p><div class="statement simple plain unnumbered"><p>All the limit sets we have constructed thus far began from a specialarrangement of four circles, the Schottky circles, grouped into twopairs. For each pair, we found a Möbius map which moved the inside ofone circle to the outside of the other. Our initial tile was the regionoutside these four circles. By iterating, we produced a tiling whichcovered the the plane minus the limit set, near which the tiles shrankto minute size. Depending on how we chose the initial Schottky circles,the limit set was either fractal dust, a very crinkled fractal loop wecalled a quasicircle or, in certain very special cases, a truecircle.</p></div><p>迄今为止，我们构造的所有极限集都源自四个圆的独特排列，这些圆被称为肖特基圆，分为两对。对于每一对圆，我们找到一个莫比乌斯映射，将一个圆的内部映射到另一个圆的外部。我们的初始瓷砖是这四个圆外部的区域。通过不断迭代，我们生成了一种密铺，覆盖了平面上除了极限集以外的区域，在极限集附近，瓷砖逐渐缩小至微不可见的尺寸。根据我们选择的初始肖特基圆的不同，极限集可能呈现为分形尘埃，或者是我们称之为拟圆的极度扭曲的分形环，亦或在某些极其特殊的情况下，成为一个真正的圆。</p><div class="statement simple plain unnumbered"><p>The problem with this approach is that it is just too time-consumingto set up the circles and maps which pair them. Free-spirited playshouldn’t be ruined by too much preparation. Why not throw the Schottkycircles away, take any pair of <span class="math inline">\(2\times2\)</span> matrices for our generators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, run our limit point plotting program,and see what we get?</p><p>Hold on though - how exactly will this work? The shrinking disks wereso reassuring, and the limit set was so comfortably nestled within them,that it is hard to see why we won’t get chaos in their absence. Nomatter, the worst that is likely to happen is that the hard diskcrashes, so why not give it a try? Luckily, on p.&nbsp;182 ff.&nbsp;we alreadyupgraded the DFS code to remove the calculation of Schottky disks fromthe branch termination procedure. All we need do is take the plunge andrun the very same algorithm for any pair of transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</p></div><p>这个方法的弊端在于，设置这些圆及其配对映射实在太耗时了。自由随性的探索不应该被繁杂的准备工作束缚住手脚。为什么不干脆抛开Schottky 圆，随便挑一对 <span class="math inline">\(2 \times 2\)</span>矩阵作为我们的生成元 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，然后直接运行极限点绘图程序，看看会蹦出什么结果呢？</p><p>不过，先别急——这真的行得通吗？那些嵌套收缩的圆盘曾给予我们清晰的秩序感，极限集恰如其分地安居其中。若失去这种结构约束，系统难道不会陷入混沌？但没关系，最糟糕的结果不过是硬盘崩溃罢了，那为什么不试试看呢？</p><p>幸运的是，在第 182 页及后续章节中，我们已经对 DFS算法进行改良，去掉了分支终止判定中对 Schottky圆盘的计算。我们所需要的，只有一股冲劲——运行同样的算法，随便选一对变换<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，放手一试就好。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Reaction-Diffusion simulation with pyglet and glsl</title>
      <link href="/grayscott/index.html"/>
      <url>/grayscott/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/grayscott">Thisproject</a> is motivated by <a href="http://pmneila.github.io/jsexp/grayscott/">pmneila’s javascriptproject</a>. The core part of the code are the two GLSL shaders<code>reaction.frag</code> and <code>render.frag</code>. The pythonscripts are merely for setting the UI and compiling the GLSL code.</p><blockquote><p>Requirements: <code>pyglet</code> for the UI and OpenGL environmentand <code>ffmpeg</code> for saving the animation to video files.</p></blockquote><h1 id="examples">Examples</h1><ol type="1"><li><p>Unstable</p><p><video src="/images/grayscott/unstable.mp4" controls=""></video></p></li><li><p>Coral</p><p><video src="/images/grayscott/coral.mp4" controls=""></video></p></li><li><p>Baceria</p><p><video src="/images/grayscott/bacteria.mp4" controls=""></video></p></li></ol><h1 id="usage">Usage</h1><p>You may simply run <code>python main.py</code> and then use keyboardand mouse to play with the simulation (for keyboard and mouse controlplease see the printed doc).</p><p>You may also initialize the window by passing more options:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python main.py -size 800x600 -fps 400 -conf 1 -scale 2<br></code></pre></td></tr></tbody></table></figure><p>Here <code>-size</code> is the size of the window, <code>-fps</code>is the frames per second of the animation, if not specified then maxpossible value will be used, <code>-conf</code> is the line number ofthe pattern that the program will load from the file<code>config.txt</code> (which contains a few precomputed patterns),<code>-scale</code> is the “resolution” factor of the texture.</p><p>You may also use an image file to control the growth of the patternby adding the <code>-mask</code> option:</p><video src="/images/grayscott/mask.mp4" controls=""><h1 id="how-to-save-the-animation-to-a-video-file">How to save theanimation to a video file</h1><p>Make sure <code>ffmpeg</code> is installed on your computer and canbe found on system path, windows users need to manually add the path toyour ffmpeg.exe to environment variables, then press <code>ctrl+v</code>to start saving the video and press <code>ctrl+v</code> again to stopthe saving.</p><p>You can use the option <code>-videorate</code> to control the fps ofthe video (not the animation!) and the option <code>-samplerate</code>to control how often a frame is sampled from the animation. If theframes are sampled too frequently the size of the video file will growvery large.</p><h1 id="about-the-code">About the code</h1><p><code>pyglet</code> is only a thin wrapper of OpenGL so one has towrite his own classes to manage things like <code>vao</code>,<code>vbo</code>, <code>framebuffer</code>, etc. There are some moduleslike <code>vispy</code> and <code>gletools</code> that does similar job,but that lays the burden of learning one more package.</p><p>I wrote two scripts <code>shader.py</code> and<code>framebuffer.py</code> for compiling the shader programs andrendering to texture. They are not meant to be serious tools, just keptsimple and suffice for our work.</p><p>The GLSL code borrows heavily from pmneila’s work, the most geniuspart in his code is the use of a <code>brush</code> variable(<code>u_mouse</code> in our program) as the interface between theshader and the UI.</p></video>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（三）：Tits 锥</title>
      <link href="/coxeter-groups/tits-cone.html"/>
      <url>/coxeter-groups/tits-cone.html</url>
      
        <content type="html"><![CDATA[<p>本文主要参考了 Bob Howlett 教授的讲义 <span class="citation" data-cites="Howlett-note">(<a href="#ref-Howlett-note" role="doc-biblioref">Howlett 1996</a>)</span>。</p><h1 id="tits-锥">Tits 锥</h1><p>在获得了 <span class="math inline">\(V\)</span>中关于根系的一些知识后，我们下面转移到 <span class="math inline">\(V\)</span> 的对偶空间 <span class="math inline">\(V^\ast\)</span> 中讨论万花筒的结构。</p><span id="more"></span><p>设 <span class="math inline">\(V^\ast\)</span> 是 <span class="math inline">\(V\)</span> 的对偶空间，<span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 之间存在自然的双线性映射 <span class="math display">\[V\times V^\ast\to\mathbb{R}: \langlev,\,f\rangle= f(v).\]</span> 注意 <span class="math inline">\(\langle\,,\,\rangle\)</span> 和内积 <span class="math inline">\((\cdot,\cdot)\)</span> 的区别：<span class="math inline">\(\langle \,,\,\rangle\)</span> 是 <span class="math inline">\(V\times V^\ast\)</span>的自然配对，用尖括号表示；<span class="math inline">\((\cdot,\cdot)\)</span> 是 <span class="math inline">\(V\)</span> 上的内积。</p><p><span class="math inline">\(V\)</span> 上的可逆线性变换 <span class="math inline">\(g\in\mathrm{GL}(V)\)</span> 同样作用在 <span class="math inline">\(V^\ast\)</span> 上：对 <span class="math inline">\(f\in V^\ast\)</span>，线性泛函 <span class="math inline">\(g\cdot f\)</span> 定义为 <span class="math display">\[(g\cdot f)(v) = f(g^{-1} v).\]</span>为了简便我们省略 <span class="math inline">\(g\cdot f\)</span> 中的<span class="math inline">\(\cdot\)</span>，把它写作 <span class="math inline">\(gf\)</span>。</p><p>这样定义的目的是为了让 <span class="math inline">\(g\)</span>保持双线性映射 <span class="math inline">\(\langle \,,\,\rangle\)</span>不变： <span class="math display">\[\langle gv,\,gf\rangle = \langlev,\,f\rangle.\]</span> 用 <span class="math inline">\(g^{-1}f\)</span>代替 <span class="math inline">\(f\)</span>，我们得到 <span class="math display">\[\langle gv,\,f\rangle = \langlev,\,g^{-1}f\rangle.\]</span> 特别当 <span class="math inline">\(g=s\)</span> 是一个反射时，由于 <span class="math inline">\(s=s^{-1}\)</span> 所以 <span class="math display">\[\langle sv,\,f\rangle = \langlev,\,sf\rangle.\]</span> 这种将单个反射在 <span class="math inline">\((\cdot,\cdot){\,}{}\)</span>两边「跳来跳去」的技巧后面会经常用到。</p><p>由于 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 互为对偶空间，所以 <span class="math inline">\(\Delta=\{\alpha_s\}\)</span> 是 <span class="math inline">\(V^\ast\)</span>上的一组线性无关的泛函，定义它们的正半空间的交为 <span class="math display">\[\mathcal{D}= \bigcap_{s\in S}\{x\in V^\ast\mid\langle \alpha_s,\,x\rangle &gt; 0\}.\]</span> <span class="math inline">\(\mathcal{D}\)</span> 总是 <span class="math inline">\(V^\ast\)</span> 中的非空开集，其闭包记作 <span class="math inline">\(\overline{\mathcal{D}}\)</span>。你可以把 <span class="math inline">\(\mathcal{D}\)</span>理解为万花筒中被镜子围起来的原像房间，超平面的集合 <span class="math inline">\(\{\alpha_s=0\}\)</span> 是房间的墙壁。<span class="math inline">\(\overline{\mathcal{D}}\)</span> 就是 <span class="math inline">\(\mathcal{D}\)</span> 加上了房间四周的墙壁。</p><p><span class="math inline">\(W\)</span> 也作用在 <span class="math inline">\(V^\ast\)</span> 上： <span class="math display">\[\langle v,\,w f\rangle = \langlew^{-1}v,\,f\rangle.\quad v\in V,\,f\in V^\ast.\]</span> 在 <a href="/coxeter-groups/root-system/#faithful">上文</a> 中我们已经证明了<span class="math inline">\(W\)</span> 忠实地作用在 <span class="math inline">\(V\)</span> 上。不难验证在此定义下，<span class="math inline">\(W\)</span> 也忠实地作用在 <span class="math inline">\(V^\ast\)</span> 上，即若 <span class="math inline">\(wf=f\)</span> 对任何 <span class="math inline">\(f\in V^\ast\)</span> 成立，则 <span class="math inline">\(w=1\)</span>。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>Tits 锥定义为<span class="math display">\[\mathcal{C}= \bigcup_{w\in W}w\overline{\mathcal{D}}.\]</span></p></div><p>显然 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(W\)</span>- 不变的。<span class="math inline">\(\mathcal{C}\)</span>可以理解为万花筒，它由原像房间 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 在 <span class="math inline">\(W\)</span> 下的所有虚像构成。</p><p>读者可能有疑问为什么 Tits 锥位于对偶空间 <span class="math inline">\(V^\ast\)</span> 中。看起来更自然的做法是，直接取以<span class="math inline">\(\Delta\)</span>为法向量的正半空间之交作为基本区域： <span class="math display">\[\mathcal{D}=\bigcap_{s\in S}\{v\inV\mid(\alpha_s, v)&gt;0\}\]</span> 在内积 <span class="math inline">\((\cdot,\cdot)\)</span>非退化时，这样做是可以的；但是在 <span class="math inline">\((\cdot,\cdot)\)</span> 退化时，这样定义可能导致<span class="math inline">\(\mathcal{D}\)</span> 是空集。以仿射 <span class="math inline">\(\widetilde{A_1}\)</span> 为例，它的 Coxeter 矩阵是<span class="math display">\[\begin{pmatrix}1 &amp;\infty\\\infty&amp;1\end{pmatrix}.\]</span> 在 <span class="math inline">\(a_{s,t}=1\)</span> 时对应的 Gram 矩阵是 <span class="math display">\[\begin{pmatrix}1&amp;-1\\-1&amp;1\end{pmatrix}.\]</span>设 <span class="math inline">\(v=a\alpha_s+b\alpha_t\)</span> 满足 <span class="math inline">\((v,\alpha_s)&gt;0\)</span> 且 <span class="math inline">\((v,\alpha_t)&gt;0\)</span>，你会发现这要求 <span class="math inline">\(a&gt;b\)</span> 且 <span class="math inline">\(b&gt;a\)</span>，即 <span class="math inline">\(\mathcal{D}\)</span> 是空集！但是通过区分 <span class="math inline">\(W\)</span> 在 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 上的作用就可以避免这个问题。因为<span class="math inline">\(\Delta\)</span> 作为 <span class="math inline">\(V\)</span> 的一组基构成 <span class="math inline">\(V^\ast\)</span> 上一组线性无关的泛函，它们在 <span class="math inline">\(V^\ast\)</span>中正半空间的交是非空的拓扑开集。</p><p>读者可能注意到了：我们使用了 Tits 锥这个称呼，但 <span class="math inline">\(\mathcal{C}\)</span>真的是一个锥吗？这可不显然。要证明 <span class="math inline">\(\mathcal{C}\)</span>确实是锥，我们需要它的另一种等价刻画。</p><p>我们回顾锥的定义：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(C\)</span> 是某实向量空间的子集。如果对任何实数<span class="math inline">\(\alpha\geq0\)</span> 都有 <span class="math inline">\(\alpha C\subset C\)</span>，就称 <span class="math inline">\(C\)</span> 是一个<strong>锥</strong>。如果 <span class="math inline">\(C\)</span> 还是凸集，就称 <span class="math inline">\(C\)</span> 是<strong>凸锥</strong>。凸锥满足对任何<span class="math inline">\(x,y\in C\)</span> 和非负实数 <span class="math inline">\(\alpha,\beta\geq0\)</span>，<span class="math inline">\(\alpha x + \beta y\)</span> 仍然属于 <span class="math inline">\(C\)</span>。</p></div><p>设 <span class="math inline">\(X\)</span>是某实向量空间的子集，定义其生成的凸锥为： <span class="math display">\[\mathrm{cone}(X) = \left\{\sum_{i=1}^n c_ix_i\midx_1,\ldots,x_n\in X,\, c_i\geq0.\right\}.\]</span> 显然 <span class="math inline">\(\mathrm{cone}(X)\)</span> 是包含 <span class="math inline">\(X\)</span> 的最小凸锥。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>当 <span class="math inline">\(X\)</span> 是有限集时，<span class="math inline">\(\mathrm{cone}(X)\)</span> 总是闭集；但是当 <span class="math inline">\(X\)</span> 是无限集时则未必。例如当 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(\mathbb{R}^2\)</span> 中直线 <span class="math inline">\(y=1\)</span> 上的全体整点时，<span class="math inline">\(\mathrm{cone}(X)=\{y&gt;0\}\cup\{0\}\)</span>不是闭集。</p></div><div id="fundamental-weights" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\Delta^\ast=\{\omega_t\}\subset V^\ast\)</span> 是<span class="math inline">\(\Delta\)</span> 的一组对偶基，满足 <span class="math inline">\(\langle\alpha_s,\,\omega_t\rangle=\delta_{st}\)</span>，<span class="math inline">\(\Delta^\ast\)</span>叫做<strong>基本权</strong>。记 <span class="math display">\[\Omega=\bigcup_{w\in W}w\Delta^\ast.\]</span><span class="math inline">\(\Omega\)</span>中的元素叫做<strong>权</strong>。</p></div><div id="fund-cone" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题1.4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\overline{\mathcal{D}}=\mathrm{cone}(\Delta^\ast)\)</span>。</p></div><p><strong>证明</strong>：任何 <span class="math inline">\(x\inV^\ast\)</span> 可以表示为 <span class="math inline">\(x=\sum_{s\inS}c_s\omega_s\)</span>，其中 <span class="math inline">\(c_s=\langle\alpha_s,\,x\rangle\)</span>，于是 <span class="math display">\[x\in\mathrm{cone}(\Delta^\ast)\Leftrightarrowc_s\geq0,\ \forall s \in S \Leftrightarrow \langle\alpha_s,\,x\rangle\geq 0,\ \forall s\in S \Leftrightarrowx\in\overline{\mathcal{D}}.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.5</span>.</span><span class="statement-spah"> </span>对任意 <span class="math inline">\(x\in V^\ast\)</span>，定义 <span class="math display">\[\mathrm{Neg}(x)= \{\lambda\in \Phi^+\mid \langle\lambda,\,x\rangle&lt;0\}.\]</span> <span class="math inline">\(\mathrm{Neg}(x)\)</span> 是正根 <span class="math inline">\(\Phi^+\)</span> 的子集，表示 <span class="math inline">\(x\)</span> 位于哪些镜子的「背面」。即这些镜子挡在<span class="math inline">\(x\)</span> 和基本区域 <span class="math inline">\(\mathcal{D}\)</span> 之间。</p></div><p>显然 <span class="math inline">\(\overline{\mathcal{D}}=\{x\inV^\ast\mid\mathrm{Neg}(x)=\emptyset\}\)</span>。</p><div id="tits-neg-finite" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.6</span>.</span><span class="statement-spah"> </span>Tits 锥 <span class="math inline">\(\mathcal{C}= \{x\in V^\ast \mid |\mathrm{Neg}(x)|&lt; \infty\}\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个定理的几何意义是，Tits 锥恰好由那些和基本区域 <span class="math inline">\(\overline{\mathcal{D}}\)</span>之间只隔着有限多个镜子的点组成，这样的点一定可以通过有限次单反射变换到<span class="math inline">\(\overline{\mathcal{D}}\)</span> 中，即下面的<code>while</code> 循环可以在有限次后结束：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> dot(x, alpha_s) &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> some s <span class="hljs-keyword">in</span> S:<br>    x = reflect(x, alpha_s)<br></code></pre></td></tr></tbody></table></figure><p>下面的动画展示了双曲 Coxeter 群 <span class="math inline">\(\Delta(3,3,7)\)</span> 的 Tits 锥中那些反射次数<span class="math inline">\(\leq10\)</span> 的点：</p><p><img src="/images/coxeter/337-anim.gif" class="fig" width="400"></p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>：设 <span class="math inline">\(x\in\mathcal{C}\)</span>，则 <span class="math inline">\(x\)</span> 可以表示为 <span class="math inline">\(x=wv\)</span>，其中 <span class="math inline">\(w\in W,v\in\overline{\mathcal{D}}\)</span>。设<span class="math inline">\(\lambda\in\mathrm{Neg}(x)\)</span>，则 <span class="math display">\[0&gt;\langle \lambda,\,x\rangle=\langle\lambda,\,wv\rangle=\langle w^{-1}\lambda,\,v\rangle.\]</span> 然而<span class="math inline">\(v\in\overline{\mathcal{D}}\)</span>，这说明<span class="math inline">\(w^{-1}\lambda\in\Phi^-\)</span>，从而 <span class="math inline">\(\mathrm{Neg}(x)\subseteq N(w^{-1})\)</span>，从而<span class="math display">\[|\mathrm{Neg}(x)|\leq|N(w^{-1})|=l(w)&lt;\infty.\]</span></p><p><span class="math inline">\(\Leftarrow\)</span>：反之若 <span class="math inline">\(|\mathrm{Neg}(x)|&lt;\infty\)</span>，我们来论证存在<span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(wx\in\overline{\mathcal{D}}\)</span>。这里的想法是，每次选择一个单根<span class="math inline">\(\alpha_s\)</span> 对应的镜面，使得 <span class="math inline">\(x\)</span> 落在这个镜子的背面，然后将 <span class="math inline">\(x\)</span> 关于 <span class="math inline">\(\alpha_s\)</span> 反射过去变到 <span class="math inline">\(\alpha_s\)</span> 的正面，这个操作会将遮挡在 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(\overline{\mathcal{D}}\)</span>之间的镜子个数严格减少 1。如此这般直到 <span class="math inline">\(x\)</span> 落入 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 为止。</p><p>具体论证如下：</p><p>若 <span class="math inline">\(\mathrm{Neg}(x)=\emptyset\)</span>，则<span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，结论显然成立。</p><p>若 <span class="math inline">\(\mathrm{Neg}(x)\ne\emptyset\)</span>，<span class="math inline">\(\mathrm{Neg}(x)\)</span> 中一定包含某个单根 <span class="math inline">\(\alpha_s\)</span>。考虑 <span class="math inline">\(x\)</span> 关于 <span class="math inline">\(\alpha_s\)</span> 的镜像 <span class="math inline">\(sx\)</span>，<span class="math inline">\(sx\)</span> 位于 <span class="math inline">\(\alpha_s\)</span> 的正面，所以 <span class="math inline">\(\alpha_s\notin\mathrm{Neg}(sx)\)</span>。于是对任何正根<span class="math inline">\(\lambda\in\mathrm{Neg}(sx)\)</span>，<a href="/coxeter-groups/root-system/#simple-ref"><span class="math inline">\(s\lambda\)</span> 仍然是正根且 <span class="math inline">\(s\lambda\ne\alpha_s\)</span></a>。对这样的 <span class="math inline">\(\lambda\)</span>，我们有 <span class="math display">\[0&gt;\langle \lambda,\,sx\rangle=\langles\lambda,\,x\rangle\Rightarrow s\lambda\in\mathrm{Neg}(x).\]</span>这说明 <span class="math display">\[s\cdot\mathrm{Neg}(sx)\subseteq\mathrm{Neg}(x)\setminus\{\alpha_s\}.\]</span>从而 <span class="math inline">\(\mathrm{Neg}(sx)\)</span>的元素个数严格小于 <span class="math inline">\(\mathrm{Neg}(x)\)</span>。</p><p>记 <span class="math inline">\(y=sx\)</span>，对 <span class="math inline">\(y\)</span> 重复此过程，我们可以逐步将 <span class="math inline">\(\mathrm{Neg}(y)\)</span> 减少为空集，即最终 <span class="math inline">\(y\)</span> 落在 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 中。于是存在 <span class="math inline">\(s_1,\ldots,s_k\)</span> 使得 <span class="math inline">\(y=(s_1\cdots s_k)\cdotx\in\overline{\mathcal{D}}\)</span>。取 <span class="math inline">\(w=s_1\cdots s_k\)</span>，则 <span class="math inline">\(x=w^{-1}y\in\mathcal{C}\)</span>。这就证明了结论。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-convex" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.7</span>.</span><span class="statement-spah"> </span>Tits 锥 <span class="math inline">\(\mathcal{C}\)</span> 是凸锥。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(x,y\in\mathcal{C}\)</span> 和 <span class="math inline">\(\alpha,\beta\geq0\)</span>，我们要证明 <span class="math inline">\(z=\alpha x+\beta y\in\mathcal{C}\)</span>。由于<span class="math display">\[\mathrm{Neg}(z)\subseteq\mathrm{Neg}(x)\cup\mathrm{Neg}(y),\]</span>根据 <a href="#tits-neg-finite" title="定理 1.6">定理 1.6</a>，<span class="math inline">\(\mathrm{Neg}(x),\,\mathrm{Neg}(y)\)</span>都是有限集，所以 <span class="math inline">\(\mathrm{Neg}(z)\)</span>也有限，从而 <span class="math inline">\(z\in\mathcal{C}\)</span>，即<span class="math inline">\(\mathcal{C}\)</span> 是凸锥。<span class="math inline">\(\blacksquare\)</span></p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.8</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathcal{C}=\mathrm{cone}(\Omega)\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(\Omega\supset\Delta^\ast\)</span>，以及根据 <a href="#fund-cone" title="命题 1.4">命题 1.4</a> 有 <span class="math inline">\(\mathrm{cone}(\Delta^\ast)=\overline{\mathcal{D}}\)</span>，所以<span class="math display">\[\mathrm{cone}(\Omega)\supset\mathrm{cone}(\Delta^\ast)=\overline{\mathcal{D}}.\]</span>又因为 <span class="math inline">\(\mathrm{cone}(\Omega)\)</span> 是<span class="math inline">\(W\)</span>- 不变的，所以它包含 <span class="math inline">\(\bigcup_{w\inW}w\overline{\mathcal{D}}=\mathcal{C}\)</span>。</p><p>另一方面 <span class="math inline">\(\mathcal{C}\supset\overline{\mathcal{D}}\supset\Delta^\ast\)</span>，并且<span class="math inline">\(\mathcal{C}\)</span> 也是 <span class="math inline">\(W\)</span>- 不变的，所以 <span class="math display">\[\mathcal{C}\supset\bigcup_{w\inW}w\Delta^\ast=\Omega.\]</span> 而 <a href="#tits-convex" title="推论 1.7">推论 1.7</a> 证明了 <span class="math inline">\(\mathcal{C}\)</span> 是凸锥，所以 <span class="math inline">\(\mathcal{C}\supset\mathrm{cone}(\Omega)\)</span>。<span class="math inline">\(\blacksquare\)</span></p><h1 id="tits-锥的内点">Tits 锥的内点</h1><p>接下来我们来讨论 <span class="math inline">\(\mathcal{C}\)</span>的内点集 <span class="math inline">\(\mathcal{C}^\circ\)</span>。我们将证明 <span class="math inline">\(\mathcal{C}^\circ\)</span>由那些稳定化子群是有限群的点组成： <span class="math display">\[\mathcal{C}^\circ = \{x\in V^\ast \mid|\mathrm{Stab}(x)| &lt; \infty\}.\]</span></p><div id="stabilizer-parabolic-subgroup" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span>对任何 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，记 <span class="math inline">\(J=\{s\in S \mid \langle\alpha_s,\,x\rangle=0\}\)</span>，则 <span class="math inline">\(\mathrm{Stab}(x) = W_J\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个定理的含义是，在原像房间 <span class="math inline">\(\overline{\mathcal{D}}\)</span>中，每个点的稳定化子群是一个标准椭圆子群，由包含该点的那些镜子生成。</p></div><p><strong>证明</strong>：</p><p>任取 <span class="math inline">\(s\in J\)</span> 和 <span class="math inline">\(v\in V\)</span>，我们有 <span class="math display">\[\langle v,\,sx\rangle = \langlesv,\,x\rangle=\langle v-2(v,\alpha_s)\alpha_s,\,x\rangle=\langlev,\,x\rangle.\]</span> 由 <span class="math inline">\(v\)</span>的任意性可得 <span class="math inline">\(sx=x\)</span>，从而 <span class="math inline">\(W_J\subseteq\mathrm{Stab}(x)\)</span>。</p><p>再证明反向包含关系。设 <span class="math inline">\(w=s_1\cdotss_k\in\mathrm{Stab}(x)\)</span> 是一个既约表示，我们从最末一个元素 <span class="math inline">\(s_k\)</span> 开始，向左逐个验证它们属于 <span class="math inline">\(J\)</span>。</p><p>记 <span class="math inline">\(w'=s_1\cdots s_{k-1}\)</span>，则<span class="math inline">\(l(ws_k)=l(w')&lt;l(w)\)</span>，于是<span class="math inline">\(w\alpha_k\in\Phi^-\)</span>。由于 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，我们有 <span class="math display">\[0\geq \langle w\alpha_k,\,x\rangle = \langle\alpha_k,\,w^{-1}x\rangle = \langle \alpha_k,\,x\rangle\geq0.\]</span>于是上面的不等式中等号都成立，从而 <span class="math inline">\(\langle\alpha_k,\,x\rangle=0\)</span>，即 <span class="math inline">\(s_k\inJ\)</span> 且 <span class="math inline">\(s_kx=x\)</span>。进一步 <span class="math inline">\(w'\)</span> 也满足 <span class="math inline">\(w'x=x\)</span>。对 <span class="math inline">\(w'\)</span> 重复此论证，便得到 <span class="math inline">\(s_1,\ldots,s_k\)</span> 都属于 <span class="math inline">\(J\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="fd-finite-stabilizer" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题2.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，则 <span class="math inline">\(x\in\mathcal{C}^\circ\)</span> 当且仅当 <span class="math inline">\(\mathrm{Stab}(x)\)</span> 是有限群。</p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>：思路：如果 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(\mathcal{C}\)</span> 的内点，并且经过 <span class="math inline">\(x\)</span> 的镜面有无穷多个，那么可以在 <span class="math inline">\(x\)</span> 的附近取一点 <span class="math inline">\(z\)</span>，<span class="math inline">\(z\)</span>仍然是 <span class="math inline">\(\mathcal{C}\)</span>的内点，使得这无穷多个镜子都挡在基本区域和 <span class="math inline">\(z\)</span> 之间，从而 <span class="math inline">\(\mathrm{Neg}(z)\)</span> 是无限集，从而 <span class="math inline">\(z\notin\mathcal{C}\)</span>，导致矛盾。</p><p>具体论证如下：</p><p>记 <span class="math inline">\(J\)</span> 和 <span class="math inline">\(W_J\)</span> 如 <a href="#stabilizer-parabolic-subgroup" title="定理 2.1">定理 2.1</a>，则<span class="math inline">\(\mathrm{Stab}(x)=W_J\)</span>。</p><figure><img src="/images/coxeter/WJ.svg" width="300" alt="一个示意图，z 落在所有 \Phi_J 中镜子的背面"><figcaption aria-hidden="true">一个示意图，<span class="math inline">\(z\)</span> 落在所有 <span class="math inline">\(\Phi_J\)</span> 中镜子的背面</figcaption></figure><p>任取 <span class="math inline">\(y\in\mathcal{D}\)</span>。由于 <span class="math inline">\(x\in\mathcal{C}^\circ\)</span>，所以在线段 <span class="math inline">\(\overline{[y, x]}\)</span> 上我们可以朝着 <span class="math inline">\(x\)</span> 的方向延伸一点点，得到点 <span class="math inline">\(z\)</span>，使得 <span class="math inline">\(z\)</span> 仍然位于 <span class="math inline">\(\mathcal{C}^\circ\)</span> 中。<span class="math inline">\(z\)</span> 可以表示为 <span class="math display">\[z=(1-t)x+ty,\quad t&lt;0.\]</span></p><p>于是对所有 <span class="math inline">\(s\in J\)</span> 都有 <span class="math inline">\(\langle \alpha_s,\,z\rangle=t\langle\alpha_s,\,y\rangle &lt; 0\)</span>，从而 <span class="math inline">\(\Phi_J^+\subset\mathrm{Neg}(z)\)</span>。如果<span class="math inline">\(W_J\)</span> 是无限群，那么 <span class="math inline">\(\Phi_J^+\)</span> 也无限，从而 <span class="math inline">\(\mathrm{Neg}(z)\)</span> 无限，这与 <span class="math inline">\(z\in\mathcal{C}\)</span> 矛盾！</p><p><span class="math inline">\(\Leftarrow\)</span>：反之若 <span class="math inline">\(W_J\)</span> 是有限群，仍然任取 <span class="math inline">\(y\in\mathcal{D}\)</span>。</p><figure><img src="/images/coxeter/WJ2.svg" width="300" alt="y 在 W_J 下的像全部位于镜面 \alpha_s=0 的正侧，故 \langle \alpha_s,\,wy\rangle 对 w\in W_J 总为正"><figcaption aria-hidden="true"><span class="math inline">\(y\)</span> 在<span class="math inline">\(W_J\)</span> 下的像全部位于镜面 <span class="math inline">\(\alpha_s=0\)</span> 的正侧，故 <span class="math inline">\(\langle \alpha_s,\,wy\rangle\)</span> 对 <span class="math inline">\(w\in W_J\)</span> 总为正</figcaption></figure><p>设 <span class="math inline">\(s\in S\setminus J\)</span>，则 <span class="math inline">\(\langle \alpha_s,\,x\rangle&gt;0\)</span>。对任何<span class="math inline">\(w\in W_J\)</span>，<a href="/coxeter-groups/root-system#remain-positive-root"><span class="math inline">\(w^{-1}\alpha_s\)</span> 仍然是正根</a>，所以 <span class="math display">\[\langle \alpha_s,\,wy\rangle=\langlew^{-1}\alpha_s,\,y\rangle&gt;0.\]</span> 于是 <span class="math display">\[\delta = \min\left\{\frac{\langle\alpha_s,\,x\rangle}{\langle \alpha_s,\,wy\rangle}\,\middle|\,\alpha_s\in S\setminus J,\, w\in W_J\right\}&gt;0.\]</span>将上面的分母乘到左边然后对 <span class="math inline">\(w\in W_J\)</span>求和，我们有 <span class="math display">\[\delta\cdot\langle\alpha_s,\,\sum_{w\in W_J}wy\rangle\leq \langle \alpha_s,\,x\rangle\cdot|W_J| &lt; 2\langle \alpha_s,\,x\rangle\cdot |W_J|,\quad s\in S\setminusJ.\tag{1}\label{eq:strict}\]</span> 注意这个不等式两边关于 <span class="math inline">\(\alpha_s\)</span> 都是线性的。</p><p>既然对 <span class="math inline">\(s\in S\setminus J\)</span>上面的不等式是严格的，那么对 <span class="math inline">\(s\in J\)</span>又如何呢？这时右边 <span class="math inline">\(\langle\alpha_s,\,x\rangle=0\)</span>。又因为 <span class="math inline">\(\sum_{w\in W_J}wy\)</span> 在 <span class="math inline">\(W_J\)</span> 下保持不动，所以根据 <a href="#stabilizer-parabolic-subgroup" title="定理 2.1">定理 2.1</a> 可得<span class="math inline">\(\langle \alpha_{s},\,\sum_{w\inW_J}wy\rangle=0\)</span>，从而上面的不等式变成了等式（两边都是 0）：<span class="math display">\[0=\delta\cdot\langle \alpha_s,\,\sum_{w\inW_J}wy\rangle= 2\langle \alpha_s,\,x\rangle\cdot |W_J|,\quad s\inJ.\tag{2}\label{eq:equal}\]</span> 对任何 <span class="math inline">\(\lambda\in\Phi^+\setminus\Phi_J^+\)</span>，设<span class="math display">\[\lambda=\sum_{s\in S\setminus J}c_s\alpha_s+ \sum_{t\in J}d_t\alpha_t,\quad c_s,\,d_t\geq0.\]</span> 其中至少有一项<span class="math inline">\(c_s\)</span> 严格大于 0。将 <span class="math inline">\(\lambda\)</span> 代入 <span class="math inline">\((\ref{eq:strict})\)</span> 中 <span class="math inline">\(\alpha_s\)</span> 的位置，严格不等式仍然成立。即<span class="math display">\[\delta\cdot\langle \lambda,\,\sum_{w\inW_J}wy\rangle&lt; 2\langle \lambda,\,x\rangle\cdot |W_J|.\]</span>注意对 <span class="math inline">\(w\in W_J\)</span>，<span class="math inline">\(w^{-1}\lambda\)</span> 作为 <span class="math inline">\(\lambda\)</span> 和 <span class="math inline">\(\{\alpha_s\mid s\in J\}\)</span>的线性组合仍然是正根，并且不在 <span class="math inline">\(\Phi_J^+\)</span> 中，所以上面的求和中每一项 <span class="math inline">\(\langle \lambda,\,wy\rangle=\langlew^{-1}\lambda,\,y\rangle&gt;0\)</span>，我们可以只取 <span class="math inline">\(w=1\)</span> 对应的项，其余全扔掉，得到 <span class="math display">\[\delta\cdot\langle \lambda,\,y\rangle&lt;2\langle \lambda,\,x\rangle\cdot |W_J|.\]</span> 记 <span class="math inline">\(z = 2|W_J|x - \delta y\)</span>，我们得到 <span class="math inline">\(\langle \lambda,\,z\rangle&gt;0\)</span> 对任何<span class="math inline">\(\lambda\in\Phi^+\setminus\Phi_J^+\)</span>成立。</p><p>另一方面对任何 <span class="math inline">\(\mu\in\Phi_J^+\)</span>，由于 <span class="math inline">\(\langle \mu,\,x\rangle=0\)</span>，所以 <span class="math inline">\(\langle \mu,\,z\rangle=-\delta\langle\mu,\,y\rangle&lt;0\)</span>，于是 <span class="math inline">\(\mathrm{Neg}(z)=\Phi_J^+\)</span> 是有限集，从而<span class="math inline">\(z\in\mathcal{C}\)</span>。</p><p>实际上我们有 <span class="math inline">\(z\in\mathcal{C}^\circ\)</span>，这是因为对任何<span class="math inline">\(\lambda\in\Phi\)</span>，<span class="math inline">\(\lambda\)</span> 必然属于 <span class="math inline">\(\pm\Phi^+_J,\pm(\Phi^+\setminus\Phi^+_J)\)</span>之一，而我们已经看到 <span class="math inline">\(\langle\lambda,\,z\rangle\)</span> 总不是 0，所以 <span class="math inline">\(z\)</span> 不落在任何镜面上。设 <span class="math inline">\(z=wv,\,v\in\overline{\mathcal{D}}\)</span>，那么<span class="math display">\[\langle \alpha_s,\,v\rangle=\langlew\alpha_s,\,wv\rangle=\langle w\alpha_s,\,z\rangle\ne0\]</span> 对任何<span class="math inline">\(\alpha_s\in\Delta\)</span> 成立，所以 <span class="math inline">\(v\in\mathcal{D}\subset\mathcal{C}^\circ\)</span>，从而<span class="math inline">\(z=wv\inw\mathcal{D}\subset\mathcal{C}^\circ\)</span>。</p><figure><img src="/images/coxeter/WJ3.svg" width="300" alt="我们证明 z 只落在 \Phi_J 中镜面的背面，从而 z\in\mathcal{C}；并证明 z 不属于任何镜面，从而 z\in\mathcal{C}^\circ"><figcaption aria-hidden="true">我们证明 <span class="math inline">\(z\)</span> 只落在 <span class="math inline">\(\Phi_J\)</span> 中镜面的背面，从而 <span class="math inline">\(z\in\mathcal{C}\)</span>；并证明 <span class="math inline">\(z\)</span> 不属于任何镜面，从而 <span class="math inline">\(z\in\mathcal{C}^\circ\)</span></figcaption></figure><p>现在 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(z\)</span> 和 <span class="math inline">\(y\)</span> 的线性组合 <span class="math inline">\(x = \frac{1}{2|W_J|}(z + \delta y)\)</span>。由于<span class="math inline">\(z,y\in\mathcal{C}^\circ\)</span> 而 <span class="math inline">\(\mathcal{C}\)</span> 是凸锥，所以 <span class="math inline">\(\frac{1}{2|W_J|}z,\frac{\delta}{2|W_J|}y\in\mathcal{C}^\circ\)</span>，即存在开集 <span class="math inline">\(A,B\)</span> 满足 <span class="math inline">\(\frac{1}{2|W_J|}z\inA\subset\mathcal{C}^\circ\)</span>，<span class="math inline">\(\frac{\delta}{2|W_J|}y\in B\subset\mathcal{C}^\circ\)</span>。于是 <span class="math inline">\(x\inA+B=\cup_{p\in B}(A+p)\)</span>，这是一组开集的并，每个 <span class="math inline">\(A+p\)</span> 都在 <span class="math inline">\(\mathcal{C}\)</span> 中，所以 <span class="math inline">\(x\in\mathcal{C}^\circ\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-int-finite-stabilizer" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(y\in\mathcal{C}\)</span>，则 <span class="math inline">\(y\in\mathcal{C}^\circ\)</span> 当且仅当 <span class="math inline">\(\mathrm{Stab}(y)\)</span> 是有限群。</p></div><p><strong>证明</strong>：<span class="math inline">\(y\)</span>可以写成 <span class="math inline">\(y=wx\,(w\inW,\,x\in\overline{\mathcal{D}})\)</span> 的形式，从而 <span class="math inline">\({\rm Stab}(y)=w{\rmStab}(x)w^{-1}\)</span>，二者同为有限群或者无限群；而且 <span class="math inline">\(x,y\)</span> 同时属于或者同时不属于 <span class="math inline">\(\mathcal{C}^\circ\)</span>。由 <a href="#fd-finite-stabilizer" title="命题 2.2">命题 2.2</a>即得结论。<span class="math inline">\(\blacksquare\)</span></p><h1 id="tits-锥的对偶锥">Tits 锥的对偶锥</h1><p>这一节来讨论 Tits 锥的对偶锥。研究对偶锥对理解 Tits锥本身的结构也很有帮助。</p><div id="dual-cone" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(C\)</span> 是 <span class="math inline">\(V\)</span> 中的一个锥，定义 <span class="math inline">\(C\)</span> 的对偶锥 <span class="math inline">\(C^\ast\in V^\ast\)</span> 为 <span class="math display">\[C^\ast = \{f\in V^\ast\mid f(v)\geq0,\ \forallv\in C\}.\]</span> 即 <span class="math inline">\(C^\ast\)</span>是对偶空间中那些在 <span class="math inline">\(C\)</span>上取值均非负的线性泛函组成的集合。</p></div><p>不难看出 <span class="math inline">\(C^\ast\)</span> 也构成 <span class="math inline">\(V^\ast\)</span>中的一个锥，所以我们又可以取其对偶锥 <span class="math inline">\(C^{\ast\ast}\subset V\)</span>。</p><div id="dual-dual-cone" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(C^{\ast\ast} = \overline{C}\)</span>。其中 <span class="math inline">\(\overline{C}\)</span> 是 <span class="math inline">\(C\)</span> 的拓扑闭包。</p></div><p><strong>证明</strong>：显然 <span class="math inline">\(\overline{C}\subseteqC^{\ast\ast}\)</span>，只要论证 <span class="math inline">\(C^{\ast\ast}\subseteq \overline{C}\)</span> 即可。</p><p>对任何 <span class="math inline">\(x\notin\overline{C}\)</span>，根据凸集分离定理，存在超平面<span class="math inline">\(H\)</span>，其法向量 <span class="math inline">\(n\)</span> 满足 <span class="math inline">\((n,C)\geq 0\)</span> 但是 <span class="math inline">\((n,x) &lt; 0\)</span>。于是线性泛函 <span class="math inline">\((n,\cdot)\in C^\ast\)</span> 且由于 <span class="math inline">\((n,x)&lt;0\)</span> 从而 <span class="math inline">\(x\notin C^{\ast\ast}\)</span>。反向包含得证。<span class="math inline">\(\blacksquare\)</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>对不熟悉凸集分离定理的读者，下面是一点细节补充：设 <span class="math inline">\(u\in\overline{C}\)</span> 是 <span class="math inline">\(\overline{C}\)</span> 中与 <span class="math inline">\(x\)</span> 距离最近的点：<span class="math inline">\(|x-u|=\inf_{z\in\overline{C}}|x-z|\)</span>。对任何 <span class="math inline">\(z\in\overline{C}\)</span>，考虑线段 <span class="math inline">\([u,z]\)</span> 上的点与 <span class="math inline">\(x\)</span> 的距离 <span class="math display">\[f(t) = |u + t(z-u) - x|,\quad 0\leqt\leq1.\]</span> <span class="math inline">\(f\)</span> 在 <span class="math inline">\(t=0\)</span> 时取得最小值： <span class="math display">\[ |u-x|^2 \leq |u-x|^2 + 2t(u-x, z-u) +t^2|z-u|^2.\]</span> 即 <span class="math display">\[0\leqt\cdot\left(2(u-x,z-u) + t|z-u|^2\right)\leq 2(u-x,z-u) +t|z-u|^2.\]</span> 令 <span class="math inline">\(t\to0^+\)</span> 可得<span class="math inline">\((u-x,z-u)\geq 0\)</span>。 这个式子对任何<span class="math inline">\(z\in\overline{C}\)</span> 成立，特别地取<span class="math inline">\(z=tu\)</span> 代入有 <span class="math display">\[(1-t)\cdot(u-x, u)\geq0.\]</span> 上式对任何<span class="math inline">\(t\geq0\)</span> 成立必须只能是 <span class="math inline">\((u-x, u)=0\)</span>。于是不等式 <span class="math display">\[(u-x,z-u)\geq 0\]</span> 可以改写为 <span class="math display">\[(u-x,z)\geq0\]</span> 对任何 <span class="math inline">\(z\in\overline{C}\)</span> 成立。而 <span class="math inline">\((u-x,x)=-(u-x,u-x)&lt;0\)</span>。所以 <span class="math inline">\(u-x\)</span> 即为所求的法向量 <span class="math inline">\(n\)</span>。</p></div><p>回到 Tits 锥 <span class="math inline">\(\mathcal{C}\)</span>的讨论上来。记 <span class="math inline">\(\mathcal{C}^\ast\)</span> 是<span class="math inline">\(\mathcal{C}\)</span> 的对偶锥，则 <span class="math inline">\(\mathcal{C}^\ast\inV\)</span>。我们有如下定理：</p><div id="tits-cone-dual" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathcal{C}^\ast=\bigcap\limits_{w\inW}w(\mathrm{cone}(\Delta))\)</span>。</p></div><p>可见 <span class="math inline">\(\mathcal{C}^\ast\)</span> 也是 <span class="math inline">\(W\)</span>- 不变的。</p><p><strong>证明</strong>：显然 <span class="math inline">\(\mathrm{cone}(\Delta)\)</span> 是 <span class="math inline">\(V\)</span> 中的一个闭凸锥，它在 <span class="math inline">\(V^\ast\)</span> 中的对偶锥是 <span class="math inline">\(\overline{\mathcal{D}}\)</span>： <span class="math display">\[\overline{\mathcal{D}}= \{x\in V^\ast\mid \langle\lambda,\,x\rangle\geq0,\ \forall\lambda\in\mathrm{cone}(\Delta)\}.\]</span> 我们有 <span class="math display">\[\begin{align}\mathcal{C}^\ast &amp;=\{v\in V \mid \langle v,\,x\rangle\geq 0 \text{for all } x \in \mathcal{C}\}\\&amp;= \{v\in V \mid \langle v,\,wz\rangle\geq0 \text{ for all }z\in\overline{\mathcal{D}}\text{ and } w \in W\}\\&amp;= \{v\in V \mid \langle w^{-1}v,\,z\rangle\geq0 \text{ for all}z\in\overline{\mathcal{D}}\text{ and } w \in W\}\\&amp;= \{v\in V \mid w^{-1}v\in (\overline{\mathcal{D}})^\ast \text{ forall } w \in W\}\\&amp;\stackrel{(\ast)}{=} \{v\in V \mid w^{-1}v\in \mathrm{cone}(\Delta)\text{ for all } w \in W\}\\&amp;= \{v\in V \mid v\in w(\mathrm{cone}(\Delta)) \text{ for all } w\in W\}.\end{align}\]</span></p><p>其中 <span class="math inline">\((\ast)\)</span> 一步正是将 <a href="#dual-dual-cone" title="定理 3.2">定理 3.2</a> 应用在 <span class="math inline">\(C=\mathrm{cone}(\Delta),\,C^\ast=\overline{\mathcal{D}}\)</span>上得到的。注意我们使用了 <span class="math inline">\(\mathrm{cone}(\Delta)\)</span> 是闭集这一点：<span class="math inline">\(\mathrm{cone}(\Delta)=\overline{\mathrm{cone}(\Delta)}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-cone-dual-pointed" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论3.4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathcal{C}^\ast\)</span> 是点锥：<span class="math inline">\(\mathcal{C}^\ast\cap-\mathcal{C}^\ast=\{0\}\)</span>。</p></div><p><strong>证明</strong>：根据 <a href="#tits-cone-dual" title="定理 3.3">定理 3.3</a> 有 <span class="math inline">\(\mathcal{C}^\ast\subset\mathrm{cone}(\Delta)\)</span>，但显然<span class="math inline">\(\mathrm{cone}(\Delta)\cap-\mathrm{cone}(\Delta)=\{0\}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>虽然我们得到了上面关于 <span class="math inline">\(\mathcal{C}^\ast\)</span>的刻画，但是它并不好用。我们下面用内积的形式给出 <span class="math inline">\(\mathcal{C}^\ast\)</span> 的一个更好的刻画。</p><div id="dual-cone-dot-neg" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.5</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(v\in\mathrm{cone}(\Delta)\)</span> 满足对任何<span class="math inline">\(\alpha_s\in\Delta\)</span> 有 <span class="math inline">\((v,\alpha_s)\leq0\)</span>，则 <span class="math inline">\(v\in\mathcal{C}^\ast\)</span>。</p></div><p><strong>证明</strong>：根据 <a href="#tits-cone-dual" title="定理 3.3">定理 3.3</a>，只要证明对任何 <span class="math inline">\(w\)</span> 都有 <span class="math inline">\(wv\in\mathrm{cone}(\Delta)\)</span> 即可。</p><p>对 <span class="math inline">\(l(w)\)</span> 归纳：<span class="math inline">\(l(w)=0\)</span> 的情形是已知。当 <span class="math inline">\(l(w)&gt;0\)</span> 时，设 <span class="math inline">\(w=w's\)</span>，其中 <span class="math inline">\(l(w')&lt;l(w)\)</span>，则 <span class="math inline">\(w'\alpha_s\in\Phi^+\subset\mathrm{cone}(\Delta)\)</span>。于是</p><p><span class="math display">\[\begin{align}wv &amp;= w'sv\\&amp;=w'(v - 2(v,\alpha_s)\alpha_s)\\&amp;=w'v - 2(v,\alpha_s)w'\alpha_s.\end{align}\]</span></p><p>根据归纳假设 <span class="math inline">\(w'v\in\mathrm{cone}(\Delta)\)</span>，所以<span class="math inline">\(wv\)</span> 是 <span class="math inline">\(\mathrm{cone}(\Delta)\)</span>中两个向量的非负线性组合，从而 <span class="math inline">\(wv\in\mathrm{cone}(\Delta)\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="dual-cone-nonspace" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.6</span>.</span><span class="statement-spah"> </span>对任何 <span class="math inline">\(u,v\in\mathcal{C}^\ast\)</span> 有 <span class="math inline">\((u,v)\leq 0\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>我是在与 <a href="https://www.maths.usyd.edu.au/u/bobh/">BobHowlett</a> 教授的邮件交流中学到这个结论的。这个证明我相信改进自 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>)</span>。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(v = \sum_{s\inS}c_s\alpha_s\in V\)</span>，定义 <span class="math inline">\(S(v)=\sum_{s\in S}c_s\)</span>为所有系数的和。注意当 <span class="math inline">\(v\in\mathcal{C}^\ast\subset\mathrm{cone}(\Delta)\)</span>时，每个 <span class="math inline">\(c_s\)</span> 都是非负的，所以 <span class="math inline">\(S(v)\geq0\)</span>。</p><p>用反证法，设 <span class="math inline">\(u,v\in\mathcal{C}^\ast\)</span> 满足 <span class="math inline">\((u,v)&gt;0\)</span>，不妨设 <span class="math inline">\((u,v)=1\)</span>。记 <span class="math inline">\(n=|S|\)</span> 和 <span class="math inline">\(M=S(u)\)</span>。定义</p><p><span class="math display">\[X=\{x\in\mathcal{C}^\ast\mid S(x)\leqS(v) \text{ and $(z,x)\geq1$ for some $z\in\mathcal{C}^\ast$ with$S(z)\leq M$}\}.\]</span></p><p>显然 <span class="math inline">\(v\in X\)</span>。</p><p>记 <span class="math inline">\(\epsilon=2/(nM)\)</span>，我们将证明对任何 <span class="math inline">\(x\in X\)</span>，都存在 <span class="math inline">\(y\in X\)</span> 使得 <span class="math inline">\(S(y)\leq S(x)-\epsilon\)</span>。</p><p>对 <span class="math inline">\(x\in X\)</span>，设 <span class="math inline">\(z=\sum_{s\inS}z_s\alpha_s\in\mathcal{C}^\ast\)</span> 满足 <span class="math inline">\(S(z)\leq M\)</span> 和 <span class="math inline">\((z,x)\geq1\)</span>，则 <span class="math display">\[(z,x)=\sum_{s\in S}z_s(\alpha_s,x)\geq1.\]</span> 所以必有某个 <span class="math inline">\(\alpha_s\)</span> 使得 <span class="math inline">\(z_s(\alpha_s,x)\geq 1/n\)</span>。由于 <span class="math inline">\(z_s\leq S(z)\leq M\)</span>，我们有 <span class="math display">\[(\alpha_s,x)\geq 1/(nz_s)\geq1/(nM)=\epsilon/2.\]</span></p><p>考察 <span class="math display">\[y=sx=x-2(x,\alpha_s)\alpha_s.\]</span> 由于 <span class="math inline">\(x\in\mathcal{C}^\ast\)</span> 以及 <span class="math inline">\(\mathcal{C}^\ast\)</span> 是 <span class="math inline">\(W-\)</span> 不变的所以 <span class="math inline">\(y\in\mathcal{C}^\ast\)</span>。又注意到 <span class="math display">\[S(y)=S(x)-2(x,\alpha_s)\leqS(x)-\epsilon.\]</span> 所以要证明 <span class="math inline">\(y\)</span> 符合要求，只要再找到某个 <span class="math inline">\(z'\in\mathcal{C}^\ast\)</span> 满足 <span class="math inline">\(S(z')\leq M\)</span> 和 <span class="math inline">\((z',y)\geq1\)</span> 即可。</p><p>如果 <span class="math inline">\((z,\alpha_s)&lt;0\)</span>，那么<span class="math inline">\(z'=z\)</span> 就满足要求，因为这时 <span class="math display">\[(z,y)=(z,x-2(x,\alpha_s)\alpha_s)=(z,x)-2\underbrace{(x,\alpha_s)}_{\geq\epsilon/2}\underbrace{(z,\alpha_s)}_{&lt;0}&gt;(z,x)\geq1.\]</span></p><p>反之如果 <span class="math inline">\((z,\alpha_s)&gt;0\)</span>，我们来验证 <span class="math inline">\(z'=sz=z-2(z,\alpha_s)\alpha_s\)</span>满足要求：由于 <span class="math inline">\(z\in\mathcal{C}^\ast\)</span>所以 <span class="math inline">\(z'\in\mathcal{C}^\ast\)</span>，并且 <span class="math inline">\(S(z')=S(z)-2(z,\alpha_s)&lt;S(z)\)</span>，以及<span class="math display">\[(z', y)=(sz,sx)=(z,x)\geq1.\]</span></p><p>于是从 <span class="math inline">\(v\)</span>出发，我们可以经过有限次取 <span class="math inline">\(y\in X\)</span>的操作使得 <span class="math inline">\(S(y)\)</span> 是负数，但这与<span class="math inline">\(y\in X\subset\mathcal{C}^\ast\)</span>矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Howlett-note" class="csl-entry" role="listitem">Howlett, Robert B. 1996. <span>“Introduction to Coxeter Groups.”</span><a href="https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html">https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html</a>.</div><div id="ref-Maxwell82" class="csl-entry" role="listitem">Maxwell, George. 1982. <span>“Sphere Packings and Hyperbolic ReflectionGroups.”</span> <em>Journal of Algebra</em> 79 (1): 78–97. <a href="https://doi.org/10.1016/0021-8693(82)90318-0">https://doi.org/10.1016/0021-8693(82)90318-0</a>.</div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Playing with parameters</title>
      <link href="/indra/playing-with-parameters.html"/>
      <url>/indra/playing-with-parameters.html</url>
      
        <content type="html"><![CDATA[<div class="statement simple plain unnumbered"><p>I could spin a web if I tried.’ said Wilbur, boasting. ‘Ive justnever tried.’</p><p>‘Let’s see you do it,’ said Charlotte…</p><p>‘OK.’ replied Wilhur. ‘You coach me and I’t’ spin one. It must be alot of fun to spill a web. How do I start?</p><p>“要是我愿意，我也能织网。”威尔伯吹嘘道，“只是我从来没试过。”</p><p>“那你来织一个给我们看看吧。”夏洛特说。</p><p>“好啊。”威尔伯答道，“你来指导我，我就织一个。织网一定很好玩。我该怎么开始呢？”</p></div><div class="statement simple plain unnumbered"><p>As any mathematician who has revealed his (or her) occupation to aneighbour on a plane flight has discovered, most people associatemathematics with something akin to the more agonizing forms of medievaltorture. It seems indeed unlikely that mathematics would be done at all,were it not that a few people discover the play that lies at its heart.Most published mathematics appears long after the play is done, cloakedin lengthy technicalities which obscure the original fun. The book inhand is unfortunately scarcely an exception. Never mind; after a fairlydetailed introduction to the art of creating tilings and fractal limitsets out of two very carefully chosen Möbius maps, we are finally set toembark on some serious mathematical play. The greatest rewards will bereaped by those who invest the time to set up their own programs andjoin us charting mathematical territory which is still only partiallyexplored.</p></div><p>正如任何一位曾在飞机上向邻座透露自己职业的数学家都会发现的那样，大多数人对数学的印象，似乎与某种中世纪酷刑的痛苦体验无异。倘若不是有少数人发现了数学的核心妙趣，数学恐怕早已无人问津。大多数已发表的数学成果，往往是在趣味探索结束许久之后才浮出水面的，而那些冗长繁复的技术细节，往往掩盖了最初的乐趣。遗憾的是，手头的这本书也未能完全例外。不过，别担心——在颇为详尽地介绍了如何用两个精心挑选的莫比乌斯变换来构造密铺图案和分形极限集之后，我们终于可以开始一场真正的数学探险了。那些愿意投入时间亲手编写程序、与我们一道探索这片尚未完全揭示的数学版图的读者，定将收获最丰厚的回报。</p><div class="statement simple plain unnumbered"><p>All the limit sets we have constructed thus far began from a specialarrangement of four circles, the Schottky circles, grouped into twopairs. For each pair, we found a Möbius map which moved the inside ofone circle to the outside of the other. Our initial tile was the regionoutside these four circles. By iterating, we produced a tiling whichcovered the the plane minus the limit set, near which the tiles shrankto minute size. Depending on how we chose the initial Schottky circles,the limit set was either fractal dust, a very crinkled fractal loop wecalled a quasicircle or, in certain very special cases, a truecircle.</p></div><p>迄今为止，我们构造的所有极限集都源自四个圆的独特排列，这些圆被称为肖特基圆，分为两对。对于每一对圆，我们找到一个莫比乌斯映射，将一个圆的内部映射到另一个圆的外部。我们的初始瓷砖是这四个圆外部的区域。通过反复迭代，我们生成了一种密铺，覆盖了平面上除了极限集以外的区域，在极限集附近，瓷砖逐渐缩小至微不可察的尺寸。根据我们选择的初始肖特基圆的不同，极限集可能呈现为分形尘埃，或者是我们称之为拟圆的极度扭曲的分形环，亦或在某些极其特殊的情况下，成为一个完美的圆。</p><div class="statement simple plain unnumbered"><p>The problem with this approach is that it is just too time-consumingto set up the circles and maps which pair them. Free-spirited playshouldn’t be ruined by too much preparation. Why not throw the Schottkycircles away, take any pair of <span class="math inline">\(2\times2\)</span> matrices for our generators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, run our limit point plotting program,and see what we get?</p><p>Hold on though - how exactly will this work? The shrinking disks wereso reassuring, and the limit set was so comfortably nestled within them,that it is hard to see why we won’t get chaos in their absence. Nomatter, the worst that is likely to happen is that the hard diskcrashes, so why not give it a try? Luckily, on p.&nbsp;182 ff.&nbsp;we alreadyupgraded the DFS code to remove the calculation of Schottky disks fromthe branch termination procedure. All we need do is take the plunge andrun the very same algorithm for any pair of transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>.</p></div><p>这个方法的弊端在于，设置这些圆及其配对映射实在太耗时了。自由随性的探索不应该被繁琐的准备工作束缚住手脚。为什么不干脆抛开Schottky 圆，随便挑一对 <span class="math inline">\(2 \times 2\)</span>矩阵作为我们的生成元 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，然后直接运行极限点绘图程序，看看会蹦出什么结果呢？</p><p>慢着，这真的行得通吗？那些嵌套收缩的圆盘让人倍感安心，极限集恰如其分地安居其中。没有了它们的庇护，系统难道不会陷入混沌？不过没关系，大不了就是硬盘崩了呗，那为什么不试试看呢？</p><p>幸运的是，在第 182 页及后续章节中，我们已经对 DFS算法进行改良，去掉了分支终止判定中对 Schottky圆盘的计算。我们所需要的，只是鼓起勇气，运行同样的算法，随便选一对变换<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，放手一试就好。</p><div class="statement simple plain unnumbered"><p>The reward is the glorious Figure 8.1! See intricate dance of spiralsof two loxodromic transformations. This is a quasifuchsian group verydifferent from the circle groups we met in Chapter 6. As usual, once acertain feature appears, the Mobius transformations in the grouptransport it around. Theoretical knowledge is one thing, but it wasn’tuntil we got our programs up and running that the first ever pictures ofexploding spirals brought the reality home. The authors, and later theparticipants in 1980 Thurston Theory Conference at Bowdoin College,could not suppress their awe at the eerie glowing image of the limitcurve snaking its way across an old Tektronix terminal.</p></div><p>奖励是辉煌的 <a href="#fig-8.1">图8.1</a>！看看两个斜驶变换螺旋的复杂舞蹈。这是一个与我们在第 6章遇到的圆群截然不同的拟 Fuchs群。像往常一样，一旦某个特征出现，群中的莫比乌斯变换便会将其传递开来。理论知识是一回事，但直到我们的程序启动并运行，第一张爆炸螺旋的图片才让人真正感受到其中的魅力。作者们，以及后来参加1980 年鲍登学院 Thurston 理论会议的与会者，无法抑制对极限曲线在老式Tektronix 显示器上蜿蜒而出的那张诡异发光图像的敬畏。</p><div class="statement simple plain unnumbered"><p>There’s one question here you may be asking: how did we choose <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>? The answer is, we built a machine.When engineers design a new sports car, do you really think they firsttest it by creeping down the driveway carefully at 5 miles per hour,then 10 miles per hour, and so on? Of course not; they push it madlythrough its paces to see how it drives. In order to carry out ourexplorations, we needed an easy-to-use program so we could quickly testout all sorts of possible matrices. In the next section, we shallexplain a recipe which allows us to easily make as many variants ofpictures like this as we please. The recipe depends on just two complexnumbers, the traces of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. These will be our parameters; justfeed them in and let the program fly.</p></div><p>接下来，你可能会有一个问题：我们是如何选择 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>的？答案是，我们构建了一台机器。当工程师设计一辆新跑车时，你真的认为他们会先以每小时5 英里的速度小心翼翼地沿着车道缓慢测试，然后是每小时 10英里，依此类推吗？当然不是；他们会毫不犹豫地将它推向极限，以各种速度行驶，观察它的驾驶表现如何。为了进行我们的探索，我们需要一个易于使用的程序，能够快速测试各种可能的矩阵。在下一节中，我们将解释一种方法，让我们轻松地制作出任意数量的此类图片变体。这个方法仅依赖于两个复数——<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>的迹。它们将作为我们的参数；只需输入它们，启动程序即可。</p><div class="statement simple plain unnumbered"><p>Actually you may get even greater satisfaction by varying theparameters continuously and watching the limit set writhing in response.For that, you will have to write another small program which plots asequence of frames of limit sets whose parameters are just slightlychanged step-by-step. Several people have done this, but stills are thebest we can offer in a book. Jeff Brock offers some films of crawlinglimit bugs on his web page www.math.uchicago.edu/~brock. For theMacintosh, we recommend a program by Masaaki Wada called <em>OPTi</em>,available at vivaldi.ics.nara-wu.ac.jp/~wada.</p></div><p>其实，如果你尝试连续调整参数，并观察极限集在这种变化中不断扭动、变形，你可能会感受到更大的乐趣。为此，你需要编写一个小程序，绘制一系列极限集的动画帧，每一帧的参数都稍稍有所变化。虽然已经有人做过这类工作，但在书中我们只能展示静态图像。JeffBrock 在他的网站 www.math.uchicago.edu/~brock上提供了一些关于“爬行的极限虫”的短片。对于 Macintosh 用户，我们推荐Masaaki Wada 开发的 OPTi 程序，可在 vivaldi.ics.nara-wu.ac.jp/~wada下载。</p><figure id="fig-8.1"><img src="/images/indra/fig-8.1.jpg" class="fig" width="500" alt="Figure 8.1. Mating snails? The limit set of a group generated by two maps a and b with complex conjugate traces t_a=1.87+0.1i and t_b=1.87-0.1i. This group is quasifuchsian because its limit set is a continuous loop which never crosses or meets itself. Curves like this are called Jordan curves: the celebrated Jordan Curve Theorem innocently states that every Jordan curve divides the plane into two parts, an ‘inside’ (gray) and an ‘outside’ (white). The proof of this seemingly obvious result is not easy. and this picture gives some idea of just how complicated a Jordan curve can be. We had to devise a handerafted algorithm to colour the inside. 图 8.1 交配的蜗牛？ 这是由两个映射 a 和 b 所生成的群的极限集，它们的迹互为复共轭，分别为 t_a = 1.87 + 0.1i 和 t_b = 1.87 - 0.1i。该群是拟 Fuchsian 群，因为它的极限集是一条既不交叉也不自交的连续闭曲线。这样的曲线被称为 Jordan 曲线。著名的 Jordan 曲线定理看似简单：每一条 Jordan 曲线都将平面分成两个部分，一个“内部”（灰色）和一个“外部”（白色）。尽管这个结果听起来显而易见，证明它却并不容易。而这幅图正好展示了 Jordan 曲线可以复杂到什么程度。为了给内部区域上色，我们不得不专门设计一个手工打造的算法。"><figcaption aria-hidden="true">Figure 8.1. Mating snails? The limit setof a group generated by two maps <span class="math inline">\(a\)</span>and <span class="math inline">\(b\)</span> with complex conjugate traces<span class="math inline">\(t_a=1.87+0.1i\)</span> and <span class="math inline">\(t_b=1.87-0.1i\)</span>. This group isquasifuchsian because its limit set is a continuous loop which nevercrosses or meets itself. Curves like this are called Jordan curves: thecelebrated Jordan Curve Theorem innocently states that every Jordancurve divides the plane into two parts, an ‘inside’ (gray) and an‘outside’ (white). The proof of this seemingly obvious result is noteasy. and this picture gives some idea of just how complicated a Jordancurve can be. We had to devise a handerafted algorithm to colour theinside.<br><strong>图 8.1 交配的蜗牛？</strong> 这是由两个映射 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>所生成的群的极限集，它们的迹互为复共轭，分别为 <span class="math inline">\(t_a = 1.87 + 0.1i\)</span> 和 <span class="math inline">\(t_b = 1.87 - 0.1i\)</span>。该群是拟 Fuchsian群，因为它的极限集是一条既不交叉也不自交的连续闭曲线。这样的曲线被称为Jordan 曲线。著名的 Jordan 曲线定理看似简单：每一条 Jordan曲线都将平面分成两个部分，一个“内部”（灰色）和一个“外部”（白色）。尽管这个结果听起来显而易见，证明它却并不容易。而这幅图正好展示了Jordan曲线可以复杂到什么程度。为了给内部区域上色，我们不得不专门设计一个手工打造的算法。</figcaption></figure><h1 id="grandmas-recipe">Grandma’s recipe</h1><div class="statement simple plain unnumbered"><p>To make pictures, we need two Möbius maps <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, given by matrices <span class="math display">\[a = \begin{pmatrix} a_1 &amp; a_2 \\ a_3 &amp; a_4 \end{pmatrix} \quad\text{and} \quad b = \begin{pmatrix} b_1 &amp; b_2 \\ b_3 &amp; b_4\end{pmatrix}.\]</span> Numerical inputs to a device or program are often calledparameters. On the face of it, two matrices means eight complex numberswhich means sixteen real numbers: that’s quite a few! To build our‘easy-to-use’ program, we need reduce the parameters to a minimum. Wecan get the number down to six by assuming that each matrix hasdeterminant 1. We can further reduce the number by remembering that theinteresting thing is to study groups up to conjugation. In practice thismeans that after we have studied one particular group <span class="math inline">\(G\)</span>, we no longer need study any of theconjugate groups <span class="math inline">\(hGh^{-1}\)</span> for anyconjugating Möbius map <span class="math inline">\(h\)</span> (apart ofcourse from the fun of getting a quite different ‘view’ of the limitset). A definite choice among all the conjugate groups <span class="math inline">\(hGh^{-1}\)</span> is called a normalization for<span class="math inline">\(G\)</span>.</p></div><p>为了绘制图形，我们需要两个莫比乌斯映射 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，它们分别由以下矩阵给出： <span class="math display">\[a = \begin{pmatrix} a_1 &amp; a_2 \\ a_3 &amp; a_4 \end{pmatrix} \quad\text{and} \quad b = \begin{pmatrix} b_1 &amp; b_2 \\ b_3 &amp; b_4\end{pmatrix}.\]</span>设备或程序的数值输入通常被称为参数。从表面上看，两个矩阵意味着八个复数，即十六个实数：这可真不少！为为了让我们的程序“好用”，我们需要尽量减少参数的数量。通过假设每个矩阵的行列式为1，我们可以将参数数减少到六个。我们还可以通过记住，研究群的共轭类才是关键，进一步减少参数数量。实际上，这意味着一旦我们研究了某个特定的群<span class="math inline">\(G\)</span>，我们就不再需要研究任何共轭群<span class="math inline">\(hGh^{-1}\)</span>，其中 <span class="math inline">\(h\)</span>是任何共轭的莫比乌斯映射（当然，除非你想体验一下从完全不同的角度观察极限集的乐趣）。在所有共轭群<span class="math inline">\(hGh^{-1}\)</span>中，选定一个特定的群作为代表，这个选择就称为对 <span class="math inline">\(G\)</span> 的归一化。</p><div class="statement simple plain unnumbered"><p>Choosing a particular normalization allows you to eliminate threefurther parameters, because there is always exactly one Möbius map whichcarries any three points to any other three. This means that you canprespecify the position of three points; for example, you might specifythat the attracting fixed points of <span class="math inline">\(a\)</span>, <span class="math inline">\(A\)</span>and <span class="math inline">\(b\)</span> are <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span>, and <span class="math inline">\(\infty\)</span> respectively. This is exactly whatwe did on p.&nbsp;207 when we proved that, up to conjugation, the modulargroup is unique. The upshot is that up to conjugacy, we should be ableto reduce the number of complex parameters necessary to describe atwo-generator group from eight to just three. The question is, whichthree? From our experience in the last two chapters, a good guess mightbe the three traces <span class="math inline">\(\mathop{\mathrm{Tr}}{a}\)</span>, <span class="math inline">\(\mathop{\mathrm{Tr}}{b}\)</span> and <span class="math inline">\(\mathop{\mathrm{Tr}}{ab}\)</span>. These numbersdon’t change when you conjugate, moreover we have already seen in somespecial cases that, up to conjugation, they completely determine thegroup.</p></div><p>选择特定的归一化方式，可以进一步消去三个参数。原因是，总存在一个莫比乌斯映射，能够将任意三个点映射到另一个任意的三点组合。这意味着，你可以预先指定这三个点的位置。例如，你可以规定映射<span class="math inline">\(a\)</span>、<span class="math inline">\(A\)</span> 和 <span class="math inline">\(b\)</span> 的吸引不动点分别为 <span class="math inline">\(0\)</span>、<span class="math inline">\(1\)</span>和 <span class="math inline">\(\infty\)</span>。事实上，这正是我们在第207 页中证明模群在共轭意义下唯一时所采用的方法。</p><p>由此可见，在共轭等价的条件下，我们应该能够将描述一个双生成元群所需的复数参数数量，从八个减少到仅三个。问题是，这三个参数该如何选取？根据我们在前两章中的经验，一个合理的猜测是：选取<span class="math inline">\(\mathop{\mathrm{Tr}}{a},\mathop{\mathrm{Tr}}{b}\)</span>和 <span class="math inline">\(\mathop{\mathrm{Tr}}{ab}\)</span>作为参数。这三个数在共轭下保持不变，而且我们已经在一些特殊情形中见过，单凭它们（在共轭意义下）就足以完全确定该群。</p><div class="statement simple plain unnumbered"><p>Our upgraded algorithm is going to work by moving systematicallyround the boundary of the word tree, plotting limit points in order whenit detects they are close. This means that for the program to workreasonably efficiently, it will be best if the limit set is still, atleast roughly speaking, a connected loop. In the situation of pairingopposite Schottky circles this happens provided all four basiccommutators are parabolic with traces equal <span class="math inline">\(-2\)</span>. As we saw on p.&nbsp;189, we can arrangethis by choosing <span class="math inline">\(\mathop{\mathrm{Tr}}{ab}\)</span> to satisfy theMarkov identity <span class="math display">\[(\mathop{\mathrm{Tr}}{a})^2 + (\mathop{\mathrm{Tr}}{b})^2 +(\mathop{\mathrm{Tr}}{ab})^2 = \mathop{\mathrm{Tr}}{a}\mathop{\mathrm{Tr}}{b} \mathop{\mathrm{Tr}}{ ab}.\]</span></p></div><p>我们升级后的算法将通过沿着单词树的边界系统地移动，在发现极限点接近时按顺序将其标出。为了让程序尽可能高效地运行，极限集最好仍然是一个连通的环，或者至少大致如此。</p><p>在配对相对的 Schottky 圆时，只要四个基本交换子都是迹为 <span class="math inline">\(-2\)</span>的抛物型元素，这种情况就会成立。正如我们在第 189页所看到的，可以通过选择 <span class="math inline">\(\mathop{\mathrm{Tr}}{ab}\)</span>满足马尔可夫恒等式来实现这一点： <span class="math display">\[(\mathop{\mathrm{Tr}}{a})^2 +(\mathop{\mathrm{Tr}}{b})^2 + (\mathop{\mathrm{Tr}}{ab})^2 =\mathop{\mathrm{Tr}}{a} \mathop{\mathrm{Tr}}{b} \mathop{\mathrm{Tr}}{ab}.\]</span></p><div class="statement simple plain unnumbered"><p>So for most of this chapter, we shall insist that <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB} = -2\)</span>, orequivalently that our three parameters <span class="math inline">\(t_a\)</span>, <span class="math inline">\(t_b\)</span> and <span class="math inline">\(t_{ab}\)</span> satisfy the Markov equation. Giveor take some trouble with square roots, this reduces our parameter countfrom 3 to 2, namely <span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span>. We shall give the name<strong>parabolic commutator groups</strong> to those groups in which<span class="math inline">\(\mathop{\mathrm{Tr}}{abAB} = -2\)</span>.They are also sometimes known as <strong>once-punctured torusgroups</strong>, because of the topological picture on p.&nbsp;190.</p></div><p>因此，在本章的大部分内容中，我们将始终假设 <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB} =-2\)</span>。换句话说，我们的三个参数 <span class="math inline">\(t_a\)</span>、<span class="math inline">\(t_b\)</span> 和 <span class="math inline">\(t_{ab}\)</span>满足马尔可夫方程。撇开一些与平方根有关的麻烦不谈，这一假设将参数的数量从3 个降至 2 个，即 <span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span>。我们将把满足 <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB} = -2\)</span>的群称为抛物交换子群（parabolic commutatorgroups）。它们有时也被称为一次穿孔环面群（once-punctured torusgroups），这是因为在第 190 页的拓扑图景中可以看到它们的相关性。</p><div class="statement simple plain unnumbered"><p>In Box 21 we have revealed Grandma’s treasured family recipe for thespecially normalized two-parameter family which we used for most of ourown explorations.^1 The matrix entries of the two generators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are written down entirely in terms ofthe parameters <span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span>, which you can set equal to any twocomplex numbers you care to choose. As you can see, the recipe isdesigned so that these numbers are the traces of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. Among all possible normalizations andhence many different possible recipes she might equally well have tried,Grandma selected this one mixed with some special spices to make thepictures come out really nice. If you put in real values for <span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span>, you get the group which pairsSchottky circles arranged in the pattern in frame (vi) on p.&nbsp;176. Thesame formula gave us the generators for the Apollonian gasket on p.&nbsp;201.There are some hints on how to verify that just knowing <span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span> really does fix the group in Project8.4.</p></div><p>在框 21中，我们揭示了奶奶传下来的秘制家族配方，这是一种特定归一化的双参数族，我们的大部分探索都采用了这种方法。两个生成元<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的矩阵元素完全由参数 <span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span>表示，你可以任意选择这两个参数为任何复数。正如你所见，这份配方经过奶奶亲手调配，加上了一些独家秘制香料，使得这两个数恰好是<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的迹。</p><p>归一化的方法有很多种，奶奶特意选择了这一份，加上她的独门手法，调出了让图像变得格外出彩的效果。如果你将<span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span> 设为实数值，就会得到与第 176 页图(vi) 中排列的 Schottky 圆相配对的群。同样的公式还为我们提供了第 201页阿波罗尼奥斯垫片的生成元。项目 8.4 提供了一些提示，教你如何验证仅凭<span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span> 确实足以确定该群。</p><div class="statement simple plain unnumbered"><p>Gosh, it’s so easy; why is there any need to explain? As you can see,in the second step of her recipe Grandma arranged that <span class="math inline">\(t_{ab}\)</span> satisfies the Markov identity,thereby ensuring that <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB} = -2\)</span>. We hadbetter check that multiplying <span class="math inline">\(a\)</span> and<span class="math inline">\(b\)</span> gives the formula we have writtendown for <span class="math inline">\(ab\)</span>, and that thedeterminants of <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are both 1. You may wish to resort toyour favourite symbolic algebra program, or, for the traditionalists, werecommend beginning with a good pile of blank scratch paper, copying thetwo matrices <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> carefully, and multiplying them outvery slowly indeed.</p></div><p>天哪，这也太简单了，还需要解释吗？正如你所见，在她的食谱第二步中，奶奶巧妙地安排了<span class="math inline">\(t_{ab}\)</span> 满足马尔可夫恒等式，从而确保<span class="math inline">\(\mathop{\mathrm{Tr}}{abAB} =-2\)</span>。不过，我们还是最好核对一下：把 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 相乘，是否确实得到了我们写下的 <span class="math inline">\(ab\)</span> 公式？还有，<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的行列式是否真的都是1？你可能想借助自己喜欢的符号代数程序，或者，如果你更喜欢传统方法，我们建议你备上一大堆干净的草稿纸，把矩阵<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>仔细抄下来，然后一步一步、慢吞吞地把它们算出来。</p><div id="box21" class="statement sta_box_21__grandma_s_special_parabolic_commutator_groups plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Box 21:Grandma’s special parabolic commutator groups</span>.</span><span class="statement-spah"> </span><strong>框21：外婆的特殊抛物线换位子群</strong></p><ol type="1"><li>Choose any complex numbers <span class="math inline">\(t_a\)</span>and <span class="math inline">\(t_b\)</span>.</li><li>Choose one of the solutions <span class="math inline">\(x\)</span>of the quadratic equation <span class="math display">\[x^2 - t_a t_b x +t_a^2 + t_b^2 = 0\]</span> and set <span class="math inline">\(t_{ab} =x\)</span>.</li><li>Compute <span class="math display">\[z_0 = \frac{(t_{ab} - 2)t_b}{t_b t_{ab} - 2 t_a + 2 i t_{ab}}.\]</span></li><li>Compute the generator matrices: <span class="math display">\[a =\begin{pmatrix}\frac{t_a}{2} &amp; \frac{t_a t_{ab} - 2 t_b + 4i}{(2 t_{ab} + 4) z_0}\\\frac{(t_a t_{ab} - 2 t_b - 4i) z_0}{2 t_{ab} - 4} &amp; \frac{t_a}{2}\end{pmatrix}\]</span> <span class="math display">\[b = \begin{pmatrix}\frac{t_b - 2i}{2} &amp; \frac{t_b}{2} \\\frac{t_b}{2} &amp; \frac{t_b + 2i}{2}\end{pmatrix}.\]</span></li><li>It’s worth noting that the product <span class="math inline">\(ab\)</span> is also quite simple: <span class="math display">\[ab = \begin{pmatrix}\frac{t_{ab}}{2} &amp; \frac{t_{ab} - 2}{2 z_0} \\\frac{(t_{ab} + 2) z_0}{2} &amp; \frac{t_{ab}}{2}\end{pmatrix}.\]</span></li></ol><p>One could compute <span class="math inline">\(b\)</span> and <span class="math inline">\(ab\)</span> first, and then find <span class="math inline">\(a\)</span> by multiplying <span class="math inline">\(ab\)</span> on the right by the inverse of <span class="math inline">\(b\)</span>, that is, <span class="math inline">\(a= (ab)B\)</span>.</p><ol type="1"><li>选取任意复数 <span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span>。<br></li><li>解以下二次方程，取其中一个解为 <span class="math inline">\(x\)</span>： <span class="math display">\[x^2 -t_a t_b x + t_a^2 + t_b^2 = 0.\]</span><br>然后令 <span class="math inline">\(t_{ab} = x\)</span>。<br></li><li>计算 <span class="math display">\[z_0 = \frac{(t_{ab} - 2) t_b}{t_bt_{ab} - 2 t_a + 2 i t_{ab}}.\]</span><br></li><li>计算生成元矩阵： <span class="math display">\[a = \begin{pmatrix}\frac{t_a}{2} &amp; \frac{t_a t_{ab} - 2 t_b + 4i}{(2 t_{ab} + 4) z_0}\\\frac{(t_a t_{ab} - 2 t_b - 4i) z_0}{2 t_{ab} - 4} &amp; \frac{t_a}{2}\end{pmatrix}\]</span><br><span class="math display">\[b = \begin{pmatrix}\frac{t_b - 2i}{2} &amp; \frac{t_b}{2} \\\frac{t_b}{2} &amp; \frac{t_b + 2i}{2}\end{pmatrix}.\]</span><br></li><li>值得注意的是，矩阵 <span class="math inline">\(ab\)</span>也有一个相对简单的形式：<br><span class="math display">\[ab = \begin{pmatrix}\frac{t_{ab}}{2} &amp; \frac{t_{ab} - 2}{2 z_0} \\\frac{(t_{ab} + 2) z_0}{2} &amp; \frac{t_{ab}}{2}\end{pmatrix}.\]</span></li></ol><p>我们也可以先计算 <span class="math inline">\(b\)</span> 和 <span class="math inline">\(ab\)</span>，然后通过将 <span class="math inline">\(ab\)</span> 右乘以 <span class="math inline">\(b\)</span> 的逆矩阵来求得 <span class="math inline">\(a\)</span>，即 <span class="math inline">\(a =(ab) B\)</span>。</p></div><div class="statement simple plain unnumbered"><p>All the groups made using Grandma’s recipe have a rather beautifulsymmetry, which Grandma felt was a very flavourful ingredient in hergroups. You may notice that the diagonal entries in both <span class="math inline">\(a\)</span> and <span class="math inline">\(ab\)</span> are the same. This has theconsequence, immediately noticeable in all our pictures, that the limitset of any group made using her recipe is symmetrical under the 180°rotation about the origin <span class="math inline">\(O\)</span>. Howthis works is explained in Note 8.1.</p><p>Lastly, what about that mysterious number <span class="math inline">\(z_0\)</span> in the off-diagonal entries of <span class="math inline">\(a\)</span> and <span class="math inline">\(ab\)</span>? Grandma could just have left it outof her recipes altogether, and then <span class="math inline">\(z_0\)</span> would have been none other than thefixed point of the commutator <span class="math inline">\(abAB\)</span>.By conjugating by a map that moves <span class="math inline">\(z_0\)</span> to 1, Grandma has added a littleextra style to her pictures. To get the hang of her recipe, you may liketo work through Projects 8.1 and 8.2.</p></div><p>所有按照祖母配方制作的群都具有相当美丽的对称性，祖母认为这是她的群中一个非常独特且富有风味的“成分”。你可能会注意到，矩阵<span class="math inline">\(a\)</span> 和 <span class="math inline">\(ab\)</span>的对角线元素是相同的。这个特性直接导致了一个显而易见的结果：在我们所有的图像中，使用她配方制作的群的极限集在关于原点<span class="math inline">\(O\)</span> 的 <span class="math inline">\(180^\circ\)</span>旋转下是对称的。这个现象的原理在注释 8.1 中已经做了详细说明。</p><p>最后，再来谈谈矩阵 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(ab\)</span> 非对角线元素中的那个神秘数字 <span class="math inline">\(z_0\)</span>。祖母本可以完全省略它，这样，<span class="math inline">\(z_0\)</span> 就会成为交换子 <span class="math inline">\(abAB\)</span> 的不动点。通过使用一个将 <span class="math inline">\(z_0\)</span> 移动到 1的映射进行共轭，祖母为她的图像增添了一点额外的风格。如果你想更好地理解她的配方，不妨尝试完成项目8.1 和 8.2。</p><h1 id="lets-play-gently-at-first">Let’s play (gently at first)</h1><figure id="fig-8.2"><img src="/images/indra/fig-8.2.jpg" width="500" alt="Figure 8.2. Varying parameters: from t_a = t_b = 3 to t_a = t_b = 2. We wrote down the generators for the group in frame (iii) in Project 6.5, and frame (vi) is the Apollonian gasket. 图 8.2. 参数变化：从 t_a = t_b = 3 到 t_a = t_b = 2。我们在项目 6.5 的框架 (iii) 中写下了该群的生成元，而框架 (vi) 则是阿波罗尼亚垫片。"><figcaption aria-hidden="true">Figure 8.2. Varying parameters: from<span class="math inline">\(t_a = t_b = 3\)</span> to <span class="math inline">\(t_a = t_b = 2\)</span>. We wrote down thegenerators for the group in frame (iii) in Project 6.5, and frame (vi)is the Apollonian gasket.<br>图 8.2. 参数变化：从 <span class="math inline">\(t_a = t_b = 3\)</span>到 <span class="math inline">\(t_a = t_b = 2\)</span>。我们在项目 6.5的框架 (iii) 中写下了该群的生成元，而框架 (vi)则是阿波罗尼亚垫片。</figcaption></figure><div class="statement simple plain unnumbered"><p>To ensure all is working smoothly and to gain familiarity with whatto expect from Grandma’s recipe, we are going start our play rathergently with groups in which the traces of the generators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are both real.</p><p>Figure 8.2 shows the outcome of our first experiment. We made it byrunning the program many times, keeping the two traces <span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span> equal and real-valued, sliding downfrom the initial value 3 to the final value 2. These groups can be madeby pairing tangent circles, and we have shown the Schottky circles. Inthe first three frames, the limit set is just the unit circle and thegroup is Fuchsian. The arcs rotate as the traces decrease until theyreach the symmetrical position in frame (iii). You may recognize thispicture - it is exactly the group in frame (vi) on p.&nbsp;176. As we movepast the symmetric position, something dramatic happens. The limit setcrinkles up and the group has become quasifuchsian. As we keep moving,the lowermost limit points (these are actually the fixed points <span class="math inline">\(\overline{b},\overline{B}\)</span>) become cornerswith evermore pronounced angles, until finally they come together like acrab’s pincers, chopping the region enclosed by the limit set into amyriad of tiny disks. This last frame should look familiar too - we havearrived at our old friend the Apollonian gasket from Chapter 7!</p></div><p>为了确保一切顺利，并且熟悉祖母食谱的“味道”，我们打算从轻松的开始，先从那些生成元<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 的迹都是实数的群开始。</p><p>图 8.2展示了我们第一次实验的结果。我们通过多次运行程序获得了这个结果，始终保持两个迹<span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span> 相等且为实数值，并让它们从初始值 3缓慢滑动至最终值 2。这样的群体可以通过配对相切的圆来构造，而我们标出了Schottky 圆。</p><p>在最初的三个画面中，极限集仅仅是单位圆，群是 Fuchsian群。随着迹的减小，弧线缓慢旋转，直到它们在画面 (iii)中达到了对称位置。你可能会觉得这幅图有些眼熟——它正是第 176 页画面 (vi)中的那个群。</p><p>当我们越过对称位置时，戏剧性的变化发生了。极限集皱缩起来，群变成了拟Fuchsian 群。继续移动时，最下方的极限点（实际上是不动点 <span class="math inline">\(\overline{b}\)</span> 和 <span class="math inline">\(\overline{B}\)</span>）逐渐变得越来越尖锐，最终它们像螃蟹的钳子一样夹拢在一起，将极限集所围成的区域切割成无数个微小的圆盘。</p><p>这最后一帧你一定也觉得眼熟——我们回到了第七章中那个熟悉的老朋友——阿波罗尼奥斯垫片！</p><div id="note-8.1" class="statement sta_note_8_1__grandma_s_symmetry definition unnumbered"><p><span class="statement-heading"><span class="statement-label">Note8.1: Grandma’s symmetry</span>：</span><span class="statement-spah"></span><strong>注解 8.1：外婆的对称性</strong></p><p>Suppose <span class="math inline">\(M\)</span> is a matrix whosediagonal entries are equal, in other words with the special form <span class="math display">\[M = \begin{pmatrix} r &amp; s \\ t &amp; r\end{pmatrix}.\]</span> Such transformations have a special symmetry,encoded in the equation <span class="math display">\[-M(-z) =\frac{r(-z) + s}{t(-z) + r} = \frac{rz - s}{-tz + r} =M^{-1}(z).\]</span> To interpret this equation, write <span class="math inline">\(j\)</span> for the 180° rotation <span class="math inline">\(z \mapsto -z\)</span>. Using the relation <span class="math inline">\(j^{-1} = j\)</span>, this equation says that <span class="math inline">\(jMj^{-1} = M^{-1}\)</span>. In other words,conjugating the transformation <span class="math inline">\(M\)</span> by180° rotation about <span class="math inline">\(O\)</span> carries <span class="math inline">\(M\)</span> to <span class="math inline">\(M^{-1}\)</span>.</p><p>In Grandma’s recipe, both <span class="math inline">\(a\)</span> and<span class="math inline">\(ab\)</span> have this property, which means<span class="math inline">\(jaj = A\)</span> and <span class="math inline">\(jabj = BA\)</span>. Since <span class="math inline">\(j\)</span> is its own inverse, these imply <span class="math inline">\(jAj = a\)</span> and <span class="math inline">\(jBAj = ab\)</span>. By combining these relations,we can show that any word in <span class="math inline">\(a\)</span>,<span class="math inline">\(b\)</span>, <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> is conjugated by <span class="math inline">\(j\)</span> into some other word in <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(A\)</span>and <span class="math inline">\(B\)</span>. That is, conjugation by<span class="math inline">\(j\)</span> does not change the group <span class="math inline">\(G\)</span> generated by <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, nor does it change the completecollection of infinite words in the generators. That is enough to tellus that the limit set of <span class="math inline">\(G\)</span> isunchanged by the transformation <span class="math inline">\(j\)</span>.As an example, consider applying <span class="math inline">\(j\)</span>to the infinite word <span class="math inline">\(abaBA\cdots\)</span>:</p><p><span class="math display">\[jabaBA \cdots = jabj jaj jBAj \cdots =BA A ab \cdots.\]</span></p><p>设 <span class="math inline">\(M\)</span>是一个对角元素相等的矩阵，具体形式为 <span class="math display">\[M=\begin{pmatrix} r &amp; s \\ t &amp; r\end{pmatrix}.\]</span>这种变换具有一种特殊的对称性，它可以通过以下等式来描述： <span class="math display">\[-M(-z) = \frac{r(-z) + s}{t(-z) + r} = \frac{rz -s}{-tz + r} = M^{-1}(z).\]</span></p><p>要理解这个等式，设 <span class="math inline">\(j\)</span> 表示将<span class="math inline">\(z\)</span> 映射到 <span class="math inline">\(-z\)</span> 的 180° 旋转。利用 <span class="math inline">\(j^{-1} = j\)</span> 这一性质，上述等式表明 <span class="math inline">\(jMj^{-1} = M^{-1}\)</span>。换句话说，对变换 <span class="math inline">\(M\)</span> 施加以原点为中心的 180°旋转，其结果是将 <span class="math inline">\(M\)</span> 变为其逆变换<span class="math inline">\(M^{-1}\)</span>。</p><p>在外婆的配方中，<span class="math inline">\(a\)</span> 和 <span class="math inline">\(ab\)</span> 都具有这一性质，这意味着 <span class="math inline">\(jaj = A\)</span>，<span class="math inline">\(jabj= BA\)</span>。由于 <span class="math inline">\(j\)</span>是它自身的逆映射，这些关系进一步推出 <span class="math inline">\(jAj =a\)</span>，以及 <span class="math inline">\(jBAj = ab\)</span>。</p><p>通过结合这些关系，我们可以证明，任何由 <span class="math inline">\(a,b,A,B\)</span> 组成的词在经过 <span class="math inline">\(j\)</span> 的共轭后，仍然是由 <span class="math inline">\(a,b,A,B\)</span> 构成的某个词。也就是说，<span class="math inline">\(j\)</span> 的共轭不会改变由 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 生成的群 <span class="math inline">\(G\)</span>，也不会改变由这些生成元构成的所有无限词的完整集合。这足以说明，群<span class="math inline">\(G\)</span> 的极限集在变换 <span class="math inline">\(j\)</span> 作用下保持不变。</p><p>举个例子，考虑将 <span class="math inline">\(j\)</span> 作用于无限词<span class="math inline">\(abaBA\cdots\)</span>： <span class="math display">\[jabaBA \cdots = jabj jaj jBAj \cdots = BA A ab\cdots.\]</span></p></div><figure id="fig-8.3"><img src="/images/indra/fig-8.3.jpg" width="500" alt="Figure 8.3. The program hits chaos. The left side is the result of running the DFS algorithm for just a short length of time; on the right we had slightly more patience. The picture resulting from running the program forever (that is, without the safety cut-off lev_max) is slightly less interesting. Groups whose limit set look like this are called non-discrete. 图 8.3 程序进入混沌状态。左侧是 DFS 算法运行短短一段时间的结果；右侧则是我们稍作耐心等待后得到的成果。如果让程序一直运行下（即不设安全上限 lev_max），得到的图像就会显得略微单调。那些极限集呈现这种形态的群体，被称为非离散群。"><figcaption aria-hidden="true">Figure 8.3. The program hits chaos. Theleft side is the result of running the DFS algorithm for just a shortlength of time; on the right we had slightly more patience. The pictureresulting from running the program forever (that is, without the safetycut-off lev_max) is slightly less interesting. Groups whose limit setlook like this are called non-discrete.<br>图 8.3 程序进入混沌状态。左侧是 DFS算法运行短短一段时间的结果；右侧则是我们稍作耐心等待后得到的成果。如果让程序一直运行下（即不设安全上限lev_max），得到的图像就会显得略微单调。那些极限集呈现这种形态的群体，被称为非离散群。</figcaption></figure><div class="statement simple plain unnumbered"><p>What happens if we decrease the traces just a little bit further andtry <span class="math inline">\(t_a = t_b = 1.9\)</span>? <em>Warning,warning, danger, danger</em>! The Schottky circles will start tooverlap, and it becomes not at all clear what to expect. You can seewhat we are worried about in Figure 8.3. In this picture, we chose apretty large cut-off value <code>epsilon = 0.1</code> in comparison tothe frame size, 2.2 by 2.2. In contrast to the previous pictures, youcan actually see the line segments drawn by the DFS program. Some ofthem are actually much larger than <code>epsilon</code>. That is becauseno matter how far we go down the branch, limit points which are supposedto be neighbours never get truly close. The branch is terminated only bythe built-in maximum depth levjnax. It is lucky we built in thissafeguard; otherwise our program would be stuck running a never endingloop. The truth is, Figure 8.3 should be a solid black square.</p></div><p>如果我们将迹的值再稍微减少一些，并尝试设定 <span class="math inline">\(t_a = t_b =1.9\)</span>，会发生什么呢？警告，警告，危险，危险！肖特基圆开始重叠，情况变得完全不可预测。你可以在图8.3 中看到我们担心的情况。</p><p>在这幅图中，我们选择了一个相对于帧尺寸（2.2×2.2）来说相当大的阈值<code>epsilon = 0.1</code>。与之前的图像不同，你现在可以看到 DFS程序绘制的线段。其中一些线段的长度实际上远远超过了<code>\epsilon</code>。这是因为无论我们沿着分支向下走多远，原本应相邻的极限点始终无法真正靠近。分支的终止仅由内置的最大深度<code>lev_max</code> 控制。</p><p>幸运的是，我们设置了这个保护机制，否则程序将陷入永无止境的循环。事实上，图8.3 本应是一块实心的黑色方块。</p><div class="statement simple plain unnumbered"><p>The groups in Figure 8.2 are actually conjugates of the groups madefrom our original circle pairing recipe on p.170 in Chapter 6. Toseethis, let <span class="math inline">\(x = u = t_a/2\)</span>. Theconnection between the two constructions is shown in Figure 8.4 whichwas drawn using Grandma’s recipe for the quasifuchsian group with <span class="math inline">\(t_a = t_b = 2.2\)</span>. Our original recipe gaveroughly equal weight to each of the four generators <span class="math inline">\(a\)</span>, <span class="math inline">\(A\)</span>, <span class="math inline">\(b\)</span>and <span class="math inline">\(B\)</span>. By contrast, Grandma’srecipe emphasizes symmetry relative to the alternative generators <span class="math inline">\(a\)</span> and <span class="math inline">\(ab\)</span>. The word tree comes out distorted sothat words beginning with <span class="math inline">\(a\)</span> occupyhalf the picture, the other half being divided among words beginningwith the other three letters <span class="math inline">\(A\)</span>,<span class="math inline">\(b\)</span> and <span class="math inline">\(B\)</span>. The basic tile in Figure 8.4 is theone which has one side of each colour. The red side is part of thecircle <span class="math inline">\(C_a\)</span>, the blue side of <span class="math inline">\(C_b\)</span>, and so on. Its vertices are thefixed points of the four commutators <span class="math inline">\(abAB\)</span>, <span class="math inline">\(bABA\)</span>, <span class="math inline">\(ABab\)</span> and <span class="math inline">\(BabA\)</span>. As you can see, the red part isexactly half the limit set. The other half can be obtained by reflectingthrough the origin, using the map <span class="math inline">\(j : z\mapsto -z\)</span>. (This trick was in part the original motivation forGrandma’s normalization: we had only to plot a quarter of the limitpoints, and by reflecting got the rest of the picture for free.)</p></div><p>图 8.2 中的群实际上是我们在第 6 章第 170页使用原始圆配对方法构造的群的共轭群。为了理解这一点，设 <span class="math inline">\(x = u = t_a / 2\)</span>。两种构造之间的联系如图8.4 所示，该图是按照祖母的拟富克斯群配方绘制的，其中 <span class="math inline">\(t_a = t_b = 2.2\)</span>。</p><p>我们的原始配方对四个生成元 <span class="math inline">\(a\)</span>、<span class="math inline">\(A\)</span>、<span class="math inline">\(b\)</span>和 <span class="math inline">\(B\)</span>赋予了大致相等的权重。而与此不同，祖母的配方则更加强调相对于替代生成元<span class="math inline">\(a\)</span> 和 <span class="math inline">\(ab\)</span>的对称性。结果，单词树出现了扭曲，导致以字母 <span class="math inline">\(a\)</span>开头的单词占据了图像的一半，另一半则被以字母 <span class="math inline">\(A\)</span>、<span class="math inline">\(b\)</span>和 <span class="math inline">\(B\)</span> 开头的单词所瓜分。</p><p>图 8.4 中的基本瓷砖是每条边各具一种颜色的那一块。红色边属于圆 <span class="math inline">\(C_a\)</span> 的一部分，蓝色边属于圆 <span class="math inline">\(C_b\)</span>的一部分，依此类推。该瓷砖的顶点是四个交换子 <span class="math inline">\(abAB\)</span>、<span class="math inline">\(bABA\)</span>、<span class="math inline">\(ABab\)</span> 和 <span class="math inline">\(BabA\)</span>的不动点。如你所见，红色部分恰好是极限集的一半。另一半可以通过使用映射<span class="math inline">\(j : z \mapsto -z\)</span>对原点进行反射得到。（这一技巧在某种程度上正是 Grandma归一化的原始动机：我们只需绘制四分之一的极限点，然后通过反射即可免费获得图像的其余部分。）</p><figure id="fig-8.4"><img src="/images/indra/fig-8.4.jpg" width="500" alt="Figure 8.4. The anatomy of the limit set for the group specified by Grandma’s recipe with t_a = t_b = 2.2. The different colours show the pieces of the limit set that begin with different one letter prefixes: red for those beginning with a, green for A, blue for b, and yellow for B. We have marked certain limit points by their infinite words, for example \overline{a} marks the attracting fixed point of a. Since it is represented by the infinite word aaaa\cdots, it appears in the red section. This section also contains the fixed point of aba^{-1} whose infinite word is a\overline{b} = abbbb\cdots, and aBa^{-1} with infinite word a\overline{B} = aBBBB\cdots. Notice the various fixed points which seem to be coming together as the traces t_a and t_b get near 2. 图 8.4. 按照“奶奶的配方”中设定的群（参数 t_a = t_b = 2.2）生成的极限集的剖析图。不同颜色表示以不同单字母前缀开头的极限集部分：红色对应以 a 开头的部分，绿色对应以 A 开头的部分，蓝色对应以 b 开头的部分，黄色对应以 B 开头的部分。我们用它们的无穷字标出了某些极限点。例如，\overline{a} 表示 a 的吸引不动点。由于它的无穷字是 aaaa\cdots，因此出现在红色区域内。该区域还包含 aba^{-1} 的不动点，其无穷字为 a\overline{b} = abbbb\cdots，以及 aBa^{-1} 的不动点，其无穷字为 a\overline{B} = aBBBB\cdots。请注意，随着迹数 t_a 和 t_b 接近 2，某些不动点似乎逐渐聚集在一起。"><figcaption aria-hidden="true">Figure 8.4. The anatomy of the limit setfor the group specified by Grandma’s recipe with <span class="math inline">\(t_a = t_b = 2.2\)</span>. The different coloursshow the pieces of the limit set that begin with different one letterprefixes: red for those beginning with <span class="math inline">\(a\)</span>, green for <span class="math inline">\(A\)</span>, blue for <span class="math inline">\(b\)</span>, and yellow for <span class="math inline">\(B\)</span>. We have marked certain limit points bytheir infinite words, for example <span class="math inline">\(\overline{a}\)</span> marks the attracting fixedpoint of <span class="math inline">\(a\)</span>. Since it is representedby the infinite word <span class="math inline">\(aaaa\cdots\)</span>, itappears in the red section. This section also contains the fixed pointof <span class="math inline">\(aba^{-1}\)</span> whose infinite word is<span class="math inline">\(a\overline{b} = abbbb\cdots\)</span>, and<span class="math inline">\(aBa^{-1}\)</span> with infinite word <span class="math inline">\(a\overline{B} = aBBBB\cdots\)</span>. Notice thevarious fixed points which seem to be coming together as the traces<span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span> get near 2.<br>图 8.4. 按照“奶奶的配方”中设定的群（参数 <span class="math inline">\(t_a= t_b =2.2\)</span>）生成的极限集的剖析图。不同颜色表示以不同单字母前缀开头的极限集部分：红色对应以<span class="math inline">\(a\)</span> 开头的部分，绿色对应以 <span class="math inline">\(A\)</span> 开头的部分，蓝色对应以 <span class="math inline">\(b\)</span> 开头的部分，黄色对应以 <span class="math inline">\(B\)</span>开头的部分。我们用它们的无穷字标出了某些极限点。例如，<span class="math inline">\(\overline{a}\)</span> 表示 <span class="math inline">\(a\)</span> 的吸引不动点。由于它的无穷字是 <span class="math inline">\(aaaa\cdots\)</span>，因此出现在红色区域内。该区域还包含<span class="math inline">\(aba^{-1}\)</span> 的不动点，其无穷字为 <span class="math inline">\(a\overline{b} = abbbb\cdots\)</span>，以及 <span class="math inline">\(aBa^{-1}\)</span> 的不动点，其无穷字为 <span class="math inline">\(a\overline{B} =aBBBB\cdots\)</span>。请注意，随着迹数 <span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span> 接近2，某些不动点似乎逐渐聚集在一起。</figcaption></figure><h1 id="the-fun-begins-traces-go-complex">The fun begins: traces gocomplex</h1><figure id="fig-8.5"><img src="/images/indra/fig-8.5.jpg" width="500" alt="Figure 8.5. Testing some complex values of the traces. For comparison we have made the viewing window the same in all four frames. 图 8.5 测试一些复杂值的轨迹。为了便于比较，我们在所有四个帧中设置了相同的观察窗口。"><figcaption aria-hidden="true">Figure 8.5. Testing some complex valuesof the traces. For comparison we have made the viewing window the samein all four frames.<br>图 8.5测试一些复杂值的轨迹。为了便于比较，我们在所有四个帧中设置了相同的观察窗口。</figcaption></figure><div class="statement simple plain unnumbered"><p>Our play has been kept artificially gentle by restricting to examplesin which <span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span> are both real. Such groups alwayscome equipped with a chain of four tangent Schottky circles, so plottingtheir limit sets is really nothing new. The real fun starts when ta andtb go properly complex. Figure 8.5 shows the results of gingerly testingthe waters. What were the Schottky circles appear to have gone haywire,but at least the limit sets are still loops.</p></div><p>为了保持温和的氛围，我们仅选取了 <span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span>都为实数的例子。这样的群总是配备有一条由四个切线 Schottky圆组成的链条，因此，绘制它们的极限集实际上并不算什么新鲜事。真正有趣的部分出现在当<span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span> 变为复数时。图 8.5展示了我们小心翼翼地试水的结果。原本是 Schottky圆的部分似乎已经乱成一团，但至少极限集仍然是环状的。</p><div class="statement simple plain unnumbered"><p>The curling and twisting you can see in these limit sets is caused bytiny spiralling motions of loxodromic transformations. Transformationswith non-real traces are always loxodromic, so as soon as we make <span class="math inline">\(t_a\)</span> and <span class="math inline">\(t_b\)</span> complex, we can expect curling tooccur. The amount of curling of a transformation depends not so much onthe imaginary part of its trace as on the tightness of the spiral motionnear its fixed points. Referring back to Chapter 3, you will see thespiral is tightly coiled if the multiplier is near 1, so the trace isnear 2, and if in addition the imaginary part is comparatively small.You can see this in evidence in the substantial curling in the last twoframes in Figure 8.5, where <span class="math inline">\(t_a\)</span> and<span class="math inline">\(t_b\)</span> are near 2 and only slightlycomplex. There are no Schottky circles, but on the <code>inside</code>,we have drawn red circular arcs meeting at the fixed points of the fourbasic commutators. (We made the first arc perpendicular to the directionof the parabolic at the fixed point.) You can tell they are no longerpieces of Schottky circles, because Schottky circles never intersect.You might wonder if the same group might be constructed as a Schottkygroup starting from a different set of circles, and with differentgenerators doing the pairings. Whether or not this is possible, we don’tknow.</p></div><p>你在这些极限集上看到的弯曲和扭曲，是由斜航型变换的小螺旋运动引起的。具有非实迹的变换总是斜航型变换，因此，只要我们将<span class="math inline">\(t_a\)</span> 和 <span class="math inline">\(t_b\)</span>设为复数，就可以预见到弯曲现象的出现。变换的弯曲程度不仅仅取决于迹的虚部，更依赖于其不动点附近螺旋运动的紧密程度。回到第三章，你会发现当乘数接近1 时，螺旋会紧密盘绕，此时迹接近2，且如果虚部相对较小，这种情况更加明显。你可以在图 8.5的最后两帧中看到这一现象，这里 <span class="math inline">\(t_a\)</span>和 <span class="math inline">\(t_b\)</span> 接近 2 且仅稍微为复数。没有Schottky圆，但在“内部”，我们画出了红色的圆弧，它们在四个基本交换子点的固定点相交。（我们使第一条圆弧垂直于固定点的抛物线方向。）你可以判断它们不再是Schottky 圆的部分，因为 Schottky圆是永远不会相交的。你可能会好奇，是否可以从一组不同的圆出发，构造出一个Schottky 群，并使用不同的生成元来完成配对。我们不知道这是否可能。</p><figure id="fig-8.6"><img src="/images/indra/fig-8.6.jpg" width="500" alt="Figure 8.6. Dr.&nbsp;Stickler blown about inside the limit set of a quasifuchsian group with t_a=t_b=1.91+0.05i. . You can see a full view of this limit set in Figure 8.1. We made this picture by implementing a tiling type plot with the prostrate Dr.&nbsp;Stickler as the initial seed. 图 8.6. 斯蒂克勒博士在一个拟福克斯群的极限集内被吹动，参数 t_a=t_b=1.91+0.05i。你可以在图 8.1 中看到这个极限集的完整视图。我们通过实现一种镶嵌类型的图形，并以斯蒂克勒博士躺倒的形象作为初始种子，制作了这张图片。"><figcaption aria-hidden="true">Figure 8.6. Dr.&nbsp;Stickler blown aboutinside the limit set of a quasifuchsian group with <span class="math inline">\(t_a=t_b=1.91+0.05i\)</span>. . You can see a fullview of this limit set in Figure 8.1. We made this picture byimplementing a tiling type plot with the prostrate Dr.&nbsp;Stickler as theinitial seed.<br>图 8.6. 斯蒂克勒博士在一个拟福克斯群的极限集内被吹动，参数 <span class="math inline">\(t_a=t_b=1.91+0.05i\)</span>。你可以在图 8.1中看到这个极限集的完整视图。我们通过实现一种镶嵌类型的图形，并以斯蒂克勒博士躺倒的形象作为初始种子，制作了这张图片。</figcaption></figure><div class="statement simple plain unnumbered"><p>As you can see, all these groups are still quasifuchsian, meaningthat the limit set is a connected curve which doesn’t cross itself andwhich divides the plane into an inside’ and ‘outside’. These are thefirst groups whose limit sets we genuinely could not have drawn usingour old Schottky circle algorithm. It would be nice to explore theregion inside the limit set, but since there are no Schottky circles towork with, it can become a very tricky problem to find suitable tiles.Undeterred, we blew up a small part of a nice limit set with <span class="math inline">\(t_a = t_b= 1.91 + 0.05i\)</span> and setDr.&nbsp;Stickler lying flat on his back in red on the righthand side. Youcan see him in Figure 8.6 spinning around, carried into every nook andcranny, so that there is exactly one Dr.&nbsp;Stickler for every word in thegroup.</p></div><p>正如你所看到的，这些群仍然是准福克群（quasifuchsian），意味着其极限集是一个连通曲线，既不交叉自身，也将平面分成了“内部”和“外部”两部分。这些是我们通过旧的Schottky圆算法，确实无法画出的第一个群体极限集。虽然我们很想探索极限集内部的区域，但由于没有Schottky圆可以使用，找到合适的瓷砖就变成了一个非常棘手的问题。尽管如此，我们依然不气馁，放大了一个漂亮的极限集的一小部分，设定了<span class="math inline">\(t_a = t_b = 1.91 +0.05i\)</span>，并让斯蒂克勒博士躺在右侧的平面上，用红色标出。你可以在图 8.6中看到他旋转的样子，他被带入每一个角落与缝隙中，所以每一个群体中的每个词语都对应着一个斯蒂克勒博士。</p><figure id="fig-8.7"><img src="/images/indra/fig-8.7.jpg" width="500" alt="Figure 8.7. All the tiles are obtained from the red one by applying words in the group. What is the red tile? In Figure 8.6, note that the red Dr.&nbsp;Stickler is larger than all his copies. We could try putting a miniscule Dr.&nbsp;Stickler anywhere and see if he is larger than his copies. The places where this happens are the points of the red tile. 图 8.7 中，所有瓷砖都是通过对红色瓷砖应用群中的词语得到的。红色瓷砖是什么？在图 8.6 中，注意红色的 Dr.&nbsp;Stickler 比所有复制品都要大。我们可以尝试在任何地方放置一个微小的 Dr.&nbsp;Stickler，看看他是否比他的复制品大。这种情况发生的地方就是红色瓷砖的点。"><figcaption aria-hidden="true">Figure 8.7. All the tiles are obtainedfrom the red one by applying words in the group. What is the red tile?In Figure 8.6, note that the red Dr.&nbsp;Stickler is larger than all hiscopies. We could try putting a miniscule Dr.&nbsp;Stickler anywhere and seeif he is larger than his copies. The places where this happens are thepoints of the red tile.<br>图 8.7中，所有瓷砖都是通过对红色瓷砖应用群中的词语得到的。红色瓷砖是什么？在图8.6 中，注意红色的 Dr.&nbsp;Stickler比所有复制品都要大。我们可以尝试在任何地方放置一个微小的Dr.&nbsp;Stickler，看看他是否比他的复制品大。这种情况发生的地方就是红色瓷砖的点。</figcaption></figure><div class="statement simple plain unnumbered"><p>In Figure 8.7 we have actually found a tiling for a quasifuchsiangroup with <span class="math inline">\(t_a = 2 + 0.1i, t_b = 3\)</span>.Notice that the tiles are no longer four- but six-sided. As ever, thedifferent tiles are carried onto each other by the transformations inthe group. They get exceedingly skinny in the middle: if we varied ourparameters just a little bit each of these tiles would fall apart intotwo halves. We found this particular tiling by a completely differentmethod explained briefly in the caption.</p></div><p>在图 8.7 中，我们实际上为一个准福克斯群找到了一个铺砖，参数为 <span class="math inline">\(t_a = 2 + 0.1i\)</span>，<span class="math inline">\(t_b =3\)</span>。注意，这些瓷砖不再是四边形，而是六边形。正如往常一样，不同的瓷砖通过群中的变换相互映射。它们在中间变得异常狭长：如果我们稍微调整一下参数，每一块瓷砖都会裂成两半。我们通过一种完全不同的方法找到了这个特殊的铺砖，简要的解释见图注。</p><figure id="fig-8.8"><img src="/images/indra/fig-8.8.jpg" width="500" alt="Figure 8.8. Our first probe. In this sequence, t_b=3 and t_a=x+0.05i with x varying from 3 down to 1.9. 图 8.8. 我们的第一次探测。在这个序列中，t_b = 3，t_a = x + 0.05i，其中 x 从 3 变化到 1.9。"><figcaption aria-hidden="true">Figure 8.8. Our first probe. In thissequence, <span class="math inline">\(t_b=3\)</span> and <span class="math inline">\(t_a=x+0.05i\)</span> with <span class="math inline">\(x\)</span> varying from 3 down to 1.9.<br>图 8.8. 我们的第一次探测。在这个序列中，<span class="math inline">\(t_b= 3\)</span>，<span class="math inline">\(t_a = x + 0.05i\)</span>，其中<span class="math inline">\(x\)</span> 从 3 变化到 1.9。</figcaption></figure><div class="statement simple plain unnumbered"><p>The curling in the last two frames of Figure 8.5 piqued our interest,hinting at directions which might be interesting to explore. Just howmuch curling is possible? The interest seems to centre on traces near 2,but ever so slightly complex. To investigate, we shall run an experimentin which we fix the trace <span class="math inline">\(t_b\)</span>safely equal 3, and then let <span class="math inline">\(t_a\)</span>run through values <span class="math inline">\(x + 0.05i\)</span>, where<span class="math inline">\(x\)</span> is a real number which starts at3 and slowly decreases to some dangerous transitional value, as yetunknown. Figure 8.8 shows the preliminary results. The first frame isjust a slightly wobbly circle. The second and third frames show somebumps forming, with the first hints of spiralling in the third frame at<span class="math inline">\(x = 2\)</span>. From the chaotic fourthframe we deduce that somewhere between <span class="math inline">\(x =2.0\)</span> and <span class="math inline">\(x = 1.9\)</span>, westepped over the boundary. The live version of the last frame is moreinteresting: the DFS algorithm frantically criss-crosses the picturetrying to draw a solid black square. To locate the transition point moreexactly, in Figure 8.9 we decrease <span class="math inline">\(x\)</span> by finer increments from 2.0 to 1.9.From 1.97 to 1.94 to 1.91, you can see the bumps on the limit setdeveloping into pronounced and ever more tightly whirling spirals. Weknow from our earlier probe that the boundary lies above <span class="math inline">\(x = 1.90\)</span>; when we ever-so-carefullystepped to 1.905, the DFS plot tried to fake sanity for a while, untilits turbulent behaviour at last manifested and we terminated theprogram, allowing us at least to see some of the spirals that are stillevident. We have pinned down the transition to madness somewhere between<span class="math inline">\(x = 1.91\)</span> and 1.905.</p></div><p>图 8.5的最后两帧中出现的弯曲引起了我们的兴趣，暗示了一些可能值得探索的方向。那么，究竟有多少弯曲是可能的呢？兴趣似乎集中在接近2的轨迹上，但又略微带有复数特性。为了探讨这一点，我们进行了一次实验，将轨迹<span class="math inline">\(t_b\)</span> 固定为安全的 3，然后让 <span class="math inline">\(t_a\)</span> 通过值 <span class="math inline">\(x+ 0.05i\)</span> 变化，其中 <span class="math inline">\(x\)</span>是一个实数，起始值为 3，并逐渐减小到某个尚未确定的危险过渡值。图 8.8展示了初步结果。第一帧只是一个略微晃动的圆形。第二帧和第三帧显示出一些隆起的形成，第3 帧在 <span class="math inline">\(x = 2\)</span>时出现了螺旋的初步迹象。从混乱的第四帧中，我们推断出在 <span class="math inline">\(x = 2.0\)</span> 到 <span class="math inline">\(x= 1.9\)</span>之间的某个位置，我们跨越了边界。最后一帧的实时版本更加有趣：DFS算法疯狂地交叉扫描图像，试图绘制一个实心的黑色正方形。为了更精确地定位过渡点，在图8.9 中，我们将 <span class="math inline">\(x\)</span> 从 2.0 到 1.9以更小的增量减少。从 1.97 到 1.94 再到1.91，你可以看到极限集上的隆起逐渐发展成明显且越来越紧密旋转的螺旋。我们从早前的探索中知道，边界位于<span class="math inline">\(x = 1.90\)</span> 之上；当我们小心翼翼地走到1.905 时，DFS图尝试保持“理智”了一段时间，直到它的动荡行为最终显现出来，我们终止了程序，至少让我们看到了仍然明显存在的一些螺旋。我们已经将过渡到混乱的边界定位在<span class="math inline">\(x = 1.91\)</span> 和 1.905 之间。</p><figure id="fig-8.9"><img src="/images/indra/fig-8.9.jpg" width="500" alt="Figure 8.9. In this refined probe, t_b = 3 and t_a = x + 0.05i with x varying from 1.97 down to 1.905. In (iv), the program was terminated prematurely, when the erratic nature of the plot became clear. 图 8.9. 在这个改进的探针中，t_b = 3，t_a = x + 0.05i，其中 x 从 1.97 变化到 1.905。在 (iv) 中，当图像的不规则性变得明显时，程序被提前终止。"><figcaption aria-hidden="true">Figure 8.9. In this refined probe, <span class="math inline">\(t_b = 3\)</span> and <span class="math inline">\(t_a = x + 0.05i\)</span> with <span class="math inline">\(x\)</span> varying from 1.97 down to 1.905. In(iv), the program was terminated prematurely, when the erratic nature ofthe plot became clear.<br>图 8.9. 在这个改进的探针中，<span class="math inline">\(t_b =3\)</span>，<span class="math inline">\(t_a = x + 0.05i\)</span>，其中<span class="math inline">\(x\)</span> 从 1.97 变化到 1.905。在 (iv)中，当图像的不规则性变得明显时，程序被提前终止。</figcaption></figure><h1 id="transition-to-madness">Transition to madness</h1><div class="statement simple plain unnumbered"><p>We have now three times bumped into places where our limit set plothas gone wild. What is going on? As we warned at the outset, there is noreason to expect that our limit set plot, bereft of the Schottkycircles, will produce anything reasonable at all. The greater miracle,perhaps, is that it ever does! What is happening here is this. If youmultiply a large number of matrices together, then you would expect thatthe resulting matrix product would automatically get ‘large’. In thegroups which produce reasonable limit sets this is certainly the case.What is going wrong when the limit set goes haywire is that a word inthe group which is a long matrix product of many generators unexpectedlyturns out to be actually very ‘small’. The matrices cancel in amysterious way, so the manner in which this particular group elementmoves points around in the plane is not at all what you might expect. Ofcourse, not all entries can be near 0 because the determinant of anymatrix in our group is always to equal to 1. So what we mean by sayingthat a matrix is ‘small’ is that it is very near the identity matrix<span class="math inline">\(I\)</span>. From this point of view, <span class="math inline">\(I\)</span> is the ‘smallest’ matrix and we measurehow large a matrix is by measuring the distance of its entries fromthose of <span class="math inline">\(\begin{pmatrix} 1 &amp; 0 \\ 0&amp; 1 \end{pmatrix}\)</span>. Groups for which large products stayaway from <span class="math inline">\(I\)</span> are calleddiscrete.</p></div><p>我们现在已经遇到三次极限集图形异常的情况。这是怎么回事呢？正如我们一开始所警告的，完全没有理由期望没有Schottky圆的极限集图形会产生任何合理的结果。也许更大的奇迹是，它居然偶尔会产生一些合理的东西！现在发生的情况是这样的。如果你将大量矩阵相乘，那么你会期望结果矩阵的乘积会自动变得“很大”。在那些能够产生合理极限集的群体中，这种情况无疑是成立的。而当极限集出现异常时，问题出在某个群中的一个词，它是许多生成元的长矩阵积，结果竟然变得非常“小”。这些矩阵以一种神秘的方式相互抵消，因此这个特定群元素在平面上移动点的方式与你预期的完全不同。当然，并非所有的元素都可以接近0，因为我们群中任何矩阵的行列式总是等于1。那么，当我们说一个矩阵是“小”的时候，指的是它非常接近单位矩阵 <span class="math inline">\(I\)</span>。从这个角度来看，<span class="math inline">\(I\)</span>是“最小”的矩阵，我们通过测量矩阵的元素与 <span class="math inline">\(\begin{pmatrix} 1 &amp; 0 \ 0 &amp; 1\end{pmatrix}\)</span> 的元素之间的距离来衡量矩阵的大小。那些大乘积远离<span class="math inline">\(I\)</span> 的群称为离散群。</p><div class="statement simple plain unnumbered"><p>You can look for discreteness in our plots by seeing how close <span class="math inline">\(M(z)\)</span> can get to <span class="math inline">\(z\)</span>, for any point <span class="math inline">\(z\)</span> in the plane. In the groups we havestudied so far, you can always find tiles which cover all of theordinary set, that is, all parts of the plane not occupied by the limitset itself. If you sit at a point <span class="math inline">\(z\)</span>in the middle of one tile, no points in any other tile can be too close,because no point can be nearer to you than the edges of your tile. Butif <span class="math inline">\(M\)</span> was very near to <span class="math inline">\(I\)</span>, then <span class="math inline">\(M(z)\)</span> would be very near to <span class="math inline">\(I(z) = z\)</span>. This shows that very nastycancellations can never occur as long as there are some ‘limit set free’regions in the plane which can be covered by tiles.</p></div><p>可以通过观察我们图表中的离散性，来查看平面上任意点 <span class="math inline">\(z\)</span> 能有多接近 <span class="math inline">\(M(z)\)</span>。在我们目前研究的群组中，你总能找到一些瓷砖，覆盖整个普通集，即覆盖平面上那些没有被极限集本身占据的部分。如果你坐在某个瓷砖中间的点<span class="math inline">\(z\)</span>，那么其他瓷砖上的任何点都不会离你太近，因为没有点能比你的瓷砖边缘更接近你。但如果<span class="math inline">\(M\)</span> 非常接近 <span class="math inline">\(I\)</span>，那么 <span class="math inline">\(M(z)\)</span> 就会非常接近 <span class="math inline">\(I(z) =z\)</span>。这表明，只要平面上存在一些可以被瓷砖覆盖的“无极限集”区域，就永远不会发生非常糟糕的抵消现象。</p><div class="statement simple plain unnumbered"><p>It turns out that there is yet another layer of complication becausethere are groups for which there is no ordinary set at all but which arestill discrete. We will look at these in Chapter 10 where we shall bemeeting some amazing pictures of groups which are discrete in the strictsense that they contain no matrices too close to <span class="math inline">\(I\)</span>, but for which the limit set plot fillsout the whole plane, in a magically organised and yet extremelycomplicated way. For now, though, looking at whether or not the computerplot goes wild and seems to be filling up the page will not lead you farwrong. If you can find a tiling, then it shows you visually that thegroup is discrete, and if there is no tiling, you had better watchout!</p></div><p>事实证明，还有另一层复杂性存在，因为有些群体根本没有普通集，但它们仍然是离散的。我们将在第10章中讨论这些群体，届时我们将看到一些令人惊叹的群体图像，这些群体在严格意义上是离散的，因为它们不包含过于接近<span class="math inline">\(I\)</span>的矩阵，但它们的极限集却以一种神奇且极其复杂的方式填满了整个平面。不过，暂时而言，观察计算机绘图是否失控并看起来似乎填满整个页面，通常不会让你走错方向。如果你能找到密铺图案，那么它直观地向你展示了该群体是离散的；如果没有密铺图案，那你最好小心了！</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>隐私政策</title>
      <link href="/privacy/index.html"/>
      <url>/privacy/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://neozhaoliang.github.io">本站</a> 使用 Google提供的广告服务（Google AdSense）以展示广告并支持网站运营。</p><h1 id="我们收集使用的信息">我们收集/使用的信息</h1><p>当你访问本站时，浏览器可能会自动提供一些信息（例如 IP地址、浏览器类型、访问时间、访问页面等），用于网站安全与统计分析。</p><h1 id="第三方广告与-cookie标识符">第三方广告与 Cookie/标识符</h1><p>Google 及其合作伙伴可能会使用Cookie、设备标识符或类似技术来投放广告，包括根据你的兴趣展示个性化广告，或投放非个性化广告。</p><p>这些技术也可能用于广告频次控制、汇总广告效果报告以及防止欺诈与滥用。</p><h1 id="你的选择">你的选择</h1><p>你可以在浏览器设置中管理 Cookie（包括清除与禁用）。</p><p>你也可以在 Google 的广告设置页面中管理个性化广告偏好。</p><p>若你位于需要同意机制的地区，你可以通过本站的同意弹窗选择接受、拒绝或管理选项，并可随时撤回同意。</p><h1 id="联系我们">联系我们</h1><p>如对本政策有疑问，请联系 <code>mathzhaoliang@gmail.com</code>。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Humphreys《反射群与 Coxeter 群》笔记</title>
      <link href="/humphreys/index.html"/>
      <url>/humphreys/index.html</url>
      
        <content type="html"><![CDATA[<p>本文是我学习 <span class="citation" data-cites="Humphreys90">Humphreys (<a href="#ref-Humphreys90" role="doc-biblioref">1990</a>)</span> 时的一些笔记。</p><span id="more"></span><h1 id="generation-by-simple-reflections">1.5 Generation by simplereflections</h1><p>这一节证明了整个反射群 <span class="math inline">\(W\)</span>可以由单反射 <span class="math inline">\(\{s_\alpha\mid\alpha\in\Delta\}\)</span>生成。</p><div id="thm-1.5" class="statement sta____1_5 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">定理1.5</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 可以由 <span class="math inline">\(\{s_\alpha\mid\alpha\in\Delta\}\)</span>生成。</p></div><p><strong>证明概要</strong>：设 <span class="math inline">\(W'\)</span> 是 <span class="math inline">\(\{s_\alpha\mid\alpha\in\Delta\}\)</span>生成的群。目标是证明 <span class="math inline">\(W'=W\)</span>。我们来一步步推理：</p><ol type="1"><li>由于 <span class="math inline">\(W\)</span>是由关于整个根系的镜面反射 <span class="math inline">\(\{s_\beta\mid\beta\in\Phi\}\)</span> 生成的，所以只要证明每个生成元 <span class="math inline">\(s_\beta\in W'\)</span> 即可。</li><li>要证明 1，只要证明任何 <span class="math inline">\(\beta\in\Phi\)</span> 可以写成 <span class="math inline">\(\beta=w'\alpha\)</span> 的形式，其中 <span class="math inline">\(w'\in W',\,\alpha\in\Pi\)</span>。这样<span class="math inline">\(s_\beta=w's_\alpha w'^{-1}\inW'\)</span>。</li><li>要证明 2，只需要分析 <span class="math inline">\(\beta\)</span>是正根且不是单根的情形，因为 <span class="math inline">\(-\beta =w's_\alpha\alpha\)</span>。</li><li>如果 <span class="math inline">\(\beta&gt;0\)</span> 但不是单根，设<span class="math inline">\(\beta=\sum c_s\alpha_s\)</span>，那么 <span class="math inline">\(0&lt;(\beta,\beta)=\sum c_s(\beta,\alpha_s)\)</span>，这说明一定存在单根 <span class="math inline">\(\alpha_s\)</span> 满足 <span class="math inline">\((\beta,\alpha_s)&gt;0\)</span>。考察 <span class="math inline">\(\gamma=s\beta\)</span>。</li><li><span class="math inline">\(\gamma\)</span> 仍然是正根，并且 <span class="math inline">\(\mathrm{ht}(\gamma) &lt;\mathrm{ht}(\beta)\)</span>。如果 <span class="math inline">\(\gamma\)</span> 不是单根，那就一直重复此步骤直到<span class="math inline">\(\gamma\)</span>变成单根为止。这个操作一定会在有限次后终止，否则我们会得到一个无穷的、高度严格降低、从而互不相同的正根序列，这与根系是有限集矛盾。</li><li>设 <span class="math inline">\(\gamma=s_1\cdotss_r\beta\in\Delta\)</span> 是最终得到的单根，则 <span class="math inline">\(\beta\in W'\Delta\)</span>，结论成立。<span class="math inline">\(\blacksquare\)</span></li></ol><h1 id="the-length-function">1.6 The length function</h1><p>这一节证明了函数 <span class="math inline">\(n(w)\)</span>满足的递推关系。</p><p>设 <span class="math inline">\(\mathrm{Neg}(w)\)</span> 是那些被<span class="math inline">\(w\)</span> 变成负根的正根的集合： <span class="math display">\[\mathrm{Neg}(w)=\{\lambda&gt;0,\lambda\in\Phi\midw\lambda&lt;0\}.\]</span> 并记 <span class="math inline">\(n(w)=|\mathrm{Neg}(w)|\)</span>。</p><div id="lem-1.6" class="statement sta____1_6 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">引理1.6</span>.</span><span class="statement-spah"> </span> 函数 <span class="math inline">\(n(w)\)</span> 满足如下的递推关系： <span class="math display">\[n(ws_\alpha)=\begin{cases}n(w)+1 &amp; w\alpha&gt;0,\\n(w)-1 &amp; w\alpha&lt;0.\end{cases}\]</span></p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在后面 5.4 节中，针对一般的 Coxeter 群证明了长度函数 <span class="math inline">\(l(w)\)</span> 也满足同样的递推关系，从而 <span class="math inline">\(l(w)=n(w)\)</span>。但是那里的证明要复杂一些。</p></div><p><strong>证明</strong>：首先注意到任何单根 <span class="math inline">\(\alpha\in\Delta\)</span> 必然恰好属于 <span class="math inline">\(\mathrm{Neg}(w)\)</span> 或者 <span class="math inline">\(\mathrm{Neg}(ws_\alpha)\)</span> 之一，这取决于<span class="math inline">\(w\alpha\)</span> 是正根还是负根：</p><ul><li><span class="math inline">\(w\alpha&lt;0\Rightarrow\alpha\in\mathrm{Neg}(w)\)</span>。</li><li><span class="math inline">\(w\alpha&gt;0\Rightarrowws_\alpha\alpha&lt;0\Rightarrow \alpha\in\mathrm{Neg}(ws_\alpha)\)</span>。</li></ul><p>另一方面对任何正根 <span class="math inline">\(\gamma\ne\alpha\)</span>，<span class="math inline">\(s_\alpha\gamma\)</span> 仍然是正根。从恒等式 <span class="math display">\[(ws_\alpha)\gamma &lt; 0\Longleftrightarroww(s_\alpha\gamma)&lt;0\]</span> 可见 <span class="math inline">\(\gamma\in\mathrm{Neg}(ws_\alpha)\)</span> 当且仅当<span class="math inline">\(\gamma\in\mathrm{Neg}(w)\)</span>，所 <span class="math inline">\(\gamma\leftrightarrow s_\alpha\gamma\)</span>给出了 <span class="math inline">\(\mathrm{Neg}(ws_\alpha)\)</span> 和<span class="math inline">\(\mathrm{Neg}(w)\)</span> 中除 <span class="math inline">\(\alpha\)</span> 之外的正根的一一对应，所以</p><p><span class="math display">\[n(ws_\alpha)=\begin{cases}n(w)+1 &amp; \alpha\in\mathrm{Neg}(ws_\alpha),\\n(w)-1 &amp; \alpha\in \mathrm{Neg}(w).\end{cases}\]</span></p><p><span class="math inline">\(\blacksquare\)</span></p><h1 id="deletion-and-exchange-conditions">1.7 Deletion and ExchangeConditions</h1><p>这一节证明了有限反射群必然满足 deletion 和 exchange条件。开头的定理乍看起来非常不直观，包含了一大堆下标。我来解释下背后的几何直观。</p><p>设 <span class="math inline">\(w=s_1\cdots s_r\)</span> 是 <span class="math inline">\(W\)</span> 的任一元素。从基本区域 <span class="math inline">\(C\)</span> 出发，我们有一个gallery，即一列两两相邻的房间</p><p><span class="math display">\[C,\, s_1C,\, s_1s_2C,\, \ldots,\,s_1\cdots s_rC.\]</span></p><p>可以这样理解：记 <span class="math inline">\(w_i=s_1\cdotss_i\)</span>，则 <span class="math inline">\(w_{i-1}\)</span>将相邻的两个房间 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(s_iC\)</span> 映射为另外两个相邻的房间 <span class="math inline">\(w_{i-1}C\)</span> 和 <span class="math inline">\(w_iC\)</span>。</p><p>不仅如此，由于 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(s_iC\)</span> 之间的墙壁是超平面 <span class="math inline">\(H_i = H_{s_i}\)</span>，它在 <span class="math inline">\(w_{i-1}\)</span> 作用下被映射为超平面 <span class="math inline">\(w_{i-1}H_i\)</span>，所以 <span class="math inline">\(w_{i-1}C\)</span> 和 <span class="math inline">\(w_iC\)</span> 之间的墙壁是 <span class="math inline">\(w_{i-1} H_i\)</span>。即</p><p><span class="math display">\[C\stackrel{H_1}{\bigl\lvert} s_1C\stackrel{s_1H_2}{\bigl\lvert}s_1s_2C\stackrel{\quad}{\bigl\lvert}\cdots\stackrel{w_{r-1}H_r}{\bigl\lvert}w_{r}C.\]</span></p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>表达式 <span class="math inline">\(w=s_1s_2\cdots s_r\)</span>是既约的，当且仅当上述镜面集合 <span class="math display">\[\{H_1,s_1H_2,\ldots,s_1\cdotss_{r-1}H_r\}\]</span> 互不相同。</p></div><p>这个引理的含义是，任何既约单词对应的 gallery不能两次跨越同一个超平面。</p><p>这个引理的证明见 4.5 小节 simpletransitivity。那里仿射的情形和这里的证明是一样的。</p><p>我们来问问自己，如果一个镜子在上面的集合中出现两次会发生什么？设<span class="math inline">\(1\leq i&lt;j\leq r\)</span> 使得 <span class="math display">\[s_1\cdots s_{i-1}H_i = s_1\cdotss_{j-1}H_j.\]</span> 两边消去 <span class="math inline">\(s_1\cdotss_{i-1}\)</span> 得到 <span class="math display">\[H_i = s_i\cdotss_{j-1}H_j.\]</span> 即 <span class="math display">\[s_i = (s_i\cdotss_{j-1})s_j(s_{j-1}\cdots s_i)=(s_i\cdots s_{j})(s_{j-1}\cdotss_i).\]</span> 把右边的 <span class="math inline">\(s_{j-1}\cdotss_i\)</span> 挪到左边来得到 <span class="math display">\[s_{i+1}\cdotss_{j-1} = s_i\cdots s_j.\]</span> 这意味着 <span class="math inline">\(s_i\cdots s_j\)</span> 这一段可以用更短的 <span class="math inline">\(s_{i+1}\cdots s_{j-1}\)</span>来代替，这就是书中定理 1.7 中的 (c)。</p><h1 id="generators-and-relations">1.9 Generators and relations</h1><p>这是比较难读的一节。这一节证明了满足 deletion 条件的有限反射群一定是Coxeter 群。</p><div id="thm-1.9" class="unnumbered statement sta____1_9 plain"><p><span class="statement-heading"><span class="statement-label">定理1.9</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\Delta\)</span> 是某 Euclidean 的一组基，<span class="math inline">\(S=\{s_\alpha\mid \alpha\in\Delta\}\)</span>是一组单反射，<span class="math inline">\(W\)</span> 是 <span class="math inline">\(S\)</span> 生成的群，并且 <span class="math inline">\(W\)</span> 满足 deletion 条件。则 <span class="math inline">\(W\)</span> 具有表现 <span class="math display">\[(s_\alpha s_\beta)^{m_{\alpha,\beta}}=1.\]</span>其中 <span class="math inline">\(m_{\alpha,\beta}\geq1\in\mathbb{Z}\)</span>。</p></div><p>注意 <span class="math inline">\(m_{\alpha,\alpha}=1\)</span>。</p><p><strong>证明</strong>：我们要说明生成元之间的任何关系 <span class="math display">\[s_1s_2\cdots s_r=1\]</span> 都可以通过形如 <span class="math inline">\((s_\alpha s_\beta)^{m_{\alpha,\beta}}=1\)</span>这样的关系推导出来。</p><p>若不然，设 <span class="math display">\[s_1s_2\cdots s_r=1,\quadr=2q\]</span> 是一个长度最短的反例。这里 <span class="math inline">\(r\)</span> 必须是偶数，因为每个 <span class="math inline">\(\det s_i=-1\)</span>。</p><p>我们将证明有 <span class="math inline">\(s_1=s_3=\cdots\)</span> 以及<span class="math inline">\(s_2=s_4=\cdots\)</span>成立，从而上述关系可以写成 <span class="math inline">\((s_1s_2)^q=1\)</span>，得出矛盾。</p><ul><li><p>我们只要证明 <span class="math inline">\(s_1=s_3\)</span>即可。然后将结论用在 <span class="math inline">\(s_2s_3\cdotss_rs_1=1\)</span> 上得到 <span class="math inline">\(s_2=s_4\)</span>；再进一步用在 <span class="math inline">\(s_3s_4\cdots s_rs_2s_1=1\)</span> 上得到 <span class="math inline">\(s_3=s_5\)</span>，等等。</p></li><li><p>为此我们只要证明如下两个等式：</p><p>(I). <span class="math inline">\(s_1s_2\cdots s_q=s_2s_3\cdotss_{q+1}\)</span>.</p><p>(II). <span class="math inline">\(s_3s_2\cdots s_q=s_2s_3\cdotss_{q+1}\)</span>.</p><p>这两个式子几乎是一样的，第一个最左边是 <span class="math inline">\(s_1\)</span>，第二个最左边是 <span class="math inline">\(s_3\)</span>，所以如果它们都成立的话就有 <span class="math inline">\(s_1=s_3\)</span>。</p></li><li><p>为了证明 I，我们把 <span class="math inline">\(s_1\cdotss_r=1\)</span> 改写为 <span class="math display">\[s_1\cdots s_{q+1} =s_r\cdots s_{q+2}.\]</span> 左边是 <span class="math inline">\(q+1\)</span> 项的乘积，右边是 <span class="math inline">\(q-1\)</span> 项的乘积，所以 <span class="math inline">\(l(s_1\cdots s_{q+1})\leq q-1\)</span>。根据deletion 条件，存在 <span class="math inline">\(1\leq i&lt;j\leqq+1\)</span> 使得有 <span class="math display">\[s_i\cdots s_j =s_{i+1}\cdots s_{j-1}. \tag{$\ast$}\]</span> 我们来论证 <span class="math inline">\(i=1,j=q+1\)</span>，也就是 I 成立。若不然，<span class="math inline">\((\ast)\)</span> 式至多包含 <span class="math inline">\(2q-2=r-2\)</span> 项，从而由假设可以由 Coxeter关系 <span class="math inline">\(\{(s_\alphas_\beta)^{m_{\alpha,\beta}}=1\mid \alpha,\beta\in\Delta\}\)</span>推导出来。然而 <span class="math inline">\((\ast)\)</span> 式等价于<span class="math display">\[s_1\cdots s_r =s_1\cdots\hat{s_i}\cdots\hat{s_j}\cdots s_r.\]</span> 此外我们已知 <span class="math inline">\(s_1\cdots s_r=1\)</span>，所以 <span class="math display">\[s_1\cdots\hat{s_i}\cdots\hat{s_j}\cdotss_r=1.\]</span> 根据 <span class="math inline">\(r\)</span>的选取，<span class="math inline">\(s_1\cdots\hat{s_i}\cdots\hat{s_j}\cdotss_r=1\)</span> 可以由 Coxeter 关系推导得到，从而 <span class="math inline">\(s_1\cdots s_r=1\)</span>也可以，这导致了矛盾，于是 I 得证。</p></li><li><p>为了证明 II，将 <span class="math inline">\(s_1\cdots s_r=1\)</span> 改写为 <span class="math inline">\(s_2\cdotss_rs_1=1\)</span>，仿照 I 的证明，我们可以得到 <span class="math display">\[s_2\cdots s_{q+1} = s_3(s_4\cdotss_{q+2}).\]</span> 把 <span class="math inline">\(s_3\)</span>挪到左边的前面，把 <span class="math inline">\(s_4\cdotss_{q+2}\)</span> 挪到左边的后面，得到 <span class="math display">\[s_3s_2\cdots s_{q+1}s_{q+2}\cdots s_4 =1.\]</span> 仍然和 I 的证明同理，我们可以得到 <span class="math display">\[s_3s_2\cdots s_q = s_2\cdots s_{q+1}.\]</span>这就是 II 中的等式。</p></li></ul><p><span class="math inline">\(\blacksquare\)</span></p><h1 id="subgraphs">2.6 Subgraphs</h1><p>在本节中，<span class="math inline">\(\Gamma\)</span> 是一个不可约Coxeter 图，内积 <span class="math inline">\((\alpha_s,\alpha_t)=-\cos\frac{\pi}{m_{s,t}}\)</span>是半正定的，但不是正定的。</p><p>记 <span class="math inline">\(N=\{v\in V\mid (v,v)=0\}\)</span> 以及<span class="math display">\[\mathrm{rad}(V)=\{v\in V\mid (v, u)=0\text{ for all } u \in V\}.\]</span> 显然 <span class="math inline">\(\mathrm{rad}(V)\)</span> 总是 <span class="math inline">\(V\)</span> 的子空间并且 <span class="math inline">\(\mathrm{rad}(V)\subset N\)</span>，但是一般来说<span class="math inline">\(N\)</span> 并不是 <span class="math inline">\(V\)</span> 的子空间。</p><p>但是在内积半正定时，我们有如下的结论：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>若内积半正定，则 <span class="math inline">\(N=\mathrm{rad}(V)\)</span>。</p></div><p>证明：只要证明 <span class="math inline">\(N\subset\mathrm{rad}(V)\)</span> 即可，即若 <span class="math inline">\(u\in V\)</span> 满足 <span class="math inline">\((u,u)=0\)</span>，则对任何 <span class="math inline">\(v\in V\)</span> 都有 <span class="math inline">\((u,v)=0\)</span>。若不然，设 <span class="math inline">\(v\)</span> 满足 <span class="math inline">\((u,v)\ne0\)</span>，我们给 <span class="math inline">\(v\)</span> 乘以适当实数使得 <span class="math inline">\((u,v)=1\)</span>。设 <span class="math inline">\(k\)</span> 是实数，考虑向量 <span class="math inline">\(z=ku +v\)</span>： <span class="math display">\[(z,z)=(ku+v,ku+v) = (v,v) + 2k.\]</span>所以只要选择 <span class="math inline">\(k\)</span> 满足 <span class="math inline">\(2k &lt; -(v,v)\)</span> 就有 <span class="math inline">\((z,z)&lt;0\)</span>，这与内积的半正定性矛盾。<span class="math inline">\(\blacksquare\)</span></p><p>这一节的主要结论是：</p><div id="-------2-6" class="unnumbered statement sta____2_6 plain"><p><span class="statement-heading"><span class="statement-label">命题2.6</span>.</span></p><ol type="1"><li><span class="math inline">\(\mathrm{rad}(V)\)</span>是一维的，由一个向量 <span class="math inline">\(\delta=\sum_{s\inS}c_s\alpha_s\)</span> 生成，并且每个系数 <span class="math inline">\(c_s\)</span> 都大于 0。</li><li><span class="math inline">\(\Gamma\)</span>删去任意多个顶点后得到的子图是正定的。</li></ol></div><p>这里给出一个不同于 Humphreys 书上的证明。</p><p>1 的证明：</p><p>设 <span class="math inline">\(u=\sum_{s\inS}c_s\alpha_s\in\mathrm{rad}(V)\)</span> 是一个非零向量，记 <span class="math display">\[I_+=\{s\in S\mid c_s&gt;0\},\quad I_-=\{s\inS\mid c_s&lt;0\},\quad I_0=\{s\in S\mid c_s=0\}.\]</span> <span class="math display">\[u_+=\sum_{s\in I_+}c_s\alpha_s,\quadu_-=\sum_{s\in I_-}c_s\alpha_s.\]</span> 则 <span class="math inline">\(u=u_++u_-\)</span>，并且 <span class="math display">\[(u_+,u_-)=\sum_{c\in I_+}\sum_{t\inI_-}\underbrace{c_sc_t}_{&lt;0}\,\underbrace{\alpha_s\alpha_t}_{\leq0}\geq0.\]</span></p><p>由于 <span class="math inline">\(u\in\mathrm{rad}(V)\)</span> 所以<span class="math inline">\((u,u)=0\)</span>，即 <span class="math display">\[(u,u)=(u_+,u_+)+(u_-,u_-)+2(u_+,u_-)=0.\]</span>根据半正定性和上面的分析，上式的三项都是非负的，所以只能是 <span class="math display">\[(u_+,u_+)=(u_-,u_-)=(u_+,u_-)=0.\]</span></p><p>此外 <span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 中至少有一个非空，不妨设 <span class="math inline">\(I_+\ne\emptyset\)</span>，我们来证明 <span class="math inline">\(I_-\)</span> 和 <span class="math inline">\(I_0\)</span> 必须都是空集。</p><p>若不然，<span class="math inline">\(I_-\cup I_0\)</span> 非空，任取<span class="math inline">\(t\in I_-\cup I_0\)</span>，设 <span class="math inline">\(\delta\)</span> 是正数，考虑向量 <span class="math inline">\(z=u_+ +\delta\alpha_t\)</span>。我们有</p><p><span class="math display">\[(z,z)=\delta^2+2\delta(u_+,\alpha_t)=\delta^2+2\delta\sum_{s\inI_+}\underbrace{c_s}_{&gt;0}\underbrace{(\alpha_s,\alpha_t)}_{\leq0}.\]</span>注意到每一项 <span class="math inline">\(c_s(\alpha_s,\alpha_t)\leq0\)</span>，所以 <span class="math inline">\(\sum_{s\inI_+}c_s(\alpha_s,\alpha_t)\leq0\)</span>，并且如果存在 <span class="math inline">\(s\in I_+\)</span> 使得 <span class="math inline">\(s\)</span> 与 <span class="math inline">\(t\)</span> 之间有边相连的话则 <span class="math inline">\(\sum_{s\in I_+}c_s(\alpha_s,\alpha_t)\)</span>严格小于 0。这时取 <span class="math inline">\(\delta\)</span>足够小可以使得 <span class="math inline">\((z,z)&lt;0\)</span>，这与内积<span class="math inline">\((,)\)</span>是半正定的矛盾。所以必须是对每个 <span class="math inline">\(s\inI_+\)</span> 有 <span class="math inline">\((\alpha_s,\alpha_t)=0\)</span>。由 <span class="math inline">\(t\)</span> 的任意性可得 <span class="math inline">\(I_-\cup I_0\)</span> 与 <span class="math inline">\(I_+\)</span> 互不连通，但这又与 <span class="math inline">\(\Gamma\)</span> 不可约矛盾。</p><p>总之我们证明了 <span class="math inline">\(\mathrm{rad}(V)\)</span>中非零向量的系数必须同时为正或者同时为负。</p><p>如果 <span class="math inline">\(\mathrm{rad}(V)\)</span>包含两个线性无关的向量 <span class="math inline">\(u,v\)</span>，根据上面的证明，我们可以不妨设 <span class="math inline">\(u,v\)</span>的各项系数都是正数。适当缩放以后我们可以让 <span class="math inline">\(u,v\)</span> 的 <span class="math inline">\(\alpha_1\)</span> 项系数都是 1。于是 <span class="math inline">\(u-v\)</span> 也在 <span class="math inline">\(\mathrm{rad}(V)\)</span> 中，并且其 <span class="math inline">\(\alpha_1\)</span> 项系数是 0，这就导致了矛盾。</p><p>2 的证明：</p><p>我们只要证明若 <span class="math inline">\(I\subsetneqq\Gamma\)</span> 是真子集，则对任何非零向量 <span class="math inline">\(u=\sum_{s\in I}c_s\alpha_s\)</span> 都有 <span class="math inline">\((u,u)&gt;0\)</span>。若不然，<span class="math inline">\(u=\sum_{s\in I}c_s\alpha_s+\sum_{t\notinI}0\cdot\alpha_t\)</span> 并且 <span class="math inline">\((u,u)=0\)</span>，这与 <span class="math inline">\(u\)</span> 的系数必须全部非零矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 id="uniqueness-of-the-degrees">3.7 Uniqueness of the degrees</h1><p>这一节介绍了不变多项式环 <span class="math inline">\(S^G\)</span>的任何一组齐次生成元的次数 <span class="math inline">\(d_1,d_2,\ldots,d_n\)</span>是唯一确定的。证明不难，但是采用的方法很典型，以后会反复用到。</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(f_1,\ldots,f_n\inK[x_1,\ldots,x_n]\)</span> 是一组齐次、代数无关的多项式；其次数分别为<span class="math inline">\(d_1,\ldots,d_n\)</span>；<span class="math inline">\(g_1,\ldots,g_n\)</span>是另一组齐次、代数无关的多项式，次数分别为 <span class="math inline">\(e_1,\ldots,e_n\)</span>，并且每个 <span class="math inline">\(g_i\)</span> 可以写成 <span class="math inline">\(f_1,\ldots,f_n\)</span> 的多项式，则适当重排以后有<span class="math inline">\(e_i\geq d_i\)</span>。</p></div><p>证明：利用链式法则对导可得 <span class="math display">\[\frac{\partial g_i}{\partial x_k} = \sum_{j=1}^n\frac{\partial g_i}{\partial f_j}\frac{\partial f_j}{\partialx_k}.\]</span></p><p>由于 <span class="math inline">\(g_1,\ldots,g_n\)</span>代数无关，根据 Jacobian 判定左边的矩阵 <span class="math inline">\(\left(\frac{\partial g_i}{\partialx_k}\right)\)</span> 可逆，从而右边的矩阵 <span class="math inline">\(\left(\frac{\partial g_i}{\partialf_j}\right)\)</span> 也可逆，其行列式非零，于是存在置换 <span class="math inline">\(\pi\)</span> 使得 <span class="math display">\[\prod_{i=1}^n\frac{\partial g_i}{\partialf_{\pi(i)}}\ne0.\]</span> 适当重排 <span class="math inline">\(g_1,\ldots,g_n\)</span> 以后可以不妨设 <span class="math inline">\(\pi\)</span> 是恒等置换，即 <span class="math display">\[\prod_{i=1}^n\frac{\partial g_i}{\partialf_{i}}\ne0.\]</span> 这说明每个 <span class="math inline">\(\frac{\partial g_i}{\partialf_i}\ne0\)</span>，即当把 <span class="math inline">\(g_i\)</span> 写成<span class="math inline">\(f_1,\ldots, f_n\)</span> 的多项式时，<span class="math inline">\(f_i\)</span> 一定出现在其中。于是至少存在一个形如<span class="math display">\[f_1^{k_1}\cdots f_n^{k_n},\quad k_i\geq1\]</span> 的单项式，它出现在 <span class="math inline">\(g_i\)</span>的表达式中，并且不会被抵消掉。从而 <span class="math inline">\(e_i=\sumk_id_i\geq d_i\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="unique-degrees" class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span><span class="math inline">\(S^G\)</span>的任何一组齐次、代数无关生成元的次数是唯一却定的。</p></div><h1 id="coxeter-elements">3.16 Coxeter elements</h1><p>我们来证明任何两个 Coxeter 元都是共轭的。我们只要取一个特殊的 Coxeter元，并证明其它 Coxeter 元都和这个特殊元共轭即可。</p><p>首先，取 Coxeter 图 <span class="math inline">\(\Gamma\)</span>的一个叶节点，将其记作 <span class="math inline">\(s_n\)</span>。从<span class="math inline">\(\Gamma\)</span> 中移走 <span class="math inline">\(s_n\)</span> 以后，剩下的部分 <span class="math inline">\(\Gamma_1=\Gamma-\{s_n\}\)</span>仍然是一个树，于是我们又可以取其叶节点，记作 <span class="math inline">\(s_{n-1}\)</span>。<span class="math inline">\(\Gamma_1-\{s_{n-1}\}\)</span>仍然是树，又可以取其一个叶节点 <span class="math inline">\(s_{n-2}\)</span>，以此类推。即我们将生成元排列为<span class="math inline">\(s_1,\ldots,s_n\)</span>，使得对每个 <span class="math inline">\(1\leq i\leq n\)</span>，<span class="math inline">\(s_1,\ldots,s_i\)</span> 构成 <span class="math inline">\(\Gamma\)</span> 的一个子树，并且 <span class="math inline">\(s_i\)</span> 是这个树的叶节点。</p><p>首先我们注意到任何 Coxeter 元都可以通过循环移位共轭于某个以 <span class="math inline">\(s_n\)</span> 结尾的 Coxeter 元 <span class="math inline">\(s_{i_1}\cdotss_{i_{n-1}}s_n\)</span>，我们来证明这样的元素都共轭于 <span class="math inline">\(s_1s_2\cdots s_n\)</span>。</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>任何形如 <span class="math inline">\(s_{i_1}\cdotss_{i_{n-2}}{\color{blue}s_{i_{n-1}}}s_n\)</span> 的 Coxeter 元共轭于<span class="math display">\[{\color{blue}s_{i_{n-1}}}s_{i_1}\cdotss_{i_{n-2}}s_n.\]</span></p></div><p><strong>证明</strong>：如果 <span class="math inline">\(s_{i_{n-1}}\)</span> 与 <span class="math inline">\(s_n\)</span> 交换，那么 <span class="math display">\[s_{i_1}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}s_n\to s_{i_1}\cdotss_{i_{n-2}}s_n\textcolor{blue}{s_{i_{n-1}}}\to\textcolor{blue}{s_{i_{n-1}}}s_{i_1}\cdots s_{i_{n-2}}s_n.\]</span>结论成立。否则 <span class="math inline">\(s_n\)</span> 唯一的边是与<span class="math inline">\(s_{i_{n-1}}\)</span> 连接，从而 <span class="math inline">\(s_n\)</span> 与 <span class="math inline">\(\{s_{i_1},\ldots,s_{i_{n-2}}\}\)</span>都交换，所以 <span class="math display">\[\begin{aligned}s_{i_1}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}\textcolor{red}{s_n}&amp;\to\textcolor{red}{s_n}s_{i_1}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}\to s_{i_1}\textcolor{red}{s_n}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}\\&amp;\to s_{i_1}\cdotss_{i_{n-2}}\textcolor{red}{s_n}\textcolor{blue}{s_{i_{n-1}}}\\&amp;\to\textcolor{blue}{s_{i_{n-1}}}s_{i_1}\cdotss_{i_{n-2}}\textcolor{red}{s_n}.\end{aligned}\]</span> 结论同样成立。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(k\geq1\)</span>，任何形如 <span class="math inline">\(s_{i_1}\cdots\textcolor{blue}{s_{i_{n-k}}}s_{n-k+1}\cdots s_n\)</span> 的 Coxeter 元都共轭于 <span class="math display">\[\textcolor{blue}{s_{i_{n-k}}} s_{i_1}\cdotss_{i_{n-k-1}}s_{n-k+1}\cdots s_n.\]</span></p></div><p><strong>证明</strong>：<span class="math inline">\(k=1\)</span>的情形在前一个的引理中已经证明了。对 <span class="math inline">\(k\geq2\)</span> 用归纳法，假设结论对小于 <span class="math inline">\(k\)</span> 的情形成立。</p><p>如果 <span class="math inline">\(s_{i_{n-k}}\)</span> 和 <span class="math inline">\(s_{n-k+1}\)</span> 交换，那么 <span class="math display">\[s_{i_1}\cdots \textcolor{blue}{s_{i_{n-k}}}s_{n-k+1}\cdots s_n\to s_{i_1}\cdotss_{n-k+1}\textcolor{blue}{s_{i_{n-k}}}\cdots s_n.\]</span></p><p>然而对 <span class="math inline">\(k-1\)</span>的情形应用归纳假设，上面右边共轭于 <span class="math display">\[\textcolor{blue}{s_{i_{n-k}}} s_{i_1}\cdotss_{n-k+1}\cdots s_n.\]</span> 于是结论成立。</p><p>如果 <span class="math inline">\(s_{i_{n-k}}\)</span> 和 <span class="math inline">\(s_{n-k+1}\)</span> 不交换，那么 <span class="math inline">\(s_{n-k+1}\)</span> 和所有 <span class="math inline">\(s_{i_1}\sim s_{i_{n-k-1}}\)</span>都交换，于是直接用归纳假设有 <span class="math display">\[s_{i_1}\cdots\textcolor{blue}{s_{i_{n-k}}}\textcolor{red}{s_{n-k+1}}\cdotss_n\to\textcolor{red}{s_{n-k+1}}s_{i_1}\cdots\textcolor{blue}{s_{i_{n-k}}}\cdotss_n\tos_{i_1}\cdots\textcolor{red}{s_{n-k+1}}\textcolor{blue}{s_{i_{n-k}}}\cdotss_n.\]</span> 再一次应用归纳假设，上面右边共轭于 <span class="math display">\[\textcolor{blue}{s_{i_{n-k}}}s_{i_1}\cdots\textcolor{red}{s_{n-k+1}}\cdotss_n.\]</span> 结论同样成立。<span class="math inline">\(\blacksquare\)</span></p><p>这样一来，下面的结论就是显然的了：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>任何 Coxeter 元都共轭于 <span class="math inline">\(s_1\cdotss_n\)</span>。</p></div><h1 id="acting-on-a-plane">3.17 Acting on a plane</h1><p>设 <span class="math inline">\(A=(a_{ij})_{1\leq i,j\leqn}=((\alpha_i,\alpha_j))\)</span> 是 Cartan 矩阵，<span class="math inline">\(\{\omega_i\}_{i=1}^n\)</span> 是关于 <span class="math inline">\(\Delta=\{\alpha_i\}_{i=1}^n\)</span>的对偶基。<span class="math inline">\(A\)</span> 正是 <span class="math inline">\(V\)</span> 上线性变换 <span class="math inline">\(\bf A\)</span> 在基 <span class="math inline">\(\{\omega_i\}\)</span> 下的矩阵： <span class="math display">\[a_{ij}=(\alpha_i,\alpha_j)=({\bfA}\omega_i,\alpha_j).\]</span> 我们知道矩阵 <span class="math inline">\(A\)</span> 有一个特征值 <span class="math inline">\(c\)</span>，它对应的特征向量 <span class="math inline">\((c_1,\ldots, c_n)\)</span> 的分量 <span class="math inline">\(c_i\)</span> 都是大于 0 的，于是 <span class="math inline">\(\sum_{i=1}^nc_i\omega_i\)</span> 是变换 <span class="math inline">\({\bf A}\)</span> 的特征向量： <span class="math display">\[{\bf A}\sum_{i=1}^nc_i\omega_i =\sum_{i=1}^ncc_i\omega_i.\]</span> 另一方面 <span class="math inline">\({\bfA}\sum_{i=1}^nc_i\omega_i=\sum_{i=1}^nc_i\alpha_i\)</span>，所以 <span class="math display">\[\sum_{i=1}^nc_i\alpha_i =\sum_{i=1}^ncc_i\omega_i.\]</span> 两边用某个 <span class="math inline">\(\alpha_j,\,(j\in J)\)</span> 作内积，并注意到<span class="math inline">\(\alpha_j\)</span> 与 <span class="math inline">\(J\)</span> 中除自己之外其它 <span class="math inline">\(J\)</span> 中的 <span class="math inline">\(\alpha_i\)</span> 正交，得到 <span class="math display">\[cc_j=\sum_{i=1}^nc_i(\alpha_i,\alpha_j)=c_j +\sum_{i\in I}c_ia_{ij}.\]</span> 即 <span class="math display">\[(c-1)c_j = \sum_{i\in I}c_ia_{ij}.\]</span>两边乘以 <span class="math inline">\(\omega_j\)</span> 并对 <span class="math inline">\(j\in J\)</span> 求和，然后交换和号得到 <span class="math display">\[\begin{aligned}(c-1)\sum_{j\in J}c_j\omega_j &amp;= \sum_{j\in J}\left(\sum_{i\inI}c_ia_{ij}\right)\omega_j\\&amp;=\sum_{i\in I}c_i\left(\sum_{j\in J}a_{ij}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\sum_{j=1}^n a_{ij}\omega_j- \sum_{j\inI}a_{ij}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\alpha_i- \sum_{j\inI}a_{ij}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\alpha_i- \omega_i-\sum_{j\in I,\,j\nei}\underbrace{a_{ij}}_{=0}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\alpha_i- \omega_i\right)\\&amp;=\sum_{i\in I}c_i\alpha_i- \mu.\\\end{aligned}\]</span> 即 <span class="math inline">\((c-1)\nu + \mu =\sum_{i\in I}c_i\alpha_i\)</span>。注意到 <span class="math inline">\(\sum_{i\in I}c_i\alpha_i\)</span> 被 <span class="math inline">\(x=\prod_{i\in I}s_i\)</span> 映射为它的负 <span class="math inline">\(-\sum_{i\in I}c_i\alpha_i\)</span>。此外 <span class="math inline">\(x\)</span> 保持 <span class="math inline">\(\nu\)</span> 不动，所以 <span class="math inline">\(x\)</span> 保持 <span class="math inline">\(\mu,\nu\)</span> 生成的二维子空间 <span class="math inline">\(P\)</span> 不变。<span class="math inline">\(x\)</span> 作为 <span class="math inline">\(P\)</span> 上的正交变换保持直线 <span class="math inline">\(\nu\)</span> 上的点不动，所以 <span class="math inline">\(x\)</span> 限制在 <span class="math inline">\(P\)</span> 上是一个反射。同理 <span class="math inline">\(y\)</span> 也是如此。所以 <span class="math inline">\(w^t=xy\)</span> 在 <span class="math inline">\(P\)</span> 上的作用是一个旋转。设这个旋转角度是<span class="math inline">\(2\pi/h\)</span>，则 <span class="math inline">\(w^t\)</span> 在 <span class="math inline">\(P\)</span> 上的阶是 <span class="math inline">\(h\)</span>。</p><p>又因为 <span class="math inline">\(\mu+\nu\)</span> 严格属于 <span class="math inline">\(C\cap P\)</span>，所以它在 <span class="math inline">\(w^t\)</span> 作用下一定在 <span class="math inline">\(V\)</span> 中有 <span class="math inline">\(k\)</span> 个不同的像，即 <span class="math inline">\(P\)</span> 上的阶等于它在 <span class="math inline">\(V\)</span> 上的阶。</p><h1 id="the-coxeter-number">3.18 The Coxeter number</h1><p>这一节证明了如下结论：对一个有限 Coxeter 群，正根的个数 <span class="math inline">\(N=|\Phi^+|\)</span>，Coxeter 数 <span class="math inline">\(h\)</span>，单根的个数 <span class="math inline">\(n=|\Delta|\)</span> 满足 <span class="math display">\[N = \frac{nh}{2}.\]</span></p><p>回忆 <span class="math inline">\(y=s_1\cdots s_r,z=s_{r+1}\cdotss_n\)</span> 在 <span class="math inline">\(P\)</span>上的作用都是反射，它们在 <span class="math inline">\(P\)</span>上生成的群是二面体群 <span class="math inline">\(I_2(h)\)</span>，这个群包含 <span class="math inline">\(h\)</span> 个反射和 <span class="math inline">\(h\)</span> 个旋转。记 <span class="math inline">\(I_2(h)\)</span> 中的 <span class="math inline">\(h\)</span> 个反射对应的超平面在 <span class="math inline">\(P\)</span> 上的截线分别是 <span class="math inline">\(L_1,\ldots,L_h\)</span>，这些 <span class="math inline">\(L_i\)</span> 是 <span class="math inline">\(I_2(h)\)</span> 作用在直线 <span class="math inline">\(L=\mathbb{R}\lambda\)</span> 和 <span class="math inline">\(M=\mathbb{R}\mu\)</span> 上得到的。设 <span class="math inline">\(\beta\in\Phi\)</span>，我们来分析 <span class="math inline">\(\beta\)</span> 对应的超平面 <span class="math inline">\(H_\beta\)</span> 在 <span class="math inline">\(P\)</span> 上的截线是什么。</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>对任何 <span class="math inline">\(\beta\in\Phi\)</span>，<span class="math inline">\(H_\beta\cap P\in \{L_1,\ldots,L_h\}\)</span>。</p></div><p>证明：首先注意到 <span class="math inline">\(P\)</span> 不可能包含在<span class="math inline">\(H_\beta\)</span> 中。因为 <span class="math inline">\(P\)</span> 和基本区域 <span class="math display">\[C=\{v\in V\mid (\alpha, v)&gt;0 \text { for all}\alpha\in\Delta\}\]</span> 的交是 <span class="math display">\[P\capC=\{a\lambda + b\mu\mid a&gt;0,b&gt;0\}.\]</span> 它当然是非空的，而<span class="math inline">\(H_\beta\)</span> 不可能包含 <span class="math inline">\(C\)</span> 中的点，所以 <span class="math inline">\(H_\beta\cap P\)</span> 是 <span class="math inline">\(P\)</span> 的一条截线。</p><p>其次如果这条截线不是上述 <span class="math inline">\(\{L_i\}\)</span>任何之一，那么我们可以用 <span class="math inline">\(y,z\)</span>的某个组合将其变换到 <span class="math inline">\(P\cap C\)</span>中，这相当于用某个 <span class="math inline">\(w\in I_2(h)\)</span> 使得<span class="math inline">\(\gamma=w\beta\)</span> 的超平面 <span class="math inline">\(H_\gamma\)</span> 与 <span class="math inline">\(P\)</span> 的交线穿过 <span class="math inline">\(P\cap C\)</span>，这与任何根的镜面与 <span class="math inline">\(C\)</span> 之交为空集矛盾。<span class="math inline">\(\blacksquare\)</span></p><p>我们只要讨论哪些 <span class="math inline">\(H_\beta\)</span> 满足<span class="math inline">\(H_\beta\cap P =L\)</span> 或者 <span class="math inline">\(H_\beta\cap P =M\)</span> 即可。其它的 <span class="math inline">\(L_i\)</span> 由于形如 <span class="math inline">\(L_i=wL\)</span> 或者 <span class="math inline">\(L_i=wM\)</span>，这里 <span class="math inline">\(w\in I_2(h)\)</span>，所以对应的是 <span class="math inline">\(wH_\beta\)</span>。</p><p>如果 <span class="math inline">\(H_\beta\cap P = L\)</span>，则反射<span class="math inline">\(s_\beta\)</span> 保持 <span class="math inline">\(L\)</span> 不动。这时 <span class="math inline">\((\beta,\lambda=0)\)</span>。设 <span class="math inline">\(\beta=\sum\limits_{i=1}^n a_i\alpha_i (a_i\geq0)\)</span>，由于 <span class="math inline">\(\lambda=\sum_{i\inI}c_i\omega_i\)</span>，所以 <span class="math display">\[(\beta,\lambda) = \sum_{i\in I} a_ic_i=0.\]</span> 由于 <span class="math inline">\(c_i(1\leq i\leq n)\)</span>都是正的，所以必须对每个 <span class="math inline">\(i\in I\)</span> 有<span class="math inline">\(a_i=0\)</span>，即 <span class="math inline">\(\beta\)</span> 是 <span class="math inline">\(\{\alpha_j,j\in J\}\)</span> 的线性组合，从而<span class="math inline">\(\beta\)</span> 属于标准椭圆子群 <span class="math inline">\(J\)</span> 的根系 <span class="math inline">\(\Phi_J\)</span>。但是 <span class="math inline">\(J\)</span> 中的生成元两两交换，<span class="math inline">\(\Phi_J\)</span> 中的正根只有 <span class="math inline">\(\{\alpha_j,j\in J\}\)</span>，所以满足 <span class="math inline">\(H_\beta\cap P=L\)</span> 的正根 <span class="math inline">\(\beta\)</span> 有 <span class="math inline">\(|J|=n-r\)</span> 个。</p><p>同样的分析可得满足 <span class="math inline">\(H_\beta\capP=M\)</span> 的正根 <span class="math inline">\(\beta\)</span> 有 <span class="math inline">\(|I|=r\)</span> 个。</p><p>当 <span class="math inline">\(h\)</span> 是偶数时，<span class="math inline">\(I_2(h)\)</span> 在 <span class="math inline">\(\{L_1,\ldots,L_h\}\)</span>上的作用分成两个长度同为 <span class="math inline">\(h/2\)</span>的轨道，分别由 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span> 生成，<span class="math inline">\(L\)</span> 所在的轨道每个超平面来自 <span class="math inline">\(n-r\)</span> 个正根，<span class="math inline">\(M\)</span> 所在的轨道每个超平面来自 <span class="math inline">\(r\)</span> 个正根，所以一共是 <span class="math inline">\(h(n-r)/2 + hr/2 = nh/2=N\)</span> 个正根。</p><p>当 <span class="math inline">\(h\)</span> 是奇数时，<span class="math inline">\(I_2(h)\)</span> 传递地作用在 <span class="math inline">\(\{L_1,\ldots,L_h\}\)</span> 上，所以 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span> 来自同样数目的正根，即 <span class="math inline">\(r=n-r\)</span>，所以 <span class="math inline">\(r=n/2\)</span>。同样地 <span class="math inline">\(N=nh/2\)</span>。</p><p>这里需要对 <span class="math inline">\(h\)</span>的奇偶性分别讨论是因为在二面体群中，奇数时两个生成元是共轭的，偶数时则不共轭。</p><h1 id="eigenvalues-of-coxeter-elements">3.19 Eigenvalues of Coxeterelements</h1><p>设 <span class="math inline">\(u,v\)</span> 是 Coxeter 平面 <span class="math inline">\(P\)</span> 的一组正交基，则 <span class="math inline">\(z=u+iv\)</span> 是 <span class="math inline">\(w\)</span> 在 <span class="math inline">\(V_{\mathbb{C}}\)</span> 上的特征向量，特征值为<span class="math inline">\(e^{2\pi i/h}\)</span>。对任何 <span class="math inline">\(\beta\in\Phi^+\)</span>，<span class="math inline">\((\beta,z)=(\beta,u) + (\beta,v)i\ne0\)</span>，否则会导致 <span class="math inline">\(P\inH_\beta\)</span>，与 <span class="math inline">\(P\cap C\)</span>非空矛盾。</p><p>设 <span class="math inline">\(\{v_i\}\)</span> 是 <span class="math inline">\(V\)</span> 的一组基，<span class="math inline">\(\{x_i\}\in V^\ast\)</span> 是对偶基：<span class="math inline">\(x_i(v_j)=\delta_{ij}\)</span>。<span class="math inline">\(x_1,\cdots,x_n\)</span>是坐标函数，它们是代数无关的：<span class="math inline">\(\mathbb{C}[x_1,\cdots,x_n]\)</span>是一个多项式环。我们把 <span class="math inline">\(\mathbb{C}[x_1,\cdots,x_n]\)</span> 称作 <span class="math inline">\(V\)</span> 上的坐标环，简记作 <span class="math inline">\(\mathbb{C}[V]\)</span>。设 <span class="math inline">\(G\subset GL(V)\)</span>是一个有限的可逆线性变换群，则 <span class="math inline">\(G\)</span>也作用在 <span class="math inline">\(\mathbb{C}[V]\)</span>上：对任何多项式 <span class="math inline">\(f\in\mathbb{C}[V]\)</span>，定义 <span class="math inline">\(g\)</span> 在<span class="math inline">\(f\)</span> 上作用的结果 <span class="math inline">\(g\cdot f\)</span> 为</p><p><span class="math display">\[g\cdot f(v)=f(g^{-1}v).\]</span> 对<span class="math inline">\(f=\sum a_{i_1\cdots i_n}x_1^{i_1}\cdotsx_n^{i_n}\in\mathbb{C}[V]\)</span>，<span class="math inline">\(f\)</span> 在 <span class="math inline">\(v=\sum_{i}c_iv_i\)</span> 处的值为 <span class="math display">\[f(v)=\sum a_{i_1\cdots i_n}x_1(v)^{i_1}\cdotsx_n(v)^{i_n} = \sum a_{i_1\cdots i_n}c_1^{i_1}\cdots c_n^{i_n}.\]</span>于是如果不含常数项的多项式 <span class="math inline">\(f\in\mathbb{C}[V]\)</span> 满足 <span class="math inline">\(f(v_1)\ne 0\)</span>，则若 <span class="math inline">\(f=\sum a_{i_1\cdots i_n}x_1^{i_1}\cdotsx_n^{i_n}\)</span>，我们有 <span class="math display">\[0\ne f(v_1)=\suma_{i_1\cdots i_n}x_1^{i_1}\cdotsx_n^{i_n}\mid_{x_1=1,x_2=\cdots=x_n=0}.\]</span> 即 <span class="math inline">\(f\)</span> 的单项式里面必有一项只含有 <span class="math inline">\(x_1\)</span>。</p><p>进一步，如果 <span class="math inline">\(\frac{\partial f}{\partialx_i}\)</span> 满足 <span class="math inline">\(\frac{\partialf}{\partial x_i}(v_1)\ne0\)</span>，那就说明 <span class="math inline">\(f\)</span> 的单项式里面必有一项形如 <span class="math inline">\(ax_1^{m}x_i\)</span>，即 <span class="math inline">\(f\)</span> 形如 <span class="math inline">\(f=ax_1^mx_i + \cdots\)</span>。</p><p>设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(V\)</span> 上可对角化的线性变换，<span class="math inline">\(Tv_i=\lambda_i v_i\)</span>，则 <span class="math inline">\(Tx_i=\lambda_i^{-1}x_i\)</span>。并且设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(T\)</span>- 不变的多项式，则 <span class="math display">\[f=T\cdot f =a\lambda_1^{-m}x_1^m\lambda_i^{-1}x_i + \cdots.\]</span> 比较即得 <span class="math display">\[ax_1^mx_i =a\lambda_1^{-m}x_1^m\lambda_i^{-1}x_i.\]</span> 即 <span class="math inline">\(1 = \lambda_1^{-m}\lambda_i^{-1}\)</span>，从而<span class="math inline">\(\lambda_i = \lambda_1^{-m}\)</span>。</p><p>对 Coxeter 元 <span class="math inline">\(w\)</span>，它的特征值是<span class="math inline">\(\{\zeta^{m_i},\,1\leq i\leqn\}\)</span>，并且 <span class="math inline">\(m_1=1,m_{n-1}=h-1\)</span>。<span class="math inline">\(m_1=1\)</span> 对应的是 <span class="math inline">\(w\)</span> 的重数为 1 的特征值 <span class="math inline">\(\zeta\)</span>。</p><p>以 <span class="math inline">\(w\)</span> 的特征向量为基，由于 <span class="math inline">\(\zeta\)</span> 对应的特征向量 <span class="math inline">\(v_1\)</span> 在 <span class="math inline">\(C\)</span> 内，它不在任何根平面 <span class="math inline">\(H_\alpha\)</span> 上，所以 Jacobian <span class="math inline">\(J=\det\left(\frac{\partial f_i}{\partialx_j}\right)\)</span> 在 <span class="math inline">\(v_1\)</span> 处不为0，于是某个 <span class="math inline">\(\prod_{i=1}^n \frac{\partialf_i}{\partial x_{\pi(j)}}\)</span> 在 <span class="math inline">\(v_1\)</span> 处不为 0，适当重排 <span class="math inline">\(f_i\)</span> 以后可以不妨设每个 <span class="math inline">\(\frac{\partial f_i}{\partialx_i}(v_1)\ne0\)</span>。根据上面的讨论，<span class="math inline">\(f_i\)</span> 形如 <span class="math display">\[f_i=ax_1^{d_i-1}x_i+\cdots.\]</span> 并且 <span class="math inline">\(\lambda_i=\zeta^{m_i}=\zeta^{1-d_i}\)</span>。从而 <span class="math inline">\(h-m_i\equiv d_i-1\pmodh\)</span>。我们知道对每个 <span class="math inline">\(i\)</span> 有<span class="math inline">\(0&lt;h-m_i&lt;h\)</span>，所以对每个 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(d_i-1\geq h-m_i\)</span>。另一方面，集合 <span class="math inline">\(\{h-m_i\}\)</span> 不过是集合 <span class="math inline">\(\{m_i\}\)</span> 的一个置换，所以 <span class="math display">\[\sum (h-m_i) = \sum m_i = \sum(d_i-1).\]</span>这只能是对每个 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(h-m_i=d_i-1\)</span>，即集合相等 <span class="math inline">\(\{d_i-1\}=\{m_i\}\)</span>。</p><h1 id="counting-hyperplanes">4.4 Counting hyperplanes</h1><p>回忆 <span class="math inline">\(\mathcal{H}\)</span> 是所有超平面<span class="math inline">\(\{H_{\alpha,k}\mid\alpha\in\Phi,k\in\mathbb{Z}\}\)</span> 组成的集合。其中 <span class="math display">\[H_{\alpha,k}=\{v\in V\mid(\alpha,v)=k\}.\]</span></p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span><span class="math inline">\(H_s\)</span> 是 <span class="math inline">\(\mathcal{H}\)</span> 中唯一分隔 <span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 的超平面，即 <span class="math inline">\(\mathcal{L}(s)=\{H_s\}\)</span>。</p></div><p>证明：我们先说明对任何正根 <span class="math inline">\(\beta\ne\alpha_s\)</span>，以及任何 <span class="math inline">\(k\in\mathbb{Z}\)</span>，<span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 都在超平面 <span class="math inline">\(H_{\beta,k}\)</span> 的同一侧。</p><p>首先根据 <span class="math inline">\(A_o\)</span>的刻画，它满足对任何正根 <span class="math inline">\(\gamma\)</span>都有 <span class="math inline">\(0&lt;(A_o,\gamma)&lt;1\)</span>，特别地<span class="math inline">\(0&lt;(A_o,\beta)&lt;1\)</span>。由于 <span class="math inline">\(\beta\ne\alpha_s\)</span> 所以 <span class="math inline">\(s\beta\)</span> 仍然是正根，因此 <span class="math display">\[0&lt;(A_o,s\beta)&lt;1\Longrightarrow0&lt;(sA_o,\beta)&lt;1.\]</span> 这说明 <span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 在 <span class="math inline">\(H_\beta\)</span> 和 <span class="math inline">\(H_{\beta,1}\)</span>围成的带状区域中间。所以对任何 <span class="math inline">\(k\)</span>它们都在 <span class="math inline">\(H_{\beta,k}\)</span> 的同一侧。</p><p>另一方面不难看出 <span class="math inline">\(-1 &lt;(sA_o,\alpha_s)&lt;0\)</span>，也就是说 <span class="math inline">\(sA_o\)</span> 和 <span class="math inline">\(A_o\)</span> 位于 <span class="math inline">\(H_{\alpha_s,0}\)</span> 的两侧，但是对任何 <span class="math inline">\(k\ne0\)</span>，它们位于 <span class="math inline">\(H_{\alpha_s,k}\)</span> 的同侧。</p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>固定 <span class="math inline">\(s\in S_a\)</span>。对任何 <span class="math inline">\(w\in\widehat{W_a}\)</span>，有如下结论成立：</p><ul><li><span class="math inline">\(H_s\)</span> 恰好属于 <span class="math inline">\(\mathcal{L}(w)\)</span> 和 <span class="math inline">\(\mathcal{L}(sw)\)</span> 之一。</li><li><span class="math inline">\(s(\mathcal{L}(w)\setminus\{H_s\}) =\mathcal{L}(sw)\setminus\{H_s\}\)</span>。</li></ul></div><p>证明：第一点是显然的，因为 <span class="math inline">\(wA_o\)</span>和 <span class="math inline">\(swA_o\)</span> 位于 <span class="math inline">\(H_s\)</span> 的两侧，它俩有且恰有一个和 <span class="math inline">\(A_o\)</span> 位于 <span class="math inline">\(H_s\)</span> 的同一侧。</p><p>对于第二点，我们要证明的是 <span class="math inline">\(H\leftrightarrow sH\)</span> 给出了 <span class="math inline">\(\mathcal{L}(w)\)</span> 和 <span class="math inline">\(\mathcal{L}(sw)\)</span> 中除 <span class="math inline">\(H_s\)</span> 之外的超平面的一一对应。然而若 <span class="math inline">\(H\ne H_s\)</span>，根据上面的引理，<span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 位于 <span class="math inline">\(H\)</span> 的同一侧，所以</p><p><span class="math display">\[H\in\mathcal{L}(w)\Longleftrightarrow\begin{matrix}A_o\\ sA_o\end{matrix}\stackrel{H=0}{\biggl\lvert} wA_o\Longleftrightarrow \begin{matrix}sA_o\\A_o\end{matrix}\stackrel{sH=0}{\biggl\lvert} swA_o.\]</span> 可见 <span class="math inline">\(sH\in \mathcal{L}(sw)\)</span> 并且显然 <span class="math inline">\(sH\ne H_s\)</span>。此即为所证。</p><h1 id="a-formula-for-the-order-of-w">4.9 A formula for the order of<span class="math inline">\(W\)</span></h1><p>从前面的学习中我们知道，一个仿射 Weyl 群 <span class="math inline">\(W_a\)</span> 总是可以写成一个有限 Weyl 群 <span class="math inline">\(W\)</span> 和一个格点群 <span class="math inline">\(L\)</span> 的半直积：<span class="math inline">\(W_a=W\ltimes L\)</span>。这里的 <span class="math inline">\(L\)</span> 实际上是 <span class="math inline">\(W\)</span> 的余根格点：<span class="math inline">\(L=L(\Phi^\vee)\)</span>。这一节介绍了怎样计算<span class="math inline">\(W\)</span> 的阶 <span class="math inline">\(|W|\)</span>。</p><p>我们以 <span class="math inline">\(\widetilde{B}_2\)</span>为例来说明。<span class="math inline">\(\Delta\)</span> 包含两个单根<span class="math inline">\(\alpha_1=e_1-e_2,\,\alpha_2=e_2\)</span>。最高根<span class="math inline">\(\widetilde{\alpha}=\alpha_1+2\alpha_2\)</span>，于是<span class="math inline">\(c_1=1,c_2=2\)</span>。</p><p><img style="margin:0px auto;display:block" width="500" src="/images/humphreys/b2.svg"></p><ul><li>图中<strong>黄色</strong>区域是由所有的房间 <span class="math inline">\(\{wA_o\mid w\in W\}\)</span> 组成。即 <span class="math inline">\(\Pi=\bigcup_{w\inW}wA_o\)</span>。另一个等价的描述是 <span class="math display">\[ \Pi =\{x\in V\mid -1 &lt; (x,\alpha) &lt; 1 \text{ for all }\alpha\in\Phi^+\}.\]</span> 所以 <span class="math inline">\(\mathrm{Vol}(\Pi)=|W|\cdot\mathrm{Vol}(A_o)\)</span>。<span class="math inline">\(\Pi\)</span> 是余根格点 <span class="math inline">\(L(\Phi^\vee)\)</span>的基本区域，因为书中已经证明了 <span class="math inline">\(W_a=W\ltimesL\)</span>，并且 <span class="math inline">\(A_o\)</span> 是 <span class="math inline">\(W_a\)</span> 作用下的基本区域，所以 <span class="math inline">\(\Pi\)</span> 在 <span class="math inline">\(L\)</span>的作用下互不相交，并且密铺了整个平面。</li><li>图中<strong>绿色</strong>区域是余权格点 <span class="math inline">\(\hat{L}(\Phi^\vee)\)</span> 的基本区域 <span class="math inline">\(\hat{\Pi}\)</span>，它是一个平行多面体，由基本余权<span class="math inline">\(\{\omega_1,\ldots,\omega_n\}\)</span>张成，并且 <span class="math inline">\(\dfrac{\mathrm{Vol}(\Pi)}{\mathrm{Vol}(\hat{\Pi}) } = f\)</span>。</li><li>基本区域 <span class="math inline">\(A_o\)</span> 是由 <span class="math inline">\(\left\{0,\dfrac{\omega_1}{c_1},\ldots,\dfrac{\omega_n}{c_n}\right\}\)</span>生成的单纯形，它和 <span class="math inline">\(\{\omega_1,\ldots,\omega_n\}\)</span>生成的平行多面体 <span class="math inline">\(\hat{\Pi}\)</span>的体积关系为 <span class="math display">\[\mathrm{Vol}(\hat{\Pi}) =n!c_1\cdots c_n\cdot\mathrm{Vol}(A_o).\]</span></li><li>综上可得 <span class="math display">\[\dfrac{\mathrm{Vol}(\Pi)}{\mathrm{Vol}(\hat{\Pi}) } =\frac{|W|\mathrm{Vol}(A_o)}{n!c_1\cdotsc_n\cdot\mathrm{Vol}(A_o)}=f.\]</span> 即 <span class="math inline">\(|W| = n!c_1\cdots c_n f\)</span>。</li></ul><h1 id="bruhat-ordering">5.9 Bruhat ordering</h1><p>这一节介绍了 Bruhat 序，以及重要的 lifting property。Humphreys书中是先介绍的 liftingproperty，然后在下一小节证明子表达式定理。实际上，如果我们采用 Bjornerand Brenti 教材的处理方式，先证明子表达式定理的话，那么 lifting property更好证。</p><div id="lifting" class="unnumbered statement sta_lifting_property plain"><p><span class="statement-heading"><span class="statement-label">Liftingproperty</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(u&lt; w\)</span>，<span class="math inline">\(s\inS\)</span> 满足 <span class="math inline">\(sw&lt;w\)</span> 和 <span class="math inline">\(su&gt;u\)</span>，则 <span class="math inline">\(u\leq sw\)</span> 并且 <span class="math inline">\(su\leq w\)</span>。</p></div><p>证明：用 <span class="math inline">\(\alpha\prec\beta\)</span> 表示word <span class="math inline">\(\alpha\)</span> 是 word <span class="math inline">\(\beta\)</span> 的子表达式。设 <span class="math inline">\(sw=s_1\cdots s_q\)</span> 是 <span class="math inline">\(sw\)</span> 的一个既约表示。由于 <span class="math inline">\(sw&lt;w\)</span>，所以 <span class="math inline">\(w=ss_1\cdots s_q\)</span> 也是既约表示。又因为已知<span class="math inline">\(u&lt;w\)</span>，所以根据子表达式定理，存在<span class="math inline">\(u=s_{i_1}\cdots s_{i_k}\)</span>的某个既约表示满足 <span class="math display">\[s_{i_1}\cdotss_{i_k}\prec ss_1\cdots s_q.\]</span> 又已知 <span class="math inline">\(su&gt;u\)</span>，所以 <span class="math inline">\(s\ne s_{i_1}\)</span>，从而 <span class="math display">\[u=s_{i_1}\cdots s_{i_k}\prec s_1\cdotss_q=sw.\]</span> 这意味着 <span class="math display">\[su=ss_{i_1}\cdotss_{i_k}\prec ss_1\cdots s_q=w,\]</span> 从而 <span class="math inline">\(u\leq sw\)</span> 且 <span class="math inline">\(su\leq w\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(u\ne w\)</span>，则存在 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(u&lt;x\)</span> 且 <span class="math inline">\(w&lt;x\)</span>。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(l(u)+l(w)\)</span> 归纳。<span class="math inline">\(l(u)+l(w)=0\)</span>时结论是显然的。假设结论对小于 <span class="math inline">\(l(u)+l(w)\)</span> 的情形已经成立。取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(su&lt;u\)</span>，则根据归纳假设，存在 <span class="math inline">\(y\)</span> 使得 <span class="math inline">\(su&lt;y\)</span> 且 <span class="math inline">\(w&lt;y\)</span>。</p><ol type="1"><li>如果 <span class="math inline">\(sy&lt;y\)</span>，那么由提升引理，<span class="math inline">\(u&lt;y\)</span>，从而 <span class="math inline">\(y\)</span> 就是所求的 <span class="math inline">\(x\)</span>。</li><li>如果 <span class="math inline">\(sy&gt;y\)</span>，那么 <span class="math inline">\(sy\)</span> 就是所求的 <span class="math inline">\(x\)</span>。</li></ol><p><span class="math inline">\(\blacksquare\)</span></p><p>这个推论的一个直接结论是，任何有限 Coxeter 群中必有 Bruhat序下唯一的极大元 <span class="math inline">\(w_0\)</span>。<span class="math inline">\(w_0\)</span> 必然满足 <span class="math inline">\(w_0^2=1\)</span>，因为如果 <span class="math inline">\(w_0\ne w_0^{-1}\)</span>的话，它们就会还有一个更大的覆盖元。</p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>如果 <span class="math inline">\(w\in W\)</span> 满足对任何 <span class="math inline">\(s\in S\)</span> 都有 <span class="math inline">\(sw&lt;w\)</span>，则 <span class="math inline">\(W\)</span> 必然是有限群，并且 <span class="math inline">\(w=w_0\)</span> 是极大元。</p></div><p><strong>证明</strong>：我们对 <span class="math inline">\(l(x)\)</span> 归纳证明对任何 <span class="math inline">\(x\in W\)</span> 有 <span class="math inline">\(x\leq w\)</span>。设结论对长度小于 <span class="math inline">\(l(x)\)</span> 的元素都成立，取 <span class="math inline">\(s\)</span> 使得 <span class="math inline">\(l(sx)&lt;l(x)\)</span>，根据归纳假设 <span class="math inline">\(sx\leq w\)</span>。但是 <span class="math inline">\(sx\)</span> 不可能等于 <span class="math inline">\(w\)</span>，因为 <span class="math inline">\(l(s\cdotsx)=l(x)&gt;l(sx)\)</span>。所以根据提升性质可得 <span class="math inline">\(x\leq w\)</span>。于是 <span class="math inline">\(W\)</span> 中任何元素都在区间 <span class="math inline">\([1,x]\)</span>中，这样的元素显然只有有限多个。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(W\)</span> 是有限群，则对任何<span class="math inline">\(w\in W\)</span> 有 <span class="math inline">\(l(ww_0)=l(w_0)-l(w)\)</span>。</p></div><p><strong>证明</strong>：只要证明 <span class="math inline">\(l(ww_0)\leq l(w_0)-l(w)\)</span> 即可。对 <span class="math inline">\(l(w_0)-l(w)\)</span> 归纳，等于 0 的情况对应 <span class="math inline">\(w=w_0\)</span>，结论显然成立。设 <span class="math inline">\(w&lt;w_0\)</span> 并且结论对任何 <span class="math inline">\(x&gt;w\)</span> 成立。根据上一个推论，必然存在<span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(sw&gt;w\)</span>。对 <span class="math inline">\(sw\)</span> 应用归纳假设可得</p><p><span class="math display">\[l(ww_0)\leq l(sww_0)+1 \leq l(w_0) -l(sw) + 1 = l(w_0) - l(w).\]</span> <span class="math inline">\(\blacksquare\)</span></p><p>对任何 <span class="math inline">\(l(w)\)</span>，记 <span class="math inline">\(T_L(w)=\{t\in T\mid l(tw) &lt;l(w)\}\)</span>。</p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(W\)</span> 是有限群，则对任何<span class="math inline">\(w\in W\)</span> 有 <span class="math inline">\(T_L(ww_0)=T\setminus T_L(w)\)</span>。</p></div><p><strong>证明</strong>：根据上一个推论，<span class="math inline">\(l(tww_0)=l(w_0)-l(tw)\)</span>。所以 <span class="math inline">\(l(tww_0)&gt;l(ww_0)\)</span> 当且仅当 <span class="math inline">\(l(tw)&lt;l(w)\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span><span class="math inline">\(l(w_0)=|T|\)</span>.</p></div><p><strong>证明</strong>：在上一个推论中取 <span class="math inline">\(w=1\)</span> 有 <span class="math inline">\(T_L(w_0)=T\)</span>，结合 <span class="math inline">\(l(w)=|T_L(w)|\)</span> 对任何 <span class="math inline">\(w\in W\)</span> 成立即得。<span class="math inline">\(\blacksquare\)</span></p><h1 id="subexpressions">5.10 Subexpressions</h1><div id="thm-5.10" class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(w=s_1\cdots s_q\)</span>是一个既约表达式，<span class="math inline">\(u\ne w\)</span> 并且 <span class="math inline">\(u\)</span> 的某个既约表达式恰好是 <span class="math inline">\(s_1\cdots s_q\)</span> 的子表达式。则存在 <span class="math inline">\(v\in W\)</span> 满足以下三点：</p><ol type="1"><li><span class="math inline">\(v &gt; u\)</span>。</li><li><span class="math inline">\(l(v) = l(u)+1\)</span>。</li><li><span class="math inline">\(v\)</span> 的某个既约表达式是 <span class="math inline">\(s_1\cdots s_q\)</span> 的子表达式。</li></ol></div><p><strong>证明</strong>：设 <span class="math inline">\(u\)</span>的既约表达式是从 <span class="math inline">\(s_1\cdots s_q\)</span>中删去 <span class="math inline">\(i_1,\ldots,i_k\)</span> 位置得到的：<span class="math display">\[u = s_1\cdots\hat{s_{i_1}}\cdots\hat{s_{i_k}}\cdots s_q.\]</span> 这样的既约表达式可能不唯一，选择使得<span class="math inline">\(i_k\)</span> 最小的那一个。令 <span class="math display">\[t=s_qs_{q-1}\cdots s_{i_k}\cdotss_{q-1}s_q.\]</span> 则 <span class="math inline">\(ut\)</span> 就是把<span class="math inline">\(s_{i_k}\)</span> 补回 <span class="math inline">\(u\)</span> 的表达式中： <span class="math display">\[ut= s_1\cdots\hat{s_{i_1}}\cdots\hat{s_{i_{k-1}}}\cdots s_{i_k}\cdots s_q.\]</span> 这个 <span class="math inline">\(ut\)</span> 的表达式未必是既约的，但是无论如何<span class="math inline">\(l(ut)\)</span> 不会超过这个表达式的长度，即<span class="math inline">\(l(ut)\leql(u)+1\)</span>。我们来证明等号是成立的。如果确实如此，那么取 <span class="math inline">\(v=ut\)</span> 即可满足要求。</p><p>若不然，<span class="math inline">\(l(ut)&lt;l(u)\)</span>，则根据strong exchange 条件，<span class="math inline">\(ut\)</span> 等于在<span class="math inline">\(u\)</span> 的表达式再删掉一个 <span class="math inline">\(s_p\)</span>。这个 <span class="math inline">\(p\)</span> 出现的位置有两种可能：</p><p>第一种可能是 <span class="math inline">\(p&gt;i_k\)</span>，即 <span class="math display">\[ut=s_1\cdots\hat{s_{i_1}}\cdots\hat{s_{i_k}}\cdots \hat{s_p}\cdotss_q.\]</span> 这种情况下 <span class="math inline">\(t\)</span> 还等于<span class="math inline">\(t=s_qs_{q-1}\cdots s_p\cdotss_{q-1}s_q\)</span>。于是 <span class="math display">\[w=wt^2=w(s_qs_{q-1}\cdots s_{i_k}\cdotss_{q-1}s_q)(s_qs_{q-1}\cdots s_p\cdotss_{q-1}s_q)=s_1\cdots\hat{s_{i_k}}\cdots\hat{s_p}\cdots s_q.\]</span>这与 <span class="math inline">\(s_1\cdots s_q\)</span> 是 <span class="math inline">\(w\)</span> 的既约表达式矛盾。</p><p>第二种可能是 <span class="math inline">\(p&lt;i_k\)</span> 出现在<span class="math inline">\(i_k\)</span> 之前的某个位置，当然 <span class="math inline">\(p\notin\{i_1,\ldots,i_k\}\)</span>。这种情况下<span class="math display">\[u=ut\cdott=s_1\cdots\hat{s_{i_1}}\cdots\hat{s_p}\cdots\hat{s_{i_k}}\cdotss_q\cdot(s_qs_{q-1}\cdots s_{i_k}\cdotss_{q-1}s_q)=s_1\cdots\hat{s_{i_1}}\cdots\hat{s_p}\cdots s_{i_k}\cdotss_q.\]</span> 这与 <span class="math inline">\(i_k\)</span>的极小性矛盾。<span class="math inline">\(\blacksquare\)</span></p><p>在上面的例子中我把 <span class="math inline">\(p\)</span> 写在了<span class="math inline">\(i_1\)</span> 和 <span class="math inline">\(i_k\)</span> 中间的某个位置上，实际上 <span class="math inline">\(p\)</span> 当然可以小于 <span class="math inline">\(i_1\)</span>，但这不影响论证。</p><div id="thm-5.10-1" class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(w=s_1\cdots s_q\)</span>是一个既约表达式，则 <span class="math inline">\(u\leq w\)</span>当且仅当 <span class="math inline">\(u\)</span> 的某个既约表达式是 <span class="math inline">\(s_1\cdots s_q\)</span> 的子表达式。</p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>: 设 <span class="math inline">\(u=x_0\xrightarrow{t_1}x_1\xrightarrow{t_2}\cdots\xrightarrow{t_m}x_m=w\)</span>，则根据strong exchange 条件，<span class="math inline">\(x_{m-1}=wt_m\)</span>是 <span class="math inline">\(w\)</span> 的子表达式，进一步 <span class="math inline">\(x_{m-2}=x_{m-1}t_{m-1}\)</span> 是 <span class="math inline">\(x_{m-1}\)</span>的子表达式，这样一直下去，得到一个 <span class="math inline">\(u=x_0\)</span> 的表达式，它是 <span class="math inline">\(s_1\cdots s_q\)</span> 的子表达式。最后根据deletion condition，这个子表达式又包含一个 <span class="math inline">\(u\)</span> 的既约子表达式。</p><p><span class="math inline">\(\Leftarrow\)</span>: 如果 <span class="math inline">\(u\)</span> 的某个既约表达式是 <span class="math inline">\(s_1\cdots s_q\)</span>的子表达式，根据上面的引理，只要 <span class="math inline">\(u\new\)</span>，那么就存在反射 <span class="math inline">\(t\)</span> 使得<span class="math inline">\(u&lt;ut\)</span>，并且 <span class="math inline">\(ut\)</span> 仍然是 <span class="math inline">\(w\)</span> 的子表达式。对 <span class="math inline">\(ut\)</span> 继续此步骤直到结果 <span class="math inline">\(w\)</span> 为止即可。<span class="math inline">\(\blacksquare\)</span></p><h1 id="more-on-the-geometric-representation">6.2 More on the geometricrepresentation</h1><p>这一节证明了如果几何实现中的二次型 <span class="math inline">\(B(\alpha_s,\alpha_t)=-\cos\frac{\pi}{m_{s,t}}\)</span>是正定的，则 <span class="math inline">\(W\)</span>是有限群。这一点是两个结论合起来的结果：</p><div id="discrete-action" class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span><span class="math inline">\(W\)</span> 是 <span class="math inline">\(O(n,\mathbb{R})\)</span> 的离散子集，即对任何<span class="math inline">\(w\in W\)</span>，存在 <span class="math inline">\(w\)</span> 的开邻域 <span class="math inline">\(w\in U\)</span> 使得 <span class="math inline">\(U\)</span> 不包含 <span class="math inline">\(W\)</span> 中除 <span class="math inline">\(w\)</span> 外的任何元素。</p></div><p>证明：固定一个基本区域中的点 <span class="math inline">\(x\inC\)</span>，考虑从 <span class="math inline">\(\mathrm{GL}(V^\ast)\)</span> 到 <span class="math inline">\(V^\ast\)</span> 的连续映射 <span class="math display">\[g\to g\cdot x,\quadg\in\mathrm{GL}(V^\ast).\]</span> <span class="math inline">\(C\)</span>在此映射下的逆像是 <span class="math inline">\(\mathrm{GL}(V^\ast)\)</span> 中的某个开集 <span class="math inline">\(U\)</span>，并且 <span class="math inline">\(U\)</span> 显然包含恒等元 1，因为 <span class="math inline">\(1\cdot x=x\in C\)</span>，即 <span class="math inline">\(U\)</span> 是 1 的一个开邻域。<span class="math inline">\(U\)</span> 不包含其它任何 <span class="math inline">\(w\ne 1\in W\)</span>，否则 <span class="math inline">\(w\cdot x\in C\)</span>，这与 <span class="math inline">\(C\)</span> 是基本区域矛盾。同理任何 <span class="math inline">\(w\in W\)</span> 都有一个开邻域不包含其它 <span class="math inline">\(W\)</span> 中的点。</p><div id="discrete-subgroup" class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>紧 Hausdorff 拓扑群 <span class="math inline">\(G\)</span>的离散子群 <span class="math inline">\(H\)</span> 必然是有限群。</p></div><p>证明：</p><p>第一步：设 <span class="math inline">\(U\)</span> 是单位元 <span class="math inline">\(e\)</span> 的邻域且满足 <span class="math inline">\(U \cap H = \{e\}\)</span>，我们来说明存在一个邻域<span class="math inline">\(e\in V\subset U\)</span> 满足 <span class="math inline">\(VV^{-1}\subset U\)</span>。</p><p>令 <span class="math inline">\(\sigma:U\times U\to G\)</span> 为映射<span class="math inline">\(\sigma(x, y) =xy^{-1}\)</span>。由连续性，存在一个邻域 <span class="math inline">\(N\subset U\times U\)</span> 包含 <span class="math inline">\((e,e)\)</span> 使得 <span class="math inline">\(\sigma(N)\subset U\)</span>。那么 <span class="math inline">\(N\)</span> 包含一个形如 <span class="math inline">\(V_1\times V_2\)</span> 的开集，其中 <span class="math inline">\(V_1, V_2 \subset U\)</span> 是开集且 <span class="math inline">\(e\in V_1\cap V_2\)</span>。取 <span class="math inline">\(V=V_1 \cap V_2\)</span>，于是 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(e\)</span> 的一个邻域，并且 <span class="math inline">\(V\times V\subset V_1\times V_2\)</span>，因此<span class="math inline">\(VV^{-1}=\sigma(V \timesV)\subset\sigma(V_1\times V_2) \subset U\)</span>。</p><p>第二步：我们来论证 <span class="math inline">\(G\backslash H\)</span>是开集。为此只要说明对任意 <span class="math inline">\(x\in G\backslashH\)</span>，存在 <span class="math inline">\(x\)</span> 的邻域 <span class="math inline">\(U\)</span> 使得 <span class="math inline">\(U\capH=\emptyset\)</span>。设 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(e\)</span> 的邻域且 <span class="math inline">\(U\cap H=\{e\}\)</span>。令 <span class="math inline">\(V\subset U\)</span> 为具有上面第一步中性质的 <span class="math inline">\(e\)</span> 的邻域，则 <span class="math inline">\(N=Vx\)</span> 是 <span class="math inline">\(x\)</span> 的邻域。假设 <span class="math inline">\(h_1, h_2\in N\cap H\)</span>，那么存在 <span class="math inline">\(v_1,v_2\in V\)</span> 满足 <span class="math inline">\(h_1 = v_1x\)</span> 且 <span class="math inline">\(h_2=v_2x\)</span>。于是 <span class="math display">\[v_1^{-1}h_1=x=v_2^{-1}h_2\implies h_1h_2^{-1} =v_1v_2^{-1}\in VV^{-1} \subset U.\]</span> 因此 <span class="math inline">\(v_1v_2^{-1}\in H\cap U\)</span>，所以 <span class="math inline">\(h_1h_2^{-1}=e\)</span>，因此 <span class="math inline">\(h_1=h_2\)</span>。这意味着 <span class="math inline">\(N\)</span> 至多包含 <span class="math inline">\(H\)</span> 的一个元素。如果 <span class="math inline">\(N\)</span> 不包含 <span class="math inline">\(H\)</span> 的任何元素，则 <span class="math inline">\(N\)</span> 即为所求。否则若 <span class="math inline">\(N\cap H=\{h\}\)</span>，由于 <span class="math inline">\(G\)</span> 是 Hausdorff 空间，我们可以取开邻域<span class="math inline">\(U_x, U_h\subset N\)</span> 将 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(h\)</span> 分开，那么 <span class="math inline">\(U_x\)</span> 是所求的邻域。</p><p>第三步：<span class="math inline">\(H\)</span>是有限的。这是因为对每个 <span class="math inline">\(x\inH\)</span>，取其邻域 <span class="math inline">\(U_x\)</span> 使得 <span class="math inline">\(U_x\cap H=\{x\}\)</span>，这些开集加上 <span class="math inline">\(G\backslash H\)</span> 构成 <span class="math inline">\(G\)</span> 的一个开覆盖，由 <span class="math inline">\(G\)</span> 的紧性可得存在 <span class="math inline">\(G\)</span> 的有限子覆盖。于是有限多个 <span class="math inline">\(\{U_{x_i}\}_{i=1}^n\)</span> 覆盖了 <span class="math inline">\(H\)</span>。然而每个 <span class="math inline">\(U_{x_i}\)</span> 只包含一个 <span class="math inline">\(H\)</span> 中的元素 <span class="math inline">\(x_i\)</span>，所以 <span class="math inline">\(H\)</span> 是有限的。<span class="math inline">\(\blacksquare\)</span></p><p>现在 <span class="math inline">\(W\)</span> 保持 Euclidean 内积 <span class="math inline">\(B\)</span> 不变，从而是正交群 <span class="math inline">\(O(n,\mathbb{R})\)</span> 的子群。而 <span class="math inline">\(O(n,\mathbb{R})\)</span> 是紧群，<span class="math inline">\(W\)</span> 是离散子群，所以 <span class="math inline">\(W\)</span> 是有限群。</p><h1 id="and-6.4-radical-of-the-bilinear-form-finite-coxeter-groups">6.3and 6.4 Radical of the bilinear form / Finite Coxeter groups</h1><p>这两节合起来证明了 6.2 的逆命题：如果 <span class="math inline">\(W\)</span> 是有限群，则 <span class="math inline">\(B\)</span>必然是正定的。这个结论是如下几个命题合起来得到的：</p><div id="-------1" class="unnumbered statement sta____1 plain"><p><span class="statement-heading"><span class="statement-label">命题1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(V\)</span> 的一个真 <span class="math inline">\(W-\)</span> 子模，则 <span class="math inline">\(U\subset V^\bot\)</span>。</p></div><p>这个命题背后的关键是任何单根 <span class="math inline">\(\alpha_s\)</span> 必须属于 <span class="math inline">\(U\)</span> 或者 <span class="math inline">\(U^\bot\)</span> 之一。由于 <span class="math inline">\(W\)</span> 是不可约 Coxeter 群，<span class="math inline">\(\Delta\)</span>不能分成两个互相正交的子集，所以要么 <span class="math inline">\(\Delta\in U\)</span>，这与 <span class="math inline">\(U\)</span> 是真子模矛盾；要么 <span class="math inline">\(\Delta\in U^\bot\)</span>，从而 <span class="math inline">\(U\subset V^\bot\)</span>。</p><div id="-------2" class="unnumbered statement sta____2 plain"><p><span class="statement-heading"><span class="statement-label">命题2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 在 <span class="math inline">\(V\)</span> 上的作用是完全可约的。</p></div><p>这是群表示论里面的 Maschke 定理。证明技巧就是取平均构造 <span class="math inline">\(W-\)</span> 不变的正定内积。</p><div id="-------3" class="unnumbered statement sta____3 plain"><p><span class="statement-heading"><span class="statement-label">命题3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B\)</span> 是非退化的。</p></div><p>若不然 <span class="math inline">\(V^\bot\ne(0)\)</span>，完全可约性说明 <span class="math inline">\(V^\bot\)</span> 有直和补 <span class="math inline">\(U\)</span>，但是 <span class="math inline">\(U\)</span> 也在 <span class="math inline">\(V^\bot\)</span> 中，矛盾。</p><div id="-------4" class="unnumbered statement sta____4 plain"><p><span class="statement-heading"><span class="statement-label">命题4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 在 <span class="math inline">\(V\)</span> 上是不可约的。</p></div><p>这是命题 3 的直接结论，因为有非平凡的真子模意味着 <span class="math inline">\(V^\bot\)</span> 也非平凡，与 <span class="math inline">\(B\)</span> 非退化矛盾。</p><div id="-------5" class="unnumbered statement sta____5 plain"><p><span class="statement-heading"><span class="statement-label">命题5</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B\)</span> 是正定的。</p></div><p>实际上 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(W\)</span> 的不可约表示说明 <span class="math inline">\(V\)</span> 上的 <span class="math inline">\(W-\)</span>不变双线性函数构成的向量空间是一维的。而我们已经有一个 <span class="math inline">\(W-\)</span> 不变的正定内积，所以 <span class="math inline">\(B\)</span>必然是它的一个倍数，从而也是正定的。</p><h1 id="affine-coxeter-groups">6.5 Affine Coxeter groups</h1><p>之前第 4 章介绍的仿射 Coxeter群是通过关于超平面的反射构造的，这种反射未必是线性的；而 Coxeter群的几何实现中，<span class="math inline">\(W\)</span>是由线性反射生成的。这一节将这两种方式统一起来。</p><p>设 <span class="math inline">\((W,S)\)</span> 是不可约 Coxeter群，<span class="math inline">\(|S|=n+1\)</span>。根据第 5章几何实现的讨论，我们知道 <span class="math inline">\((W,S)\)</span>可以实现为 <span class="math inline">\(n+1\)</span> 维实向量空间 <span class="math inline">\(V\)</span> 上的反射群。设 <span class="math inline">\(V\)</span> 的一组基为 <span class="math inline">\(\Delta=\{\alpha_i\}\)</span>，每个 <span class="math inline">\(s_i\in S\)</span> 对应于 <span class="math inline">\(V\)</span> 上的反射 <span class="math inline">\(s_{\alpha_i}\)</span>。</p><p>此外设 <span class="math inline">\(V^\ast\)</span> 是 <span class="math inline">\(V\)</span> 的对偶空间，<span class="math inline">\(\langle \cdot,\cdot \rangle\)</span> 是 <span class="math inline">\(V\times V^\ast\to\mathbb{R}\)</span>的自然配对。</p><p>我们来分析当 Cartan 矩阵是半正定，但不是正定时 <span class="math inline">\((W,S)\)</span> 的结构。</p><p>根据 2.6 小节的结论，<span class="math inline">\(\mathrm{rad}{(V)}=\mathbb{R}\delta\)</span>可以由一个向量 <span class="math inline">\(\delta\)</span> 生成，并且<span class="math inline">\(W\)</span> 保持子空间 <span class="math inline">\(\mathbb{R}\delta\)</span> 不变。在 <span class="math inline">\(V/\mathbb{R}\delta\)</span>上诱导的内积是正定的。</p><p>我们知道，<span class="math inline">\(W\)</span> 也作用在 <span class="math inline">\(V^\ast\)</span> 上，这个作用的定义是规定 <span class="math inline">\(W\)</span> 保持双线性对 <span class="math inline">\(\langle \cdot,\cdot \rangle\)</span> 不变： <span class="math display">\[\langle wv,wx \rangle = \langle v, x\rangle.\quad w\in W,v\in V, x\in V^\ast.\]</span> 记 <span class="math display">\[\begin{aligned}H_0&amp;=\{x\in V^\ast\mid \langle\delta,x\rangle=0\},\\H_1&amp;=\{x\in V^\ast\mid \langle\delta,x\rangle=1\}.\end{aligned}\]</span> 则 <span class="math inline">\(H_0\)</span>是线性子空间，<span class="math inline">\(H_1\)</span>是仿射超平面。<span class="math inline">\(W\)</span> 保持 <span class="math inline">\(H_0,H_1\)</span> 不变：因为对任何 <span class="math inline">\(x\in V^\ast\)</span> 都有 <span class="math display">\[\langle\delta,wx\rangle=\langlew^{-1}\delta,x\rangle=\langle\delta,x\rangle.\]</span></p><p>注意到 <span class="math inline">\(H_0\)</span> 与 <span class="math inline">\(V/\mathbb{R}\delta\)</span> 是对偶的，所以它是一个Euclidean空间（通过指定一组对偶基，你可以把一个空间上的度量挪到它的对偶空间上）；<span class="math inline">\(H_1\)</span> 作为 <span class="math inline">\(H_0\)</span> 平移得到的超平面也具有 Euclidean度量。<span class="math inline">\(W\)</span> 同样保持 <span class="math inline">\(H_0\)</span> 和 <span class="math inline">\(H_1\)</span> 上的度量不变。</p><p>所以我们只要在 <span class="math inline">\(V^\ast\)</span>中考虑问题即可。现在的问题变成，已知 <span class="math inline">\(W\leqslant {\rm GL}(V^\ast)\)</span> 保持 <span class="math inline">\(H_0,H_1\)</span> 不变，分析 <span class="math inline">\(W\)</span> 在 <span class="math inline">\(H_1\)</span> 上的作用。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(f: H_1\to H_1\)</span>是映射，如果存在 <span class="math inline">\(T\in {\rmGL}(V^\ast)\)</span> 满足 <span class="math inline">\(f(x + y) - f(x) =T(y)\)</span> 对任何 <span class="math inline">\(x\in H_1,y\inH_0\)</span> 成立，就称 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(H_1\)</span> 上的仿射变换。记 <span class="math inline">\({\bf Aff}(H_1)\)</span> 是 <span class="math inline">\(H_1\)</span> 上所有仿射变换构成的集合，不难验证<span class="math inline">\({\bf Aff}(H_1)\)</span>在映射的复合下构成一个群。</p></div><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span><span class="math inline">\(W\)</span> 在 <span class="math inline">\(H_1\)</span> 上的作用诱导了群同态 <span class="math inline">\(W\to {\bf Aff}(H_1)\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(w\)</span> 在<span class="math inline">\(V^\ast\)</span> 上的作用是线性的，<span class="math inline">\(w(x+y)-w(x)=w(y)\)</span>，所以结论是显然的。<span class="math inline">\(\blacksquare\)</span></p><h1 id="hecke-algebras-and-inverses">7.4 Hecke algebras andinverses</h1><p>这一节引入了 <span class="math inline">\(R\)</span>多项式，并给出了它们满足的递推关系。这部分用对合来处理会比较方便。</p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>对任何 <span class="math inline">\(w\in W\)</span>， <span class="math display">\[q^{l(w)}\,\overline{T_w}=\sum_{x\leqw}(-1)^{l(x)+l(w)}R_{x,w}(q)T_x.\]</span> 其中 <span class="math inline">\(R_{x,w}(q)\in\mathbb{Z}[q]\)</span> 是关于 <span class="math inline">\(q\)</span> 的多项式，满足 <span class="math inline">\(R_{w,w}(q)=1\)</span>。</p></div><p><strong>证明</strong>：由 <span class="math inline">\(q^{l(e)}\,\overline{T_e}=q^0\,\overline{T_e}=T_e\)</span>，结论对<span class="math inline">\(w=e\)</span> 成立。当 <span class="math inline">\(l(w)&gt;0\)</span> 时，设 <span class="math inline">\(w=s_1\cdots s_r\)</span> 是一个既约表示，则 <span class="math display">\[\begin{align}q^{l(w)}\,\overline{T_w}&amp;=q^r\,\overline{T_{s_1\cdots s_r}}\\&amp;=q^r\,\overline{T_{s_1}}\cdots\overline{T_{s_r}}\\&amp;=(qT_{s_1}^{-1})\cdots (qT_{s_r}^{-1})\\&amp;=(T_{s_1}+1-q)\cdots (T_{s_r}+1-q)\\&amp;=\sum_{k=1}^r\sum_{1\leq i_1\leq\cdots\leq i_k\leqr}(1-q)^{r-k}T_{s_{i_1}}\cdots T_{s_{i_k}} + (1-q)^r.\end{align}\]</span> 注意到每个 <span class="math inline">\(T_{s_{i_1}}\cdots T_{s_{i_k}}=T_{s_1\cdotss_k}=T_x\)</span>，<span class="math inline">\(x\)</span> 是 <span class="math inline">\(w\)</span> 的子表达式，所以 <span class="math inline">\(x\leq w\)</span>。合并相同的 <span class="math inline">\(x\)</span> 的系数以后，显然 <span class="math inline">\(T_x\)</span> 的系数在 <span class="math inline">\(\mathbb{Z}[q]\)</span> 中，所以存在 <span class="math inline">\(R_{x,w}\in\mathbb{Z}[q]\)</span> 满足 <span class="math display">\[\sum_{k=1}^r\sum_{1\leq i_1\leq\cdots\leq i_k\leqr}(1-q)^{r-k}T_{s_{i_1}}\cdots T_{s_{i_k}} +(1-q)^r=\sum_{x\leqw}(-1)^{l(x)+l(w)}R_{x,w}(q)T_x.\]</span> 由于 <span class="math inline">\(s_{i_1}\cdots s_{i_k}=w\)</span>只有一种可能，就是 <span class="math inline">\(k=r\)</span> 并且 <span class="math inline">\((i_1,\ldots,i_r)=(1,\ldots,r)\)</span>，所以 <span class="math inline">\(R_{w,w}(q)=1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(s\in S\)</span>，<span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(sw&lt;w\)</span>，则 <span class="math display">\[R_{x,w}(q) = \begin{cases}R_{sx,sw}(q) &amp; \text{if } sx&lt;x,\\qR_{sx,sw}(q)+(q-1)R_{x,sw}(q) &amp; \text{if } x&lt;sx.\end{cases}\]</span></p></div><p><strong>证明</strong>： <span class="math display">\[\begin{aligned}&amp;\qquad\sum_{w\in W}(-1)^{l(x)+l(w)}R_{x,w}(q)T_x =q^{l(w)}\,\overline{T_w}=q^{l(s)+l(sw)}\overline{T_s}\,\overline{T_{sw}}=q\,\overline{T_s}\,q^{l(sw)}\,\overline{T_{sw}}\\&amp;=(T_s +1-q)\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x\\&amp;=\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)(T_sT_x+(1-q)T_x)\\&amp;=(1-q)\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x + \sum_{w\inW}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_sT_x\\&amp;=(1-q)\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x +\sum_{w\inW,\,x&lt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_{sx}\\&amp;\quad +\sum_{w\inW,\,x&gt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)(qT_{sx}+(q-1)T_x)\\&amp;=(1-q)\sum_{w\inW,\,x&lt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x+\sum_{w\inW,\,x&lt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_{sx}\\&amp;\quad+\,q\sum_{w\in W,\,x&gt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_{sx}\\&amp;\overset{y=sx}=(q-1)\sum_{w\inW,\,x&lt;sx}(-1)^{l(w)+l(x)}R_{x,sw}(q)T_x+\sum_{w\in W,\,sy&lt;y}(-1)^{l(sw)+l(sy)}R_{sy,sw}(q)T_y\\&amp;\quad +q\sum_{w\inW,\,sy&gt;y}(-1)^{l(sw)+l(sy)}R_{sy,sw}(q)T_y\\&amp;\overset{y=x}=\sum_{w\inW,\,sx&lt;x}(-1)^{l(w)+l(x)}R_{sx,sw}(q)T_x+\sum_{w\inW,\,sx&gt;x}(-1)^{l(w)+l(x)}\left(qR_{sx,sw}+(q-1)R_{x,sw}\right)T_x.\end{aligned}\]</span> 比较两边 <span class="math inline">\(T_x\)</span>的系数即可得到结论。</p><h1 id="further-properties-of-r-polynomials">7.8 Further properties of<span class="math inline">\(R\)</span>-polynomials</h1><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span><span class="math inline">\(R\)</span>-多项式满足如下性质：</p><ol type="1"><li><span class="math inline">\((-q)^{l(w)-l(x)}\overline{R_{x,w}(q)}=R_{x,w}\)</span>。</li><li><span class="math inline">\(\sum_{x\leq y\leqw}(-1)^{l(x)+l(y)}R_{x,y}(q) R_{y,w}(q)=\delta_{x,w}\)</span>。</li></ol></div><p>1 的证明：对 <span class="math inline">\(w\)</span> 的长度归纳。如果<span class="math inline">\(l(w)=0\)</span> 则 <span class="math inline">\(w=x=e\)</span>，<span class="math inline">\(R_{e,e}=1\)</span>，结论成立。</p><p>设结论对所有长度 <span class="math inline">\(&lt;l(w)\)</span>的元素成立，取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(l(sw)&lt;l(w)\)</span>。考虑两种情况：</p><ul><li><span class="math inline">\(sx &lt; x\)</span>。这时 <span class="math inline">\(R_{x,w}=R_{sx,sw}\)</span>，对 <span class="math inline">\(sw\)</span> 应用归纳假设 <span class="math display">\[(-q)^{l(sw)-l(sx)}\overline{R_{sx,sw}}=R_{sx,sw}=R_{x,w}.\]</span>由于 <span class="math inline">\(l(sw)-l(sx)=l(w)-l(x)\)</span>所以结论对 <span class="math inline">\(w\)</span> 也成立。</li><li><span class="math inline">\(sx&gt;x\)</span>。 <span class="math display">\[\begin{align}(-q)^{l(w) - l(x)} R_{x,w}(q) &amp;= (-1)^{l(w) + l(x)} q^{l(w) - l(x)}R_{x,w}(q^{-1}) \\&amp;= (-1)^{l(w) + l(x)} q^{l(w) - l(x)} \left( q^{-1}R_{sx,sw}(q^{-1}) + (q^{-1} - 1) R_{x,sw}(q^{-1}) \right) \\&amp;= (-1)^{l(w) + l(x)} q^{l(sw) - l(sx)} q^2\left( q^{-1}R_{sx,sw}(q^{-1}) + (q^{-1} - 1) R_{x,sw}(q^{-1}) \right) \\&amp;= q (-1)^{l(sw) + l(sx)} q^{l(sw) - l(sx)} R_{sx,sw}(q^{-1}) \\&amp;\quad - (-1)^{l(sw) + l(x)} q^{l(sw) - l(x)} (1 - q)R_{x,sw}(q^{-1}) \\&amp;= q (-q)^{l(sw) - l(sx)} R_{sx,sw}(q) + (q - 1)(-q)^{l(sw) - l(x)}R_{x,sw}(q) \\&amp;= q R_{sx,sw}(q) + (q - 1) R_{x,sw}(q) \\&amp;= R_{x,w}(q).\end{align}\]</span></li></ul><p>2 的证明：根据 <span class="math inline">\(R\)</span>-多项式的定义，<span class="math display">\[\overline{T_w}=q^{-l(w)}\sum_{y\inW}(-1)^{l(y)+l(w)}R_{y,w}T_y.\]</span> 两边取对合得到 <span class="math display">\[\begin{aligned}T_w&amp;=\overline{q^{-l(w)}\sum_{y\in W}(-1)^{l(y)+l(w)}R_{y,w}T_y}\\&amp;=q^{l(w)}\sum_{y\inW}(-1)^{l(y)+l(w)}\overline{R_{y,w}}\,\overline{T_y}\\&amp;=q^{l(w)}\sum_{y\in W}(-1)^{l(y)+l(w)}q^{l(y)-l(w)}R_{y,w}\cdotq^{-l(y)}\sum_{x\in W}(-1)^{l(x)+l(y)}R_{x,y}T_y\\&amp;=\sum_{x\in W}\left(\sum_{x\leq y\leqw}(-1)^{l(y)+l(x)}R_{x,y}R_{y,w}\right)T_x\end{aligned}\]</span> 比较两边关于 <span class="math inline">\(T_w\)</span> 项的系数即可。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Make awesome gif animation in a few seconds with pure Python!</title>
      <link href="/gifmaze/index.html"/>
      <url>/gifmaze/index.html</url>
      
        <content type="html"><![CDATA[<p>This program can help you make gif animations of various algorithmsrunning on the 2d square grid.</p><blockquote><p><strong>Requirements</strong>: <code>tqdm</code> for showing processbar and <code>pillow</code> for reading images.</p></blockquote><h1 id="examples">Examples</h1><ul><li><p>Wilson’s uniform spanning tree algorithm (my favourite, 2349frames, 333KB, generated in 3 seconds):</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/wilson-bfs.gif"></p></li><li><p>Prim’s algorithm:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/prim.gif"></p></li><li><p>Kruskal’s algorithm:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/kruskal.gif"></p></li><li><p>Langton’s ant:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/langton-ant.gif"></p></li><li><p>Hilbert curve：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/hilbert.gif"></p></li><li><p>Conway’s game of life (gosper glider gun):</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/gosperglidergun.gif"></p></li></ul><h1 id="whats-special-about-this-program">What’s special about thisprogram</h1><p>The code is implemented in pure Python, no third-party modules norsoftwares are required, just built-in modules like <code>struct</code>,<code>random</code>, <code>colorsys</code> and some built-in functions,and without any “color” or “draw” function calls. In later versions Iadded some features like showing process bars (requires<code>tqdm</code>) and enabling the user to embed the animtion into abackground image (requires <code>pillow</code>). The program runs muchfaster than expected, it can generate highly optimized gif output inonly a few seconds. One drawback is that it’s not quite user-friendly:the user must have some basic knowledge of the GIF89a specification toknow how to set parameters correctly in the animation.</p><h1 id="how-did-this-program-come-out">How did this program comeout</h1><p>This program is motivated by Mike Bostock’s wonderful <a href="https://bl.ocks.org/mbostock/11357811">Javascript animation</a>. Afew years ago when I saw Mike’s page I immediately had the idea ofwriting a Python version to produce gif animations of Wilson’salgorithm. A first thought on this was to save the animation into framesand then pack them back into a whole gif. But the animation usuallycontains thousands of frames so this is definitely a horrible task andis far from being efficient. Luckily five years later I learnt theGIF89a specification by chance and suddenly realized the new approach ofencoding the animation into a byte stream. So basically I implemented asmall gif encoder first, then run the algorithm on a 2d grid (use a 2darray to represent it) and encode it into frames along the way.</p><h1 id="what-is-wilsons-algorithm">What is Wilson’s algorithm</h1><p>Consider the following problem:</p><blockquote><p><strong>Problem</strong>: Let <span class="math inline">\(G\)</span>be a finite, connected and undirected graph. How can one choose a randomspanning tree among all spanning trees of <span class="math inline">\(G\)</span> from uniform probability? (we shallcall such a tree an uniform spanning tree, or simply an<strong>UST</strong>.)</p></blockquote><p>The following image shows an UST of a 48x36 grid, the circled dot isthe root vertex:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/ust.png"></p><p>You might say “that’s easy, just write a program that lists allspanning trees and then use a random integer to choose one”. But let’sconsider the complete graph <span class="math inline">\(K_n\)</span> forexample: <span class="math inline">\(K_n\)</span> has <span class="math inline">\(n^{n/2}\)</span> many different spanning trees by<a href="https://en.wikipedia.org/wiki/Cayley%27s_formula">Cayley’sformula</a>, for <span class="math inline">\(n=100\)</span> this numberis <span class="math inline">\(100^{98}\)</span>, far more larger thanthe number of particles in the universe! (which is estimated about <span class="math inline">\(10^{90}\)</span>)</p><p>Currently the most efficient algorithm known is the one proposed inWilson’s paper</p><blockquote><p>“generating random spanning trees more quickly than the covertime”.</p></blockquote><p>It’s a random algorithm, that is, some times you may be very lucky toget an UST soon, or you may wait forever. But one can prove that thisalgorithm will terminate in finite steps with probability one (note thisdoes not exclude the possibility of running forever, think about this),and it performs really well in most cases.</p><p>The key to understand Wilson’s algorithm is the so called <a href="https://en.wikipedia.org/wiki/Loop-erased_random_walk">loop erasedrandom walk</a>, that is, once the random walk visits a vertex thatalready existed in its path, it immediately erases the loop betweenthese two visits and continues the walk from this vertex. Just watch theJavascript animation if you don’t understand this, it’s obvious to seewhat “loop erased random walk” means from it. (click on the canvas torestart the animation)</p><script type="text/javascript" src="/images/code/wilson.js"></script><div data-align="center"><canvas id="wilson" width="600" height="600"></canvas></div><p>The algorithm runs as follows:</p><blockquote><p><strong>Wilson’s algorithm</strong>:</p><ol type="1"><li>Choose any vertex <span class="math inline">\(v\)</span> as the rootand maintain a tree <span class="math inline">\(T\)</span>, initially<span class="math inline">\(T=\{v\}\)</span>.</li><li>For any vertex <span class="math inline">\(z\)</span> that is not in<span class="math inline">\(T\)</span>, start a loop erased random walkfrom <span class="math inline">\(z\)</span> until the walk hits <span class="math inline">\(T\)</span>, then add the resulting path of thewalk to <span class="math inline">\(T\)</span>.</li><li>Repeat step 2 until all vertices of the graph are in <span class="math inline">\(T\)</span>.</li></ol></blockquote><p>The proof of the correctness of this algorithm is a bit tricky andwill not be discussed here, you may refer to Wilson’s original paper orthe book by Russell Lyons and Yuval Peres:</p><blockquote><p>“Probability on Trees and Networks”.</p></blockquote><h1 id="implementation">Implementation</h1><p>As mentioned before, the animation of Wilson’s algorithm (and alsoLangton’s ant animation) usually contains thousands of frames in it, soit’s quite surprising that this program takes only a few seconds toproduce a highly optimized image. The key points are:</p><ul><li><p>Only encode a minimum region at a time. We can maintain arectangular region to store which cells are changed between successiveframes, this enables us to encode only a small portion of the windowinstead of the whole into a frame.</p></li><li><p>Use variable mimimum code length for the LZW compression. Whenencoding a frame into bytearrays LZW compression allows the minimum codelength <span class="math inline">\(k\)</span> can be as small as thecolor depth of this frame (and must satisfy <span class="math inline">\(2\leq k\leq12\)</span>), this is another benifitsince most frames only contain very few colors.</p></li><li><p>Write the frames to a temporary <code>BytesIO</code> file inmemory and flush it to disk in the end.</p></li></ul><p>The code is divided into three layers: at the top layer is the<code>Maze</code> class on which we run various algoirthms. This layerknows nothing about the gif image. At the bottom layer is the<code>GIFSurface</code> class which holds the raw information like imagesize, global color table, number of loops, background color index, etc.It knows nothing about the <code>Maze</code>. At the middle layer is the<code>Animation</code> class which controls how the <code>Maze</code> isencoded and writes to the <code>GIFSurface</code>.</p><h1 id="a-short-introduction-to-the-gif89a-specification">A shortintroduction to the GIF89a specification</h1><p>In this section I’ll give a not-so-detailed introduction to theGIF89a specification. It’s not meant to be comprehensive norself-contained, you should always refer to <a href="http://giflib.sourceforge.net/whatsinagif/index.html">What’s in aGIF</a> when you have difficulties understanding my words here.</p><p>Roughly a GIF image consists of:</p><blockquote><p><strong>Structure of a GIF File</strong></p><ol type="1"><li>Always begins with 6 bytes <code>GIF89a</code>.</li><li>Then follows the <strong>logical screen descriptor</strong> whichspecifies the width and height of the image and the size of the<strong>global color table</strong>.</li><li>Then follows the global color table.</li><li>Then follows the <strong>loop control block</strong> which specifiesthe number of loops of the image.</li><li>Then comes the actual data of the frames. The data of each frame canbe further divided into 3 parts:<ol type="1"><li>the <strong>graphics control block</strong> which specifies thedelay and transparent color of this frame.</li><li>the <strong>image descriptor</strong> which specifies the relativeposition of this frame in the window and the size of the local colortable.</li><li>the local color table of this frame (if there is a local color tablefor this frame).</li><li>the LZW compressed pixel data of this frame.</li></ol></li><li>Finally the image file ends with a byte <code>0x3B</code>.</li></ol></blockquote><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>The above description does not apply to all GIF images, there canbe some variations. For example:</p><ol type="1"><li><p>The image may not contain a global color table (so you have tospecify a local color table for each frame).</p></li><li><p>For a static image the loop control block is not required; for astacit frame the graphcs control block is not required.</p></li><li><p>The file may end without the byte <code>0x3B</code>, mostdecoders can still decode the image correctly.</p></li></ol></div><p>Now we explain each part in more details.</p><h2 id="the-header-gif89a">The header GIF89a</h2><p>In python you can write it as</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">'6s'</span>, <span class="hljs-string">b'GIF89a'</span>)<br></code></pre></td></tr></tbody></table></figure><p>Why <code>b'GIF89a'</code> not simply <code>'GIF89a'</code>? This isfor compatibility with Python2 and 3 since the default encoding inPython3 is unicode whereas in python2 it’s ascii.</p><h2 id="the-logical-screen-descriptor">The logical screendescriptor</h2><p>Example:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">'&lt;2H3B'</span>, width, height, <span class="hljs-number">0b10010001</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><p>Here you shoud note the format string <code>&lt;</code> (littleendian).</p><p>The byte <code>0b10010001</code> is called a packed field. Let’s readit from left to right:</p><ol type="1"><li>The first bit 1 means we have a global color table (0 forabsent).</li><li>The next 3 bits specify the “color depth”. You don’t need care aboutwhat they mean since modern decoders like firefox and chrome do not usethem.</li><li>The fifth bit is the “sort flag” and is not used today, always setto 0.</li><li>The ending 3 bits represent an integer <span class="math inline">\(x\)</span> in range 0-7, <span class="math inline">\(x\)</span> specifies the size of the global colortable (<span class="math inline">\(=2^{x+1})\)</span>.</li></ol><p>The last two bytes are of little importance and we don’t discuss themhere.</p><h2 id="global-color-table">Global color table</h2><p><strong>Example</strong>: if we want to use 4 colors red, green,blue, yellow, then the global color table can be written as</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">bytearray</span>([<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>])<br></code></pre></td></tr></tbody></table></figure><p>It’s important that the number of colors in this array must be apower of 2 and match the size of the global color table specified in thepacked byte in the logical screen descriptor, otherwise the decoder willnot be able to parse the image correctly.</p><h2 id="graphics-control-block">Graphics control block</h2><p><strong>Example</strong>:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">"&lt;4BH2B"</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0xF9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0b00000101</span>, delay, trans_index, <span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><p>The 3 beginning bytes <code>0x21, 0xF9, 4</code> are fixed and areused to inform the decoder “Hey, I’m a graphics control block, see thenext 4 bytes!”</p><p>The next byte <code>0b00000101</code> is also a packed field, let’sread it from left to right:</p><ol type="1"><li>The first 3 bits are useless and are always 0.</li><li>The next 3 bits are called “desposal method”, they represent aninteger <span class="math inline">\(x\)</span> in range 0-7 and <span class="math inline">\(x\)</span> specifies how we should dispose thisframe after it’s displayed.<ol type="1"><li><p><span class="math inline">\(x=0\)</span> means it’s undefined,decoders will use default 1 instead in this case.</p></li><li><p><span class="math inline">\(x=1\)</span> is the default, it meansleave this frame here. So if the next frame is not overlapped with thisframe then both these two frames will be displayed. Otherwise theoverlapped area in this frame will be covered by the next one. See theexample below:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/disposal1.gif"></p></li><li><p><span class="math inline">\(x=2\)</span> means remove this frameand restore the image to background image/color, see the followingexample:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/disposal2.gif"></p><p>You can see each frame is remove immediately after it’s displayed,and its region is filled with transparent background (so you are reallyseeing the browser’s background color through the image).</p></li><li><p><span class="math inline">\(x=3\)</span> also means remove thisframe, but restore the image to the previous frame.<img style="margin:0px auto;display:block" src="/images/gifmaze/disposal3.gif"></p></li><li><p>4-7 are unused.</p></li></ol></li></ol><p>The next 2 bytes <code>delay</code> specifies the delay of the framein centiseconds, so <code>delay=3</code> means “keep staying here for0.03 second”.</p><p>The last byte <code>trans_index</code> specifies the transparentcolor in this frame, the pixels in this frame using this color aretransparent: you can see the previous frame through them (of course onlywhen the previous frame is still there (reserved), otherwise you areseeing the previous previous frame, …, etc).</p><h2 id="image-descriptor-block">Image descriptor block</h2><p>Example:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">'&lt;B4HB'</span>, <span class="hljs-number">0x2C</span>, left, top, width, height, <span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><p>Quite straight-forward to understand. Note the last byte is 0 sincewe do not need local color tables here.</p><h2 id="the-lzw-compression-algorithm">The LZW compressionalgorithm</h2><p>Finally we are left with the most difficult part: the LZW algorithm.It’s too long to include an introduction to the algorithm here, soplease refer to <a href="http://www.matthewflickinger.com/lab/whatsinagif/lzw_image_data.asp">thesecond article in What’s in a gif</a> for a complete treatment. But it’squite simple to implement it in Python, see the file <a href="https://github.com/neozhaoliang/pywonderland/blob/master/src/gifmaze/gifmaze/encoder.py">encoder.py</a>for an example.</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>The glowing gasket</title>
      <link href="/indra/the-glowing-gasket.html"/>
      <url>/indra/the-glowing-gasket.html</url>
      
        <content type="html"><![CDATA[<div class="statement simple plain unnumbered"><p>Four circles to the kissing come.<br>The smafter are the benter.<br>The bend is just the inverse of The distance from the centre.<br>Though sheir intrigue left Euclid dumb There’s now no need for nule ofthumb.<br>Since zero bend’s a dead straight line And concave bends have minussign.<br>The sum of the squares of alt four bends Is half the square of theirsum.</p><p>The Kiss Precise, Sir Frederick Soddy <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>四圆相吻巧相连，大小虽异自周全。<br>曲率正是心距倒，欧几里得愁煞然。<br>拇指法则今无用，零曲率者乃直线。<br>若为凹者曲率负，四曲率平方来加。<br>其和平方恰一半。</p><p>精确之吻，弗雷德里克·索迪爵士</p></div><figure id="fig-7.1"><img src="/images/indra/fig-7.1.jpg" class="fig" width="600" alt="Figure 7.1. The Apollonian gasket. The lacy web in the two pictures is the same: on the left, it is drawn in the complex plane and, on the right, on the sphere. As you might imagine, many people have tried calculating the Hausdorff dimension of the gasket. Curt McMullen has found the most accurate value, which is estimated as about 1.305688. 图 7.1. 阿波罗尼奥斯垫片。两幅图中的蕾丝网状结构是相同的：左边是在复平面上绘制的，右边是在球面上绘制的。你可能已经猜到，许多人都曾尝试计算该垫片的豪斯多夫维数。柯特·麦克马伦（Curt McMullen）给出了目前最精确的估计值，约为 1.305688。"><figcaption aria-hidden="true">Figure 7.1. The Apollonian gasket. Thelacy web in the two pictures is the same: on the left, it is drawn inthe complex plane and, on the right, on the sphere. As you mightimagine, many people have tried calculating the Hausdorff dimension ofthe gasket. Curt McMullen has found the most accurate value, which isestimated as about 1.305688.<br>图 7.1.阿波罗尼奥斯垫片。两幅图中的蕾丝网状结构是相同的：左边是在复平面上绘制的，右边是在球面上绘制的。你可能已经猜到，许多人都曾尝试计算该垫片的豪斯多夫维数。柯特·麦克马伦（CurtMcMullen）给出了目前最精确的估计值，约为 1.305688。</figcaption></figure><div class="statement simple plain unnumbered"><p>The lacy web in Figure 7.1 is called the Apollonian gasket. Usually,it is constructed by a simple geometric procedure, dating back to thosemost famous of geometers, the ancient Greeks. We shall start byexplaining the traditional construction, but as we shall discloseshortly, the gasket also represents another remarkable way in which theSchottky dust can congeal. The pictures you see here were actually alldrawn using a refinement <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> of the DFS algorithm for tangentSchottky circles.</p></div><p><a href="#fig-7.1">图 7.1</a>中蕾丝状的图案被称为阿波罗尼奥斯垫片。其构造基于一种简单的几何方法，这种方法可以追溯到最著名的几何学家——古希腊人。我们将首先解释这种传统的构造方式，但很快你会看到，这种圆垫其实还展现了另一个非同寻常的形式，即所谓的Schottky尘埃如何聚集成形。你所看到的这些图像，实际上都是使用一种针对相切Schottky 圆的 DFS 算法改进版本 <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> 绘制出来的。</p><div class="statement simple plain unnumbered"><p>The starting point of the traditional construction is a chain ofthree non-overlapping disks, each tangent to both of the others. Aregion between three tangent disks is a ‘triangle’ with circular arcsfor sides. This shape is often called an ideal triangle: the sides aretangent at each of the three vertices so the angle between them is zerodegrees.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> The gasket is activated by the factthat in the middle of each ideal triangle there is always a unique‘inscribed disk’ or incircle, tangent to the three outer circles. It isreally better to think of the gasket as a construction on the sphere.Insides and outsides don’t matter any more, so we may as well start withany three mutually tangent circles. You can see lots of disks andincircles in Figure 7.2.</p></div><p>传统构造的起点是由三个互不重叠的圆盘组成的一条链，每个圆盘都与另外两个相切。三个相切圆盘之间的区域构成了一个“三角形”，其边界是由圆弧构成的。这种形状常被称为理想三角形：由于其三条边在三个顶点处相切，因此它们之间的夹角为零度。该垫片（gasket）的关键在于，每个理想三角形的中间总存在一个唯一的“内切圆”，即同时与三个外接圆相切的圆。事实上，更好的理解方式是将这个垫片看作是在球面上的一种构造。在球面上，内侧与外侧的区别已不复存在，因此我们可以从任意三个两两相切的圆开始。你可以在<a href="#fig-7.2">图 7.2</a> 中看到大量的圆盘和它们的内切圆。</p><figure id="fig-7.2"><img src="/images/indra/fig-7.2.jpg" class="fig" width="600" alt="Figure 7.2. Activating the gasket. On the top left, the three largest disks which activate the gasket are shown in blue. One of the three disks appears as the outer blue region which frames the picture, because it contains the point \infty, the North Pole on the Riemann sphere. On the top right, two of the disks are tangent at \infty, so that you see them in the picture as parallel blue strips. Removing the blue circles leaves two red ideal triangles. Inside each ideal triangle is an incircle, coloured yellow. Below, we see more levels of incircles. 图 7.2. 激活垫片。左上图中，标出的三个最大圆盘以蓝色呈现，正是它们激活了垫片。其中一个圆盘显示为环绕整幅图像的外部蓝色区域，这是因为它包含了点 \infty，即黎曼球面上的北极点。右上图中，其中两个圆盘在 \infty 处相切，因此在图中呈现为两条平行的蓝色带状区域。当我们移除这些蓝色圆盘后，图中便显现出两个红色的理想三角形。每个理想三角形内部都嵌有一个黄色内切圆。下方图示进一步展示了更深层次的内切圆结构。"><figcaption aria-hidden="true">Figure 7.2. Activating the gasket. On thetop left, the three largest disks which activate the gasket are shown inblue. One of the three disks appears as the outer blue region whichframes the picture, because it contains the point <span class="math inline">\(\infty\)</span>, the North Pole on the Riemannsphere. On the top right, two of the disks are tangent at <span class="math inline">\(\infty\)</span>, so that you see them in thepicture as parallel blue strips. Removing the blue circles leaves twored ideal triangles. Inside each ideal triangle is an incircle, colouredyellow. Below, we see more levels of incircles.<br>图 7.2.激活垫片。左上图中，标出的三个最大圆盘以蓝色呈现，正是它们激活了垫片。其中一个圆盘显示为环绕整幅图像的外部蓝色区域，这是因为它包含了点<span class="math inline">\(\infty\)</span>，即黎曼球面上的北极点。右上图中，其中两个圆盘在<span class="math inline">\(\infty\)</span>处相切，因此在图中呈现为两条平行的蓝色带状区域。当我们移除这些蓝色圆盘后，图中便显现出两个红色的理想三角形。每个理想三角形内部都嵌有一个黄色内切圆。下方图示进一步展示了更深层次的内切圆结构。</figcaption></figure><div class="statement simple plain unnumbered"><p>In the figure, we show two initial configurations of three tangentblue disks. When you take out the three blue disks you are left with twored ideal triangles. Each red ideal triangle has a yellow incircle. Seehow each yellow incircle divides the red triangle into three moretriangles. For repetitive people (a necessary quality in this subject,you might say), it is only natural to draw the incircles in these newtriangles, resulting, of course, in even more triangles of the samekind. The bottom frame shows this subdivision carried out twice more,with green and then even smaller purple disks. In The Cat in the HatComes Back,’ the cat takes off his hat to reveal Little Cat, who thenremoves his hat and releases Little Cat, who then uncovers Little Cat,and so on. Now imagine there are not one but three new cats inside eachcat’s hat. That gives a good impression of the explosive proliferationof these tiny ideal triangles. Carry out this process to infinity, andVoom, the Apollonian Gasket appears.</p></div><p>图中展示了三个相切蓝色圆盘的两种初始配置。当你移除这三个蓝色圆盘时，剩下的是两个红色理想三角形。每个红色理想三角形都有一个黄色的内切圆。观察每个黄色内切圆如何将红色三角形分割成三个更小的三角形。</p><p>对于那些乐此不疲的人（或许正是研究这一主题的必备素质），在新三角形中继续绘制内切圆简直是顺理成章的事。这当然会催生出更多相似的三角形。下方的子图展示了这种细分过程再执行两次的结果——先是绿色圆盘，接着是更小的紫色圆盘，密密层层地堆叠起来。这让我想起《戴帽子的猫又来了》中的情节——大猫摘下帽子，露出一只小猫；小猫摘下自己的帽子，又冒出一只更小的小猫；接着更小的小猫再摘帽……如此反复进行。现在，想象每顶帽子里不是藏着一只，而是三只小猫，那你就能体会这些微型理想三角形是如何爆炸式增长的了。让这一过程无限延续，砰——阿波罗尼奥斯分形就出现了。</p><div class="statement simple plain unnumbered"><p>The Apollonian gasket is indeed very pretty, but the reason forintroducing it here is that, remarkably, it is also the limit set of aSchottky group made by pairing tangent circles. Exactly the sameintricate mathematical object can created by completely different means!You can see better how this works in the beautiful glowing version inFigure 7.3. The solid red circles in this picture are the initialSchottky circles in a very special configuration which we will look atclosely in the next section. The glowing yellow limit set can berecognized as the same as the Apollonian gasket of Figure 7.1. Thepicture was made by pairing four tangent circles arranged in theconfiguration shown in Figure 7.4. The four circles are tangent not onlyin a chain; there are also extra tangencies between <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span>, and between <span class="math inline">\(C_b\)</span> and <span class="math inline">\(C_B\)</span>.</p></div><p>阿波罗尼奥斯分形确实非常美丽，但我们在此介绍它的原因是：令人惊讶的是，它也是由切圆配对生成的肖特基群的极限集。完全不同的方式也能创造出完全相同的复杂数学对象！您可以通过<a href="#fig-7.3">图 7.3</a>中的荧光渲染图更好地理解它是如何运作的。图中的实心红色圆环是以一种特殊配置排列的初始肖特基圆（具体分析请参见下一节），其荧黄色的极限集与<a href="#fig-7.1">图 7.1</a>中的阿波罗尼奥斯垫片完全一致。这幅图像是通过配对四个相切圆生成的，排列方式如<a href="#fig-7.4">图 7.4</a>所示：这些圆不仅形成了链式相切的关系，而且在 <span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span>、<span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 之间还存在额外的切点。</p><figure id="fig-7.3"><img src="/images/indra/fig-7.3.jpg" width="600" alt="Figure 7.3. (Overleaf.) The glowing gasket. This picture was created by applying the generating transformations a,A,b,B to the chain of four solid red disks bounding the black ideal triangles. At higher levels, the image circles tone from red to orange to yellow, through green to blue, finally cycling back to red. Don’t let the picture fool you - the red circles are not the circles which activate the gasket in the traditional construction. The ones which appear in the traditional construction are the ‘dual’ circles with the yellow glow. 图 7.3. 荧光垫片。此图像是通过对围绕黑色理想三角形的四个实心红色圆盘施加生成变换 a,A,b,B 而生成的。在更高的层级中，图像中的圆环色调从红色渐变为橙色、黄色，接着是绿色，再到蓝色，最终循环回红色。需要特别注意的是：图中的红色圆并非传统阿波罗尼奥斯构造中激活垫片的圆——在传统构造中，起激活作用的是发出黄色光辉的“对偶圆”。"><figcaption aria-hidden="true">Figure 7.3. (Overleaf.) The glowinggasket. This picture was created by applying the generatingtransformations <span class="math inline">\(a,A,b,B\)</span> to thechain of four solid red disks bounding the black ideal triangles. Athigher levels, the image circles tone from red to orange to yellow,through green to blue, finally cycling back to red. Don’t let thepicture fool you - the red circles are not the circles which activatethe gasket in the traditional construction. The ones which appear in thetraditional construction are the ‘dual’ circles with the yellowglow.<br>图 7.3.荧光垫片。此图像是通过对围绕黑色理想三角形的四个实心红色圆盘施加生成变换<span class="math inline">\(a,A,b,B\)</span>而生成的。在更高的层级中，图像中的圆环色调从红色渐变为橙色、黄色，接着是绿色，再到蓝色，最终循环回红色。需要特别注意的是：图中的红色圆并非传统阿波罗尼奥斯构造中激活垫片的圆——在传统构造中，起激活作用的是发出黄色光辉的“对偶圆”。</figcaption></figure><div class="statement simple plain unnumbered"><p>As you iterate the pairing transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, the extra tangency proliferates, withthe effect that inside each disk <span class="math inline">\(D\)</span>you see three further Schottky disks tangent to <span class="math inline">\(D\)</span> and each of the other two. In ourversion, the circles have been coloured depending on their level,starting with red at the first or lowest level, gradually changing toyellow, green and then blue. The small yellow and blue circles pile up,highlighting the limit set with a mysterious glow.</p></div><p>当你不断迭代配对变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>时，额外的切点会迅速增殖。结果是在每个圆盘 <span class="math inline">\(D\)</span>内部，都会涌现出三个新的肖特基子圆盘——它们不仅与 <span class="math inline">\(D\)</span>相切，而且两两之间也彼此相切。在我们的可视化方案中，圆盘根据迭代的层级依次着色——最底层从红色起步，逐步过渡到黄色、绿色、蓝色。随着黄色和蓝色的小圆盘层层堆叠，突出了极限集，并散发出一种神秘的光辉。</p><div class="statement simple plain unnumbered"><p>In this chapter, we shall be exploring various features of thegasket. Notwithstanding the extra tangency, it turns out that each limitpoint is still associated to exactly one or two infinite words in thegenerators <span class="math inline">\(a,b,A\)</span> and <span class="math inline">\(B\)</span>. You will be able to make your ownversion of the glowing gasket by running our DFS algorithm for the groupgenerated by the transformations <span class="math inline">\(a\)</span>and <span class="math inline">\(b\)</span>. The algorithm draws thiscomplicated lacework as a continuous curve, which is hard to imagineuntil you see it in progress on a computer screen. The curve snakes itsway through the gasket, apparently leaving one region for quite a whileuntil finally weaving its way back. Animation is the true reward ofsuccessfully implementing the program we have been learning tobuild.</p></div><p>在本章中，我们将深入探索垫片结构的各种特性。尽管存在额外的相切关系，但事实证明，每个极限点仍然对应于生成元<span class="math inline">\(a, b, A, B\)</span>所构成的一至两个无限字。通过运行我们为变换群 <span class="math inline">\(\langle a,b\rangle\)</span>特别设计的深度优先搜索（DFS）算法，你将能够制作出自己专属的发光垫片。该算法将这种复杂的蕾丝结构绘制成一条连续的曲线——这种奇妙的生成过程，唯有在计算机屏幕上亲眼目睹，方能真正感受到其变幻莫测之美。曲线如同灵蛇般在垫片中蜿蜒穿梭，仿佛要彻底离开某个区域，却又在某个时刻悄然折返。成功实现我们精心构建的程序后，最令人欣喜的收获正是这些跃然屏上的动态演绎。</p><div id="apollonius--circa-250-200-bc" class="statement sta_apollonius__circa_250_200_bc plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Apollonius, circa 250-200 BC</span>.</span><span class="statement-spah"> </span><br></p><p>Apollonius, known to his contemporaries as the Great Geometer, livedin Perga, now part of Turkey. One of the giants of Greek mathematics, hewas famed for his 8 volume treatise Conics which studied ellipses,hyperbolas and parabolas as sections of a cone by a plane at variousangles. His writings swiftly became standard texts in the ancient world.Many are now lost and we know them only through mention in othercommentaries, among them works on regular solids, irrational numbers,and approximations to <span class="math inline">\(\pi\)</span>. Ptolemycredits Apollonius with the theory of epicycles on which he based histheory of planetary motion.</p><p>One of Apollonius’ lost works is a book called Tangencies, reportedto provide methods of constructing circles tangent to various othercombinations of lines and circles, for example finding a circle tangentto two given lines and another circle. You can think of the problem offinding the incircle of an ideal triangle in this way. The mostdifficult problem, that of constructing the two circles tangent to threeother given disjoint circles, was probably not solved in ancient times,however Sir Isaac Newton wrote down a proof. According to Pappus,Tangencies gave a formula for the radius of the incircle to an idealtriangle in terms of the radii of the circles which bound its threesides. Be that as it may, exactly such a formula was described byDescartes in 1643, and a version was known in eighteenth century Japan.In fact this formula seems to have been rediscovered many times, mostrecently by Sir Frederick Soddy, in whose honour the incircles aresometimes known as Soddy circles. Awarded the Nobel prize in 1921, forthe discovery of isotopes, Soddy had a natural interest in how to packspherical atoms of differing size.</p><p>Soddy was so taken with the formula that he published it in theunusual form of a poem, which appeared in the journal Nature in 1936.The central part is contained in the middle verse quoted at the head ofthis chapter. For those who feel more comfortable with symbols, supposethe radii of the chain of three circles are <span class="math inline">\(a,b\)</span> and <span class="math inline">\(c\)</span>, and that the incircle has radius <span class="math inline">\(d\)</span>. Soddy’s formula is: <span class="math display">\[\left(\frac{1}{a}+\frac{1}{b}+\frac{1}{c}+\frac{1}{d}\right)^2=2\left(\frac{1}{a^2}+\frac{1}{b^2}+\frac{1}{c^2}+\frac{1}{d^2}\right).\]</span></p><p>阿波罗尼奥斯，被同时代人誉为伟大的几何学家，生活在佩尔加，即现今土耳其的一部分。作为希腊数学的巨擘之一，他因八卷本专著《圆锥曲线论》而闻名，该著作研究了椭圆、双曲线和抛物线作为平面以不同角度切割圆锥所得截面的性质。其著作迅速成为古代世界的标准教材。许多作品现已遗失，我们仅通过其他评论中的提及了解它们，其中包括关于正多面体、无理数及对<span class="math inline">\(\pi\)</span>的近似值的研究。托勒密将本轮理论归功于阿波罗尼奥斯，这一理论成为他行星运动学说的基础。</p><p>阿波罗尼奥斯遗失的著作之一名为《切触》，据记载，该书提供了构建与各种直线和圆组合相切的圆的方法，例如寻找与两条给定直线及另一个圆相切的圆。你可以将寻找理想三角形内切圆的问题视为此类问题。最难的难题，即构建与三个给定且互不相交的圆相切的两个圆，在古代可能并未解决，然而艾萨克·牛顿爵士记录了一个证明。根据帕普斯的说法，《切触》给出了一个公式，用于计算理想三角形内切圆的半径，该半径与限定其三条边的圆的半径有关。尽管如此，笛卡尔在1643 年确实描述了这样一个公式，且在 18世纪的日本也已知晓其版本。实际上，这个公式似乎被多次重新发现，最近一次是由弗雷德里克·索迪爵士完成的。为了纪念他，内切圆有时被称为索迪圆。索迪因发现同位素而于1921 年获得诺贝尔奖，他对如何排列不同大小的球形原子自然产生了兴趣。</p><p>索迪对这个公式深深着迷，以至于他以一首诗的形式将其发表，这首诗出现在1936年的《自然》杂志上。其核心部分包含在本章开头引用的中间诗句中。对于那些更偏好使用符号的读者，假设三个连锁圆的半径分别为<span class="math inline">\(a, b\)</span> 和 <span class="math inline">\(c\)</span>，内切圆的半径为 <span class="math inline">\(d\)</span>。索迪的公式为：</p><p><span class="math display">\[\left(\frac{1}{a}+\frac{1}{b}+\frac{1}{c}+\frac{1}{d}\right)^2=2\left(\frac{1}{a^2}+\frac{1}{b^2}+\frac{1}{c^2}+\frac{1}{d^2}\right).\]</span></p></div><h1 id="generating-the-gasket">Generating the gasket</h1><div class="statement simple plain unnumbered"><p>The configuration of tangent circles which produced the gasket isshown in the right frame of Figure 7.4. The picture has been arranged sothat <span class="math inline">\(C_a\)</span> goes through <span class="math inline">\(\infty\)</span>, hence it appears in the figure asa straight line. In addition, <span class="math inline">\(C_A\)</span>and <span class="math inline">\(C_a\)</span> are tangent at 0 and <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> are tangent at <span class="math inline">\(-i\)</span>. You can see how this picture is madeby creating extra tangencies among a kissing chain of four circles bycomparing with the nearby arrangement of four circles in the left handframe.</p></div><p>生成垫片的相切圆配置如 <a href="#fig-7.4">图 7.4</a>右图所示。图中特意令圆 <span class="math inline">\(C_a\)</span> 经过<span class="math inline">\(\infty\)</span>，从而它在图中呈现为一条直线。此外，我们令圆<span class="math inline">\(C_A\)</span> 与 <span class="math inline">\(C_a\)</span> 在原点 0 处相切，圆 <span class="math inline">\(C_B\)</span> 与 <span class="math inline">\(C_b\)</span> 在<span class="math inline">\(-i\)</span>处相切。通过与左边图中四个圆的排列进行对比，可以清晰观察到右图通过在四圆相切链中引入额外切点形成的特殊结构。</p><figure id="fig-7.4"><img src="/images/indra/fig-7.4.jpg" class="fig" width="600" alt="Figure 7.4. The right frame shows the starting configuration of tangent Schottky circles which produces the glowing gasket. The red circles C_a and C_A are paired by the transformation a and the blue circles C_B and C_b by b. Using notation from the last chapter, the tangency points P,Q,R and S are at 1,-1,-0.2-0.4i and 0.2-0.4i respectively. On the left is a nearby Schottky configuration of circles which are not quite tangent and a and b are loxodromic. This is similar to the configuration shown in frame (vi) of Figure 6.10. The centre frame is an intermediate stage where a is parabolic but b is not. 图 7.4. 右图展示了生成发光垫片的相切 Schottky 圆的初始配置。红色圆 C_a 与 C_A 通过变换 a 配对，蓝色圆 C_B 与 C_b 通过变换 b 配对。根据前一章的记号，切点 P, Q, R, S 分别位于坐标 1, -1, -0.2-0.4i 和 0.2-0.4i 处。左图展示了一个相似的 Schottky 圆配置，其中圆未完全相切，且变换 a 和 b 均为斜航的。该配置与 图 6.10 (vi) 中的结构相似。中间图呈现了过渡状态，其中变换 a 是抛物线型的，而 b 不是。"><figcaption aria-hidden="true">Figure 7.4. The right frame shows thestarting configuration of tangent Schottky circles which produces theglowing gasket. The red circles <span class="math inline">\(C_a\)</span>and <span class="math inline">\(C_A\)</span> are paired by thetransformation <span class="math inline">\(a\)</span> and the bluecircles <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> by <span class="math inline">\(b\)</span>. Using notation from the last chapter,the tangency points <span class="math inline">\(P,Q,R\)</span> and <span class="math inline">\(S\)</span> are at <span class="math inline">\(1,-1,-0.2-0.4i\)</span> and <span class="math inline">\(0.2-0.4i\)</span> respectively. On the left is anearby Schottky configuration of circles which are not quite tangent and<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are loxodromic. This is similar to theconfiguration shown in frame (vi) of Figure 6.10. The centre frame is anintermediate stage where <span class="math inline">\(a\)</span> isparabolic but <span class="math inline">\(b\)</span> is not.<br>图 7.4. 右图展示了生成发光垫片的相切 Schottky 圆的初始配置。红色圆 <span class="math inline">\(C_a\)</span> 与 <span class="math inline">\(C_A\)</span> 通过变换 <span class="math inline">\(a\)</span> 配对，蓝色圆 <span class="math inline">\(C_B\)</span> 与 <span class="math inline">\(C_b\)</span> 通过变换 <span class="math inline">\(b\)</span> 配对。根据前一章的记号，切点 <span class="math inline">\(P, Q, R, S\)</span> 分别位于坐标 <span class="math inline">\(1, -1, -0.2-0.4i\)</span> 和 <span class="math inline">\(0.2-0.4i\)</span> 处。左图展示了一个相似的Schottky 圆配置，其中圆未完全相切，且变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 均为斜航的。该配置与 <a href="#fig-6.10">图 6.10</a> (vi)中的结构相似。中间图呈现了过渡状态，其中变换 <span class="math inline">\(a\)</span> 是抛物线型的，而 <span class="math inline">\(b\)</span> 不是。</figcaption></figure><div class="statement simple plain unnumbered"><p>The generating matrices for the gasket are quite simple: <span class="math display">\[a=\begin{pmatrix}1&amp;0\\-2i&amp;1\end{pmatrix}\quad\text{and}\quadb=\begin{pmatrix}1-i&amp;1\\1&amp;1+i\end{pmatrix}.\]</span></p><p>We shall have more to say about how we arrived at these particularformulas later on. Note that <span class="math inline">\(\mathop{\mathrm{Tr}}{a}=\mathop{\mathrm{Tr}}{b}=2\)</span>,so <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are parabolic. Looking at thearrangement of Schottky circles in Figure 7.4, you see the fixed pointof <span class="math inline">\(a\)</span> is 0, the tangency point ofthe circles <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span>. In Figure 7.3, you can see twochains of tangent circles nesting down on 0 from above and below. Thesame phenomenon occurs at <span class="math inline">\(-i\)</span>, thetangency point of <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> and the fixed point of <span class="math inline">\(b\)</span>. Notwithstanding extra tangencies, thegenerators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> still pair opposite circles in theinitial tangent chain <span class="math inline">\(C_a,C_b,C_A\)</span>and <span class="math inline">\(C_B\)</span>. This means that fornesting circles we still need the commutator condition <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB}=2\)</span>, which isnot hard to check.</p></div><p>生成该垫片的矩阵非常简单：</p><p><span class="math display">\[a=\begin{pmatrix}1&amp;0\\-2i&amp;1\end{pmatrix}\quad\text{and}\quadb=\begin{pmatrix}1-i&amp;1\\1&amp;1+i\end{pmatrix}.\]</span></p><p>关于这两个特定的矩阵，我们稍后会详细解释它们的推导过程。注意到 <span class="math inline">\(\mathop{\mathrm{Tr}}{a}=\mathop{\mathrm{Tr}}{b}=2\)</span>，因此<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 都是抛物型变换。观察 <a href="#fig-7.4">图 7.4</a> 中 Schottky 圆的排列，可以看到 <span class="math inline">\(a\)</span> 的不动点是 0，即圆 <span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span> 的切点。在 <a href="#fig-7.3">图7.3</a> 中，你可以看到两条相切的圆链从上下两侧分别向 0点逐渐嵌套收缩。相同的现象也出现在 <span class="math inline">\(-i\)</span> 处，这既是圆 <span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 的切点，也是变换 <span class="math inline">\(b\)</span> 的不动点。尽管存在额外的切点，生成元<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 依然将初始的相切链 <span class="math inline">\(C_a,C_b,C_A,C_B\)</span>中的圆配对。这意味着要实现圆链的无穷嵌套，我们仍需满足交换子条件 <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB}=2\)</span>，这一点并不难验证。</p><div class="statement simple plain unnumbered"><p>We have been speaking as if there is only one Apollonian gasket, butcould we not get different gaskets by starting with different tangentchains? Not really, because it turns out that any chain of three tangentcircles can be conjugated to any other three. As you can work out inProject 7.1, this stems from the fact that there is always a Möbius mapcarrying any three points to any other three. Since the gasket isactivated by its initial ideal triangle, and since the procedure at eachstep consists in adding incircles, a Möbius map which conjugates oneideal triangle to another carries the whole gasket along in itswake.</p><p>This explains why it makes sense to talk about the Apollonian gasket,because up to conjugation by Möbius maps there is really only one.</p></div><p>我们此前的讨论似乎一直都默认了阿波罗尼奥斯垫片是独一无二的，但如果我们从不同的初始相切圆链出发，难道不会得到不同的垫片吗？其实不能。事实上，任何由三个相切圆组成的链，都可以通过某个莫比乌斯变换转化为另一组任意的相切圆链。正如你在<a href="#proj-7.1" title="项目 7.1">项目 7.1</a>中可以推导出的那样，这源于总有一个莫比乌斯映射将任意三个点映射到其他任意三个点。由于垫片的构造源于其初始理想三角形，而每一步的操作都是添加内切圆，一个将一个理想三角形共轭到另一个理想三角形的莫比乌斯映射会将整个垫片一起带走。</p><p>这就解释了为什么谈论“阿波罗尼奥斯垫片”是有意义的，因为在莫比乌斯变换的共轭意义下，归根结底，阿波罗尼奥斯垫片只有一个。</p><figure id="fig-7.5"><img src="/images/indra/fig-7.5.jpg" width="600" alt="Figure 7.5. The strip gasket. This shows the gasket as it appears when we conjugate so that the extra tangency point of C_b and C_B is at \infty. Any parabolic with a fixed point at \infty is a Euclidean translation, in this case b(z)=z+2, which explains the translational symmetry along the infinite strip. 图 7.5. 带状垫片。图中展示了当我们进行共轭变换，使得 C_b 和 C_B 的额外切点位于 \infty 处时，垫片的样貌。任何以 \infty 为不动点的抛物型变换都是欧几里得平移，在本例中为 b(z)=z+2，这解释了沿着无限带的平移对称性。"><figcaption aria-hidden="true">Figure 7.5. The strip gasket. This showsthe gasket as it appears when we conjugate so that the extra tangencypoint of <span class="math inline">\(C_b\)</span> and <span class="math inline">\(C_B\)</span> is at <span class="math inline">\(\infty\)</span>. Any parabolic with a fixed pointat <span class="math inline">\(\infty\)</span> is a Euclideantranslation, in this case <span class="math inline">\(b(z)=z+2\)</span>,which explains the translational symmetry along the infinitestrip.<br>图 7.5. 带状垫片。图中展示了当我们进行共轭变换，使得 <span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 的额外切点位于 <span class="math inline">\(\infty\)</span> 处时，垫片的样貌。任何以 <span class="math inline">\(\infty\)</span>为不动点的抛物型变换都是欧几里得平移，在本例中为 <span class="math inline">\(b(z)=z+2\)</span>，这解释了沿着无限带的平移对称性。</figcaption></figure><p>另一个著名的垫片版本可以在 <a href="#fig-7.5">图 7.5</a>中看到。为了得到这个，我们进行了共轭，使得 <span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span> 在 0 处相切，因此它们是垂直线。映射<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 现在在 <span class="math inline">\(0\)</span> 处有一个不动点。该群的生成元为：</p><p><span class="math display">\[a=\begin{pmatrix}2&amp;-i\\-i&amp;0\end{pmatrix}\quad\text{and}\quadb=\begin{pmatrix}1&amp;2\\0&amp;1\end{pmatrix}.\]</span></p><h1 id="pinching-tiles">Pinching tiles</h1><figure id="fig-7.6"><img src="/images/indra/fig-7.6.jpg" width="600" alt="Figure 7.6. Dr.&nbsp;Stickler meets Apollonius. Placing Dr.&nbsp;Stickler in the Apollonian gasket, we let the group of symmetries carry him around. He appears exactly in those disks which were pink in Figure 7.4. If we had started him off in a white one, his images would fill the white disks instead. The symmetry a is parabolic and on both sides of its fixed point 0, circles of Sticklers are streaming out. A startling feature is the circle of Sticklers streaming out from and into 1. Every alternate Stickler is standing on his head! The upright Sticklers are just powers of abAB (which fixes 1) applied to the Stickler standing on the right hand horizontal axis, while the upside down ones are the images of this same Stickler under (abAB)^nA. 图 7.6. Stickler 博士邂逅阿波罗尼奥斯分形。我们将 Stickler 博士置于阿波罗尼奥斯垫片中，然后让对称群带他四处转转。结果，他恰好出现在 图 7.4 里那些粉红色的圆盘中。若是他最初出现在某个白色圆盘中，那么他的身影就会填满所有的白色圆盘。对称 a 是抛物型的，在它的不动点 0 的两侧，成群的 Stickler 博士正沿着圆圈向外扩散。最令人惊奇的是，在坐标 1 附近，竟然出现了一圈 Stickler 博士首尾相连、双向流动的奇妙图案。更绝的是，相邻的 Stickler 博士还头朝上、头朝下交替出现。那些站得笔直的 Stickler 博士，是通过不断对右侧水平轴上那位 Stickler 施加变换 (abAB)^n（该变换以 1 为不动点）得到的。而那些倒立的 Stickler 博士，则是这位 Stickler 在变换 (abAB)^nA 作用下的映射结果。"><figcaption aria-hidden="true">Figure 7.6. Dr.&nbsp;Stickler meetsApollonius. Placing Dr.&nbsp;Stickler in the Apollonian gasket, we let thegroup of symmetries carry him around. He appears exactly in those diskswhich were pink in Figure 7.4. If we had started him off in a white one,his images would fill the white disks instead. The symmetry <span class="math inline">\(a\)</span> is parabolic and on both sides of itsfixed point 0, circles of Sticklers are streaming out. A startlingfeature is the circle of Sticklers streaming out from and into 1. Everyalternate Stickler is standing on his head! The upright Sticklers arejust powers of <span class="math inline">\(abAB\)</span> (which fixes 1)applied to the Stickler standing on the right hand horizontal axis,while the upside down ones are the images of this same Stickler under<span class="math inline">\((abAB)^nA\)</span>.<br>图 7.6. Stickler 博士邂逅阿波罗尼奥斯分形。我们将 Stickler博士置于阿波罗尼奥斯垫片中，然后让对称群带他四处转转。结果，他恰好出现在<a href="#fig-7.4">图 7.4</a>里那些粉红色的圆盘中。若是他最初出现在某个白色圆盘中，那么他的身影就会填满所有的白色圆盘。对称<span class="math inline">\(a\)</span> 是抛物型的，在它的不动点 0的两侧，成群的 Stickler 博士正沿着圆圈向外扩散。最令人惊奇的是，在坐标 1附近，竟然出现了一圈 Stickler博士首尾相连、双向流动的奇妙图案。更绝的是，相邻的 Stickler博士还头朝上、头朝下交替出现。那些站得笔直的 Stickler博士，是通过不断对右侧水平轴上那位 Stickler 施加变换 <span class="math inline">\((abAB)^n\)</span>（该变换以 1为不动点）得到的。而那些倒立的 Stickler 博士，则是这位 Stickler 在变换<span class="math inline">\((abAB)^nA\)</span>作用下的映射结果。</figcaption></figure><div class="statement simple plain unnumbered"><p>Figure 7.6 is a wonderful picture of what happened when we introducedDr.&nbsp;Stickler to Apollonius! It is a pretty intricate arrangement, solet’s take a bit of time understanding what has happened to the tiles.To get a grasp on the situation, look back at the three pictures inFigure 7.4, and watch the progression across the three frames. On theleft the limit set is a loop or quasicircle, so the ordinary set - whatis left when you take away the limit set - has two parts, a pink insideand a white outside. In the central picture, the pink part has collapsedinto a myriad of tangent disks, and the red Schottky circles <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span> touch at 0. On the right, the gasketgroup, the ‘horns’ of the pink region have also come together, causingthe white outside to fracture into disks as well. Notice how the memoryof which was inside and which was outside still persists, because whatwere the ‘inside’ disks are pink while the ‘outside’ ones are white.</p></div><p><a href="#fig-7.6">图 7.6</a> 是一幅精彩的画面，生动展现了当我们邀请Stickler博士探索阿波罗尼奥斯分形时所发生的奇妙事情！图中的结构相当复杂，因此我们不妨花些时间，仔细剖析图案的变化。要理解这一过程，不妨回顾<a href="#fig-7.4">图 7.4</a>的三幅子图，并观察这三帧之间的演变：左图中的极限集是一个回路或拟圆，因此普通集（即去掉极限集后剩下的部分）分为粉色的内部和白色的外部。中间的图中，粉色区域已收缩成无数相切的圆盘，而红色的肖特基圆<span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_A\)</span> 在 0处相切。右图则展示了垫片群，其中粉色区域的“触角”也汇聚在一起，使得白色外部区域也裂解成圆盘。令人惊奇的是，尽管整体结构支离破碎，内外区域仍清晰保留着原始的记忆——曾经“内部”的圆盘依旧是粉色，而“外部”的圆盘依旧是白色。</p><div class="statement simple plain unnumbered"><p>In each picture, the initial Schottky circles are blue and red. Watchthem to follow the fate of the tiles. On the left, as usual for akissing Schottky group, they surround the central inner four sided tile.If we transported this tile around by the group, we would see atessellation　of the pink region similar to the one in Figure 6.6.(There is also an outer tile, the region outside the four Schottkycircles, which as usual you can see more clearly by imagining it on theRiemann sphere.) The inner and outer parts of the ordinary set areinvariant under the group, so if you apply any transformation of thegroup to any tile in the pink region ‘inside’ the limit set, you getanother tile which is also ‘inside’.</p></div><p>在每幅图中，最初的 Schottky圆分别是蓝色和红色。仔细观察它们的变化，有助于追踪瓷砖的运动轨迹。在左图中，和典型的“亲吻”Schottky群一样，这些圆环绕着中央的四边形瓷砖。如果我们将这块瓷砖沿着群的变换不断移动，就会在粉色区域中形成类似于<a href="#fig-6.6">图 6.6</a>的镶嵌图案（此外，还有一个外部瓷砖，即位于四个 Schottky圆之外的区域，通常，通过在黎曼球面上想象它的位置，可以更清楚地看到它的轮廓）。普通集的内部和外部在群作用下各自保持不变，因此，如果对极限集“内部”粉色区域中的某块瓷砖施加群中的某个变换，得到的仍会是另一块位于“内部”的瓷砖。</p><div class="statement simple plain unnumbered"><p>In the central picture, where <span class="math inline">\(a\)</span>has become parabolic, the inner tile has been pinched into two halves.Each half-tile is an ideal triangle, with two red sides and one blue.You should think of this pair of triangles as one composite two-parttile. Moved around by the group, the composite tile will cover all thepink circles. There is an outer tile in this picture too, which (on theRiemann sphere) remains in one piece.</p><p>On the right, in the gasket group, both <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> have been pinched so that now <span class="math inline">\(C_b\)</span> and <span class="math inline">\(C_B\)</span> also tuch at <span class="math inline">\(-i\)</span>. Now there are four basic half-tiles.The two pink ones will produce a tiling of the pink circles and thewhite ones will make a tiling of the white circles. In the glowinggasket picture, these four tiles are black. The upper two ‘horizontal’ideal triangles are the remnants of the inner Schottky tile, while thelower ‘vertical’ triangle is a remnant of the outer one. If you lookcarefully, you can just see its twin peeping out in the bottom centre ofthe page.</p></div><p>在中央的图片中，<span class="math inline">\(a\)</span>已变成了抛物型，内部的瓷砖被挤压成了两半。每个半瓷砖都是一个理想三角形，带有两条红边和一条蓝边。你可以把这对三角形视作一个由两部分组成的复合瓷砖。通过群的作用，这个复合瓷砖将覆盖所有的粉色圆盘。图中还有一个外部瓷砖，它在黎曼球面上依然保持完整。</p><p>在右侧的垫片图中，<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 都被挤压变形，使得 <span class="math inline">\(C_b\)</span> 和 <span class="math inline">\(C_B\)</span> 现在也在 <span class="math inline">\(-i\)</span>处相切。此时出现了四个基本的半瓷砖。两块粉色的会铺满粉色圆盘，而两块白色的则会铺满白色圆盘。在那幅发光的垫片图中，这四块瓷砖都呈现为黑色。上方的两个“水平”理想三角形是内部Schottky瓷砖的残迹，而下方的“垂直”三角形则是外部瓷砖的残迹。仔细观察，你会在页面底部中央隐约发现它的孪生兄弟正悄悄探出头来。</p><div class="statement simple plain unnumbered"><p>Now we can go back to the picture of Dr.&nbsp;Stickler meeting Apollonius.The party is taking place in the remnants of the ‘pink’ circles. If youcompare with the half-tiles in Figure 7.4, something rather odd hashappened to Dr.&nbsp;Stickler - when the original tile split in two, his headended up in the green half-tile and his feet in the blue one.Fortunately, there is a transformation of the group (namely <span class="math inline">\(B\)</span>) which carries the blue Stickler to thegreen one, moving the blue half-tile containing the blue feet to theyellow half-tile containing the green feet. Had we not pointed out hisdifficulties you might not even have noticed that anything was wrong.After gluing the yellow half-tile to the green halftile, the relieved(but still slightly greenish) Dr.&nbsp;Stickler stands reunited in a new andcomplete tile whose images under the group map to all the Sticklers inthe picture.</p></div><p>现在我们可以回到 Stickler博士与阿波罗尼奥斯相遇的画面。聚会正在“粉色”圆圈的残迹中举行。对照 <a href="#fig-7.4">图 7.4</a> 中的半瓷砖，你会发现 Stickler博士身上发生了一件相当奇怪的事——当原始瓷砖裂成两半时，原始瓷砖裂成两半时，他的头跑到了绿色半瓷砖里，而他的脚却留在了蓝色半瓷砖上。幸好，群中有一个变换（即<span class="math inline">\(B\)</span>）可以将蓝色的 Stickler 带到绿色Stickler的位置，把装着蓝色脚丫的蓝色半瓷砖挪到装着绿色脚丫的黄色半瓷砖上。要不是我们特意指出这种窘况，你可能根本没发现哪里不对劲。等到黄色半瓷砖和绿色半瓷砖粘合完毕，那位如释重负（却仍然带着一丝“绿意”）的Stickler博士终于又完整地站在了一块崭新的瓷砖上。通过群的映射，这块瓷砖的影像铺展开来，构成了画面中所有Stickler 博士的身影。</p><h1 id="and-pinching-surfaces">And pinching surfaces</h1><div class="statement simple plain unnumbered"><p>What happened to the tiles in the last section, has, of course, alsoan interpretation in terms of surfaces. Looking back to the picture onp.&nbsp;190 which showed how tiles were glued up in a kissing Schottky group,we can work out what happens when we bring the four circles together tomake the gasket. It takes a bit of stretching and squeezing to do this,which we have illustrated in Figure 7.7.</p><p>The result, shown in the last panel, is our old friend the pretzelwith three circles pinched to points or cusps: the waist as in the lastchapter and, in addition, loops around the top and bottom tori. Both topand bottom are now ‘spheres’ with three cusps or punctures each. Onepair of cusps on each sphere are joined together like ‘horns’, and thesetwo ‘horned spheres’ are themselves joined together at the last twocusps.</p></div><p>上一节中瓷砖的演变过程，当然也可以从曲面角度得到诠释。回顾第 190页展示的亲吻 Schottky群的基本域粘合过程的示意图，我们可以推导出当将四个圆粘合为垫片群时会发生什么。这一过程需要一些拉伸和压缩，我们在<a href="#fig-7.7" title="图 7.7">图 7.7</a> 中进行了直观展示。</p><p>最终结果呈现于最后一幅示意图中，正是我们熟悉的椒盐脆饼造型——三个圆周被压缩为尖点（cusp）：其中一个是上一章提到的“腰部”尖点，另外两个则是围绕顶部和底部的环面。此时，顶部与底部都变成了各自有三个尖点（或称穿孔）的”球面”。每个球面上的一对尖点像”犄角”一样连接在一起，而这两个“带角球面”则通过它们剩下的两个尖点相互连接。</p><div class="statement simple plain unnumbered"><p>The gasket group is called doubly cusped because we have pinched twoextra loops, <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>. It is also sometimes called maximallycusped, because, after all this squeezing, there are no more curves leftto pinch. In Chapter 9, we shall see that you can make many variants ofthe gasket group by imposing more complicated relationships between thecurves we choose to pinch on the top and bottom halves of the pinchedpretzel.</p></div><p>垫片群被称为双尖群，因为我们挤压了两个额外的环路 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>。它也常被称为“极大尖群”，因为经过这般操作后，已不存在可供进一步挤压的曲线。在第九章中我们将看到，通过在挤压后的椒盐卷曲曲面（pretzel）的上下半部之间，对选定挤压曲线施加更复杂的关联约束，可以构造出多种垫片群的变体。</p><div id="fig-7.7" class="statement simple plain unnumbered"><p>Figure 7.7. Pinching curves. How gluing up the gasket configurationof tangent circles leads to a pair of triply-punctured spheres. The<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> curves we have to shrink are are marked<span class="math inline">\(L\)</span> and <span class="math inline">\(M\)</span>. Instead of pulling the upper and lowerpartially glued-up cylinders logether right away, as we did in Figure6.16, it now takes some effort first to twist them relative to eachother in such a way that when we glue-up, the dotted loops are in theirproper position ready to be shrunk.</p><p>图 7.7.捏合曲线。如何通过粘合垫片的切圆得到一对带有三穿孔球面。需要收缩的 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 曲线分别标记为 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span>。与 <a href="#fig-6.16">图 6.16</a>中直接粘合上下圆柱体的操作不同，此时需要先使两者相对扭转，确保粘合时虚线环处于正确位置以便后续收缩。</p><figure><img src="/images/indra/fig-7.7-1.jpg" width="200" alt="BEGIN WITH A PLANE WITH FOUR HOLES, EACH OF WHICH JUST TOUCHES THREE OTHERS, WHAT HAPPENS WHEN WE GLUE A TO a (THE SMALL ONE) AND B TO b? 从一个带有四个孔的平面开始，每个孔都与另外三个孔相切。当我们将 A 粘合到 a（较小的孔），并将 B 粘合到 b 时，会发生什么？"><figcaption aria-hidden="true">BEGIN WITH A PLANE WITH FOUR HOLES, EACHOF WHICH JUST TOUCHES THREE OTHERS, WHAT HAPPENS WHEN WE GLUE <span class="math inline">\(A\)</span> TO <span class="math inline">\(a\)</span> (THE SMALL ONE) AND <span class="math inline">\(B\)</span> TO <span class="math inline">\(b\)</span>?<br>从一个带有四个孔的平面开始，每个孔都与另外三个孔相切。当我们将 <span class="math inline">\(A\)</span> 粘合到 <span class="math inline">\(a\)</span>（较小的孔），并将 <span class="math inline">\(B\)</span> 粘合到 <span class="math inline">\(b\)</span> 时，会发生什么？</figcaption></figure><figure><img src="/images/indra/fig-7.7-2.jpg" width="200" alt="FIRST PULL a AWAY FROM A AND B AWAY FROM b ALONG THE ARCS L AND M. HOW WE SEE A DISTORTED BUT FAMILIAR PICTURE: ABab. 首先，沿弧线 L 将 a 从 A 处拉开，沿弧线 M 将 B 从 b 处拉开。此时会呈现一个扭曲但熟悉的图案：ABab。"><figcaption aria-hidden="true">FIRST PULL a AWAY FROM A AND B AWAY FROMb ALONG THE ARCS <span class="math inline">\(L\)</span> AND <span class="math inline">\(M\)</span>. HOW WE SEE A DISTORTED BUT FAMILIARPICTURE: <span class="math inline">\(ABab\)</span>.<br>首先，沿弧线 <span class="math inline">\(L\)</span> 将 <span class="math inline">\(a\)</span> 从 <span class="math inline">\(A\)</span> 处拉开，沿弧线 <span class="math inline">\(M\)</span> 将 <span class="math inline">\(B\)</span> 从 <span class="math inline">\(b\)</span>处拉开。此时会呈现一个扭曲但熟悉的图案：<span class="math inline">\(ABab\)</span>。</figcaption></figure><figure><img src="/images/indra/fig-7.7-3.jpg" width="200" alt="ADO THE POINT AT INFINITY TO WRAP UP THE PLANE. 通过添加无穷远点使平面闭合。"><figcaption aria-hidden="true">ADO THE POINT AT INFINITY TO WRAP UP THEPLANE.<br>通过添加无穷远点使平面闭合。</figcaption></figure><figure><img src="/images/indra/fig-7.7-4.jpg" width="200" alt="STRETCH TO MAKE THIS FAMILIAR SURFACE. NOTE ARCS L AND M. 拉伸形成我们熟悉的曲面。注意观察弧线 L 和 M。"><figcaption aria-hidden="true">STRETCH TO MAKE THIS FAMILIAR SURFACE.NOTE ARCS <span class="math inline">\(L\)</span> AND <span class="math inline">\(M\)</span>.<br>拉伸形成我们熟悉的曲面。注意观察弧线 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span>。</figcaption></figure><figure><img src="/images/indra/fig-7.7-5.jpg" width="200" alt="NOW SOMETHING STRANGE: PULL TOGETHER THE TOP HALVES OF A AND a AND THE BOTTOM HALVES OF B AND b. 进行奇怪的操作：将 A 和 a 的上半部分、B 和 b 的下半部分别拉到一起。"><figcaption aria-hidden="true">NOW SOMETHING STRANGE: PULL TOGETHER THETOP HALVES OF <span class="math inline">\(A\)</span> AND <span class="math inline">\(a\)</span> AND THE BOTTOM HALVES OF <span class="math inline">\(B\)</span> AND <span class="math inline">\(b\)</span>.<br>进行奇怪的操作：将 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(a\)</span> 的上半部分、<span class="math inline">\(B\)</span> 和 <span class="math inline">\(b\)</span> 的下半部分别拉到一起。</figcaption></figure><figure><img src="/images/indra/fig-7.7-6.jpg" width="200" alt="GUE TOP OF A TO TOP of a, BOTTOM OF B TO BOTTOM OF b. 将 A 的顶部和 a 的顶部粘在一起，将 B 的底部和 b 的底部粘在一起。"><figcaption aria-hidden="true">GUE TOP OF <span class="math inline">\(A\)</span> TO TOP of <span class="math inline">\(a\)</span>, BOTTOM OF <span class="math inline">\(B\)</span> TO BOTTOM OF <span class="math inline">\(b\)</span>.<br>将 <span class="math inline">\(A\)</span> 的顶部和 <span class="math inline">\(a\)</span> 的顶部粘在一起，将 <span class="math inline">\(B\)</span> 的底部和 <span class="math inline">\(b\)</span> 的底部粘在一起。</figcaption></figure><figure><img src="/images/indra/fig-7.7-7.jpg" width="200" alt="NOW JOIN THE REST OF A TO a ANP B TO b. 继续完成 A 与 a、B 与 b 剩余部分的粘合。"><figcaption aria-hidden="true">NOW JOIN THE REST OF <span class="math inline">\(A\)</span> TO <span class="math inline">\(a\)</span> ANP <span class="math inline">\(B\)</span> TO <span class="math inline">\(b\)</span>.<br>继续完成 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(a\)</span>、<span class="math inline">\(B\)</span>与 <span class="math inline">\(b\)</span> 剩余部分的粘合。</figcaption></figure><figure><img src="/images/indra/fig-7.7-8.jpg" width="200" alt="FINALLY, SHORTEN THE ARCS L AND M … 最终收缩弧线 L 和 M …"><figcaption aria-hidden="true">FINALLY, SHORTEN THE ARCS <span class="math inline">\(L\)</span> AND <span class="math inline">\(M\)</span> …<br>最终收缩弧线 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span> …</figcaption></figure><figure><img src="/images/indra/fig-7.7-9.jpg" width="200" alt="UNTIL EACH ARC SHRINKS TO A POINT, MAKING TWO TRIPLY-PUNCTURED SPHERES. 直至每个弧线都坍缩为一点，形成两个三穿孔球面。"><figcaption aria-hidden="true">UNTIL EACH ARC SHRINKS TO A POINT, MAKINGTWO TRIPLY-PUNCTURED SPHERES.<br>直至每个弧线都坍缩为一点，形成两个三穿孔球面。</figcaption></figure></div><h1 id="tiling-the-inner-disks">Tiling the inner disks</h1><div class="statement simple plain unnumbered"><p>Figure 7.6 is made up of lots of disks full of Dr.&nbsp;Sticklers, eachtiled by ideal triangles shown in grey. These disks are the remnants ofthe pink region in Figure 7.4. For most of the rest of this chapter, weshall be occupied with the tiling of just one of these disks. The sametiling fills out the insides of each of the glowing circles in Figure7.3. The group of symmetries which goes with this very special disktessellation is called the modular group and has been the well-spring ofa huge body of mathematics.</p></div><p><a href="#fig-7.6">图 7.6</a> 由无数布满 Sticklers博士身影的圆盘构成，每个圆盘都被灰色的理想三角形所镶嵌。这些圆盘正是 <a href="#fig-7.4">图 7.4</a>中粉色区域的残迹。在本章接下来的大部分篇幅里，我们将专注于研究其中一个圆盘的密铺结构。同样的密铺图案也出现在<a href="#fig-7.3">图 7.3</a>中每个发光圆圈的内部。这种独特的圆盘镶嵌的对称群称为模群，它一直是众多数学成果的源泉。</p><div class="statement simple plain unnumbered"><p>Since the tiling in each disk is the same, we may as well focus onthe large disk through -1 and 0, shown in yellow in Figure 7.8. Tounderstand how these ideal triangle tiles cover the yellow disk we needto find the subgroup of all the transformations in the gasket groupwhich map the inside of this disk to itself. This subgroup (which is ofcourse also a group in its own right), or any of its conjugates, is whatwe call the modular group. The basic tile is made up of two idealtriangles, the ones coloured green and yellow in Figure 7.6. The twotriangles together form one of our familiar four-sided pinched-off tileswith four circular arc sides. Moved around by the modular group, theytile the whole yellow disk.</p></div><p>由于每个圆盘中的密铺方式相同，我们可以将注意力集中在通过 -1 和 0的大圆盘上，这在 <a href="#fig-7.8">图 7.8</a>中以黄色部分表示。为了理解这些理想三角形如何覆盖黄色圆盘，我们需要找出垫片群中所有将圆盘内部映射到自身的变换子群。这个子群（显然，它本身也是一个群），或者它的任何共轭子群，便是我们所称的模群。基本的瓷砖由两个理想三角形组成，即<a href="#fig-7.6">图 7.6</a>中绿色和黄色的三角形。这两个三角形合在一起，构成了我们熟悉的四边弧形瓷砖。通过模群的作用，它们密铺了整个黄色圆盘。</p><figure id="fig-7.8"><img src="/images/indra/fig-7.8.jpg" width="600" alt="Figure 7.8. The set-up of tangent circles for the modular subgroup. The left frame is just to get oriented. The red circles C_A and C_a, together with the level 2 green circles B(C_a)=C_{Ba} and B(C_A)=C_{BA} form the boundary of the new four-sided tile. The arrows show how a pairs C_A to C_a and b pairs C_B to C_b. The boundary of the yellow disk is the limit set of the modular group generated by a and BAb. 图 7.8. 模群的切线圆配置。左侧子图仅用于帮助定位。红色圆圈 C_A 和 C_a，以及二级绿色圆圈 B(C_a)=C_{Ba} 和 B(C_A)=C_{BA} 共同构成了新四边形瓷砖的边界。箭头指示了变换 a 如何将 C_A 和 C_a 配对，变换 b 如何将 C_B 和 C_b 配对。黄色圆盘的边界是由 a 和 BAb 生成的模群的极限集。"><figcaption aria-hidden="true">Figure 7.8. The set-up of tangent circlesfor the modular subgroup. The left frame is just to get oriented. Thered circles <span class="math inline">\(C_A\)</span> and <span class="math inline">\(C_a\)</span>, together with the level 2 greencircles <span class="math inline">\(B(C_a)=C_{Ba}\)</span> and <span class="math inline">\(B(C_A)=C_{BA}\)</span> form the boundary of thenew four-sided tile. The arrows show how <span class="math inline">\(a\)</span> pairs <span class="math inline">\(C_A\)</span> to <span class="math inline">\(C_a\)</span> and <span class="math inline">\(b\)</span> pairs <span class="math inline">\(C_B\)</span> to <span class="math inline">\(C_b\)</span>. The boundary of the yellow disk isthe limit set of the modular group generated by <span class="math inline">\(a\)</span> and <span class="math inline">\(BAb\)</span>.<br>图 7.8. 模群的切线圆配置。左侧子图仅用于帮助定位。红色圆圈 <span class="math inline">\(C_A\)</span> 和 <span class="math inline">\(C_a\)</span>，以及二级绿色圆圈 <span class="math inline">\(B(C_a)=C_{Ba}\)</span> 和 <span class="math inline">\(B(C_A)=C_{BA}\)</span>共同构成了新四边形瓷砖的边界。箭头指示了变换 <span class="math inline">\(a\)</span> 如何将 <span class="math inline">\(C_A\)</span> 和 <span class="math inline">\(C_a\)</span> 配对，变换 <span class="math inline">\(b\)</span> 如何将 <span class="math inline">\(C_B\)</span> 和 <span class="math inline">\(C_b\)</span> 配对。黄色圆盘的边界是由 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(BAb\)</span> 生成的模群的极限集。</figcaption></figure><div class="statement simple plain unnumbered"><p>We worked out the labels of the boundary circles <span class="math inline">\(C_a, C_A, C_{BA}\)</span> and <span class="math inline">\(C_{Ba}\)</span> in Figure 7.8 of the four-sidedtile by going to part of the level-two Schottky chain for the gasketgroup. (You may find it easiest to check the arrangement in a picturelike the left frame of Figure 7.4 without all the extra gaskettangencies first.) Notice the four tangency points of these circles areall on the boundary of the yellow disk. As you can see, the four circlesform a new chain of tangent circles. As usual, <span class="math inline">\(a\)</span> pairs <span class="math inline">\(C_A\)</span> to <span class="math inline">\(C_a\)</span>. In addition, <span class="math inline">\(BAb\)</span> pairs <span class="math inline">\(C_{Ba}\)</span> to <span class="math inline">\(C_{BA}\)</span> because:</p><p><span class="math display">\[BAb\left(C_{Ba}\right) =BAb\left(B\left(C_a\right)\right) = BA\left(C_a\right) =B\left(C_A\right) = C_{BA}.\]</span></p><p>Inside the gasket group we have found another mini-chain of fourtangent circles, together with a pair of transformations which matchthem together in pairs!</p></div><p>我们通过研究垫片群的二级 Schottky 链的局部结构，确定了 <a href="#fig-7.8">图 7.8</a> 中四边形瓷砖的边界圆 <span class="math inline">\(C_a,C_A,C_{BA}\)</span> 和 <span class="math inline">\(C_{Ba}\)</span> 的标签。（建议首先参考 <a href="#fig-7.4">图 7.4</a>左图中圆的排列，暂时忽略所有额外的垫片切点，会更容易理解）。值得注意的是，这些圆的四个切点全部位于黄色圆盘的边界上。正如你所见，这四个圆形成了一个新的切圆链。按照惯例，变换<span class="math inline">\(a\)</span> 将圆 <span class="math inline">\(C_A\)</span> 和 <span class="math inline">\(C_a\)</span> 配对。此外，变换 <span class="math inline">\(BAb\)</span> 将圆 <span class="math inline">\(C_{Ba}\)</span> 和 <span class="math inline">\(C_{BA}\)</span> 配对，原因如下： <span class="math display">\[BAb\left(C_{Ba}\right) =BAb\left(B\left(C_a\right)\right) = BA\left(C_a\right) =B\left(C_A\right) = C_{BA}.\]</span>在垫片群中，我们发现了一个由四个相切圆组成的迷你链，以及一对将它们成对匹配的变换！</p><div class="statement simple plain unnumbered"><p>This construction shows that the modular group is a new kind of‘necklace group’, made by disregarding all the rest of the gasket andlooking only at the disks produced by acting with <span class="math inline">\(a\)</span> and <span class="math inline">\(BAb\)</span> on the four circles which bound thenew tile. The new group is generated by the transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(BAb\)</span>. Indeed in Figure 7.3, you canactually pick out chains of image disks nicely shrinking down onto theglowing limit circle through -1 and 0 . The only difference from thekissing Schottky groups we met in the last chapter is that the twogenerators pair not opposite circles but adjacent ones. As we shallexplain in more detail on p.&nbsp;213 ff., the image circles shrink because<span class="math inline">\(a,BAb\)</span> and their product <span class="math inline">\(aBAb\)</span> are all parabolic.</p></div><p>这一构造表明，模群是一种新型的“项链群”，它是通过忽略垫片的其余部分，仅关注由变换<span class="math inline">\(a\)</span> 和 <span class="math inline">\(BAb\)</span>作用于新瓷砖边界的四个圆所产生的圆盘而形成的。这个新群由变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(BAb\)</span> 生成。实际上，在 <a href="#fig-7.3">图 7.3</a>中，你可以清晰地看到一串映像圆盘，它们逐渐缩小并收敛到经过点 -1 和 0的发光极限圆上。这与上一章讨论的“接吻式 Schottky群”的唯一关键时，这两个生成元配对的不是相对的圆，而是相邻的圆。正如我们将在第213 页及以后章节中详细解释的那样，这些像圆之所以缩小，是因为 <span class="math inline">\(a,BAb\)</span> 以及它们的乘积 <span class="math inline">\(aBAb\)</span> 都是抛物型变换。</p><div class="statement simple plain unnumbered"><p>The same pattern of pairing circles is repeated all over the gasket.Every pink disk is the image of the yellow one under some element in thegasket group, which conjugates our modular group to another ‘modulargroup’ acting in the new disk. The white disks are different from thepink ones, because you can never get from pink to white usingtransformations in the gasket group. However you can still find a chainof four tangent circles matched in the same pattern, as described in <a href="#proj-7.4" title="Project 7.4">Project 7.4</a>.</p></div><p>在垫片的每一个局部区域，都能观察到完全相同的圆配对模式。每个粉色圆盘均可视为黄色圆盘经垫片群中某个变换作用后的像——这个变换元素会将我们原本的模群共轭到一个新的”模群”，而新模群将作用在对应的粉色圆盘上。白色圆盘与粉色圆盘存在本质区别：垫片群中的任意变换都无法将粉色圆盘映射为白色圆盘。不过，我们仍能找到四个相切圆构成的配对链，其模式与前文所述完全一致（具体构造方法详见项目7.4）。</p><div class="statement simple plain unnumbered"><p>You might well imagine that we should be set to repeat everything wedid in the last chapter. By taking four tangent circles and pairing themin this new pattern we should presumably get a whole new lot ofquasifuchsian groups. Not so! It turns out that the rigours imposed byspecifying that the two generators and their product are all parabolicactually ‘freeze’ the group. Without any mention of circle chains, weprove in Note 7.1 the remarkable fact that all groups made with pairingconditions like this are, up to conjugation, ‘the same’. What this meansin more detail is this. Suppose that <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are any two parabolic Möbiustransformations with the property that <span class="math inline">\(UV\)</span> is also parabolic, and such that thefixed points <span class="math inline">\({\rm Fix}\,U\)</span> and <span class="math inline">\({\rm Fix}\,V\)</span> of <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are not the same. Then there is alwaysa conjugating map <span class="math inline">\(M\)</span> such that:<span class="math display">\[MUM^{-1} = \begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix}, \quadMVM^{-1} = \begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}.\]</span> This explains why there are so many circles in the gasketgroup, and why you get an identical tiling pattern in each one.</p></div><p>你或许会以为，我们接下来要做的就是重复上一章的研究过程。毕竟，如果我们选取四个相切圆并按照这种新模式进行配对，似乎理所当然会得到一大堆新的拟富克斯群。然而并非如此！事实证明，要求两个生成元及其乘积都是抛物型变换这一刚性条件，实际上”冻结”了群的结构。在<a href="#note-7.1" title="注记 7.1">注记 7.1</a>中，我们甚至无需提及圆链的概念，就证明了这样一个惊人的结论：所有满足这种配对条件的群，在共轭意义下其实都是“相同”的。具体而言，设<span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 是任意两个抛物型莫比乌斯变换，满足<span class="math inline">\(UV\)</span> 仍为抛物型，且两者的不动点 <span class="math inline">\(\mathrm{Fix}\,U\)</span> 与 <span class="math inline">\(\mathrm{Fix}\,V\)</span>互异，那么，总存在一个共轭变换 <span class="math inline">\(M\)</span>，使得： <span class="math display">\[MUM^{-1} = \begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix}, \quadMVM^{-1} = \begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}.\]</span> 这也解释了为何在垫片群（gasketgroup）中会出现那么多的圆，以及为何每个圆内的镶嵌图案都一模一样。</p><div id="note-7.1" class="statement sta_note_7_1__uniqueness_of_the_modular_group definition unnumbered"><p><span class="statement-heading"><span class="statement-label">Note7.1: Uniqueness of the modular group</span>：</span><span class="statement-spah"> </span><br></p><p><strong>注 7.1：模群的唯一性</strong></p><p>Suppose that <span class="math inline">\(U\)</span>, <span class="math inline">\(V\)</span> and <span class="math inline">\(UV\)</span> are all parabolic (and therefore notthe identity!) and the fixed point of <span class="math inline">\(U\)</span> is <span class="math inline">\(z_U\)</span> and the fixed point of <span class="math inline">\(V\)</span> is <span class="math inline">\(z_V\)</span>. We are trying to conjugate <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> to the generators of the modular group.We have seen that we can find a Möbius transformation <span class="math inline">\(M\)</span> that maps <span class="math inline">\(z_U\)</span> to <span class="math inline">\(0\)</span> and <span class="math inline">\(z_V\)</span> to <span class="math inline">\(\infty\)</span>. Conjugating our originaltransformations <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> by <span class="math inline">\(M\)</span> arranges that <span class="math inline">\(MUM^{-1}(0)=0\)</span> and <span class="math inline">\(MVM^{-1}(\infty)=\infty\)</span>, and still thetwo transformations <span class="math inline">\(MUM^{-1}\)</span> and<span class="math inline">\(MVM^{-1}\)</span> are parabolic. Since wecan simultaneously conjugate them in this way, we may just as wellassume the original transformations <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> have fixed points <span class="math inline">\(0\)</span> and <span class="math inline">\(\infty\)</span>, respectively.</p><p>A parabolic transformation that fixes <span class="math inline">\(\infty\)</span> is always conjugate to any other,up to a minus sign. (See Chapter 3.) Let’s arrange by conjugation andpossibly multiplying by -1 that <span class="math inline">\(V\)</span>corresponds to the matrix <span class="math inline">\(\begin{pmatrix} 1&amp; 2 \\ 0 &amp; 1 \end{pmatrix}\)</span>.　Now all that’s left is<span class="math inline">\(U\)</span>. Since <span class="math inline">\(U(0)=0\)</span>, after again possibly multiplyingby -1, we can conclude that the matrix of <span class="math inline">\(U\)</span> is <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix}\]</span> for some number <span class="math inline">\(x\)</span>.</p><p>That brings us to the last hypothesis that <span class="math inline">\(UV\)</span> is parabolic. Let’s multiply thisout:</p><p><span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix} \begin{pmatrix} 1&amp; 2 \\ 0 &amp; 1 \end{pmatrix} = \begin{pmatrix} 1 &amp; 2 \\ x&amp; 1+2x \end{pmatrix}.\]</span></p><p>The trace of <span class="math inline">\(UV\)</span> under theseassumptions is <span class="math inline">\(2 + 2x\)</span>. This is<span class="math inline">\(\pm 2\)</span> for precisely two values of<span class="math inline">\(x\)</span>, namely, <span class="math inline">\(x = -2\)</span> and <span class="math inline">\(x= 0\)</span>. In the latter case, <span class="math inline">\(U\)</span>is the identity, which we are definitely excluding. That means <span class="math inline">\(x = -2\)</span>, and we have shown that <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> are simultaneously conjugate to <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix} \text{ and }\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}.\]</span> (We may have to multiply one or both matrices by -1 to arrangethat they both have trace 2.)</p><p>假设 <span class="math inline">\(U\)</span>, <span class="math inline">\(V\)</span> 和 <span class="math inline">\(UV\)</span>均为抛物型变换（因此不是恒等变换！），且 <span class="math inline">\(U\)</span> 的不动点是 <span class="math inline">\(z_U\)</span>，<span class="math inline">\(V\)</span> 的不动点是 <span class="math inline">\(z_V\)</span>。我们的目标是将 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span>共轭变换为模群的生成元。我们已经看到，可以找到一个莫比乌斯变换 <span class="math inline">\(M\)</span>，它将 <span class="math inline">\(z_U\)</span> 映射到 <span class="math inline">\(0\)</span>，<span class="math inline">\(z_V\)</span> 映射到 <span class="math inline">\(\infty\)</span>。通过 <span class="math inline">\(M\)</span> 对原变换 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 进行共轭后，新变换 <span class="math inline">\(MUM^{-1}\)</span> 将保持 0 不变，<span class="math inline">\(MVM^{-1}\)</span> 将保持 <span class="math inline">\(\infty\)</span>不变，且两者仍为抛物型变换。既然这种共轭可同步完成，我们不妨直接假设原变换<span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 的不动点分别是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>。</p><p>固定 <span class="math inline">\(\infty\)</span>的抛物型变换在相差一个符号的意义下彼此共轭（参见第 3章）。通过适当共轭及可能的符号调整，可以使 <span class="math inline">\(V\)</span> 对应于矩阵 <span class="math inline">\(\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1\end{pmatrix}\)</span>。此时仅需确定 <span class="math inline">\(U\)</span> 的形式。由于 <span class="math inline">\(U(0) = 0\)</span>，经可能的符号调整后，<span class="math inline">\(U\)</span> 的矩阵必为： <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix}\quad(x\in\mathbb{C}).\]</span> 最后利用 <span class="math inline">\(UV\)</span>是抛物型这一条件。计算乘积： <span class="math display">\[UV=\begin{pmatrix} 1 &amp; 0 \\ x &amp; 1 \end{pmatrix} \begin{pmatrix}1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix} = \begin{pmatrix} 1 &amp; 2 \\ x&amp; 1+2x \end{pmatrix}.\]</span> 此时 <span class="math inline">\(UV\)</span> 的迹是 <span class="math inline">\(2 + 2x\)</span>。抛物型变换的迹需满足 <span class="math inline">\(|\mathop{\mathrm{Tr}}|=2\)</span>，这恰好对 <span class="math inline">\(x\)</span> 的两个值成立，即 <span class="math inline">\(x = -2\)</span> 和 <span class="math inline">\(x =0\)</span>。当 <span class="math inline">\(x=0\)</span> 时，<span class="math inline">\(U\)</span> 退化为恒等变换（已排除），因此必有<span class="math inline">\(x=−2\)</span>。由此可知 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(V\)</span> 可共轭于矩阵： <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix} \text{ and }\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}\]</span> （必要时可对其中一个或两个矩阵取负，以确保其迹均为 2）</p></div><h1 id="the-modular-group-of-arithmetic">The modular group ofarithmetic</h1><div class="statement simple plain unnumbered"><p>The result just discussed shows that the modular group is conjugateto a very famous group of great importance in number theory. It is madeby arranging the four Schottky circles with their tangency points at<span class="math inline">\(-1,0,1\)</span> and <span class="math inline">\(\infty\)</span>. You can see these, coloured redand green, in the left frame of Figure 7.9. Since one of the tangencypoints is the point at infinity, two of the circles show up as greenvertical lines. These green lines are paired by <span class="math inline">\(b=\begin{pmatrix}1&amp;2\\0&amp;1\end{pmatrix}\)</span>,while the two red circles tangent at 0 are paired by <span class="math inline">\(a=\begin{pmatrix}1&amp;0\\-2&amp;1\end{pmatrix}\)</span>.Notice how <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> match adjacent circles in the chain inexactly the pattern of the red and green arrows in Figure 7.8. In fact,as you can easily calculate, <span class="math inline">\(ab\)</span> isthe parabolic transformation <span class="math inline">\(\begin{pmatrix}1&amp;2\\-2&amp;-3\end{pmatrix}\)</span>.</p></div><p>刚刚讨论的结果表明，模群与一个在数论中极为著名且重要的群是共轭的。这个群是通过排列四个肖特基圆生成的，其切点分别位于<span class="math inline">\(-1, 0, 1\)</span> 和 <span class="math inline">\(\infty\)</span>。在 <a href="#fig-7.9">图 7.9</a>的左图中，这些圆分别以红绿两色呈现。由于其中一个切点是无穷远点，因此有两个圆在图中呈现为绿色的垂直直线。这两条绿色直线由变换<span class="math inline">\(b=\begin{pmatrix}1&amp;2\\0&amp;1\end{pmatrix}\)</span>配对，而在原点 0 处相切的两个红色圆则通过变换 <span class="math inline">\(a=\begin{pmatrix}1&amp;0\\-2&amp;1\end{pmatrix}\)</span>配对。请注意，变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 对相邻圆的配对方式，恰好与 <a href="#fig-7.8">图 7.8</a>中红绿箭头所示的模式完全一致。事实上，通过简单的计算即可验证，<span class="math inline">\(ab\)</span> 是抛物型变换 <span class="math inline">\(\begin{pmatrix}1&amp;2\\-2&amp;-3\end{pmatrix}\)</span>。</p><figure id="fig-7.9"><img src="/images/indra/fig-7.9.jpg" width="600" alt="Figure 7.9. The modular tessellation of the upper half plane. The left frame shows the tiling or tessellation of the upper half plane by ideal triangles belonging to the smaller modular group coming from pairing tangent circles, while the right frame shows the richer tessellation associated to the full modular group with its added symmetries. Each tile on the left is subdivided into twelve tiles on the right. 图 7.9. 上半平面的模群密铺。左图展示了通过配对相切圆生成的子模群对应的理想三角形密铺结构；右图则展示具有完整模群对称性的更加精细的密铺。左侧的每个瓷砖在右侧被细分为十二个小瓷砖。"><figcaption aria-hidden="true">Figure 7.9. The modular tessellation ofthe upper half plane. The left frame shows the tiling or tessellation ofthe upper half plane by ideal triangles belonging to the smaller modulargroup coming from pairing tangent circles, while the right frame showsthe richer tessellation associated to the full modular group with itsadded symmetries. Each tile on the left is subdivided into twelve tileson the right.<br>图 7.9.上半平面的模群密铺。左图展示了通过配对相切圆生成的子模群对应的理想三角形密铺结构；右图则展示具有完整模群对称性的更加精细的密铺。左侧的每个瓷砖在右侧被细分为十二个小瓷砖。</figcaption></figure><div class="statement simple plain unnumbered"><p>It is no coincidence that the entries of these three matrices areintegers. The right frame of Figure 7.9 is a more complicated picturewhich shows all the symmetries of the tiling on the left. Each idealtriangle has been subdivided into three hatched and three unhatchedsub-triangles. (The sub-triangles are not quite ideal, because only oneof their angles is 0 .) The group of symmetries of this more complicatedtiling is, from the point of view of Möbius maps, the simplest group ofall: just the set of all <span class="math inline">\(2\times 2\)</span>matrices <span class="math inline">\(\begin{pmatrix}p&amp;q\\r&amp;s\end{pmatrix}\)</span>with integer entries <span class="math inline">\(p,q,r\)</span> and<span class="math inline">\(s\)</span> and determinant <span class="math inline">\(ps-qr\)</span> equal to 1. To distinguish from thegroup of the left frame, we sometimes call it the full modular group.The matrices in the (smaller) modular group of the left picture are justthose matrices with integer entries for which <span class="math inline">\(q\)</span> and <span class="math inline">\(r\)</span> are even and <span class="math inline">\(p\)</span> and <span class="math inline">\(s\)</span> are odd.</p></div><p>这三个矩阵的元素都是整数，此现象绝非偶然。<a href="#fig-7.9">图7.9</a>右侧的复杂图像完整呈现了左侧密铺图案的所有对称性。每个理想三角形都被剖分为三个阴影子三角形和三个非阴影子三角形。（这些子三角形并不完全是理想的，因为它们只有一个角为0）。从莫比乌斯变换的角度来看，这个更复杂的密铺结构的对称群是最简单的：即所有元素为整数且行列式<span class="math inline">\(ps-qr\)</span> 等于 1 的 <span class="math inline">\(2\times2\)</span> 矩阵 <span class="math inline">\(\begin{pmatrix}p&amp;q\\r&amp;s\end{pmatrix}\)</span>构成的集合。为了与左图的对称群区分开来，该群常被称为全模群。而左侧密铺对应的（较小）模群则由满足特殊同余条件的整数矩阵构成——其<span class="math inline">\(q\)</span> 与 <span class="math inline">\(r\)</span> 元素都是偶数，<span class="math inline">\(p\)</span> 与 <span class="math inline">\(s\)</span> 元素都是奇数。</p><div class="statement simple plain unnumbered"><p>There is a very beautiful connection between the modular tessellationand fractions: the points where the ideal triangles meet the real axisare exactly the rational numbers. Although it is something of adigression here, we want to take the time to explain the pattern, whichturns out to be indispensible when we come to map making in Chapter9.</p></div><p>模镶嵌与有理数之间有着极其美妙的联系：理想三角形与实轴交点恰恰是有理数。虽然这一内容在此略显偏离主题，但我们希望花些时间来阐明这个规律，因为它在第9 章的制图过程中将变得至关重要。</p><figure id="fig-7.10"><img src="/images/indra/fig-7.10.jpg" width="600" alt="Figure 7.10. The modular tiling from our ancestral home. The tessellation generated by the full modular group, conjugated over to the unit disk. This beautiful rendition is Figure 35 in Vol. 1 of Vorlesungen äber elliptischen Modulfunctionen by Klein and Fricke. 图 7.10. 来自我们老家的模密铺。这是一个由完整模群生成的镶嵌图案，经过共轭变换映射到单位圆盘上。这幅精美的图像出自克莱因与弗里克合著的《椭圆模函数讲义》第一卷中的第 35 图。"><figcaption aria-hidden="true">Figure 7.10. The modular tiling from ourancestral home. The tessellation generated by the full modular group,conjugated over to the unit disk. This beautiful rendition is Figure 35in Vol. 1 of Vorlesungen äber elliptischen Modulfunctionen by Klein andFricke.<br>图 7.10.来自我们老家的模密铺。这是一个由完整模群生成的镶嵌图案，经过共轭变换映射到单位圆盘上。这幅精美的图像出自克莱因与弗里克合著的《椭圆模函数讲义》第一卷中的第35 图。</figcaption></figure><div class="statement simple plain unnumbered"><p>Figure 7.11 shows the first few levels in the modular tessellation.The basic tile is the four-sided region, called an ideal quadrilateral,which was bounded by the coloured lines in Figure 7.9. Images of thisideal quadrilateral are shown bounded by solid arcs. The dotted arcsdivide them into the two ideal triangles which we saw, half hatched andhalf white, on the left in Figure 7.9. As the group acts on the basictile, we get more and more smaller and smaller tiles nesting down to thereal axis. The vertices of all these tiles meet the real axis in pointswhich are all fractions. Several things can be read off from a carefulexamination of this intricate pattern:</p><ul><li>All vertices of the tiles are rational numbers <span class="math inline">\(p/q\)</span>.</li><li>If <span class="math inline">\(r/s\)</span> and <span class="math inline">\(p/q\)</span> are two vertices of the same tile,then <span class="math inline">\(ps - rq = \pm 1\)</span>.</li><li>If <span class="math inline">\(r/s &lt; p/q\)</span> are the outertwo vertices of a tile, then the third vertex between them is <span class="math inline">\((r + p)/(s + q)\)</span>.</li></ul><p>Check this out! For instance, between <span class="math inline">\(2/3\)</span> and <span class="math inline">\(1/2\)</span>, we get <span class="math inline">\((2 + 1)/(3 + 2)\)</span>, that is <span class="math inline">\(3/5\)</span>.</p></div><p><a href="#fig-7.11">图 7.11</a>展示了模镶嵌的前几个层级。基本瓷砖是一个四边形，称为理想四边形，它由 <a href="#fig-7.9">图 7.9</a>中的彩色线条围成。实线弧显示了这个理想四边形的图像，而虚线弧将其分割成两个理想三角形，这两个三角形可以在<a href="#fig-7.9">图 7.9</a>的左侧看到，一半是阴影，一半是空白。随着群对基本瓷砖的作用，我们得到越来越多、越来越小的瓷砖，逐层嵌套，直至延伸到实轴。所有这些瓷砖的顶点都与实轴相交，这些交点都是分数。仔细观察这个复杂的图案，我们可以得出以下几个结论：</p><ul><li>所有瓷砖的顶点都是有理数 <span class="math inline">\(p/q\)</span>。</li><li>如果 <span class="math inline">\(r/s\)</span> 和 <span class="math inline">\(p/q\)</span> 是同一瓷砖的两个顶点，则 <span class="math inline">\(ps - rq = \pm 1\)</span>。</li><li>如果 <span class="math inline">\(r/s &lt; p/q\)</span>是同一瓷砖的两个外顶点，那么它们之间的第三个顶点是 <span class="math inline">\((r + p)/(s + q)\)</span>。</li></ul><p>验证一下吧！比如，在 <span class="math inline">\(2/3\)</span> 和<span class="math inline">\(1/2\)</span> 之间，我们得到 <span class="math inline">\((2 + 1)/(3 + 2)\)</span>，即 <span class="math inline">\(3/5\)</span>。</p><div class="statement simple plain unnumbered"><p>It’s easy to see why this happens. As we have seen, a typical matrixin the modular group will look like</p><p><span class="math display">\[M = \begin{pmatrix} p &amp; q \\ r &amp;s \end{pmatrix}\]</span></p><p>where <span class="math inline">\(p, q, r\)</span> and <span class="math inline">\(s\)</span> are integers and <span class="math inline">\(ps - rq = 1\)</span>. If <span class="math inline">\(M\)</span> acts on the vertices of the initialtriangle with vertices <span class="math inline">\(0 = 0/1, 1 =1/1\)</span> and <span class="math inline">\(\infty = 1/0\)</span>, thenwe get the new triangle with vertices <span class="math inline">\(M(0) =r/s, M(\infty) = p/q\)</span> and <span class="math inline">\(M(1) = (p+ r)/(q + s)\)</span>. Assuming all four entries are positive, we have<span class="math inline">\(r/s &lt; (p + r)/(q + s) &lt; p/q\)</span>(you can see this by multiplying out). This is just what we found inFigure 7.11. If <span class="math inline">\(p, q, r, s\)</span> are notall positive, there are half a dozen other cases in which the order ofthe points <span class="math inline">\(M(0), M(1)\)</span> and <span class="math inline">\(M(\infty)\)</span> is different but we get thesame result. The same thing happens if we start from the other triangle<span class="math inline">\(M(-1), M(0), M(\infty)\)</span>.</p></div><p>这个现象不难理解。我们知道，模群中的一个典型矩阵可以表示为 <span class="math display">\[M = \begin{pmatrix} p &amp; q \\ r &amp; s\end{pmatrix},\]</span> 其中 <span class="math inline">\(p, q,r\)</span> 和 <span class="math inline">\(s\)</span> 是整数，且满足<span class="math inline">\(ps - rq = 1\)</span>。如果矩阵 <span class="math inline">\(M\)</span>作用于初始三角形的顶点，该初始三角形的顶点分别是 <span class="math inline">\(0 = 0/1, 1 = 1/1\)</span> 和 <span class="math inline">\(\infty =1/0\)</span>，那么变换后的新三角形的顶点将变成 <span class="math inline">\(M(0) = r/s, M(\infty) = p/q\)</span> 和 <span class="math inline">\(M(1) = (p + r)/(q + s)\)</span>。假设 <span class="math inline">\(p,q,r,s\)</span> 都是正数，我们可以验证不等式<span class="math inline">\(r/s &lt; (p + r)/(q + s) &lt; p/q\)</span>成立（通过乘法可轻松验证）。这正是 <a href="#fig-7.11">图 7.11</a>所示的情况。如果 <span class="math inline">\(p, q, r, s\)</span>并非全为正数，还有几种不同的情形，此时点 <span class="math inline">\(M(0), M(1), M(\infty)\)</span>的顺序可能会改变，但结果仍然一致。类似地，若从另一个三角形 <span class="math inline">\(M(-1), M(0), M(\infty)\)</span>出发，也会得到相同的结论。</p><div class="statement simple plain unnumbered"><p>Any two fractions <span class="math inline">\(r/s\)</span> and <span class="math inline">\(p/q\)</span> such that <span class="math inline">\(ps - qr = \pm 1\)</span> are called neighbours.Thus any two vertices of an ideal triangle in the modular tessellationare neighbours. If <span class="math inline">\(p/q\)</span> is afraction, then, as we explain in Project 7.5, the process of finding itsneighbours is essentially Euclid’s two thousand year old algorithm forfinding the highest common factor of two numbers, surely one of the mostuseful and clever algorithms of all time. The rule for finding the‘next’ point <span class="math inline">\(\frac{p+r}{q+s}\)</span>between two neighbours is every student’s dream of what addition offractions should be. This simple form of fraction ‘addition’ issometimes called Farey addition’, which one might want to symbolise witha funny symbol like:</p><p><span class="math display">\[\frac{p}{q} \oplus \frac{r}{s} = \frac{p + r}{q + s}\]</span></p><p>Farey addition gives a neat way of organising the rational numbers.Instead of the usual way of arranging them in increasing order (which isdifficult, because you never know which one should come ‘next’),fractions can be described by a sequence of left or right moves,reflecting the choice at each stage of whether we choose the new pair ofneighbours to the right, or the pair of neighbours to the left.</p></div><p>任何两个分数 <span class="math inline">\(r/s\)</span> 和 <span class="math inline">\(p/q\)</span>，若满足 <span class="math inline">\(ps - qr = \pm1\)</span>，则称它们为邻居。因此，模群镶嵌中的理想三角形的任意两个顶点都是邻居。如果<span class="math inline">\(p/q\)</span> 是一个分数，那么正如我们在项目7.5中所解释的那样，寻找其邻居的过程，本质上就是欧几里得两千年前发明的最大公约数算法——这无疑是人类历史上最实用、最巧妙的算法之一。计算两个邻居之间“下一个”点<span class="math inline">\(\frac{p+r}{q+s}\)</span>的规则，正是每个学生心目中理想的分数加法方式。这种简单的分数“加法”有时被称为“法雷加法”（Fareyaddition），人们或许会用一个有趣的符号来表示它，比如： <span class="math display">\[\frac{p}{q} \oplus \frac{r}{s} = \frac{p + r}{q + s}\]</span></p><p>法雷加法提供了一种巧妙的方式来组织有理数。不像按递增顺序排列那样麻烦（毕竟你很难确定下一个该是谁），分数可以通过一系列左移或右移的操作来描述，这正对应了我们在每一步中选择将新的邻居对放置在左边还是右边的决定。</p><div class="statement simple plain unnumbered"><p>For positive fractions, the starting point are the two fractions<span class="math inline">\(0/1\)</span> and <span class="math inline">\(1/0\)</span>, which we can regard as specialhonourary neighbours because they are connected by a side of our initialtriangle, the vertical imaginary axis. Farey addition gives thein-between fraction <span class="math inline">\(0/1\oplus1/0=1/1\)</span>.</p><p>Now we have a choice: go to the ‘left’ and look in the intervalbetween 0 and 1, or go to the ‘right’ and look in the interval between 1and <span class="math inline">\(\infty\)</span>. Suppose we are aimingfor the fraction <span class="math inline">\(3/5\)</span>. Then we turnto the left and apply the Farey addition <span class="math inline">\(0/1\oplus 1/1 = 1/2\)</span>. At the next stage, we choose the rightinterval and Farey add to get <span class="math inline">\(1/2 \oplus 1/1= 2/3\)</span>. Finally, we choose the left interval and Farey add <span class="math inline">\(1/2 \oplus 2/3 = 3/5\)</span>. An exactly similarprocedure could be applied to home in on any fraction <span class="math inline">\(p/q\)</span>. Our choice of left-right turns is adriving map: <span class="math inline">\(3/5\)</span> is given by theinstructions ‘left, right, left’. This arrangement of fractions andsequence of right-left moves is closely related to a way of writingfractions as what are called continued fractions, explained in Note7.2.</p></div><p>对于正分数，我们的起点是两个特殊的分数：<span class="math inline">\(0/1\)</span> 和 <span class="math inline">\(1/0\)</span>。我们不妨将它们视作“荣誉邻居”，因为它们由初始三角形的一条边——垂直的虚轴——连接在一起。利用Farey 加法，我们可以在它们之间找到一个中间分数：<span class="math inline">\(0/1 \oplus 1/0 = 1/1\)</span>。</p><p>接下来，我们需要做出选择：向“左”走，查看 0 到 1之间的区间；还是向“右”走，查看 1 到 <span class="math inline">\(\infty\)</span> 之间的区间。假设我们的目标是分数<span class="math inline">\(3/5\)</span>。那么我们选择向左，执行 Farey加法：<span class="math inline">\(0/1 \oplus 1/1 =1/2\)</span>。在下一步，我们转向右侧区间，并执行 Farey 加法得到：<span class="math inline">\(1/2 \oplus 1/1 =2/3\)</span>。最后，我们再次选择左侧区间，进行 Farey 加法：<span class="math inline">\(1/2 \oplus 2/3 = 3/5\)</span>。</p><p>通过完全相同的步骤，我们可以找到任意分数 <span class="math inline">\(p/q\)</span>。我们每次选择向左或向右的决策就像一张“导航图”：例如，分数<span class="math inline">\(3/5\)</span>对应的指令是“左、右、左”。这种分数的排列方式和左右转向的序列，与将分数表示为连分数的写法密切相关，详见<a href="#note-7.2" title="注记 7.2">注记 7.2</a>。</p><div id="note-7.2" class="statement sta_note_7_2__continued_fractions definition unnumbered"><p><span class="statement-heading"><span class="statement-label">Note7.2: Continued fractions</span>：</span><span class="statement-spah"></span><strong>注记 7.2 连分数</strong></p><p>Expressions like <span class="math display">\[\frac{3}{10} =\frac{1}{3 + \frac{1}{3}}\]</span> and <span class="math display">\[\frac{2}{19} = \frac{1}{2 + \frac{1}{9}}\]</span>are called continued fractions. It turns out that every fraction <span class="math inline">\(p/q\)</span> can be written in a similar way.Assuming <span class="math inline">\(p/q\)</span> is between 0 and 1,then you can always write it in the form <span class="math display">\[\frac{p}{q} = \frac{1}{a + \frac{1}{b +\frac{1}{c + \frac{1}{\cdots}}}}\]</span> where <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>and so on are positive integers. Actually you can do the same even foran irrational number. The difference is that if the original number isirrational, then the terms <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>and so on continue without end. The sequence <span class="math inline">\(a, b, c, \ldots\)</span> always describes thenumber of left-right turns in the Farey algorithm we described in thetext.</p><p>If we successively ‘reduce’ a continued fraction by decreasing itsfinal entry by 1, down to the value 1, and then shrinking its length, werecover the Farey process for homing in on the fraction. For example,for the fraction <span class="math inline">\(3/5\)</span>, we get: <span class="math display">\[\begin{aligned}\frac{3}{5} &amp;= \frac{1}{2 + \frac{1}{2 + \frac{1}{2}}}\\\frac{2}{5} &amp;= \frac{1}{2 + \frac{1}{2 + \frac{1}{2}}}\\\frac{1}{3} &amp;= \frac{1}{2 + \frac{1}{1}}\\\frac{1}{2} &amp;= \frac{1}{2}.\end{aligned}\]</span> The process of turning a fraction into a continued fraction isvery closely related to Euclid’s algorithm. We give some hints inProject 7.5.</p><p>像下面这样的表达式 <span class="math display">\[\frac{3}{10} =\frac{1}{3 + \frac{1}{3}}\]</span> 和 <span class="math display">\[\frac{2}{19} = \frac{1}{2 + \frac{1}{9}}\]</span>被称为连分数。事实上，任何分数 <span class="math inline">\(p/q\)</span>都可以以类似的方式表示。假设 <span class="math inline">\(p/q\)</span>介于 0 与 1 之间，那么你总能将其写成如下的形式</p><p><span class="math display">\[\frac{p}{q} = \frac{1}{a + \frac{1}{b +\frac{1}{c + \frac{1}{\cdots}}}}\]</span> 其中 <span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>，<span class="math inline">\(c\)</span>等是正整数。实际上，即使是无理数，你也可以用同样的方式表示。区别在于，如果原始数字是无理数，那么项<span class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>，<span class="math inline">\(c\)</span>等将无限延续下去。序列 <span class="math inline">\(a, b, c,\ldots\)</span> 始终对应于我们在正文中提到的 Farey算法中的左右转弯次数。</p><p>如果我们通过将连分数的最后一项逐步减 1，直到其值为1，然后缩短其长度，连续地“简化”一个连分数，我们就能恢复用于逼近该分数的Farey 过程。以分数 <span class="math inline">\(3/5\)</span>为例，经过这一过程，我们得到：</p><p><span class="math display">\[\begin{aligned}\frac{3}{5} &amp;= \frac{1}{2 + \frac{1}{2 + \frac{1}{2}}}\\\frac{2}{5} &amp;= \frac{1}{2 + \frac{1}{2 + \frac{1}{2}}}\\\frac{1}{3} &amp;= \frac{1}{2 + \frac{1}{1}}\\\frac{1}{2} &amp;= \frac{1}{2}.\end{aligned}\]</span></p><p>将一个分数转换成连分数的过程与欧几里得算法密切相关。我们在项目 7.5中提供了一些线索。</p></div><h1 id="the-pairing-pattern-of-the-modular-group">The pairing pattern ofthe modular group</h1><div class="statement simple plain unnumbered"><p>The modular group is a new kind of ‘necklace group’. It is still madeby pairing four tangent circles, and the only difference from thekissing Schottky groups we met in the last chapter is that thegenerators pair not opposite circles but adjacent ones. Whenever we havean arrangement of paired tangent circles like this, something like thenecklace condition on p.&nbsp;168 must still be true, but because we arepairing the circles in a different pattern, we can expect that differentelements must be parabolic to cause the image circles to shrink.</p></div><p>模群是一种新型的“项链群”。它同样由四个相切的圆配对构成，不同之处在于，生成元这次配对的不是相对的圆，而是相邻的圆。每当我们遇到这样的相切圆配对排列时，类似于第168页提到的“项链条件”仍然必须成立。不过，由于这次采用了不同的配对模式，我们可以预见，只有某些不同的元素变成抛物型时，像圆才会缩小。</p><div class="statement simple plain unnumbered"><p>With the notation of the figure beside Box 20, we have <span class="math inline">\(a(P) = R\)</span> and <span class="math inline">\(b(R) = P\)</span>, so that the four tangencypoints of the circles are <span class="math inline">\(S =\text{Fix}(a)\)</span>, <span class="math inline">\(Q =\text{Fix}(b)\)</span>, <span class="math inline">\(P =\text{Fix}(ba)\)</span>, and <span class="math inline">\(R =\text{Fix}(ab)\)</span>. By similar reasoning to that in Chapter 6, inorder for the image circles near <span class="math inline">\(S\)</span>and <span class="math inline">\(Q\)</span> to shrink, the generators<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> must be parabolic. Moreover, <span class="math inline">\(ba\)</span> must also be parabolic, to make thecircles shrink at <span class="math inline">\(P\)</span>. Notice that<span class="math inline">\(ab\)</span> and <span class="math inline">\(ba\)</span> are conjugate (since <span class="math inline">\(b(ab)b^{-1} = ba\)</span>), so saying that <span class="math inline">\(ab\)</span> or <span class="math inline">\(ba\)</span> must be parabolic is really one andthe same thing. The wonderful thing is, that as we proved in Note 7.1,all groups with these three elements parabolic are automaticallyconjugate. This is so important to us that we summarize it in Box20.</p></div><p>根据 <a href="#box20" title="框 20">框 20</a> 旁的图示，我们有 <span class="math inline">\(a(P) = R\)</span> 且 <span class="math inline">\(b(R) = P\)</span>，因此四个切点分别是：<span class="math inline">\(S＝\mathrm{Fix}\,(a)\)</span>, <span class="math inline">\(Q =\mathrm{Fix}\,(b)\)</span>, <span class="math inline">\(P =\mathrm{Fix}\,(ba)\)</span> 和 <span class="math inline">\(R=\mathrm{Fix}\,(ab)\)</span>。类似于第 6章的推理，为使靠近 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(Q\)</span> 的像圆收缩，生成元 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 必须是抛物型变换。而且 <span class="math inline">\(ba\)</span> 也必须是抛物型的，以确保圆在 <span class="math inline">\(P\)</span> 处收缩。需要注意的是，<span class="math inline">\(ab\)</span> 和 <span class="math inline">\(ba\)</span> 是共轭的（因为 <span class="math inline">\(b(ab)b^{-1} = ba\)</span>），所以要求 <span class="math inline">\(ab\)</span> 或 <span class="math inline">\(ba\)</span>是抛物型本质上是一回事。奇妙的是，正如我们在 <a href="#note-7.1" title="注记 7.1">注记 7.1</a>中所证明的，所有包含这三个抛物型元素的群自动共轭。这一点对我们来说非常重要，因此我们在<a href="#box20" title="框 20">框 20</a> 中专门进行了总结。</p><div class="statement simple plain unnumbered"><p>Because the pattern of pairing circles is different, so is thearrangement in which the labelled circles are laid down in the plane.The Schottky circles in Figure 7.11 are labelled according to our usualrules, so for example, <span class="math inline">\(C_{ba}\)</span> stillmeans the image of circle <span class="math inline">\(C_a\)</span> underthe map <span class="math inline">\(b\)</span>. However, if you lookcarefully, you will see that the order of the circles along the line isnot the same as our original order round the boundary of the word treeon p.&nbsp;104. The labels can be read off in their correct order from therevised version in Figure 7.12. (To see this you will have to twiddlethe diagram around so the arrows from the vertex you are interested inare pointing ‘down’ rather than ‘up’.) There is a subtle difference fromour original word tree, because there the cyclic order round a vertexwas <span class="math inline">\(a,B,A,b\)</span> while now it is <span class="math inline">\(a,A,b,B\)</span>. The ramifications of thisseemingly minor change propagate down the tree.</p></div><p>由于圆的配对方式改变，标记圆在平面上的排列方式也随之改变。<a href="#fig-7.11">图 7.11</a> 中的 Schottky圆仍按照我们通常的规则标记，例如，<span class="math inline">\(C_{ba}\)</span> 依然表示圆 <span class="math inline">\(C_a\)</span> 在映射 <span class="math inline">\(b\)</span>下的像。然而，如果你仔细观察，就会发现这些圆沿着直线的排列顺序与第 104页单词树边界上的原始顺序不同。修订后的 <a href="#fig-7.12">图 7.12</a>显示了正确的标签顺序。（为了看清这一点，你需要稍微调整图形，使得你关注的顶点的箭头指向“下方”而非“上方”）。与原单词树相比，这里有一个微妙的差异，源于顶点周围的循环顺序变化：原单词树中的顺序是<span class="math inline">\(a, B, A, b\)</span>，而现在则是 <span class="math inline">\(a, A, b,B\)</span>。这一看似微小的变化将沿树结构逐级向下传播。</p><div id="box20" class="statement sta_box_20__the_modular_necklace plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Box 20.The modular necklace</span>.</span><span class="statement-spah"></span><strong>盒子 20：模群项链</strong></p><p><img src="/images/indra/box20.jpg" class="fig" width="200"></p><p>A modular necklace is a tangent chain of four circles in whichadjacent disks are paired by two transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> as in the figure in the margin. Thetransformations <span class="math inline">\(a, b\)</span> and <span class="math inline">\(ab\)</span> are all parabolic and <span class="math inline">\(S = Fix(a), Q = Fix(fc), a(P) = K, b(R) =P\)</span> so that <span class="math inline">\(P =\mathrm{Fix}\,(ba)\)</span> and <span class="math inline">\(R =\mathrm{Fix}\,(ab)\)</span>. The group generated by <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> is always conjugate to the ‘standard’modular group generated by <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix} \text{ and }\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}\]</span></p><p>The four points <span class="math inline">\(P, Q, R\)</span> and<span class="math inline">\(S\)</span> always lie on a circle (or line)which is the limit set of the group. The limit circle is perpendicularto all circles in the chain. Both inner and outer tiles have their sidesmatched in the same way and the surfaces made by gluing up these tilesare each spheres with three punctures or cusps.</p><p>一个模群项链是由四个相切的圆组成的链条，其中相邻的圆盘通过两种变换<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 配对，正如旁边图中的所示。变换 <span class="math inline">\(a\)</span>、<span class="math inline">\(b\)</span>和 <span class="math inline">\(ab\)</span> 都是抛物型的，且有 <span class="math inline">\(S=\mathrm{Fix}\,(a)\)</span>, <span class="math inline">\(Q = \mathrm{Fix}\,(b)\)</span>, <span class="math inline">\(a(P) = R\)</span>, <span class="math inline">\(b(R) = P\)</span>，从而得到 <span class="math inline">\(P = \mathrm{Fix}\,(ba)\)</span> 和 <span class="math inline">\(R = \mathrm{Fix}\,(ab)\)</span>。由 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 生成的群总是与由 <span class="math display">\[\begin{pmatrix} 1 &amp; 0 \\ -2 &amp; 1 \end{pmatrix} \text{ and }\begin{pmatrix} 1 &amp; 2 \\ 0 &amp; 1 \end{pmatrix}\]</span> 生成的“标准”模群共轭。</p><p>四个点 <span class="math inline">\(P,Q,R,S\)</span>总是位于一个圆（或直线）上，这个圆（或直线）是该群的极限集。极限圆与链条中的所有圆都垂直。无论是内层还是外层的瓷砖，它们的边缘都以相同的方式匹配，通过将这些瓷砖拼接在一起形成的曲面，都是具有三个孔或尖点的球面。</p></div><figure id="fig-7.12"><img src="/images/indra/fig-7.12.jpg" width="600" alt="Figure 7.12. The tree of words rearranged in the pattern of the modular group. 图 7.12. 以模群模式重新排列的词汇树。"><figcaption aria-hidden="true">Figure 7.12. The tree of words rearrangedin the pattern of the modular group.<br>图 7.12. 以模群模式重新排列的词汇树。</figcaption></figure><div class="statement simple plain unnumbered"><p>Because some elements in the modular group are parabolic, theinfinite endpoints of certain paths down the word tree merge. Forexample, the path which starts at <span class="math inline">\(a\)</span>and heads always as far as possible to the left (from the viewpoint of aperson walking down the branch) is <span class="math inline">\(aaa\cdots\)</span>, ending at the attracting fixedpoint <span class="math inline">\({\rm Fix}^+a\)</span>. On the otherhand, starting from <span class="math inline">\(A\)</span> and alwaysturning right gives the path <span class="math inline">\(AAA\cdots\)</span>, ending at <span class="math inline">\({\rm Fix}^+A\)</span>. Since <span class="math inline">\(a\)</span> is parabolic, the end points of thesetwo paths are the same. In a similar way, other coincidences ofendpoints are caused by the merging of the fixed points of <span class="math inline">\(b\)</span> and <span class="math inline">\(ab\)</span>. You should compare the details withFigure 6.13.</p></div><p>由于模群中存在抛物型元素，这导致单词树中某些路径的无限端点会发生合并。例如，从<span class="math inline">\(a\)</span>出发并始终尽可能向左延伸的路径（从沿分支下行的视角来看）可表示为 <span class="math inline">\(aaa\cdots\)</span>，最终到达 <span class="math inline">\(a\)</span> 的吸引不动点 <span class="math inline">\(\mathrm{Fix}\,^+a\)</span>。反之，从 <span class="math inline">\(A\)</span> 出发始终右转的路径则为 <span class="math inline">\(AAA\cdots\)</span>，终止于 <span class="math inline">\(\mathrm{Fix}\,^+A\)</span>。由于 <span class="math inline">\(a\)</span>是抛物型元素，这两条路径的终点完全重合。类似地，<span class="math inline">\(b\)</span> 与 <span class="math inline">\(ab\)</span>的不动点合并也会导致其他端点重合的现象。建议读者将这些细节与 <a href="#fig-6.13">图 6.13</a> 进行对照分析。</p><div class="statement simple plain unnumbered"><p>A similar phenomenon is repeated at all levels. For example, theextreme left and extreme right paths starting at <span class="math inline">\(aB\)</span> end at <span class="math inline">\(aB\bar{a}=\mathrm{Fix}\,aBabA\)</span>, and <span class="math inline">\(aB\bar{A} = \mathrm{Fix}\,aBAbA\)</span>. Noticethat <span class="math inline">\((aBAbA)^{-1}=aBabA\)</span> and that<span class="math inline">\(aBabA\)</span> must be parabolic because itcan be written <span class="math inline">\((aB)a(aB)^{-1}\)</span>, sothe two endpoints merge. Every tangency point of the many circles inFigure 7.9 comes about because of a similar conjugacy to one of thethree basic parabolics <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> or <span class="math inline">\(ab\)</span>.</p></div><p>类似的现象在各个层次上反复出现。例如，从 <span class="math inline">\(aB\)</span> 出发的极左和极右路径分别终止于 <span class="math inline">\(aB\bar{a} = \mathrm{Fix}\,^+ aBabA\)</span> 和<span class="math inline">\(aB\bar{A} =\mathrm{Fix}\,^+aBAbA\)</span>。注意，<span class="math inline">\((aBAbA)^{-1} = aBabA\)</span>，而且 <span class="math inline">\(aBabA\)</span> 必然是抛物型的，因为它可以写成<span class="math inline">\((aB)a(aB)^{-1}\)</span>，因此这两个端点最终重合。<a href="#fig-7.9">图 7.9</a>中众多圆的切点的出现，本质上都源于群元素与三个基本抛物元 <span class="math inline">\(a\)</span>、<span class="math inline">\(b\)</span>或 <span class="math inline">\(ab\)</span> 之一类似的共轭关系。</p><div class="statement simple plain unnumbered"><p>Let’s mention one final difference from the kissing Schottky groupsin Chapter 6. The chain of four initial circles still divides theRiemann sphere into two four-sided tiles. However, because the pairingis different, so is the result of glueing up the tiles. Dr.&nbsp;Stickler ispuzzling this out in Figure 7.13. In contrast to the pair ofonce-punctured tori we got in Figure 6.16, the outcome is now a pair oftriply-punctured spheres.</p></div><p>让我们提到与第 6 章中亲吻 Schottky群的最后一个不同之处。四个最初的圆依然将黎曼球面划分为两个四边形瓷砖。然而，由于配对方式的不同，拼接后的结果也发生了变化。Stickler博士正在 <a href="#fig-7.13">图 7.13</a> 中对此进行思考。与我们在 <a href="#fig-6.16">图 6.16</a>中得到的那一对单孔环面相比，这次的结果是两个三孔球面。</p><figure id="fig-7.13"><img src="/images/indra/fig-7.13.png" width="600" alt="Figure 7.13. The gluing construction for the modular group. We start from a chain of four kissing circles giving a tile with two pieces, each a rectangle with four cusps. After gluing according to the modular recipe, we get two spheres, each with three cuspidal ‘punctures’ where they are joined. 图 7.13. 模群的粘合构造。我们从一串四个相切的圆开始，得到一个由两块矩形瓷砖组成的图案，每块瓷砖上都有四个尖点。按照模群的粘合法则将这些部分粘合后，最终得到两个球面，每个球面上都有三个尖点状的“穿孔”，它们通过这些穿孔相连。"><figcaption aria-hidden="true">Figure 7.13. The gluing construction forthe modular group. We start from a chain of four kissing circles givinga tile with two pieces, each a rectangle with four cusps. After gluingaccording to the modular recipe, we get two spheres, each with threecuspidal ‘punctures’ where they are joined.<br>图 7.13.模群的粘合构造。我们从一串四个相切的圆开始，得到一个由两块矩形瓷砖组成的图案，每块瓷砖上都有四个尖点。按照模群的粘合法则将这些部分粘合后，最终得到两个球面，每个球面上都有三个尖点状的“穿孔”，它们通过这些穿孔相连。</figcaption></figure><h1 id="the-problem-of-gaps">The problem of gaps</h1><figure id="fig-7.14"><img src="/images/indra/fig-7.14.jpg" width="500" alt="Figure 7.14. The gaps in the gasket. 图 7.14. 垫片中的缝隙。"><figcaption aria-hidden="true">Figure 7.14. The gaps in the gasket. 图7.14. 垫片中的缝隙。</figcaption></figure><div class="statement simple plain unnumbered"><p>We end this chapter by returning to the gasket and programming, withthe confession that we cheated slightly to make pictures like Figures7.1 and 7.4. Figure 7.14 shows the same picture plotted with our currentalgorithm. It contains a slight but thoroughly annoying imperfection ifyou look closely, you will see that at many places where we allege thelimit set is ‘pinched’, it does not actually quite meet itself, butcontains what are in reality quite large gaps.</p></div><p>本章的结尾，我们再次回到垫片和编程的话题，并坦白在绘制 <a href="#fig-7.1">图 7.1</a> 和 <a href="#fig-7.4">图 7.4</a>这类图像时，我们稍微做了一点“取巧”。<a href="#fig-7.14">图 7.14</a>展示的是使用我们当前算法绘制的同一图像。仔细观察的话，你会发现它存在一个微小但颇为恼人的缺陷：在许多地方，我们宣称极限集已经“收缩”的地方，实际上并没有完全闭合，反而留下一些肉眼可见的较大空隙。</p><div class="statement simple plain unnumbered"><p>Gaps and other imperfections in scientific pictures are a commonnuisance, but they sometimes have greater significance. Mandelbrotrecounted that his first detailed pictures of what later came to beknown as the Mandelbrot set seemed to be plagued by specks of dirt. Heand his assistant made a complete inspection of their program, computersystem and printer, only to find that the specks were indeed correct.Investigating the specks led to the discovery of the vast andcomplicated spider web of filaments connecting all the various parts ofthat stunningly beautiful and now famous icon of the fractal world.</p></div><p>科学图像中的空隙和其他瑕疵往往令人烦恼，但有时它们却蕴藏着更深的含义。曼德勃罗回忆道，他第一次绘制的、后来被称为曼德勃罗集的精细图像，总是被一些看似污点的斑点困扰。于是，他和助手对程序、计算机系统和打印机进行了彻底检查，结果发现这些斑点竟然是正确的。深入探究这些斑点，他们最终发现了一个复杂而庞大的蜘蛛网般的细丝结构，连接着曼德勃罗集各个部分，揭示了这个令人震撼、现已声名赫赫的分形世界象征的奇妙之处。</p><div class="statement simple plain unnumbered"><p>What is happening in the present case is that our algorithm developstremendous inertia as it approaches the fixed points of parabolic ornearly parabolic words. It’s as if it starts to run in slow motion,simply not having the energy to go all the way out to the end. For thisparticular picture, the plotting threshold was a reasonably small 0.005and the word length crept up to more than 400 as the plot approached thegaps. Still the visible gaps are substantially larger than 0.005.</p></div><p>在这个例子中，我们的算法在接近抛物型或近似抛物型词的固定点时，表现出极大的惯性。就像是进入了慢动作，似乎完全没有足够的能量继续前进，无法走到最后。对于这幅特定的图像，绘图的阈值被设置得相当小，仅为0.005，而随着绘图接近空隙，词的长度悄然增加到了超过400。然而，尽管如此，空隙的大小依然明显超过了 0.005。</p><div class="statement simple plain unnumbered"><p>We could make better plots if we modified the algorithm to takeaccount of the fact that the words <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are parabolic. The basic idea is thatwe should plot not only points with repetends which are cyclicpermutations of the basic commutator abAB (itself parabolic), but inaddition those whose repetends are any of <span class="math inline">\(a,A, b\)</span> or <span class="math inline">\(B\)</span>. Pictures likeFigure 7.4, plotted with the new algorithm, are the measure of oursuccess.</p></div><p>如果我们修改算法，使其考虑到单词 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>是抛物型的这一特点，就能绘制出更精确的图形。基本思路是，我们不仅要绘制那些循环节为基本换位子<span class="math inline">\(abAB\)</span>（本身是抛物型）及其循环排列的点，还要包括那些循环节为<span class="math inline">\(a, A, b\)</span> 或 <span class="math inline">\(B\)</span> 的点。采用新算法绘制的图像。比如 <a href="#fig-7.4">图 7.4</a>，正是我们取得成功的标志。</p><div class="statement simple plain unnumbered"><p>Here is a more detailed look at the modified algorithm. We start bytelling the program that the three parabolic elements <span class="math inline">\(a, b\)</span> and <span class="math inline">\(abAB\)</span> are ‘special’. For each generator,the program then determines the repetends it must consider whenenumerating the infinite words. They are listed in Note 7.3.</p></div><p>下面是对修改后算法的更详细说明。首先，我们告诉程序，三个抛物型元素<span class="math inline">\(a\)</span>、<span class="math inline">\(b\)</span> 和 <span class="math inline">\(abAB\)</span>是“特殊的”。接下来，程序会为每个生成元确定在枚举无限词时需要考虑的循环节。这些循环节列在<a href="#note-7.3" title="注记 7.3">注记 7.3</a> 中。</p><div class="statement simple plain unnumbered"><p>This chart is used in the following way. Suppose we are considering aword w which ends with the tag <code>gens[l] = a</code>, for example<span class="math inline">\(w = BABaa\)</span>. We are trying to plotthe part of the limit set corresponding to words with prefix <span class="math inline">\(w\)</span>, so we want to look at those placeswhere this segment of the limit curve unexpectedly gets stretched out.This section of limit set, the <span class="math inline">\(w\)</span>-section as we may call it, consists ofpoints corresponding to all the infinite words between <span class="math inline">\(w\overline{bABa}\)</span> and <span class="math inline">\(w\overline{BAba}\)</span>.</p></div><p>该图表的使用方法如下。假设我们正在考虑一个以标签<code>gens[l] = a</code> 结尾的单词，比如 <span class="math inline">\(w= BABaa\)</span>。我们希望绘制极限集中的一部分，这部分对应的是以 <span class="math inline">\(w\)</span>为前缀的所有单词。因此，我们关注的是极限曲线中该段意外被拉伸的位置。这一段极限集，我们可以称之为<span class="math inline">\(w\)</span>-区段，包含了所有介于 <span class="math inline">\(w\overline{bABa}\)</span> 和 <span class="math inline">\(w\overline{BAba}\)</span>之间的无限单词所对应的点。</p><div class="statement simple plain unnumbered"><p>Because <span class="math inline">\(a\)</span> is parabolic, thefixed points <span class="math inline">\(\bar{a}\)</span> and <span class="math inline">\(\bar{A}\)</span> are the same, and therefore,although the infinite words are different, the limit pointscorresponding to <span class="math inline">\(w\bar{a}\)</span> and <span class="math inline">\(w\bar{A}\)</span> are equal. Notice that theinfinite word <span class="math inline">\(w\bar{A}\)</span> reducesslightly to <span class="math display">\[w\bar{A} = BABaaAAAAA\cdots =BABAAA\cdots = BAB\bar{A}.\]</span> These cancellations mean that, onthe boundary of the word tree, <span class="math inline">\(BAB\bar{A}\)</span> is far outside the interval ofinfinite words which correspond to the <span class="math inline">\(w\)</span>-section of the limit set. So thechances are that the point <span class="math inline">\(w\hat{a}\)</span>is going to be stretched way away from its expected position, and we hadbetter check it out when we are making our plot. We explain in Note 7.3why it is only worth checking out the special repetends in the list andnot, for example, words ending in <span class="math inline">\(a\)</span>followed by the repetend <span class="math inline">\(b\)</span>.</p></div><p>由于 <span class="math inline">\(a\)</span> 是抛物元素，<span class="math inline">\(\bar{a}\)</span> 和 <span class="math inline">\(\bar{A}\)</span> 的不动点重合，因此，尽管无限词<span class="math inline">\(w\bar{a}\)</span> 和 <span class="math inline">\(w\bar{A}\)</span>不同，它们对应的极限点却是相同的。请注意，无限词 <span class="math inline">\(w\bar{A}\)</span> 可以简化为： <span class="math display">\[w\bar{A} = BABaaAAAAA\cdots = BABAAA\cdots =BAB\bar{A}.\]</span> 这种简化意味着，在词树的边界上，<span class="math inline">\(BAB\bar{A}\)</span> 超出了与 <span class="math inline">\(w\)</span>-截面极限集对应的无限词区间的范围。因此，点<span class="math inline">\(w\hat{a}\)</span>很可能会被拉伸得远离预期位置，因此我们在绘制图形时需要特别留意这一点。在<a href="#note-7.3" title="注记 7.3">注记 7.3</a>中，我们解释了为何只需检查列表中的特定循环节，而不必关注像以 <span class="math inline">\(a\)</span> 结尾、后接循环节 <span class="math inline">\(b\)</span> 的词。</p><div id="note-7.3" class="statement sta_note_7_3__which_repetends_should_be_considered_ definition unnumbered"><p><span class="statement-heading"><span class="statement-label">Note7.3: Which repetends should be considered?</span>：</span><span class="statement-spah"> </span><br></p><p><strong>注 7.3：应考虑哪些循环节？</strong></p><p>Here is the list of repetends the program must consider whenenumerating infinite words:</p><p><span class="math display">\[\begin{aligned}\text{gens[1]}&amp;=a \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[1,1]=bABa \\\text{repet}[1,2]=a \\\text{repet}[1,3]=BAba\end{array}\right. \\\text{gens[2]}&amp;=b \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[2,1]=ABab \\\text{repet}[2,2]=b \\\text{repet}[2,3]=aBAb\end{array}\right. \\\text{gens[3]}&amp;=A \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[3,1]=BabA \\\text{repet}[3,2]=A \\\text{repet}[3,3]=baBA\end{array}\right. \\\text{gens[4]}&amp;=B \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[4,1]=abAB \\\text{repet}[4,2]=B \\\text{repet}[4,3]=AbaB\end{array}\right.\end{aligned}\]</span></p><p>There are some obvious omissions. For example, the generator <span class="math inline">\(b\)</span> is also parabolic, so that <span class="math inline">\(w\overline{b}\)</span> is the same point as <span class="math inline">\(w\overline{B}\)</span>. Should we perhaps checkout <span class="math inline">\(w\overline{b}\)</span> as well? Well,since <span class="math inline">\(w\)</span> ends in <span class="math inline">\(a\)</span>, neither of the infinite words <span class="math inline">\(w\overline{b}\)</span> and <span class="math inline">\(w\overline{B}\)</span> collapse at all, so both<span class="math inline">\(w\overline{b}\)</span> and <span class="math inline">\(w\overline{B}\)</span> are in the small stretch ofinfinite words which correspond to the wiggly <span class="math inline">\(w\)</span>-section. There seems to be no specialneed to bother with these points, in fact looking at plots we learned byexperience that they don’t stick particularly far out at all. In otherwords, if <span class="math inline">\(w\)</span> ends with <span class="math inline">\(a\)</span>, then there is no need to look atrepetends <span class="math inline">\(b\)</span> or <span class="math inline">\(B\)</span>. Similar reasoning leads to the patternin the chart. The repetends which are important to consider after a word<span class="math inline">\(w\)</span> which ends in the tag <span class="math inline">\(c\)</span> (one of <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(A\)</span>or <span class="math inline">\(B\)</span>) are precisely those whichthemselves end in <span class="math inline">\(c\)</span>. This isbecause the inverse of the repetend will begin with <span class="math inline">\(C\)</span> (letters in the inverse word, remember,appear in reverse order) so that there are cancellations in <span class="math inline">\(wC\)</span>. This means that the point <span class="math inline">\(w(\overline{C})\)</span> is not in the part of theboundary of the word tree corresponding to infinite words with theprefix <span class="math inline">\(w\)</span>. You can imagine that itspresence pulls the point <span class="math inline">\(w(\overline{c})\)</span> (which is in the <span class="math inline">\(w\)</span>-section) towards it, causingdistortions which our program needs to check out.</p><p>程序枚举无限字时需考察的循环节列表如下：</p><p><span class="math display">\[\begin{aligned}\text{gens[1]}&amp;=a \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[1,1]=bABa \\\text{repet}[1,2]=a \\\text{repet}[1,3]=BAba\end{array}\right. \\\text{gens[2]}&amp;=b \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[2,1]=ABab \\\text{repet}[2,2]=b \\\text{repet}[2,3]=aBAb\end{array}\right. \\\text{gens[3]}&amp;=A \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[3,1]=BabA \\\text{repet}[3,2]=A \\\text{repet}[3,3]=baBA\end{array}\right. \\\text{gens[4]}&amp;=B \quad \Rightarrow \quad \left\{\begin{array}{l}\text{repet}[4,1]=abAB \\\text{repet}[4,2]=B \\\text{repet}[4,3]=AbaB\end{array}\right.\end{aligned}\]</span></p><p>显然，当前列表存在一些遗漏。例如，生成元 <span class="math inline">\(b\)</span> 同样是抛物型的，因此 <span class="math inline">\(w\overline{b}\)</span> 和 <span class="math inline">\(w\overline{B}\)</span>对应相同的点。那么，我们是否也应该检查 <span class="math inline">\(w\overline{b}\)</span> 呢？实际上，由于 <span class="math inline">\(w\)</span> 以 <span class="math inline">\(a\)</span> 结尾，<span class="math inline">\(w\overline{b}\)</span> 和 <span class="math inline">\(w\overline{B}\)</span>都不会发生任何坍缩，因此二者均位于描述 <span class="math inline">\(w\)</span>-区段波动形态的无限词集合中。根据绘图观察的经验，这类点并不会显著突出边界轮廓。换言之，如果<span class="math inline">\(w\)</span> 以 <span class="math inline">\(a\)</span> 结尾，则无需考察以 <span class="math inline">\(b\)</span> 或 <span class="math inline">\(B\)</span>结尾的循环节。通过类似推理可得图表中的模式规律：对于以标签 <span class="math inline">\(c\)</span>（即 <span class="math inline">\(a,b,A,B\)</span> 之一）结尾的词 <span class="math inline">\(w\)</span>，需重点考察的循环节恰是那些自身以 <span class="math inline">\(c\)</span> 结尾者。这是因为此类循环节的逆元将以<span class="math inline">\(C\)</span>开始（注意逆元中的字母顺序是反转的），从而在组合 <span class="math inline">\(wC\)</span> 时产生抵消效应。这意味着点 <span class="math inline">\(w(\overline{C})\)</span> 并不位于对应前缀 <span class="math inline">\(w\)</span>的无限字所在词树边界区域。可以设想，该点的存在会将 <span class="math inline">\(w(\overline{c})\)</span>（位于 <span class="math inline">\(w\)</span>-区段内）拉向它，从而产生程序需要检查的扭曲效应。</p></div><figure id="fig-7.15"><img src="/images/indra/fig-7.14.jpg" width="500" alt="Figure 7.15. Slow motion gasket. This is a piece of the Apollonian gasket plotted with \epsilon=0.1. The width and height of the frame are 0.4. We have started numbering the limit points at 1 = \overline{bABA} in the upper left corner. One has to run through quite a few limit points after number 20 = b\overline{A}, before we return to that same point labelled by the different infinite word b\overline{a} at number 128. The limit points through which the curve passes twice have repetends a, A, b or B. 图 7.15. 慢动作的阿波罗涡旋。这是一个阿波罗涡旋的片段，使用了 \epsilon = 0.1 进行绘制。框架的宽度和高度都是 0.4。我们从左上角的点 1 = \overline{bABA} 开始为极限点编号。直到编号为 20 = b\overline{A} 的点之后，才需要通过若干个极限点，才能返回到那个用不同无限单词 b\overline{a} 标记的同一点——这个点的编号是 128。曲线经过两次的极限点，其重复部分包括 a、A、b 或 B。"><figcaption aria-hidden="true">Figure 7.15. Slow motion gasket. This isa piece of the Apollonian gasket plotted with <code>\epsilon=0.1</code>.The width and height of the frame are 0.4. We have started numbering thelimit points at <span class="math inline">\(1 = \overline{bABA}\)</span>in the upper left corner. One has to run through quite a few limitpoints after number <span class="math inline">\(20 =b\overline{A}\)</span>, before we return to that same point labelled bythe different infinite word <span class="math inline">\(b\overline{a}\)</span> at number 128. The limitpoints through which the curve passes twice have repetends <span class="math inline">\(a\)</span>, <span class="math inline">\(A\)</span>, <span class="math inline">\(b\)</span>or <span class="math inline">\(B\)</span>.<br>图 7.15. 慢动作的阿波罗涡旋。这是一个阿波罗涡旋的片段，使用了 <span class="math inline">\(\epsilon = 0.1\)</span>进行绘制。框架的宽度和高度都是 0.4。我们从左上角的点 <span class="math inline">\(1 = \overline{bABA}\)</span>开始为极限点编号。直到编号为 <span class="math inline">\(20 =b\overline{A}\)</span>的点之后，才需要通过若干个极限点，才能返回到那个用不同无限单词 <span class="math inline">\(b\overline{a}\)</span>标记的同一点——这个点的编号是 128。曲线经过两次的极限点，其重复部分包括<span class="math inline">\(a\)</span>、<span class="math inline">\(A\)</span>、<span class="math inline">\(b\)</span>或 <span class="math inline">\(B\)</span>。</figcaption></figure><div class="statement simple plain unnumbered"><p>At the beginning of the program, our routine computes the attractivefixed point <span class="math inline">\({\rm fp}[i,j]\)</span> of eachof the repetends <span class="math inline">\({\rm repet[i,j]\}\)</span>listed in the chart. The only parts of the running algorithm which needto be changed are the termination and plotting subroutines. Suppose weare at the finite word ending in the generator <span class="math inline">\(gens[i]\)</span>. Then we compute the threepoints</p><p><span class="math display">\[z_j = \text{word}({\rmfp}[i,j])\]</span></p><p>for <span class="math inline">\(j = 1, 2, 3\)</span>. Given theplotting gap <span class="math inline">\(\epsilon\)</span>, we requireboth <span class="math inline">\(|z_2 - z_1| \leq \epsilon\)</span> and<span class="math inline">\(|z_3 - z_2| \leq \epsilon\)</span> in orderto terminate the forward enumeration along that particular branch of theword tree. If the criterion is met, we draw a line segment from <span class="math inline">\(z_1\)</span> to <span class="math inline">\(z_2\)</span>, and a line segment from <span class="math inline">\(z_2\)</span> to <span class="math inline">\(z_3\)</span>. That is all the modification weneed.</p></div><p>在程序开始时，我们的例行步骤会计算出图表中每个循环节（repetend）<span class="math inline">\({\rm repet[i,j]}\)</span> 的吸引不动点（attractivefixed point）<span class="math inline">\({\rmfp}[i,j]\)</span>。原有算法中，唯一需要修改的部分是终止条件和绘图子程序。假设我们当前位于一个以生成元<span class="math inline">\(gens[i]\)</span> 结尾的有限字（finiteword）。此时，我们计算以下三个点： zj=word(fp[i,j])zj​=word(fp[i,j]) 其中<span class="math inline">\(j = 1, 2, 3\)</span>。</p><p>给定绘图精度 <span class="math inline">\(\epsilon\)</span>，我们要求满足 <span class="math inline">\(|z_2 - z_1| \leq \epsilon\)</span> 且 <span class="math inline">\(|z_3 - z_2| \leq\epsilon\)</span>，才能终止该分支在字树（wordtree）上的正向枚举。若条件满足，我们依次绘制两条线段：一条从 <span class="math inline">\(z_1\)</span> 到 <span class="math inline">\(z_2\)</span>，另一条从 <span class="math inline">\(z_2\)</span> 到 <span class="math inline">\(z_3\)</span>。这就是我们所需的全部修改。</p><div class="statement simple plain unnumbered"><p>Figure 7.15 shows a slow motion execution of this special wordalgorithm for the gasket. As above, <span class="math inline">\(a,b\)</span> and the commutator have been listedas special words. A piece of the gasket has been plotted at the ratherlarge gap size of <code>epsilon=0.1</code>. As you can see, all thecontact points between far away parts of the limit set curve arecompletely filled in and the algorithm produces limit sets with novisible gaps. You will see better how the special word algorithm worksif you follow through the description in Note 7.4.</p></div><p>图 7.15 展示了这种针对垫片的特殊词算法的慢动作执行过程。和上文一样，特殊词中包括 <span class="math inline">\(a,b\)</span>和换位子。图中绘制了垫片的一部分，采用了较大的间隙尺寸<code>epsilon=0.1</code>。正如你所见，极限集曲线中远处部分之间的所有接触点都已被完全填充，算法生成的极限集不再存在可见的间隙。如果你参照<a href="#note-7.4" title="注记 7.4">注记 7.4</a>中的描述，将能更清楚地理解特殊词算法的工作原理。</p><div class="statement simple plain unnumbered"><p>Many fractals are created through a process of iteration which is notterribly sensitive to the order of execution of the program. Seeinglimit sets like the gasket drawn as curves is too wonderful to leave tosuch a procedure. When testing your program it is essential toscrutinize with excruciating care the order of infinite words andcorresponding limit points. For lack of space (it’s already a crowdedpicture), not all the limit points in Figure 7.15 have been labelled. Ifyou really wish to test your understanding of the algorithm, you shouldtry to fill in some missing labels, which can be done given thedictionary ordering and the desired special words.</p></div><p>许多分形图形是通过迭代过程生成的，而这种过程对程序的执行顺序通常并不十分敏感。然而，像垫片（gasket）这样的极限集，如果仅仅以这种方式画成曲线，未免太过可惜——它的美妙远不止于此。</p><p>在测试程序时，务必仔细审查无限词的顺序及其对应的极限点，做到一丝不苟。由于空间有限（图7.15已经非常拥挤），并未对其中的所有极限点标注。如果你真的想检验自己对算法的理解，不妨尝试补全其中缺失的标注。只要参考字典序和那些特殊的目标词，这项工作是完全可行的。</p><div id="note-7.4" class="statement sta_note_7_4__tracing_the_gasket definition unnumbered"><p><span class="statement-heading"><span class="statement-label">Note7.4: Tracing the gasket</span>：</span><span class="statement-spah"></span><strong>注记 7.4：追踪垫片</strong></p><p>To understand the workings of our special word algorithm better, youmay like to try following along segments of the curve in Figure 7.15carefully as we describe here.</p><p>Let’s focus on the segment of limit set between points 1 and 35. Thisis the segment corresponding to all words with prefix <span class="math inline">\(bA\)</span>. As you can see by referring to ourchart of repetends, <span class="math inline">\(1 = bABabA\)</span> and<span class="math inline">\(35 = bAbaBA\)</span>. (In the figure, thesepoints are written slightly differently, simply because we chose adifferent point starting point for cycling the repetend. So for example<span class="math inline">\(bABabA\)</span> is exactly the same sequenceas <span class="math inline">\(\overline{bABA}\)</span>.) As you can seeby following the numbers closely, the segment of limit set betweenpoints <span class="math inline">\(1 = bABabA\)</span> and <span class="math inline">\(35 = bAbaBA\)</span> passes through the bad fixedpoint <span class="math inline">\(20 = bAA\)</span>. At this scale thedistortion is not too bad – in comparison to the distance between 1 and35, the point 20 is not too far away. Things get worse when you go tothe next level and study the subsegment corresponding to infinite wordswith prefix <span class="math inline">\(bAA\)</span>. The initial pointof this section of limit set is <span class="math inline">\(15 =bAABabA\)</span> and the final point is <span class="math inline">\(25 =bAAbaBA\)</span>. The outlier is still 20, which can also be written as<span class="math inline">\(bAAA\)</span>. See how 20 is pulled quitefar out in comparison to the distance between 15 and 25. This ishappening because in fact <span class="math inline">\(20 =b\overline{A}\)</span> is the same point as 128 = <span class="math inline">\(b\overline{a}\)</span>, which is in quite adifferent section of the path round the boundary of the word tree. Ouralgorithm would only stop at this prefix if the distances from 15 to 20and from 20 to 25 were both less than the cut-off value <span class="math inline">\(\epsilon\)</span>. At the next stage, look at theinterval between 17 = <span class="math inline">\(bAAABabA\)</span> and23 = <span class="math inline">\(bAAAbaBA\)</span>. The outlier is still20 = <span class="math inline">\(bAAAA\)</span>. Now the disproportionbetween the distances from 17 to 23, as opposed to the distances from 17to 20 and 20 to 23, is really getting large. As you go further andfurther into the spike, the disproportion gets ever worse, so the fineryou want to plot your pictures the more important it is to check outthese outliers. If we weren’t using the special words algorithm, theplot would terminate far too soon, chopping off the piece of limit setwhich sticks out into the spike.</p><p>为了更好地理解我们的特殊单词算法的工作原理，不妨按照我们在此描述的内容，仔细沿着图7.15 中曲线的某些部分追踪观察。</p><p>让我们聚焦于点 1 和点 35 之间的极限集部分。这一部分对应于所有以 <span class="math inline">\(bA\)</span>为前缀的单词。参照我们的循环节图表，可以看到 <span class="math inline">\(1 = bABabA\)</span>，而 <span class="math inline">\(35 =bAbaBA\)</span>。（图中这些点的表示稍有不同，仅仅是因为我们选择了一个不同的起始点来循环循环节。例如，<span class="math inline">\(bABabA\)</span> 与 <span class="math inline">\(\overline{bABA}\)</span>实际上是完全相同的序列。）</p><p>仔细观察编号，可以发现，从点 <span class="math inline">\(1 =bABabA\)</span> 到点 <span class="math inline">\(35 = bAbaBA\)</span>的极限集部分经过了那个糟糕的不动点 <span class="math inline">\(20 =bAA\)</span>。在这个尺度下，尽管存在一定的畸变，但相较于点 1 和点 35之间的距离，点 20也并不算太远。然而，情况在进一步深入时变得更糟。当研究对应于以 <span class="math inline">\(bAA\)</span>为前缀的无限单词的子区段时，情况就更明显了。这个区段的起始点是 <span class="math inline">\(15 = bAABabA\)</span>，终点是 <span class="math inline">\(25 = bAAbaBA\)</span>。</p><p>异常点依然是 20，它也可以写作 <span class="math inline">\(bAAA\)</span>。注意点 20在图中被拉出了相当远的距离，相较于点 15 到点 25 之间的距离，点 20的偏离尤为显著。这种现象的根本原因在于，实际上 <span class="math inline">\(20 = b\overline{A}\)</span> 与 <span class="math inline">\(128 = b\overline{a}\)</span>是同一个点，而该点在单词树边界路径的完全不同的部分。我们的算法仅在点 15到点 20 以及点 20 到点 25 的距离都小于截断值 <span class="math inline">\(\epsilon\)</span> 时，才会在该前缀处停止。</p><p>再往下一层观察区间时，查看点 17 = <span class="math inline">\(bAAABabA\)</span> 和点 23 = <span class="math inline">\(bAAAbaBA\)</span> 之间的区段。异常点依然是点 20 =<span class="math inline">\(bAAAA\)</span>。此时，点 17 到点 23的距离，与点 17 到点 20 以及点 20 到点 23的距离之间的失衡变得更加明显。随着你在这根尖刺中不断深入，这种失衡愈加严重。因此，越是要精细地绘制图形，检查这些异常点就越重要。如果我们没有使用特殊单词算法，绘图将会过早终止，从而截断伸入尖刺的那一部分极限集。</p></div><h1 id="projects">Projects</h1><div id="proj-7.1" class="statement sta_7_1__uniqueness_of_ideal_triangles plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.1:Uniqueness of ideal triangles</span>.</span><span class="statement-spah"></span><strong>7.1：理想三角形的唯一性</strong></p><p>How many ideal triangles can you draw with given vertices <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>and <span class="math inline">\(R\)</span>? If the vertices are <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span>and <span class="math inline">\(\infty\)</span>, show that the sidesmust be the two ‘vertical’ lines through <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span> and the circle with centre <span class="math inline">\(1/2\)</span>, radius <span class="math inline">\(1/2\)</span>. Thus there are exactly two idealtriangles with these vertices, but only in the ‘upper’ triangle are thevertices <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span> and <span class="math inline">\(\infty\)</span> in anticlockwise order round theedge. Sometimes this is called the standard ideal triangle. Find itsincircle.</p><p>Suppose now you have another ideal triangle with vertices <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>and <span class="math inline">\(R\)</span> in anticlockwise order.Project 3.2 showed there is exactly one Möbius map <span class="math inline">\(M\)</span> which carries <span class="math inline">\(0\)</span>, <span class="math inline">\(1\)</span>and <span class="math inline">\(\infty\)</span> to <span class="math inline">\(P\)</span>, <span class="math inline">\(Q\)</span>, <span class="math inline">\(R\)</span>in that order. What properties of Möbius maps show that <span class="math inline">\(M\)</span> carries the standard ideal triangleinto the new one? If there were another other ideal triangle with thesame vertices in the same order, what would happen when you applied<span class="math inline">\(M^{-1}\)</span>? Why does any ideal trianglehave exactly one incircle?</p><p>给定顶点 <span class="math inline">\(P\)</span>、<span class="math inline">\(Q\)</span> 和 <span class="math inline">\(R\)</span>，可以画出多少个理想三角形？如果顶点是<span class="math inline">\(0\)</span>、<span class="math inline">\(1\)</span> 和 <span class="math inline">\(\infty\)</span>，可以证明它们的边必须是通过 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(1\)</span> 的两条“垂直”直线，以及以 <span class="math inline">\(1/2\)</span> 为圆心、<span class="math inline">\(1/2\)</span>为半径的圆。因此，具有这些顶点的理想三角形恰好有两个，但只有在“上方”的三角形中，顶点<span class="math inline">\(0\)</span>、<span class="math inline">\(1\)</span> 和 <span class="math inline">\(\infty\)</span>按逆时针顺序排列在边界上。有时这个三角形被称为标准理想三角形。找出它的内切圆。</p><p>假设现在有另一个理想三角形，其顶点 <span class="math inline">\(P\)</span>、<span class="math inline">\(Q\)</span>和 <span class="math inline">\(R\)</span> 按逆时针顺序排列。项目 3.2表明，存在唯一的莫比乌斯变换 <span class="math inline">\(M\)</span>，将<span class="math inline">\(0\)</span>、<span class="math inline">\(1\)</span> 和 <span class="math inline">\(\infty\)</span> 依次映射到 <span class="math inline">\(P\)</span>、<span class="math inline">\(Q\)</span>、<span class="math inline">\(R\)</span>。莫比乌斯变换的哪些性质表明 <span class="math inline">\(M\)</span>将标准理想三角形映射到新的三角形？如果存在另一个具有相同顶点且按相同顺序排列的理想三角形，那么对其应用<span class="math inline">\(M^{-1}\)</span>会发生什么？为什么任何理想三角形都有且仅有一个内切圆？</p></div><div id="proj-7.2" class="statement simple plain unnumbered"><p>7.2: An instance of Soddy’s formula</p><p><strong>7.2：索迪公式的一个实例</strong></p><p>Calculate the radius of the incircle <span class="math inline">\(C_A\)</span> in the right frame of Figure 7.4using Soddy’s formula, and check your answer with a more conventionalcomputation using Pythagoras’ theorem. Be careful: one circle hasinfinite radius! Use your result to show that the points <span class="math inline">\(S\)</span> and <span class="math inline">\(R\)</span> in the figure are at <span class="math inline">\(\pm 0.2 - 0.4i\)</span>, and then check thegenerators pair the tangency points properly.</p><p>使用索迪公式计算图 7.4 右侧框中的内切圆 <span class="math inline">\(C_A\)</span>的半径，并通过应用勾股定理进行常规计算来验证你的结果。请小心：其中一个圆的半径是无限的！利用你的结果，证明图中的点<span class="math inline">\(S\)</span> 和 <span class="math inline">\(R\)</span> 位于 <span class="math inline">\(\pm0.2 - 0.4i\)</span>，然后检查生成器是否正确地配对了切点。</p></div><div id="proj-7.3" class="statement sta_7_3__the_ford_circles plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.3:The Ford circles</span>.</span><span class="statement-spah"></span><strong>7.3: 福特圆</strong></p><p>There is a remarkable pattern for the radii of the circles whichtouch the real axis in Figure 7.5, commonly credited to Lester Ford. Thepattern is easiest to analyze if we shift and scale so that the largestpink circles are tangent to the real axis at integer points, so theyhave diameter <span class="math inline">\(1\)</span>, and the strip is<span class="math inline">\(1\)</span> unit high. Then there is exactlyone circle (pink or white) tangent at every rational point <span class="math inline">\(p/q\)</span>. Find the pattern that describeswhich rationals <span class="math inline">\(p/q\)</span> are tangent toa white circle, and which to a pink one.</p><p>The formula for the radius of the circle tangent at <span class="math inline">\(p/q\)</span> is quite simple. It depends only on<span class="math inline">\(q\)</span>. For example, at each integerpoint <span class="math inline">\(n/1\)</span> the denominator is <span class="math inline">\(1\)</span> and the radius is <span class="math inline">\(1/2\)</span>. At each half-integer, <span class="math inline">\(\pm 1/2, \pm 3/2\)</span>, etc., the denominatoris <span class="math inline">\(2\)</span> and the radius is <span class="math inline">\(1/8\)</span>. Those are all the hints we’llgive.</p><p>如图 7.5 所示，与实轴相切的圆的半径呈现出一个显著的规律，通常归功于LesterFord。最容易分析这个规律的方法是通过平移和缩放，使得最大的粉色圆与实轴在整数点相切，直径为<span class="math inline">\(1\)</span>，并且该条带的高度为 <span class="math inline">\(1\)</span> 单位。这样，恰好每个有理数点 <span class="math inline">\(p/q\)</span>上都会有一个圆（无论是粉色还是白色）与实轴相切。接下来，找出描述哪些有理数<span class="math inline">\(p/q\)</span>与白色圆相切，哪些与粉色圆相切的规律。</p><p>在 <span class="math inline">\(p/q\)</span>处与实轴相切的圆的半径公式非常简单，它只与分母 <span class="math inline">\(q\)</span> 有关。例如，在每个整数点 <span class="math inline">\(n/1\)</span> 处，分母为 <span class="math inline">\(1\)</span>，半径为 <span class="math inline">\(1/2\)</span>；在每个半整数点 <span class="math inline">\(\pm 1/2, \pm 3/2\)</span> 等处，分母为 <span class="math inline">\(2\)</span>，半径为 <span class="math inline">\(1/8\)</span>。这些就是我们给出的所有提示。</p></div><div id="proj-7.4" class="statement sta_7_4__another_modular_group_in_the_gasket_group plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.4:Another modular group in the gasket group</span>.</span><span class="statement-spah"> </span><strong>垫片群中的另一个模群</strong></p><p>In the text (see p.&nbsp;213), we focussed on the modular group acting inwhat were the pink disks in Figure 7.4. (The tiling of these disks isshown in Figure 7.6.) The modular group acts in the white disks too. Inthe right frame of Figure 7.4, look at the lower blue circles <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span>. Their images <span class="math inline">\(a(C_B)\)</span> and <span class="math inline">\(a(C_b)\)</span> are also tangent circles, actuallythe reflections of the first two in the real axis. These four circlesare tangent and cut the white exterior of the unit disk into fourquarters. Twist yourself inside out to see that in this white exteriorwe also have the gluing pattern for the modular group: four tangentcircles with neighbouring circles being paired. Show that the twotangency points correspond to the parabolic elements <span class="math inline">\(b\)</span> and <span class="math inline">\(abA\)</span>, while the other two are the products<span class="math inline">\(abAB\)</span> and <span class="math inline">\(BabA\)</span>, which are parabolic with fixedpoints at <span class="math inline">\(1\)</span> and <span class="math inline">\(-1\)</span> respectively. The limit set for thissubgroup is the unit circle.</p><p>在文本中（见第 213 页），我们集中讨论了模群在图 7.4中粉色圆盘上的作用。（这些圆盘的镶嵌方式见图7.6。）模群同样作用于白色圆盘。在图 7.4 的右侧框架中，观察下方的蓝色圆圈<span class="math inline">\(C_B\)</span> 和 <span class="math inline">\(C_b\)</span>。它们的像 <span class="math inline">\(a(C_B)\)</span> 和 <span class="math inline">\(a(C_b)\)</span>也是相切的圆，实际上是前两个圆关于实轴的对称映像。这四个圆相切，并且将单位圆的白色外部区域切割成四个部分。试着从另一个角度来理解，你会发现，在这片白色外部区域中，模群的拼接模式也显现出来：四个相切的圆，其中相邻的圆形成一对。证明这两个相切点对应于抛物线元<span class="math inline">\(b\)</span> 和 <span class="math inline">\(abA\)</span>，而另外两个则是乘积 <span class="math inline">\(abAB\)</span> 和 <span class="math inline">\(BabA\)</span>，这两个也是抛物线元，分别在 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(-1\)</span>处有不动点。这个子群的极限集是单位圆。</p></div><div id="proj-7.5" class="statement sta_7_5__farey_fractions_and_euclid_s_algorithm plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.5:Farey fractions and Euclid’s algorithm</span>.</span><span class="statement-spah"> </span><strong>7.5:法雷分数与欧几里得算法</strong></p><p>To show that every rational number <span class="math inline">\(p/q\)</span> is a vertex of the modular tiling inFigure 7.9 we need to find two other integers <span class="math inline">\(r\)</span> and <span class="math inline">\(s\)</span> such that <span class="math inline">\(ps - qr = \pm 1\)</span>. Why will this do what wewant?</p><p>The procedure for finding <span class="math inline">\(r\)</span> and<span class="math inline">\(s\)</span> like this is exactly the famousEuclidean algorithm for finding the highest common factor of twonumbers. In this case, we may as well suppose that <span class="math inline">\(p/q\)</span> is in its lowest terms so the highestcommon factor is 1. Let’s suppose <span class="math inline">\(p &gt; q&gt; 0\)</span>. The algorithm says we shall be able to find integers<span class="math inline">\(a_1, r_1, a_2, r_2, \ldots\)</span> and soon such that:</p><p><span class="math display">\[\begin{aligned}&amp; p = a_1 q + r_1, \quad 0 &lt; r_1 &lt; q, \\&amp; q = a_2 r_1 + r_2, \quad 0 &lt; r_2 &lt; r_1, \\&amp; r_1 = a_3 r_2 + r_3, \quad 0 &lt; r_3 &lt; r_2, \\&amp; \vdots \\&amp; r_{n-1} = a_{n+1} r_n + 1.\end{aligned}\]</span></p><p>Using these equations you can work backwards to find <span class="math inline">\(r\)</span> and <span class="math inline">\(s\)</span>. For example, if <span class="math inline">\(p = 14\)</span>, <span class="math inline">\(q =3\)</span> then <span class="math inline">\(14 = 4 \cdot 3 + 2\)</span>,<span class="math inline">\(3 = 2 \cdot 1 + 1\)</span> and so <span class="math inline">\(14 - 4 \cdot 3 = 2 = 3 - 1\)</span> giving <span class="math inline">\(14 - 5 \cdot 3 = -1\)</span>. Now try to spot theconnection with continued fractions:</p><p><span class="math display">\[\frac{14}{3} = 4 + \frac{2}{3} = 4 +\frac{1}{\frac{3}{2}} = 4 + \frac{1}{1 + \frac{1}{2}}.\]</span></p><p>要证明每个有理数 <span class="math inline">\(p/q\)</span> 都是图 7.9中模群镶嵌的一个顶点，我们需要找到两个整数 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(s\)</span>，使得 <span class="math inline">\(ps -qr = \pm 1\)</span>。为什么这能达到我们的目标？</p><p>这种寻找 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(s\)</span>的方法正是著名的欧几里得算法，用于求两个数的最大公因数。在这种情况下，我们可以假设<span class="math inline">\(p/q\)</span>已经化为最简分数，因此它们的最大公因数为 1。假设 <span class="math inline">\(p &gt; q &gt;0\)</span>。算法指出，我们可以找到整数 <span class="math inline">\(a_1,r_1, a_2, r_2, \ldots\)</span> 等，使得：</p><p><span class="math display">\[\begin{aligned}&amp; p = a_1 q + r_1, \quad 0 &lt; r_1 &lt; q, \\&amp; q = a_2 r_1 + r_2, \quad 0 &lt; r_2 &lt; r_1, \\&amp; r_1 = a_3 r_2 + r_3, \quad 0 &lt; r_3 &lt; r_2, \\&amp; \vdots \\&amp; r_{n-1} = a_{n+1} r_n + 1.\end{aligned}\]</span> 利用这些等式可以回溯找到 <span class="math inline">\(r\)</span> 和 <span class="math inline">\(s\)</span>。例如，如果 <span class="math inline">\(p = 14\)</span>，<span class="math inline">\(q =3\)</span>，则 <span class="math inline">\(14 = 4 \cdot 3 +2\)</span>，<span class="math inline">\(3 = 2 \cdot 1 + 1\)</span>，因此<span class="math inline">\(14 - 4 \cdot 3 = 2 = 3 - 1\)</span>，从而<span class="math inline">\(14 - 5 \cdot 3 =-1\)</span>。现在尝试找到与连分数的联系： <span class="math display">\[\frac{14}{3} = 4 + \frac{2}{3} = 4 +\frac{1}{\frac{3}{2}} = 4 + \frac{1}{1 + \frac{1}{2}}.\]</span></p></div><div id="proj-7.6" class="statement sta_7_6__the_modular_group_and_odd_even_fractions plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.6:The modular group and odd-even fractions</span>.</span><span class="statement-spah"> </span><strong>7.6：模群与奇偶分数</strong></p><p>Show that if <span class="math inline">\(\begin{pmatrix} a &amp; b \\c &amp; d \end{pmatrix}\)</span> is in the (small) modular group then<span class="math inline">\(a\)</span> and <span class="math inline">\(d\)</span> are odd and <span class="math inline">\(b\)</span> and <span class="math inline">\(c\)</span> are even. Why is a fraction in theorbit of <span class="math inline">\(0\)</span> under the (small)modular group exactly when it is ‘even/odd’? What can you say aboutodd/odd and odd/even? (Notice that in any triple of Farey neighbours youget one fraction of each kind.)</p><p>证明如果 <span class="math inline">\(\begin{pmatrix} a &amp; b \ c&amp; d \end{pmatrix}\)</span> 属于（小）模群，则 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(d\)</span> 为奇数，<span class="math inline">\(b\)</span> 和 <span class="math inline">\(c\)</span>为偶数。为什么当一个分数在（小）模群作用下的轨道中时，它恰好是“偶/奇”分数？关于奇/奇和奇/偶分数可以说些什么？（请注意，在任何一个Farey 邻居三元组中，总会有一种类型的分数。）</p></div><div id="proj-7.7" class="statement sta_7_7__the_modular_group_or_not_ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.7:The modular group or not?</span>.</span><span class="statement-spah"></span><strong>7.7：模群还是别的？</strong></p><p>It is interesting to compare the group which generated Figure 6.5 inthe last chapter with the modular group. The group in Chapter 6 hasgenerators</p><p><span class="math display">\[a = \begin{pmatrix} \sqrt{2} &amp; i \\-i &amp; \sqrt{2} \end{pmatrix} \text{ and } b = \begin{pmatrix}\sqrt{2} &amp; 1 \\ 1 &amp; \sqrt{2} \end{pmatrix}.\]</span></p><p>The conjugated picture of this group in frame (v) of Figure 6.10looks exactly the same as the basic tile for the modular group in Figure7.9. Are these two groups the same up to conjugation or not?</p><p>将第 6 章中生成 <a href="#fig-6.5">图 6.5</a>的群与模群进行比较很有趣。第 6 章中的群的生成元为： <span class="math display">\[a = \begin{pmatrix} \sqrt{2} &amp; i \\ -i &amp;\sqrt{2} \end{pmatrix} \text{ and } b = \begin{pmatrix} \sqrt{2} &amp; 1\\ 1 &amp; \sqrt{2} \end{pmatrix}.\]</span> 在 <a href="#fig-6.10">图6.10</a> 的第 (v) 帧中，该群的共轭图看起来与 <a href="#fig-7.9">图7.9</a> 中模群的基本镶嵌完全相同。它们是否在共轭意义下相同？</p></div><div id="proj-7.8" class="statement sta_7_8__a_special_schottky_group plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.8: Aspecial Schottky group</span>.</span><span class="statement-spah"></span><strong>7.8：一个特殊的 Schottky 群</strong></p><p>In Project 4.1 we introduced a family of Schottky groups depending on2 real numbers <span class="math inline">\(s\)</span> and <span class="math inline">\(t\)</span> which mapped the real axis to itself.These groups were designed so that the order of the Schottky circlesalong the real axis was the same as for the modular group. In fact, weorganised things so that when <span class="math inline">\(s = 0\)</span>and <span class="math inline">\(t = 1\)</span>, we get the modular groupitself! Just as we did on p.&nbsp;<span class="math inline">\(179ff\)</span>. in the last chapter, we can use this family to seeexplicitly what happens as we bring the four disjoint circles togetheruntil they touch.</p><p>Check that if <span class="math inline">\(s = 0\)</span>, then bothgenerators are parabolic. Which of the four Schottky circles touch? Showthat if <span class="math inline">\(s = 0\)</span> then <span class="math inline">\(\text{Tr } ab = 2 - 4/t^2\)</span> and thedistance between its fixed points is <span class="math inline">\(4\sqrt{1 - t^2}/t^2\)</span>. Hence verifydirectly that as <span class="math inline">\(t\)</span> tends to 1,<span class="math inline">\(ab\)</span> also becomes parabolic withtrace <span class="math inline">\(-2\)</span> and fixed point at <span class="math inline">\(-1\)</span>, the tangency point of <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_b\)</span>. Which group element corresponds tothe tangency point of <span class="math inline">\(C_A\)</span> and <span class="math inline">\(C_b\)</span>? Why does it become parabolic at thesame time as <span class="math inline">\(ab\)</span>?</p><p>在项目 4.1 中，我们介绍了一个取决于两个实数 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 的 Schottky群族，这些群将实轴映射到自身。我们特意设计这些群，使得沿实轴的 Schottky圆的排列顺序与模群相同。事实上，我们特意安排使得当 <span class="math inline">\(s = 0\)</span> 且 <span class="math inline">\(t =1\)</span> 时，该群就是模群本身！正如上一章第 179页及后续部分所讨论的那样，我们可以利用这个群族来直观地观察，当四个互不相交的圆逐渐靠近直至相切时会发生什么。</p><p>验证当 <span class="math inline">\(s = 0\)</span>时，这两个生成元都是抛物变换。此时，哪四个 Schottky 圆相切？证明如果<span class="math inline">\(s = 0\)</span>，则 <span class="math inline">\(\mathop{\mathrm{Tr}}{ab} = 2 -4/t^2\)</span>，且其不动点之间的距离为 <span class="math inline">\(4\sqrt{1 - t^2}/t^2\)</span>。从而可以直接验证，当<span class="math inline">\(t \to 1\)</span> 时，<span class="math inline">\(ab\)</span> 也成为一个抛物变换，其迹为 <span class="math inline">\(-2\)</span>，且不动点为 <span class="math inline">\(-1\)</span>，即圆 <span class="math inline">\(C_a\)</span> 和 <span class="math inline">\(C_b\)</span> 的切点。哪个群元素与圆 <span class="math inline">\(C_A\)</span> 和 <span class="math inline">\(C_b\)</span> 的切点相关？为什么它会恰好在 <span class="math inline">\(ab\)</span> 变为抛物变换时同时成为抛物变换？</p></div><div id="proj-7.9" class="statement sta_7_9__nesting_circles_which_don_t_shrink_ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">7.9:Nesting circles which don’t shrink!</span>.</span><span class="statement-spah"></span><strong>7.9：不会收缩的嵌套圆！</strong></p><p>It is not quite easy to find an explicit group whose generators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> pair opposite Schottky circles in atangent chain in such a way that <span class="math inline">\(abAB\)</span> is not parabolic. If instead we usecircles paired according to the modular group pattern, it is muchsimpler. The non-parabolic element will be the product <span class="math inline">\(ab\)</span>.</p><p>We do it with a slight alteration to the modular group which iseasiest to describe in terms of the vertices of the red and green idealquadrilateral in Figure 7.9. Fix the vertices at <span class="math inline">\(0\)</span>, <span class="math inline">\(-1\)</span> and <span class="math inline">\(\infty\)</span> but move the vertex <span class="math inline">\(1\)</span> to a point <span class="math inline">\(r\)</span> on the real axis slightly to its right(so <span class="math inline">\(r &gt; 1\)</span>). Check that</p><p><span class="math display">\[b = \begin{pmatrix} 1 &amp; 1 + r \\ 0&amp; 1 \end{pmatrix} \text{ and } a = \begin{pmatrix} 1 &amp; 0 \\ -1 -1/r &amp; 1 \end{pmatrix}\]</span></p><p>pair the new chain of tangent circles, matching tangency pointscorrectly.</p><p>Verify that <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are parabolic with fixed points at<span class="math inline">\(\infty\)</span> and <span class="math inline">\(0\)</span>. Now calculate <span class="math inline">\(ab\)</span> and show it is hyperbolic whenever<span class="math inline">\(r &gt; 1\)</span>. Where are its fixedpoints? If you have a suitable program up and running, you may wish todraw some pictures to check that the diameters of the nested circles donot shrink properly near <span class="math inline">\(-1\)</span> and<span class="math inline">\(r\)</span>.</p><p>要显式构造一个群，使其生成元 <span class="math inline">\(a\)</span>和 <span class="math inline">\(b\)</span> 能将相切链中相对的 Schottky圆配对，且使得 <span class="math inline">\(abAB\)</span>不是抛物型变换，这并非易事。但若采用模群的圆配对方式，问题便大为简化——此时非抛物元素恰是乘积</p><p>我们通过对模群稍作调整来实现这一点，最简单的方法是借助图 7.9中红色和绿色理想四边形的顶点：将三个顶点固定于 <span class="math inline">\(0,-1,\infty\)</span> 处，并将顶点 <span class="math inline">\(1\)</span> 沿实轴向右侧略微移动至 <span class="math inline">\(r\)</span>（即 <span class="math inline">\(r &gt;1\)</span>）。可验证矩阵 <span class="math display">\[b =\begin{pmatrix} 1 &amp; 1 + r \\ 0 &amp; 1 \end{pmatrix} \text{ and } a= \begin{pmatrix} 1 &amp; 0 \\ -1 - 1/r &amp; 1\end{pmatrix}\]</span></p><p>能正确配对新生成的相切圆链，并精确匹配切点。</p><p>验证这时 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 都是抛物型变换，其不动点分别位于 <span class="math inline">\(\infty\)</span> 和 <span class="math inline">\(0\)</span>。然后计算 <span class="math inline">\(ab\)</span> 并证明当 <span class="math inline">\(r&gt; 1\)</span>时它是双曲变换。它的不动点在哪里？如果你有合适的程序运行，不妨绘制一些图像，检查靠近<span class="math inline">\(-1\)</span> 和 <span class="math inline">\(r\)</span> 处的嵌套圆的直径是否未按预期缩小。</p></div><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>Reproduced from Nature, 137, 1936.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>The refinement has to do with ensuring that circlesappear with the desired visual accuracy.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p>The refinement has to do with ensuring that circlesappear with the desired visual accuracy.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>That would have made high school geometry a lot simpler!Perhaps that’s why triangles like this are called ‘ideal’.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd-Coxeter algorithm and uniform polytopes</title>
      <link href="/polytopes/index.html"/>
      <url>/polytopes/index.html</url>
      
        <content type="html"><![CDATA[<p>This project uses Python and POV-Ray to render 3D/4D uniformpolytopes. The code is hosted on <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/polytopes">GitHub</a>and requires the <code>numpy</code> library and the free raytracer,<code>POV-Ray</code>.</p><h1 id="examples">Examples</h1><p>All the images and videos displayed below are created using thisprogram. The polytope data is computed in Python and then exported toPOV-Ray for rendering.</p><ul><li><p>All Platonic solids and Archimedean solids, prims and antiprisms,for example the <a href="https://en.wikipedia.org/wiki/Snub_dodecahedron">snubdodecahedron</a>:</p><p><video src="/images/polytopes/snub-dodecahedron.mp4" controls=""></video></p></li><li><p>All Kepler-Poinsot solids, for example the <a href="https://en.wikipedia.org/wiki/Great_icosahedron">greaticosahedron</a>:</p><p><video src="/images/polytopes/great-icosahedron.mp4" controls=""></video></p></li><li><p>All uniform 4d polytopes (except the <a href="https://en.wikipedia.org/wiki/Grand_antiprism">grandantiprism</a>, which is non-Wythoffian), for example my github favicon,the <a href="https://en.wikipedia.org/wiki/Runcinated_120-cells">runcinated120-cell</a>:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/github-favicon.png"></p></li><li><p>5-cell:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/5-cell.png"></p></li><li><p>4d cube:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/4-cube.png"></p></li><li><p><a href="https://en.wikipedia.org/wiki/Truncated_tesseract">Truncatedtesseract</a>:</p><p><video src="/images/polytopes/truncated-tesseract.mp4" controls=""></video></p></li><li><p><a href="https://en.wikipedia.org/wiki/600-cell">600-cell</a>:(you can render the bubble faces and choose which of them are shown)</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/600-cell.png"></p></li><li><p><a href="https://en.wikipedia.org/wiki/16-cell">runcinated16-cell</a>:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/runcinated-16-cell.png"></p></li><li><p><a href="https://en.wikipedia.org/wiki/Snub_24-cell">snub24-cell</a>:</p><p><video src="/images/polytopes/snub24-cell.mp4" controls=""></video></p></li><li><p>You can also render uniform star 4d polytopes, for example the <a href="https://en.wikipedia.org/wiki/Grand_stellated_120-cell">grandstellated 120-cell</a>:</p><p><video src="/images/polytopes/grand-stellated-120-cell.mp4" controls=""></video></p><p>and its rectified version (rendered in a curved fashion):</p><p><video src="/images/polytopes/rectified-grand-stellated-120-cell.mp4" controls=""></video></p></li><li><p>And finally, uniform 5D polytopes like 5-cube:</p><p><video src="/images/polytopes/5-cube.mp4" controls=""></video></p></li></ul><h1 id="what-are-these-examples-about">What are these examplesabout?</h1><p>The polytopes showcased above are convex and non-convex uniformpolytopes in 3D or 4D Euclidean spaces. Key terms to note include“convex/non-convex”, “Euclidean”, and “uniform”.</p><p>The term “convex” refers to the property of a polytope such that anyline segment joining two points on the polytope lies entirely within theenclosure of the polytope. Examples of convex polytopes include Platonicsolids, Archimedean solids, and Catalan solids, while non-convex onesinclude Kepler-Poinsot solids and star polychora.</p><p>In 3D Euclidean space, there are 18 different convex uniformpolytopes (excluding the two infinite classes of prisms and antiprisms)and 57 different non-convex uniform polytopes. Currently, my program canonly render the convex ones and a few non-convex ones, but I’m workingon figuring out how to make it work for all of them in the future.</p><p>The term “Euclidean” is emphasized here because we also have uniformpolytopes in other metric spaces, such as the hyperbolic metric, whichbends the space and makes the polytopes look “deformed”. A famousexample of this is the logo “Spikey” of Mathematica, which is based onthe dodecahedron in hyperbolic 3-space.</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/spikey.png"></p><p>The term “uniform” requires some mathematical subtleties. Roughlyspeaking, it means that</p><ol type="1"><li>All vertices are the same.</li><li>All faces are regular polygons.</li><li>All cells are uniform polyhedra (a polyhedron that satisfiesconditions 1 and 2).</li></ol><p>To explain what “the same” means, we need to use terms from grouptheory: it means that the symmetry group <span class="math inline">\(G\)</span> of the polytope acts transitively onthe set of vertices, such that for any pair of vertices <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>, there is some <span class="math inline">\(g\in G\)</span> that transforms <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>: <span class="math inline">\(g \cdot u= v\)</span>.</p><p>In the above examples, the polytopes are colored such that allvertices, edges, and faces that are in the same orbit under the actionof the symmetry group have the same color.</p><h1 id="how-to-compute-the-data-of-a-uniform-polytope">How to computethe data of a uniform polytope</h1><p>Though these polytopes appear quite different from each other, theycan all be constructed using a uniform approach called the <a href="https://en.wikipedia.org/wiki/Wythoff_construction">Wythonffconstruction</a> (also known as the kaleidoscope construction). Inprinciple, this construction works in the same way as a kaleidoscope: weplace reflection planes (mirrors) in space, passing through the originand with carefully chosen angles between them (which must be of the form<span class="math inline">\(\pi-\pi/p\)</span> for some rational <span class="math inline">\(p\)</span>). These mirrors partition space into“rooms”. We choose any room (called the fundamental domain) and aninitial vertex <span class="math inline">\(v_0\)</span> in it, and thenrepeatedly reflect <span class="math inline">\(v_0\)</span> about themirrors to obtain a set of virtual images. All virtual images togetherwith <span class="math inline">\(v_0\)</span> form the vertices of ourpolytope. If <span class="math inline">\(v_1\)</span> is the virtualimage of <span class="math inline">\(v_0\)</span> about the <span class="math inline">\(i\)</span>-th mirror, then <span class="math inline">\((v_0,v_1)\)</span> form an edge of type <span class="math inline">\(i\)</span>. We can use the symmetry group totransform it to other edges in the same orbit. Also, if <span class="math inline">\(v_0\)</span> is firstly reflected about mirror<span class="math inline">\(i\)</span> and then reflected about mirror<span class="math inline">\(j\)</span>, then since the composition oftwo reflections is a rotation, <span class="math inline">\(v_0\)</span>is rotated about the center of some face <span class="math inline">\(f\)</span> by an angle of <span class="math inline">\(2\pi/m\)</span> (assuming the angle between mirror<span class="math inline">\(i\)</span> and mirror <span class="math inline">\(j\)</span> is <span class="math inline">\(\pi-\pi/m\)</span>). We can recover <span class="math inline">\(f\)</span> by applying this rotation <span class="math inline">\(m\)</span> times and using the symmetry group toobtain other faces.</p><p>To implement the above strategy in a practical program, we need toaddress two main issues:</p><ol type="1"><li>How to position the mirrors and select the initial vertex <span class="math inline">\(v_0\)</span> for a given convex uniformpolytope?</li><li>Once the mirrors and <span class="math inline">\(v_0\)</span> aredetermined, how do we compute all the virtual images of <span class="math inline">\(v_0\)</span>?</li></ol><p>The solution to the first problem is known as the <a href="https://en.wikipedia.org/wiki/Coxeter%E2%80%93Dynkin_diagram">Coxeter-Dynkindiagram</a>, which is a labeled undirected graph that encodes all thenecessary information. Each uniform polytope has a correspondingCoxeter-Dynkin diagram that represents it, although different diagramsmay represent the same polytope.</p><p>For example, the Coxeter-Dynkin diagram of the cube is:</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="250"></p><p>Let’s delve deeper into the Coxeter-Dynkin diagram. Each node in thediagram represents a mirror in the kaleidoscope. In the diagram above,there are three nodes, and therefore three mirrors, which we label fromleft to right as <span class="math inline">\(m_0\)</span>, <span class="math inline">\(m_1\)</span>, and <span class="math inline">\(m_2\)</span>. The labelled edge between two nodesencodes the angle between their corresponding mirrors, as follows:</p><ol type="1"><li>Two nodes are connected if and only if the angle between theirmirrors is not equal to <span class="math inline">\(\pi/2\)</span>.</li><li>Two nodes are connected by an unlabelled edge if and only if theangle between their mirrors equals <span class="math inline">\(\pi-\pi/3\)</span>.</li><li>Two nodes are connected by an edge labelled with a rational number<span class="math inline">\(m&gt;2\)</span> and <span class="math inline">\(m\ne3\)</span> if and only if the angle betweentheir mirrors equals <span class="math inline">\(\pi-\pi/m\)</span>.</li></ol><p>Moreover, we use “circled” nodes to indicate which mirrors are“active”, i.e., those that do not contain the initial vertex <span class="math inline">\(v_0\)</span>. In this case, reflecting <span class="math inline">\(v_0\)</span> about an active mirror produces avirtual image.</p><p>In the above example we have <span class="math inline">\(\langlem_0,m_1\rangle=\pi-\pi/4\)</span>, <span class="math inline">\(\langlem_1,m_2\rangle=\pi-\pi/3\)</span>, <span class="math inline">\(\langlem_0,m_2\rangle=\pi/2\)</span>. <span class="math inline">\(m_0\)</span>is active, but <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> are not.</p><p>Therefore, we can place the three mirrors as follows: (<span class="math inline">\(n_i\)</span> is the normalized normal vector ofmirror <span class="math inline">\(m_i\)</span>)</p><ol type="1"><li>The normal of <span class="math inline">\(m_0\)</span> can be chosenarbitrarily, for example <span class="math inline">\(n_0=(1,0,0)\)</span>.</li><li>The angle between <span class="math inline">\(n_1\)</span> and <span class="math inline">\(n_0\)</span> is <span class="math inline">\(3\pi/4\)</span>, so we can choose <span class="math inline">\(n_1\)</span> to be <span class="math inline">\(n_1=(\cos\dfrac{3\pi}{4}, \sin\dfrac{3\pi}{4},0)\)</span>.</li><li>The normal of <span class="math inline">\(m_2\)</span> isperpendicular to <span class="math inline">\(n_0\)</span>, so <span class="math inline">\(n_2\)</span> has the form <span class="math inline">\((0,y_3,z_3)\)</span>. Using <span class="math inline">\(\langle n_1,n_2\rangle=2\pi/3\)</span>, we have<span class="math inline">\(y_3\sin\dfrac{3\pi}{4}=\cos\dfrac{2\pi}{3}\)</span>,and since <span class="math inline">\(z_3\)</span> is a unit vector,<span class="math inline">\(z_3=\sqrt{1−y_3^2}\)</span>. We can solvethese two equations to obtain <span class="math inline">\(y_3,z_3\)</span>.</li></ol><p>To choose an initial vertex <span class="math inline">\(v_0\)</span>that lies on both <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> but not on <span class="math inline">\(m_0\)</span>, we can choose <span class="math inline">\(v_0\)</span> so that its distance to <span class="math inline">\(m_0\)</span> is 1 and its distance to <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> are both 0:</p><p><span class="math display">\[\begin{align*}\langle v_0,n_0\rangle=1,\\\langle v_0, n_1\rangle=0,\\\langle v_0,n_2\rangle=0.\\\end{align*}\]</span></p><p>Then solve this linear system to get <span class="math inline">\(v_0\)</span>.</p><p>As mentioned before the angles between the mirrors must be chosencarefully to ensure <span class="math inline">\(v_0\)</span> and itsvirtual images form the vertices of an uniform polytope, this restrictsus to only finitely many choices of Coxeter diagrams, you can refer tothis <a href="https://en.wikipedia.org/wiki/Uniform_polytope">wikipage</a> for the complete list.</p><p>The answer to the second question is called the Todd-Coxeteralgorithm, I’ll discuss it in the next section.</p><h1 id="finitely-presented-groups-and-todd-coxeter-algorithm">Finitelypresented groups and Todd-Coxeter algorithm</h1><p>How can we obtain all the virtual images of the initial vertex <span class="math inline">\(v_0\)</span> with respect to all mirrors? Anobvious but crude method is to repeatedly reflect <span class="math inline">\(v_0\)</span> about the mirrors and compare theresulting images with the set of virtual images obtained so far (withina predefined rounding error bound) until no new virtual images emerge.This approach is easy to program but it’s unappealing from amathematician’s perspective, as it fails to utilize the abundantsymmetries inherent in the polytope.</p><p>This program takes a “symbolic computation” approach by solving the<a href="https://en.wikipedia.org/wiki/Coset_enumeration">cosetenumeration problem</a> in the symmetry group. It offers the advantageof providing exact information about the polytope without resorting torounding errors or approximation procedures. However, the price we payis that the math involved is somewhat complex (and hence so is thecode), and readers should have some basic knowledge of group theory tounderstand it.</p><p>Firstly, let’s recall the <a href="https://en.wikipedia.org/wiki/Group_action_(mathematics)#Orbit-stabilizer_theorem">orbit-stabilizertheorem</a> from group theory:</p><blockquote><p><strong>Theorem</strong>: Suppose a group <span class="math inline">\(G\)</span> acts transitively on a set <span class="math inline">\(S\)</span>, and let <span class="math inline">\(x\in S\)</span> have stabilizer subgroup <span class="math inline">\(H\leq G\)</span>. Then there exists a one-to-one correspondence between<span class="math inline">\(S\)</span> and the right cosets of <span class="math inline">\(G/H\)</span>: <span class="math inline">\(x \cdotg \mapsto Hg\)</span>.</p></blockquote><p>Note that the action of <span class="math inline">\(G\)</span> on<span class="math inline">\(S\)</span> is written as “applying on theright”, this is mainly for programming convenience and has nosignificant difference from applying on the left.</p><p>The theorem mentioned above tells us that if a group <span class="math inline">\(G\)</span> acts transitively on a set <span class="math inline">\(S\)</span> and we know the stabilizing subgroup ofsome <span class="math inline">\(x\in S\)</span> in <span class="math inline">\(G\)</span> is <span class="math inline">\(H\)</span>, then we can recover the entire orbit<span class="math inline">\(S\)</span> by applying a set of cosetrepresentatives of <span class="math inline">\(G/H\)</span> to <span class="math inline">\(x\)</span>.</p><p>Therefore, to compute all vertices of a given uniform polytope <span class="math inline">\(P\)</span>, we can follow these steps:</p><ol type="1"><li>Obtain a presentation of the symmetry group <span class="math inline">\(G\)</span> and the coordinates of an initialvertex <span class="math inline">\(v_0\)</span> from the Coxeter-Dynkindiagram.</li><li>Obtain a presentation of the stabilizing subgroup <span class="math inline">\(H\)</span> of <span class="math inline">\(v_0\)</span> in <span class="math inline">\(G\)</span> and calculate a set of right cosetrepresentatives of <span class="math inline">\(G/H\)</span>.</li><li>Apply these representatives to <span class="math inline">\(v_0\)</span> to obtain all vertices of <span class="math inline">\(P\)</span>.</li></ol><p>Again we use the cube as an example to show this procedure: recallthe Coxeter-Dynkin diagram of the cube is</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="250"></p><p>The mirrors of the cube are <span class="math inline">\(m_0,m_1,\)</span> and <span class="math inline">\(m_2\)</span>, with normals<span class="math inline">\(n_0, n_1,\)</span> and <span class="math inline">\(n_2\)</span>, respectively, all of which are unitvectors. The reflections about these mirrors are denoted as <span class="math inline">\(\rho_0, \rho_1,\)</span> and <span class="math inline">\(\rho_2\)</span>, and the matrix of <span class="math inline">\(\rho_i\)</span> is <span class="math inline">\(M_i= I - 2n_in_i^T\)</span> (see <a href="https://en.wikipedia.org/wiki/Householder_transformation">Householdertransformation</a>).</p><p>The symmetry group <span class="math inline">\(G\)</span> of the cubeis generated by the three aforementioned “generator reflections”: <span class="math inline">\(\rho_0, \rho_1,\)</span> and <span class="math inline">\(\rho_2\)</span>. A presentation of the groupis:</p><p><span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p>This is because a reflection always has order 2 and since <span class="math inline">\(\rho_0\)</span> and <span class="math inline">\(\rho_1\)</span> are two reflections with an angleof <span class="math inline">\(3\pi/4\)</span> between their mirrors,<span class="math inline">\(\rho_0\rho_1\)</span> is a rotation aboutthe line of intersection of their mirrors with an angle of <span class="math inline">\(3\pi/2\)</span>. Therefore, <span class="math inline">\((\rho_0\rho_1)^4=1\)</span>. Similarly, we havethe relations for <span class="math inline">\(\rho_1\rho_2\)</span> and<span class="math inline">\(\rho_0\rho_2\)</span>.</p><blockquote><p><strong>Note</strong>: It is natural to wonder if we might be missingsome “hidden” relations. For convex polytopes, the answer is no, but forcertain star polytopes, the answer is yes. In these cases, we need toadd extra relations to ensure the procedure works correctly. Asignificant difference is that, in convex cases, the symmetry groupalways maps the interior of the fundamental domain to another disjointone, whereas in star polytopes, the fundamental domain may be coveredmultiple times by other domains. For more information, refer toVinberg’s paper “Discrete linear groups generated by reflections”.</p></blockquote><p>One can employ the Todd-Coxeter algorithm (which will be explainedlater) to calculate a comprehensive list of all 48 elements in <span class="math inline">\(G\)</span>.</p><p><span class="math display">\[\begin{array}{lll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{0}&amp;\rho_{1}&amp;\rho_{0}\rho_{2}\\\rho_{2}&amp;\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\end{array}\]</span></p><p>Since the initial vertex <span class="math inline">\(v_0\)</span> ison <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> but not on <span class="math inline">\(m_0\)</span> in the Coxeter-Dynkin diagram, onlythe mirror <span class="math inline">\(m_0\)</span> is active. Thus,both <span class="math inline">\(\rho_1\)</span> and <span class="math inline">\(\rho_2\)</span> map <span class="math inline">\(v_0\)</span> to itself, while <span class="math inline">\(\rho_0\)</span> maps <span class="math inline">\(v_0\)</span> to its virtual image about <span class="math inline">\(m_0\)</span>. Therefore, the stabilizing subgroupof <span class="math inline">\(v_0\)</span> is given by:</p><p><span class="math display">\[H=\langle \rho_1, \rho_2\ |\\rho_1^2=\rho_2^2=(\rho_1\rho_2)^3=e\rangle.\]</span></p><blockquote><p><strong>Note</strong>: You may wonder if we can only claim that thesubgroup generated by <span class="math inline">\({\rho_0,\rho_1}\)</span> is contained in thestabilizing subgroup of <span class="math inline">\(v_0\)</span> but maynot be exactly equal to it. Indeed, this is a possibility. However, forCoxeter groups, it is a property that in the geometric realization of aCoxeter group <span class="math inline">\(W\)</span> (that is,representing <span class="math inline">\(W\)</span> as a set ofreflections about hyperplanes in <span class="math inline">\(\mathbb{R}^n\)</span>), the stabilizing subgroupof any point <span class="math inline">\(v\)</span> in the fundamentaldomain is a standard parabolic subgroup generated by those simplereflections whose hyperplanes contain <span class="math inline">\(v\)</span>. This may seem like an obviousgeometric intuition, but it requires a quite non-trivial proof, whichcan be found in Humphreys’s book “Reflection Groups and Coxeter Groups”,chapter 1.</p></blockquote><p>It is clear that <span class="math inline">\(H\)</span> is thedihedral group <span class="math inline">\(D_3\)</span>, thus <span class="math inline">\(|H|=6\)</span> and <span class="math inline">\(|G/H|=8\)</span>. Using the Todd-Coxeteralgorithm, we can obtain a complete list of coset representatives for<span class="math inline">\(G/H\)</span>:</p><p><span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span></p><p>Applying these coset representatives to <span class="math inline">\(v_0\)</span> gives us the 8 vertices of the cube.For example, the action of <span class="math inline">\(\rho_0\rho_1\)</span> on <span class="math inline">\(v_0\)</span> is as follows:</p><p><span class="math display">\[v_0(\rho_0\rho_1)=(v_0\rho_0)\rho_1=(v_0M_0)\rho_1=v_0M_0M_1.\]</span></p><p>Here, <span class="math inline">\(v_0\)</span> is represented as arow vector since all <span class="math inline">\(M_i\)</span>’s aresymmetric matrices.</p><p>We can also use the same procedure to find all edges and faces of thecube. To find all edges of type <span class="math inline">\(i\)</span>,we proceed as follows:</p><ol type="1"><li>Check if the initial vertex <span class="math inline">\(v_0\)</span>lies on the mirror <span class="math inline">\(m_i\)</span>. If it does,then the reflection <span class="math inline">\(\rho_i\)</span> fixes<span class="math inline">\(v_0\)</span>, and there are no edges of type<span class="math inline">\(i\)</span>. Otherwise, let <span class="math inline">\(v_1=\rho_i(v_0)\)</span>. Then, the segment <span class="math inline">\((v_0,v_1)\)</span> forms an edge <span class="math inline">\(e\)</span> of type <span class="math inline">\(i\)</span></li><li>To find the stabilizing subgroup of <span class="math inline">\(e\)</span>, we note that a symmetry fixes <span class="math inline">\(e\)</span> if and only if it fixes the midpoint<span class="math inline">\(p\)</span> of <span class="math inline">\(e\)</span>. Thus, the stabilizing subgroup of<span class="math inline">\(e\)</span> is the same as the stabilizingsubgroup of <span class="math inline">\(p\)</span>. From the previouscomment, we know that this subgroup is generated by those simplereflections whose mirrors contain <span class="math inline">\(p\)</span>. These mirrors are either <span class="math inline">\(m_i\)</span> (bisects <span class="math inline">\(e\)</span>), or those containing <span class="math inline">\(v_0\)</span> and orthogonal to <span class="math inline">\(m_i\)</span> (contain <span class="math inline">\(e\)</span>), so the stabilizing subgroup of <span class="math inline">\(e\)</span> is generated by <span class="math inline">\(\rho_i\)</span> and those simple reflections thatfix <span class="math inline">\(v_0\)</span> and commute with <span class="math inline">\(\rho_i\)</span>. In the case of the cube, we have<span class="math inline">\(H=\langle \rho_0,\rho_2\rangle\)</span>, so<span class="math inline">\(|H|=4\)</span> and <span class="math inline">\(|G/H|=12\)</span>, confirming that the cube has 12edges.</li><li>We then find a set of coset representatives of <span class="math inline">\(G/H\)</span> and apply them to <span class="math inline">\(e\)</span> to obtain all edges of type <span class="math inline">\(i\)</span>.</li></ol><p>To find all faces of type <span class="math inline">\((i,j)\)</span>,where <span class="math inline">\(i\neq j\)</span>, we use the sameprocedure. If at least one of <span class="math inline">\(m_i,m_j\)</span> is active, then the rotation<span class="math inline">\(r_{ij}=\rho_i\rho_j\)</span> generates aface <span class="math inline">\(f\)</span> of type <span class="math inline">\((i,j)\)</span>, which is invariant under <span class="math inline">\(\rho_i\)</span> and <span class="math inline">\(\rho_j\)</span>. However, if <span class="math inline">\(v_0\)</span> lies on exactly one of the twomirrors and they are perpendicular, we need to be careful. In this case,the stabilizing subgroup of <span class="math inline">\(f\)</span> isgenerated by <span class="math inline">\(\rho_i\)</span>, <span class="math inline">\(\rho_j\)</span>, and those generators that fix<span class="math inline">\(v_0\)</span> and commute with both <span class="math inline">\(\rho_i\)</span> and <span class="math inline">\(\rho_j\)</span>. We then find a set of cosetrepresentatives of <span class="math inline">\(G/H\)</span> and applythem to <span class="math inline">\(f\)</span> to obtain all faces oftype <span class="math inline">\((i,j)\)</span>.</p><p>Now the key step is to compute a set of coset representatives of<span class="math inline">\(G/H\)</span> for a finitely presented group<span class="math inline">\(G\)</span> and its subgroup <span class="math inline">\(H\)</span>, which is exactly what the Todd-Coxeteralgorithm does.</p><p>The Todd-Coxeter algorithm can be thought of as a Sudoku game wherethe table to complete is a dynamically growing 2D array <span class="math inline">\(T\)</span>. The rows of <span class="math inline">\(T\)</span> are labeled by the right cosets in<span class="math inline">\(G/H\)</span>, and the columns of <span class="math inline">\(T\)</span> are labeled by the generators of <span class="math inline">\(G\)</span>. Each entry <span class="math inline">\(T[i][j]\)</span> records the right coset obtainedby multiplying the <span class="math inline">\(j\)</span>-th generatoron the right of the <span class="math inline">\(i\)</span>-th coset. Thealgorithm uses the defining relations in the presentation of <span class="math inline">\(G\)</span> and <span class="math inline">\(H\)</span> as guidelines to find new cosets andfill their corresponding entries in <span class="math inline">\(T\)</span>. The game ends when all entries in<span class="math inline">\(T\)</span> are filled, and the coset in eachentry has a row in <span class="math inline">\(T\)</span> and satisfiesall relations. The resulting <span class="math inline">\(T\)</span> isthe adjacency matrix of the Schreier graph of <span class="math inline">\(G/H\)</span>, and one can easily obtain a completelist of word representations for all cosets in <span class="math inline">\(G/H\)</span>.</p><p>For a more detailed treatment of the Todd-Coxeter algorithm, pleaserefer to the Handbook of Computational Group Theory (HCGT) or otherrelated literature.</p><blockquote><p>Chapter 5, Handbook of Computational Group Theory, Holt, D., Eick,B., O’Brien, E.</p></blockquote><p>I will demonstrate below how the algorithm works using the cube as anexample:</p><blockquote><p><strong>Example</strong>: let <span class="math inline">\(G\)</span>be the symmetric group of the cube: <span class="math display">\[\begin{align*}G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2&amp;=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3\\&amp;=(\rho_0\rho_2)^2=1\rangle.\end{align*}\]</span>and subgroup <span class="math inline">\(H=\langle \rho_1,\rho_2\rangle\)</span>. Find a set of coset representatives of <span class="math inline">\(G/H\)</span>.</p></blockquote><p><strong>Our known relations</strong>:</p><ol type="1"><li>For each generator word <span class="math inline">\(w\)</span> of<span class="math inline">\(H\)</span>, it holds <span class="math inline">\(Hw=H\)</span>, i.e.&nbsp;<span class="math inline">\(H\rho_1=H\)</span> and <span class="math inline">\(H\rho_2=H\)</span>.</li><li>For any coset <span class="math inline">\(K\)</span> and anygenerator relation <span class="math inline">\(r\)</span> of <span class="math inline">\(G\)</span> it holds <span class="math inline">\(Kr=K\)</span>, i.e.&nbsp;<span class="math inline">\(K\rho_i^2=K,i=0,1,2\)</span>, and <span class="math inline">\(K(\rho_0\rho_1)^4=K(\rho_1\rho_2)^3=K(\rho_0\rho_2)^2=K.\)</span></li></ol><p>These relations can be stored in two lists, one for the relations in<span class="math inline">\(H\)</span> and one for the relations in<span class="math inline">\(G\)</span>, each relation can be furtherstored as an array of int type.</p><p>The first list stores the generator words of <span class="math inline">\(H\)</span>:</p><blockquote><ol start="0" type="1"><li>(1,) // <span class="math inline">\(\rho_1\)</span></li><li>(2,) // <span class="math inline">\(\rho_2\)</span></li></ol></blockquote><p>The second list stores the defining relations of <span class="math inline">\(G\)</span>:</p><blockquote><ol start="2" type="1"><li>(0, 0) // <span class="math inline">\(\rho_0^2=1\)</span></li><li>(1, 1) // <span class="math inline">\(\rho_1^2=1\)</span></li><li>(2, 2) // <span class="math inline">\(\rho_2^2=1\)</span></li><li>(0, 1, 0, 1, 0, 1, 0, 1) // (<span class="math inline">\(\rho_0\rho_1)^4=1\)</span></li><li>(1, 2, 1, 2, 1, 2) // (<span class="math inline">\(\rho_1\rho_2)^3=1\)</span></li><li>(0, 2, 0, 2) // (<span class="math inline">\(\rho_0\rho_2)^2=1\)</span></li></ol></blockquote><p>The relations are numbered from 0 to 7 for easy reference in thefollowing steps.</p><blockquote><p><strong>Note</strong>: When <span class="math inline">\(G\)</span> isnot represented as a Coxeter group, for example in the case of snubpolytopes, we need to consider the inverse of the generators as well,and they also occupy their own columns in <span class="math inline">\(T\)</span>. Therefore, the actual number ofcolumns in <span class="math inline">\(T\)</span> is twice the number ofgenerators. However, for Coxeter groups, all generators are involutions,so there is no need to insert columns for their inverses.</p></blockquote><p>Initially, the table <span class="math inline">\(T\)</span> has onlyone row, corresponding to the coset <span class="math inline">\(H\)</span> (which is the only coset we know atthis point).</p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>Here, the algorithm initializes <span class="math inline">\(H_0\)</span> to be the subgroup <span class="math inline">\(H\)</span> and checks if it satisfies allrelations in the first list. Once this check is done, the first list canbe discarded. Then, the algorithm scans all cosets of <span class="math inline">\(T\)</span> from top to bottom and verifies if thecurrent coset satisfies all relations in the second list. During thisprocess, new cosets may be defined and their rows are appended at theend of <span class="math inline">\(T\)</span>. However, it is importantto note that some cosets in the table may actually represent the samecoset, so care must be taken.</p><hr><p>Let’s start by scanning <span class="math inline">\(H_0\)</span> andchecking whether the relations in the first list are satisfied byit:</p><ol type="1"><li>For relation 0, we have <span class="math inline">\(H_0\rho_1=H_0\)</span>, i.e., <span class="math inline">\(T[0][1]=0\)</span>.</li><li>For relation 1, we have <span class="math inline">\(H_0\rho_2=H_0\)</span>, i.e., <span class="math inline">\(T[0][2]=0\)</span>.</li></ol><p><span class="math inline">\(T\)</span> is now updated as follows:</p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><p><strong>Now that <span class="math inline">\(H_0\)</span> satisfiesall relations in the first list, we can discard it and focus on checkingthe relations in the second list</strong>.</p><p>We move on to check the relations in the second list for <span class="math inline">\(H_0\)</span>:</p><p>(2). Relation 2 says <span class="math inline">\(H_0\rho_0^2=H_0\)</span>. Since we do not know<span class="math inline">\(H_0\rho_0\)</span> yet, we define it to be<span class="math inline">\(H_1\)</span>, fill in 1 in its entry <span class="math inline">\(T[0][0]\)</span>, and append a new row for <span class="math inline">\(H_1\)</span>:</p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><strong>Note that each time we define or find <span class="math inline">\(H_i\rho_j=H_k\)</span> for some <span class="math inline">\(i,j,k\)</span>, we automatically get the “dual”relation <span class="math inline">\(H_k\rho_j=H_i\)</span>. Therefore,we always fill in a pair of entries <span class="math inline">\(T[i][j]=k\)</span> and <span class="math inline">\(T[k][j]=i\)</span> at a time</strong>.</p><p>(3). Relations 3 and 4 are already satisfied, so we continue.</p><p>(4). Relation 5 says <span class="math inline">\(H_0\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1=H_0\)</span>.We already know <span class="math inline">\(H_0\rho_0=H_1\)</span>, but<span class="math inline">\(H_1\rho_1\)</span> is unknown, so we defineit to be <span class="math inline">\(H_2\)</span>. We fill in the twoentries <span class="math inline">\(T[1][3]=2\)</span> and <span class="math inline">\(T[2][3]=1\)</span> and append a new row for <span class="math inline">\(H_2\)</span>.</p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><span class="math inline">\(H_2\rho_0\)</span> is not yet defined, sowe set <span class="math inline">\(H_2\rho_0=H_3\)</span> and update thecorresponding entries in <span class="math inline">\(T\)</span>:</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>Continuing with the scan, we notice that <span class="math inline">\(H_3\rho_1\)</span> is unknown, and we might betempted to define it as a new coset <span class="math inline">\(H_4\)</span> and continue. However, this strategycan create many redundant cosets, leading to a rapid growth of <span class="math inline">\(T\)</span>. Instead, we scan the relation inreverse order, trying to fill the gaps without introducing new cosets.Recall that we scanned from left to right, and we arrived at thefollowing position: <span class="math display">\[H_0\rho_0\rho_1\rho_0(=H_3)\rho_1\rho_0\rho_1\rho_0\rho_1=H_0.\]</span>Now, scanning from right to left, we get <span class="math inline">\(H_0\rho_1\rho_0\rho_1\rho_0=H_3\)</span>, whichmeans that <span class="math display">\[H_0\rho_0\rho_1\rho_0(=H_3)\rho_1=H_0\rho_1\rho_0\rho_1\rho_0=H_3.\]</span> Thus, we have deduced that<span class="math inline">\(H_3\rho_1=H_3\)</span>, instead of definingit as a new coset. This technique is called a<strong>deduction</strong>, as described in the book HCGT. Therefore, weupdate <span class="math inline">\(T\)</span> accordingly:</p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><strong>So in the actual program we always scan a relation from bothends and define new cosets if necessary until they meet</strong>.</p><p>(5). Relation 6 is already satisfied, continue.</p><p>(6). Relation 7 says <span class="math inline">\(H_0\rho_0\rho_2\rho_0\rho_2=H_0\)</span>, scanningfrom both ends gives <span class="math display">\[H_0\rho_0(=H_1)\rho_2=H_0\rho_2\rho_0=H_1,\]</span>hence <span class="math inline">\(H_1\rho_2=H_1\)</span> and we makeanother deduction. <span class="math inline">\(T\)</span> nowbecomes</p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>Now, <span class="math inline">\(H_0\)</span> satisfies all relationsin the two lists and the scanning of the first row is completed. We canmove on to begin scanning of the row for <span class="math inline">\(H_1\)</span>. Note the first list is nowdiscarded, and we will only check relations 2-7.</p><p>(1). Relations 2, 3, 4, and 5 are already satisfied. We can continueto the next relation. (2). Relation 6 says <span class="math inline">\(H_1\rho_1\rho_2\rho_1\rho_2\rho_1\rho_2=H_1\)</span>.We know that <span class="math inline">\(H_1\rho_1=H_2\)</span>, but<span class="math inline">\(H_2\rho_2\)</span> is unknown. Backwardscanning also gets stuck here: <span class="math display">\[H_1\rho_1(=H_2)\rho_2\rho_1=H_1\rho_2\rho_1\rho_2=H_2\rho_2.\]</span>So we define <span class="math inline">\(H_2\rho_2=H_4\)</span>. Then wehave <span class="math inline">\(H_4\rho_1=H_4\)</span>, and <span class="math inline">\(T\)</span> becomes:</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr></tbody></table><ol start="3" type="1"><li>Relation 7 is already satisfied for <span class="math inline">\(H_1\)</span>, so we can move on to scan the rowfor <span class="math inline">\(H_2\)</span>.</li></ol><hr><p>I’ll leave it as an exercise for you to complete the scanning of<span class="math inline">\(H_2\)</span>, <span class="math inline">\(H_3\)</span>, <span class="math inline">\(H_4\)</span>, and <span class="math inline">\(H_5\)</span>. These are relatively easy tasks.Once <span class="math inline">\(H_2\)</span> has been scanned, your<span class="math inline">\(T\)</span> should look like this:</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">3</td></tr></tbody></table><p>After completing the scanning of <span class="math inline">\(H_3\)</span>, your <span class="math inline">\(T\)</span> should be:</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr></tbody></table><p>After completing the scanning for <span class="math inline">\(H_4\)</span>, your <span class="math inline">\(T\)</span> should be:</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>And when we scan <span class="math inline">\(H_6\)</span>, we findthat relations 2-6 are already satisfied. From relation 7, <span class="math inline">\(H_6\rho_0\rho_2\rho_0\rho_2=H_6\)</span>, we get adeduction <span class="math inline">\(H_7\rho_2=H_7\)</span>, and <span class="math inline">\(T\)</span> is updated as follows:</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td></tr></tbody></table><p>One can check that <span class="math inline">\(H_7\)</span> satisfiesall relations in the second list, so no more cosets can be found and thegame is over.</p><p>The multiplication relations between these cosets can be obtainedusing breadth-first search:</p><p><span class="math display">\[\begin{array}{l}H_0 = H_0\cdot e,\\H_1=H_0\cdot\rho_0,\\H_2=H_1\cdot\rho_1=H_0\cdot\rho_0\rho_1,\\H_3=H_2\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0,\\H_4=H_2\cdot\rho_2=H_0\cdot\rho_0\rho_1\rho_2,\\H_5=H_3\cdot\rho_2=H_0\cdot \rho_0\rho_1\rho_0\rho_2,\\H_6=H_5\cdot\rho_1=H_0\cdot \rho_0\rho_1\rho_0\rho_2\rho_1,\\H_7=H_6\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0\rho_2\rho_1\rho_0.\end{array}\]</span></p><p>So a set of representatives can be chosen as</p><p><span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span> This is exactly what we have seen before.</p><blockquote><p><strong>Note</strong>: This example is a bit tedious, but it is stilla simple one because we did not encounter the case where two cosets inthe table are found to be the same (in the book HCGT, this is called a<strong>coincidence</strong>). When this occurs, the scanning must bepaused, and the control flow is jumped to handle this coincidence: a newstack <span class="math inline">\(q\)</span> is opened, and this pair ofcoincidences is pushed into <span class="math inline">\(q\)</span>.Then, one pair of coincidences is popped from <span class="math inline">\(q\)</span> at a time, their rows are merged, andnew coincidences that occur in the merging process are pushed into <span class="math inline">\(q\)</span>.</p></blockquote><h1 id="snub-polytopes">Snub polytopes</h1><p>Snub polytopes can be constructed by applying rotations in the fullsymmetry group to the initial vertex <span class="math inline">\(v_0\)</span>. In the case of the cube, we haveseen the full symmetry group <span class="math inline">\(G\)</span>is</p><p><span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p><span class="math inline">\(G\)</span> consists of 48 elements, halfof which are rotations, so totaling 24 rotations. These rotationsconstitute the symmetry group <span class="math inline">\(\widetilde{G}\)</span> of the snub cube, which canbe generated by three fundamental rotations: <span class="math inline">\(r_0=\rho_0\rho_1\)</span>, <span class="math inline">\(r_1=\rho_1\rho_2\)</span>, and <span class="math inline">\(r_2=\rho_0\rho_2\)</span>. Since <span class="math inline">\(r_0r_1=r_2\)</span>, it follows that <span class="math inline">\(\widetilde{G}\)</span> can be generated by only<span class="math inline">\(r_0\)</span> and <span class="math inline">\(r_1\)</span>.</p><p>A presentation of <span class="math inline">\(\widetilde{G}\)</span>is <span class="math display">\[\widetilde{G}=\langle r_0,r_1\ |\r_0^4=r_1^3=(r_0r_1)^2=1\rangle.\]</span> Using the Todd-Coxeteralgorithm, we can obtain a complete list of word representations of<span class="math inline">\(\widetilde{G}\)</span>:</p><p><span class="math display">\[\begin{array}{lll}e&amp;r_{0}&amp;r_{0}r_{0}\\r_{0}r_{0}r_{0}&amp;r_{1}&amp;r_{1}r_{1}\\r_{0}r_{1}&amp;r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{1}\\r_{0}r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}\\r_{1}r_{0}r_{0}&amp;r_{1}r_{0}r_{0}r_{0}&amp;r_{1}r_{1}r_{0}\\r_{1}r_{1}r_{0}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}\\r_{0}r_{0}r_{1}r_{1}r_{0}&amp;r_{1}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}r_{0}r_{1}r_{1}\\r_{1}r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{1}r_{0}r_{0}r_{1}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}r_{1}\end{array}\]</span></p><p>We choose the initial vertex <span class="math inline">\(v_0\)</span>so that it’s not on any of the three mirrors, and apply the above wordrepresentations of <span class="math inline">\(\widetilde{G}\)</span> to<span class="math inline">\(v_0\)</span>. This gives the 24 vertices ofthe snub cube.</p><p>To obtain the edges of the snub cube, the following steps can betaken:</p><ol type="1"><li>Each rotation <span class="math inline">\(r_i\,(i=0,1,2)\)</span>generates a base edge <span class="math inline">\(e\)</span>. These baseedges are in different orbits under the action of <span class="math inline">\(\widetilde{G}\)</span>.</li><li>The stabilizing subgroup of <span class="math inline">\(e\)</span>is <span class="math inline">\(H=\langle 1\rangle\)</span> if the orderof <span class="math inline">\(r_i\)</span> is greater than 2, or thecyclic group <span class="math inline">\(H=\langle r_i\rangle\)</span>if the order of <span class="math inline">\(r_i\)</span> is 2. The cosetrepresentatives of <span class="math inline">\(G/H\)</span> can becomputed, and applied to <span class="math inline">\(e\)</span> toobtain all other edges of type <span class="math inline">\(i\)</span>.</li></ol><p>The case of faces is slightly more involved:</p><ol type="1"><li><p>Each rotation <span class="math inline">\(r_i\,(i=0,1)\)</span>generates a base face <span class="math inline">\(f={v_0,r_i(v_0),\ldots, r_i^{m-1}(v_0)}\)</span> for <span class="math inline">\(m&gt;2\)</span>, where <span class="math inline">\(m\)</span> is the order of <span class="math inline">\(r_i\)</span>. For <span class="math inline">\(i=2\)</span>, <span class="math inline">\(m=2\)</span>, and <span class="math inline">\(f\)</span> is degenerated to an edge. Thestabilizing subgroup of <span class="math inline">\(f\)</span> is thecyclic group <span class="math inline">\(H=\langle r_i\rangle\)</span>.The coset representatives of <span class="math inline">\(G/H\)</span>can be computed, and applied to <span class="math inline">\(f\)</span>to obtain all other faces of type <span class="math inline">\(i\)</span>. For the snub cube, there are <span class="math inline">\(6\)</span> square faces generated by <span class="math inline">\(r_0\)</span> (since <span class="math inline">\(24/|\langle r_0\rangle|=24/4=6\)</span>), and<span class="math inline">\(8\)</span> triangle faces generated by <span class="math inline">\(r_1\)</span> (since <span class="math inline">\(24/|\langle r_1\rangle|=24/3=8\)</span>).</p></li><li><p>There is another type of triangle faces which comes from therelation <span class="math inline">\(r_0r_1=r_2\)</span>. Let’s considerthe three vertices <span class="math inline">\({v_0,v_0r_1,v_0r_2}\)</span>. We see that <span class="math inline">\((v_0, v_0r_1)\)</span> is an edge of type 1 and<span class="math inline">\((v_0, v_0r_2)\)</span> is an edge of type 2.But we also have <span class="math display">\[(v_0,v_0r_0)\xrightarrow{\ r_1\ }(v_0r_1, v_0r_0r_1) = (v_0r_1,v_0r_2).\]</span> That is, <span class="math inline">\((v_0r_1,v_0r_2)\)</span> is an edge of type 0 obtained by applying <span class="math inline">\(r_1\)</span> to the base edge <span class="math inline">\((v_0, v_0r_0)\)</span>. The stabilizing subgroupof this triangle must be <span class="math inline">\(\langle1\rangle\)</span> since all its three edgesare in different orbits. Thereforre, we have <span class="math inline">\(|\widetilde{G}|/1=24\)</span> triangle faces ofthis “mixed type”, which are not generated by any of the “fundamentalrotations”.</p></li></ol><p>So the snub cube has <span class="math inline">\(6+8+24=38\)</span>faces in total.</p><h1 id="star-polytopes">Star polytopes</h1><p>Most star polytopes can be generated using the Wythoff construction,but generally, it is not enough to use the method described abovedirectly. You also need to add an additional generating relation intothe group’s presentation.</p><p>To illustrate, let’s take the great dodecahedron as an example. ItsCoxeter-Dynkin diagram is shown below:</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/coxeter552.svg" width="250"></p><p>Therefore, the angles between the mirrors are <span class="math inline">\(\pi-2\pi/5, \pi/2, \pi-\pi/5\)</span>. If wecontinue with the previous analysis, we obtain the presentation of thesymmetry group as:</p><p><span class="math display">\[K = \langle\tau_0,\tau_1,\tau_2 \|\  \tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=(\tau_0\tau_2)^2=1\rangle.\]</span></p><p>This group is infinite, and since the quotient group of thestabilizer subgroup of <span class="math inline">\(v_0\)</span> is alsoinfinite, the Todd-Coxeter algorithm will not work here.</p><p>In fact, we just need to add another generating relation to thepresentation, namely <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>. With thisaddition, the presentation of the symmetry group becomes:</p><p><span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>Note that I intentionally used <span class="math inline">\(\tau\)</span> to represent reflections and <span class="math inline">\(K\)</span> to denote the symmetry group of thegreat dodecahedron. What’s happening here? Let’s take a look at thevideo:</p><video src="/images/polytopes/great-dodecahedron.mp4" controls=""></video><p>From the video, we can observe that the great dodecahedron and theicosahedron share the exact same set of vertices. However, it seems thatthe great dodecahedron can be obtained by digging some triangular holeson the surface of the icosahedron. In general, if the hole of astar-shaped polyhedron is a polygon with <span class="math inline">\(h\)</span> sides, the corresponding extra relationis given by <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^h=1\)</span>.</p><p>Let’s take a closer look at the fundamental region of the greatdodecahedron:</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/star.png" width="600"></p><p>The figure above shows <span class="math inline">\(\DeltaABC\)</span> as the fundamental domain of the icosahedron. Its internalangles are <span class="math inline">\(\angle CAB=\pi/5\)</span>，<span class="math inline">\(\angle CBA=\pi/2\)</span>，<span class="math inline">\(\angle ACB=\pi/3\)</span>. Reflections about thearcs <span class="math inline">\(BC\)</span>, <span class="math inline">\(AC\)</span>, and <span class="math inline">\(AB\)</span> are denoted by <span class="math inline">\(\rho_0\)</span>, <span class="math inline">\(\rho_1\)</span>, and <span class="math inline">\(\rho_2\)</span>, respectively. The presentation ofthe symmetry group of icosahedron, <span class="math inline">\(G\)</span>, can be expressed as follows: <span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^3=(\rho_1\rho_2)^5=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p>The great dodecahedron can be constructed as follows: we keep thevertices and edges of the icosahedron untouched, but change its faces.To do this we start a walk from vertex <span class="math inline">\(Q\)</span> and move along edge <span class="math inline">\(QA\)</span> to reach the next vertex <span class="math inline">\(A\)</span>. At <span class="math inline">\(A\)</span>, we skip the first edge on the right(<span class="math inline">\(AO\)</span>) and choose the second one,which is <span class="math inline">\(AK\)</span>, to follow and move tovertex <span class="math inline">\(K\)</span> (sorry for abusing thenotation <span class="math inline">\(K\)</span> here). We continuemoving in this way by always choosing the second edge to the right. Ittakes five steps to return to <span class="math inline">\(Q\)</span>,forming a pentagonal face of the great dodecahedron. By performing thisoperation for all edges of the icosahedron, we can generate all thefaces of the great dodecahedron.</p><p>This operaion is called <strong>faceting</strong>, it changes thefaces of a given polyhedron while preserving its vertices and edges.This is achieved by walking along the edges of the original polyhedronand choosing the <span class="math inline">\(k\)</span>-th edge to theright of the current path, where <span class="math inline">\(k\geq2\)</span> is a fixed integer. By repeating this process until a closedloop is formed, a new face is created. In our project, we use <span class="math inline">\(k=2\)</span>.</p><p>Let’s derive the relations between the symmetry groups <span class="math inline">\(G\)</span> and <span class="math inline">\(K\)</span>:</p><p>Consider the triangle <span class="math inline">\(\DeltaOAB\)</span>, which has internal angles <span class="math inline">\(\angle OAB=2\pi/5\)</span>, <span class="math inline">\(\angle OBA=\pi/2\)</span>, and <span class="math inline">\(\angle AOB=\pi/5\)</span>, and contains threecongruent triangles with the triangle <span class="math inline">\(\DeltaABC\)</span>. The reflections about its three edges <span class="math inline">\(OA\)</span>, <span class="math inline">\(OB\)</span>, and <span class="math inline">\(AB\)</span> are denoted by <span class="math inline">\(\tau_1=\rho_1\rho_2\rho_1\)</span>, <span class="math inline">\(\tau_0=\rho_0\)</span>, and <span class="math inline">\(\tau_2=\rho_2\)</span>.</p><p>In the language of group theory, the faceting operation <span class="math inline">\(\varphi_k\)</span> can be described astransforming the group <span class="math inline">\(G\)</span> intoanother group <span class="math inline">\(K\)</span>:</p><p><span class="math display">\[G=\langle\rho_0,\rho_1,\rho_2\rangle\xrightarrow{\ \varphi_k\}\langle\rho_0,\rho_1(\rho_2\rho_1)^{k-1},\rho_2\rangle=\langle\tau_0,\tau_1,\tau_2\rangle=K.\]</span></p><p>Usually, <span class="math inline">\(K\)</span> is a subgroup of<span class="math inline">\(G\)</span>, but in many cases, including thegreat dodecahedron here, <span class="math inline">\(G\)</span> and<span class="math inline">\(K\)</span> are the same group.</p><p>To see that <span class="math inline">\(K\)</span> is indeed thesymmetry group of the great dodecaheron, we can argue as follows:</p><p>Firstly, <span class="math inline">\(\langle\tau_1,\tau_2\rangle=\langle \rho_1,\rho_2\rangle\)</span> is thestabilizer subgroup of the vertex <span class="math inline">\(A\)</span>, so the great dodecahedron has the sameset of vertices as that of the icosahedron. However, <span class="math inline">\(\tau_1\tau_2\)</span> gives a rotation of <span class="math inline">\(4\pi/5\)</span>, which differs from <span class="math inline">\(\rho_1\rho_2\)</span> that gives a rotation of<span class="math inline">\(2\pi/5\)</span>. Consequently, the vertexconfiguration of the great dodecahedron forms a pentagram, whereas thatof the icosahedron forms a pentagon.</p><p>Secondly, the subgroup <span class="math inline">\(\langle\tau_0,\tau_2\rangle=\langle \rho_0,\rho_2\rangle\)</span> is thestabilizer of the edge <span class="math inline">\(AQ\)</span>. Thus,the great dodecahedron shares its edges with those of theicosahedron.</p><p>Thirdly, <span class="math inline">\(\langle\tau_0,\tau_1\rangle\)</span> is thestabilizer subgroup of one of the faces of the great dodecahedron. Notethat <span class="math inline">\(\tau_0\tau_1\)</span> is a rotation of<span class="math inline">\(2\pi/5\)</span> arounds <span class="math inline">\(O\)</span>. It maps the edge <span class="math inline">\(QA\)</span> to the edge <span class="math inline">\(AK\)</span>, corresponding to the operation ofselecting the <span class="math inline">\(k\)</span>-th edge to walk on.Repeatedly applying <span class="math inline">\(\tau_0\tau_1\)</span> to<span class="math inline">\(QA\)</span> will give the five edges of oneface of the great dodecahedron.</p><p>Let’s find out a hidden relation among <span class="math inline">\(\tau_0,\tau_1\)</span> and <span class="math inline">\(\tau_2\)</span>:</p><p>Note that <span class="math inline">\(\tau_1\tau_2\tau_1=\tau_1\rho_2\tau_1\)</span> isa reflection about <span class="math inline">\(AP\)</span>, and itscomposition with <span class="math inline">\(\tau_0=\rho_0\)</span> is arotation around the vertex <span class="math inline">\(P\)</span> by anangle of <span class="math inline">\(2\pi/3\)</span>, so <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>. Addingthis additional generating relation to the presentation of gives thecorrect presentation of <span class="math inline">\(K\)</span>:</p><p><span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>The remaining steps of the construction are identical to the previousones.</p><p>This extra relation has a geometric explanation: By applying thefaceting operation to the great dodecahedron again, we can restore ouricosahedron. We simply walk from <span class="math inline">\(Q\)</span>to <span class="math inline">\(A\)</span>, and when we reach <span class="math inline">\(A\)</span>, instead of selecting the edge <span class="math inline">\(AK\)</span> to continue moveing, we choose itsprevious one clockwise, which is <span class="math inline">\(AO\)</span>. Continuing to walk gives us back thetriangle face <span class="math inline">\(\Delta OAB\)</span> of theicosahedron. This correspondes to the exponent 3 in the extrarelation.</p><p>In terms of group theory, this can be expressed as <span class="math display">\[K=\langle\tau_0,\tau_1,\tau_2\rangle\xrightarrow{\ \varphi_2\}\langle\tau_0,\tau_1\tau_2\tau_1,\tau_2\rangle=\langle\rho_0,\rho_2\rho_1\rho_2,\rho_2\rangle=G.\]</span></p><p>One might wonder if there are more such relationships we haveoverlooked. However, since we know that <span class="math inline">\(K\)</span> is isomorphic to <span class="math inline">\(G\)</span> (though not proved in this article),there’s no cause for concern.</p><h1 id="appendix">Appendix</h1><p>I also added a script <code>run_coset_enumeration.py</code> forshowing how to compute the coset table of <span class="math inline">\(G/H\)</span> for a given finitely presented group<span class="math inline">\(G\)</span> and its subgroup <span class="math inline">\(H\)</span> (necessarily <span class="math inline">\(|G/H|&lt;\infty\)</span>). It assumes a<code>yaml</code> file as input which describes the presentation of<span class="math inline">\(G\)</span> and <span class="math inline">\(H\)</span>. An example format is</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">G8723</span><br><span class="hljs-attr">relators:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">a^8</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">b^7</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">(ab)^2</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">(Ab)^3</span><br><span class="hljs-attr">subgroup-generators:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">aa</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Ab</span><br></code></pre></td></tr></tbody></table></figure><p>Here we use the convention that uppercase means the inverse oflowercase, i.e.&nbsp;<span class="math inline">\(A=a^{-1},B=b^{-1}\)</span>.</p><p>So the presentation of this group is <span class="math display">\[G =\langle a, b\ |\ a^8=b^7=(ab)^2=(a^{-1}b)^3=1\rangle\]</span> and <span class="math inline">\(H=\langle a^2, a^{-1}b\rangle\)</span>.</p><p>Save this file as <code>G8723.yaml</code> and run </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python run_coset_enumeration.py G8723.yaml<br></code></pre></td></tr></tbody></table></figure> Theoutput should be (with some output omitted)<p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">           a    A    b    B<br>------------------------------<br>    1:     2    2    3    2<br>    2:     1    1    1    4<br>    3:     4    5    6    1<br>    4:     7    3    2    8<br>  ...    ...  ...  ...  ...<br>  ...    ...  ...  ...  ...<br>  ...    ...  ...  ...  ...<br>  446:   444  444  441  430<br>  447:   438  433  432  443<br>  448:   445  445  440  445<br></code></pre></td></tr></tbody></table></figure><p>so <span class="math inline">\(G/H\)</span> has 448 cosets.</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd Kemp 概率论课程笔记</title>
      <link href="/todd-kemp/bak2.html"/>
      <url>/todd-kemp/bak2.html</url>
      
        <content type="html"><![CDATA[<h1 id="kolmogorovs-extension-theorem">16.1/16.2 Kolmogorov’s ExtensionTheorem</h1><p>这两讲的目的是介绍 Kolmogorov扩张定理，即构造无穷乘积可测空间使得其有限维分布为给定的、满足相容性条件的有限维分布。</p><p>Kolmogorov扩张定理看起来是一个纯测度论定理，但它本质与空间的拓扑性质有关。</p><p>设 <span class="math inline">\(I\)</span> 是指标集，<span class="math inline">\(\{\mathcal{A}_i,\, i\in I\}\)</span>是某个样本空间 <span class="math inline">\(\Omega\)</span> 的一族子<span class="math inline">\(\sigma-\)</span> 代数（每个 <span class="math inline">\(\mathcal{A}_i\)</span> 都是一个 <span class="math inline">\(\sigma-\)</span> 代数），满足条件：对任何两个<span class="math inline">\(\sigma-\)</span> 代数 <span class="math inline">\(\mathcal{A}_\alpha,\mathcal{A}_\beta\)</span>，都存在<span class="math inline">\(\mathcal{A}_\gamma\)</span> （<span class="math inline">\(\mathcal{A}_\gamma\)</span> 未必唯一）使得 <span class="math inline">\(\mathcal{A}_\alpha\subset\mathcal{A}_\gamma,\,\mathcal{A}_\beta\subset\mathcal{A}_\gamma\)</span>。</p><p>设 <span class="math inline">\(\mathbb{P}_i\)</span> 是 <span class="math inline">\(\mathcal{A}_i\)</span> 上的概率测度，如果对任何<span class="math inline">\(\mathcal{A}_\alpha\subset\mathcal{A}_\gamma\)</span>还有 <span class="math display">\[\mathbb{P}_\gamma \big|_{A_\alpha} =\mathbb{P}_\alpha.\]</span> 这时我们就称概率空间 <span class="math inline">\(\{(\mathcal{A}_i,\mathbb{P}_i)\}\)</span><strong>满足 Kolmogorov 相容性条件</strong>。</p><p>这就自然地引出一个问题：是否存在代数 <span class="math inline">\(\mathcal{A}=\cup_{i\in I}\mathcal{A}_i\)</span>上存在一个可数可加的概率测度 <span class="math inline">\(\mathbb{P}\)</span>，使得它是所有 <span class="math inline">\(\mathbb{P}_i\)</span> 的扩张？即对任何 <span class="math inline">\(\mathcal{A}_i\)</span> 都有 <span class="math inline">\(\mathbb{P}\big|_{\mathcal{A}_i}=\mathbb{P}_i\)</span>？如果有这样的 <span class="math inline">\(\mathbb{P}\)</span>，我们就可以用 Carathéodory定理将 <span class="math inline">\(\mathbb{P}\)</span> 扩张为 <span class="math inline">\(\sigma(\mathcal{A})\)</span>上的可数可加测度。</p><p>基本逻辑是：</p><ol type="1"><li>根据 Carathéodory 测度扩张定，我们只要证明代数 <span class="math inline">\(\mathcal{A}=\cup_{n=1}^\infty\mathcal{B}_n\)</span>上的有限可加测度是可数可加的。这里 <span class="math display">\[\mathcal{B}_n=\mathcal{B}([0,1])^n\times Q,\quadQ=[0,1]^{\infty}.\]</span> 而这只要证明测度的连续性：若 <span class="math inline">\(B_n\in\mathcal{A}, B_n\downarrow\)</span> 且 <span class="math inline">\(\inf_n\mathbb{P}(B_n)=\epsilon&gt;0\)</span>，则<span class="math inline">\(\cap B_n\ne\emptyset\)</span>。</li><li>我们可以不妨假设 <span class="math inline">\(B_n\in\mathcal{B}_n\)</span>。这可以通过拉伸整个序列，在缝隙中塞上<span class="math inline">\(\Omega_k\)</span> 或者 <span class="math inline">\(B_k\)</span> 来得到。</li><li>我们可以取紧集 <span class="math inline">\(K_n\in B_n\)</span> 使得<span class="math inline">\(\mu(B_n\backslashK_n)&lt;\epsilon/2^n\)</span>，然后证明对任何 <span class="math inline">\(N\)</span>，<span class="math inline">\(\cap_{n=1}^NK_n\)</span> 非空，然后利用 <span class="math inline">\(Q\)</span> 的紧性，和紧集的有限交性质，证明 <span class="math inline">\(\cap_{n=1}^\infty K_n\)</span> 非空，从而 <span class="math inline">\(\cap_{n=1}^\infty B_n\)</span> 非空。</li><li>在上一步中，可以取这样的紧集 <span class="math inline">\(K_n\)</span> 要用到 <span class="math inline">\(R^d\)</span> 上的概率测度是 Radon测度这一性质：它们同时被开集从外部逼近和紧集从内部逼近。<span class="math inline">\(Q\)</span> 的紧性是用了 Tychonoff 定理。</li></ol><blockquote><p><strong>引理</strong>：<span class="math inline">\(K\)</span></p></blockquote>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Sporadic Groups</title>
      <link href="/reading/index.html"/>
      <url>/reading/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>环视系统项目文档</title>
      <link href="/surround-view-doc/index.html"/>
      <url>/surround-view-doc/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>关于车辆的全景环视系统网上已经有很多的资料，然而几乎没有可供参考的代码，这一点对入门的新人来说非常不友好。这个项目的目的就是介绍全景系统的原理，并给出一份基本要素齐全的、可以实际运行的Python实现供大家参考。环视全景系统涉及的知识并不复杂，只需要读者了解相机的标定、透视变换，并懂得如何使用OpenCV。</p><p>这个程序最初是在一辆搭载了一台 AGX Xavier的无人小车上开发的，运行效果如下：</p><video style="margin:0px auto;display:block" width="400" src="https://github.com/neozhaoliang/surround-view-system-introduction/raw/refs/heads/master/doc/img/smallcar.mp4" controls=""></video><p>小车上搭载了四个 USB 环视鱼眼摄像头，相机传回的画面分辨率为640x480，图像首先经过畸变校正，然后在射影变换下转换为对地面的鸟瞰图，最后拼接起来经过平滑处理后得到了上面的效果。全部过程在CPU 中进行处理，整体运行流畅。</p><p>后来我把代码重构以后移植到一辆乘用车上 (处理器是同型号的AGX)，得到了差不多的效果：</p><video style="margin:0px auto;display:block" width="400" src="https://github.com/neozhaoliang/surround-view-system-introduction/raw/refs/heads/master/doc/img/car.mp4" controls=""></video><p>这个版本使用的是四个 960x640 的 csi 摄像头，输出的全景图分辨率为1200x1600，在不进行亮度均衡处理时全景图处理线程运行速度大约为 17fps，加入亮度均衡处理后骤降到只有 7 fps。我认为适当缩小分辨率的话(比如采用 480x640 的输出可以将像素个数降低到原来的 1/6)应该也可以获得流畅的视觉效果。</p><blockquote><p><strong>注</strong>：画面中黑色的部分是相机投影后出现的盲区，这是因为前面的相机为了避开车标的部位安装在了车头左侧且角度倾斜，所以视野受到了限制。想象一个人歪着脖子还斜着眼走路的样子…</p></blockquote><p>这个项目的实现比较粗糙，仅作为演示项目展示生成环视全景图的基本要素，大家领会精神即可。我开发这个项目的目的是为了在自动泊车时实时显示车辆的轨迹，同时也用来作为我指导的实习生的实习项目。由于之前没有经验和参照，大多数算法和流程都是琢磨着写的，不见得高明，请大家多指教。代码是Python 写成的，效率上肯定不如 C++，所以仅适合作学习和验证想法使用。</p><p>下面就来一一介绍我的实现步骤。</p><h1 id="硬件和软件配置">硬件和软件配置</h1><p>我想首先强调的是，硬件配置是这个项目中最不需要费心的事情，在第一个小车项目中使用的硬件如下：</p><ol type="1"><li>四个 USB 鱼眼相机，支持的分辨率为 640x480|800x600|1920x1080三种。我这里因为是需要在 Python 下面实时运行，为了效率考虑设置的分辨率是640x480。</li><li>一台 AGX Xavier。实际上在普通笔记本上跑一样溜得飞起。</li></ol><p>第二个乘用车项目使用的硬件如下：</p><ol type="1"><li>四个 csi 摄像头，设置的分辨率是 960x640。型号是 Sekonix 的 <a href="http://sekolab.com/products/camera/">SF3326-100-RCCB</a>。</li><li>一台 AGX Xavier，型号同上面的小车项目一样，不过外加了一个工控机接收csi 摄像头画面。</li></ol><p>我认为你只要有四个视野足够覆盖车周围的摄像头，再加一个普通笔记本电脑就足够进行全部的离线开发了。需要注意的是，由于传输速率的限制，笔记本的一个USB 口可能无法同时带动四个摄像头，所以你可能需要用 hub将摄像头分配在两个 USB 端口上。</p><p>软件配置如下：</p><ol type="1"><li>操作系统 Ubuntu 16.04/18.04.</li><li>Python&gt;=3.</li><li>OpenCV&gt;=3.</li><li>PyQt5.</li></ol><p>其中 PyQt5 主要用来实现多线程，方便将来移植到 Qt 环境。</p><h1 id="项目采用的若干约定">项目采用的若干约定</h1><p>为了方便起见，在本项目中四个环视相机分别用<code>front</code>、<code>back</code>、<code>left</code>、<code>right</code>来指代，并假定其对应的设备号是整数，例如 0, 1, 2,3。实际开发中请针对具体情况进行修改。</p><p>相机的内参矩阵记作 <code>camera_matrix</code>，这是一个 3x3的矩阵。畸变系数记作 <code>dist_coeffs</code>，这是一个 1x4的向量。相机的投影矩阵记作 <code>project_matrix</code>，这是一个 3x3的射影矩阵。</p><h1 id="准备工作获得原始图像与相机内参">准备工作：获得原始图像与相机内参</h1><p>首先我们需要获取每个相机的内参矩阵与畸变系数。我在项目中附上了一个脚本<a href="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/run_calibrate_camera.py">run_calibrate_camera.py</a>，你只需要运行这个脚本，通过命令行参数告诉它相机设备号，是否是鱼眼相机，以及标定板的网格大小，然后手举标定板在相机面前摆几个姿势即可。</p><p>以下是视频中四个相机分别拍摄的原始画面，顺序依次为前、后、左、右，并命名为<code>front.png</code>、<code>back.png</code>、<code>left.png</code>、<code>right.png</code>保存在项目的 <code>images/</code> 目录下。</p><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><tbody><tr><td style="text-align: center;">front</td><td style="text-align: center;">back</td><td style="text-align: center;">left</td><td style="text-align: center;">right</td></tr><tr><td style="text-align: center;"><img style="margin:0px auto;display:block" width="200" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/images/front.png?raw=true"></td><td style="text-align: center;"><img style="margin:0px auto;display:block" width="200" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/images/back.png?raw=true"></td><td style="text-align: center;"><img style="margin:0px auto;display:block" width="200" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/images/left.png?raw=true"></td><td style="text-align: center;"><img style="margin:0px auto;display:block" width="200" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/images/right.png?raw=true"></td></tr></tbody></table><p>四个相机的内参文件分别为<code>front.yaml</code>、<code>back.yaml</code>、<code>left.yaml</code>、<code>right.yaml</code>，这些内参文件都存放在项目的<a href="https://github.com/neozhaoliang/surround-view-system-introduction/tree/master/yaml">yaml</a>子目录下。</p><p>你可以看到图中地面上铺了一张标定布，这个布的尺寸是<code>6mx10m</code>，每个黑白方格的尺寸为<code>40cmx40cm</code>，每个圆形图案所在的方格是<code>80cmx80cm</code>。我们将利用这个标定物来手动选择对应点获得投影矩阵。</p><h1 id="设置投影范围和参数">设置投影范围和参数</h1><p>接下来我们需要获取每个相机到地面的投影矩阵，这个投影矩阵会把相机校正后的画面转换为对地面上某个矩形区域的鸟瞰图。这四个相机的投影矩阵不是独立的，它们必须保证投影后的区域能够正好拼起来。</p><p>这一步是通过联合标定实现的，即在车的四周地面上摆放标定物，拍摄图像，手动选取对应点，然后获取投影矩阵。</p><p>请看下图：</p><p><img style="margin:0px auto;display:block" width="400" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/paramsettings.png?raw=true"></p><p>首先在车身的四角摆放四个标定板，标定板的图案大小并无特殊要求，只要尺寸一致，能在图像中清晰看到即可。每个标定板应当恰好位于相邻的两个相机视野的重合区域中。</p><p>在上面拍摄的相机画面中车的四周铺了一张标定布，这个具体是标定板还是标定布不重要，只要能清楚的看到特征点就可以了。</p><p>然后我们需要设置几个参数：(以下所有参数均以厘米为单位)</p><ul><li><p><code>innerShiftWidth</code>,<code>innerShiftHeight</code>：标定板内侧边缘与车辆左右两侧的距离，标定板内侧边缘与车辆前后方的距离。</p></li><li><p><code>shiftWidth</code>,<code>shiftHeight</code>：这两个参数决定了在鸟瞰图中向标定板的外侧看多远。这两个值越大，鸟瞰图看的范围就越大，相应地远处的物体被投影后的形变也越严重，所以应酌情选择。</p></li><li><p><code>totalWidth</code>,<code>totalHeight</code>：这两个参数代表鸟瞰图的总宽高，在我们这个项目中标定布宽6m 高 10m，于是鸟瞰图中地面的范围为<code>(600 + 2 * shiftWidth, 1000 + 2 * shiftHeight)</code>。为方便计我们让每个像素对应1 厘米，于是鸟瞰图的总宽高为</p><p></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">totalWidth = 600 + 2 * shiftWidth<br>totalHeight = 1000 + 2 * shiftHeight<br></code></pre></td></tr></tbody></table></figure><p></p></li><li><p>车辆所在矩形区域的四角(图中标注的红色圆点)，这四个角点的坐标分别为 <code>(xl, yt)</code>,<code>(xr, yt)</code>, <code>(xl, yb)</code>, <code>(xr, yb)</code>(<code>l</code> 表示 left, <code>r</code> 表示 right，<code>t</code>表示 top，<code>b</code> 表示bottom)。这个矩形区域相机是看不到的，我们会用一张车辆的图标来覆盖此处。</p></li></ul><p>注意这个车辆区域四边的延长线将整个鸟瞰图分为前左 (FL)、前中 (F)、前右(FR)、左 (L)、右 (R)、后左 (BL)、后中 (B)、后右 (BR) 八个部分，其中 FL(区域 I)、FR (区域 II)、BL (区域 III)、BR (区域 IV)是相邻相机视野的重合区域，也是我们重点需要进行融合处理的部分。F、R、L、R四个区域属于每个相机单独的视野，不需要进行融合处理。</p><p>以上参数存放在 <a href="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/surround_view/param_settings.py">param_settings.py</a>中。</p><p>设置好参数以后，每个相机的投影区域也就确定了，比如前方相机对应的投影区域如下：</p><p><img style="margin:0px auto;display:block" width="400" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/mask.png?raw=true"></p><p>接下来我们需要通过手动选取标志点来获取到地面的投影矩阵。</p><h1 id="手动标定获取投影矩阵">手动标定获取投影矩阵</h1><p>首先运行项目中 <a href="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/run_get_projection_maps.py">run_get_projection_maps.py</a>这个脚本，这个脚本需要你输入如下的参数：</p><ul><li><code>-camera</code>: 指定是哪个相机。</li><li><code>-scale</code>: 校正后画面的横向和纵向放缩比。</li><li><code>-shift</code>: 校正后画面中心的横向和纵向平移距离。</li></ul><p>为什么需要 <code>scale</code> 和 <code>shift</code>这两个参数呢？这是因为默认的 OpenCV的校正方式是在鱼眼相机校正后的图像中裁剪出一个 OpenCV “认为”合适的区域并将其返回，这必然会丢失一部分像素，特别地可能会把我们希望选择的特征点给裁掉。幸运的是<a href="https://docs.opencv.org/master/db/d58/group__calib3d__fisheye.html#ga0d37b45f780b32f63ed19c21aa9fd333">cv2.fisheye.initUndistortRectifyMap</a>这个函数允许我们再传入一个新的内参矩阵，对校正后但是裁剪前的画面作一次放缩和平移。你可以尝试调整并选择合适的横向、纵向压缩比和图像中心的位置使得地面上的标志点出现在画面中舒服的位置上，以方便进行标定。</p><p>运行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python run_get_projection_maps.py -camera front -scale 0.7 0.8 -<span class="hljs-built_in">shift</span> -150 -100<br></code></pre></td></tr></tbody></table></figure><p>后显示前方相机校正后的画面如下：</p><p><img style="margin:0px auto;display:block" width="600" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/original.png?raw=true"></p><p>然后依次点击事先确定好的四个标志点(顺序不能错！)，得到的效果如下：</p><p><img style="margin:0px auto;display:block" width="600" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/choose_front.png?raw=true"></p><p>注意标志点的设置代码在<a href="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/surround_view/param_settings.py#L40">这里</a>。</p><p>这四个点是可以自由设置的，但是你需要在程序中手动修改它们在鸟瞰图中的像素坐标。当你在校正图中点击这四个点时，OpenCV会根据它们在校正图中的像素坐标和在鸟瞰图中的像素坐标的对应关系计算一个射影矩阵。这里用到的原理就是四点对应确定一个射影变换(四点对应可以给出八个方程，从而求解出射影矩阵的八个未知量。注意射影矩阵的最后一个分量总是固定为1)。</p><p>如果你不小心点歪了的话可以按 <code>d</code>键删除上一个错误的点。选择好以后点回车，就会显示投影后的效果图:</p><p><img style="margin:0px auto;display:block" width="600" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/front_proj.png?raw=true"></p><p>觉得效果可以的话敲回车，就会将投影矩阵写入 <code>front.yaml</code>中，这个矩阵的名字为 <code>project_matrix</code>。失败的话就按<code>q</code> 退出再来一次。</p><p>再比如后面相机的标定如下图所示：</p><p><img style="margin:0px auto;display:block" width="600" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/choose_back.png?raw=true"></p><p>对应的投影图为</p><p><img style="margin:0px auto;display:block" width="600" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/back_proj.png?raw=true"></p><p>对四个相机分别采用此操作，我们就得到了四个相机的鸟瞰图，以及对应的四个投影矩阵。下一步我们的任务是把这四个鸟瞰图拼起来。</p><div id="------------------" class="statement sta_______ definition unnumbered"><p><span class="statement-heading"><span class="statement-label">重要注意事项</span>：</span><span class="statement-spah"></span>：有不少读者反映在按照上面的方法进行标定时，得到的拼接效果不够好。经过询问，发现原因是他们选择的四个标定点都集中在图像的中心部分。你应该让四个标定点构成的矩形区域覆盖图像尽可能大的范围。原因是鱼眼图像在矫正后也是有误差的，边缘的误差更大。所以要尽可能让OpenCV 在更大的范围内计算一个全局最优的射影矩阵。</p></div><h1 id="鸟瞰图的拼接与平滑">鸟瞰图的拼接与平滑</h1><p>如果你前面操作一切正常的话，运行 <a href="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/run_get_weight_matrices.py">run_get_weight_matrices.py</a>后应该会显示如下的拼接图：</p><p><img style="margin:0px auto;display:block" width="480" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/result.png?raw=true"></p><p>我来逐步介绍它是怎么做到的：</p><ol type="1"><li><p>由于相邻相机之间有重叠的区域，所以这部分的融合是关键。如果直接采取两幅图像加权平均(权重各自为 1/2) 的方式融合的话你会得到类似下面的结果：</p><p><img style="margin:0px auto;display:block" width="480" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/bad.png?raw=true"></p><p>你可以看到由于校正和投影的误差，相邻相机在重合区域的投影结果并不能完全吻合，导致拼接的结果出现乱码和重影。这里的关键在于权重系数应该是随像素变化而变化的，并且是随着像素连续变化。</p></li><li><p>以左上角区域为例，这个区域是 <code>front</code>,<code>left</code>两个相机视野的重叠区域。我们首先将投影图中的重叠部分取出来：</p><p><img style="margin:0px auto;display:block" width="250" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/overlap.png?raw=true"></p><p>灰度化并二值化：</p><p><img style="margin:0px auto;display:block" width="250" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/overlap_gray.png?raw=true"></p><p>注意这里面有噪点，可以用形态学操作去掉(不必特别精细，大致去掉即可)：</p><p><img style="margin:0px auto;display:block" width="250" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/mask_dilate.png?raw=true"></p><p>至此我们就得到了重叠区域的一个完整 mask。</p></li><li><p>将 <code>front</code>, <code>left</code>图像各自位于重叠区域外部的边界检测出来，这一步是通过先调用<code>cv2.findContours</code> 求出最外围的边界，再用<code>cv2.approxPolyDP</code> 获得逼近的多边形轮廓：</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr><td style="text-align: center;"><img style="margin:0px auto;display:block" width="250" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/polyA.png?raw=true"></td><td style="text-align: center;"><img style="margin:0px auto;display:block" width="250" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/polyB.png?raw=true"></td></tr></tbody></table><p>我们把 <code>front</code> 相机减去重叠区域后的轮廓记作<code>polyA</code> (左上图中蓝色边界)，<code>left</code>相机减去重叠区域后的轮廓记作 <code>polyB</code>(右上图中绿色边界)。</p></li><li><p>对重叠区域中的每个像素，利用 <code>cv2.pointPolygonTest</code>计算其到这两个多边形 <code>polyA</code> 和 <code>polyB</code> 的距离<span class="math inline">\(d_A,d_B\)</span>，则该像素对应的权值为 <span class="math inline">\(w=d_B^2/(d_A^2+d_B^2)\)</span>，即如果这个像素落在<code>front</code> 画面内，则它与 <code>polyB</code>的距离就更远，从而权值更大。</p></li><li><p>对不在重叠区域内的像素，若其属于 <code>front</code>相机的范围则其权值为 1，否则权值为0。于是我们得到了一个连续变化的，取值范围在 0~1 之间的矩阵 <span class="math inline">\(G\)</span>，其灰度图如下：</p><p><img style="margin:0px auto;display:block" width="250" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/weight_for_FL.png?raw=true"></p><p>将 <span class="math inline">\(G\)</span> 作为权值可得融合后的图像为<code>front * G + (1- G) * left</code>。</p></li><li><p>注意由于重叠区域中的像素值是来自两幅图像的加权平均，所以出现在这个区域内的物体会不可避免出现虚影的现象，所以我们需要尽量压缩重叠区域的范围，尽可能只对拼接缝周围的像素计算权值，拼接缝上方的像素尽量使用来自<code>front</code> 的原像素，拼接缝下方的像素尽量使用来自<code>back</code> 的原像素。这一步可以通过控制 <span class="math inline">\(d_B\)</span> 的值得到。</p></li><li><p>我们还漏掉了重要的一步：由于不同相机的曝光度不同，导致不同的区域会出现明暗的亮度差，影响美观。我们需要调整每个区域的亮度，使得整个拼接图像的亮度趋于一致。这一步做法不唯一，自由发挥的空间很大。我查阅了一下网上提到的方法，发现它们要么过于复杂，几乎不可能是实时的；要么过于简单，无法达到理想的效果。特别在上面第二个视频的例子中，由于前方相机的视野被车标遮挡导致感光范围不足，导致其与其它三个相机的画面亮度差异很大，调整起来很费劲。</p><p>一个基本的想法是这样的：每个相机传回的画面有 <code>BGR</code>三个通道，四个相机传回的画面总共有 12 个通道。我们要计算 12 个系数，将这12 个系数分别乘到这 12个通道上，然后再合并起来形成调整后的画面。过亮的通道要调暗一些所以乘的系数小于1，过暗的通道要调亮一些所以乘的系数大于1。这些系数可以通过四个画面在四个重合区域内的亮度比值得出，你可以自由设计计算系数的方式，只要满足这个基本原理即可。</p><p>我的实现见<a href="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/surround_view/birdview.py#L210">这里</a>。感觉就像一段shader 代码。</p><p>还有一种偷懒的办法是事先计算一个 tone mapping 函数(比如逐段线性的，或者 AES tone mappingfunction)，然后强制把所有像素进行转换，这个方法最省力，但是得到的画面色调会与真实场景有较大差距。似乎有的市面产品就是采用的这种方法。</p></li><li><p>最后由于有些情况下摄像头不同通道的强度不同，还需要进行一次色彩平衡，见下图:</p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr><td style="text-align: center;">拼接后原始画面</td><td style="text-align: center;">亮度平衡画面</td><td style="text-align: center;">亮度平衡+色彩平衡画面</td></tr><tr><td style="text-align: center;"><img style="margin:0px auto;display:block" width="250" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/example1.png?raw=true"></td><td style="text-align: center;"><img style="margin:0px auto;display:block" width="250" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/example2.png?raw=true"></td><td style="text-align: center;"><img style="margin:0px auto;display:block" width="250" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/example3.png?raw=true"></td></tr></tbody></table><p>在第二个视频的例子中，画面的颜色偏红，加入色彩平衡后画面恢复了正常。</p></li></ol><h1 id="具体实现的注意事项">具体实现的注意事项</h1><ol type="1"><li><p>多线程与线程同步。本文的两个例子中四个摄像头都不是硬件触发保证同步的，而且即便是硬件同步的，四个画面的处理线程也未必同步，所以需要有一个线程同步机制。这个项目的实现采用的是比较原始的一种，其核心代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiBufferManager</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    ...<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sync</span>(<span class="hljs-params">self, device_id</span>):<br>        <span class="hljs-comment"># only perform sync if enabled for specified device/stream</span><br>        <span class="hljs-variable language_">self</span>.mutex.lock()<br>        <span class="hljs-keyword">if</span> device_id <span class="hljs-keyword">in</span> <span class="hljs-variable language_">self</span>.sync_devices:<br>            <span class="hljs-comment"># increment arrived count</span><br>            <span class="hljs-variable language_">self</span>.arrived += <span class="hljs-number">1</span><br>            <span class="hljs-comment"># we are the last to arrive: wake all waiting threads</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.do_sync <span class="hljs-keyword">and</span> <span class="hljs-variable language_">self</span>.arrived == <span class="hljs-built_in">len</span>(<span class="hljs-variable language_">self</span>.sync_devices):<br>                <span class="hljs-variable language_">self</span>.wc.wakeAll()<br>            <span class="hljs-comment"># still waiting for other streams to arrive: wait</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-variable language_">self</span>.wc.wait(<span class="hljs-variable language_">self</span>.mutex)<br>            <span class="hljs-comment"># decrement arrived count</span><br>            <span class="hljs-variable language_">self</span>.arrived -= <span class="hljs-number">1</span><br>        <span class="hljs-variable language_">self</span>.mutex.unlock()<br></code></pre></td></tr></tbody></table></figure> 这里使用了一个 <code>MultiBufferManager</code>对象来管理所有的线程，每个摄像头的线程在每次循环时会调用它的<code>sync</code> 方法，并通过将计数器加 1 的方法来通知这个对象“报告，我已做完上次的任务，请将我加入休眠池等待下次任务”。一旦计数器达到4 就会触发唤醒所有线程进入下一轮的任务循环。<p></p></li><li><p>建立查找表 (lookup table)以加快运算速度。鱼眼镜头的画面需要经过校正、投影、翻转以后才能用于拼接，这三步涉及频繁的图像内存分配和销毁，非常费时间。在我的测试中抓取线程始终稳定在30fps 多一点左右，但是每个画面的处理线程只有 20 fps左右。这一步最好是通过预计算一个查找表来加速。你还记得<code>cv2.fisheye.initUndistortRectifyMap</code> 这个函数吗？它返回的<code>mapx, mapy</code> 就是两个查找表。比如当你指定它返回的矩阵类型为<code>cv2.CV_16SC2</code> 的时候，它返回的 <code>mapx</code>就是一个逐像素的查找表，<code>mapy</code> 是一个用于插值平滑的一维数组(可以扔掉不要)。同理对于 <code>project_matrix</code>也不难获得一个查找表，两个合起来就可以得到一个直接从原始画面到投影画面的查找表(当然损失了用于插值的信息)。 在这个项目中由于采用的是 Python 实现，而Python 的 <code>for</code>循环效率不高，所以没有采用这种查找表的方式。</p></li><li><p>四个权重矩阵可以作为 <code>RGBA</code>四个通道压缩到一张图片中，这样存储和读取都很方便。四个重叠区域对应的mask 矩阵也是如此：</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr><td style="text-align: center;">四个 mask 矩阵</td><td style="text-align: center;">四个权重矩阵</td></tr><tr><td style="text-align: center;"><img style="margin:0px auto;display:block" width="250" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/masks.png?raw=true"></td><td style="text-align: center;"><img style="margin:0px auto;display:block" width="250" src="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/doc/img/weights.png?raw=true"></td></tr></tbody></table></li></ol><h1 id="实车运行">实车运行</h1><p>你可以在实车上运行 <a href="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/run_live_demo.py">run_live_demo.py</a>来验证最终的效果。</p><p>你需要注意修改相机设备号，以及 OpenCV 打开摄像头的方式。usb相机可以直接用 <code>cv2.VideoCapture(i)</code> (<code>i</code> 是 usb设备号) 的方式打开，csi 相机则需要调用 <code>gstreamer</code>打开，对应的代码在<a href="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/surround_view/utils.py#L5">这里</a>和<a href="https://github.com/neozhaoliang/surround-view-system-introduction/blob/master/surround_view/capture_thread.py#L75">这里</a>。</p><h1 id="附录项目各脚本一览">附录：项目各脚本一览</h1><p>项目中目前的脚本根据执行顺序排列如下:</p><ol type="1"><li><code>run_calibrate_camera.py</code>：用于相机内参标定。</li><li><code>param_settings.py</code>：用于设置投影区域的各参数。</li><li><code>run_get_projection_maps.py</code>：用于手动标定获取到地面的投影矩阵。</li><li><code>run_get_weight_matrices.py</code>：用于计算四个重叠区域对应的权重矩阵以及mask 矩阵，并显示拼接效果。</li><li><code>run_live_demo.py</code>：用于在实车上运行的最终版本。</li></ol>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter groups, automata and uniform tilings</title>
      <link href="/uniform-tilings/index.html"/>
      <url>/uniform-tilings/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Since using POV-Ray to render 3D hyperbolic honeycombs was incrediblyslow, I’ve decided to abandon this approach and have removed the codefrom the main branch on GitHub. You can find the code used in thisarticle in the <a href="https://github.com/neozhaoliang/pywonderland/releases/tag/0.1.0">oldrelease version</a>. For how to render hyperbolic honeycombs, readerscan refer to <a href="https://github.com/neozhaoliang/Hyperbolic-Honeycombs/">anotherproject</a>.</p></blockquote><p>This article introduces a <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/uniform-tilings">Pythonprogram</a> I just finished. Although it’s freshly completed, it took upmost of my free time over the last six months. It was quite thechallenge, requiring a lot of effort and dedication. The main reason isthat it involves a few complicated theories, specifically the deepproperties of Coxeter groups, known as the automatic property. Asignificant portion of these months was spent learning from articles byCasselman, Brink &amp; Howlett, and others, which helped me understandthe mathematicas of this project (see references at the end).</p><p>Although finishing this program is a great achievement for me, Idon’t mean to boast about any superiority of this program: thecomputational method it uses for Coxeter groups is not advanced andmight not impress the experts. Moreover, its code is somewhat ugly, andlikely difficult for other people to use.</p><p>The purpose of this program is to use group theory to draw varioustwo-dimensional and three-dimensional <a href="https://en.wikipedia.org/wiki/Uniform_tiling">uniform tilings</a>.You can think of uniform tiling as using some regular polygons to tilethe space so that the vertices of the tiles are transitive under theaction of a symmetry group (forming a single orbit).</p><p>I will first show some examples of what this program can do, and thenexplain how it works.</p><h1 id="examples">Examples</h1><ul><li><p>Below is the 2d Euclidean tiling omnitruncated (4, 2, 4):</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-4-2-4.png" width="600"></p></li><li><p>Below is the 2d hyperbolic tiling regular (2, 3, 13) inPoincaré’s disk model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/2-3-13.png" width="600"></p></li><li><p>Below is the 2d hyperbolic tiling omnitruncated (4, 3, 3) inupper half plane model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/uhp-4-3-3.png" width="600"></p></li><li><p>A hyperbolic weave pattern:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/weave_pattern.png" width="500"></p></li><li><p>Below is the 3d hyperbolic tiling regular (3, 5, 3) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/3-5-3.png" width="600"></p></li><li><p>Below is the 3d hyperbolic tiling regular (5, 3, 5) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/5-3-5.png" width="600"></p></li><li><p>Below is the 3d hyperbolic tiling regular (5, 3, 4) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/5-3-4.png" width="600"></p></li><li><p>Below is the 3d hyperbolic tiling regular (4, 3, 5) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/4-3-5.png" width="600"></p></li><li><p>The above four regular tilings are the only regular ones withcompact cells. If we drop the restriction on compactness and requiresthe cells must have finite volume, then we have ten more regulartilings, with each has a Euclidean vertex configure. For example (6, 3,3)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/6-3-3.png" width="600"></p><p>You can see the cells have ideal vertices, i.e.&nbsp;vertices at theinfinity. These tilings are called “paracompact”.</p></li><li><p>If we drop the restriction on being “regular” then we have lotsmore examples, like rectified (3, 5, 3) and rectified (5, 3, 4)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/rectified-3-5-3.png" width="600"></p><p><img style="margin:0px auto;display:block" src="/images/coxeter/rectified-5-3-4.png" width="600"></p><p>and the <a href="https://en.wikipedia.org/wiki/Uniform_honeycombs_in_hyperbolic_space#%5B5,31,1%5D_family">canticorder-5 cubic</a> tiling from the [5, 3<sup>1,1</sup>] family:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/cantic-order-5-cubic.png" width="600"></p></li><li><p>Below is a 2d spherical tiling rendered in 3d:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-5-2-3.png" width="600"></p></li><li><p>Finally a shader program exported from Matt Zucker’s excellentwork on <a href="https://www.shadertoy.com/view/3tsSzM">shadertoy</a>:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/wythoff_shader.png" width="600"></p></li></ul><h1 id="wythoff-construction">Wythoff construction</h1><p>The main theoretical tool for drawing uniform tilings is theso-called <a href="https://en.wikipedia.org/wiki/Wythoff_construction">Wythoffconstruction</a>, also known as the kaleidoscope method. This involvesplacing several reflecting planes (mirrors) in space, then starting froman initial point, and repeatedly applying reflection transformationsabout these mirrors to obtain all the virtual images, which gives allthe vertices of the tiling.</p><p>The following video demonstrates the effect of the Wythoffconstruction: in the 2D Poincaré hyperbolic disk, the walls around theroom are all mirrors. The scene in the room is repeatedly reflected inthe mirrors, creating infinitely many virtual image rooms, filling theentire hyperbolic space. Note that, there is only one ‘real’ room,namely the room where the observer is standing in; all other rooms arevirtual images of the real one.</p><video src="/images/hyperbolic-honeycombs/lego-hyperbolic-kaleido.mp4" width="600" controls=""></video><p>There are two different approaches to implemente the Wythoffconstruction in a program:</p><ol type="1"><li><p>Inverse Pixel Method. This method involves calculating, for eachpixel in the image, its corresponding point <span class="math inline">\(p\)</span> in the world space. Then, <span class="math inline">\(p\)</span> is repeatedly reflected off mirrorsuntil it falls within the fundamental region, say the final location is<span class="math inline">\(q\)</span>. Essentially, we find thepre-image <span class="math inline">\(q\)</span> of <span class="math inline">\(p\)</span> in the real room (called thefundamental domain). Then, based on <span class="math inline">\(q\)</span>’s position within the fundamentaldomain, the pixel corresponding to <span class="math inline">\(p\)</span> is colored. This method allows forparallel computation on all pixels, and when combined with shaderprogramming, it can produce very stunning effects. Here are two examplesfrom shadertoy:</p><p><iframe width="480" height="270" frameborder="0" src="https://www.shadertoy.com/embed/mlGfzV?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe></p><p><iframe width="480" height="270" frameborder="0" src="https://www.shadertoy.com/embed/Nd3cR2?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe></p><p>The inverse pixel method cares solely about the final pixel color. Itdoesn’t care about the actual coordinates. It produces raster images andcannot output vector graphics. Moreover, exporting data for use inmodeling software is not very convenient with this method.</p></li><li><p>Coordinate Method. This approach starts from a given initialpoint <span class="math inline">\(v_0\)</span> and calculates all itsvirtual images (within some maximum number of vertices) as well as theconnections between edges and faces, then draws them one by one. Thismethod allows for the acquisition of specific vertex coordinateinformation and outputs vector graphics and model files, making it moresuitable for usage in academic papers. However, it cannot beparallelized and is quite slow in computing hyperbolic tilings, as thestructures grows exponentially.</p></li></ol><p>My program uses the coordinate method. It first performs symboliccalculations within the symmetry group of the tiling to determine theword representation corresponding to each vertex in the shortestlexicographical order (a word is a tuple where each element is aninteger), as well as the connections between edges and faces (alsotuples of integers), and then applies the word corresponding to eachvertex to the initial vertex to obtain the floating-point coordinates ofthat vertex. In other words, before computing the final coordinates ofeach vertex, it has already pre-calculated how many vertices there are,how each vertex is obtained through reflections from the initial vertex,which vertices form edges, which form faces, which form cells, etc.These calculations involve only integer operations, completely avoidingissues with floating-point precision loss.</p><p>Sounds amazing? Let me demonstrate the specific steps with anexample.</p><h1 id="example-omnitruncated-7-2-3-tiling">Example: omnitruncated (7,2, 3) tiling</h1><p>The Coxeter-Dynkin diagram for the omnitruncated (7, 2, 3) tilingis:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/coxeter723.svg" width="250"></p><p>This is a hyperbolic tiling, its symmetry group <span class="math inline">\(G\)</span> is the Coxeter group determined byCoxeter matrix</p><p><span class="math display">\[M=\begin{pmatrix} 1 &amp; 7 &amp; 2 \\ 7&amp;1 &amp;3\\ 2 &amp; 3 &amp;1\end{pmatrix}\]</span></p><p>and has presentation</p><p><span class="math display">\[W = \langle s_0,s_1, s_2\ |\s_0^2=s_1^2=s_2^2=(s_0s_1)^7=(s_1s_2)^3=(s_0s_2)^2=1\rangle.\]</span></p><p>The initial vertex <span class="math inline">\(v_0\)</span> is not onany of the three mirrors, so its stabilizing subgroup is <span class="math inline">\(\langle 1\rangle\)</span>, by <a href="https://en.wikipedia.org/wiki/Group_action_(mathematics)#Orbit-stabilizer_theorem">orbit-stabilizertheorem</a> each element <span class="math inline">\(w\)</span> of <span class="math inline">\(W\)</span> maps <span class="math inline">\(v_0\)</span> to a distinct vertex in thetiling.</p><p>Every element <span class="math inline">\(w\)</span> in <span class="math inline">\(W\)</span> can be expressed as a product of thegenerators <span class="math inline">\(s_0,s_1,s_2\)</span>. We call anysuch expression a word representation of <span class="math inline">\(w\)</span>. If <span class="math inline">\(w=s_{i_1}s_{i_2}\cdots s_{i_k}\)</span> is a wordexpression, and there are no other expressions of <span class="math inline">\(w\)</span> with length less than <span class="math inline">\(k\)</span>, we call <span class="math inline">\(s_{i_1}s_{i_2}\cdots s_{i_k}\)</span> a reducedexpression, and define <span class="math inline">\(l(w)=k\)</span> to bethe length of <span class="math inline">\(w\)</span>. The reducedexpression of <span class="math inline">\(w\)</span> is generally notunique. For example, from the defining relations of <span class="math inline">\(W\)</span>, we can see that <span class="math inline">\(s_0s_2=s_2s_0\)</span> and <span class="math inline">\(s_1s_2s_1=s_2s_1s_2\)</span>, etc. However, allreduced expressions of <span class="math inline">\(w\)</span> must havethe same length, so the definition of <span class="math inline">\(l(w)\)</span> is reasonable.</p><p>We can choose a smallest one among all reduced expressions <span class="math inline">\(w\)</span> as the normal form of <span class="math inline">\(w\)</span>. This sorting is called shortlex order.As the name implies, shortlex order is the order used by dictionaries toarrange words.</p><p>First, define the alphabetical order of the generators <span class="math inline">\(s_0,s_1,s_2\)</span> as <span class="math inline">\(s_0&lt;s_1&lt;s_2\)</span>​, then extend this orderto any two reduced expression <span class="math inline">\(w_1\)</span>and <span class="math inline">\(w_2\)</span>:</p><blockquote><p><strong>Shortlex Order</strong>: Let <span class="math inline">\(w_1= s_{i_1}s_{i_2}\ldots s_{i_n}\)</span> and <span class="math inline">\(w_2=s_{j_1}s_{j_2}\cdots s_{j_m}\)</span> be twodifferent reduced expressions, where <span class="math inline">\(w_1,w_2\)</span> can be different group elements. The relationship betweenthem in shortlex order is determined as follows:</p><ol type="1"><li>First, compare the lengths. If the lengths are different, the onewith the shorter length is considered smaller, that is, if <span class="math inline">\(n &lt; m\)</span> then <span class="math inline">\(w_1 &lt; w_2\)</span>, conversely if <span class="math inline">\(n &gt; m\)</span> then <span class="math inline">\(w_1 &gt; w_2\)</span>.</li><li>If the lengths are the same, then compare the alphabetical orderfrom left to right. Let <span class="math inline">\(k\)</span> be thefirst index such that for any <span class="math inline">\(l &lt;k\)</span>, <span class="math inline">\(s_{i_l} = s_{j_l}\)</span> but<span class="math inline">\(s_{i_k} \ne s_{j_k}\)</span>, then therelationship between <span class="math inline">\(w_1, w_2\)</span> isthe same as the relationship between <span class="math inline">\(s_{i_k}\)</span> and <span class="math inline">\(s_{j_k}\)</span>.</li></ol></blockquote><p>Thus, every <span class="math inline">\(w\in W\)</span> has a uniquenormal form under shortlex order.</p><p>Define <span class="math inline">\(\mathcal{SL}(W)\)</span> as theset consisting of the normal forms of all elements in <span class="math inline">\(W\)</span>. Below is a list of all elements in<span class="math inline">\(\mathcal{SL}(W)\)</span> with lengths up to5, totaling 37: (arranged in rows from smallest to largest)</p><p><span class="math display">\[\begin{array}{lllll}e&amp;s_{0}&amp;s_{1}&amp;s_{2}&amp;s_{0}s_{1}\\s_{0}s_{2}&amp;s_{1}s_{0}&amp;s_{1}s_{2}&amp;s_{2}s_{1}&amp;s_{0}s_{1}s_{0}\\s_{0}s_{1}s_{2}&amp;s_{0}s_{2}s_{1}&amp;s_{1}s_{0}s_{1}&amp;s_{1}s_{0}s_{2}&amp;s_{1}s_{2}s_{1}\\s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{1}&amp;s_{0}s_{1}s_{0}s_{2}&amp;s_{0}s_{1}s_{2}s_{1}&amp;s_{0}s_{2}s_{1}s_{0}\\s_{1}s_{0}s_{1}s_{0}&amp;s_{1}s_{0}s_{1}s_{2}&amp;s_{1}s_{0}s_{2}s_{1}&amp;s_{1}s_{2}s_{1}s_{0}&amp;s_{2}s_{1}s_{0}s_{1}\\s_{0}s_{1}s_{0}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{1}s_{2}&amp;s_{0}s_{1}s_{0}s_{2}s_{1}&amp;s_{0}s_{1}s_{2}s_{1}s_{0}&amp;s_{0}s_{2}s_{1}s_{0}s_{1}\\s_{1}s_{0}s_{1}s_{0}s_{1}&amp;s_{1}s_{0}s_{1}s_{0}s_{2}&amp;s_{1}s_{0}s_{1}s_{2}s_{1}&amp;s_{1}s_{0}s_{2}s_{1}s_{0}&amp;s_{1}s_{2}s_{1}s_{0}s_{1}\\s_{2}s_{1}s_{0}s_{1}s_{0}&amp;s_{2}s_{1}s_{0}s_{1}s_{2}&amp;\end{array}\]</span></p><p>Note the number of all words in <span class="math inline">\(s_0,s_1,s_2\)</span> with length less or equalthan five is <span class="math inline">\(1+3+\cdots+3^5=364\)</span>,the list above tells us that they indeed contain only 37 different ones,the remaining 364 - 37 = 327 ones are duplicates. A further computationshows that the number of all words with length no more than six is 1093but they contain only 53 different elements. So we can gain a greatimprovement in efficiency if we only use words in <span class="math inline">\(\mathcal{SL}(W)\)</span> instead of traversing allpossible combinations of the generators.</p><p>How can we generate those words that are precisely in <span class="math inline">\(\mathcal{SL}(W)\)</span>? This leads us to a veryimportant theorem on Coxeter groups:</p><blockquote><p><strong>Theorem [Brigitte Brink &amp; Robert B. Howlett,1993]</strong>: If <span class="math inline">\(G\)</span> is a finitelygenerated Coxeter group then <span class="math inline">\(\mathcal{SL}(W)\)</span> is a regularlanguage.</p></blockquote><p>The term “regular language” comes from computer science, a basic factabout a regular language over a finite alphabetical set is that thislanguage can always be recognized by a definite finite automaton (DFA),such DFA may not be unique but there is a “minimal one” with the leastnumber of states and this minimal one is unique if we don’t distinctrelabellings of the states.</p><p>Below is the automaton recognizes <span class="math inline">\(\mathcal{SL}(W)\)</span> for the (7, 2, 3)group:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/dfa_723.svg" width="600"></p><p>You can see there are 19 nodes (i.e.&nbsp;states) in the automaton. Thelabels of the states are irrevalent because renumbering the states of anautomaton does not change the language it recognizes.</p><p>The red node is the initial state.</p><p>The directed edges in the graph tell us the transition rule betweenthe states. The edges are labelled by the generators of the group,i.e.&nbsp;<span class="math inline">\(i\)</span> for <span class="math inline">\(s_i\)</span>. If we start from the initial stateand keep on moving to a next state along an edge up to a finite numberof steps, then the path we travelled gives a word in <span class="math inline">\(\mathcal{SL}(W)\)</span>. All words in <span class="math inline">\(\mathcal{SL}(W)\)</span> can be generated in thisway.</p><p>For example:</p><ol type="1"><li>The only path of length 0 correspondes to the identidy 1.</li><li>The three paths of length 1 <span class="math display">\[\begin{align*}0&amp;\xrightarrow{\ s_0\ }1,\\0&amp;\xrightarrow{\ s_1\ }2,\\0&amp;\xrightarrow{\ s_2\ }8.\end{align*}\]</span> corresponde to the three generators <span class="math inline">\(s_0,s_1,s_2\)</span> in <span class="math inline">\(\mathcal{SL}(W)\)</span>.</li><li>The five paths <span class="math display">\[\begin{align*}0&amp;\xrightarrow{\ s_0\}1\xrightarrow{\ s_1\ }2\\0&amp;\xrightarrow{\ s_0\ }1\xrightarrow{\ s_2\ }8\\0&amp;\xrightarrow{\ s_1\ }2\xrightarrow{\ s_0\ }3\\0&amp;\xrightarrow{\ s_1\ }2\xrightarrow{\ s_2\ }8\\0&amp;\xrightarrow{\ s_2\ }8\xrightarrow{\ s_1\ }9\end{align*}\]</span> corresponde to the five elements of length 2 in <span class="math inline">\(\mathcal{SL}(W)\)</span>: <span class="math inline">\(s_0s_1,s_0s_2,s_1s_0,s_1s_2,s_2s_1\)</span>.</li></ol><p>Using breadth-first search we can easily generate all words in <span class="math inline">\(\mathcal{SL}(W)\)</span> up to any givendepth.</p><p>Note for an infinite Coxeter group the automaton must have cycles,but for a finite Coxeter group the automaton must be a directed tree,for example the symmetry group <span class="math inline">\(S_4\)</span>of tetrahedron:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/tetrahedron.svg" width="600"></p><p>The 24 different paths corresponde to the 24 group elements of <span class="math inline">\(S_4\)</span>:</p><p><span class="math display">\[\begin{array}{llll}e&amp;s_{0}&amp;s_{1}&amp;s_{2}\\s_{0}s_{1}&amp;s_{0}s_{2}&amp;s_{1}s_{0}&amp;s_{1}s_{2}\\s_{2}s_{1}&amp;s_{0}s_{1}s_{0}&amp;s_{0}s_{1}s_{2}&amp;s_{0}s_{2}s_{1}\\s_{1}s_{0}s_{2}&amp;s_{1}s_{2}s_{1}&amp;s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{2}\\s_{0}s_{1}s_{2}s_{1}&amp;s_{0}s_{2}s_{1}s_{0}&amp;s_{1}s_{0}s_{2}s_{1}&amp;s_{1}s_{2}s_{1}s_{0}\\s_{0}s_{1}s_{0}s_{2}s_{1}&amp;s_{0}s_{1}s_{2}s_{1}s_{0}&amp;s_{1}s_{0}s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{2}s_{1}s_{0}\end{array}\]</span></p><p>Now the big question:</p><blockquote><p><strong>Question 1</strong>: How to compute <span class="math inline">\(\mathcal{SL}(W)\)</span>?</p></blockquote><p>The answer to this question is too complicated to be covered in thisarticle, a simple sketch of the main thread is appended at the end. WhenI was developing this program I mainly referred to Casselman’s notes <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> andthe textbook by Humphreys <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. These should be enoughfor a reader with a solid background in undergradute abstractalgebra.</p><p>Once we have the normal forms of the group elements, we can easilyuse them to map the initial vertex <span class="math inline">\(v_0\)</span> to other vertices in the tiling:</p><p>Let <span class="math inline">\(w=s_{i_0}s_{i_1}\cdotss_{i_n}\)</span>, we adopt the convention that the action of <span class="math inline">\(w\)</span> on <span class="math inline">\(v_0\)</span> is to successively apply eachgenerator in <span class="math inline">\(w\)</span> from right to left:<span class="math display">\[w\cdot v_0 = s_{i_0}(s_{i_1}(\cdotss_{i_n}(v_0))).\]</span> Since <span class="math inline">\(W\)</span> isinfinite we can only generate words up to a given depth. Suppose we havethe 37 words listed above stored in a list <span class="math inline">\(L\)</span>, they map <span class="math inline">\(v_0\)</span> to 37 different vertices in thetiling. To draw the edges between them we need to compute which of themare adjacent. How can we do this?</p><p>Firstly we need a multiplicaiton table <span class="math inline">\(T\)</span> for the words in <span class="math inline">\(L\)</span>. <span class="math inline">\(T\)</span>is a 2d array with its <span class="math inline">\(i\)</span>-th rowcorrespondes to the <span class="math inline">\(i\)</span>-th word <span class="math inline">\(w_i\)</span> in <span class="math inline">\(L\)</span> and its <span class="math inline">\(j\)</span>-th column correspondes to the <span class="math inline">\(j\)</span>-th generator <span class="math inline">\(s_j\)</span>. The entry <span class="math inline">\(T[i][j]\)</span> records the index of <span class="math inline">\(s_jw_j\)</span> in <span class="math inline">\(L\)</span> (note this multiplication may not be anormal form). If <span class="math inline">\(s_jw_i\)</span> does notexist in <span class="math inline">\(L\)</span> we simply return<code>None</code>. The usage of <span class="math inline">\(T\)</span>is, for any given word <span class="math inline">\(w\)</span>, we canquickly find the index of <span class="math inline">\(w\)</span> in<span class="math inline">\(L\)</span> by using <span class="math inline">\(T\)</span> as a lookup table.</p><p>In our example <span class="math inline">\(T\)</span> is listedbelow, the words in <span class="math inline">\(L\)</span> are put intothe second column:</p><details><summary><font color="#D00"><strong>Click to expand <span class="math inline">\(T\)</span></strong></font></summary><div><table><thead><tr><th style="text-align: center;">V</th><th style="text-align: center;">word</th><th style="text-align: center;"><span class="math inline">\(s_0\)</span></th><th style="text-align: center;"><span class="math inline">\(s_1\)</span></th><th style="text-align: center;"><span class="math inline">\(s_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(e\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(s_{0}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">6</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(s_{1}\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">0</td><td style="text-align: center;">8</td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(s_{2}\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">7</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">12</td><td style="text-align: center;">11</td></tr><tr><td style="text-align: center;">5</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">13</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">6</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}\)</span></td><td style="text-align: center;">9</td><td style="text-align: center;">1</td><td style="text-align: center;">15</td></tr><tr><td style="text-align: center;">7</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}\)</span></td><td style="text-align: center;">10</td><td style="text-align: center;">3</td><td style="text-align: center;">14</td></tr><tr><td style="text-align: center;">8</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}\)</span></td><td style="text-align: center;">11</td><td style="text-align: center;">14</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">9</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">20</td><td style="text-align: center;">19</td></tr><tr><td style="text-align: center;">10</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">21</td><td style="text-align: center;">18</td></tr><tr><td style="text-align: center;">11</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">8</td><td style="text-align: center;">22</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;">12</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">16</td><td style="text-align: center;">4</td><td style="text-align: center;">24</td></tr><tr><td style="text-align: center;">13</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">17</td><td style="text-align: center;">5</td><td style="text-align: center;">23</td></tr><tr><td style="text-align: center;">14</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">18</td><td style="text-align: center;">8</td><td style="text-align: center;">7</td></tr><tr><td style="text-align: center;">15</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">19</td><td style="text-align: center;">23</td><td style="text-align: center;">6</td></tr><tr><td style="text-align: center;">16</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">12</td><td style="text-align: center;">30</td><td style="text-align: center;">29</td></tr><tr><td style="text-align: center;">17</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">13</td><td style="text-align: center;">31</td><td style="text-align: center;">28</td></tr><tr><td style="text-align: center;">18</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">14</td><td style="text-align: center;">32</td><td style="text-align: center;">10</td></tr><tr><td style="text-align: center;">19</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">15</td><td style="text-align: center;">33</td><td style="text-align: center;">9</td></tr><tr><td style="text-align: center;">20</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">25</td><td style="text-align: center;">9</td><td style="text-align: center;">35</td></tr><tr><td style="text-align: center;">21</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">26</td><td style="text-align: center;">10</td><td style="text-align: center;">36</td></tr><tr><td style="text-align: center;">22</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">27</td><td style="text-align: center;">11</td><td style="text-align: center;">34</td></tr><tr><td style="text-align: center;">23</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">28</td><td style="text-align: center;">15</td><td style="text-align: center;">13</td></tr><tr><td style="text-align: center;">24</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">29</td><td style="text-align: center;">34</td><td style="text-align: center;">12</td></tr><tr><td style="text-align: center;">25</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">20</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">26</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">21</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">27</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">22</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">28</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">23</td><td style="text-align: center;">None</td><td style="text-align: center;">17</td></tr><tr><td style="text-align: center;">29</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">24</td><td style="text-align: center;">None</td><td style="text-align: center;">16</td></tr><tr><td style="text-align: center;">30</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">16</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">31</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">17</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">32</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">18</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">33</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">19</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">34</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">24</td><td style="text-align: center;">22</td></tr><tr><td style="text-align: center;">35</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">None</td><td style="text-align: center;">20</td></tr><tr><td style="text-align: center;">36</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">None</td><td style="text-align: center;">21</td></tr></tbody></table></div></details><p>Hence for any word <span class="math inline">\(w=s_{i_0}s_{i_1}\cdotss_{i_n}\)</span>, we can start from the first row of <span class="math inline">\(T\)</span>, find the index of <span class="math inline">\(s_{i_n}\)</span> in <span class="math inline">\(L\)</span>, say <span class="math inline">\(k\)</span>, then jump to the <span class="math inline">\(k\)</span>-th row and find the index of <span class="math inline">\(s_{i_{n-1}}s_{i_n}\)</span> in <span class="math inline">\(L\)</span>, …, and finally get the index of <span class="math inline">\(w\)</span> (or <code>None</code>).</p><p>Suppose the reflection of the initial vertex <span class="math inline">\(v_0\)</span> about the <span class="math inline">\(i\)</span>-th mirror gives a virtual image <span class="math inline">\(v_1=s_i(v_0)\)</span>, then <span class="math inline">\(e=(v_0,v_1)\)</span> is an edge of type <span class="math inline">\(i\)</span>. By the orbit-stabilizer theorem alledges of type <span class="math inline">\(i\)</span> can be obtained byapplying the coset representatives in <span class="math inline">\(G/H\)</span> to <span class="math inline">\(e\)</span>, where <span class="math inline">\(H=\langle i\rangle\)</span> is the stabilizingsubgroup of <span class="math inline">\(e\)</span> (<span class="math inline">\(H\)</span> is called a standard parabolicsubgroup). It’s easy to see the words of the two ends of <span class="math inline">\(e\)</span> are <span class="math inline">\(1\)</span> and <span class="math inline">\(s_i\)</span> respectively. We then compute thecoset representatives of the words in <span class="math inline">\(L\)</span> for the subgroup <span class="math inline">\(H\)</span>, use a set to remove duplicates, applyeach resulting coset representative <span class="math inline">\(w\)</span> to the two ends of <span class="math inline">\(e\)</span>. The words of the two ends of <span class="math inline">\(w\cdot e\)</span> are <span class="math inline">\(w\)</span> and <span class="math inline">\(ws_i\)</span> respectively. We can find theindices of <span class="math inline">\(w\)</span> and <span class="math inline">\(ws_i\)</span> as shown above to get <span class="math inline">\(w\cdot e\)</span>.</p><p>The edges between the 37 vertices in <span class="math inline">\(L\)</span> are drawn below:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/723_edges.png" width="500"></p><p>0 is the initial vertex, the number of white strips in an edgeindices the type of it (no white strips for <span class="math inline">\(s_0\)</span>, one for <span class="math inline">\(s_1\)</span> and two for <span class="math inline">\(s_2\)</span>).</p><p>It’s worth noting that one can easily read the shortlex wordrepresentation of any vertex <span class="math inline">\(v\)</span> fromthe above image, just start from vertex 0, trace a shortest path from 0to <span class="math inline">\(v\)</span> (if there are more than oneshortest path then always choose the smaller vertex at bifurcatonpoints) and record the edges along the way. For example there are twopaths with shortest length from vetex 0 to vertex 33: <span class="math display">\[\begin{align*}&amp;0\xrightarrow{\ s_1\ }2\xrightarrow{\ s_0\}6\xrightarrow{\ s_2\ }13\xrightarrow{\ s_1\ }22\xrightarrow{\ s_0\}33.\\&amp;0\xrightarrow{\ s_1\ }2\xrightarrow{\ s_2\ }7\xrightarrow{\ s_0\}13\xrightarrow{\ s_1\ }22\xrightarrow{\ s_0\ }33.\end{align*}\]</span> By concatenating edge labels from left to right wehave two words that both map vertex 0 to vertex 33: <span class="math inline">\(s_1s_0s_2s_1s_0\)</span> and <span class="math inline">\(s_1s_2s_0s_1s_0\)</span>. The first is theshortlex one.</p><blockquote><p><strong>Question 2</strong>: How to compute the normal form of themultiplicaiton of two words? How to compute the coset representative ofa word for a standard parabolic subgroup?</p></blockquote><p>Again the answer is too long to be included here. A short sketch ofthe procedure is attached below.</p><p>The procedure for computing faces is very similar with the case ofedges. The reflections about the <span class="math inline">\(i\)</span>-th and <span class="math inline">\(j\)</span>-th mirrors generate a polygon <span class="math inline">\(f_0\)</span> centered at a vertex of thefundamental triangle. The stabilizing subgroup of <span class="math inline">\(f_0\)</span> is the standard parabolic subgroup<span class="math inline">\(\langle i,j\rangle\)</span>. Again we find aword representation for each vertex in <span class="math inline">\(f_0\)</span>, apply the words in <span class="math inline">\(L\)</span> to <span class="math inline">\(f_0\)</span>, and use <span class="math inline">\(T\)</span> to get the indices of the transformedface.</p><p>The final image is shown below, it contains 30517 vertices, 42057edges and 11541 polygons.</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-7-2-3.png" width="500"></p><h1 id="about-the-code">About the code</h1><p>The entire code mainly includes the following functionalities:</p><ol type="1"><li>Computation of Coxeter groups. This part is implemented by the<code>CoxeterGroup</code> class in the <code>coxeter</code> module. Thecomputation of Coxeter groups includes the following aspects:<ul><li>Compute the minimal root reflection table of the Coxeter group.</li><li>Compute the multiplication of two words in the Coxeter group, andreturning the result in its normal form.</li><li>Compute the coset representatives of group elements with respect toa given standard parabolic subgroup, and returning the result in itsnormal form.</li><li>Compute of the finite state machine that recognizes <span class="math inline">\(\mathcal{SL}(W)\)</span>, minimizing it, anddrawing the state machine.</li></ul></li><li>Tiling drawing. Mainly implemented in the <code>tiling.py</code>file. It includes the following steps:<ul><li>For a given Coxeter group and specified initial vertex position,calculate the reflection mirrors and fundamental domain.</li><li>Compute the normal forms of all vertices, as well as the connectionsof edges and faces.</li><li>Apply the words of vertices obtained in the previous step to theinitial vertex to obtain the floating-point coordinates of all vertices.These calculations are all performed in one higher dimension, because inthe higher dimension all reflections are linear transformations, whichavoids the use of affine transformations and inversion. Then project totwo dimensions.</li><li>Call the drawing library to draw the tiling.</li></ul></li></ol><p>The drawing of the finite state machine of <span class="math inline">\(\mathcal{SL}(W)\)</span> requires the use of the<code>pygraphviz</code> module, which depends on the<code>graphviz</code> software and <code>libgraphviz-dev</code>.</p><p>The minimization of the finite state machine was referenced from <a href="https://link.springer.com/article/10.1007/BF00264025">Gries’spaper</a>. Gries’s article is excellent, but I think he did not clarifythe property of the list that storing the <span class="math inline">\((B,a)\)</span> pairs.</p><p>The drawing of the hyperbolic case uses a third-party library <a href="https://github.com/cduck/hyperbolic/">hyperbolic</a>. I’m actuallynot very satisfied with this library, but I don’t have the energy towrite another one at the moment, so I’ll make do for now. The biggestadvantage of this library is that it can draw edges with a constanthyperbolic width, namely the so-called <a href="https://en.wikipedia.org/wiki/Hypercycle_(hyperbolic_geometry)">hypercycle</a>.</p><p>The algorithm for calculating minimal roots is the biggestperformance bottleneck in this code. In determining whether a minimalroot <span class="math inline">\(\gamma\)</span> remains a minimal rootafter a single reflection <span class="math inline">\(s_\alpha\)</span>,the method used is to determine whether <span class="math inline">\(s_\gamma\)</span> and <span class="math inline">\(s_\alpha\)</span> generate a finite dihedralgroup, that is, whether the matrix corresponding to <span class="math inline">\(s_\gamma s_\alpha\)</span> under the basis <span class="math inline">\(\Delta\)</span> of simple roots becomes theidentity matrix after a certain power. The elements of the matrix arealgebraic integers in the cyclotomic field, in the form of <span class="math inline">\(p(\xi)\)</span>, where <span class="math inline">\(p(x)\)</span> is an irreducible polynomial withinteger coefficients, and <span class="math inline">\(\xi\)</span> is aprimitive <span class="math inline">\(m\)</span>-th root of unity, where<span class="math inline">\(m\)</span> is twice the least commonmultiple of all elements in the Coxeter matrix. <span class="math inline">\(\xi\)</span> can be described by the cyclotomicpolynomial <span class="math inline">\(\Phi_m(x)\)</span>. Thus, thecomputation of the matrix is reduced to polynomial operations in <span class="math inline">\(\mathbb{Z}[x]/(\Phi_m(x))\)</span>. Thiscomputational complexity heavily depends on the value of <span class="math inline">\(m\)</span>: for example, for a triangle group like(19, 20, 21), the expression of <span class="math inline">\(\Phi_m(x)\)</span> is very complicated, and thecomputation speed is very slow. This is different from the inverse pixelreflection method, whose computational complexity hardly changes withthe group.</p><p>A more reasonable implementation method can be seen <a href="https://github.com/ulthiel/CoxeterGroups.jl">here</a>.</p><h1 id="more-explainations-on-the-math-stuff">More explainations on themath stuff</h1><p>In this section I’ll give a short sketch of the core part of the mathstuff. This requires you know some basic concepts like geometricrealizations of Coxeter groups, Tit’s cone, root systems. These arefairly standard materials and can be found in Humphreys’s book.</p><p>Almost everything relies upon a 2d table called <strong>reflectiontable of minimal roots</strong>. Again we use group (7, 2, 3) asexample:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/roots.png" width="800"></p><p>This image is the same with the last one except that it has 12labelled mirrors, these mirror have particular importance among allroots in the root system: they are the set of minimal roots in the rootsystem.</p><p>You can think the root system of <span class="math inline">\(W\)</span> as all the circular arcs in thediagram, each of which is a reflection mirror. These mirrors are theresult of the action of the group <span class="math inline">\(W\)</span>on the initial mirrors <span class="math inline">\(AB, AC, BC\)</span>that are the edges of <span class="math inline">\(\Delta ABC\)</span>.Each mirror has two sides, where the side where the fundamental domain<span class="math inline">\(\Delta ABC\)</span> is located is consideredthe positive side of the mirror, and the other side is the negativeside. The normal vector of the mirror’s positive side gives a positiveroot, while the normal vector corresponding to the other side is thenegative of that positive root (negative root).</p><p>We always use a mirror’s positive normal vector (positive root) torepresent that mirror.</p><p>Intuitively, a minimal root <span class="math inline">\(\gamma\)</span> is characterized by the followingcondition: suppose a person stands inside <span class="math inline">\(\Delta ABC\)</span> looking outward, there existsno mirror <span class="math inline">\(\beta \neq \gamma\)</span>completely blocking the view of <span class="math inline">\(\gamma\)</span>, preventing the person from seeingany part of <span class="math inline">\(\gamma\)</span>. In other words,this means that if the person wants to walk from the inside of <span class="math inline">\(\Delta ABC\)</span> to the negatve side of <span class="math inline">\(\gamma\)</span>, and he must cross another mirror<span class="math inline">\(\beta \neq \gamma\)</span> first, regardlessof the path he chooses, then <span class="math inline">\(\gamma\)</span>is <strong>not</strong> a minimal root.</p><p>Simple roots are necessarily minimal roots, as they are theboundaries of the fundamental domain <span class="math inline">\(\DeltaABC\)</span>, and it is impossible for there to be another mirrorblocking between them and the basic region.</p><p>The most important fact about minimal root is:</p><blockquote><p><strong>Theorem</strong>: The set of minimal roots is finite.</p></blockquote><p>This theorem is the key step in Brink and Howlett’s proof thatCoxeter groups are automatic groups.</p><p>The reflection table of minimal roots <code>reftable</code> isdefined as follows: it’s a 2d array with its <span class="math inline">\(i\)</span>-th row correspondes to the <span class="math inline">\(i\)</span>-th minimal root <span class="math inline">\(\alpha_i\)</span> and <span class="math inline">\(j\)</span>-th column correspondes to the <span class="math inline">\(j\)</span>-th generator <span class="math inline">\(s_j\)</span>. The <span class="math inline">\((i,j)\)</span>-entry records the action of <span class="math inline">\(s_j\)</span> on <span class="math inline">\(\alpha_i\)</span>. Let <span class="math inline">\(\beta=s_j(\alpha_i)\)</span>:</p><ol type="1"><li>If <span class="math inline">\(\beta=\alpha_k\)</span> is the <span class="math inline">\(k\)</span>-th minimal root then set this entry to<span class="math inline">\(k\)</span>.</li><li>If <span class="math inline">\(\beta\)</span> is a negative rootthen set this entry to <span class="math inline">\(-1\)</span>.</li><li>Else <span class="math inline">\(\beta\)</span> is a positive rootbut not minimal, set this entry to <code>None</code>.</li></ol><p>The <code>reftable</code> of the (7, 2, 3) group is listed below:</p><table><thead><tr><th style="text-align: center;">root</th><th style="text-align: center;"><span class="math inline">\(s_0\)</span></th><th style="text-align: center;"><span class="math inline">\(s_1\)</span></th><th style="text-align: center;"><span class="math inline">\(s_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">-1</td><td style="text-align: center;">3</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">4</td><td style="text-align: center;">-1</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">5</td><td style="text-align: center;">-1</td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">6</td><td style="text-align: center;">0</td><td style="text-align: center;">7</td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;">1</td><td style="text-align: center;">8</td><td style="text-align: center;">9</td></tr><tr><td style="text-align: center;">5</td><td style="text-align: center;">9</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">6</td><td style="text-align: center;">3</td><td style="text-align: center;">10</td><td style="text-align: center;">11</td></tr><tr><td style="text-align: center;">7</td><td style="text-align: center;">11</td><td style="text-align: center;">7</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">8</td><td style="text-align: center;">10</td><td style="text-align: center;">4</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">9</td><td style="text-align: center;">5</td><td style="text-align: center;">None</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;">10</td><td style="text-align: center;">8</td><td style="text-align: center;">6</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">11</td><td style="text-align: center;">7</td><td style="text-align: center;">None</td><td style="text-align: center;">6</td></tr></tbody></table><p>Let <span class="math inline">\(\Sigma\)</span> be the set of minimalroots of <span class="math inline">\(G\)</span>, all states in theautomaton are subsets of <span class="math inline">\(\Sigma\)</span>,the transition rule between the subsets is:</p><p><span class="math display">\[S\xrightarrow{\ s_i\ } \{s_i\} \cup(s_i(S)\cup\{ s_i(\alpha_j),j&lt;i\})\cap\Sigma.\]</span></p><p>One can use breadth-first search to build this automaton and use <a href="https://en.wikipedia.org/wiki/DFA_minimization#Hopcroft's_algorithm">Hopcroft’salgorithm</a> to get a minimized version of it.</p><p>The image below shows the subsets of minimal roots for each state inthe automaton:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/723_dfa_subsets.png" width="800"></p><p>The code for computing the multiplication of a generator and a wordis given below:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">left_mul_invshortlex</span>(<span class="hljs-params">reftable, s, w</span>):<br>    w = <span class="hljs-built_in">tuple</span>(w)<br>    t = s<br>    k = -<span class="hljs-number">1</span><br>    mu = s<br>    <span class="hljs-keyword">for</span> i, s_i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(w):<br>        <span class="hljs-keyword">if</span> mu <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> w[:k+<span class="hljs-number">1</span>] + (t,) + w[k+<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">elif</span> mu &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> w[:i] + w[i+<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">elif</span> mu &lt; s_i:<br>            t = mu<br>            k = i<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">return</span> w[:k+<span class="hljs-number">1</span>] + (t,) + w[k+<span class="hljs-number">1</span>:]<br></code></pre></td></tr></tbody></table></figure><p>Here <span class="math inline">\(s\)</span> is a generator and <span class="math inline">\(w\)</span> is a word in the normal form of the<em>inverse shortlex ordering</em> (invshortlex). The function returnsthe normal form of <span class="math inline">\(s\cdot w\)</span> also inthe invshortlex ordering. The computations in shortlex can be obtainedby doing computations in invshortlex first and then reverse the resultback.</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>The intermedian step of doing computations in invshortlexordering is mainly for keeping consistent with Casselman’s paper.</p></div><p>Finding the coset representative of a given word for a standardparabolic subgroup is quite straight-forward: let <span class="math inline">\(T\)</span> be the set of generators of thisstandard parabolic subgroup, the pseudocode for the procedure is givenbelow:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">x := w<br>u := 1<br>while l(xt) &lt; l(x) for some t in T<br>    x := xt<br>    u := t<br>end<br><br>return x<br></code></pre></td></tr></tbody></table></figure><p>Where <span class="math inline">\(l(\cdot)\)</span> is the lengthfunction.</p><p>For finite Coxeter groups all positive roots are minimal. For affineCoxeter groups the root system consists of families of parallel affinehyperplanes. In each family there is a pair of minimal roots such thatthe fundamental domain lies between them and all other mirrors in thisfamily are completely screened off by them hence are not minimal. Seethe image for (6, 2, 3) (affine <span class="math inline">\(\widetilde{G}_2\)</span>) for an example:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/roots_623.png" width="600"></p><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://www.math.ubc.ca/~cass/research/pdf/banff.pdf">Automata toperform basic calculations in Coxeter groups, by Bill Casselman</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://www.math.ubc.ca/~cass/research/pdf/cm.pdf">Computation inCoxeter groups I. Multiplication, by Bill Casselman</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://www.math.ubc.ca/~cass/research/pdf/roots.pdf">Computationin Coxeter groups II. Constructing minimal roots, by BillCasselman</a>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>Reflection Groups and Coxeter Groups, by James E.Humphreys.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd Kemp 概率论课程笔记</title>
      <link href="/todd-kemp/index.html"/>
      <url>/todd-kemp/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="banach-tarski">✅ 0 Banach Tarski</h1><div id="---------------------" class="statement sta________ definition unnumbered"><p><span class="statement-heading"><span class="statement-label">不可测集的例子</span>：</span><span class="statement-spah"> </span>记单位圆 <span class="math inline">\(S^1=\{e^{it},\,t\in\mathbb{R}\}\)</span>，子群<span class="math inline">\(H=\{e^{iq},\,q\in\mathbb{Q}\}\)</span>，在每个左陪集<span class="math inline">\(S^1/H\)</span> 中选择一个代表元组成集合<span class="math inline">\(E\)</span>，则 <span class="math inline">\(E\)</span> 是不可测集合。这是因为 <span class="math inline">\(S^1 = \bigcup_{q\in\mathbb{Q}}Ee^{iq}\)</span>是可数多个互不相交的集合的并，这些集合两两之间只差乘以一个单位复数，即差一个旋转，所以测度均相等，于是<span class="math display">\[1 = \sum_{q\in\mathbb{Q}}\mu(E) =\infty\cdot \mu(E)\Rightarrow E\text{ not measuabe.}\]</span></p></div><h1 id="probability-motivation">✅ 1.1 Probability Motivation</h1><p>无要点</p><h1 id="sigma--fields">✅ 1.2 <span class="math inline">\(\sigma\)</span>- Fields</h1><p>介绍了 <span class="math inline">\(\sigma\)</span>-域的概念，以及最重要的 <span class="math inline">\(\sigma\)</span>-域的例子：拓扑空间中开集生成的 Borel 域。</p><h1 id="measures-definition-and-examples">✅ 2.1 Measures Definition andExamples</h1><p>介绍了可测空间，以及测度的定义和基本性质。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(\mathcal{F}\)</span> 是一个 <span class="math inline">\(\sigma\)</span>- 域，称 <span class="math inline">\(\mu:\ \mathcal{F}\to[0,\infty]\)</span>是测度，如果对任何可数多个不交并有 <span class="math inline">\(\mu(\uplus_{n=1}^\inftyE_n)=\sum_{n=1}^\infty\mu(E_n)\)</span> 成立。</p></div><p>测度的三个基本性质：</p><ul><li>单调性：<span class="math inline">\(A\subseteq B\Rightarrow\mu(A)\leq\mu(B)\)</span>。</li><li>加法等式 <span class="math inline">\(\mu(A\cup B) + \mu(A\cap B) =\mu(A) + \mu(B)\)</span>。</li><li>次可数可加：<span class="math inline">\(\mu(\cup_{n=1}^\inftyE_n)\leq\sum_{n=1}^\infty\mu(E_n)\)</span>。</li></ul><p>此外如果 <span class="math inline">\(\{\mu_n\}_{n=1}^\infty\)</span>是一列测度，则它们的和 <span class="math inline">\(\mu=\sum\limits_{n=1}^\infty\mu_n\)</span>也是测度。</p><p>预告了接下来构造测度的过程：有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 预测度 <span class="math inline">\(\Rightarrow\)</span> ·测度。</p><h1 id="finitely-additive-measures">✅ 2.2 Finitely AdditiveMeasures</h1><p>这一讲介绍了<strong>有限可加测度</strong>，<strong>预测度(pre-measure，即域上的可数可加测度)</strong>，<strong>半代数(semi-algebra)</strong> 等概念。</p><div class="unnumnered statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.1</span>.</span></p><ol type="1"><li>域上的可数可加测度叫做 <strong>预测度</strong>。</li><li>域上的有限可加测度叫做 <strong>有限可加测度</strong>。</li></ol></div><blockquote><p><strong>核心思想</strong>：半代数 <span class="math inline">\(\mathcal{S}\)</span> 上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数 <span class="math inline">\(\mathcal{A}\)</span> 上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数 <span class="math inline">\(\mathcal{A}\)</span> 上的可数可加测度 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\sigma\)</span>- 域上的可数可加测度。</p></blockquote><p>域 <span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度的基本性质：</p><ul><li>单调性、加法等式同可数可加的情形。</li><li><strong>超可数可加</strong>：如果 <span class="math inline">\(\{E_n\}_{n=1}^{\infty}\)</span>是一列不相交的集合，每个 <span class="math inline">\(E_n\in\mathcal{A}\)</span> 并且 <span class="math inline">\(\mu(\uplus_{n=1}^\inftyE_n)\in\mathcal{A}\)</span>。则 <span class="math inline">\(\mu(\uplus_{n=1}^\inftyE_n)\geq\sum_{n=1}^\infty\mu(E_n)\)</span>。这是由于单调性左边始终是右边部分和的上界。</li></ul><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.2</span>.</span><span class="statement-spah"> </span>一个半代数 <span class="math inline">\(\mathcal{S}\)</span>是指满足如下条件的集合族：</p><ol type="1"><li><span class="math inline">\(\emptyset\in\mathcal{S}\)</span>。</li><li>若 <span class="math inline">\(A,\,B\in\mathcal{S}\)</span> 则 <span class="math inline">\(A\cap B\in\mathcal{S}\)</span>。</li><li>若 <span class="math inline">\(A\in\mathcal{S}\)</span> 则 <span class="math inline">\(A^c\)</span> 可以表示为 <span class="math inline">\(\mathcal{S}\)</span> 中有限多个成员的不交并。</li></ol></div><p>半代数 <span class="math inline">\(\mathcal{S}\)</span> 生成一个代数<span class="math inline">\(\mathcal{A}\)</span>： <span class="math display">\[\mathcal{A}=\{\text{all finite disjoint unions ofsets from }\mathcal{S} \}.\]</span></p><p>第一步<strong>半代数 <span class="math inline">\(\mathcal{S}\)</span>上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数<span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度</strong>：这一步是显然的，只需要验证定义不依赖于 <span class="math inline">\(\mathcal{A}\)</span> 作为 <span class="math inline">\(\mathcal{S}\)</span>中集合不交并的表示方式即可。</p><p>第三步<strong>代数 <span class="math inline">\(\mathcal{A}\)</span>上的可数可加测度 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\sigma\)</span>-域上的可数可加测度</strong>：这一步总是可以做到的，由后面的测度扩张定理给出。</p><p>第二步<strong>代数 <span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数<span class="math inline">\(\mathcal{A}\)</span>上的可数可加测度</strong>：这一步并不总是可以做到。举个例子，在是整数集<span class="math inline">\(\mathbb{Z}\)</span> 的所有子集上定义如下测度<span class="math inline">\(\mu\)</span>：若子集 <span class="math inline">\(E\)</span> 或者 <span class="math inline">\(E^c\)</span> 之一是有限集，则规定 <span class="math inline">\(\mu(E)=0\)</span>，否则 <span class="math inline">\(\mu(E)=1\)</span>。此测度有限可加但不是可数可加，所以也不会有可数可加的扩张。</p><p>最重要的半代数 <span class="math inline">\(\mathcal{S}\)</span>的例子：所有形如 <span class="math inline">\(\{(a, b],-\infty\leqa&lt;b\leq \infty\}\)</span> 的半开区间。</p><p>任何单调函数 <span class="math inline">\(F\)</span>都可以给出其上的一个有限可加测度：<span class="math inline">\(F((a, b]))= F(b) - F(a)\)</span>，从而可以扩张为代数 <span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度。<strong>但是要使得这个测度是可数可加的，我们必须限制<span class="math inline">\(F\)</span>是右连续的</strong>，这样的测度叫做 Stieltjes 测度，会在下一讲介绍。</p><h1 id="stieltjes-premeasures">✅ 3.1 Stieltjes Premeasures</h1><p>本讲接着上一讲的内容，证明了当 <span class="math inline">\(F\)</span>单调且右连续时，<span class="math inline">\(\mu((a,b])=F(b)-F(a)\)</span> 确实给出 Borel 域<span class="math inline">\(\mathcal{A}\)</span>上的一个可数可加测度。当然 Borel 域还是太复杂了(虽然它们都是有限多个半开区间的不交并)，无法用可数可加的定义来验证。我们还是要回到由半开区间构成的半代数<span class="math inline">\(\mathcal{S}\)</span> 上。</p><p>我们要从有限可加推出可数可加，而有限可加蕴涵了可数<strong>超</strong>可加，所以我们还缺少可数<strong>次</strong>可加。而<span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>上的可数次可加实际上可以由 <span class="math inline">\(\mathcal{S}\)</span> 上的可数次可加给出：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>代数 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span> 上的有限可加测度<span class="math inline">\(\mu\)</span>是可数可加的，<strong>当且仅当它限制在 <span class="math inline">\(\mathcal{S}\)</span>上是次可数可加的</strong>。</p></div><p>这个话需要仔细解释清楚：<span class="math inline">\(\mu\)</span> 在<span class="math inline">\(\mathcal{S}\)</span> 上次可数可加是指如果<span class="math inline">\(\{E_n\}\)</span> 是半代数 <span class="math inline">\(\mathcal{S}\)</span>中互不相交的集合，并且它们的可数并 <span class="math inline">\(\uplus_{n} E_n\)</span> 也在半代数 <span class="math inline">\(\mathcal{S}\)</span> 中，则 <span class="math inline">\(\mu(\uplus_nE_n)\leq\sum_n\mu(E_n)\)</span>。</p><p><strong>证明概要</strong>：<span class="math inline">\(\Rightarrow\)</span>是显然的，可数可加必然蕴含次可数可加。</p><p><span class="math inline">\(\Leftarrow\)</span>：<span class="math inline">\(\mu\)</span> 作为 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>上的有限可加测度自然是超可数可加的，要证明它可数可加，只要再证明它次可数可加：即若<span class="math inline">\(\uplus_n A_n\)</span> 是 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>中的可数不交并，则 <span class="math inline">\(\mu(\uplus_nA_n)\leq\sum_n\mu(A_n)\)</span>。记住 <span class="math inline">\(\uplus_n A_n\)</span> 以及所有 <span class="math inline">\(A_n\)</span> 现在都是 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span> 中的元素，所以<span class="math inline">\(\uplus_n A_n = \uplus_{j=1}^NE_j\)</span>，其中 <span class="math inline">\(E_j\in\mathcal{S}\)</span>。于是 <span class="math display">\[E_j = \uplus_n (A_n\capE_j)=\uplus_n\uplus_{i=1}^{N_n}E_i^n\cap E_j.\]</span> 利用 <span class="math inline">\(\mu\)</span> 在 <span class="math inline">\(\mathcal{S}\)</span> 上的次可数可加性有 <span class="math display">\[\mu(E_j)\leq \sum_n\sum_{i=1}^{N_n}\mu(E_i^n\capE_j).\]</span> 再利用 <span class="math inline">\(\mu\)</span> 在 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span> 上的有限可加性有<span class="math display">\[\sum_{i=1}^{N_n}\mu(E_i^n\capE_j)=\mu(A_n\cap E_j).\]</span> 于是 <span class="math display">\[\mu(\uplus_jE_j)=\sum_{j=1}^N\mu(E_j)\leq\sum_{j=1}^N\sum_{n=1}^\infty\mu(A_n\capE_j)=\sum_{n=1}^\infty\sum_{j=1}^N\mu(A_n\capE_j)=\sum_{n=1}^\infty\mu(A_n).\]</span> 即为所证。</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>由单调右连续的函数 <span class="math inline">\(F\)</span>给出的半代数 <span class="math inline">\(\mathcal{S}=\{(a,b]\-\infty\leq a&lt;b\leq\infty\}\)</span> 上的 Stieltjes测度是次可数可加的，因而由上面引理它给出 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>上的可数可加测度。</p></div><p><strong>Todd-Kemp 的精彩证明讲解</strong>：设 <span class="math inline">\((a,b]=\uplus_{i=1}^\infty (a_i,b_i]\)</span>，我们要证明 <span class="math display">\[F(b)-F(a)=\mu((a,b])\leq\sum_{i=1}^\infty\mu((a_i,b_i])=\sum_{i=1}^\infty(F(b_i)-F(a_i)).\]</span> 我们可以先假设 <span class="math inline">\(a,b\)</span> 都是有限的。</p><p><strong>不要幻想可以给区间 <span class="math inline">\((a_i,b_i]\)</span>之间按照大小排顺序，它们可能有无穷多个聚点</strong>。</p><p><strong>想法是把 <span class="math inline">\((a, b]\)</span>缩小一点变成 <span class="math inline">\([a+\delta, b]\)</span>，把<span class="math inline">\((a_i,b_i]\)</span> 放大一点变成 <span class="math inline">\((a_i,b_i+\delta_i)\)</span>，这样可以使用紧集的有限开覆盖性质</strong>。从而存在<span class="math inline">\(N\)</span> 使得前 <span class="math inline">\(N\)</span> 个开区间就足以覆盖 <span class="math inline">\([a+\delta,b]\)</span>： <span class="math display">\[[a+\delta,b] \subseteq \cup_{j=1}^N (a_j,b_j+\delta_j).\]</span> 现在 <span class="math inline">\(\mu\)</span>作为一个有限可加测度，由于 <span class="math inline">\((a+\delta,b]\)</span> 被 <span class="math inline">\(\cup_{j=1}^N (a_j,b_j+\delta_j]\)</span> 覆盖，因而必然有 <span class="math display">\[\mu((a+\delta, b])\leq \sum_{j=1}^N \mu((a_j,b_j+\delta_j])\leq\sum_{j=1}^\infty \mu((a_j, b_j+\delta_j]).\]</span>上式左边等于 <span class="math inline">\(F(b)-F(a+\delta)\)</span>，<span class="math inline">\(\delta\)</span> 是任意正数，所以令其趋于 0 并利用<span class="math inline">\(F\)</span> 的右连续有 <span class="math inline">\(F(a+\delta)\downarrow F(a)\)</span>，所以上式变为<span class="math display">\[\mu((a, b])\leq\sum_{j=1}^\infty\mu((a_j,b_j+\delta_j])=\sum_{j=1}^\infty \mu((a_j, b_j]) + \sum_{j=1}^\infty\mu((b_j, b_j+\delta_j]).\]</span> 注意到 <span class="math inline">\(\delta_j\)</span> 也是任意的，并且 <span class="math inline">\(F\)</span> 右连续，所以对任何 <span class="math inline">\(\epsilon&gt;0\)</span> 我们可以取 <span class="math inline">\(\delta_j\)</span> 足够小，使得 <span class="math inline">\(F(b_j+\delta_j)- F(b_j) &lt;\epsilon/2^j\)</span>。于是 <span class="math display">\[\mu((a,b])\leq\sum_{j=1}^\infty\mu((a_j, b_j+\delta_j])=\sum_{j=1}^\infty\mu((a_j, b_j]) + \epsilon.\]</span> 由 <span class="math inline">\(\epsilon\)</span> 任意性定理得证。</p><h1 id="outer-measure">3.2 Outer Measure</h1><p>这一节介绍了外测度的概念。</p><p>如果我们有一个集合族 <span class="math inline">\(\mathcal{A}\)</span>(<span class="math inline">\(\mathcal{A}\)</span>一般是个代数)，以及其上的函数 <span class="math inline">\(\mu:\\mathcal{A}\to[0,+\infty]\)</span>，则我们可以定义 <span class="math inline">\(2^{\Omega}\)</span> 上的外测度 <span class="math inline">\(\mu^\ast\)</span> 为 <span class="math display">\[\mu^\ast(E) =\inf\left\{\sum_{n=1}^\infty\mu(E_n),\ E_n\in\mathcal{A},E\subset\bigcup_{n=1}^\infty E_n\right\}.\]</span> 外测度 <span class="math inline">\(\mu^\ast\)</span> 满足：</p><blockquote><ol type="1"><li><span class="math inline">\(\mu^\ast(\emptyset)=0\)</span>。</li><li>单调性。</li><li>次可数可加性。</li></ol></blockquote><p>Todd Kemp 视频里面提到 <span class="math inline">\(\mu^\ast\)</span>可以用来区别有限可加测度和预测度：</p><blockquote><ol type="1"><li>如果 <span class="math inline">\((\mu, \mathcal{A})\)</span>是预测度，则<strong>在 <span class="math inline">\(\sigma(\mathcal{A})\)</span> 上有 <span class="math inline">\(\mu(E)\leq\mu^\ast(E)\)</span>，并且在 <span class="math inline">\(\mathcal{A}\)</span> 上有 <span class="math inline">\(\mu=\mu^\ast\)</span></strong>。</li><li>如果 <span class="math inline">\((\mu, \mathcal{A})\)</span>是有限可加测度，则<strong>在 <span class="math inline">\(\mathcal{A}\)</span> 上有 <span class="math inline">\(\mu(E)\geq\mu^\ast(E)\)</span></strong>。</li></ol></blockquote><h1 id="outer-pseudo-metric">4.1 Outer Pseudo-Metric</h1><p>这一节介绍了 Carathéodory 测度扩张定理。设 <span class="math inline">\((\Omega,\mathcal{A},\mu)\)</span>是一个预测度空间。即 <span class="math inline">\(\mu\)</span>是定义在代数 <span class="math inline">\(\mathcal{A}\)</span>上的可数可加测度。我们将把它扩充为 <span class="math inline">\(\sigma(\mathcal{A})\)</span>上的可数可加测度。</p><p>定义外测度 <span class="math inline">\(\mu^\ast:2^\Omega\to[0,\infty]\)</span> 为 <span class="math display">\[\mu^\ast(E)=\inf\left\{\sum_{n=1}^\infty\mu(A_n):E\subseteq\bigcup_{n=1}^\inftyA_n,A_n\in\mathcal{A}\right\}\]</span></p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>存在 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\mathcal{M}\supset\mathcal{A}\)</span> 使得 <span class="math inline">\(\mu^\ast\mid_{\mathcal{M}}\)</span>是可数可加测度。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>Todd Kemp 评论说，<span class="math inline">\(\mathcal{M}\)</span>最大可以是多大是一个非常深刻的技术问题。</p></div><p>标准的证明途径是规定 <span class="math display">\[\mathcal{M}=\{E\in\Omega\mid\mu^\ast(T)=\mu^\ast(T\cap E)+\mu^\ast(T\cap E^c),\forallT\in\Omega\}.\]</span></p><p>这里介绍了 Driver 的方法。这个方法稍微有一点缺陷，它要求 <span class="math inline">\(\mu:\mathcal{A}\to[0,\infty)\)</span>是一个有限测度。稍后也可以扩展到 <span class="math inline">\(\sigma\)</span>-有限测度。在概率论中这足够了。</p><h1 id="radon-measures">✅ 5.1 Radon Measures</h1><p>本讲介绍了实直线上的 Radon 测度等价于 Stieltjes 测度。</p><p>Radon 测度是指对任何紧集 <span class="math inline">\(K\)</span> 有<span class="math inline">\(\mu(K)&lt;\infty\)</span>的测度。这种测度的分布函数必然是单调、右连续的，从而根据之前介绍的预测度和测度扩张定理给出了实直线上的一个可数可加测度。</p><h1 id="lebesgue-measure">✅ 5.2 Lebesgue Measure</h1><p>无要点</p><h1 id="random-variables-motivation">✅ 6.1 Random VariablesMotivation</h1><p>本节介绍了随机变量，分布函数的概念。样本空间 <span class="math inline">\(\Omega\)</span> (modelling space)是难以接触到的，我们对其的观测是通过随机变量来进行的。</p><p>随机变量 <span class="math inline">\(X\)</span> 的分布函数为 <span class="math inline">\(F(t) = \mathbb{P}(X\leq t),\,t\in\overline{\mathbb{R}}\)</span>。<span class="math inline">\(F(t)\)</span> 是单调递增且右连续的。</p><h1 id="measurable-functions">✅ 6.2 Measurable Functions</h1><p>本讲介绍了测度空间上可测映射的概念。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理12.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(f:\Omega\to\mathcal{S}\)</span> 是一个映射，<span class="math inline">\(\mathcal{A}\subset2^\mathcal{S}\)</span> 是 <span class="math inline">\(\mathcal{S}\)</span> 中一个集合族，定义 <span class="math display">\[f^{-1}(\mathcal{A}) =\{f^{-1}(E),E\in\mathcal{A}\}.\]</span> 则 <span class="math inline">\(\sigma(f^{-1}(\mathcal{A}))=f^{-1}(\sigma(\mathcal{A}))\)</span>。</p></div><p>引理的证明不难， 只要注意到一个 <span class="math inline">\(\sigma\)</span>- 域在映射下的像 (push forward)和逆映射下的原像 (push back) 都是 <span class="math inline">\(\sigma\)</span>- 域即可。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义12.2</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 和 <span class="math inline">\((\mathcal{S}, \mathcal{B})\)</span>是两个可测空间，我们称 <span class="math inline">\(f:\Omega\to\mathcal{S}\)</span>是一个可测映射，如果有 <span class="math inline">\(f^{-1}(\mathcal{B})\subseteq\mathcal{F}\)</span>。</p></div><p>要检查一个映射是不是可测的，我们不必对每个 <span class="math inline">\(B\in\mathcal{B}\)</span> 都检查，只要对满足 <span class="math inline">\(\sigma(\mathcal{A})=\mathcal{B}\)</span>的一个子集合族 <span class="math inline">\(\mathcal{A}\)</span> 检查有<span class="math inline">\(f^{-1}(\mathcal{A})\subseteq\mathcal{F}\)</span>即可。这是因为由上面的引理， <span class="math display">\[f^{-1}(\mathcal{B})=f^{-1}(\sigma(\mathcal{A}))=\sigma(f^{-1}(\mathcal{A}))\subseteq\mathcal{F}.\]</span></p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论12.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(X_1,\ldots,X_n\)</span> 都是测度空间 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 上的可测函数，<span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}\)</span>是一个连续或者 Borel 可测的多元函数，则 <span class="math inline">\(Y=f(X_1,\ldots,X_n)\)</span> 也是可测函数。</p></div><p><strong>证明</strong>：记 <span class="math inline">\(X=(X_1,\ldots,X_n)\)</span>，我们要说明复合映射<span class="math display">\[\Omega\xrightarrow{\ X\}\mathbb{R}^n\xrightarrow{\ f\ }\mathbb{R}\]</span> 是可测的。由于 <span class="math inline">\(f\)</span> 显然可测，只要再说明 <span class="math inline">\(X\)</span> 是可测的。根据上面的引理，只要验证<span class="math display">\[X^{-1}\left((-\infty, t_1], (-\infty,t_2],\ldots, (-\infty, t_n]\right)=\bigcap_{i=1}^n \{X_i\leqt_i\}.\]</span> 是可测的，这显然。<span class="math inline">\(\blacksquare\)</span></p><h1 id="robustness-of-measurability">✅ 7.1 Robustness ofMeasurability</h1><p>本讲主要介绍了可测函数集合在通常的运算，以及取极限的操作下得到的仍然是可测函数。</p><p>下面这个结论在整个课程中都会频繁用到：</p><div id="doob-dynkin-------" class="statement sta_doob_dynkin___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Doob-Dynkin 分解</span>.</span><span class="statement-spah"> </span>设有限或者可数指标集 <span class="math inline">\(I=\{1,\ldots,d\}\)</span> 或者 <span class="math inline">\(I=\mathbb{Z}^+\)</span>。 <span class="math display">\[X(\omega)=(X_i(\omega))_{i\in I}\in\mathbb{R}^I.\]</span> 其中每个 <span class="math inline">\(X_i:(\Omega,\mathcal{F})\to(\mathbb{R},\mathcal{B}(\mathbb{R}))\)</span> 都是可测函数。</p><p>设 <span class="math inline">\(Y:(\Omega,\mathcal{F})\to(\mathbb{R},\mathcal{B}(\mathbb{R}))\)</span>且 <span class="math inline">\(Y\)</span> 关于 <span class="math inline">\(\sigma(X_1,\ldots,X_i,\ldots)\)</span>可测。则存在 Borel 可测函数 <span class="math inline">\((\mathbb{R}^I,\mathcal{B}(\mathbb{R}^I))\to\mathbb{R}\)</span>使得 <span class="math display">\[Y=f(X).\]</span></p></div><p><strong>证明</strong>：</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理13.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(T:\Omega\to\Omega'\)</span> 为函数，<span class="math inline">\((\Omega,\mathcal F)\)</span> 与 <span class="math inline">\((\Omega',\mathcal A')\)</span>为可测空间。函数 <span class="math inline">\(f:\Omega\to[0,1]\)</span>关于 <span class="math inline">\(\sigma(T)\)</span> 可测，当且仅当存在<span class="math inline">\(\mathcal A'\)</span> 可测的 <span class="math inline">\(g:\Omega'\to[0,1]\)</span> 使得 <span class="math display">\[f=g\circ T.\]</span></p></div><p>证明：由 <span class="math inline">\(\sigma(T)\)</span>的定义，对任意 <span class="math inline">\(A\in\sigma(T)\)</span> 都存在<span class="math inline">\(A'\in\mathcal A'\)</span> 使 <span class="math display">\[A=T^{-1}(A').\]</span></p><p><strong>Step 1 示性函数</strong></p><p>若 <span class="math inline">\(f=\mathbb{1}_A\)</span> 且 <span class="math inline">\(A\in\sigma(T)\)</span>，取 <span class="math inline">\(A'\in\mathcal A'\)</span> 使 <span class="math inline">\(A=T^{-1}(A')\)</span>，令 <span class="math inline">\(g=\mathbb{1}_{A'}:\Omega'\to[0,1]\)</span>，则<span class="math inline">\(g\)</span> 可测且 <span class="math display">\[g\circ T=\mathbb{1}_{A'}\circT=\mathbb{1}_{T^{-1}(A')}=\mathbb{1}_A=f.\]</span></p><p><strong>Step 2 简单函数</strong></p><p>若 <span class="math inline">\(f=\sum_{k=1}^ma_k\mathbb{1}_{A_k}\)</span>，其中 <span class="math inline">\(a_k\in[0,1]\)</span>、<span class="math inline">\(A_k\in\sigma(T)\)</span>。对每个 <span class="math inline">\(k\)</span> 取 <span class="math inline">\(A_k'\in\mathcal A'\)</span> 满足 <span class="math inline">\(A_k=T^{-1}(A_k')\)</span>，并令 <span class="math display">\[g:=\sum_{k=1}^ma_k\mathbb{1}_{A_k'}:\Omega'\to[0,1].\]</span> 则 <span class="math inline">\(g\)</span> 可测且 <span class="math inline">\(g\circ T=f\)</span>。</p><p><strong>Step 3 一般可测函数</strong></p><p>取单调递增的简单函数列 <span class="math inline">\(f_n\uparrowf\)</span>。由第二步，对每个 <span class="math inline">\(n\)</span>存在可测 <span class="math inline">\(g_n:\Omega'\to[0,1]\)</span> 使<span class="math inline">\(f_n=g_n\circ T\)</span>。定义 <span class="math display">\[g(x):=\sup_{n\ge1} g_n(x),\qquadx\in\Omega'.\]</span> 对任意 <span class="math inline">\(\omega\in\Omega\)</span>， <span class="math display">\[g\bigl(T(\omega)\bigr)=\sup_ng_n\bigl(T(\omega)\bigr)=\sup_n f_n(\omega)=f(\omega).\]</span> 于是 <span class="math inline">\(f=g\circ T\)</span>。</p><p><strong>从 <span class="math inline">\([0,1]\)</span> 推广到 <span class="math inline">\(\mathbb R\)</span></strong></p><p>取一个 Borel 同构 <span class="math inline">\(\phi:\mathbbR\to(0,1)\)</span>（例如 <span class="math inline">\(\phi(t)=\tfrac1\pi\arctant+\tfrac12\)</span>）。若 <span class="math inline">\(Y:\Omega\to\mathbbR\)</span> 关于 <span class="math inline">\(\sigma(T)\)</span> 可测，则<span class="math inline">\(\phi\circ Y:\Omega\to(0,1)\)</span>亦可测。由引理存在可测 <span class="math inline">\(g:\Omega'\to[0,1]\)</span> 使 <span class="math display">\[\phi\circ Y=g\circ T.\]</span> 令 <span class="math display">\[f:=\phi^{-1}\circg:\Omega'\to\mathbb{R}.\]</span> 则 <span class="math inline">\(f\)</span> Borel 可测且 <span class="math inline">\(Y=f\circ T\)</span>。</p><p><strong>应用于 Doob–Dynkin（<span class="math inline">\(\mathbb{R}^d\)</span> 与 <span class="math inline">\(\mathbb{R}^\infty\)</span>）</strong></p><p>取指标集 <span class="math inline">\(I=\{1,\dots,d\}\)</span>（有限维）或 <span class="math inline">\(I=\mathbb{Z}^+\)</span>。给定可测 <span class="math inline">\(X_i:(\Omega,\mathcal{F})\to(\mathbb{R},\mathcal{B}(\mathbb{R}))\)</span>，定义<span class="math display">\[X:=(X_i)_{i\in I}:\Omega\to\mathbbR^{I}.\]</span> 在 <span class="math inline">\(\mathbb R^{I}\)</span>上取乘积拓扑的 Borel <span class="math inline">\(\sigma\)</span>-代数<span class="math inline">\(\mathcal B(\mathbb R^{I})\)</span>。则有<span class="math display">\[\sigma(X_1,X_2,\dots)=X^{-1}(\mathcal B(\mathbb R^{I})).\]</span> 若 <span class="math inline">\(Y:\Omega\to\mathbb R\)</span>关于 <span class="math inline">\(\sigma(X_1,X_2,\dots)\)</span> 可测，取<span class="math inline">\(T=X\)</span>、<span class="math inline">\(\Omega'=\mathbb R^{I}\)</span>、<span class="math inline">\(\mathcal A'=\mathcal B(\mathbbR^{I})\)</span>，由上节得到 Borel 可测 <span class="math inline">\(f:\mathbb R^{I}\to\mathbb R\)</span> 使 <span class="math display">\[Y=f\bigl(X_1,X_2,\dots\bigr).\]</span> 上述论证对有限 <span class="math inline">\(I\)</span> 与可数<span class="math inline">\(I\)</span> 完全一致。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>令 <span class="math inline">\(X(\omega)=(X_i(\omega))_{i\inI}\)</span>，我们要证 <span class="math display">\[\sigma(X_1,X_2,\ldots)=X^{-1}\bigl(\mathcal B(\mathbb R^{I})\bigr).\tag{$\ast$}\]</span></p><p>设 <span class="math inline">\(\mathcal C\)</span>为所有柱集的族。利用原像保持 <span class="math inline">\(\sigma\)</span>-运算的事实， <span class="math display">\[X^{-1}\bigl(\sigma(\mathcalC)\bigr)=\sigma\bigl(X^{-1}(\mathcal C)\bigr).\]</span> 但对任意柱集<span class="math display">\[C=\prod_{i\in I}B_i\quad(\text{仅有限多 }B_i\neq\mathbb R)\]</span> 都有<span class="math display">\[X^{-1}(C)=\bigcap_{i:\,B_i\neq\mathbb R}X_i^{-1}(B_i)\in \sigma(X_i:i\in I).\]</span> 于是 <span class="math display">\[X^{-1}\bigl(\mathcal B(\mathbb R^{I})\bigr)= X^{-1}\bigl(\sigma(\mathcal C)\bigr)= \sigma\bigl(X^{-1}(\mathcal C)\bigr)\subset \sigma(X_i:i\in I).\]</span> 另一方面 <span class="math display">\[\pi_i:\mathbb R^{I}\to\mathbb R,\qquad \pi_i\bigl((s_j)_{j\inI}\bigr)=s_i,\]</span> 为坐标投影。它是<strong>连续</strong>的。因此对任意 <span class="math inline">\(B\in\mathcal B(\mathbb R)\)</span>，有 <span class="math display">\[\pi_i^{-1}(B)\in\mathcal B(\mathbb R^{I}).\]</span> 另一方面， <span class="math display">\[X_i=\pi_i\circ X \quad\Rightarrow\quadX_i^{-1}(B)=X^{-1}\bigl(\pi_i^{-1}(B)\bigr)\in X^{-1}\bigl(\mathcalB(\mathbb R^{I})\bigr).\]</span> 这对所有 <span class="math inline">\(i\)</span>、所有 <span class="math inline">\(B\in\mathcal B(\mathbb R)\)</span>都成立，于是由生成性得 <span class="math display">\[\sigma(X_i:i\in I)\subset X^{-1}\bigl(\mathcal B(\mathbb R^{I})\bigr).\]</span></p></div><h1 id="riemann-stieltjes-integration">✅ 7.2 Riemann-StieltjesIntegration</h1><p>无要点。</p><h1 id="simple-integeration">✅ 8.1 Simple Integeration</h1><p>无要点</p><h1 id="monotone-convergence-theorem">✅ 8.2 Monotone convergencetheorem</h1><p>本讲给出了<strong>非负可测函数积分</strong>的定义：设 <span class="math inline">\(f\in L^+\)</span> 为非负可测函数，其积分定义为<span class="math display">\[\int f\,\mathrm{d}\mu=\sup\left\{\int\varphi\,\mathrm{d}\mu:\ \varphi\leq f,\ \varphi \text{simple and measuable}\right\}.\]</span></p><p>这个定义的问题在于不容易直接得出积分的可加性： <span class="math display">\[\int (f+g) \,\mathrm{d}\mu=\int f\,\mathrm{d}\mu+\int g\,\mathrm{d}\mu.\]</span></p><p>为此先证明了单调收敛定理：</p><div id="------------------" class="statement sta_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">单调收敛定理</span> <span class="statement-info">(MCT)</span>.</span><span class="statement-spah"></span>若 <span class="math inline">\(\{f_n\}\in L^+\)</span> 且 <span class="math inline">\(f_n\uparrow f\)</span>，则 <span class="math inline">\(\int f_n\,\mathrm{d}\mu\uparrow \intf\,\mathrm{d}\mu\)</span>。</p></div><p><strong>证明概要</strong>：显然 <span class="math inline">\(\lim\limits_{n\to\infty}\intf_n\,\mathrm{d}\mu\)</span> 存在且小于等于 <span class="math inline">\(\intf\,\mathrm{d}\mu\)</span>。为了证明二者相等，只要证明对任何简单函数<span class="math inline">\(\varphi\leq f\)</span> 有 <span class="math display">\[\lim_{n\to\infty} \int f_n\,\mathrm{d}\mu\geq\int \varphi\,\mathrm{d}\mu\]</span> 即可。<strong>不要指望通过分析集合<span class="math inline">\(\{f_n\geq \varphi\}\)</span>来得出结论</strong>，这完全可能对任何 <span class="math inline">\(n\)</span> 都是空集。但是如果可以证明对任何 <span class="math inline">\(0&lt;c&lt;1\)</span> 有 <span class="math display">\[\lim_{n\to\infty} \int f_n\,\mathrm{d}\mu\geq c\int \varphi\,\mathrm{d}\mu\]</span> 成立，那么令 <span class="math inline">\(c\uparrow1\)</span>即得结论（两边都是非负的）。而集合 <span class="math inline">\(E_n=\{f_n\geq c\varphi\}\)</span> 满足 <span class="math inline">\(E_n\uparrow\Omega\)</span>。于是由 <span class="math inline">\(f_n\geq c\varphi\mathbb{1}_{E_n}\)</span>以及积分单调性有 <span class="math display">\[\intf_n\,\mathrm{d}\mu\geqc\int\varphi\mathbb{1}_{E_n}\,\mathrm{d}\mu.\]</span> 由于 <span class="math inline">\(\varphi\)</span> 是简单函数，所以可设 <span class="math inline">\(\varphi = \sum_{k} a_k\mathbb{1}_{A_k}\)</span>并代入上面右边，有 <span class="math display">\[\intf_n\,\mathrm{d}\mu\geq c\int\varphi\mathbb{1}_{E_n}\,\mathrm{d}\mu=c\sum_{k}a_k\mu(A_k\cap E_n).\]</span> 令 <span class="math inline">\(n\to\infty\)</span> 并利用测度连续性 <span class="math inline">\(\mu(A_k\cap E_n)\uparrow\mu(A_k)\)</span> 即得<span class="math display">\[\lim_{n\to\infty} \intf_n\,\mathrm{d}\mu\geq c\sum_ka_k\mu(A_k)= c \int\varphi\,\mathrm{d}\mu.\]</span> 单调收敛定理得证。<span class="math inline">\(\blacksquare\)</span></p><p><strong>MCT告诉我们总是可以用一个只取有限多个值、每个值都有限的简单函数来逼近 <span class="math inline">\(f\)</span> 的积分</strong>。</p><p>非负可测函数 <span class="math inline">\(f\)</span>可以用简单函数序列 <span class="math display">\[\varphi_n =\sum_{k=1}^{2^{2n}}\frac{k-1}{2^n}\mathbb{1}_{\{\frac{k-1}{2^n}\leqf&lt;\frac{k}{2^n}\}} + 2^n\mathbb{1}_{\{f\geq 2^n\}}\]</span>来逼近。在第 <span class="math inline">\(n\)</span>次切割中，我们将切割范围扩大为原来的 2 倍以逼近 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\infty\)</span>的部分，同时将切割的间隔缩小为原来的 1/2 以保证逼近的误差是减小的。</p><h1 id="integrals-and-null-sets">✅ 9.1 Integrals and Null Sets</h1><p>本讲主要是论证积分的基本结论在 <span class="math inline">\(\mathrm{a.e.}\)</span>的情形下也都成立。此外介绍了非负可测函数列积分的 Fatou定理，它是上一讲中单调收敛定理的直接推论：</p><div id="fatou-------" class="statement sta_fatou___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Fatou定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(f_n\in L^+\)</span> 是非负可积函数列，则 <span class="math display">\[\int\liminf f_n\,\mathrm{d}\mu\leq \liminf \intf_n\,\mathrm{d}\mu.\]</span></p></div><p><strong>证明</strong>：设 <span class="math inline">\(g_n=\inf_{m\geqn}f_m\)</span>，则 <span class="math inline">\(g_n\leqf_m\)</span>，所以 <span class="math display">\[\intg_n\,\mathrm{d}\mu\leq\int f_m\,\mathrm{d}\mu,\quad n\leq m\]</span>从而 <span class="math inline">\(\int g_n\,\mathrm{d}\mu\leq\liminf\intf_m\,\mathrm{d}\mu\)</span>。 另一方面 <span class="math inline">\(g_n\uparrow\liminf f_n\)</span>，所以利用 MCT 有<span class="math display">\[\int\liminff_n\,\mathrm{d}\mu=\int\lim_{n\to\infty}g_n\,\mathrm{d}\mu=\lim_{n\to\infty}\intg_n\,\mathrm{d}\mu\leq\liminf\int f_m\,\mathrm{d}\mu.\]</span> <span class="math inline">\(\blacksquare\)</span></p><p>另一个重要结论是 Borel-Cantelli 引理：</p><div id="borel-cantelli" class="statement sta_borel_cantelli plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Borel-Cantelli</span> <span class="statement-info">(Ⅰ)</span>.</span><span class="statement-spah"></span>如果 <span class="math inline">\(\sum_{n=0}^\infty\mu(A_n)&lt;\infty\)</span>，则<span class="math inline">\(\mu\{A_n,\ \mathrm{i.o.}\}=0\)</span>。</p></div><p>这个用积分很容易看出来： <span class="math display">\[\sum_{n=0}^\infty\mu(A_n)=\int\sum_{n=0}^\infty\mathbb{1}_{A_n}\,\mathrm{d}\mu.\]</span>左边如果有限，那么右边的函数必须几乎处处有限，所以 <span class="math inline">\(\{A_n,\ \mathrm{i.o.}\}\)</span> 是零测集。</p><h1 id="l1-and-the-dct">✅ 9.2 <span class="math inline">\(L^1\)</span>and the DCT</h1><p>本讲引入了一般可积函数的定义，并证明了控制收敛定理。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义18.1</span>.</span><span class="statement-spah"> </span>称 <span class="math inline">\(f\in L^1(\Omega,\mathcal{F},\mathbb{P})\)</span>为可积函数，如果 <span class="math inline">\(f^+,f^-\)</span>都是可积的：<span class="math inline">\(\intf^{\pm}\,\mathrm{d}\mu&lt;\infty\)</span>。此时我们定义 <span class="math inline">\(\int f=\int f^+-\intf^-\)</span>。或者等价地，<span class="math inline">\(f\)</span>可积当且仅当 <span class="math inline">\(\int|f|\,\mathrm{d}\mu&lt;\infty\)</span>。</p></div><p>对可积函数，积分是<strong>线性的</strong>、<strong>保持单调性的</strong>。</p><p>如果我们将几乎处处相等的函数看作是同一个函数的话，<span class="math inline">\(\|\cdot\|_{L^1}\)</span>是可积函数空间上的度量。</p><div id="-------------------1" class="statement sta_______-1 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">控制收敛定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(f_n,g\)</span> 都是可积函数并且 <span class="math inline">\(|f_n|\leqg\)</span>，<span class="math inline">\(\lim\limits_{n\to\infty}f_n=f\)</span>。 则 <span class="math inline">\(f\)</span> 也是可积函数并且 <span class="math inline">\(\lim\limits_{n\to\infty}\int f_n=\intf\)</span>。</p></div><p><strong>证明概要</strong>：显然 <span class="math inline">\(|f|\leqg\)</span>，所以 <span class="math inline">\(f\)</span>可积，从而由线性性质 <span class="math inline">\(g\pm f\)</span>都是可积的。对可积函数序列 <span class="math inline">\(g\pm f_n\)</span>使用 Fatou 引理，有 <span class="math display">\[\int (g\pmf)\,\mathrm{d}\mu=\int\varliminf_{n\to\infty} (g\pmf_n)\,\mathrm{d}\mu\leq \varliminf_{n\to\infty}\int (g\pmf_n)\,\mathrm{d}\mu= \int g\,\mathrm{d}\mu\pm\varliminf_{n\to\infty}\intf_n\,\mathrm{d}\mu.\]</span> 比较两边有 <span class="math display">\[\int (g\pm f)\,\mathrm{d}\mu\leq \intg\,\mathrm{d}\mu\pm \varliminf_{n\to\infty}\intf_n\,\mathrm{d}\mu.\]</span> 消去 <span class="math inline">\(g\)</span>的积分，并注意对任何实数列 <span class="math inline">\(\{a_n\}\)</span>有 <span class="math inline">\(\varliminf\limits_{n\to\infty}(-a_n)=-\varlimsup\limits_{n\to\infty}a_n\)</span>，从而 <span class="math display">\[\varlimsup\intf_n\,\mathrm{d}\mu\leq \int f\,\mathrm{d}\mu\leq \varliminf\intf_n\,\mathrm{d}\mu.\]</span> 即得结论。</p><h1 id="integrals-and-derivatives">✅ 10.1 Integrals andDerivatives</h1><p>这一讲介绍了在何种条件下，可以在积分号下对参数求导。</p><p>我把视频中的结论作了一些加强，实际上是等价的：</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理19.1</span>.</span></p><ol type="1"><li><span class="math inline">\(f(t, \cdot)\)</span> 对每个 <span class="math inline">\(t\)</span> 都是可测的，而且是 <span class="math inline">\(L^1\)</span> 可积的；</li><li><span class="math inline">\(\frac{\partial f}{\partialt}(t,\omega)\)</span> 对几乎处处的 <span class="math inline">\(\omega\)</span> 有定义；</li><li><span class="math inline">\(|\frac{\partial f}{\partialt}(t,\omega)|\le g(\omega)\)</span> 对某个 <span class="math inline">\(g\in L^1\)</span> 几乎处处成立。</li></ol><p>则 <span class="math display">\[\frac{\mathrm d}{\mathrm d t}\intf(t,\omega)\,\mu(\mathrm d\omega)=\int \frac{\partial f}{\partialt}(t,\omega)\,\mu(\mathrm d\omega).\]</span></p></div><p>注意：对所有的 <span class="math inline">\(t\)</span>，使得 2, 3成立的那些 <span class="math inline">\(\omega\)</span>组成的集合必须是固定的，不能随着 <span class="math inline">\(t\)</span>变化而变化。反例：<span class="math inline">\((0,1)\)</span> 上的Lebesgue 测度，<span class="math inline">\(f(t,\omega)=\mathbb{1}_{\{\omega\let\}}\)</span>。</p><h1 id="the-radon-nikodym-theorem">✅ 11.1 The Radon-NikodymTheorem</h1><p>本讲介绍了 Radon-Nikodym 定理，不过没有给出证明。</p><p><strong>Motivation</strong>: 设 <span class="math inline">\(\mu,\nu\)</span> 是两个测度，是否存在非负可测函数<span class="math inline">\(\rho\)</span> 使得 <span class="math inline">\(\nu(A)=\int_A\rho\,\mathrm{d}\mu\)</span>对任何可测集 <span class="math inline">\(A\)</span> 成立？</p><p><strong>必要条件</strong>：<span class="math inline">\(\mu(A)=0\Rightarrow\nu(A)=0\)</span>。这时我们称<span class="math inline">\(\nu\)</span> 关于 <span class="math inline">\(\mu\)</span> <strong>绝对连续</strong>，记作 <span class="math inline">\(\nu\ll\mu\)</span>。</p><p>此条件同样也是充分的：若 <span class="math inline">\(\nu\)</span>关于 <span class="math inline">\(\mu\)</span> 绝对连续，则存在 <span class="math inline">\(\rho\)</span> 使得 <span class="math inline">\(\rho=\dfrac{\mathrm{d}\nu}{\mathrm{d}\mu}\)</span>。</p><p><strong>奇异连续测度的例子</strong>：Cantor 函数 (devilstaircase)。<a href="https://www.youtube.com/watch?v=dQXVn7pFsVI">YouTube科普</a>。此函数没有点质量，也没有密度函数，但是确实给出一个全质量为 1的概率测度。</p><ul><li>此函数是连续递增的，所以是一个分布函数。</li><li>此函数是连续的，所以没有点质量，即单个点的测度是 0。</li><li>此函数是奇异的，因为它在除去 Cantor集对应的点之外几乎处处是常数。</li></ul><h1 id="probability-laws-revisited">✅ 11.2 Probability LawsRevisited</h1><div id="---------------------------" class="statement sta__________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">积分的变量替换定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(X:\(\Omega,\mathcal{F},\mu)\to(\mathcal{S},\mathcal{B})\)</span>是一个可测映射，<span class="math inline">\((\mathcal{S},\mathcal{B})\)</span> 上的测度 <span class="math inline">\(\nu\)</span> 由 <span class="math inline">\(\nu(E)= \mu(X^{-1}(E))\)</span> 给出，<span class="math inline">\(g:\(\mathcal{S},\mathcal{B},\nu)\to\mathbb{R}\)</span> 是一个可积函数，则<span class="math display">\[\int_{\Omega}g\circX\,\mathrm{d}\mu=\int_{\mathcal{S}}g\,\mathrm{d}\nu.\]</span></p></div><p>示意图：</p><p><span class="math display">\[\underbrace{\Omega\xrightarrow{\ X\}\overbrace{S\xrightarrow{\ g\}\mathbb{R}}^{\int_{\mathcal{S}}g\,\mathrm{d}\nu}}_{\int_{g\circX\,\mathrm{d}\mu}}.\]</span></p><p><strong>证明概要</strong>：首先考察 <span class="math inline">\(g=\mathbb{1}_B,\,B\in\mathcal{B}\)</span>是指标函数的情形。 <span class="math display">\[\int_{\mathcal{S}}g\,\mathrm{d}\nu= \nu(B) =\mu(X^{-1}(B))=\int_{\Omega}\mathbb{1}_{X^{-1}(B)}\,\mathrm{d}\mu.\]</span>由于 <span class="math inline">\(\omega\in X^{-1}(B)\LeftrightarrowX(\omega)\in B\)</span>，所以 <span class="math inline">\(\mathbb{1}_{X^{-1}(B)} = \mathbb{1}_{B}\circX\)</span>，所以上式右边的积分等于 <span class="math display">\[\int_{\Omega}\mathbb{1}_{B}\circX\,\mathrm{d}\nu.\]</span>此时结论成立。根据积分的线性性质结论对简单函数也成立，从而进一步取极限可得对任何可积函数<span class="math inline">\(g\)</span> 都成立。</p><h1 id="l2">✅ 12.1 <span class="math inline">\(L^2\)</span></h1><p>无要点</p><h1 id="the-weak-law-of-large-numbers-wlln">✅ 12.2 The Weak Law ofLarge Numbers (WLLN)</h1><p>这一讲证明了弱大数定律，即当 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(L^2\)</span> 可积的 i.i.d 序列时有 <span class="math display">\[\mathbb{P}\left(|\frac{S_n}{n} - a|\geq\epsilon\right) = O(\frac{1}{n}).\]</span></p><h1 id="convergence-in-measure">✅ 13.1 Convergence in measure</h1><p>本讲介绍了可测函数的依测度收敛概念，及其与逐点收敛之间的联系。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义24.1</span>.</span><span class="statement-spah"> </span>称 <span class="math inline">\(f_n\to_{\mu} f\)</span> 为依测度收敛，如果对任意<span class="math inline">\(\epsilon &gt;0\)</span> 有 <span class="math display">\[\lim_{n\to\infty}\mu\{|f_n-f|\geq0\}=0.\]</span></p></div><p><strong>依测度收敛但不处处收敛的例子</strong>：将区间 <span class="math inline">\([0, 1]\)</span> 等分为 <span class="math inline">\(2^n\)</span>份，将它们的指标函数排成一排，再对所有 <span class="math inline">\(n\)</span> 将这些片段排列起来得到序列 <span class="math inline">\(f_n\)</span>，则 <span class="math inline">\(f_n\)</span> 依测度收敛到 0 但不逐点收敛。</p><p><strong>接下来是一个将测度和逐点收敛联系起来的重要技巧</strong>：根据几乎处处收敛的定义，<span class="math inline">\(f_n\to f,\mathrm{a.e.}\)</span> 收敛即要求对任何<span class="math inline">\(\epsilon&gt;0\)</span> 有 <span class="math display">\[\mu\{|f_n-f|\geq\epsilon,\ \mathrm{i.o.}\} =0.\]</span>这样就可以把逐点收敛和测度联系起来。有时候我们还可以使用更强的条件：<span class="math display">\[\mu\{|f_n-f|\geq 2^{-n},\ \mathrm{i.o.}\} =0.\]</span> 这是因为对任何 <span class="math inline">\(\epsilon\)</span>，<span class="math inline">\(n\)</span> 足够大时 <span class="math inline">\(2^{-n}&lt;\epsilon\)</span>, 从而 <span class="math inline">\(\{|f_n-f|\geq\epsilon\}\subseteq\{|f_n-f|\geq2^{-n}\}\)</span>，前者发生无穷多次自然意味着后者也发生无穷多次。这样就可以和Borel-Cantelli 引理结合起来使用，只要 <span class="math display">\[\sum_{n}\mu\{|f_n - f|\geq 2^{-n}\} &lt;\infty,\]</span> 就可以保证 <span class="math inline">\(\{f_n\}\)</span>是几乎处处收敛的。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理24.2</span>.</span><span class="statement-spah"></span>逐点收敛可以推出依测度收敛。</p></div><p><strong>简要证明</strong>：对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，记 <span class="math inline">\(A_n=\{|f_n-f|\geq\epsilon\}\)</span>，则 <span class="math display">\[\mu\{A_n,\ \mathrm{i.o.}\} =\lim_{n\to\infty}\mu(\bigcup_{k\geq n}A_k)\geq\lim_{n\to\infty}\mu(A_n).\]</span></p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理24.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{f_n\}\)</span> 为依测度收敛的 Cauchy 序列：<span class="math display">\[\lim_{n,m\to\infty}\mu\{|f_n-f_m|\geq\epsilon\} =0.\]</span> 则 <span class="math inline">\(f_n\)</span>必有逐点收敛的子序列 <span class="math inline">\(f_{n_k}\to f\\mathrm{a.e.}\)</span>，并且 <span class="math inline">\(f_n\)</span>依测度收敛到 <span class="math inline">\(f\)</span>。</p></div><p><strong>必有逐点收敛的子序列</strong>：利用上面介绍的技巧，归结为抽取子序列<span class="math inline">\(\{f_{n_k}\}\)</span> 满足 <span class="math display">\[\mu\{|f_{n_{k+1}} - f_{n_k}|\geq2^{-k},\\mathrm{i.o.}\} = 0.\]</span> 利用 Borel-Cantelli 引理这只要让 <span class="math inline">\(\sum_{k=1}^\infty\mu\{|f_{n_{k+1}} - f_{n_k}|\geq2^{-k}\}&lt;\infty\)</span> 即可。为此又只要让 <span class="math inline">\(\mu\{|f_{n_{k+1}} - f_{n_k}|\geq 2^{-k}\}\leq2^{-k}\)</span> 即可。根据 Cauchy 条件这是可以做到的。</p><p><strong>子序列的极限也是原序列的依测度极限</strong>：对任何 <span class="math inline">\(n\)</span>，取 <span class="math inline">\(n_{k}&gt;n\)</span> 则有 <span class="math display">\[\{|f_n-f|\geq\epsilon\}\subseteq\{|f_n-f_{n_k}|\geq\epsilon/2\}\cup\{|f_{n_k}-f|\geq\epsilon/2\}.\]</span> 显然 <span class="math inline">\(n\)</span> 足够大时右边两个集合测度都趋于 0。</p><h1 id="lp-is-complete">✅ 13.2 <span class="math inline">\(L^p\)</span>is Complete</h1><p>首先我们来证明 <span class="math inline">\(L^p\)</span>收敛可以推出依测度收敛。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理25.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(L^p\)</span> 度量是完备的，任何 Cauchy序列必有极限。</p></div><p><strong>证明概要</strong>：<span class="math inline">\(L^p\)</span>Cauchy 列也都是依测度 Cauchy 列，从而有几乎处处收敛的子序列 <span class="math inline">\(f_{n_k}\to f\)</span>。对固定的 <span class="math inline">\(k\)</span>，当 <span class="math inline">\(j&gt;k\)</span> 时有 <span class="math display">\[\begin{align*}\int\|f_{n_k}-f\|^p\,\mathrm{d}\mu&amp;=\int\lim_{j\to\infty}\|f_{n_k}-f_{n_j}\|^p\,\mathrm{d}\mu\leq\liminf_{j\to\infty}\int\|f_{n_k}-f_{n_j}\|^p\,\mathrm{d}\mu\\&amp;\leq\limsup_{j\to\infty}\int\|f_{n_k}-f_{n_j}\|^p\,\mathrm{d}\mu.\end{align*}\]</span>两边令 <span class="math inline">\(k\to\infty\)</span> 并利用 Cauchy条件即得子序列 <span class="math inline">\(f_{n_k}\xrightarrow{L^p}f\)</span>。再利用 Cauchy条件可得原序列 <span class="math inline">\(f_n\xrightarrow{L^p}f\)</span>。</p><div id="----------------------------1" class="statement sta__________-1 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">依测度控制收敛定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(f_n\)</span> 依测度收敛到 <span class="math inline">\(f\)</span>，且 <span class="math inline">\(|f_n|\leq f,\, f\in L^1\)</span>。则 <span class="math inline">\(f_n\xrightarrow{L^1} f\)</span>。</p></div><p><strong>证明概要</strong>：假设 <span class="math inline">\(f_n\)</span> 不 <span class="math inline">\(L^1\)</span> 收敛到 <span class="math inline">\(f\)</span>，则对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，存在子序列 <span class="math inline">\(f_{n_k}\)</span> 满足：</p><ul><li><span class="math inline">\(\|f_{n_k} -f\|_{L^1}\geq\epsilon\)</span>。</li><li><span class="math inline">\(f_{n_k}\)</span> 几乎处处收敛到 <span class="math inline">\(f\)</span>。</li></ul><p>这与控制收敛定理矛盾。</p><h1 id="dynkins-multiplicative-systems-theorem">✅ 14.1 Dynkin’sMultiplicative Systems Theorem</h1><p>本讲介绍了 Dynkin <span class="math inline">\(\pi-\lambda\)</span>定理的函数形式的版本。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义26.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\((\Omega,\mathcal{F})\)</span>是一个可测空间，<span class="math inline">\(f\)</span>是可测函数。如果存在 <span class="math inline">\(M&gt;0\)</span> 使得<span class="math display">\[|f|\leq M,\quad \mathrm{a.e.}\]</span>成立，就称 <span class="math inline">\(f\)</span> 是一个有界可测函数。记<span class="math inline">\(\mathbb{B}(\Omega,\mathcal{F})\)</span>为全体有界函数构成的向量空间。若 <span class="math inline">\(\{f_n\}\in\mathbb{B}(M,\mathcal{F})\)</span> 满足<span class="math display">\[|f_n|\leq M,\ \mathrm{a.e.}\quad \foralln\]</span> 并且 <span class="math display">\[\lim_{n\to\infty} f_n =f,\quad \mathrm{a.e.}\]</span> 就称 <span class="math inline">\(\{f_n\}\)</span> <strong>一致有界收敛到 <span class="math inline">\(f\)</span></strong>。</p></div><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理26.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathbb{H}\subset\mathbb{B}(\Omega)\)</span>是一个向量空间，包含常函数 <span class="math inline">\(\mathbb{1}_\Omega\)</span>，并且在有界收敛下封闭。又设<span class="math inline">\(\mathbb{M}\subset\mathbb{H}\)</span>是一个乘法系：<span class="math inline">\(f,g\in\mathbb{M}\Rightarrowf\cdot g\in\mathbb{M}\)</span>。则 <span class="math inline">\(\mathbb{H}\)</span> 包含所有关于 <span class="math inline">\(\sigma(\mathbb{M})\)</span>- 可测的有界可测函数：<span class="math display">\[\mathbb{B}(\Omega,\sigma(\mathbb{M}))\subset\mathbb{H}.\]</span></p></div><p><strong>证明</strong>：设 <span class="math inline">\(\mathbb{H}=\mathbb{H}(\mathbb{M})\)</span> 是包含<span class="math inline">\(\mathbb{M}\)</span> 和 1的向量空间。且在有界收敛下封闭。</p><p><strong>Step 1 <span class="math inline">\(\mathbb{H}\)</span>是一个代数</strong></p><p>固定 <span class="math inline">\(f\in\mathbb{H}\)</span>，记 <span class="math inline">\(\mathbb{H}^f =\{g\in\mathbb{H}\mid f\cdotg\in\mathbb{H}\}\)</span>。</p><ul><li><span class="math inline">\(\mathbb{H}^f\)</span> 是 <span class="math inline">\(\mathbb{H}\)</span> 的子空间</li><li><span class="math inline">\(\mathbb{H}^f\)</span> 包含常数 1</li><li><span class="math inline">\(\mathbb{H}^f\)</span>在有界收敛下封闭</li></ul><p>特别地，如果 <span class="math inline">\(f\in\mathbb{M}\)</span>，由定义 <span class="math inline">\(\mathbb{M}\subset\mathbb{H}^f\)</span>。所以 <span class="math display">\[\mathbb{H}=\mathbb{H}(\mathbb{M})\subset\mathbb{H}^f\subset \mathbb{H}.\]</span> 即 <span class="math inline">\(\mathbb{H}=\mathbb{H}^f\)</span>。但根据 <span class="math inline">\(f\)</span> 的任意性，这正说明对任何 <span class="math inline">\(f,g\in\mathbb{H}\)</span> 都有 <span class="math inline">\(f,g\in\mathbb{H}\)</span>。从而 <span class="math inline">\(\mathbb{H}\)</span> 是一个代数。</p><p><strong>Step 2 <span class="math inline">\(\mathcal{F}=\{A\subset\Omega\mid \mathbb{1}_A\in\mathbb{H}\}\)</span> 是 <span class="math inline">\(\sigma\)</span>-域</strong></p><p>这一步很容易</p><p><strong>Step 3 <span class="math inline">\(\mathbb{B}(\Omega,\mathcal{F})\subset\mathbb{H}\)</span></strong></p><p><span class="math inline">\(\mathcal{F}\)</span> 中的示性函数都在<span class="math inline">\(\mathbb{H}\)</span> 中，从而简单函数也在<span class="math inline">\(\mathcal{F}\)</span>中。又因为有界收敛封闭，所以有界函数的 <span class="math inline">\(f^+,f^-\)</span> 也在 <span class="math inline">\(\mathcal{F}\)</span> 中，从而 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\mathcal{F}\)</span> 中。</p><p><strong>Step 4 <span class="math inline">\(\sigma(\mathbb{M})\subset\mathcal{F}\)</span></strong></p><p>根据 <span class="math display">\[\sigma(\mathbb{M}) = \sigma(\cup\{f^{-1}\mathcal{B}(\mathbb{R}), f\in\mathbb{M}\})=\sigma(\\bigcup\{f^{-1}(a,+\infty)\mid a\in\mathbb{R}, f\in\mathbb{M}\\}).\]</span> 所以我们只要证明所有形如 <span class="math inline">\(\mathbb{1}_{\{f&gt;a\}},\forallf\in\mathbb{M},a\in\mathbb{R}\)</span> 的函数在 <span class="math inline">\(\mathbb{H}\)</span> 中即可。 设 <span class="math inline">\(|f|\leq M\)</span>。首先我们构造连续函数列 <span class="math inline">\(\psi_n\uparrow\mathbb{1}_{(a,+\infty)}\)</span>，这总是可以的：</p><p><span class="math display">\[\psi_n(t)=\begin{cases}0,&amp; t\le a\\n(t-a), &amp; a &lt; t &lt; a+1/n\\1, &amp; t\geq a+1/n\end{cases}\]</span> 故 <span class="math display">\[\psi_n(f)\uparrow\mathbb{1}_{\{f &gt; a\}}.\]</span></p><p>由于 <span class="math inline">\(\psi_n\)</span> 在紧集 <span class="math inline">\([-M,M]\)</span> 上连续，由 Weierstrass逼近定理，存在多项式 <span class="math inline">\(p_{n,k}\)</span> 使得<span class="math display">\[\sup_{|t|\leM}|p_{n,k}(t)-\psi_n(t)|\leq\frac{1}{k}.\]</span> 因为 <span class="math inline">\(0\leq\psi_n\leq 1\)</span>，就有 <span class="math display">\[\sup_{|t|\le M}|p_{n,k}(t)|\leq \sup_{|t|\leM}|\psi_n(t)|+\frac{1}{k} \le 2.\]</span> 于是对所有 <span class="math inline">\(n,k\)</span> 有 <span class="math display">\[\|p_{n,k}(f)\|_\infty \leq 2.\]</span></p><p>因为 <span class="math inline">\(\mathbb{H}\)</span> 是代数且 <span class="math inline">\(f\in\mathbb{M}\)</span>，故 <span class="math inline">\(p_{n,k}(f)\in\mathbb{H}\)</span>。 又根据 <span class="math inline">\(p_{n,k}(f)\to \psi_n(f)\)</span> 是有界收敛，所以<span class="math inline">\(\psi_n(f)\in\mathbb{H}\)</span>。再根据<span class="math inline">\(\psi_n(f)\uparrow\mathbb{1}_{\{f&gt;a\}}\)</span> 也是有界收敛，得到结论。<span class="math inline">\(\blacksquare\)</span></p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论26.3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\sigma(C_c(\mathbb{R})) =\sigma(\mathbb{\mathbb{R}})\)</span>。</p></div><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论26.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mu,\nu\)</span> 是 <span class="math inline">\(\mathbb{R}\)</span> 上的 Borel概率测度，并且对任何 <span class="math inline">\(f\inC_c(\mathbb{R})\)</span> 都有 <span class="math display">\[\intf\,\mathrm{d}\mu= \int f\,\mathrm{d}\nu\]</span> 成立，则 <span class="math inline">\(\mu=\nu\)</span>。</p></div><p>设 <span class="math inline">\(\mathbb{H}\)</span>是使得上面积分相等的全体有界函数成立的集合，则 <span class="math inline">\(\mathbb{H}\)</span> 包含常数1，在有界收敛下封闭，还包含乘法系 <span class="math inline">\(C_c(\mathbb{R})\)</span>，从而 <span class="math inline">\(\mathbb{H}\)</span> 包含所有的 <span class="math inline">\(\mathbb{B}(\mathbb{R},\sigma(C_c(\mathbb{R})))=\mathbb{B}(\mathbb{R},\mathcal{B}(\mathbb{R}))\)</span>。特别地，对任何 Borel 可测集 <span class="math inline">\(E\)</span> 有 <span class="math inline">\(\mathbb{1}_E\in\mathcal{B}(\mathbb{R})\subset\mathbb{H}\)</span>，从而<span class="math display">\[\mu(E) = \int \mathbb{1}_E\,\mathrm{d}\mu=\int \mathbb{1}_E\,\mathrm{d}\nu= \nu(E).\]</span></p><h1 id="product-measure">✅ 14.2 Product Measure</h1><p>本讲介绍了乘积测度的构造。<strong>记住乘积测度的构造是用到重积分的</strong>。</p><p><strong>可测空间的乘积</strong>：设 <span class="math inline">\((\Omega_1,\mathcal{F_1}),\,(\Omega_2,\mathcal{F_2})\)</span>是两个可测空间，其乘积空间定义为 <span class="math inline">\((\Omega_1\times\Omega_2,\,\sigma(\mathcal{F}_1\times\mathcal{F}_2))\)</span>。其中<span class="math inline">\(\mathcal{F}_1\otimes\mathcal{F}_2=\sigma(\mathcal{F}_1\times\mathcal{F}_2)\)</span>是由所有形如 <span class="math inline">\(\{A_1\times A_2,A_i\in\mathcal{F}_i\}\)</span> 的集合生成的 <span class="math inline">\(\sigma\)</span>- 域。</p><p><span class="math inline">\(\mathcal{F}_1\otimes\mathcal{F}_2\)</span>还有一种等价的刻画：它是使得投影映射 <span class="math inline">\(\pi_i(\omega_1,\omega_2)=\omega_i\)</span>均可测的最小 <span class="math inline">\(\sigma\)</span>- 域。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理27.1</span>.</span><span class="statement-spah"> </span>随机向量 <span class="math inline">\(f:(\Omega,\mathcal{F})\to(\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>是可测的，当且仅当其每个分量 <span class="math inline">\(f_i\)</span>是可测的。</p></div><p><strong>证明</strong>： x <span class="math inline">\(\Rightarrow\)</span>: 每个 <span class="math inline">\(f_i=\pi_i\circ f\)</span>作为两个可测映射的复合当然是可测的。</p><p><span class="math inline">\(\Leftarrow\)</span>: 本质是证明如果每个<span class="math inline">\(X_i\)</span> 都是随机变量，则 <span class="math inline">\(X=(X_1,\ldots,X_n)\)</span> 是随机向量。对任何形如<span class="math inline">\(E=E_i\times_{j\nei}\mathcal{B}_i(\mathbb{R})\)</span> 的集合，<span class="math inline">\(X^{-1}(E) =\{\omega\in\Omega: X_i(\omega)\inE_i\}\)</span> 是可测集，而这样的 <span class="math inline">\(E\)</span>生成了 <span class="math inline">\(\mathcal{B}(\mathbb{R}^d)\)</span>，所以 <span class="math inline">\(X^{-1}(E)\)</span> 对任何 <span class="math inline">\(E\subset\mathcal{B}(\mathbb{R}^d)\)</span>都可测。结论得证。</p><p>如果每个 <span class="math inline">\((\Omega_i,\mathcal{F}_i)\)</span>还是测度空间，其上的测度为 <span class="math inline">\(\mu_i\)</span>，则我们可以在 <span class="math inline">\((\Omega_1\times\Omega_2,\mathcal{F}_1\otimes\mathcal{F}_2)\)</span>上定义测度 <span class="math inline">\(\mu_1\otimes\mu_2\)</span> 使得<span class="math inline">\((\mu_1\otimes\mu_2)(E_1\timesE_2)=\mu_1(E_1)\mu_2(E_2)\)</span> 对任何 <span class="math inline">\(E_i\in\mathcal{F}_i,\, i=1,2\)</span> 成立。</p><p>实际上我们可以让这个乘积测度满足</p><p><span class="math display">\[\int_{\Omega_1\times\Omega_2}f_1\otimesf_2\mathrm{d}(\mu_1\otimes\mu_2) =\int_{\Omega_1}f_1\mathrm{d}\mu_1\cdot\int_{\Omega_2}f_2\mathrm{d}\mu_2.\]</span></p><p>首先我们假定 <span class="math inline">\(\mu_1,\mu_2\)</span>都是有限测度。构建完毕以后再扩展到 <span class="math inline">\(\sigma\)</span>- 有限的测度上去。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理27.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(f\)</span> 是一个非负的，关于 <span class="math inline">\((\Omega_1\times\Omega_2,\mathcal{F}_1\otimes\mathcal{F}_2)\)</span>可测的函数，则</p><ol type="1"><li><span class="math inline">\(f(\cdot,\omega_2)\)</span> 对任何 <span class="math inline">\(\omega_2\)</span> 都是 <span class="math inline">\(\mathcal{F}_1\)</span> 可测的。</li><li><span class="math inline">\(f(\omega_1,\cdot)\)</span> 对任何 <span class="math inline">\(\omega_1\)</span> 都是 <span class="math inline">\(\mathcal{F}_2\)</span> 可测的。</li><li><span class="math inline">\(\int_{\Omega_2}f(\cdot,\omega_2)\mu_2(\mathrm{d}\omega_2)\)</span>是 <span class="math inline">\(\mathcal{F}_1\)</span>可测的。注意这个积分值可能是无穷。</li><li><span class="math inline">\(\int_{\Omega_1}f(\omega_1,\cdot)\mu_1(\mathrm{d}\omega_1)\)</span>是 <span class="math inline">\(\mathcal{F}_2\)</span> 可测的。</li><li><span class="math display">\[\int_{\Omega_1}\left(\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2(\mathrm{d}\omega_2)\right)\mu_1(\mathrm{d}\omega_1)=\int_{\Omega_2}\left(\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1(\mathrm{d}\omega_1)\right)\mu_2(\mathrm{d}\omega_2).\]</span></li></ol></div><p><strong>证明</strong>：我们先来验证结论对形如 <span class="math inline">\(f_1\otimes f_2\)</span> 的函数成立。</p><ol type="1"><li><span class="math inline">\(f(\cdot,\omega_2) =f_1(\cdot)f_2(\omega_2)\)</span> 当然是 <span class="math inline">\(\mathcal{F}_1\)</span> 可测函数。</li><li>同 1。</li><li><span class="math inline">\(\int_{\Omega_2}f(\cdot,\omega_2)\mu_2(\mathrm{d}\omega_2)=f_1(\cdot)\int_{\Omega_2}f_2(\omega_2)\mu_2(\mathrm{d}\omega_2)\)</span>。</li><li>同 3.</li><li>两边都等于 <span class="math inline">\(\int_{\Omega_1}f_1(\omega_1)\mu_1(\mathrm{d}\omega_1)\cdot\int_{\Omega_2}f_2(\omega_2)\mu_2(\mathrm{d}\omega_2)\)</span>。</li></ol><p>令 <span class="math inline">\(\mathbb{H}\)</span>是所有满足定理中条件的函数组成的集合，<span class="math inline">\(\mathbb{M}\)</span> 是所有形如 <span class="math inline">\(\f_1\otimes f_2\)</span>的非负可测函数组成的集合。则 <span class="math inline">\(\mathbb{M}\)</span> 是乘法系。又因为 <span class="math inline">\(\mathbb{M}\)</span> 包含所有形如 <span class="math inline">\(\mathbb{1}_{B_1}\otimes\mathbb{1}_{B_2}\)</span>的函数，所以 <span class="math inline">\(\sigma(\mathbb{M})=\mathcal{F}_1\otimes\mathcal{F}_2\)</span>。</p><p>又 <span class="math inline">\(\mathbb{H}\)</span> 是向量空间，包含<span class="math inline">\(\{1\}\cup\mathbb{M}\)</span>，并且在有界收敛下封闭。（对5 需要用两次控制收敛定理或者非负函数的单调收敛定理）,所以根据 Dynkin乘法系引理，<span class="math inline">\(\mathbb{H}\)</span> 包含所有<span class="math inline">\(\mathcal{F}_1\otimes\mathcal{F}_2\)</span>可测的有界函数（或者非负函数）。<span class="math inline">\(\blacksquare\)</span></p><p>由此我们可以定义乘积空间中的测度为</p><p><span class="math display">\[\mu(E)=\int_{\Omega_1}\left(\int_{\Omega_2}\mathbb{1}_{E}\mu_2(\mathrm{d}\omega_2)\right)\mu_1(\mathrm{d}\omega_1)=\int_{\Omega_2}\left(\int_{\Omega_1}\mathbb{1}_{E}\mu_1(\mathrm{d}\omega_1)\right)\mu_2(\mathrm{d}\omega_2).\]</span>不难验证这样定义的积分是有限可加的(积分的线性性质)，可以取单调上升的极限，所以是可数可加的，并且当 <span class="math inline">\(E\)</span> 形如 <span class="math inline">\(E_1\times E_2\)</span> 时有 <span class="math inline">\(\mu(E)=\mu_1(E_1)\mu_2(E_2)\)</span>，从而确实给出符合要求的乘积测度。</p><h1 id="tonelli-fubini">✅ 14.3 Tonelli-Fubini</h1><div id="tonelli-------" class="statement sta_tonelli___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Tonelli定理</span>.</span><span class="statement-spah"> </span> 如果 <span class="math inline">\(f\in(\Omega_1\times\Omega_2,\mathcal{F}_1\otimes\mathcal{F}_2)\)</span>是<strong>非负可测</strong>的，则 <span class="math display">\[\int_{\Omega_1\times\Omega_2}f\,\mathrm{d}(\mu_1\times\mu_2)=\int_{\Omega_1}\left(\int_{\Omega_2}f\,\mathrm{d}\mu_2\right)\,\mathrm{d}\mu_1=\int_{\Omega_2}\left(\int_{\Omega_1}f\,\mathrm{d}\mu_1\right)\,\mathrm{d}\mu_2.\]</span></p></div><p>上一讲里面已经证明了右边两者相等。要把左边也连上，只需补一句标准话：用非负简单函数递增逼近<span class="math inline">\(f\)</span>，对简单函数这三者相等（按照乘积测度的定义，它就是集合示性函数的分部积分），再用单调收敛定理把等式传到极限。</p><p>令一般可测 <span class="math inline">\(f\)</span> 可积：<span class="math inline">\(\int|f|\,\mathrm{d}(\mu_1\times\mu_2)&lt;\infty\)</span>，写 <span class="math inline">\(f=f^+-f^-\)</span>。</p><ol type="1"><li>由 Tonelli 可得 <span class="math display">\[\int |f|\, \mathrm d(\mu_1\times\mu_2)=\int\left(\int |f(\omega_1,\omega_2)|\,\mathrm d\mu_2\right)\,\mathrmd\mu_1=\int\left(\int |f(\omega_1,\omega_2)|\,\mathrm d\mu_1\right)\,\mathrmd\mu_2&lt;\infty.\]</span> 因而对 <span class="math inline">\(\mu_1\)</span>-几乎处处的<span class="math inline">\(\omega_1\)</span>，截面 <span class="math inline">\(f(\omega_1,\cdot)\inL^1(\mu_2)\)</span>；同理交换坐标亦然。</li><li>再对 <span class="math inline">\(f^\pm\)</span>分别应用上一节的等式并相减，得到 <span class="math display">\[\int_{\Omega_1\times\Omega_2} f\, \mathrm d(\mu_1\times\mu_2)=\int_{\Omega_1}\left(\int_{\Omega_2} f\,\mathrm d\mu_2\right)d\mu_1=\int_{\Omega_2}\left(\int_{\Omega_1} f\,\mathrm d\mu_1\right)d\mu_2.\]</span> 且两个迭代积分都有限。这就是 <strong>Fubini定理</strong>。</li></ol><h1 id="independence">✅ 15.1 Independence</h1><p>本讲介绍了事件和 <span class="math inline">\(\sigma\)</span>-域之间的独立性概念。</p><p>要点总结：</p><ol type="1"><li>若干个事件 <span class="math inline">\(\{A_n\}\)</span>独立不是指它们两两独立，而是其中任何有限多个子事件都独立。</li><li>验证若干 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\{\mathcal{F}_i\}\)</span>独立只需要验证生成它们的 <span class="math inline">\(\pi\)</span>- 系<span class="math inline">\(\{C_i:\ \mathcal{F}_i=\sigma(C_i)\}\)</span>独立。</li></ol><div id="borel-cantelli--------ii" class="statement sta_borel_cantelli____ii plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Borel-Cantelli 引理 II</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{A_n\}\)</span> 是独立的事件列，则若 <span class="math inline">\(\sum_{n=1}^\infty\mathbb{P}(A_n)=\infty\)</span>，则<span class="math inline">\(\mathbb{P}(\{A_n,\mathrm{i.o.}\})=1\)</span>。</p></div><p>想法还是要用独立性，转到事件的交上去。</p><p><span class="math display">\[\mathbb{P}(\{A_n,\\mathrm{i.o.}\})=\mathbb{P}(\bigcap_{n=1}^\infty\bigcup_{k\geqn}A_k)=\lim_{n\to\infty}\mathbb{P}(\bigcup_{k\geq n}A_k).\]</span>观察两边，要想用上独立性，就得取补： <span class="math display">\[1-\mathbb{P}(\bigcup_{k\geqn}A_k)=\mathbb{P}(\bigcap_{k\geqn}A_k^c)=\lim_{M\to\infty}\prod_{k=n}^M\mathbb{P}(A_k^c)=\lim_{M\to\inftyy}\prod_{k=n}^M(1-\mathbb{P}(A_k)).\]</span> 利用 <span class="math inline">\(1-x\leq e^{-x}\)</span> 有 <span class="math display">\[\lim_{M\to\infty}\prod_{k=n}^M(1-\mathbb{P}(A_k))\leq\lim_{M\to\infty}\prod_{k=n}^Me^{-\mathbb{P}(A_k)}=\lim_{M\to\infty}e^{-\sum_{k=n}^M\mathbb{P}(A_k)}.\]</span>上式右边对任何固定的 <span class="math inline">\(n\)</span> 其极限都是0，从而 <span class="math inline">\(\mathbb{P}(\bigcup_{k\geqn}A_k)\to1\)</span>，结论得证。<span class="math inline">\(\blacksquare\)</span></p><h1 id="independent-random-variables">✅ 15.2 Independent RandomVariables</h1><p>上一讲介绍了独立事件和独立事件域的概念，这一讲介绍了独立随机变量的概念。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理30.1</span>.</span><span class="statement-spah"> </span>一族随机变量<span class="math inline">\(\{X_i\}_{i\in I}\)</span>称作是独立的，如果它们的 <span class="math inline">\(\sigma-\)</span> 域<span class="math inline">\(\{\sigma(X_i)\}_{i\in I}\)</span>是独立的。</p></div><p>由于 <span class="math inline">\(\sigma(X_i)\)</span> 可以由 <span class="math inline">\(\pi-\)</span> 系 <span class="math inline">\(\{X_i\in(-\infty, t_i]\}\)</span>生成，所以只要验证这个 <span class="math inline">\(\pi\)</span>-系的独立性即可。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理30.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(X=(X_1,\ldots,X_n)\)</span>，其中每个 <span class="math inline">\(X_i:(\Omega,\mathcal{F},\mathbb{P})\to(\mathcal{S}_i,\mathcal{B}_i)\)</span>是随机变量，<span class="math inline">\(\mu_X\)</span> 是 <span class="math inline">\(\mathcal{B}_1\otimes\cdots\otimes\mathcal{B}_n\)</span>上的测度: <span class="math inline">\(\mu_X(B)=\mathbb{P}(X\inB)\)</span>。则 <span class="math inline">\(X_1,X_2,\ldots,X_n\)</span>独立当且仅当 <span class="math inline">\(\mu_X=\mu_{X_1}\otimes\cdots\otimes\mu_{X_n}\)</span>。</p></div><p><strong>证明</strong>：<span class="math inline">\(\Leftarrow\)</span>:</p><p><span class="math display">\[\begin{align*}\mathbb{P}(X_1\inB_1,\ldots,X_n\in B_n)&amp;=\mu_X(B_1\times \cdots\times B_n)\\&amp;=\mu_{X_1}(B_1)\cdots\mu_{X_n}(B_n)\\&amp;=\mathbb{P}(X_1\in B_1)\cdots\mathbb{P}(X_n\inB_n).\end{align*}\]</span></p><p><span class="math inline">\(\Rightarrow\)</span>: 简单。</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论30.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(X_1,X_2,\ldots,X_n\)</span> 都是 <span class="math inline">\(L^1\)</span> 可积的随机变量，则 <span class="math inline">\(X_1X_2\cdots X_n\in L^1\)</span> 且 <span class="math inline">\(\mathbb{E}[X_1\cdotsX_n]=\mathbb{E}[X_1]\cdots\mathbb{E}[X_n]\)</span>。</p></div><p>首先对 <span class="math inline">\(|X_1X_2\cdots X_n|\)</span> 用Tonelli 定理得出 <span class="math inline">\(|X_1X_2\cdots X_n|\)</span>可积，然后再对 <span class="math inline">\(X_1X_2\cdots X_n\)</span> 用Fubini 定理。</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论30.4</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(X_1,\ldots,X_n,Y_1,\ldots,Y_m\)</span>是一组独立的随机变量，则 <span class="math inline">\(f(X_1,\ldots,X_n)\)</span> 和 <span class="math inline">\(g(Y_1,\ldots,Y_m)\)</span> 也是独立的。</p></div><p>这是因为 <span class="math inline">\(\sigma(f(X_1,\ldots,X_n))\subseteq\sigma(X_1,\ldots,X_n)\)</span>，<span class="math inline">\(\sigma(g(Y_1,\ldots,Y_m))\subseteq\sigma(Y_1,\ldots,Y_m)\)</span>，所以也是独立的。</p><h1 id="kolmogorovs-extension-theorem-part-2">✅ 16.2 Kolmogorov’sExtension Theorem, Part 2</h1><p>回忆一个 Radon 测度是指，它是一个有限的 Borel测度，并且满足内外的正则性：从内部可以用紧集任意逼近，从外部可以用开集任意逼近。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理31.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathbb{R}^d\)</span> 上的任何有限 Borel 测度都是Radon 测度。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(\mathcal{F}\)</span>是所有可以从外部被开集任意逼近的那些子集构成的集合。我们要证明 <span class="math inline">\(\mathcal{F}\)</span> 包含 <span class="math inline">\(\mathcal{B}(\mathbb{R}^d)\)</span>。</p><ol type="1"><li><span class="math inline">\(\mathcal{F}\)</span>包含所有闭集。实际上对闭集 <span class="math inline">\(F\)</span>，令<span class="math inline">\(G_\epsilon=\cup_{x\inF}B(x,\epsilon)\)</span>，则 <span class="math inline">\(G_\epsilon\downarrow\overline{F}=F\)</span>。从而由测度连续性即得。</li><li><span class="math inline">\(\mathcal{F}\)</span>对有限集合运算封闭，从而 <span class="math inline">\(\mathcal{F}\)</span> 是一个代数。</li><li><span class="math inline">\(\mathcal{F}\)</span>对可数不交并封闭。</li></ol><p>由此即得结论。<span class="math inline">\(\blacksquare\)</span></p><h1 id="kolmogorovs-0-1-law">✅ 17.1 Kolmogorov’s 0-1 Law</h1><p>本讲介绍了独立随机变量序列的尾事件，以及 Kolmogrov 0-1 律。</p><p>设 <span class="math inline">\(\{X_n\}\)</span> 是独立的随机变量序列(不是两两独立，而是任何有限多个都独立)称 <span class="math inline">\(\mathcal{T}=\cap_{n=1}^\infty\sigma(X_n,X_{n+1},\ldots)\)</span>为尾事件域。</p><div id="kolmogrov-0-1----" class="statement sta_kolmogrov_0_1__ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Kolmogrov 0-1 律</span>.</span><span class="statement-spah"> </span>对任何 <span class="math inline">\(A\in\mathcal{T}\)</span> 有 <span class="math inline">\(\mathbb{P}(A)\in\{0,1\}\)</span>。</p></div><p><strong>证明概要</strong>：</p><ul><li><span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span> 和 <span class="math inline">\(\sigma(X_{n+1},X_{n+2},\ldots)\)</span>是独立的。因为考虑如下两个集合族： <span class="math display">\[\{\text{all finite intersections like }\cap A_i,A_i\in\sigma(X_i),i=1,2,\ldots,n\}.\]</span> <span class="math display">\[\{\text{all finite intersections like }\cap A_j,A_j\in\sigma(X_j),j=n+1,n+2,\ldots\}.\]</span> 这俩都是 <span class="math inline">\(\pi\)</span>- 系且互相独立，所以它们生成的 <span class="math inline">\(\sigma\)</span>- 域也独立。前者可以生成 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span>，后者可以生成<span class="math inline">\(\sigma(X_{n+1},X_{n+2},\ldots)\)</span>。</li><li>于是 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span> 和<span class="math inline">\(\mathcal{T}\)</span> 是独立的。</li><li>于是 <span class="math inline">\(\cup_{n=1}^\infty\sigma(X_1,\ldots,X_n)\)</span>作为代数，当然也是 <span class="math inline">\(\pi\)</span>- 系，和<span class="math inline">\(\mathcal{T}\)</span> 是独立的。</li><li>于是 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\sigma(X_1,\ldots,X_n,\ldots)\)</span> 和 <span class="math inline">\(\mathcal{T}\)</span> 独立，从而 <span class="math inline">\(\mathcal{T}\)</span> 和 <span class="math inline">\(\mathcal{T}\)</span> 独立，从而得证。</li></ul><p><span class="math inline">\(\blacksquare\)</span></p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题32.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{X_i\}_{i=1}^\infty\)</span>是一个随机变量的无限序列，如果 <span class="math inline">\(Y\)</span> 是<span class="math inline">\(\sigma(X_1,X_2,\ldots)\)</span> 可测的，且<span class="math inline">\(Y\)</span> 有界，则对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，都存在 <span class="math inline">\(N\)</span> 和 Borel 可测的有界函数 <span class="math inline">\(F:\mathbb{R}^N\to\mathbb{R}\)</span> 使得 <span class="math display">\[\mathbb{E}|Y -F(X_1,\ldots,X_N)|&lt;\epsilon,\quad \mathrm{a.e.}\]</span></p></div><p><strong>证明</strong>：记 <span class="math inline">\(Y_n=\mathbb{E}[Y\mid\sigma(X_1,\ldots,X_n)]\)</span>，则<span class="math inline">\(\{Y_n\}\)</span> 是一致可积鞅，且在 <span class="math inline">\(L^1\)</span> 范数下收敛到 <span class="math inline">\(Y\)</span>。每个 <span class="math inline">\(Y_n\)</span> 根据 Doob-Dynkin 引理都形如 <span class="math inline">\(Y_n=F(X_1,\ldots,X_n)\)</span>。此即为结论。</p><p>或者也可以这样证：先取简单函数 <span class="math display">\[\varphi =\sum_{k=1}^n a_k\mathbb{1}_{A_k},\quadA_k\in\mathcal{B}(\mathbb{R}^{\mathbb{N}})\]</span> 满足 <span class="math inline">\(|Y -\varphi|_1&lt;\epsilon/2\)</span>。然后记<span class="math inline">\(M=\max\{|a_1|,\ldots,|a_k|\}\)</span>。对每个<span class="math inline">\(A_k\)</span>，取柱集 <span class="math inline">\(C_k\)</span> 使得 <span class="math display">\[\mu(A_k\Delta C_k) &lt;\frac{\epsilon}{2nM}.\]</span> 于是 <span class="math display">\[\left|\sum_{k=1}^n a_k\mathbb{1}_{A_k} -  \sum_{k=1}^na_k\mathbb{1}_{C_k}\right|\leq  \sum_{k=1}^n |a_k||\mathbb{1}_{A_k}-\mathbb{1}_{C_k}|= \sum_{k=1}^n|a_k|\mathbb{1}_{A_k\Delta C_k}\leq M \sum_{k=1}^n\mathbb{1}_{A_k\DeltaC_k}.\]</span> 右边函数每一项的积分 <span class="math inline">\(&lt;\epsilon/2n\)</span>，全部 <span class="math inline">\(n\)</span> 项合起来的积分 <span class="math inline">\(&lt;\epsilon\)</span>，所以简单函数 $ <em>{k=1}^na_k</em>{C_k}$ 就是所求的 <span class="math inline">\(F\)</span>。<span class="math inline">\(\blacksquare\)</span></p><h1 id="convolution">✅ 17.2 Convolution</h1><p>本讲介绍了概率测度之间的卷积。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义33.1</span>.</span><span class="statement-spah"> </span>两个概率测度<span class="math inline">\(\mu,\nu\)</span> 之间的卷积定义为 <span class="math display">\[\mu\ast \nu(B) =\int_{\mathbb{R}^d\times\mathbb{R}^d}\mathbb{1}_B(x+y)\mu\otimes\nu(\,\mathrm{d}x\,\mathrm{d}y)=\int_{\mathbb{R}^d}\mu(B-y)\nu(\mathrm{d}y).\]</span></p></div><h1 id="strong-law-of-large-numbers-part-1">✅ 18.1 Strong Law of LargeNumbers, Part 1</h1><p>本讲介绍了 Kolmogrov 强大数定理的表述，以及证明思想。</p><p>基本思想是利用截断的序列与原序列是尾等价的，先对截断的序列证明结论，再回到原序列。</p><div id="---------------" class="statement sta______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">强大数定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span> 的 <span class="math inline">\(L^1\)</span> 序列且 <span class="math inline">\(\mathbb{E}[X_n]=a\)</span>，则 <span class="math inline">\(\dfrac{S_n}{n}\to a, \mathrm{a.e.}\)</span>。</p></div><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义34.1</span>.</span><span class="statement-spah"></span>同一个概率空间上的两个随机变量序列 <span class="math inline">\(\{X_n\},\,\{Y_n\}\)</span> 称作是尾等价的，如果<span class="math display">\[\sum_{n=1}^\infty\mathbb{P}(X_n\neY_n)&lt;\infty.\]</span></p></div><p>这样根据 Borel-Cantelli 引理，<span class="math inline">\(\{X_n\neY_n\,\mathrm{i.o.}\}\)</span> 是零测集，从而 <span class="math inline">\(X_n=Y_n\)</span>最终会几乎处处成立，从而二者的极限行为一致。</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论34.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\{X_n\}\)</span> 和 <span class="math inline">\(\{Y_n\}\)</span> 是尾等价的，<span class="math inline">\(b_n\uparrow\infty\)</span>，则 <span class="math display">\[\lim\limits_{n\to\infty}\dfrac{1}{b_n}\sum_{j=1}^nX_n = X \Leftrightarrow\lim\limits_{n\to\infty}\dfrac{1}{b_n}\sum_{j=1}^n Y_n = X.\]</span></p></div><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理34.3</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(X\in L^1,\,\epsilon&gt;0\)</span>，则 <span class="math display">\[\sum_{n=1}^\infty\mathbb{P}(X\geq n\epsilon)\leq\frac{1}{\epsilon}\mathbb{E}|X|.\]</span></p></div><p>值得与 Markov 不等式比较一下，这个不等式更强。</p><p><strong>证明概要</strong>：只要证明结论对 <span class="math inline">\(\epsilon=1\)</span> 成立即可。对任意实数 <span class="math inline">\(x\ge 0\)</span>，我们有 <span class="math display">\[\sum_{n=1}^{\infty}\mathbb{1}_{[n,\infty)}(x)=\sharp\{n\in\mathbb{Z}_+\mid n\le x\}= \lfloor x\rfloor\le x.\]</span> 对 <span class="math inline">\(|X|\)</span> 使用上式得<span class="math display">\[\sum_{n=1}^{\infty}\mathbb{1}_{[n,\infty)}(|X|)\le|X|.\]</span> 两边求期望即得 <span class="math display">\[\sum_{n=1}^\infty\mathbb{P}(|X|\ge n)\le\mathbb{E}|X|.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论34.4</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span> 的 <span class="math inline">\(L^1\)</span> 序列，令 <span class="math inline">\(Y_n = X_n\mathbb{1}_{\{|X_n|\leq n\}}\)</span>，则<span class="math inline">\(\{Y_n\}\)</span> 与 <span class="math inline">\(\{X_n\}\)</span> 是尾等价的。</p></div><p><strong>证明</strong>： <span class="math display">\[\sum_{n=1}^\infty\mathbb{P}(X_n\neY_n)=\sum_{n=1}^\infty\mathbb{P}(|X_n|&gt;n)=\sum_{n=1}^\infty\mathbb{P}(|X_1|&gt;n)\le\mathbb{E}|X_1|&lt;\infty.\]</span><span class="math inline">\(\blacksquare\)</span></p><p>于是接下来的任务就是证明 <span class="math inline">\(S_n^Y =\dfrac{Y_1+\cdots+Y_n}{n}\to a,\,\mathrm{a.e.}\)</span>。</p><h1 id="kolmogorovs-convergence-criterion">✅ 18.2 Kolmogorov’sConvergence Criterion</h1><p>本讲介绍了 Kolmogrov 收敛判定：独立随机变量序列如果是 <span class="math inline">\(L^2\)</span> 意义下的 Cauchy序列，则也是逐点收敛意义下的 Cauchy 序列。</p><p>在上一讲中，我们通过把 <span class="math inline">\(L^1\)</span>的序列 <span class="math inline">\(\{X_n\}\)</span> 取截断得到 <span class="math inline">\(Y_n=X_n\mathbb{1}_{\{|X_n|\leqn\}}\)</span>，这是一个与 <span class="math inline">\(\{X_n\}\)</span>尾等价的序列。从而只要证明 <span class="math inline">\(\frac{\sum_{k=1}^n Y_k}{n}\toa\)</span>。为此我们分两步：</p><ol type="1"><li>证明 <span class="math inline">\(\frac{\sum_{k=1}^n(Y_k-\mathbb{E}Y_k)}{n}\to 0\)</span>。</li><li>证明 <span class="math inline">\(\mathbb{E}Y_n\to a\)</span>，从而<span class="math inline">\(\frac{\sum_{k=1}^n\mathbb{E}Y_k}{n}\toa\)</span>。结合上一点就证明了强大数定理。</li></ol><p>2 用控制收敛定理很容易得出，所以关键是证明 1。</p><p>我们首先证明 <span class="math inline">\(\sum_{k=1}^n\frac{Y_k-\mathbb{E}Y_k}{n}\)</span> 是个收敛的序列，然后用下一讲介绍的Kronecker 引理来得出 <span class="math inline">\(\frac{\sum_{k=1}^n(Y_k-\mathbb{E}Y_k)}{n}\to 0\)</span>。</p><div id="kolmogrov-------------" class="statement sta_kolmogrov_____ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Kolmogrov 收敛判定</span>.</span><span class="statement-spah"> </span>：若独立且 <span class="math inline">\(L^2\)</span> 可积的随机变量序列 <span class="math inline">\(\{Y_n\}\)</span> 满足 <span class="math display">\[\sum\mathrm{Var}(Y_n)&lt;\infty.\]</span> 则<span class="math display">\[\sum_{n=1}^\infty(Y_n-\mathbb{E}Y_n)\]</span>几乎处处收敛。并且这个收敛也是 <span class="math inline">\(L^2\)</span>收敛。</p></div><p><strong>证明概要</strong>：记 <span class="math inline">\(Z_n=Y_n-\mathbb{E}Y_n\)</span>，则 <span class="math inline">\(\mathbb{E}Z_n=0\)</span> 且 <span class="math inline">\(\sum_{n=1}^\infty\mathbb{E}Z_n^2&lt;\infty\)</span>。我们来证明<span class="math inline">\(\sum_{n=1}^\infty Z_n\)</span>几乎处处收敛。</p><p>记 <span class="math inline">\(S_n=\sum_{k=1}^nZ_k\)</span>，利用Markov 不等式不难有 <span class="math display">\[\mathbb{P}(|S_n|\geq\epsilon)\leq\frac{1}{\epsilon^2}\mathbb{E}[S_n^2].\]</span>有意思的是，上面的不等式中在左边把 <span class="math inline">\(S_n\)</span> 换成 <span class="math inline">\(S_n^\ast=\max\limits_{1\leq i\leq n}|S_n|\)</span>仍然成立：</p><div id="kolmogrov----------------" class="statement sta_kolmogrov______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Kolmogrov 极大不等式</span>.</span><span class="statement-spah"> </span>：对任何正数 <span class="math inline">\(\epsilon&gt;0\)</span> 有 <span class="math display">\[\mathbb{P}(S_n^\ast\geq\epsilon)\leq\frac{1}{\epsilon^2}\mathbb{E}[S_n]^2.\]</span></p></div><p><strong>证明</strong>：记 <span class="math inline">\(\tau=\min\{j\mid |S_j|\geq\epsilon\}\)</span>。则<span class="math inline">\(\{S_n^\ast\geq\}=\{\tau\leq n\}\)</span>。<span class="math display">\[\mathbb{E}[S_n^2\mathbb{1}_{\{S_n^\ast\geq\epsilon\}}]=\mathbb{E}[S_n^2\mathbb{1}_{\{\tau\leqn\}}]=\sum_{k=1}^n\mathbb{E}[S_n^2\mathbb{1}_{\{\tau=k\}}].\]</span>使用技巧 <span class="math inline">\(S_n^2=(S_k + S_n - S_k)^2\)</span>我们有 <span class="math display">\[\mathbb{E}[S_n^2\mathbb{1}_{\{\tau=k\}}] =\mathbb{E}[(S_k^2 + (S_n-S_k)^2)\mathbb{1}_{\{\tau=k\}}] +\mathbb{E}[2S_k(S_n-S_k)\mathbb{1}_{\{\tau=k\}}].\]</span> 注意到第二项<span class="math display">\[\mathbb{E}[2S_k(S_n-S_k)\mathbb{1}_{\{\tau=k\}}]=2\mathbb{E}[S_k\mathbb{1}_{\{\tau=k\}}]\cdot\mathbb{E}[S_n-S_k]=0.\]</span>所以 <span class="math display">\[\mathbb{E}[S_n^2]\geq\sum_{k=1}^n\mathbb{E}[S_k^2\mathbb{1}_{\{\tau=k\}}]\geq\epsilon^2\sum_{k=1}^n\mathbb{E}[\mathbb{1}_{\{\tau=k\}}]=\epsilon^2\mathbb{P}(\tau\leqn)=\epsilon^2 \mathbb{P}(S_n^\ast\geq\epsilon).\]</span></p><p>回到 Kolmogrov 收敛定理的证明。</p><p>Kolmogrov 极大不等式告诉我们</p><p><span class="math display">\[\mathbb{P}(\max_{n\leq k \leq m}|S_k -S_n|\geq\epsilon)\leq\frac{1}{\epsilon^2}\mathbb{E}|S_m-S_n|^2=\frac{1}{\epsilon^2}\sum_{k=n}^m\mathbb{E}Z_k^2.\]</span> 令 <span class="math inline">\(m\to\infty\)</span> 我们有 <span class="math display">\[\mathbb{P}(\sup_{k\geq n}|S_k -S_n|\geq\epsilon)\leq\frac{1}{\epsilon^2}\sum_{k=n}^\infty\mathbb{E}Z_k^2.\]</span> 于是 <span class="math display">\[\mathbb{P}(\sup_{k,j\geq n}|S_k -S_j|\geq\epsilon)\leq\frac{2}{\epsilon^2}\sum_{k=n}^\infty\mathbb{E}Z_k^2.\]</span> 所以随机变量序列 <span class="math display">\[\delta_n := \sup_{k,j\geq n}|S_k - S_j|\]</span>依测度收敛到 0。但是 <span class="math inline">\(\{\delta_n\}\)</span>是一个单调下降的非负序列，它必然有一个几乎处处收敛的极限 <span class="math inline">\(\delta\)</span>，<span class="math inline">\(\delta\)</span> 也非负。<span class="math inline">\(\{\delta_n\}\)</span> 依测度收敛到0，又几乎处处收敛到 <span class="math inline">\(\delta\)</span>，那必须<span class="math inline">\(\delta\)</span> 几乎处处为 0，即 <span class="math inline">\(\{S_n\}\)</span> 是 Cauchy 序列。<span class="math inline">\(\blacksquare\)</span></p><h1 id="strong-law-of-large-numbers-part-2">19.1 Strong Law of LargeNumbers, Part 2</h1><p>介绍了证明强大数定理的第二个工具：Kronecker 引理。</p><div id="kronecker-------" class="statement sta_kronecker___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Kronecker 引理</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\{b_k\}\uparrow\infty\)</span> 且 <span class="math inline">\(\lim\limits_{n\to\infty}\sum\limits_{k=1}^n\dfrac{x_k}{b_k}\)</span>存在，则 <span class="math inline">\(\lim\limits_{n\to\infty}\dfrac{1}{b_n}\sum\limits_{k=1}^nx_k=0\)</span>。</p></div><p><strong>证明概要</strong>：记 <span class="math inline">\(u_n=\sum\limits_{k=1}^n\dfrac{x_k}{b_k},\,u_0=0\)</span>，则<span class="math inline">\(\lim\limits_{n\to\infty}u_n=s\)</span>存在。 <span class="math display">\[\begin{align*}\frac{1}{b_n}\sum_{k=1}^nx_k&amp;=\frac{1}{b_n}\sum_{k=1}^n(u_k-u_{k-1})b_k=\frac{1}{b_n}\sum_{k=1}^nu_kb_k-\frac{1}{b_n}\sum_{k=0}^{n-1}u_kb_{k+1}\\&amp;=u_n-\frac{b_n-b_1}{b_n}s-\sum_{k=1}^{n-1}\frac{b_{k+1}-b_k}{b_n}(u_k-s).\end{align*}\]</span>而最后一个余项的绝对值小于等于 <span class="math display">\[\begin{align*}\sum_{k=1}^{n-1}\frac{b_{k+1}-b_k}{b_n}|u_k-s|=\left(\sum_{k=1}^{N}+\sum_{k=N+1}^{n-1}\right)\frac{b_{k+1}-b_k}{b_n}|u_k-s|\end{align*}\]</span>这里对 <span class="math inline">\(n&gt;N\)</span> 有 <span class="math inline">\(|u_n-s|&lt;\epsilon\)</span> 成立。</p><p>当 <span class="math inline">\(n\to\infty\)</span>时第一个和项是一个有界的值除以 <span class="math inline">\(b_n\)</span>从而趋于 0。第二个和项显然不大于 <span class="math inline">\(\dfrac{b_n}{b_n}\epsilon\)</span>，所以这个余项可以任意小。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理36.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(Y_n' = Y_n/n\)</span> 满足 Kolmogrov收敛判定。</p></div><p><strong>证明概要</strong>： <span class="math display">\[\begin{align*}\sum_{n=1}^\infty\mathrm{Var}(Y_n')&amp;=\sum_{n=1}^\infty\frac{\mathbb{E}Y_n^2- (\mathbb{E}Y_n)^2}{n^2}\leq\sum_{n=1}^\infty\frac{\mathbb{E}Y_n^2}{n^2}\\&amp;=\sum_{n=1}^\infty\frac{\mathbb{E}X_n^2\mathbb{1}_{\{|X_n|\leqn\}}}{n^2}\\&amp;=\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}}\right]\\&amp;\leq\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2},\|X_1|\leq 2\right] +\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}},\|X_1|&gt;2\right]\\&amp;\leq4\sum_{n=1}^\infty\frac{1}{n^2}+\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}},\ |X_1|&gt;2\right] .\end{align*}\]</span> 为什么要用 <span class="math inline">\(|X_1|\)</span> 是否大于 2把它分成两部分？这里其实可以用任何大于等于 2 的数，不过 2已经足够了，这样做的原因下面就会看到。</p><p>现在第一项是有限的，我们只要说明第二项也有限即可。你可能想把 <span class="math inline">\(\mathbb{1}_{\{|X_1|\leq n\}}\)</span>扔掉，但是注意强大数定律中 <span class="math inline">\(|X_1|\)</span> 是<span class="math inline">\(L^1\)</span> 可积的，未必是 <span class="math inline">\(L^2\)</span> 可积的，所以扔掉是不行的。我们得把<span class="math inline">\(\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}}\)</span> 这个东西估计一下。注意到对任何正整数 <span class="math inline">\(k\)</span>，<span class="math inline">\(\sum_{n=k}^\infty\frac{1}{n^2}\)</span> 就是 <span class="math inline">\(\frac{1}{\lfloor t\rfloor^2}\)</span> 在 <span class="math inline">\([k,\infty)\)</span> 上的积分， 所以当 <span class="math inline">\(x&gt;2\)</span> 时 <span class="math display">\[\begin{align*}\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{x\leq n\}}&amp;=\sum_{n\geqx}^\infty\frac{1}{n^2}=\sum_{n= \lceilx\rceil}^\infty\frac{1}{n^2}\\&amp;=\int_{\lceilx\rceil}^\infty\frac{1}{\lfloor t\rfloor^2}\,\mathrm{d}t\\&amp;\leq\int_{\lceilx\rceil}^\infty\frac{1}{(t-1)^2}\,\mathrm{d}t\\&amp;=\frac{1}{\lceilx\rceil -1}\\&amp;\leq\frac{1}{x-1}&lt;\frac{2}{x}.\end{align*}\]</span> 所以取<span class="math inline">\(x&gt;2\)</span> 主要是为了最后一步的 <span class="math inline">\(\frac{1}{x-1}&lt;\frac{2}{x}\)</span>。</p><p>于是我们就证明了在 <span class="math inline">\(|X_1|&gt;2\)</span>上有 <span class="math display">\[\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}}&lt;\frac{2}{|X_1|}.\]</span> 两边乘以 <span class="math inline">\(|X_1|^2\)</span> 并积分，则 <span class="math display">\[\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}},\ |X_1|&gt;2\right] &lt; 2\mathbb{E}|X_1|.\]</span>这就证明了结论。</p><h1 id="renewal-theory">19.2 Renewal Theory</h1><p>本讲以灯泡寿命为例子，介绍了强大数定理在更新理论中的应用。</p><p>设灯泡的寿命互相独立，且服从某个共同的非负随机变量 <span class="math inline">\(X,\ \mathbb{E}X&lt;\infty\)</span>。设长度为 <span class="math inline">\(t\)</span> 的时刻内需要报废的灯泡数最多为 <span class="math inline">\(N_t\)</span>，即 <span class="math inline">\(S_{N_t}\leq t &lt; S_{N_t+1}\)</span>。则 <span class="math display">\[\lim_{t\to\infty}\frac{N_t}{t}\to\frac{1}{\mathbb{E}X},\quad\mathrm{a.e.}\]</span> 实际上由定义有 <span class="math display">\[\frac{S_{N_t}}{N_t}\leq \frac{t}{N_t} &lt;\frac{S_{N_t+1}}{N_t}.\]</span> 如果我们能证明 <span class="math inline">\(t\to\infty\)</span> 时同样有 <span class="math inline">\(N_t\to\infty,\mathrm{a.e.}\)</span>，则利用强大数定理就有<span class="math inline">\(S_{N_t}/N_t\to\mathbb{E}X\)</span>，从而结论得证。</p><p>我们考虑 <span class="math inline">\(\Omega_1=\{\omega\in\Omega\midS_n(\omega)&lt;\infty,\ \forall n\geq1\}\)</span>。<span class="math inline">\(\Omega_1\)</span> 作为一列递减的测度均为 1的集合列的极限，测度显然也是 1。我们只要证明在 <span class="math inline">\(\Omega_1\)</span> 上有 <span class="math inline">\(S_{N_t}/N_t\to\mathbb{E}X\)</span> 成立。</p><p>首先 <span class="math inline">\(N_t\)</span> 随着 <span class="math inline">\(t\)</span> 递增是没有问题的，如果它对某个 <span class="math inline">\(\omega\)</span> 是有界的，则 <span class="math inline">\(N_t(\omega)\leq M\)</span> 对所有 <span class="math inline">\(t\)</span> 成立。即不管 <span class="math inline">\(t\)</span> 是多少都有 <span class="math inline">\(S_M\leq t &lt; S_{M+1}\)</span>，这只能要求 <span class="math inline">\(S_{M+1}(\omega)=\infty\)</span>，从而 <span class="math inline">\(\omega\)</span> 不属于 <span class="math inline">\(\Omega_1\)</span>。</p><p>一个有意思的引理：</p><blockquote><p><strong>引理</strong>：设 <span class="math inline">\(X\inL^1\)</span>，如果 <span class="math inline">\(\{X_n\}\)</span> 是一列<span class="math inline">\(\mathrm{i.i.d}\)</span> 且服从和 <span class="math inline">\(X\)</span> 同样的分布，则 <span class="math inline">\(\dfrac{X_n}{n}\to0,\mathrm{a.e.}\)</span>。</p></blockquote><p>老技巧，只要证明 <span class="math inline">\(\mathbb{P}(\{|X_n|\geqn\epsilon,\ \mathrm{i.o.}\})=0\)</span> 即可。根据 Borel-Cantelli引理，只要证明 <span class="math inline">\(\sum_{n=1}^\infty\mathbb{P}(|X_n|\geqn\epsilon)&lt;\infty\)</span> 即可，而这在 18.1 中已经证明过了。</p><h1 id="total-variation">✅ 21.1 Total Variation</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义38.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mu,\nu\)</span> 是 <span class="math inline">\((S,\mathcal{B})\)</span>上的两个概率测度。定义它们之间的全变差为 <span class="math display">\[\mathrm{d_{TV}}(\mu,\nu) =\sup_{B\in\mathcal{B}}|\mu(B)-\nu(B)|.\]</span></p></div><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理38.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mu,\nu\)</span> 是 <span class="math inline">\((S,\mathcal{B})\)</span> 上的两个概率测度，<span class="math inline">\(\alpha\)</span> 是有限测度且 <span class="math inline">\(\mu,\nu\ll\alpha\)</span>。设 <span class="math inline">\(\mathrm{d}\mu =f\,\mathrm{d}\alpha,\mathrm{d}\nu=g\,\mathrm{d}\alpha\)</span>，则 <span class="math display">\[\mathrm{d_{TV}}(\mu,\nu) =\frac{1}{2}\|f-g\|_{L^1(\alpha)}.\]</span></p></div><p><strong>证明</strong>：对任何 <span class="math inline">\(B\in\mathcal{B}\)</span>， <span class="math display">\[|\mu(B) - \nu(B)| =\left|\int_B (f-g)\,\mathrm{d}\alpha\right|.\]</span> <span class="math display">\[|\mu(B^c) - \nu(B^c)| = \left|\int_{B^c}(f-g)\,\mathrm{d}\alpha\right|.\]</span>上面两个式子，左边的值是一样的，右边之和大于等于 <span class="math inline">\(\|f-g\|\)</span>，所以 <span class="math display">\[\mathrm{d_{TV}}(\mu,\nu)\le \|f-g\|.\]</span>另一方面，取 <span class="math inline">\(A=\{f &gt; g\}\)</span>，则由于<span class="math inline">\(\mu,\nu\)</span> 是概率测度，所以 <span class="math display">\[0=\int_S (f-g)\,\mathrm{d}\alpha=\int_A(f-g)\,\mathrm{d}\alpha+ \int_{A^c}(f-g)\,\mathrm{d}\alpha=\int_A|f-g|\,\mathrm{d}\alpha- \int_{A^c}|f-g|\,\mathrm{d}\alpha.\]</span> 即<span class="math display">\[\mu(A)-\nu(A)=\int_A(f-g)\,\mathrm{d}\alpha=\int_A|f-g|\,\mathrm{d}\alpha=\frac{1}{2}\|f-g\|_{L1}.\]</span> <span class="math inline">\(\blacksquare\)</span></p><p>给定一族 <span class="math inline">\(\{\mu_n\}_{n\ge1}\)</span>，取<span class="math display">\[\alpha =\sum_{n=1}^\infty\frac{\mu_n}{2^n}.\]</span> 则 <span class="math inline">\(\mu_n\ll\alpha_n\)</span>。</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论38.3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathrm{d_{TV}}\)</span> 是 <span class="math inline">\((S,\mathcal{B})\)</span> 上的完备度量。</p></div><p><strong>证明</strong>：取 <span class="math inline">\(\alpha\)</span>如上使得 <span class="math inline">\(\mu_n\ll\alpha\)</span>，则问题转化为使用 <span class="math inline">\(L^1(\alpha)\)</span> 是完备度量空间。<span class="math inline">\(\blacksquare\)</span>。</p><h1 id="weak-convergence">✅ 22.1 Weak Convergence</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义39.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{S}\)</span> 是一个度量空间，<span class="math inline">\(\mu_n,\mu\)</span> 是 <span class="math inline">\((\mathcal{S},\mathcal{B}(\mathcal{S}))\)</span>上的概率测度。如果有 <span class="math display">\[\intf\,\mathrm{d}\mu_n\to \int f \,\mathrm{d}\mu,\quad \forall f\inC_b(\mathcal{S}).\]</span> 就称 <span class="math inline">\(\mu_n\)</span> 弱收敛到 <span class="math inline">\(\mu\)</span>。</p></div><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理39.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{X_n\}, X\)</span> 都是从概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\to(\mathcal{S},\mathcal{B}(\mathcal{S}))\)</span> 的随机变量。 如果 <span class="math inline">\(X_n\to_\mathbb{P}X\)</span> 且 <span class="math inline">\(g\)</span> 是连续函数，则 <span class="math inline">\(g(X_n)\to_\mathbb{P}g(X)\)</span>。</p></div><p>证明：设 <span class="math inline">\(\epsilon,\delta&gt;0\)</span>。记 <span class="math display">\[B_{\epsilon,\delta}(g)=\{x\in\mathcal{S}\mid\exists y\in\mathcal{S}, d(x,y)\leq\delta,|g(x)-g(y)|\geq\epsilon\}.\]</span> <span class="math inline">\(g\)</span> 的连续性保证了对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，<span class="math inline">\(\lim_{\delta\to0}B_{\epsilon,\delta}(g)\downarrow\emptyset\)</span>。</p><p>于是 <span class="math display">\[\{\omega\mid|g(X_n(\omega))-g(X(\omega))|\geq\epsilon\}\subset\{\omega\midd(X_n(\omega), X(\omega))\geq\delta\}\cup\{\omega\mid X(\omega)\inB_{\epsilon,\delta}(g)\}.\]</span> 于是 <span class="math display">\[\mathbb{P}(|g(X_n(\omega))-g(X(\omega))|\geq\epsilon)\le\mathbb{P}(d(X_n(\omega), X(\omega))\geq\delta) + \mathbb{P}(X\inB_{\epsilon,\delta}(g)).\]</span> 也就是 <span class="math display">\[\mathbb{P}(|g(X_n)-g(X)|\geq\epsilon)\le\mathbb{P}(d(X_n, X)\geq\delta) +\mu_X(B_{\epsilon,\delta}(g)).\]</span>所以，对给定的 <span class="math inline">\(\epsilon\)</span>，我们可以取<span class="math inline">\(\delta\)</span>使得第二项任意小，再取最后大的 <span class="math inline">\(n\)</span>使得第一项任意小。这就证明了结论。<span class="math inline">\(\blacksquare\)</span></p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题39.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(X_n\to_\mathbb{P}X\)</span>，则 <span class="math inline">\(X_n\to_w X\)</span>。</p></div><p>证明：设 <span class="math inline">\(f\inC_b(\mathcal{S})\)</span>。则 <span class="math inline">\(\intf\,\mathrm{d}\mu_{X_n}=\mathbb{E}[f(X_n)]\)</span>。于是我们要证明 <span class="math display">\[\mathbb{E}[f(X_n)]\to \mathbb{E}[f(X)].\]</span>但是根据引理，<span class="math inline">\(f(X_n)\to_\mathbb{P}f(X)\)</span>。又因为 <span class="math inline">\(f\)</span>有界，所以由依测度收敛的控制收敛定理即得。<span class="math inline">\(\blacksquare\)</span></p><div id="portmanteau-------" class="statement sta_portmanteau___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Portmanteau 定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{\mu_n\},\mu\)</span> 都是空间 <span class="math inline">\((\mathcal{S},\mathcal{B}(\mathcal{S}))\)</span>上的概率测度。以下结论是等价的：</p><ol type="1"><li><span class="math inline">\(\mu_n\to_w\mu\)</span>。</li><li><span class="math inline">\(\int f\,\mathrm{d}\mu_n\to\intf\,\mathrm{d}\mu,\quad \forallf\in\mathrm{Lip}_b(\mathcal{S})\)</span>。</li><li><span class="math inline">\(\limsup \mu_n(F)\le \mu(F)\)</span>对任何闭集 <span class="math inline">\(F\)</span> 成立。</li><li><span class="math inline">\(\liminf \mu_n(G)\ge \mu(G)\)</span>对任何开集 <span class="math inline">\(G\)</span> 成立。</li><li><span class="math inline">\(\mu_n(A)\to \mu(A)\)</span> 对任何满足<span class="math inline">\(\mu(\partial A)=0\)</span> 的集合 <span class="math inline">\(A\in\mathcal{B}(\mathcal{S})\)</span> 成立。</li></ol></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>Portmanteau的原意是把若干词拼起来组成新词。这里表示把一些看起来不同的结论放在一起。</p></div><p><span class="math inline">\(1\Rightarrow 2\)</span> 显然。</p><p><span class="math inline">\(2\Rightarrow3\)</span>：取 <span class="math inline">\(\psi\in{\rm Lip}_b(\mathbb{R})\)</span>为如下的截断函数：</p><p><span class="math display">\[\psi(x)=\begin{cases}1, &amp; x &lt; 0\\0, &amp; x &gt; 1\\1-x, &amp; 0\leq x\leq 1\end{cases}\]</span> 不难看出 <span class="math inline">\(\|\phi\|_{\rmLip}\leq1\)</span>。</p><p>给定闭集 <span class="math inline">\(F\)</span>，考虑 <span class="math display">\[f_k(x) = \phi(k \cdot d(x, F)).\]</span> 则 <span class="math display">\[|f_k(x)-f_k(y)|\leq k |d(x,F)-d(y,F)|\leq k\cdotd(x,y).\]</span> 这里用到了距离到集合的函数是 1-Lipschitz。从而 <span class="math inline">\(f_k\in{\rm Lip}_b(\mathcal{S})\)</span>。 注意到<span class="math display">\[\lim_{k\to\infty}f_k(x)=\begin{cases}f_k(x)\downarrow\psi(\infty) = 0, &amp; d(x,F)&gt; 0\\f_k(x) = \phi(0) = 0, &amp; d(x,F)=0\end{cases} = \mathbb{1}_F.\]</span> 总之 <span class="math inline">\(f_k\downarrow \mathbb{1}_F\)</span>。于是 <span class="math display">\[\limsup\mu_n(F)=\limsup\int\mathbb{1}_F\,\mathrm{d}\mu_n\le \limsup\int f_k\,\mathrm{d}\mu_n = \intf_k\,\mathrm{d}\mu\]</span> 上面的式子对所有 <span class="math inline">\(k\)</span> 都成立。然而根据控制收敛定理，<span class="math inline">\(\int f_k\,\mathrm{d}\mu\to \int\mathbb{1}_F\,\mathrm{d}\mu= \mu(F)\)</span>。得证。</p><p><span class="math inline">\(3\Leftrightarrow4\)</span>：对闭集 <span class="math inline">\(F=G^c\)</span> 应用 3 即可。反之对 <span class="math inline">\(G=F^c\)</span> 应用 4。</p><p><span class="math inline">\(3,4\Rightarrow5\)</span>：如果 <span class="math inline">\(\mu(\partial A)=0\)</span>，则 <span class="math inline">\(\mu(A)=\mu(\overline{A})=\mu({\rmint}(A))\)</span>。 <span class="math display">\[\varlimsup\mu_n(A)\le\varlimsup\mu_n(\overline{A})\le\mu(\overline{A})=\mu(A)=\mu({\rm int}(A))\le\varliminf\mu_n({\rmint}(A))\le\varliminf\mu_n(A).\]</span></p><p><span class="math inline">\(5\Rightarrow1\)</span>：取任意 <span class="math inline">\(f\in C_b(\mathcal S)\)</span>，记 <span class="math inline">\(m=\inf f\)</span>, <span class="math inline">\(M=\sup f\)</span>，并令 <span class="math display">\[g=\frac{f-m}{M-m}\in C_b(\mathcal S),\qquad 0\le g\le 1.\]</span> 若已证 <span class="math inline">\(\intg\,\mathrm{d}\mu_n\to\intg\,\,\mathrm{d}\mu\)</span>，则由线性缩放可还原对 <span class="math inline">\(f\)</span> 的结论。</p><p>对任意有限测度 <span class="math inline">\(\nu\)</span> 及 <span class="math inline">\(0\le h\le 1\)</span> 的可测函数，有层蛋糕表示：<span class="math display">\[\int h\,\mathrm{d}\nu= \int_0^1 \nu\big(\{h\ge t\}\big)\,\mathrm{d}t.\]</span> 因为 <span class="math display">\[h(x)=\int_0^{h(x)}\,\mathrm{d}t=\int_0^1\mathbb{1}_{\{h(x)\get\}}\,\mathrm{d}t.\]</span> 再用 Tonelli 交换积分次序。</p><p>据此，只需证明 <span class="math display">\[\int_0^1 \mu_n\big(\{g\ge t\}\big)\,\mathrm{d}t\longrightarrow\int_0^1\mu\big(\{g\ge t\}\big)\,\mathrm{d}t.\]</span> 从而我们只要证明 <span class="math inline">\(\mu_n(\{g\get\})\to \mu(\{g\ge t\})\)</span> 对几乎处处的 <span class="math inline">\(t\in[0,1]\)</span> 成立即可。</p><p>对每个 <span class="math inline">\(t\in[0,1]\)</span>，记 <span class="math display">\[\{t\in[0,1]\mid \mu(\partial\{g\get\})&gt;0\}\subset\{t\in[0,1]\mid \mu(\{g=t\})&gt;0\}:=E.\]</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这里只是包含关系，不是相等关系。例如，取 <span class="math inline">\(g(x)\)</span> 是任何在 <span class="math inline">\([-1,1]\)</span> 上为 0，在 <span class="math inline">\(|x|&gt;1\)</span> 时取值在 <span class="math inline">\((0,1]\)</span> 之间的连续函数，则 <span class="math display">\[\{g(x)&gt; 0 \}=(-\infty, -1)\cup(1,\infty),\quad\{g(x) = 0\} = [-1,1].\]</span> 前者的边界只要两个点 <span class="math inline">\(\pm1\)</span>，是后者严格的子集。</p></div><p>则 <span class="math inline">\(\mu_n(\{g\ge t\})\to \mu(\{g\get\})\)</span> 对所有 <span class="math inline">\(t\in[0,1]\setminusE\)</span> 成立。 所以我们只要再证明 <span class="math inline">\(E\)</span> 是可数集合即可。</p><p>对每个 <span class="math inline">\(k\in\mathbb N\)</span>，集合 <span class="math display">\[E_k:=\{t:\ \mu(\{g=t\})\ge 1/k\}\]</span> 必为有限集，否则将导致 <span class="math inline">\(\sum_{t\inE_k}\mu(\{g=t\})=\infty\)</span>，与 <span class="math inline">\(\mu(\mathcal S)=1\)</span> 矛盾。从而 <span class="math inline">\(E=\bigcup_{k\ge1}E_k\)</span> 可数。<span class="math inline">\(\blacksquare\)</span></p><h1 id="weak-convergence-over-mathbbrd">✅ 22.2 Weak Convergence over<span class="math inline">\(\mathbb{R}^d\)</span></h1><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理40.1</span>.</span><span class="statement-spah"> </span>在 <span class="math inline">\(\mathcal{S}=\mathbb{R}^d\)</span> 的情形，<span class="math inline">\(\mu_n\to_w \mu\)</span> 等价于对任何 <span class="math inline">\(f\in C_c(\mathbb{R}^d)\)</span> 有 <span class="math display">\[\int f\,\mathrm{d}\mu_n\to \intf\,\mathrm{d}\mu.\]</span> 注意，这里的 <span class="math inline">\(f\)</span> 加强为具有紧支集的函数。</p></div><p>证明：只要证明当 <span class="math inline">\(f\inC_c(\mathbb{R}^d)\)</span> 时有 <span class="math display">\[\intf\,\mathrm{d}\mu_n\to \int f\,\mathrm{d}\mu.\]</span> 即可。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理40.2</span>.</span><span class="statement-spah"></span>如果定理结论成立，则 <span class="math display">\[\lim_{R\to\infty}\inf_n\mu_n(\overlineB_R)=1.\]</span></p></div><p>证明：令 <span class="math inline">\(g_R(x):\mathbb{R}^d\to\mathbb{R}\)</span>是如下的连续　函数：当 <span class="math inline">\(|x|&lt; R/2\)</span>时 <span class="math inline">\(g(x)=1\)</span>，当 <span class="math inline">\(|x|&gt;R\)</span> 时 <span class="math inline">\(g(x)=0\)</span>，当 <span class="math inline">\(R/2\le |x|\le R\)</span> 时 <span class="math inline">\(g(x)\)</span> 线性插值。则 <span class="math display">\[\mathbb{1}_{\overline B_{R/2}}\le g_R \le\mathbb{1}_{\overline B_{R}}.\]</span> 所以 <span class="math display">\[\int g_R\,\mathrm{d}\mu_n\leq \int\mathbb{1}_{\overline B_{R}}\,\mathrm{d}\mu_n=\mu_n(\overlineB_R).\]</span> 两边取下极限，并利用 <span class="math inline">\(g_R\)</span> 是具有紧支集的连续函数，得到 <span class="math display">\[\liminf_n\mu_n(\overline B_R)\geq \liminf_n\intg_R\,\mathrm{d}\mu_n=\int g_R\,\mathrm{d}\mu\geq\mu(\overlineB_{R/2}).\]</span></p><p>给定 <span class="math inline">\(\varepsilon&gt;0\)</span>。由 <span class="math inline">\(\mu(\overline B_{R/2})\uparrow 1\)</span>，可取<span class="math inline">\(R_0\)</span> 使 <span class="math inline">\(\mu(\overlineB_{R_0/2})&gt;1-\varepsilon\)</span>。 <span class="math display">\[\liminf_{n}\mu_n(\overline B_{R_0})\ \ge\1-\varepsilon.\]</span> 故存在 <span class="math inline">\(N\)</span>使得对所有 <span class="math inline">\(n\ge N\)</span>，<span class="math inline">\(\mu_n(\overline B_{R_0})\ge1-\varepsilon\)</span>。</p><p>对有限个指标 <span class="math inline">\(n&lt;N\)</span>，可取 <span class="math inline">\(R_1,\dots,R_{N-1}\)</span> 使 <span class="math inline">\(\mu_n(\overline B_{R_n})\ge1-\varepsilon\)</span>。令 <span class="math display">\[R=\max\{R_0,R_1,\dots,R_{N-1}\}.\]</span>则对所有 <span class="math inline">\(n\)</span> 都有 <span class="math inline">\(\mu_n(\overline B_R)\ge1-\varepsilon\)</span>。于是 <span class="math display">\[\inf_n\mu_n(\overline B_R)\ \ge\ 1-\varepsilon.\]</span> 由 <span class="math inline">\(\varepsilon\)</span> 任意，遂得 <span class="math display">\[\lim_{R\to\infty}\inf_n \mu_n(\overlineB_R)=1.\]</span></p><p>回到定理证明。</p><p>现取任意有界连续函数 <span class="math inline">\(f\inC_b(\mathbb{R}^d)\)</span>，令 <span class="math inline">\(f_R:=f\cdotg_R\in C_c(\mathbb{R}^d)\)</span>。注意到 <span class="math display">\[0\le 1-g_R\le \mathbb{1}_{\overline B_{R/2}^{c}},\quad |f-f_R|=|f|\cdot (1-g_R)\le \|f\|_\infty\cdot\mathbb{1}_{\overlineB_{R/2}^{c}}.\]</span> 因此对所有 <span class="math inline">\(n\)</span>有 <span class="math display">\[\left|\int (f-f_R)\,\mathrm d\mu_n\right|\le \|f\|_\infty\cdot\mu_n(\overline B_{R/2}^{c}),\quad\left|\int (f-f_R)\,\mathrm{d}\mu\right|\le \|f\|_\infty\cdot\mu(\overline B_{R/2}^{c}).\tag{1}\]</span></p><p>由上一部分已得的统一紧性 <span class="math inline">\(\displaystyle\lim_{R\to\infty}\inf_n\mu_n(\overline B_R)=1\)</span> 以及 <span class="math inline">\(\mu(\overline B_R)\uparrow 1\)</span>，给定 <span class="math inline">\(\varepsilon&gt;0\)</span>，可取 <span class="math inline">\(R\)</span> 使得 <span class="math display">\[\sup_n\mu_n(\overline B_{R/2}^{c})\le\varepsilon,\quad\mu(\overline B_{R/2}^{c})\le \varepsilon.\tag{2}\]</span> 代回 (1) 得到 <span class="math display">\[\sup_n\left|\int (f-f_R)\,\mathrmd\mu_n\right|\le \|f\|_\infty\varepsilon,\quad\left|\int (f-f_R)\,\mathrm{d}\mu\right|\le \|f\|_\infty \varepsilon.\tag{3}\]</span></p><p>另一方面，对这个固定的 <span class="math inline">\(R\)</span>，由假设在 <span class="math inline">\(C_c(\mathbb{R}^d)\)</span> 上的收敛有 <span class="math display">\[\int f_R\,\mathrm d\mu_n\to\intf_R\,\mathrm{d}\mu\quad (n\to\infty)\]</span> 故存在 <span class="math inline">\(N\)</span> 使得 <span class="math inline">\(n\geN\)</span> 时 <span class="math display">\[\left|\int f_R\,\mathrmd\mu_n-\int f_R\,\mathrm{d}\mu\right|\le \varepsilon.\tag{4}\]</span></p><p>现在分解 <span class="math display">\[\int f\,\mathrm d\mu_n-\intf\,\mathrm{d}\mu=\int (f-f_R)\,\mathrm d\mu_n + \left(\int f_R\,\mathrm d\mu_n-\intf_R\,\mathrm{d}\mu\right)+\int (f-f_R)\,\mathrm{d}\mu.\]</span></p><p>由 (3), (4) 得到当 <span class="math inline">\(n\ge N\)</span> 时<span class="math display">\[\left|\int f\,\mathrm d\mu_n-\intf\,\mathrm{d}\mu\right|\le 2\|f\|_\infty\varepsilon+\varepsilon.\]</span> 由于 <span class="math inline">\(\varepsilon&gt;0\)</span> 任意，便得 <span class="math display">\[\int f\,\mathrm d\mu_n\to\intf\,\mathrm{d}\mu\quad(n\to\infty).\]</span></p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论40.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{\mu_n\},\mu\)</span> 是 <span class="math inline">\(\mathbb{R}^d\)</span> 上的概率分部，则 <span class="math inline">\(\mu_n\to_w\mu\)</span> 当且仅当 <span class="math display">\[\int f\,\mathrm{d}\mu_n\to \intf\,\mathrm{d}\mu,\quad \forall f\inC_c^\infty(\mathbb{R}^d).\]</span></p></div><p>这里进一步把 <span class="math inline">\(f\)</span>加强成了具有紧支集且光滑的函数。</p><p>证明：任取一个光滑函数 <span class="math inline">\(\rho\)</span> 满足<span class="math inline">\(0\le \rho\le \mathbb{1}_{\overlineB_1}\)</span>。并归一化使得 <span class="math inline">\(\rho\)</span>是概率密度。</p><p>任取 <span class="math inline">\(\epsilon&gt;0\)</span>，<span class="math inline">\(f\in C_c(\mathbb{R}^d)\)</span>。令 <span class="math display">\[f_\epsilon(x) = \int_{\mathbb{R}^d}f(x+\epsilont)\rho(t)\,\mathrm{d}t=\frac{1}{\epsilon^d}\intf(y)\rho(\frac{y-x}{\epsilon})\,\mathrm{d}y.\]</span> 直观上，<span class="math inline">\(f_\epsilon\)</span> 就是 <span class="math inline">\(f\)</span> 在半径为 <span class="math inline">\(\epsilon\)</span> 邻域内，以 <span class="math inline">\(\rho\)</span> 为密度的平均值。显然 <span class="math inline">\(f_\epsilon\)</span> 是光滑且具有紧支集的函数且<span class="math display">\[\|f - f_\epsilon\|_\infty \to 0.\]</span>取 <span class="math inline">\(f_\delta\)</span> 满足 <span class="math inline">\(\|f - f_\delta\|_\infty&lt;\epsilon.\)</span>$<span class="math display">\[\int f\,\mathrm{d}\mu- \intf\,\mathrm{d}\mu_n = \int (f-f_\epsilon)\,\mathrm{d}\mu+ \intf_\epsilon\,\mathrm{d}\mu- \int f_\epsilon\,\mathrm{d}\mu_n+\int f_\epsilon-f\,\mathrm{d}\mu_n.\]</span> 第一项和第三项都不超过 <span class="math inline">\(\epsilon\)</span>，中间项可以通过取 <span class="math inline">\(n\)</span> 足够大使得也不超过 <span class="math inline">\(\epsilon\)</span>， 所以 <span class="math display">\[\left|\int f\,\mathrm{d}\mu- \intf\,\mathrm{d}\mu_n\right|\le 3\epsilon.\]</span> 由 <span class="math inline">\(\epsilon\)</span> 任意性即得。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>我们来证明 <span class="math inline">\(f_\varepsilon \tof\)</span> 是一致收敛的：</p><p>由于 <span class="math inline">\(f\in C_c(\mathbb{R}^d)\)</span>有界。设 <span class="math display">\[\|f\|_\infty:=\sup_{x\in\mathbb{R}^d}|f(x)|&lt;\infty.\]</span>（这是因为 <span class="math inline">\(\operatorname{supp} f\)</span>紧且 <span class="math inline">\(f\)</span>在紧集上连续，故取得最大值；在支集外 <span class="math inline">\(f=0\)</span>。）</p><p>于是对任意 <span class="math inline">\(h\in\mathbb{R}^d\)</span>与任意 <span class="math inline">\(x\)</span>, <span class="math display">\[|f(x+h)-f(x)|\le |f(x+h)|+|f(x)|\le2\|f\|_\infty.\]</span> 对 <span class="math inline">\(x\)</span>取上确界得到 <span class="math display">\[\|f(\cdot+h)-f(\cdot)\|_\infty\le2\|f\|_\infty.\]</span> 再对所有 <span class="math inline">\(|h|\ler\)</span> 取上确界，便有 <span class="math display">\[\omega_f(r):=\sup_{|h|\ler}\|f(\cdot+h)-f(\cdot)\|_\infty\le 2\|f\|_\infty&lt;\infty.\]</span></p><p>设 <span class="math inline">\(\rho\inC_c^\infty(\mathbb{R}^d)\)</span>，<span class="math inline">\(\rho\ge0\)</span>，<span class="math inline">\(\int \rho=1\)</span>，<span class="math inline">\(\mathrm{supp}\,\rho\subset\overline{B_1(0)}\)</span>。令 <span class="math display">\[\rho_\varepsilon(x)=\varepsilon^{-d}\rho(x/\varepsilon),\quadf_\varepsilon=f*\rho_\varepsilon.\]</span> 对任意 <span class="math inline">\(x\in\mathbb{R}^d\)</span>，<span class="math display">\[f_\varepsilon(x)-f(x)=\int_{\mathbb{R}^d}\rho_\varepsilon(y)\bigl(f(x-y)-f(x)\bigr)\,dy.\]</span> 因为 <span class="math inline">\(\mathrm{supp}\,\rho_\varepsilon\subset\overline{B_\varepsilon(0)}\)</span>，有 <span class="math display">\[|f_\varepsilon(x)-f(x)|\le \int \rho_\varepsilon(y)\,\sup_{|y|\le \varepsilon}|f(x-y)-f(x)|\,dy\le \omega_f(\varepsilon).\]</span></p><p>由于 <span class="math inline">\(f\in C_c(\mathbb{R}^d)\)</span>连续且支撑紧，<span class="math inline">\(f\)</span> 在 <span class="math inline">\(\mathbb{R}^d\)</span> 上一致连续，故 <span class="math inline">\(\omega_f(r)\to0\)</span> 当 <span class="math inline">\(r\to0\)</span>。于是 <span class="math display">\[\|f_\varepsilon-f\|_\infty \xrightarrow[\varepsilon\to0]{} 0,\]</span> 这正是一致收敛。</p></div><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理40.4</span>.</span><span class="statement-spah"> </span>当 <span class="math inline">\(\mathcal{S}=\mathbb{R}\)</span> 时，<span class="math inline">\(\mu_n\to_w\mu\)</span> 当且仅当 <span class="math display">\[F_n(t)=\mu_n((-\infty, t])\to \mu((-\infty, t]) =F(t),\quad \forall t, \text{ $F$ continous at $t$}.\]</span></p></div><p>证明：<span class="math inline">\(\Rightarrow\)</span> 由 Portmanteau定理即得。</p><p><span class="math inline">\(\Leftarrow\)</span>：设 <span class="math inline">\(f\in C_c(\mathbb{R})\)</span>是具有紧支集的连续函数，则 <span class="math inline">\(f\)</span>也是一致连续的。</p><p>设 <span class="math inline">\(\pi= \{x_0&lt;x_1&lt;\cdots&lt;x_k\}\)</span> 是 <span class="math inline">\(\mathop{\mathrm{supp}}f\)</span>的一个划分，满足：</p><ol type="1"><li><span class="math inline">\(x_j\)</span> 都是 <span class="math inline">\(F\)</span> 的连续点；</li><li><span class="math inline">\(|x_j-x_{j+1}|\leq\epsilon\)</span>；</li><li><span class="math inline">\(|f(x_j)-f(x_{j+1})|\leq\delta\)</span>。</li></ol><p>则 <span class="math inline">\(f_\pi = \sum_{j=1}^k\mathbb{1}_{(x_{j-1},x_j]}\)</span> 满足 <span class="math inline">\(\|f_\pi - f\|_\infty &lt; \epsilon\)</span>。 于是<span class="math display">\[\left|\int(f-f_\pi)\,\mathrm{d}\mu_n\right| \leq \epsilon.\]</span> <span class="math display">\[\left|\int (f-f_\pi)\,\mathrm{d}\mu\right| \leq\epsilon.\]</span> <span class="math display">\[\left|\intf_\pi\,\mathrm{d}\mu - \int f_\pi\,\mathrm{d}\mu\right|\le \epsilon\sum_{j=1}^k|F_n(x_j) - F(x_j)|\xrightarrow{x\to\infty}0.\]</span></p><h1 id="vague-convergence">✅ 23.1 Vague Convergence</h1><p>回忆弱收敛是指，一族概率测度 <span class="math inline">\(\{\mu_n\}\)</span> 收敛到一个概率测度 <span class="math inline">\(\mu\)</span>。如果这些测度都是 <span class="math inline">\(\mathbb{R}^d\)</span>上的，那么这等价于用连续有界函数 <span class="math inline">\(C_b(\mathbb{R}^d)\)</span>，或者连续紧支集函数<span class="math inline">\(C_c(\mathbb{R}^d)\)</span>，甚至光滑紧支集函数<span class="math inline">\(C_c^\infty(\mathbb{R}^d)\)</span>的积分检查的收敛。</p><p>如果我们不要求 <span class="math inline">\(\mu_n,\mu\)</span>是概率测度呢？只要求它们是 Borel 测度呢？</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义41.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mu_n,\mu\)</span> 是 <span class="math inline">\(\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d)\)</span>上的 Borel 测度。如果对任何 <span class="math inline">\(f\inC_c(\mathbb{R}^d)\)</span> 有 <span class="math display">\[\intf\,\mathrm{d}\mu_n\to \int f\,\mathrm{d}\mu.\]</span> 就称 <span class="math inline">\(\mu_n\)</span> vaguely 收敛到 <span class="math inline">\(\mu\)</span>。记作 <span class="math inline">\(\mu_n\to_v\mu\)</span>。</p></div><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义41.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{S}\)</span>是一个拓扑空间。其上的一族概率测度 <span class="math inline">\(\Lambda\)</span> 称作是 tight 的，如果对任意 <span class="math inline">\(\epsilon&gt;0\)</span>，都存在紧集 <span class="math inline">\(K_\epsilon\)</span> 使得 <span class="math inline">\(\mu_(K^c)&lt;\epsilon\)</span> 对任何 <span class="math inline">\(\mu\in\Lambda\)</span> 成立。</p></div><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理41.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{\mu_n\}\)</span> 是 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>上的概率测度，且 <span class="math inline">\(\mu_n\to_v \mu\)</span>。则<span class="math inline">\(\mu\)</span> 是概率测度当且仅当 <span class="math inline">\(\{\mu_n\}\)</span> 是 tight 的。这时 <span class="math inline">\(\mu_n\to_w\mu\)</span>。</p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>：如果 <span class="math inline">\(\mu\)</span> 是概率测度，则在 22.2的引理中我们证明了 <span class="math display">\[\lim_{R\uparrow\infty}\inf_n\mu_n(\overline B_R)= 1.\]</span> 由此即得结论。</p><p><span class="math inline">\(\Leftarrow\)</span>：给定 <span class="math inline">\(\epsilon &gt; 0\)</span>。取紧集 <span class="math inline">\(K_\epsilon\)</span> 使得 <span class="math inline">\(\mu_n(K_\epsilon)\ge1-\epsilon\)</span>。再取具有紧支集的<span class="math inline">\(f\in C_c(\mathbb{R}^d)\)</span> 满足 <span class="math inline">\(1_{K_\epsilon}\le f\le 1\)</span>。则 <span class="math display">\[\mu(\mathbb{R}^d)=\int 1\,\mathrm{d}\mu\ge \intf\,\mathrm{d}\mu=\lim_{n\to\infty}\intf\,\mathrm{d}\mu_n\ge\varliminf_{n\to\infty}\int1_{K_\epsilon}\,\mathrm{d}\mu_n=\varliminf_{n\to\infty}\mu_n(K_\epsilon)\ge1-\epsilon.\]</span> 由 <span class="math inline">\(\epsilon\)</span>任意性可得 <span class="math inline">\(\mu(\mathbb{R}^d)\ge1\)</span>。</p><p>另一方面，如果 <span class="math inline">\(\mu(\mathbb{R}^d) &gt;1\)</span> 的话，则我们可以取紧集 <span class="math inline">\(K=\overline B_R\)</span> 满足 <span class="math inline">\(\mu(K)&gt;1\)</span>。仍然取 <span class="math inline">\(f\in C_c(\mathbb{R}^d)\)</span> 满足 <span class="math inline">\(1 \ge f \ge \mathbb{1}_K\)</span>，则 <span class="math display">\[1=\mu_n(\mathbb{R}^d)=\int1\,\mathrm{d}\mu_n\ge\int f\,\mathrm{d}\mu_n\to \int f\,\mathrm{d}\mu\ge\mu(K)&gt;1.\]</span> 矛盾！<span class="math inline">\(\blacksquare\)</span></p><h1 id="prokhorovs-compactness-theorem">✅ 23.2 Prokhorov’s CompactnessTheorem</h1><div id="prokhorov-------------" class="statement sta_prokhorov_____ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Prokhorov 紧性定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{S}\)</span> 是可分度量空间，<span class="math inline">\(\{\mu_n\}\)</span> 是 <span class="math inline">\((\mathcal{S},\mathcal{B}(\mathcal{S}))\)</span>上的概率测度，则 <span class="math inline">\(\{\mu_n\}\)</span> 有vaguely 收敛的子序列。</p></div><p><strong>证明</strong>：将有理数 <span class="math inline">\(\mathbbQ\)</span> 排列为 <span class="math inline">\(\mathbb{Q}=\{q_1,q_2,\ldots\}\)</span>，并记 <span class="math inline">\(F_n=F_{\mu_n}\)</span>。</p><ul><li><span class="math inline">\(\{F_n(q_1)\}_{n=1}^\infty\)</span> 是<span class="math inline">\([0,1]\)</span>中的有界序列，所以存在收敛子序列 <span class="math inline">\(\{F_{m_1(k)}(q_1)\}_{k=1}^\infty\)</span>。</li><li><span class="math inline">\(\{F_{m_1(k)}(q_2)\}_{k=1}^\infty\)</span> 是 <span class="math inline">\([0,1]\)</span> 中的有界序列，所以存在收敛子序列<span class="math inline">\(\{F_{m_2(k)}(q_2)\}_{k=1}^\infty\)</span>。</li><li>…</li></ul><p>这样我们会得到一串子序列 <span class="math inline">\(\{m_j(k)\}\)</span> 使得 <span class="math inline">\(m_j(\cdot)\)</span> 是 <span class="math inline">\(m_{j-1}(\cdot)\)</span> 的子序列；并且 <span class="math display">\[F_{m_j(k)}(q_j)\to G(q_j).\]</span> 于是 <span class="math inline">\(F_{m_k(k)}(q) \to G(q)\)</span> 对所有 <span class="math inline">\(q\in\mathbb Q\)</span> 成立。</p><p>现在的 <span class="math inline">\(G\)</span> 只在 <span class="math inline">\(\mathbb Q\)</span> 上有定义。我们想把它变成一个<span class="math inline">\(\mathbb{R}\)</span> 上的分布函数。令</p><p><span class="math display">\[F(x) = \inf\,\{G(q)\mid q\in\mathbb{Q},\q &gt; x\}.\]</span> 显然 <span class="math inline">\(F\)</span>是递增的。我们来说明 <span class="math inline">\(F\)</span>也是右连续的：设 <span class="math inline">\(x_n\downarrowx\)</span>，则 <span class="math display">\[\begin{aligned}\lim_{n\to\infty}F(x_n)&amp;=\inf F(x_n)=\inf_n\inf\,\{G(q)\midq\in\mathbb{Q},\ q &gt; x_n\}\\&amp;=\inf\,\{G(q)\mid q\in\mathbb{Q}&gt;\text{ some }x_n\}\\&amp;=\inf\,\{G(q)\mid q\in\mathbb{Q}&gt; x\}\\&amp;=F(x).\end{aligned}.\]</span> 所以 <span class="math inline">\(F\)</span>确实是右连续的。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>我们使用了 <span class="math inline">\(\inf_n \inf S_n =\inf(\cup_{n=1}^\infty S_n)\)</span> 对任何集合族 <span class="math inline">\(\{S_n\}\)</span> 成立这一事实。</p></div><p>此外还有 <span class="math display">\[\lim_{x\to -\infty} F(x) =\inf\{G(q)\}\geq 0,\quad \lim_{x\to \infty} F(x) = \sup\{G(q)\}\leq1.\]</span> 所以 <span class="math inline">\(F\)</span>是一个次分布函数。它给出一个有限 Borel 测度。</p><p>要证明 <span class="math inline">\(\mu_{n_k}\to_v\mu\)</span>，只要证明对任何 <span class="math inline">\(F\)</span> 的连续点 <span class="math inline">\(x\)</span> 有 <span class="math display">\[F_{n_k}(x)\to F(x).\]</span> 即可。设有理数序列<span class="math inline">\(q_j\uparrow x,r_j\downarrow x\)</span>。由于<span class="math inline">\(F_{n_k}\)</span> 都是递增的，所以 <span class="math display">\[F_{n_k}(q_j)\le F_{n_k}(x) \le F_{n_k}(r_j),\quad\forall k, j.\]</span> 令 <span class="math inline">\(k\to\infty\)</span> 可得 <span class="math display">\[G(q_j)\leq \varliminf_k F_{n_k}(x)\le\varlimsup_k F_{n_k}(x)\le G(r_j).\]</span> 从而 <span class="math display">\[\sup_j G(q_j)\leq \varliminf_k F_{n_k}(x)\le\varlimsup_k F_{n_k}(x)\le \inf_j G(r_j).\]</span> 一方面右边 <span class="math inline">\(\inf_{r&gt;x}G(r)=F(x)\)</span>。</p><p>另一方面，对任意 <span class="math inline">\(q &lt; y &lt;x\)</span>，由 <span class="math display">\[G(q)\leq \inf_{s &gt; y}G(s) = F(y).\]</span> 对所有 <span class="math inline">\(q&lt;y\)</span>取上确界，再对所有 <span class="math inline">\(y&lt;x\)</span>取上确界，得 <span class="math display">\[\sup_{q&lt;x}G(q) =\sup_{y&lt;x}\sup_{q&lt;y}G(q)\le \sup_{y&lt;x}F(y) = F(x-).\]</span>由于 <span class="math inline">\(x\)</span> 是连续点可得 <span class="math inline">\(F(x)= \sup_{q&lt;x}G(q)=\sup_j G(q_j)\)</span>。于是 <span class="math inline">\(F(x) = \varliminf_k F_{n_k}(x)=\varlimsup_k F_{n_k}(x)\)</span>。</p><p>先对 <span class="math inline">\(\varphi\in C_c^1(\mathbbR)\)</span>。记 <span class="math inline">\(K=\operatorname{supp}\varphi\)</span> 紧。对每个<span class="math inline">\(k\)</span>, <span class="math display">\[\int \varphi\,\mathrm{d}\mu_{n_k}=\int_{(-\infty,\infty)} \varphi\,\mathrm{d}F_{n_k}=\Big[\varphi(x)F_{n_k}(x)\Big]_{-\infty}^{+\infty}-\int F_{n_k}(x)\varphi'(x)\,\mathrm{d}x= -\int_K F_{n_k}(x)\varphi'(x)\,\mathrm{d}x.\]</span> 同理 <span class="math display">\[\int \varphi\,\,\mathrm{d}\mu= -\int_KF(x)\varphi'(x)\,\mathrm{d}x.\]</span> 我们有 <span class="math inline">\(F_{n_k}(x)\to F(x)\)</span> 对 <span class="math inline">\(x\)</span> <strong>几乎处处</strong>成立，且 <span class="math inline">\(0\le F_{n_k}\le 1\)</span>。支配收敛给出 <span class="math display">\[\int\varphi\,\mathrm{d}\mu_{n_k}\to-\int_KF(x)\varphi'(x)\,\mathrm{d}x=\int\varphi\,\mathrm{d}\mu.\]</span></p><p>再用 <span class="math inline">\(C_c^1\)</span> 在 <span class="math inline">\(C_c\)</span> 上的一致稠密性：给定任意 <span class="math inline">\(\psi\in C_c(\mathbb R)\)</span> 与 <span class="math inline">\(\epsilon&gt;0\)</span>，可取 <span class="math inline">\(\varphi\in C_c^1\)</span> 使 <span class="math inline">\(\|\psi-\varphi\|_\infty&lt;\epsilon\)</span>。因为<span class="math inline">\(\mu_{n_k},\mu\)</span> 都是有限测度， <span class="math display">\[\left|\int \psi\,\mathrm d\mu_{n_k}-\int\psi\,\mathrm{d}\mu\right|\le \left|\int \varphi\,\mathrm{d}\mu_{n_k}-\int\varphi\,\mathrm{d}\mu\right|+ \epsilon\cdot(\mu_{n_k}(\mathbb R)+\mu(\mathbb R))  \le \left|\int \varphi\,\mathrm{d}\mu_{n_k}-\int\varphi\,\mathrm{d}\mu\right|+2\epsilon.\]</span> 令 <span class="math inline">\(k\to\infty\)</span> 后，再令 <span class="math inline">\(\epsilon\downarrow0\)</span> 即得 <span class="math inline">\(\mu_{n_k}\to_v\mu\)</span>。</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论42.1</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\{\mu_n\}\)</span> 还是 tight的，则存在弱收敛的子序列，其弱收敛的极限是一个概率测度 <span class="math inline">\(\mu\)</span>。</p></div><h1 id="skorohods-theorem">✅ 23.3 Skorohod’s Theorem</h1><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理43.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{S}\)</span> 是可分度量空间，<span class="math inline">\(\mu_n,\mu\)</span> 都是 <span class="math inline">\((\mathcal{S},\mathcal{B}(\mathcal{S}))\)</span>上的概率测度，如果 <span class="math inline">\(\mu_n\to_w\mu\)</span>，则存在概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\)</span>和随机变量 <span class="math inline">\(Y_n,Y:\Omega\to\mathcal{S}\)</span> 满足：</p><ol type="1"><li><span class="math inline">\(Y_n,Y\)</span> 的分布分别是 <span class="math inline">\(\mu_n,\mu\)</span>。</li><li><span class="math inline">\(Y_n\to Y\ \mathrm{a.e.}\)</span>。</li></ol></div><p>我们只在 <span class="math inline">\(\mathcal{S}=\mathbb{R}\)</span>的情形证明这个结论。</p><p><strong>Inverting the CDF</strong></p><p>设 <span class="math inline">\(F:\mathbb{R}\to [0,1]\)</span>是一个分布函数。<span class="math inline">\(F\)</span>未必是单射。我们来试着定义 <span class="math inline">\(F\)</span> 的逆<span class="math inline">\(F^\leftarrow\)</span>。这里的问题在于 <span class="math inline">\(F\)</span> 的平坦处（即 <span class="math inline">\(F\)</span> 在区间 <span class="math inline">\((a,b)\)</span> 上是常数），<span class="math inline">\(F^{-1}\)</span>是没有定义的。这时我们一律规定取区间的左端点 <span class="math inline">\(a\)</span> 作为 <span class="math inline">\(F^{-1}\)</span>：</p><p><span class="math display">\[F^\leftarrow(x)=\sup\{y\in\mathbb{R}\mid F(y)&lt;x\}.\]</span></p><p>直观上，就是取高度为 <span class="math inline">\(x\)</span>的水平横线与 <span class="math inline">\(F\)</span>的图像的第一个交点的横坐标。</p><p><span class="math inline">\(F^\leftarrow\)</span> 满足：</p><p><span class="math display">\[F^{\leftarrow}(u)\let\Longleftrightarrow  F(t)\ge u.\]</span></p><p>几何上这很显然：<span class="math inline">\(F(t)\ge u\)</span> 说明在<span class="math inline">\(t\)</span> 处，<span class="math inline">\(F\)</span> 的图像已经和高度为 <span class="math inline">\(u\)</span> 的水平线相交了，即交点横坐标必然在<span class="math inline">\(t\)</span> 或者 <span class="math inline">\(t\)</span> 的左侧，即 <span class="math inline">\(F^\leftarrow\le t\)</span>。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理43.2</span>.</span><span class="statement-spah"> </span>取 <span class="math inline">\(Y = F^\leftarrow\)</span>，则 <span class="math inline">\(Y\)</span> 的分布函数就是 <span class="math inline">\(F\)</span>。</p></div><p>证明： <span class="math display">\[\begin{aligned}\mathbb{P}(Y\le t)&amp;=\lambda(\{x\in(0,1): Y(x)\le t\})\\&amp;=\lambda(\{x\in(0,1): x\le F(t)\})\\&amp;=\lambda((0, F(t)])\\&amp;=F(t).\end{aligned}\]</span></p><p>回到 Skorohod 定理的证明。我们取 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})=((0,1),\mathcal{B}(0,1),\lambda)\)</span>。<span class="math inline">\(Y_n=F_n^\leftarrow\)</span>。<span class="math inline">\(Y=F^\leftarrow\)</span>。这样就解决了“存在随机变量的分布恰好是<span class="math inline">\(\mu_n\)</span> 和 <span class="math inline">\(\mu\)</span>” 这一步。我们再来证明 <span class="math inline">\(Y_n\)</span> 几乎处处收敛到 <span class="math inline">\(Y\)</span>。</p><p>记 <span class="math display">\[E = \{t\in(0,1)\mid F^\leftarrow(t)&lt; F^\to(t)\}.\]</span> 即 <span class="math inline">\(E\)</span> 是<span class="math inline">\(F\)</span>的图像中的那些“平坦”对应的高度值。则 <span class="math inline">\(E\)</span> 是可数集。 我们要证明 <span class="math inline">\(Y_n(x)\to Y(x)\)</span> 对任何 <span class="math inline">\(x\notin E\)</span> 成立。</p><ul><li><p>取一列 <span class="math inline">\(F\)</span> 的连续点 <span class="math inline">\(y_j\uparrow Y(x)\)</span>。弱收敛给出 <span class="math inline">\(F_n(y_j)\to F(y_j)\)</span> 对每个 <span class="math inline">\(j\)</span> 成立。由于 <span class="math display">\[y_j&lt;Y(x) = \sup\{u\mid F(u) &lt; x\}.\]</span>所以 <span class="math inline">\(F(y_j)&lt;x\)</span>。从而 <span class="math inline">\(F_n(y_j)&lt;x\)</span> 对充分大的 <span class="math inline">\(n\)</span> 成立。但这说明对这些充分大的 <span class="math inline">\(n\)</span> 也有 <span class="math display">\[Y_n(x) = \sup\{y\mid F_n(y) &lt; x\}\gey_j.\]</span> 于是 <span class="math display">\[\varliminf_n Y_n(x)\ge\sup_j y_j = Y(x).\]</span></p></li><li><p>取一列 <span class="math inline">\(F\)</span> 的连续点 <span class="math inline">\(y_j\downarrow Y(x)\)</span>。弱收敛给出 <span class="math inline">\(F_n(y_j)\to F(y_j)\)</span> 对每个 <span class="math inline">\(j\)</span> 成立。由于 <span class="math inline">\(x\in E\)</span>，所以 <span class="math display">\[y_j&gt;Y(x) = Y^\leftarrow(x) = Y^\to(x) =\inf\{u\mid F(u)&gt;x\}.\]</span> 所以 <span class="math inline">\(F(y_j)&gt;x\)</span>。从而 <span class="math inline">\(F_n(y_j)&gt;x\)</span> 对充分大的 <span class="math inline">\(n\)</span> 成立。但这说明对这些充分大的 <span class="math inline">\(n\)</span> 也有 <span class="math display">\[Y_n(x) = \sup\{y\mid F_n(y) &lt; x\}\ley_j.\]</span> 于是 <span class="math display">\[\varlimsup_n Y_n(x)\le\inf_j y_j = Y(x).\]</span></p></li></ul><h1 id="complex-integration-and-dynkins-theorem">✅ 24.1 ComplexIntegration and Dynkin’s Theorem</h1><p>这一节将 Dynkin 函数系引理推广到了复可测的函数上。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义44.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span>是一个可测空间，<span class="math inline">\(f:\Omega\to(\mathbb{C},\mathcal{B}(\mathbb{R}^2))\)</span>是一个可测函数。我们称 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(L^1\)</span> 可积的，当且仅当 <span class="math inline">\(f\)</span> 的实部和虚部都是 <span class="math inline">\(L^1\)</span> 可积的。</p></div><div id="-------------dynkin----------------" class="statement sta______dynkin______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">复版本的 Dynkin 函数系引理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathbb{H}\in\mathbb{B}(\Omega)\)</span> 是一个由<span class="math inline">\(\mathbb{C}\)</span>- 值有界可测函数组成的<span class="math inline">\(\mathbb{C}\)</span>- 向量空间，满足：</p><ul><li>包含 1</li><li>在有界收敛下封闭</li><li>对复共轭封闭</li></ul><p>又设 <span class="math inline">\(\mathbb{M}\subset\mathbb{H}\)</span>是一个乘法系，则 <span class="math inline">\(\mathbb{H}\)</span>包含所有关于 <span class="math inline">\(\sigma(\mathbb{M})\)</span>可测的有界函数。即</p><p><span class="math display">\[\mathbb{B}(\Omega,\sigma(\mathbb{M}))\subset\mathbb{H}.\]</span></p></div><p>证明：</p><p><strong>把生成集从乘法系扩到代数：</strong>令 <span class="math inline">\(\mathcal{A}\)</span> 为由 <span class="math inline">\(\mathbb{M}\)</span>生成的（复）<strong>代数</strong>。由于 <span class="math inline">\(\mathbb{M}\)</span> 乘法封闭，<span class="math inline">\(\mathcal{A}\subset\mathbb{H}\)</span>。显然 <span class="math inline">\(\sigma(\mathcal{A})=\sigma(\mathbb{M})\)</span>。</p><p>记 <span class="math display">\[\mathcal{L}:=\{f\in\mathbb{B}(\Omega,\sigma(\mathcal{A})):\f\in\mathbb{H}\}.\]</span> 则 <span class="math inline">\(\mathcal{L}\)</span> 是一个复向量空间，且：</p><ul><li><span class="math inline">\(1\in\mathcal{L}\)</span>（因 <span class="math inline">\(1\in\mathcal{A}\subset\mathbb{H}\)</span> 且 <span class="math inline">\(\sigma(\mathcal{A})\)</span>-可测）；</li><li><strong>有界收敛封闭：</strong>若 <span class="math inline">\(|f_n|\le C,\ f_n\to f\)</span> 点态，且 <span class="math inline">\(f_n\in\mathcal{L}\)</span>，则 <span class="math inline">\(f\)</span> 仍 <span class="math inline">\(\sigma(\mathcal{A})\)</span>-可测且 <span class="math inline">\(f\in\mathbb{H}\)</span>，故 <span class="math inline">\(f\in\mathcal{L}\)</span>；</li><li><strong>复共轭封闭：</strong>若 <span class="math inline">\(f\in\mathcal{L}\)</span>，则 <span class="math inline">\(\overline f\in\mathbb{H}\)</span>，且仍 <span class="math inline">\(\sigma(\mathcal{A})\)</span>-可测，因此 <span class="math inline">\(\overline f\in\mathcal{L}\)</span>。并且 <span class="math inline">\(\mathcal{A}\subset\mathcal{L}\)</span>。</li></ul><p>应用<strong>函数版单调类定理（实值）</strong>：</p><p><span class="math display">\[\mathcal{C}_{\mathbbR}:=\{\mathrm{Re}\,a,\ \Im a:\ a\in\mathcal{A}\}\\text{生成的实值代数}.\]</span> 上一段的说明保证 <span class="math inline">\(\mathcal{C}_{\mathbb R}\subset\mathcal{L}\)</span>（这里用到了<strong>共轭封闭</strong>来把 <span class="math inline">\(\mathrm{Re}\,a,\Im a\)</span> 放进 <span class="math inline">\(\mathbb{H}\)</span>，从而放进 <span class="math inline">\(\mathcal{L}\)</span>）。于是得到：所有<strong>有界实值</strong>、<span class="math inline">\(\sigma(\mathcal{A})\)</span>-可测的函数都在 <span class="math inline">\(\mathcal{L}\subset\mathbb{H}\)</span>。</p><p>任取有界复值 <span class="math inline">\(\sigma(\mathcal{A})\)</span>-可测 <span class="math inline">\(f\)</span>。写 <span class="math inline">\(f=u+iv\)</span>（(u,v) 。由第 2 步 <span class="math inline">\(u,v\in\mathcal{L}\subset\mathbb{H}\)</span>。因<span class="math inline">\(\mathbb{H}\)</span> 为复向量空间，<span class="math inline">\(f=u+iv\in\mathbb{H}\)</span>。 结合 <span class="math inline">\(\sigma(\mathcal{A})=\sigma(\mathbb{M})\)</span>，即得<span class="math inline">\(\mathbb{B}(\Omega,\sigma(\mathbb{M}))\subset\mathbb{H}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><h1 id="characteristic-function">✅ 24.2 Characteristic Function</h1><p>本讲介绍了随机变量的特征函数及其基本性质。整体内容比较基础。</p><h1 id="the-riemann-lebesgue-lemma">✅ 25.1 The Riemann-Lebesguelemma</h1><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理46.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(f\in L^1(\mathbb{R}^n)\)</span>，则其特征函数<span class="math display">\[\varphi(t) = \int_{\mathbb{R}^n}e^{it\cdotx}f(x)\,\,\mathrm{d}x.\]</span> 满足 <span class="math display">\[\lim_{t\to\infty}\varphi(t) = 0.\]</span></p></div><p><strong>证明</strong>：首先，我们假设 <span class="math inline">\(f\)</span>无穷次可微，并且具有紧支集。由分部积分，我们得到</p><p><span class="math display">\[it_j\varphi(t) =\int_{\mathbb{R}^n}\underbrace{it_je^{it\cdot x}}_{\frac{\partialx}{\partial x_j}e^{it\cdotx}}f(x)\,\,\mathrm{d}x=-\int_{\mathbb{R}^n}e^{it\cdot x}\frac{\partialx}{\partial x_j}f(x)\,\,\mathrm{d}x.\]</span> 两边取绝对值，我们有 <span class="math display">\[|t_j\varphi(t)|\leq\int_{\mathbb{R}^n}\left|\frac{\partial x}{\partialx_j}f(x)\right|\,\,\mathrm{d}x=M_j&lt;\infty.\]</span> 于是 <span class="math display">\[|t|\cdot |\varphi(t)|\leq\sqrt{M_1^2+\cdots+M_n^2} &lt; \infty.\]</span> 所以在 <span class="math inline">\(f\)</span> 光滑且紧支集的情形，我们得到 <span class="math inline">\(\varphi(t)=O(|t|^{-1})\)</span>。</p><p>对一般的 <span class="math inline">\(L^1\)</span> 型 <span class="math inline">\(f\)</span>，我们用一个具有紧支集的光滑函数来逼近<span class="math inline">\(f\)</span>。首先 <span class="math display">\[f\mathbb{1}_{\overline{B}_R}\to f \text{ in }L^1\text{ as }R\to\infty.\]</span> 所以我们可以假设 <span class="math inline">\(\mathrm{supp}(f)\subset\overline{B}_R\)</span>。令 <span class="math display">\[\mathbb{H}=\{h\in\mathbb{B}(\overline{B}_R)\mid \exists\{g_n}\xrightarrow{L^1}h\text{ with }g_n\inC^\infty(\overline{B}_R)\}.\]</span> 则</p><ul><li><span class="math inline">\(1\in\mathbb{H}\)</span>；因为我们可以取类似“钟形”的光滑函数<span class="math inline">\(g_n\in C^\infty(\overline{B}_R)\)</span>使得 <span class="math inline">\(g_n\)</span> 在缩小一点的闭球 <span class="math inline">\(\overline{B}_{R-1/n}\)</span> 上恒为 1。</li><li><span class="math inline">\(\mathbb{H}\)</span>在有界收敛下封闭；因为如果 <span class="math inline">\(h_n\toh\)</span>，则根据控制收敛定理，<span class="math inline">\(|h_n-h|_1\to0\)</span>。由于 <span class="math inline">\(h_n\in\mathbb{H}\)</span>，设 <span class="math inline">\(g_n\in C^\infty(\overline{B}_R)\)</span> 满足<span class="math inline">\(|h_n-g_n|_1&lt;1/n\)</span>，则由三角不等式有 <span class="math display">\[|h-g_n|\leq 1/n +||h_n-g_n|_1\to 0.\]</span> 记 <span class="math inline">\(\mathbb{M}=C^\infty_c(\mathbb{R}^n)\)</span>是全体具有紧支集的光滑函数组成的集合，则 <span class="math inline">\(\mathbb{M}\)</span> 是乘法系，且 <span class="math inline">\(\mathbb{M}\subset \mathbb{H}\)</span>。于是 <span class="math inline">\(\mathbb{B}(\overline{B}_R,\sigma(\mathbb{M}))\subset\mathbb{H}\)</span>。但是<span class="math inline">\(\sigma(\mathbb{M})=\mathcal{B}(\mathbb{R}^n)\)</span>，所以所有在<span class="math inline">\(\overline{B}_R\)</span> 上有界，且 Borel可测的函数都在 <span class="math inline">\(\mathbb{H}\)</span> 中。</li></ul><p>最后，取 <span class="math inline">\(g\inC^\infty_c(\mathbb{R}^n)\)</span> 满足 <span class="math inline">\(|f-g|_1&lt;\epsilon\)</span>。则 <span class="math display">\[|\varphi(t) - \hat{g}(t)|\leq |f-g|_1 &lt;\epsilon.\]</span> 而我们已经证明了 <span class="math inline">\(|\hat{g}|=O(1/t)\)</span>，所以我们可以取 <span class="math inline">\(R&gt;0\)</span> 使得 <span class="math inline">\(|t|&gt;R\)</span> 时有 <span class="math inline">\(|\hat{g}|&lt;\epsilon\)</span>。从而 <span class="math inline">\(|t|&gt;R\)</span> 时有 <span class="math display">\[|\varphi(t)| &lt; |\hat{g}(t)|+\epsilon &lt;2\epsilon.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>证明中，我们不加证明使用了两个结论：</p><ol type="1"><li>光滑函数 <span class="math inline">\(g_n\)</span> 的存在性；</li><li><span class="math inline">\(\sigma(\mathbb{M})=\mathcal{B}(\mathbb{R}^n)\)</span>。</li></ol><p>这两点原因如下：任意 <span class="math inline">\(\mathbb{R}^n\)</span>中的开球都能写成某个紧支撑光滑函数的开阈值原像。给定中心 <span class="math inline">\(a\in\mathbb{R}^n\)</span> 和半径 <span class="math inline">\(r&gt;0\)</span>，定义标准“钟形”函数 <span class="math display">\[\phi_{a,r}(x)=\begin{cases}\exp\Bigl(-\dfrac{1}{1-\frac{|x-a|^2}{r^2}}\Bigr), &amp; |x-a|&lt;r,\\0,&amp; |x-a|\ge r.\end{cases}\]</span> 则 <span class="math inline">\(\phi_{a,r}\inC_c^\infty(\mathbb{R}^n)\)</span>，并且 <span class="math display">\[\phi_{a,r}^{-1}((0,+\infty))=\{x\in\mathbb{R}^n\mid\phi_{a,r}(x)&gt;0\}=B(a,r)\]</span>。因此每个开球<span class="math inline">\(B(a,r)\)</span> 都属于 <span class="math inline">\(\sigma(\mathbb{M})\)</span>。</p></div><h1 id="fourier-inversion">✅ 25.2 Fourier inversion</h1><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理47.1</span>.</span><span class="statement-spah"> </span>对 <span class="math inline">\(\xi\geq0\)</span>，定义函数 <span class="math display">\[S(\xi) =\int_{-r}^r\frac{\sin\xi}{\xi}\,\mathrm{d}\xi.\]</span> 则 <span class="math inline">\(S(\xi)\)</span> 是 <span class="math inline">\([0,+\infty)\)</span> 上的连续函数，并且 <span class="math display">\[\lim_{\xi\to\infty}S(\xi) = \pi.\]</span></p></div><p><strong>证明</strong>：由于被积函数 <span class="math inline">\(\frac{\sin\xi}{\xi}\)</span> 在 <span class="math inline">\(\mathbb{R}\)</span>上连续。由微积分基本定理，连续函数的变上限积分是连续的，故 <span class="math inline">\(S\)</span> 在 <span class="math inline">\([0,\infty)\)</span> 上连续。</p><p>对 <span class="math inline">\(a&gt;0\)</span> 定义 <span class="math display">\[F(a)=\int_0^\infty e^{-ax}\frac{\sinx}{x}\,\mathrm{d}x.\]</span></p><p>可以在积分号下求导，得到 <span class="math display">\[F'(a)=-\int_0^\infty e^{-ax}\sinx\,\mathrm{d}x=-\frac{1}{1+a^2}.\]</span> 故 <span class="math display">\[F(a)=C-\arctan a.\]</span> 当 <span class="math inline">\(a\to+\infty\)</span> 时，<span class="math inline">\(e^{-ax}\)</span> 强衰减，<span class="math inline">\(F(a)\to 0\)</span>，而 <span class="math inline">\(\arctan a\to \frac{\pi}{2}\)</span>，故 <span class="math inline">\(C=\frac{\pi}{2}\)</span>。于是 <span class="math display">\[F(a)=\frac{\pi}{2}-\arctana=\arctan\frac{1}{a}.\]</span> 令 <span class="math inline">\(a\downarrow 0\)</span> 即得结论。<span class="math inline">\(\blacksquare\)</span></p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理47.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\((\mathbb{R},\mathcal{B}(\mathbb{R}))\)</span>上的概率测度，则对任何 <span class="math inline">\(a&lt;b\in\mathbb{R}\)</span> 有 <span class="math display">\[\mu((a,b)) + \frac{1}{2}\mu(\{a,b\}) =\lim_{R\to\infty}\frac{1}{2\pi}\int_{-R}^R\frac{e^{-ia\xi}-e^{-ib\xi}}{i\xi}\hat{\mu}(\xi)\,\mathrm{d}\xi.\]</span></p></div><p><strong>证明</strong>： <span class="math display">\[\begin{aligned}I(R) &amp;=\frac{1}{2\pi}\int_{-R}^R\frac{e^{-ia\xi}-e^{-ib\xi}}{i\xi}\hat{\mu}(\xi)\,\mathrm{d}\xi\\&amp;=\frac{1}{2\pi}\int_{-R}^R \frac{e^{-ia\xi}-e^{-ib\xi}}{i\xi}\,\mathrm{d}\xi\int_\mathbb{R}e^{i\xi x}\mu(\mathrm{d}x) \\&amp;=\frac{1}{2\pi}\int_\mathbb{R}e^{i\xi x} \mu(\mathrm{d}x)\int_{-R}^R \frac{e^{-ia\xi}-e^{-ib\xi}}{i\xi} \,\mathrm{d}\xi\\&amp;=\frac{1}{2\pi}\int_\mathbb{R}\mu(\mathrm{d}x) \int_{-R}^R\frac{e^{i\xi(x-a)}-e^{i\xi(x-b)}}{i\xi} \,\mathrm{d}\xi\\&amp;=\frac{1}{2\pi}\int_\mathbb{R}\mu(\mathrm{d}x) \int_{-R}^R\frac{\sin\xi(x-a)-\sin\xi(x-b)}{\xi} \,\mathrm{d}\xi.\end{aligned}\]</span> 这里我们可以使用 Fubini 定理交换关于 <span class="math inline">\(\xi\)</span> 和 <span class="math inline">\(x\)</span> 的积分顺序是因为 <span class="math display">\[F(x,\xi)=e^{i\xix}\frac{e^{-ia\xi}-e^{-ib\xi}}{i\xi}\mathbb{1}_{[-R,R]}(\xi).\]</span>满足 <span class="math display">\[|F(x,\xi)|\le|a-b|\mathbb{1}_{[-R,R]}(\xi).\]</span> 从而 <span class="math display">\[\int_{\mathbb{R}}\int_{\mathbb{R}}|F(x,\xi)|\,\mathrm{d}\mu\,\mathrm{d}\xi\leq\int_{\mathbb{R}}\int_{\mathbb{R}}|a-b|\mathbb{1}_{[-R,R]}(\xi)\,\mathrm{d}\mu\,\mathrm{d}\xi=|a-b|\cdot \mu(\mathbb{R})\cdot (2R)&lt;\infty.\]</span></p><p>然后注意到 <span class="math display">\[\begin{aligned}\int_{-R}^R\frac{\sin\xi(x-a)}{\xi}\,\mathrm{d}\xi&amp;=\int_{-R(x-a)}^{R(x-a)}\frac{\sin\eta}{\eta}\,\mathrm{d}\eta=\begin{cases}S(R(x-a)), &amp; x-a &gt; 0,\\-S(R(a-x)), &amp; x - a &lt; 0.\end{cases} \\&amp;= \mathrm{sgn}(x-a)S(R|x-a|).\end{aligned}\]</span> 所以 <span class="math display">\[I(R)=\frac{1}{2\pi}\int_\mathbb{R}\big[\mathrm{sgn}(x-a)S(R|x-a|)-\mathrm{sgn}(x-b)S(R|x-b|)\big]\mu(\mathrm{d}x).\]</span>现在，被积函数是有界的（不超过 <span class="math inline">\(S(r)\)</span>在 <span class="math inline">\([0,+\infty)\)</span> 上的上界 x2），所以可以用控制收敛定理得到 <span class="math display">\[\lim_{R\to\infty}I(R)=\frac{1}{2}\int_\mathbb{R}[\mathrm{sgn}(x-a)-\mathrm{sgn}(x-b)]\mu(\mathrm{d}x).\]</span>注意到现在的被积函数满足 <span class="math display">\[\mathrm{sgn}(x-a)-\mathrm{sgn}(x-b)=\begin{cases}0, &amp; x &gt; b \text{ or } x &lt; a,\\1, &amp; x = a \text{ or } x = b,\\2, &amp; a &lt; x &lt; b.\end{cases}.\]</span> 所以 <span class="math display">\[\lim_{R\to\infty}I(R) = \frac{1}{2}\mu(\{a,b\}) +\mu((a,b)).\]</span> <span class="math inline">\(\blacksquare\)</span></p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论47.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mu\)</span> 是 <span class="math inline">\((\mathbb{R},\mathcal{B}(\mathbb{R}))\)</span>上的概率测度，<span class="math inline">\(\hat{\mu}\)</span> 是关于Legesgue <span class="math inline">\(L^1\)</span> 的，则其有密度函数<span class="math inline">\(\rho\)</span>，满足 <span class="math display">\[\rho(x)=\frac{1}{2\pi}\int_\mathbb{R}e^{-itx}\hat{\mu}(t)\,\mathrm{d}t.\]</span></p></div><p><strong>证明</strong>：令 <span class="math inline">\(\rho\)</span>如上定义，则 <span class="math display">\[\begin{aligned}\int_a^b\rho(x)\,\mathrm{d}x&amp;=\frac{1}{2\pi}\int_a^b\,\mathrm{d}x\int_\mathbb{R}\hat{\mu}(\xi)e^{-i\xix}\,\mathrm{d}\xi\\&amp;=\frac{1}{2\pi}\int_\mathbb{R}\hat{\mu}(\xi)\,\mathrm{d}\xi\int_a^be^{-i\xi x}\,\mathrm{d}x\\&amp;=\frac{1}{2\pi}\int_\mathbb{R}\hat{\mu}(\xi)\frac{e^{-ia\xi}-e^{-ib\xi}}{i\xi}\,\mathrm{d}\xi\\&amp;=\lim_{R\to\infty} I(R)\\&amp;=\mu((a,b)) + \frac{\mu(\{a,b\})}{2}.\end{aligned}\]</span> <span class="math inline">\(\blacksquare\)</span></p><h1 id="the-continuity-theorem">✅ 25.3 The Continuity Theorem</h1><p>本讲介绍了测度弱收敛的连续性定理。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理48.1</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\{\mu_n\}_{n=1}^\infty\)</span> 是一列 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>上的概率测度。假设极限 <span class="math inline">\(\varphi(t) =\lim\limits_{n\to\infty}\hat{\mu_n}\)</span> 存在，并且 <span class="math inline">\(\varphi(t)\)</span> 在 <span class="math inline">\(t=0\)</span> 处连续，则存在概率测度 <span class="math inline">\(\mu\)</span> 使得 <span class="math inline">\(\hat{\mu}=\varphi\)</span>，并且 <span class="math inline">\(\mu_n\rightarrow_{w}\mu\)</span>。</p></div><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理48.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mu,\nu\)</span> 是 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>上的两个概率测度，<span class="math inline">\(K&gt;0\)</span>是任意正实数，则 <span class="math display">\[\int_{\mathbb{R}^d}\hat{\mu}(Kx)\nu(\mathrm{d}x)=\int_{\mathbb{R}^d}\hat{\nu}(Ky)\mu(\mathrm{d}y).\]</span></p></div><p><strong>证明</strong>：要证明的是 <span class="math display">\[\int_{\mathbb{R}^d}\nu(\mathrm{d}x)\int_{\mathbb{R}^d}e^{iKx\cdot\xi}\mu(\mathrm{d}\xi)=\int_{\mathbb{R}^d}\mu(\mathrm{d}y)\int_{\mathbb{R}^d}e^{iKy\cdot\xi}\nu(\mathrm{d}\xi).\]</span> 直接 Fubini 即可。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理48.3</span>.</span><span class="statement-spah"> </span><span class="math display">\[\int_{\mathbb{R}^d}[1-\mathrm{Re}\,\hat{\mu}(Kx)]\nu(\mathrm{d}x)=\int_{\mathbb{R}^d}[1-\mathrm{Re}\,\hat{\nu}(Ky)]\mu(\mathrm{d}x).\]</span></p></div><p><strong>证明</strong>：在前一个引理中两边取实部，然后被 1减去即可。</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论48.4</span>.</span><span class="statement-spah"> </span>假设 <span class="math inline">\(\rho\)</span> 是一个 <span class="math inline">\(\mathbb{R}^d\)</span>上的概率密度，其支集位于闭的单位球 <span class="math inline">\(\bar{B}_1\)</span> 内。设 <span class="math inline">\(M&gt;0\)</span> 使得 <span class="math inline">\(|\hat{\rho}(t)|\leq1/2\)</span> 对任何 <span class="math inline">\(|t|\geq M\)</span> 成立，则对任何 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>上的概率测度 <span class="math inline">\(\mu\)</span> 和正数 <span class="math inline">\(\alpha&gt;0\)</span> 有 <span class="math display">\[\mu\{x\in\mathbb{R}^d:\ |x|\geq\alpha\}\leq2\int_{\bar{B}_1}\left[1-\mathrm{Re}\,\hat{\mu}\left(\frac{M}{\alpha}x\right)\right]\rho(x)\,\mathrm{d}x.\]</span></p></div><p><strong>证明</strong>：设 <span class="math display">\[\hat{\mu}(t)=\int_{\mathbb{R}^d}e^{it\cdotx}\mu(\mathrm{d}x),\quad \hat{\rho}(t)=\int_{\mathbb{R}^d}e^{it\cdotx}\rho(x)\,\mathrm{d}x.\]</span> 令 <span class="math inline">\(K=\frac{M}{\alpha}\)</span>，由于 <span class="math inline">\(\rho\)</span> 的支集包含在 <span class="math inline">\(\bar B_1\)</span> 中，所以 <span class="math display">\[2\int_{\barB_1}\bigl[1-\mathrm{Re}\,\hat{\mu}(Kx)\bigr]\rho(x)\,\mathrm{d}x=2\int_{\mathbb{R}^d}\bigl[1-\mathrm{Re}\,\hat{\rho}(Ky)\bigr]\mu(\mathrm{d}y).\]</span>由假设，当 <span class="math inline">\(|y|\ge\alpha\)</span> 时有 <span class="math inline">\(|K y|=\frac{M}{\alpha} |y|\ge M\)</span>，从而<span class="math display">\[1-\mathrm{Re}\,\hat{\rho}(Ky)\ge1-|\hat{\rho}(K y)|\ge\frac{1}{2}.\]</span> 故 <span class="math inline">\(|y|\ge\alpha\)</span> 时有 <span class="math display">\[2\bigl(1-\mathrm{Re}\,\hat{\rho}(K y)\bigr)\ge\mathbb{1}_{\{|y|\ge\alpha\}}(y).\]</span> 这个式子对 <span class="math inline">\(|y|&lt;\alpha\)</span> 也成立，所以同时对 <span class="math inline">\(\mu\)</span> 积分得到 <span class="math display">\[2\int_{\mathbb{R}^d}\bigl[1-\mathrm{Re}\,\hat{\rho}(Ky)\bigr]\mu(\mathrm{d}y)\ge\int_{\mathbb{R}^d}\mathbb{1}_{\{|y|\ge\alpha\}}\mu(\mathrm{d}y)=\mu(\{|y|\ge\alpha\}).\]</span>把左边换回原式即得 <span class="math display">\[\mu(\{|x|\ge\alpha\})\le2\int_{\barB_1}\left[1-\mathrm{Re}\,\hat{\mu}\left(\tfrac M\alphax\right)\right]\rho(x)\,\mathrm{d}x.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论48.5</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{\mu_n\}_{n=1}^\infty\)</span> 是 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>上的概率测度，且 <span class="math inline">\(\varphi(t)=\lim\limits_{n\to\infty}\hat{\mu}_n(t)\)</span>处处存在，并且 <span class="math inline">\(\varphi\)</span> 在 <span class="math inline">\(t=0\)</span> 处连续。则 <span class="math inline">\(\{\mu_n\}_{n=1}^\infty\)</span> 是 tight 的。</p></div><p><strong>证明</strong>：记 <span class="math display">\[I_n(\alpha)=2\int_{\barB_1}\bigl[1-\mathrm{Re}\,\hat{\mu}_n(\tfrac M\alphax)\bigr]\rho(x)\,\mathrm{d}x.\]</span></p><p>由于 <span class="math inline">\(|1-\mathrm{Re}\,\hat{\mu}_n|\le2\)</span> 且 <span class="math inline">\(\rho\)</span>为概率密度，故由控制收敛定理 <span class="math display">\[\lim_{n\to\infty}I_n(\alpha)=I(\alpha)=2\int_{\barB_1}\bigl[1-\mathrm{Re}\,\varphi(\tfrac M\alphax)\bigr]\rho(x)\,\mathrm{d}x.\]</span></p><p>由于 <span class="math inline">\(\varphi\)</span> 在 <span class="math inline">\(0\)</span> 处连续且对每个 <span class="math inline">\(x\)</span> 有 <span class="math inline">\(\tfracM\alpha x\to 0\)</span>，仍由控制收敛定理得 <span class="math display">\[I(\alpha)\xrightarrow{\alpha\to\infty}0.\]</span></p><p>给定 <span class="math inline">\(\epsilon&gt;0\)</span>。取 <span class="math inline">\(\alpha_1\)</span> 使得 <span class="math inline">\(I(\alpha_1)\le\epsilon/2\)</span>。再取 <span class="math inline">\(N\)</span> 使得对所有 <span class="math inline">\(n\ge N\)</span> 有 <span class="math display">\[I_n(\alpha_1)\le I(\alpha_1)+\epsilon/2\le\epsilon.\]</span></p><p>从而 <span class="math inline">\(\mu_n(\{|x|\ge \alpha_1\})\leI_n(\alpha_1)\le\epsilon\)</span> 对所有 <span class="math inline">\(n\ge N\)</span> 成立。</p><p>对那些 <span class="math inline">\(n&lt;N\)</span>，由于 <span class="math inline">\(\hat{\mu}_n\)</span> 作为特征函数在 0处连续，<span class="math inline">\(\alpha\to\infty\)</span> 时 <span class="math inline">\(I_n(\alpha)\to 0\)</span>，因此可取 <span class="math inline">\(\alpha_0\)</span> 使 <span class="math display">\[\max_{1\le n&lt;N}\mu_n(\{|x|\ge \alpha_0\})\le\max_{1\le n&lt;N} I_n(\alpha_0)\le\epsilon.\]</span></p><p>令 <span class="math inline">\(R=\max\{\alpha_0,\alpha_1\}\)</span>。则</p><ul><li>若 <span class="math inline">\(n\ge N\)</span>，则 <span class="math inline">\(\mu_n(\{|x|\ge R\})\le \mu_n(\{|x|\ge\alpha_1\})\le\epsilon\)</span>；</li><li>若 <span class="math inline">\(n&lt; N\)</span>，同理 <span class="math inline">\(\mu_n(\{|x|\ge R\})\le \mu_n(\{|x|\ge\alpha_0\})\le\epsilon\)</span>。</li></ul><p>于是 <span class="math display">\[\sup_{n\ge1}\mu_n(\{|x|\geR\})\le\epsilon.\]</span> 这正是 tightness 的定义。<span class="math inline">\(\blacksquare\)</span></p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论48.6</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{\mu_n\}_{n=1}^\infty\)</span> 是 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>上的概率测度，且 <span class="math inline">\(\varphi(t)=\lim\limits_{n\to\infty}\hat{\mu}_n(t)\)</span>处处存在，并且 <span class="math inline">\(\varphi\)</span> 在 <span class="math inline">\(t=0\)</span> 处连续。则存在概率测度 <span class="math inline">\(\mu\)</span> 使得 <span class="math inline">\(\varphi=\hat{\mu}\)</span> 并且 <span class="math inline">\(\mu_n\to_w \mu\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(\{\mu_n\}\)</span> 是 tight 的，根据Prokhorov，存在子序列 <span class="math inline">\(\{\mu_{n_k}\}\)</span>弱收敛到某个概率测度 <span class="math inline">\(\mu_{n_k}\to_w\mu\)</span>。于是 <span class="math display">\[\varphi=\lim_{k\to\infty}\hat\mu_{n_k}=\hat{\mu}.\]</span> 从而对整个序列也有 <span class="math display">\[\varphi=\lim_{n\to\infty}\hat\mu_{n}=\hat{\mu}.\]</span> 这样我们就证明了 <span class="math inline">\(\varphi=\hat\mu\)</span> 是概率测度 <span class="math inline">\(\mu\)</span> 的 Fourier 变换。</p><p>我们断言整个 <span class="math inline">\(\{\mu_n\}\)</span>都弱收敛到 <span class="math inline">\(\mu\)</span>。若不然，存在有界连续函数 <span class="math inline">\(g\)</span> 使得 <span class="math display">\[\int_{\mathbb{R}^d} g \,\mathrm{d}\mu_n\nrightarrow \int_{\mathbb{R}^d} g \,\mathrm{d}\mu.\]</span> 于是对任何<span class="math inline">\(\epsilon&gt;0\)</span>，存在子序列 <span class="math inline">\(\{\mu_{n_k'}\}\)</span> 使得 <span class="math display">\[\left|\int_{\mathbb{R}^d} g \,\mathrm{d}\mu_n -\int_{\mathbb{R}^d} g \,\mathrm{d}\mu\right|\ge\epsilon,\quad \forallk.\]</span> 但是 <span class="math inline">\(\{\mu_{n_k'}\}\)</span>也是 tight 的，所以再用一次 Prokhorov 定理，存在二级子序列 <span class="math inline">\(\{\mu_{n_k''}\}\subset\{\mu_{n_k'}\}\)</span>使得 <span class="math inline">\(\mu_{n_k''}\to_w\nu\)</span>。于是 <span class="math inline">\(\hat\mu_{n_k''}\to\hat\nu\)</span>。我们上面已经证明了 <span class="math inline">\(\hat\mu_{n_k''}\to\hat\mu\)</span>，从而<span class="math inline">\(\hat\mu=\hat\nu\)</span>，由 Fourierinversion 有 <span class="math inline">\(\mu=\nu\)</span>。即 <span class="math inline">\(\mu_{n_k''}\to_w\mu\)</span>。矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 id="central-limit-theorem">✅ 26.1 Central Limit Theorem</h1><div id="basic-central-limit-theorem" class="statement sta_basic_central_limit_theorem plain unnumbered"><p><span class="statement-heading"><span class="statement-label">BasicCentral Limit Theorem</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(\{X_n\}_{n=1}^\infty\)</span> 是i.i.d 的 <span class="math inline">\(L^2\)</span>随机变量，具有共同的期望 <span class="math inline">\(\mathbb{E}[X_n]=a\)</span> 和 <span class="math inline">\(\mathrm{Var}[X_n]=\sigma^2\)</span>。则 <span class="math display">\[\frac{S_n-na}{\sigma\sqrt{n}}\to_w\mathcal{N}(0,1).\]</span></p></div><p><strong>证明</strong>：记 <span class="math inline">\(Z_n =\frac{S_n-na}{\sigma\sqrt{n}}\)</span>。我们只要证明特征函数的收敛 <span class="math display">\[\varphi_{Z_n}(t) \to e^{-t^2/2},\quad \forallt\in\mathbb{R}.\]</span> 那么根据 Levy 连续性定理：</p><ul><li>若一列特征函数 <span class="math inline">\(\varphi_{Z_n}\)</span>对每个 <span class="math inline">\(t\)</span> 都有极限 <span class="math inline">\(\varphi(t)\)</span>，且 <span class="math inline">\(\varphi\)</span> 在 <span class="math inline">\(t=0\)</span> 处连续，那么</li><li><span class="math inline">\(\varphi\)</span>本身就是某个概率分布的特征函数；</li><li><span class="math inline">\(Z_n\)</span>的分布按弱收敛收敛到这个分布。</li></ul><p>就得到 <span class="math inline">\(Z_n\to_w\mathcal{N}(0,1)\)</span>，因为 <span class="math inline">\(e^{-t^2/2}\)</span> 显然在 0处连续，且它就是标准正态的特征函数。</p><p>记 <span class="math inline">\(Y_1=X_1-a\)</span>，则 <span class="math inline">\(\mathbb{E}Y_1=0\)</span> 且 <span class="math inline">\(\mathbb{E}Y_1^2 =\sigma^2&lt;\infty\)</span>，所以 <span class="math inline">\(Y_1\)</span> 的特征函数 <span class="math inline">\(\varphi(t)\)</span> 是 <span class="math inline">\(C^2\)</span> 的。根据 Taylor 展开， <span class="math display">\[\varphi(t) = \varphi(0)+\varphi'(0)t +\frac{1}{2}\varphi''(r(t))t^2,\quad 0&lt;r(t)&lt;t.\]</span>注意到 <span class="math display">\[\varphi'(0) = \mathbb{E}[iY_1e^{itY_1}]\Big|_{t=0}=i\mathbb{E}Y_1 = 0.\]</span> 所以 <span class="math display">\[\varphi(t) =\varphi(0)+\frac{1}{2}\varphi''(r(t))t^2,\quad0&lt;r(t)&lt;t.\]</span> 利用 <span class="math display">\[\lim_{t\to0}\varphi''(r(t))=\varphi''(0)=-\mathbb{E}Y_1^2 =-\sigma^2.\]</span> 以及熟知的微积分结论 <span class="math display">\[\lim_{n\to\infty}\left(1+ \frac{c_n}{n}\right)^n=e^c,\quad c_n\to c.\]</span> 可得 <span class="math display">\[\begin{aligned}\lim_{n\to\infty}\left(\varphi\left(\frac{\xi}{\sigma\sqrt{n}}\right)\right)^n&amp;=\lim_{n\to\infty}\left(1+\frac{1}{2}\varphi''\left(r\left(\frac{\xi}{\sigma\sqrt{n}}\right)\right)\frac{\xi^2}{\sigma^2n}\right)^n\\&amp;=\lim_{n\to\infty}\left(1+ \frac{-\xi^2/2}{n}\right)^n\\&amp;=e^{-\xi^2/2}.\end{aligned}\]</span> <span class="math inline">\(\blacksquare\)</span></p><div id="cramer-wold-device" class="statement sta_cramer_wold_device plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Cramer-Wold Device</span>.</span><span class="statement-spah"> </span> 设 <span class="math inline">\(\{X_n\}\)</span> 和 <span class="math inline">\(X\)</span> 都是 <span class="math inline">\(\mathbb{R}^d\)</span> 中的随机向量。则 <span class="math inline">\(X_n\to_w X\)</span> 当且仅当对任何 <span class="math inline">\(\xi\in\mathbb{R}^d\)</span> 有 <span class="math inline">\(\xi\cdot X_n\to_w \xi\cdot X\)</span>。</p></div><p><strong>证明</strong>：如果对 <span class="math inline">\(\xi\in\mathbb{R}^d\)</span> 有 <span class="math inline">\(\xi\cdot X_n\to_w \xi\cdot X\)</span>，则 <span class="math display">\[\exp(i\xi\cdot X_n)\to_w \exp(i\xi \cdotX).\]</span> 所以 <span class="math display">\[\mathbb{E}f(\exp(i\xi\cdot X_n))\to\mathbb{E}f(\exp(i\xi \cdot X)).\quad \forall f\inC_b(\mathbb{C}).\]</span> 取 <span class="math inline">\(f(z)\)</span>满足 <span class="math inline">\(f(z)=z\,(|z|\leq 1)\)</span> 和 <span class="math inline">\(f(z)=1\,(|z|&gt;1)\)</span>，则 <span class="math display">\[\varphi_{X_n}(\xi) \to \varphi_X(\xi).\]</span>由连续性定理可得 <span class="math inline">\(X_n\to_w X\)</span>。</p><p>反过来，若 <span class="math inline">\(X_n\to_wX\)</span>，则对任何实数 <span class="math inline">\(u\)</span>， <span class="math display">\[\varphi_{\xi\cdotX_n}(u)=\mathbb{E}[e^{iu\xi\cdot X_n}]\to \mathbb{E}[e^{iu\xi\cdotX}]=\varphi_{\xi\cdot X}(u).\]</span> 由连续性定理，<span class="math inline">\(\xi\cdot X_n\to_w \xi\cdot X\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个结论的证明可以直接用 <strong>Portmanteau 定理</strong>：若<span class="math inline">\(X_n\to_wX\)</span>，则对任意<strong>有界连续</strong>函数 <span class="math inline">\(h:\mathbb{R}^d\to\mathbb{R}\)</span>，有 <span class="math inline">\(\mathbb{E}[h(X_n)]\to\mathbb{E}[h(X)]\)</span>。</p></div><div id="multivariate-clt" class="statement sta_multivariate_clt plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Multivariate CLT</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(X_1,X_2,\dots\)</span> 是 <span class="math inline">\(\mathbb{R}^d\)</span> 上的 i.i.d. 随机向量，<span class="math inline">\(\mu=\mathbb{E}X_1\in\mathbbR^d\)</span>，协方差矩阵 <span class="math inline">\(\Sigma=\mathrm{Cov}(X_1)\)</span>（允许奇异）。令<span class="math display">\[S_n=\sum_{k=1}^n X_k,\qquadZ_n=\frac{S_n-n\mu}{\sqrt n}.\]</span> 则 <span class="math display">\[Z_n \ \to_w \ N_d(0,\Sigma).\]</span></p></div><p><strong>取任意方向做投影，化为一维问题。</strong></p><p>对任意 <span class="math inline">\(\xi\in\mathbb{R}^d\)</span>，令<span class="math inline">\(Y_{k,\xi}=\xi^\top (X_k-\mu)\)</span>。则<span class="math inline">\(Y_{1,\xi},Y_{2,\xi},\dots\)</span> 是一维i.i.d.，且 <span class="math display">\[\mathbb{E}Y_{k,\xi}=0,\quad\mathrm{Var}(Y_{k,\xi})=\xi^\top\Sigma\xi.\]</span> 并且 <span class="math display">\[\xi^\top Z_n=\frac1{\sqrt n}\sum_{k=1}^nY_{k,\xi}.\]</span></p><p><strong>对每个 <span class="math inline">\(\xi\)</span>应用一维中心极限定理。</strong></p><p>由一维 CLT（Lindeberg–Lévy）得 <span class="math display">\[\xi^\topZ_n \ \to_w\ \mathcal{N}\big(0,\ \xi^\top\Sigma\xi\big),\quad\forall\xi\in\mathbb{R}^d.\]</span></p><p><strong>用 Cramér–Wold 得出向量弱收敛。</strong></p><p>既然对所有 <span class="math inline">\(\xi\)</span> 都有 <span class="math inline">\(\xi^\top Z_n \Rightarrow\mathcal{N}(0,\xi^\top\Sigma\xi)\)</span>，由<strong>Cramér–Wold</strong>知 <span class="math inline">\(Z_n\to_wZ\)</span>（某极限向量），并且该极限 <span class="math inline">\(Z\)</span> 的任意线性投影都是正态，且 <span class="math display">\[\mathrm{Var}(\xi^\top Z)=\xi^\top\Sigma\xi,\quad\forall\xi.\]</span> 这唯一刻画了 <span class="math inline">\(Z\)</span>的分布为 <span class="math inline">\(\mathcal{N}_d(0,\Sigma)\)</span>。因此 <span class="math display">\[Z_n \Rightarrow\mathcal{N}_d(0,\Sigma).\]</span></p><h1 id="infinitely-divisible-distributions">✅ 26.2 Infinitely DivisibleDistributions</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义50.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\((\mathbb{R},\mathcal{B}(\mathbb{R}))\)</span>上的一个概率分布 <span class="math inline">\(\mu\)</span>称作是无穷可除的，如果对任何正整数 <span class="math inline">\(n\)</span>，都存在 <span class="math inline">\((\mathbb{R},\mathcal{B}(\mathbb{R}))\)</span>上的概率分布 <span class="math inline">\(\mu_n\)</span> 使得 <span class="math inline">\(\mu=\mu_n^{\ast n}\)</span>。</p></div><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理50.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mu\)</span>是无穷可除分布，当且仅当存在随机变量的三角列 <span class="math display">\[\{X_{n,k}\}_{k=1}^{n}\]</span> 满足对每个 <span class="math inline">\(n\)</span>，<span class="math inline">\(\{X_{n,k}\}\)</span> 是 i.i.d 的，并且 <span class="math display">\[S_n = \sum_{k=1}^{n}X_k \to_wX\overset{d}{=}\mu.\]</span></p></div><p><strong>证明</strong>：<span class="math inline">\(\Rightarrow\)</span>：由无穷可除的定义，显然。</p><p><span class="math inline">\(\Leftarrow\)</span>: 固定任意 <span class="math inline">\(l\in\mathbb N\)</span>。对第 <span class="math inline">\(nl\)</span> 行把和分成 <span class="math inline">\(l\)</span> 个相邻的块： <span class="math display">\[S_{nl}=\sum_{k=1}^{nl}X_{nl,k}=\sum_{i=1}^lS_n^{(i)},\qquadS_n^{(i)}:=\sum_{j=n(i-1)+1}^{ni} X_{nl,j}.\]</span>由于同一行内独立同分布，<span class="math inline">\((S_n^{(1)},\dots,S_n^{(l)})\)</span>相互独立且同分布。</p><p>设 <span class="math inline">\(\mu_{nl}=\mathcalL(S_{nl})\)</span>。因为 <span class="math inline">\(S_{nl}\RightarrowX\)</span>，<span class="math inline">\({\mu_{nl}}\)</span> tight。定义<span class="math display">\[\epsilon_l(r):=\sup_{n\ge1}\mathbbP(|S_{nl}|&gt;r)\downarrow 0\quad (r\to\infty).\]</span> 对任意 <span class="math inline">\(r&gt;0\)</span> 与任意 <span class="math inline">\(n\)</span>，由独立性有 <span class="math display">\[\mathbb P(S_n^{(1)}&gt;r,\dots,S_n^{(l)}&gt;r)=\prod_{i=1}^l\mathbb P(S_n^{(i)}&gt;r)\le \mathbb{P}(S_{nl}&gt;lr)\le \epsilon_l(lr).\]</span> 故 <span class="math inline">\(\mathbb{P}(S_n^{(1)}&gt;r)\le\epsilon_l(lr)^{1/l}\)</span>，同理 <span class="math inline">\(\mathbbP(S_n^{(1)}&lt;-r)\le \epsilon_l(lr)^{1/l}\)</span>，于是 <span class="math display">\[\sup_{n}\mathbb P\big(|S_n^{(1)}|&gt;r\big)\le2\epsilon_l(lr)^{1/l}\xrightarrow{r\to\infty}0,\]</span> 即 <span class="math inline">\(\{\mathcal L(S_n^{(1)})\}_n\)</span> 紧。由Prokhorov 定理，存在子列 <span class="math inline">\(n_j\)</span> 使得<span class="math display">\[S_{n_j}^{(1)}\overset{j\to\infty}{\Rightarrow}Y_l.\]</span> 由于 <span class="math inline">\(\mathcalL(S_n^{(i)})=\mathcal L(S_n^{(1)})\)</span>，所以 <span class="math inline">\(S_{n_j}^{(i)}\Rightarrow Y_l\)</span> 亦成立。</p><p>对每个 <span class="math inline">\(t\in\mathbb R\)</span>，有 <span class="math display">\[\varphi_{S_{n_j l}}(t)=\prod_{i=1}^l \varphi_{S_{n_j}^{(i)}}(t)=\big(\varphi_{S_{n_j}^{(1)}}(t)\big)^{l}.\]</span> 当 <span class="math inline">\(j\to\infty\)</span> 时，左边因<span class="math inline">\(S_{n_j l}\Rightarrow X\)</span> 收敛到 <span class="math inline">\(\varphi_X(t)\)</span>；右边因 <span class="math inline">\(S_{n_j}^{(1)}\Rightarrow Y_l\)</span> 收敛到 <span class="math inline">\(\big(\varphi_{Y_l}(t)\big)^l\)</span>。因此 <span class="math display">\[\varphi_X(t)=\big(\varphi_{Y_l}(t)\big)^l,\qquad\forall t\in\mathbb R.\]</span> 由 Lévy 连续性定理知 <span class="math inline">\(\mu=\mu_{Y_1}{*l}\)</span>。由于 <span class="math inline">\(l\)</span> 任意，<span class="math inline">\(\mu\)</span> 为无穷可除。证毕。 <span class="math inline">\(\blacksquare\)</span></p><h1 id="average-uniformity">✅ 27.1 Average Uniformity</h1><p>设 <span class="math inline">\(\{X_{n,k}\}_{k=1}^n\)</span>是一个随机变量三角列，满足 <span class="math display">\[\mathbb{E}[X_{n,k}]=0,\\mathbb{E}[X_{n,k}^2]=\sigma_{n,k}^2,\\sum_{k=1}^n\sigma_{n,k}^2=1.\]</span></p><ul><li><strong>(DV) The decaying variance conditon</strong> <span class="math display">\[\max_{1\leq k\leqn}\sigma_{n,k}^2\xrightarrow{n\to\infty} 0.\]</span></li><li><strong>(UAN) The uniform asymptotic negligiblilitycondition</strong> <span class="math display">\[\forall \epsilon &gt;0,\ \lim_{n\to\infty}\max_{1\leq k\leqn}\mathbb{P}(|X_{n,k}|&gt;\epsilon)=0.\]</span></li></ul><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理51.1</span>.</span><span class="statement-spah"> </span>DV <span class="math inline">\(\Rightarrow\)</span> UAN.</p></div><p><strong>证明</strong>：由切比雪夫不等式 <span class="math inline">\(\mathbb{P}(|X_{n,k}|&gt;\epsilon) \leq\frac{\sigma_{n,k}^2}{\epsilon^2}\)</span> 即得。</p><p>但是，仅有 DV条件仍不能保证中心极限定理的成立。我们需要一个更强的条件：</p><div id="lindberg-------" class="statement sta_lindberg___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Lindberg 条件</span>.</span><span class="statement-spah"> </span><span class="math display">\[\lim_{n\to\infty}\sum_{k=1}^n\mathbb{E}[X_{n,k}^2: |X_{n,k}|&gt;\epsilon]=0,\quad\forall\epsilon&gt;0.\]</span></p></div><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理51.2</span>.</span><span class="statement-spah"> </span>Lindberg <span class="math inline">\(\Rightarrow\)</span> DV.</p></div><p>证明： <span class="math display">\[\sigma_{n,k}^2=\mathbb{E}[X_{n,k}^2:|X_{n,k}|\leq\epsilon]+\mathbb{E}[X_{n,k}^2:|X_{n,k}|&gt;\epsilon]\leq\epsilon^2 + \sum_{j=1}^n\mathbb{E}[X_{n,j}^2:|X_{n,j}|&gt;\epsilon].\]</span></p><p>对 <span class="math inline">\(k\)</span> 取最大值得 <span class="math display">\[\max_{1\le k\le n}\sigma_{n,k}^2\le \epsilon^2 +\sum_{j=1}^n \mathbb{E}\big[X_{n,j}^2:\ |X_{n,j}|&gt;\epsilon\big].\]</span> 由 Lindeberg 条件，右端和式随 <span class="math inline">\(n\to\infty\)</span> 收敛到 <span class="math inline">\(0\)</span>，故 <span class="math display">\[\limsup_{n\to\infty}\max_{1\le k\len}\sigma_{n,k}^2\le \epsilon^2.\]</span> 由于 <span class="math inline">\(\epsilon&gt;0\)</span> 任意，必有 <span class="math display">\[\max_{1\le k\le n}\sigma_{n,k}^2\xrightarrow[n\to\infty]{} 0.\]</span> 即 DV 成立。<span class="math inline">\(\blacksquare\)</span></p><div id="lindberg-feller-------------------" class="statement sta_lindberg_feller_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Lindberg-Feller 中心极限定理</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\{X_{n,k}\}\)</span> 满足 Lindberg 条件，则 <span class="math inline">\(S_n\to_w\mathcal{N}(0,1)\)</span>。</p><p>反之，如果 <span class="math inline">\(\{X_{n,k}\}\)</span> 满足 DV条件，且 <span class="math inline">\(S_n\to_w\mathcal{N}(0,1)\)</span>，则 <span class="math inline">\(\{X_{n,k}\}\)</span> 也满足 Lindberg 条件。</p></div><h1 id="lindberg-feller-clt">✅ 27.2 Lindberg-Feller CLT</h1><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理52.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(a_j,b_j\)</span> 是复数且 <span class="math inline">\(|a_j|, |b_j|\leq1\)</span>，则 <span class="math display">\[|a_1\cdots a_n - b_1\cdots b_n|\leq\sum_{j=1}^n|a_j-b_j|.\]</span></p></div><p>证明：用归纳法即可。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理52.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(L^2\)</span> 可积的随机变量，<span class="math inline">\(\varphi\)</span> 是其特征函数，则 <span class="math display">\[\left|\varphi(t) - 1 - it\mathbb{E}X +\frac{1}{2}\mathbb{E}[X^2]t^2\right|\leq\mathbb{E}\left[X^2\wedge\frac{|X|^3}{3!}t\right].\]</span></p></div><p>证明：根据 Taylor 定理， <span class="math display">\[\left|e^{it} -1 - it\right|\leq \frac{t^2}{2}.\]</span> <span class="math display">\[\left|e^{it} - 1 - it+ \frac{1}{2}t^2\right|\leq\frac{|it|^3}{3!}.\]</span> 合起来就得到 <span class="math display">\[\left|e^{it} - 1 - it+ \frac{1}{2}t^2\right|\leqt^2\wedge \frac{|it|^3}{3!}.\]</span> 取 <span class="math inline">\(tX\)</span> 代入并求期望，得到 <span class="math display">\[\left|\mathbb{E}\left[e^{itX} - 1 - itX+\frac{1}{2}t^2X^2\right]\right|\leq \mathbb{E}\left[t^2X^2\wedge\frac{|X|^3}{3!}t^3\right].\]</span> 即为所证。<span class="math inline">\(\blacksquare\)</span></p><div id="lindberg-feller-clt-part-1" class="statement sta_lindberg_feller_clt_part_1 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Lindberg-Feller CLT Part 1</span>.</span><span class="statement-spah"> </span>如果三角列 <span class="math inline">\(\{X_{n,k}\}\)</span> 满足 Lindberg 条件，则 <span class="math inline">\(S_n\to_w\mathcal{N}(0,1)\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>注意 Lindberg-Feller CLT 仍然要求 <span class="math inline">\(\{X_{n,k}\}\)</span> 对每个 <span class="math inline">\(n\)</span> 都是 i.i.d 序列。</p></div><p><strong>证明</strong>：只要证 <span class="math inline">\(\varphi_{S_n}\to e^{-t^2/2}\)</span> 即可。</p><p>根据第一个引理，结合 <span class="math inline">\(\sum_{k=1}^n\sigma_{n,k}^2=1\)</span>，我们得到</p><p><span class="math display">\[|\varphi_{S_n}(t) - e^{-t^2/2}|\leq\sum_{k=1}^n\left|\varphi_{X_{n,k}}(t) -e^{-\sigma_{n,k}^2t^2/2}\right|.\]</span> 注意这个特征函数的分解就用到了i.i.d 性质。</p><p><span class="math display">\[\begin{aligned}|\varphi_{X_{n,k}}(t) - e^{-\sigma_{n,k}^2t^2/2}| &amp;\le|\varphi_{X_{n,k}}(t)-(1-\frac{t^2\sigma_{n,k}^2}{2})|+|(1-\frac{t^2\sigma_{n,k}^2}{2})-e^{-\sigma_{n,k}^2t^2/2}|.\end{aligned}\]</span> 记第一项是 <span class="math inline">\(A_{n,k}\)</span>，第二项是 <span class="math inline">\(B_{n,k}\)</span>，问题转化为证明 <span class="math display">\[\lim_{n\to\infty}\sum_{k=1}^n(A_{n,k}+B_{n,k})=0.\]</span> 我们任取一个正数 <span class="math inline">\(\epsilon&gt;0\)</span>。注意到 <span class="math inline">\(\mathbb{E}[X_{n,k}]=0\)</span>，所以 <span class="math display">\[\begin{aligned}A_{n,k}&amp;=|\varphi_{X_{n,k}}(t)-(1-\frac{t^2\sigma_{n,k}^2}{2})|\leqt^2\left(\mathbb{E}X_{n,k}^2\wedge \frac{|X_{n,k}|^3}{3!}t\right)\\&amp;\le t^2\left(\mathbb{E}\left[X_{n,k}^2\wedge \frac{|X_{n,k}|^3}{3!}t:|X_{n,k}|\leq\epsilon\right]+\mathbb{E}\left[X_{n,k}^2\wedge \frac{|X_{n,k}|^3}{3!}t:|X_{n,k}|&gt;\epsilon\right]\right)\\&amp;\le|t|^3\frac{\epsilon}{3!}\mathbb{E}[X_{n,k}^2]+t^2\mathbb{E}\left[X_{n,k}^2:|X_{n,k}|&gt;\epsilon\right]\\&amp;=|t|^3\frac{\epsilon}{3!}\sigma_{n,k}^2+t^2\mathbb{E}\left[X_{n,k}^2:|X_{n,k}|&gt;\epsilon\right]\end{aligned}\]</span> 所以 <span class="math display">\[\sum_{k=1}^nA_{n,k}\le|t|^3\frac{\epsilon}{3!}\sum_{k=1}^n\sigma_{n,k}^2+t^2\sum_{k=1}^n\mathbb{E}\left[X_{n,k}^2:|X_{n,k}|&gt;\epsilon\right].\]</span> 于是 <span class="math display">\[\limsup_{n\to\infty}\sum_{k=1}^n A_{n,k}\leq\frac{|t|^3}{6}\epsilon.\]</span> 由 <span class="math inline">\(\epsilon\)</span> 任意性即得。</p><p>再来估计 <span class="math inline">\(B_{n,k}=|(1-\frac{t^2\sigma_{n,k}^2}{2})-e^{-\sigma_{n,k}^2t^2/2}|\)</span>。利用<span class="math inline">\(|e^{-u}-(1-u)|\leq\frac{u^2}{2}\)</span>，可得<span class="math display">\[\sum_{k=1}^nB_{n,k}\le\frac{1}{8}t^4\sum_{k=1}^n\sigma_{n,k}^4\le\frac{1}{8}t^4\max_{k}\sigma_{n,k}^2.\]</span> 由于 Lindberg条件意味着 DV 条件，故 <span class="math inline">\(n\to\infty\)</span>时上式右边趋于 0，得证。<span class="math inline">\(\blacksquare\)</span></p><h1 id="conditional-expectation-part-1">✅ 30.2 Conditional Expectation,Part 1</h1><p>无要点</p><h1 id="orthogonal-projections">✅ 31.1 Orthogonal Projections</h1><p>一些关于 Hilber 空间 <span class="math inline">\(L^2\)</span>的基本结论，无要点</p><h1 id="conditioning-on-random-variables">✅ 32.3 Conditioning on RandomVariables</h1><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题55.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(X:(\Omega,\mathcal F)\to(S,\mathcalB)\)</span>，<span class="math inline">\(Y:(\Omega,\mathcalF)\to(T,\mathcal C)\)</span> 为随机变量。若 <span class="math inline">\(X\)</span> 与 <span class="math inline">\(Y\)</span> 独立，且 <span class="math inline">\(f\in \mathbb B(S\times T,\mathcal B\otimes\mathcalC)\)</span>（有界可测），则对 <span class="math inline">\(\mu_X\)</span>-a.e. 的 <span class="math inline">\(x\)</span> 有 <span class="math display">\[\mathbb{E}\left[f(X,Y)\mid X=x\right]=\int_Tf(x,y)\,\mu_Y(\mathrm d y).\]</span> 等价地， <span class="math display">\[\mathbb E\left[f(X,Y)\mid \sigma(X)\right]=g(X)\quad a.s.,\quadg(x):=\int_T f(x,y)\,\mu_Y(\mathrm d y).\]</span></p></div><p><strong>证明</strong>：由独立性，联合分布 <span class="math inline">\(\mu_{X,Y}=\mu_X\otimes \mu_Y\)</span>。令 <span class="math display">\[g(x):=\int_Tf(x,y)\,\mu_Y(\,\mathrm{d}y).\]</span> 则按核积分的可测性引理，<span class="math inline">\(g\)</span> 是 <span class="math inline">\(\mathcalB\)</span>-可测且有界。</p><p>取任意 <span class="math inline">\(h\in\mathbb B(S,\mathcalB)\)</span>，有（把期望写成对联合分布的积分并用 Fubini/Tonelli） <span class="math display">\[\begin{aligned}\mathbb E\left[f(X,Y)h(X)\right]&amp;=\int_{S\times T}f(x,y)h(x)\,(\mu_X\otimes\mu_Y)(\,\mathrm{d}x\,\mathrm{d}y)\\&amp;=\int_{S}\left(\int_{T} f(x,y)\,\mu_Y(\,\mathrm{d}y)\right)h(x)\,\mu_X(\,\mathrm{d}x)\\&amp;=\int_S g(x)h(x)\,\mu_X(\,\mathrm{d}x)\\&amp;=\mathbb E\left[g(X)h(X)\right].\end{aligned}\]</span> 以上对一切有界 <span class="math inline">\(\mathcalB\)</span>-可测 <span class="math inline">\(h\)</span>成立，故按条件期望的刻画， <span class="math display">\[\mathbb E\left[f(X,Y)\mid \sigma(X)\right]=g(X)\quad a.e.\]</span> 从而对 <span class="math inline">\(\mu_X\)</span>-a.e. 的<span class="math inline">\(x\)</span>， <span class="math display">\[\mathbb E\left[f(X,Y)\mid X=x\right]=g(x)=\int_Tf(x,y)\,\mu_Y(\,\mathrm{d}y).\]</span> 证毕。</p><h1 id="probability-kernels-part-1">✅ 33.1 Probability Kernels, Part1</h1><p>本讲引入了概率核的概念。</p><p>设 <span class="math inline">\((S_i,\mathcal{B}_i), i=1,2\)</span>是两个可测空间，一个概率核 <span class="math inline">\(Q(x,B):S_1\times\mathcal{B}_2\to[0,1]\)</span> 是一个二元函数，满足：</p><ol type="1"><li>对任何 <span class="math inline">\(x\in S_1\)</span>，<span class="math inline">\(Q(x,\cdot):\mathcal{B}_2\to[0,1]\)</span> 是 <span class="math inline">\((S_2,\mathcal{B}_2)\)</span> 上的概率测度。</li><li>对任何 <span class="math inline">\(B\in\mathcal{B}_2\)</span>，<span class="math inline">\(Q(\cdot,B):S_1\to[0,1]\)</span> 是 <span class="math inline">\((S_1,\mathcal{B}_1)\)</span> 上的可测函数。</li></ol><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理56.1</span>.</span><span class="statement-spah"> </span>假设 <span class="math inline">\(f(x,y)\in (S_1\times S_2,\mathcal{B}_1\otimes\mathcal{B}_2)\)</span>是乘积空间上的可测函数，并且是有界的或者非负的，则积分 <span class="math display">\[x\to\int_{S_2}f(x,y)Q(x,\,\mathrm{d}y)\]</span>是关于 <span class="math inline">\(x\)</span> 的可测函数。</p></div><p>此引理不难从简单函数 <span class="math inline">\(\mathbb{1}_{B_1\timesB_2}(x,y)=\mathbb{1}_{B_1}(x)\mathbb{1}_{B_2}(y)\)</span>出发，使用函数形式的 Dynkin 引理得到。</p><p>由此对任何 <span class="math inline">\((S_1,\mathcal{B}_1)\)</span>上的测度 <span class="math inline">\(\mu\)</span>，我们可以定义乘积空间<span class="math inline">\((S_1\times S_2,\mathcal{B}_1\otimes\mathcal{B}_2)\)</span> 上的乘积测度 <span class="math inline">\(\mu\otimes Q\)</span>： <span class="math display">\[(\mu\otimesQ)(E)=\int_{S_1}\mu(\mathrm{d}x)\int_{S_2}\mathbb{1}_{E}(x,y)Q(x,\,\mathrm{d}y).\]</span>不过这真的是一个概率测度吗？你可以用积分的线性性质立刻看出它是有限可加的，并且利用积分项有界和控制收敛定理立刻看出它是可数可加的，所以确实是个概率测度。</p><p>有了概率核的乘积测度，我们自然要研究对这种测度的积分。由于这个测度本身就是通过对示性函数积分来定义的，所以其上的积分也具有类似的性质：</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理56.2</span>.</span><span class="statement-spah"> </span>假设 <span class="math inline">\(f(x,y)\)</span>是乘积空间的可测函数，并且是有界或者非负的，则 <span class="math display">\[\int_{S_1\times S_2}f\,\mathrm{d}(\mu\otimes Q) =\int_{S_1}\mu(\,\mathrm{d}x)\int_{S_2}f(x,y)Q(x,\,\mathrm{d}y).\]</span></p></div><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理56.3</span>.</span><span class="statement-spah"> </span>若两核 <span class="math inline">\((Q,\tilde Q)\)</span> 只在 <span class="math inline">\(\mu\)</span>-零集上不同，即 <span class="math inline">\(Q(x,\cdot)=\tilde Q(x,\cdot)\)</span> for <span class="math inline">\(\mu\)</span>-a.e. <span class="math inline">\(x\)</span>，则由它们和边缘 <span class="math inline">\(\mu\)</span>拼出来的“联合测度”是<strong>同一个</strong>测度：<span class="math inline">\(\mu\otimes Q=\mu\otimes \tilde Q\)</span>。</p><p>反过来，如果 <span class="math inline">\(\mathcal{B}_2\)</span>是可数生成的，则如果 <span class="math inline">\(\mu\otimes Q=\mu\otimes\tilde Q\)</span>，那么 <span class="math inline">\(Q(x,\cdot)=\tildeQ(x,\cdot)\)</span> 对 <span class="math inline">\(\mu\)</span>-a.e. 的<span class="math inline">\(x\)</span> 成立。</p></div><p><strong>意义</strong>：正则条件分布/概率核通常只在 <span class="math inline">\(\mu\)</span>-a.e. 意义下唯一。若 <span class="math inline">\(\mu\otimes Q\)</span>会因零集上的改动而改变，那很多定义就不稳固了。这个结论保证：<strong>任选一个版本</strong>都得到<strong>同一</strong>联合测度与同一组期望值<span class="math inline">\(\displaystyle \int f\,\mathrm{d}(\mu\otimesQ)=\int \mu(\mathrm{d}x)\int f(x,y)\,Q(x,\mathrm{d}y)\)</span>。</p><p><strong>证明</strong>：<span class="math inline">\(\Rightarrow\)</span>： <span class="math display">\[\begin{aligned}(\mu\otimes Q)(B_1\times B_2) &amp;=\int_{S_1}\mu(\mathrm{d}x)\int_{S_2}\mathbb{1}_{B_1}(x)\mathbb{1}_{B_2}(y)Q(x,\,\mathrm{d}y)\\&amp;=\int_{B_1}\mu(\mathrm{d}x) Q(x,B_2) = \int_{B_1}\mu(\mathrm{d}x)\tilde Q(x,B_2).\end{aligned}\]</span></p><p><span class="math inline">\(\Leftarrow\)</span>：如果 <span class="math inline">\(\mu\otimes Q=\mu\otimes \tildeQ\)</span>，上面的计算给出 <span class="math display">\[\int_{B_1}\mu(\mathrm{d}x)Q(x,B_2) =\int_{B_2}\mu(\mathrm{d}x)\tilde Q(x,B_2),\quad \forallB_1\in\mathcal{B}_1,B_2\in\mathcal{B}_2.\]</span> 于是 <span class="math display">\[\int_{S_1}[Q(x,B_2) - \tildeQ(x,B_2)]\mathbb{1}_{B_1}(x)\mu(\mathrm{d}x) = 0,\quad\forallB_1\in\mathcal{B}_1.\]</span> 从而 <span class="math display">\[\int_{S_1}[Q(x,B_2) - \tildeQ(x,B_2)]h(x)\mu(\mathrm{d}x) = 0,\quad\forallh\in\mathbb{B}(S_1,\mathcal{B}_1).\]</span> 这必须有 <span class="math inline">\(Q(x,B_2) =\tilde Q(x,B_2)\)</span>几乎处处成立才行。<span class="math inline">\(\blacksquare\)</span></p><h1 id="regular-conditional-distributions">✅ 33.2 Regular ConditionalDistributions</h1><p>本讲使用概率核给出了 <span class="math inline">\(\mathbb{E}[f(X,Y)\mid X=x]\)</span> 这种条件期望的严格定义。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理57.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\)</span>是一个概率空间，<span class="math inline">\((S_i,\mathcal{B}_i),\,i=1,2\)</span>是两个可测空间。 <span class="math display">\[X:(\Omega,\mathcal{F})\to(S_1,\mathcal{B}_1),\quadY:(\Omega,\mathcal{F})\to(S_2,\mathcal{B}_2)\]</span>是两个随机变量。于是 <span class="math display">\[(X,Y):(\Omega,\mathcal{F})\to(S_1\timesS_2,\,\mathcal{B}1\otimes\mathcal{B}_2)\]</span></p><p>是随机向量。记 <span class="math inline">\(\mu_{X,Y}\)</span>为此随机向量在 <span class="math inline">\((S_1\timesS_2,\,\mathcal{B}1\otimes\mathcal{B}_2)\)</span> 上 push forward给出的测度，<span class="math inline">\(\mu_X\)</span> 是 <span class="math inline">\(X\)</span> 在 <span class="math inline">\((S_1,\mathcal{B}_1)\)</span> 上 push forward给出的测度。如果存在概率核 <span class="math inline">\(Q(x,B)\)</span>使得 <span class="math display">\[\mu_{X,Y}=\mu_X\otimes Q.\]</span></p><p>则对任何 <span class="math inline">\(f\in L^1(S_1\timesS_2,\mathcal{B}1\otimes\mathcal{B}_2)\)</span> 有 <span class="math display">\[\mathbb{E}[f(X,Y)\mid X = x] =\int_{S_2}f(x,y)Q(x, \,\mathrm{d}y).\]</span></p></div><p>这里需要解释 <span class="math inline">\(\mathbb{E}[f(X,Y)\mid X =x]\)</span> 这个记号的含义。这里其实引用了条件期望 (后面才会讲到)的性质：<span class="math inline">\(\mathbb{E}[f(X,Y)\mid X]\)</span>是一个关于 <span class="math inline">\(\sigma(X)\)</span>可测的随机变量，从而由 Doob-Dynkin 表示定理，存在可测函数 <span class="math inline">\(g\)</span> 使得 <span class="math inline">\(\mathbb{E}[f(X,Y)\mid X] = g(X)\)</span>，所以<span class="math inline">\(\mathbb{E}[f(X,Y)\mid X = x] =g(x)\)</span>。这个定理说的就是 <span class="math display">\[g(x):=\mathbb{E}[f(X,Y)\mid X = x] = \tildeg(x):=\int_{S_2}f(x,y)Q(x, \,\mathrm{d}y).\]</span></p><p><strong>证明</strong>：怎么证明两个关于 <span class="math inline">\(\sigma(X)\)</span> 可测的函数 (几乎处处)相等呢？我们可以给它们同时乘以 <span class="math inline">\(h(x)\)</span>，这里 <span class="math inline">\(h(x)\)</span> 是任何一个关于 <span class="math inline">\(\sigma(X)\)</span> 可测的有界函数，然后证明它们对<span class="math inline">\(\mu_X\)</span>积分以后的值相等，则这两个可测函数必相等。</p><p><span class="math inline">\(g(x)h(x)\)</span> 这个函数对 <span class="math inline">\(\mu_X\)</span> 积分，根据积分变量替换定理，正是<span class="math inline">\(\mathbb{E}[g(X)h(X)]\)</span>。而根据 <span class="math inline">\(g(x)\)</span> 的定义和条件期望的性质， <span class="math display">\[\mathbb{E}[g(X)h(X)]=\mathbb{E}[\mathbb{E}[f(X,Y)|X]h(X)]= \mathbb{E}[\mathbb{E}[f(X,Y)h(X)|X]] = \mathbb{E}[f(X,Y)h(X)].\]</span> 注意右边的期望悄悄地变成了关于 <span class="math inline">\(\mu_X\otimes Q\)</span>的积分。这是因为上式最后的等号使用了条件期望的 telescoping 性质，而<span class="math inline">\(f(X,Y)g(X)\)</span> 是关于 <span class="math inline">\(\mathcal{B}_1\otimes\mathcal{B}_2\)</span>可测的函数。</p><p>另一方面， <span class="math display">\[\begin{aligned}\mathbb{E}[f(X,Y)h(X)] &amp;= \int_{S_1\timesS_2}f(x,y)h(x)\mu_{X,Y}(\,\mathrm{d}x\,\mathrm{d}y) \\&amp;= \int_{S_1\times S_2}f(x,y)h(x)\mu_X\otimes Q \\&amp;= \int_{S_1}\mu(\mathrm{d}x) \int_{S_2}f(x,y)h(x)Q(x,\,\mathrm{d}y)\\&amp;= \int_{S_1}h(x)\mu(\mathrm{d}x)h(x)\int_{S_2}f(x,y)Q(x,\,\mathrm{d}y)\\&amp;= \int_{S_1}\tilde g(x)h(x)\mu(\mathrm{d}x)\\&amp;= \mathbb{E}[\tilde g(x)h(x)].\end{aligned}\]</span> 正是所要证明的。</p><p>不过在上面的证明中我们都假定了所有的可积性的前提。我们实际上需要假定<span class="math inline">\(f(x,y)\)</span>有界才能确保推导成立。对一般的 <span class="math inline">\(f(x,y)\inL^1(S_1\times S_2,\mathcal{B}_1\otimes\mathcal{B}_2)\)</span>，取有界函数列 <span class="math inline">\(f_n=f\mathbb{1}_{|f|\len}\xrightarrow{L^1}f\)</span>。由于条件期望是 contraction，所以 <span class="math display">\[\mathbb{E}[f_n(X, Y)| X] \xrightarrow{L^1}\mathbb{E}[f(X,Y)|X].\]</span> 我们上面已经证明了 <span class="math display">\[\mathbb{E}[f_n(X, Y)| X] =\left.\int_{S_2}f_n(x,y)Q(x,\,\mathrm{d}y)\right|_{x=X}.\]</span>所以只要证明 <span class="math display">\[\left.\int_{S_2}f_n(x,y)Q(x,\,\mathrm{d}y)\right|_{x=X}\xrightarrow{L^1}\left.\int_{S_2}f(x,y)Q(x,\,\mathrm{d}y)\right|_{x=X}.\]</span>即可。这个 <span class="math inline">\(L^1\)</span> 收敛的意思是对 <span class="math inline">\(\mu_X\)</span> 取积分，因此我们要估计 <span class="math display">\[\int_{S_1}\mu(\,\mathrm{d}x)\int_{S_2}|f_n(x,y)-f(x,y)|Q(x,\,\mathrm{d}y).\]</span>这不正是 <span class="math inline">\(|f_n-f|\)</span>对乘积测度的积分嘛，而我们已经知道了它是 <span class="math inline">\(L^1\)</span> 收敛的了。</p><p>所以如果我们能把一个联合分布分解为边际分布和一个概率核的乘积，则我们就得到了条件概率的一个表示。</p><blockquote><p><strong>问题</strong>：<span class="math inline">\(\mu_{X,Y}\)</span>总可以表示为 <span class="math inline">\(\mu_X\otimes Q\)</span>的形式吗？</p></blockquote><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理57.2</span>.</span><span class="statement-spah"> </span>如果概率核 <span class="math inline">\(Q(x, B)\)</span> 满足 <span class="math display">\[\mathbb{P}(Y\in B | X=x) = Q(x, B)\]</span>(这个条件等价于 <span class="math display">\[\mathbb{E}[h(Y) | X] =\left.\int h(y) Q(x,\,\mathrm{d}y)\right|_{x=X}.\]</span>对任何有界的可测函数 <span class="math inline">\(h(y)\)</span> 成立)</p><p>则对 <span class="math inline">\(f(x,y)\)</span> 同样有 <span class="math display">\[\mathbb{E}[f(X,Y) | X] = \left.\int f(x,y)Q(x,\,\mathrm{d}y)\right|_{x=X}.\]</span> 成立。</p></div><p>这个定理可以先从 <span class="math inline">\(f(x,y)=f(x)\otimesg(y)\)</span> 形式的函数出发，然后用 Dynkin 函数系引理得到。</p><p>总结一下，至此我们讨论了：</p><ol type="1"><li>如果 <span class="math inline">\(\mu_{X,Y}=\mu_X\otimesQ\)</span>，那我们就有了 <span class="math inline">\(\mathbb{E}[f(X,Y)|X]\)</span> 的计算方法：积分<span class="math inline">\(\int_{S_2}f(X,y)Q(X,\,\mathrm{d}y)\)</span>。特别地我们可以算条件概率了。</li><li>反之如果我们有一个概率核给出条件概率：<span class="math inline">\(\mathbb{P}(Y\in B | X=x) = Q(x,B)\)</span>，那么它就给出 <span class="math inline">\(\mu_{X,Y}\)</span>的一个分解：<span class="math inline">\(\mu_{X,Y}=\mu_X\otimesQ\)</span>。</li></ol><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理57.3</span>.</span><span class="statement-spah"> </span>当 <span class="math inline">\(S_2\)</span> 是标准 Borel 空间或者 Polish空间时，正则条件概率存在。</p></div><p><strong>证明</strong>：我们对 <span class="math inline">\(S=\mathbb{R}\)</span> 的情形证明。设 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\)</span>为概率空间，<span class="math inline">\(\mathcalG\subset\mathcal{F}\)</span> 为子 <span class="math inline">\(\sigma\)</span>-代数，<span class="math inline">\(Y:(\Omega,\mathcal{F})\to(\mathbb{R},\mathcal{B}(\mathbb{R}))\)</span>可测。</p><p>对每个 <span class="math inline">\(q\in\mathbb Q\)</span>，设 <span class="math display">\[G(q,\omega):=\mathbb P(Y\le q\mid \mathcalG)(\omega).\]</span> 由 <span class="math inline">\(\mathbb{1}_{\{Y\leq_1\}}\le\mathbb{1}_{\{Y\leq_2\}}\)</span>与条件期望的单调性，丢掉可数零集 <span class="math inline">\(\bigcup_{q_1,q_2} \{\omega\midG(q_1,\omega)\not\le G(q_2,\omega)\}\)</span> 后可取版本使得对每个 <span class="math inline">\(\omega\)</span>，<span class="math inline">\(q\mapsto G(q,\omega)\)</span> 非降。定义 <span class="math display">\[F(x,\omega):=\inf\{\,G(q,\omega):q\in\mathbb Q,\ q&gt;x\,\}.\]</span> 则对每个 <span class="math inline">\(\omega\)</span>，<span class="math inline">\(F(\cdot,\omega)\)</span> 非降、右连续，且 <span class="math inline">\(\lim_{x\to-\infty}F(x,\omega)=0\)</span>、<span class="math inline">\(\lim_{x\to+\infty}F(x,\omega)=1\)</span>。并且对任意<span class="math inline">\(A\in\mathcal G\)</span> 与 <span class="math inline">\(x\in\mathbb R\)</span>，取 <span class="math inline">\(q_n\downarrow x\)</span> 得 <span class="math display">\[\int_A F(x,\omega)\,\mathrm d\mathbb P(\omega)=\lim_{n}\int_A G(q_n,\omega)\,\mathrm d\mathbb P(\omega)=\lim_{n}\mathbb P\big(A\cap{Y\le q_n}\big)=\mathbb P\big(A\cap{Y\le u}\big).\]</span></p><p>令 <span class="math inline">\(\nu(\omega,\cdot)\)</span> 是以 <span class="math inline">\(F(\cdot,\omega)\)</span> 为分布函数的Lebesgue–Stieltjes 概率测度，由上式可得对一切 <span class="math inline">\(A\in\mathcal G\)</span> 与 <span class="math inline">\(x\in\mathbb R\)</span>， <span class="math display">\[\int_A \nu\big(\omega,(-\infty,x]\big)\,\mathrm d\mathbbP(\omega)=\mathbb P\big(A\cap{Y\le x}\big).\]</span> 令 <span class="math display">\[\mathcal D:=\{B\in\mathcal B(\mathbb R):\ \omega\mapsto \nu(\omega,B)\ \\mathcal G\text{-可测且}\ \int_A \nu(\omega,B)\,\mathrm d\mathbbP=\mathbb P\big(A\cap{Y\in B}\big),\ \forall A\in\mathcal G\}.\]</span> 则 <span class="math inline">\(\mathcal D\)</span> 为 <span class="math inline">\(\lambda\)</span>-系且包含 <span class="math inline">\(\pi\)</span>-系 <span class="math inline">\(\{(a,b]\}\)</span>，故由 <span class="math inline">\(\pi-\lambda\)</span> 定理 <span class="math inline">\(\mathcal D=\mathcal B(\mathbbR)\)</span>。于是对所有 Borel集 <span class="math inline">\(B\)</span>，<span class="math inline">\(\nu(\cdot,B)\)</span> 为 <span class="math inline">\(\mathcal G\)</span>-可测，且 <span class="math display">\[\int_A \nu(\omega,B)\,\mathrm{d}\mathbb P=\mathbb P\big(A\cap{Y\inB}\big),\qquad \forall A\in\mathcal G.\]</span></p><p>定义 <span class="math display">\[Q(\omega,B):=\nu\big(\omega,B\big),\qquad B\in\mathcal S.\]</span> 则对每个 <span class="math inline">\(\omega\)</span>，<span class="math inline">\(B\mapsto Q(\omega,B)\)</span> 为 <span class="math inline">\((S,\mathcal S)\)</span>上的概率测度；对每个 <span class="math inline">\(B\)</span>，<span class="math inline">\(\omega\mapsto Q(\omega,B)\)</span> 为 <span class="math inline">\(\mathcal G\)</span>-可测。并且对一切 <span class="math inline">\(A\in\mathcal G\)</span> 与 <span class="math inline">\(B\in\mathcal S\)</span>， <span class="math display">\[\int_A Q(\omega,B)\,\mathrm d\mathbb P=\int_A \nu\big(\omega,B\big)\,\mathrm d\mathbb P=\mathbb P\big(A\cap{Y\in B}\big).\]</span> 因此 <span class="math inline">\(Q(\cdot, B)\)</span> 正是<span class="math inline">\(\mathbb{E}[\mathbb{1}_{\{Y\in B\}}|\mathcalG]\)</span> 的一个版本。于是 <span class="math inline">\(Q\)</span>是给定 <span class="math inline">\(\mathcal G\)</span>的正则条件概率核。<span class="math inline">\(\blacksquare\)</span></p><h1 id="probability-kernels-part-2">✅ 34.1 Probability Kernels, Part2</h1><p>本讲介绍了概率核的本质是 Markov生成元，即可测函数空间上的非负线性泛函。</p><p>当有一个概率核 <span class="math inline">\(Q: S_1\times\mathcal{B}_2\to[0, 1]\)</span> 时， <span class="math display">\[f\to\int_{S_2}f(y)Q(x,\,\mathrm{d}y),\quadf\in\mathbb{B}(S_2,\mathcal{B}_2)\]</span> 给出了从 <span class="math inline">\(L^\infty(S_2,\mathcal{B}_2)\)</span> 到 <span class="math inline">\(L^\infty(S_1,\mathcal{B}_1)\)</span> 的线性映射<span class="math inline">\(L_Q\)</span>，<span class="math inline">\(L_Q\)</span> 满足</p><ol type="1"><li><span class="math inline">\(L_Q(1)=1\)</span>。</li><li>若 <span class="math inline">\(f\geq 0\)</span> 非负可测，则 <span class="math inline">\(L_Q(f)\geq 0\)</span> 也非负可测。</li><li>若 <span class="math inline">\(f_n\uparrow f\)</span> 则 <span class="math inline">\(L_Q(f_n)\uparrow L_Q(f)\)</span>。</li><li><span class="math inline">\(\|L_Q(f)\|_{\infty} \leq\|f\|_{\infty}\)</span>。</li></ol><p>所以 <span class="math inline">\(L_Q\)</span>是一个连续的正线性泛函？</p><p>反过来，如果有这样的一个泛函 <span class="math inline">\(L\)</span>，<span class="math inline">\(L\)</span>是否给出一个概率核 <span class="math inline">\(Q\)</span> 呢？</p><p>答案是否定的，一般来说这不成立。但是在 <span class="math inline">\((S_1,\mathcal{B}_1)=(S_2,\mathcal{B}_2)\)</span>的情形，这确实是对的。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理58.1</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(L:\mathbb{B}(S,\mathcal{B})\to\mathbb{B}(S,B)\)</span>满足以上四个条件，则 <span class="math display">\[Q(x, B) =L(\mathbb{1}_B)(x)\]</span> 给出一个概率核。并且 <span class="math inline">\(L_Q=L\)</span>，即此概率核给出的线性泛函正是 <span class="math inline">\(L\)</span>。</p></div><p><strong>证明</strong>：先证 <span class="math inline">\(Q\)</span>为概率核。对任意固定 <span class="math inline">\(B\in\mathcalB\)</span>，有 <span class="math display">\[Q(\cdot,B)=L(\mathbb{1}_B)\in\mathbb{B}(S,\mathcalB).\]</span> 故 <span class="math inline">\(x\mapsto Q(x,B)\)</span>可测。对任意固定 <span class="math inline">\(x\in S\)</span>，由 <span class="math inline">\(0\le \mathbb{1}_B\le 1\)</span> 与正性得 <span class="math display">\[0\le Q(x,B)\le Q(x,S)=L(1)(x)=1.\]</span> 且<span class="math inline">\(Q(x,\varnothing)=0\)</span>。设 <span class="math inline">\(B=\biguplus_{k\ge1} B_k\)</span> 两两不交，令<span class="math inline">\(f_n:=\sum_{k=1}^n\mathbb{1}_{B_k}\)</span>，则 <span class="math inline">\(0\lef_n\uparrow \mathbb{1}_B\)</span>，由线性与单调连续性， <span class="math display">\[Q(x,B)=L(\mathbb{1}_B)(x)=\lim_{n\to\infty}L(f_n)(x)=\lim_{n\to\infty}\sum_{k=1}^nL(\mathbb{1}_{B_k})(x)=\sum_{k=1}^\infty Q(x,B_k).\]</span> 故 <span class="math inline">\(B\mapsto Q(x,B)\)</span> 为概率测度。于是 <span class="math inline">\(Q\)</span> 是概率核。</p><p>记 <span class="math display">\[L_Q(f)(x):=\int_Sf(y)Q(x,\,\mathrm{d}y).\]</span> 显然对任意 <span class="math inline">\(B\in\mathcal B\)</span>， <span class="math display">\[L(\mathbb{1}_B)=Q(\cdot,B)=\int_S\mathbb{1}_B(y)Q(\cdot,\,\mathrm{d}y)=L_Q(\mathbb{1}_B).\]</span></p><p>设 <span class="math display">\[\mathbb{H}=\{f\in\mathbb{B}(S,\mathcal B):\L(f)=L_Q(f)\}.\]</span> 则 <span class="math inline">\(\mathbb{H}\)</span>是向量空间，并且对有界收敛封闭。<span class="math inline">\(\mathbb{H}\)</span> 包含乘法系 <span class="math display">\[\mathbb{M}=\{\mathbb{1}_B:\ B\in\mathcal B\}.\]</span> 显然 <span class="math inline">\(\sigma(\mathbb{M})=\mathcal{B}\)</span>。由<strong>Dynkin 的乘法系定理（函数版）</strong>，对一切 <span class="math inline">\(f\in\mathbb{B}(S,\mathcal B)\)</span> 与 <span class="math inline">\(x\in S\)</span>， <span class="math display">\[L(f)(x)=L_Q(f)(x)=\int_Sf(y)Q(x,\,\mathrm{d}y).\]</span> 即 <span class="math inline">\(L=L_Q\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>如果 <span class="math inline">\(Q_1,Q_2\)</span> 是两个 <span class="math inline">\((S,\mathcal{B})\)</span> 到自身的概率核，则 <span class="math inline">\(L_{Q_1}L_{Q_2}\)</span> 也满足性质1-4，因而也是由一个概率核给出：存在概率核 <span class="math inline">\(Q\)</span> 使得 <span class="math inline">\(L_Q =L_{Q_1}L_{Q_2}\)</span>。我们可以把 <span class="math inline">\(Q\)</span> 明确的写出来： <span class="math display">\[L_Q(f) =L_{Q_1}L_{Q_2}(f)=\int_{S}Q_1(x,\,\mathrm{d}y)\left(\int_Sf(z)Q_2(y,\,\mathrm{d}z)\right).\]</span>这看起来很像乘积测度，实际上我们后面会讨论 <span class="math display">\[Q_1(x,dy)Q_2(d, dz)= Q_1\otimes Q_2(x,dz)\]</span> 的具体含义。</p><h1 id="random-dynamics">✅ 34.2 Random Dynamics</h1><p>什么是随机动力系统：</p><p>有一个概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\)</span>，一个可测空间<span class="math inline">\((R,\mathcal{G})\)</span>，以及一些 i.i.d随机变量 <span class="math inline">\(\xi_n:(\Omega,\mathcal{F},\mathbb{P})\to(R,\mathcal{G})\)</span>。此外设 <span class="math inline">\((S,\mathbb{R})\)</span> 是一个可测空间。</p><p>如果 <span class="math inline">\(f\)</span> 是一个 <span class="math inline">\((S, R)\to S\)</span> 的可测函数映射满足</p><p><span class="math display">\[X_{n+1} = f(X_n, \xi_{n+1}) =F_n(X_0,\xi_1,\xi_2,\ldots,\xi_n),\quad F_n:S\times R^n\to S.\]</span>即 <span class="math inline">\(f(\cdot,\xi_n)\)</span> 是一个由随机序列<span class="math inline">\(\{\xi_n\}\)</span>驱动的映射，则我们就称这是一个随机动力系统。</p><p>注意 <span class="math inline">\(X_n\)</span> 由 <span class="math inline">\(\xi_1\sim\xi_n\)</span> 决定，所以 <span class="math inline">\(\mathcal{F}_n=\sigma(X_0,X_1,\ldots,X_n)=\sigma(X_0,\xi_1,\ldots,\xi_n)\)</span>。</p><p>记 <span class="math inline">\(Q_n(x,A)=\mathbb{P}(f(x, \xi_n)\inA)\)</span>，则 <span class="math inline">\(Q_n\)</span>是一个概率核。设 <span class="math inline">\(L_n\)</span> 是其 Markov生成元。 <span class="math display">\[L_n(g)(x) = \int g(y)Q_n(x,\,\mathrm{d}y)=\mathbb{E}[g(f(x,\xi_n))].\]</span> 则</p><p><span class="math display">\[\begin{align*}\mathbb{E}[g(X_{n+1})|\mathcal{F}_n]&amp;= \mathbb{E}[g(f(X_n,\xi_{n+1}))|\mathcal{F}_n]\\&amp;=\left.\mathbb{E}[g\circ f(x,\xi_{n+1})]\right|_{x=X_n} \\&amp;=\left.\int g(y)Q_{n+1}(x,\,\mathrm{d}y)\right|_{x=X_n}\\&amp;=L_{n+1}(g)(X_n).\end{align*}\]</span> 但是 <span class="math inline">\(L_{n+1}(g)(X_n)\)</span> 是 <span class="math inline">\(X_n\)</span> 的函数，所以它关于 <span class="math inline">\(\sigma(X_n)\)</span>是可测的，而且是有界可测，从而两边对 <span class="math inline">\(\sigma(X_n)\)</span> 这个子 <span class="math inline">\(\sigma\)</span>- 域取条件期望，并注意到 <span class="math inline">\(\sigma(X_n)\subset\mathcal{F}_n\)</span> 有 <span class="math display">\[\mathbb{E}[g(X_{n+1})|\mathcal{F}_n] =\mathbb{E}[g(X_{n+1})|X_n].\]</span> 这正是 Markov 性质。</p><h1 id="stochastic-processes">✅ 35.1 Stochastic Processes</h1><p>本讲介绍了随机过程的定义，以及它们的有限维分布、滤过(filtration)、适应 (adapted) 等概念。</p><h1 id="the-markov-property">✅ 36.1 The Markov property</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义61.1</span>.</span><span class="statement-spah"> </span>我们称随机过程<span class="math inline">\(X_t:(\Omega,\mathcal{F}_t)\to(S_,\mathcal{B})\)</span>具有 Markov 性质，如果对任何有界可测函数 <span class="math inline">\(f\in\mathbb{B}(S,\mathcal{B})\)</span> 有 <span class="math display">\[\mathbb{E}[f(X_t)|\mathcal{F}_s] =\mathbb{E}[f(X_t)|X_s],\quad \mathrm{a.e.}\ \forall s &lt;t.\]</span></p></div><p>即对 <span class="math inline">\(s\)</span>时刻之前的所有历史取条件期望，等于只对 <span class="math inline">\(s\)</span> 时刻的历史取条件期望。</p><p>根据 Doob-Dynkin 引理，不难验证这个定义等价于 <span class="math display">\[\mathbb{E}[f(X_t)|\mathcal{F}_s] = F(X_s),\quad\mathrm{a.e.}\text{ for some }F\in\mathbb{B}(S,\mathcal{B}).\]</span></p><p>上面定义看起来是说，Markov过程是关于过去和当前的。但实际上它也告诉了我们关于未来的信息：</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论61.2</span>.</span><span class="statement-spah"> </span><span class="math display">\[\mathbb{E}[Y|\mathcal{F}_s] = E[Y|X_s],\quad\forall Y\in\mathbb{B}(\Omega, \mathcal{F}^X_{\geq s}).\]</span>注意，<span class="math inline">\(Y\)</span> 来自 <span class="math inline">\(\mathcal{F}^X_{\geq s}=\sigma(X_t:t\geqs)\)</span>，而不是 Filtration <span class="math inline">\(\mathcal{F}_{\geq s}\)</span>。</p></div><p>这个推论的证明很有意思，要用到 Dynkin multiplicative system。</p><p><strong>证明</strong>：考虑所有形如 <span class="math display">\[Y =g_0(X_{t_0})g_1(X_{t_1})\cdots g_n(X_{t_n})\]</span> 的函数，这里 <span class="math inline">\(s =t_0&lt;t_1&lt;\cdots &lt;t_n\)</span>，且每个<span class="math inline">\(g_i\)</span> 都是有界可测的，从而 <span class="math inline">\(Y\)</span> 也是有界可测的，并且 <span class="math inline">\(Y\in\mathcal{F}^X_{\geq s}\)</span>。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理61.3</span>.</span><span class="statement-spah"> </span>设 <span class="math display">\[\mathcal{M} = \{g_0(X_{t_0})g_1(X_{t_1})\cdotsg_n(X_{t_n})\mid n\in\mathbb{Z}_{\geq0},\ s=t_0&lt;t_1&lt;\cdots&lt;t_n,g_j\in\mathbb{B}(S,\mathcal{B})\}.\]</span> 则 <span class="math inline">\(\mathcal{M}\)</span> 是乘法系，且 <span class="math inline">\(\sigma(M) = \mathcal{F}^X_{\geq s}\)</span>。</p></div><p>引理的证明很简单，这里省略。</p><p>回到推论的证明。</p><p>设 <span class="math inline">\(\mathcal{H}\)</span>是所有满足推论要求的函数构成的空间。显然 <span class="math inline">\(\mathcal{H}\)</span> 满足：</p><ol type="1"><li>是向量空间；</li><li>包含常函数 1；</li><li>对有界收敛下封闭</li></ol><p>我们只要再证明 <span class="math inline">\(\mathcal{H}\)</span>包含乘法系 <span class="math inline">\(\mathcal{M}\)</span>，从而根据Dynkin 函数系引理它包含所有关于 <span class="math inline">\(\sigma(\mathcal{M})=\mathcal{F}^X_{\geqs}\)</span> 可测的有界可测函数，这正是所要证明的。</p><p>根据 Markov 性质和 Doob-Dynkin 引理，我们可以记 <span class="math inline">\(\mathbb{E}_{\mathcal{F}_{t_{n-1}}}[g_n(X_{t_n})]=h(X_{t_{n-1}})\)</span>。于是</p><p><span class="math display">\[\begin{aligned}\mathbb{E}_{\mathcal{F}_s}[Y]&amp;=\mathbb{E}_{\mathcal{F}_s}[E_{\mathcal{F}_{t_{n-1}}}[Y]]\\&amp;=\mathbb{E}_{\mathcal{F}_s}[g_0(X_{t_0})\cdotsg_{n-1}(X_{t_{n-1}})h(X_{t_{n-1}})]\\&amp;=\mathbb{E}_{\mathcal{F}_s}[g_0(X_{t_0})\cdots\widetilde{g_{n-1}}(X_{t_{n-1}})]\\&amp;=\cdots\\&amp;=\mathbb{E}_{\mathcal{F}_s}[F(X_{s})]\\&amp;=F(X_s)\end{aligned}\]</span> 再利用 <span class="math inline">\(\mathbb{E}_{X_s}[Y]=\mathbb{E}_{X_s}[\mathbb{E}_{\mathcal{F}_s}[Y]]=\mathbb{E}_{X_s}[F(X_s)]=F(X_s)\)</span>即得所证。<span class="math inline">\(\blacksquare\)</span></p><p>上面是 Markov性质的第一种刻画：将对未来可测的函数对当前和过去取条件期望，相当于只对当前取条件期望。</p><p>本讲接下来用条件独立给出了 Markov 性质的第二种刻画：</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理61.4</span>.</span><span class="statement-spah"> </span>随机过程 <span class="math inline">\(\{X_t\}\)</span> 满足 Markov 性质当且仅当 <span class="math inline">\(\mathcal{F}_s\)</span> 和 <span class="math inline">\(\mathcal{F}^X_{\geq s}\)</span> 关于 <span class="math inline">\(\sigma(X_s)\)</span>是条件独立的，即对任何有界可测函数 <span class="math inline">\(Z\in\mathbb{B}(\Omega,\mathcal{F}_s)\)</span>，<span class="math inline">\(Y\in\mathbb{B}(\Omega,\mathcal{F}^X_{\geqs})\)</span> 有 <span class="math display">\[\mathbb{E}[ZY\mid X_s] =\mathbb{E}[Z\mid X_s]\cdot \mathbb{E}[Y\mid X_s].\]</span></p></div><p>注意到 <span class="math inline">\(\mathcal{F}_s\supset\sigma(X_t:t\leq s)\)</span> 以及 <span class="math inline">\(\mathcal{F}^X_{\geqs}=\sigma(X_t:t\geq s)\)</span>，所以这个结论可以概括为：对 Markov过程，给定当下，过去与未来独立。</p><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>：由于 <span class="math inline">\(Z\)</span> 关于 <span class="math inline">\(\mathcal{F}_s\)</span> 可测，以及 Markov 性质，有<span class="math display">\[\mathbb{E}[ZY\mid\mathcal{F}_s] =Z\mathbb{E}[Y\mid \mathcal{F}_s]=Z\cdot \mathbb{E}[Y\mid X_s].\]</span>两边同时对 <span class="math inline">\(\sigma(X_s)\)</span>取条件期望，并利用条件期望的 Tower 性质，得到 <span class="math display">\[\mathbb{E}[ZY\mid X_s] = \mathbb{E}[Z\midX_s]\cdot \mathbb{E}[Y\mid\mathcal{F}_s].\]</span></p><p><span class="math inline">\(\Leftarrow\)</span>：对任意 <span class="math inline">\(Z\in\mathbb{B}(\Omega,\sigma(X_s))\)</span>，考虑<span class="math inline">\(\mathbb{E}[Zf(X_t)]\)</span>。由条件独立得：</p><p><span class="math display">\[\mathbb{E}[Z\cdot f(X_t)]=\mathbb{E}\big[\mathbb{E}[Z f(X_t)\mid X_s]\big]=\mathbb{E}\big[\mathbb{E}[Z\mid X_s]\cdot\mathbb{E}[f(X_t)\midX_s]\big]=\mathbb{E}[Z\cdot h(X_s)].\]</span> 其中 <span class="math inline">\(h(X_s):=\mathbb{E}[f(X_t)\midX_s]\)</span>。另一方面，根据条件期望定义， <span class="math display">\[\mathbb{E}[Z\cdot f(X_t)] = \mathbb{E}\big[Z\cdot\mathbb{E}[f(X_t)\mid \mathcal{F}_s]\big].\]</span>两个式子的右边相等，所以 <span class="math display">\[\mathbb{E}\big[Z\cdot\mathbb{E}[f(X_t)\mid\mathcal{F}_s]\big]= \mathbb{E}\big[Z\cdot h(X_s)\big].\]</span>而这正是条件期望的“投影特征”：由 <span class="math inline">\(Z\)</span>的任意性，必然有 <span class="math display">\[\mathbb{E}[f(X_t)\mid\mathcal{F}_s] = h(X_s) =\mathbb{E}[f(X_t)\mid X_s],\quad \mathrm{a.e.}\]</span> <span class="math inline">\(\blacksquare\)</span></p><h1 id="probability-kernels-revisited">36.2 Probability KernelsRevisited</h1><p>回顾了之前概率核的概念。没啥新的。</p><h1 id="markov-processes">✅ 37.1 Markov Processes</h1><p>设 <span class="math inline">\(\{X_t\}:(\Omega,\mathcal{F})\to(\mathcal{S},\mathcal{B}(\mathcal{S}))\)</span>是一族随机变量，满足 Markov 性质： <span class="math display">\[\mathbb{E}[f(X_t)\mid \mathcal{F}_s] =\mathbb{E}[f(X_t)\mid X_s],\quad \mathrm{a.e.}\ \forall s&lt;t.\]</span>假设 <span class="math inline">\(\mathcal{S}\)</span> 足够nice，于是我们可以定义正则条件概率 <span class="math inline">\(q_{s,t}=\mathbb{P}(X_t\in B\mid X_s)\)</span> 满足<span class="math display">\[\mathbb{E}[f(X_s)|X_t] =\int_\mathcal{S}f(y)q_{s,t}(X_s,\,\mathrm{d}y)=Q_{s,t}(f(X_s)).\]</span>那么，这些算子 <span class="math inline">\(Q_{s,t}\)</span>之间应该满足怎样的关系呢？</p><p>固定 <span class="math inline">\(r&lt;s&lt;t\)</span>，利用条件期望的Tower 性质，可以得到 <span class="math display">\[Q_{r,t}f(X_r)=\mathbb{E}[f(X_t)\midX_r]=\mathbb{E}[\mathbb{E}[f(X_t)\mid X_s] \midX_r]=\mathbb{E}[Q_{s,t}f(X_s)\mid X_r]=Q_{r,s}Q_{s,t}f(X_r).\]</span>于是正则条件概率 <span class="math inline">\(\{q_{s,t}\}\)</span> 满足<span class="math display">\[q_{r,t}(x, B)=\intq_{r,s}(x,\,\mathrm{d}y)q_{s,t}(y, B).\]</span> 这就是所谓的<strong>Chapman-Kolmogorov</strong> 方程。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义63.1</span>.</span><span class="statement-spah"> </span>Markov过程就是满足 Markov 性质，并且存在概率转移核 <span class="math inline">\(\{Q_{s,t}\}\)</span> 使得 <span class="math display">\[\mathbb{E}[f(X_t)\mid X_s] =Q_{s,t}f(X_s).\]</span></p></div><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题63.2</span>.</span><span class="statement-spah"> </span>独立增量过程是Markov 过程，其中 <span class="math display">\[q_{s,t}(x,B) =\mathbb{E}[\mathbb{1}_B(x + X_t - X_s)].\]</span></p></div><p>视频接下来介绍了 Markov 过程的有限维分布。我们的目标是证明：对任意<span class="math inline">\(t_0&lt;\cdots&lt;t_n\)</span> 与 <span class="math inline">\(B_0,\ldots,B_n\in\mathcal B(\mathcalS)\)</span>，都有 <span class="math display">\[\mathbb P(X_{t_0}\inB_0,\ldots,X_{t_n}\in B_n)=\int_{B_0}\mu_{t_0}(\mathrm dx_0)\int_{B_1}q_{t_0,t_1}(x_0,\mathrm dx_1)\cdots\int_{B_n}q_{t_{n-1},t_n}(x_{n-1},\mathrm d x_n).\]</span>更方便的做法是先证明一个函数版的等式：对任意有界 Borel 函数 <span class="math inline">\(f_0,\dots,f_n:\mathcal S\to\mathbb R\)</span>，有<span class="math display">\[\mathbb E\Big[\prod_{k=0}^nf_k(X_{t_k})\Big]=\int_{\mathcal S}\mu_{t_0}(\mathrmdx_0)\,f_0(x_0)\int_{\mathcal S} q_{t_0,t_1}(x_0,\mathrmdx_1)\,f_1(x_1)\cdots\int_{\mathcal S} q_{t_{n-1},t_n}(x_{n-1},\mathrmdx_n)\,f_n(x_n).\]</span> 然后取 <span class="math inline">\(f_k=\mathbf1_{B_k}\)</span> 即得到有限维分布的核表示。</p><p>对 <span class="math inline">\(n\)</span> 的归纳，当 <span class="math inline">\(n=0\)</span> 时， <span class="math display">\[\mathbb E[f_0(X_{t_0})] = \int_{\mathcal S}f_0(x_0)\,\mu_{t_0}(\mathrm dx_0),\]</span> 这只是 <span class="math inline">\(X_{t_0}\)</span> 分布为<span class="math inline">\(\mu_{t_0}\)</span>的定义，因此命题成立。</p><p>现在假设 <span class="math inline">\((P_{n-1})\)</span>已经成立，固定任意有界 Borel 函数 <span class="math inline">\(f_0,\dots,f_{n-1}\)</span>，它们在下面都视为给定的常量函数族。现在把注意力放在最后一个函数<span class="math inline">\(f_n\)</span> 上。</p><p>对任意有界 Borel 函数 <span class="math inline">\(g:\mathcalS\to\mathbb R\)</span>，定义 <span class="math display">\[\Lambda(g):=\mathbb E\Big[\Big(\prod_{k=0}^{n-1}f_k(X_{t_k})\Big)\,g(X_{t_n})\Big],\]</span> <span class="math display">\[\Phi(g):=\int_{\mathcal S}\mu_{t_0}(\mathrm dx_0)\,f_0(x_0)\int_{\mathcal S}q_{t_0,t_1}(x_0,\mathrm dx_1)\,f_1(x_1)\cdots\int_{\mathcal S}q_{t_{n-1},t_n}(x_{n-1},\mathrmdx_n)\,f_{n-1}(x_{n-1})\,g(x_n).\]</span> 当我们能证明对所有有界 Borel<span class="math inline">\(g\)</span> 都有 <span class="math inline">\(\Lambda(g)=\Phi(g)\)</span> 时，把 <span class="math inline">\(g=f_n\)</span> 代入，就得到结论对 <span class="math inline">\(n\)</span> 的情形成立。</p><p>因此定义函数类 <span class="math display">\[\mathcal H :=\{g\in\mathcal B_b(\mathcal S):\ \Lambda(g)=\Phi(g)\}.\]</span></p><p>接下来要证明 <span class="math inline">\(\mathcal H\)</span> 满足Dynkin 函数系引理的条件，从而 <span class="math inline">\(\mathcalH=\mathcal B_b(\mathcal S)\)</span>。</p><p>首先，<span class="math inline">\(\mathcal H\)</span>是向量空间。</p><p>其次，由单调收敛定理，<span class="math inline">\(\mathcal H\)</span>对有界单调极限封闭。因此 <span class="math inline">\(\mathcal H\)</span>是一个对线性组合与有界单调极限封闭的有界可测函数类，符合 Dynkin函数系引理的结构要求。</p><p>接下来需要一个生成族。假设状态空间 <span class="math inline">\((\mathcal S,\mathcal B(\mathcal S))\)</span>是标准 Borel 空间（或足够 nice），则存在一个可数的 <span class="math inline">\(\pi\)</span>-系统（或代数） <span class="math inline">\(\mathcal C\subset\mathcal B(\mathcal S)\)</span>生成 <span class="math inline">\(\mathcal B(\mathcalS)\)</span>。我们只需在每个 <span class="math inline">\(C\in\mathcalC\)</span> 上验证 <span class="math inline">\(\mathbf 1_C\in\mathcalH\)</span>，即证明 <span class="math display">\[\Lambda(\mathbf 1_C)=\Phi(\mathbf 1_C).\]</span></p><p>取任意 <span class="math inline">\(C\in\mathcal C\)</span>。计算<span class="math display">\[\begin{aligned}\Lambda(\mathbf 1_C)&amp;=\mathbb E\Big[\Big(\prod_{k=0}^{n-1} f_k(X_{t_k})\Big)\,\mathbf1_C(X_{t_n})\Big]\\&amp;=\mathbb E\Big[\Big(\prod_{k=0}^{n-1} f_k(X_{t_k})\Big)\,\mathbbE[\mathbf 1_C(X_{t_n})\mid\mathcal F_{t_{n-1}}]\Big].\end{aligned}\]</span></p><p>利用 Markov 性质和转移核的定义， <span class="math display">\[\mathbb E[\mathbf 1_C(X_{t_n})\mid\mathcal F_{t_{n-1}}]=\mathbb E[\mathbf 1_C(X_{t_n})\mid X_{t_{n-1}}]=q_{t_{n-1},t_n}(X_{t_{n-1}},C),\]</span> 于是 <span class="math display">\[\begin{aligned}\Lambda(\mathbf 1_C)&amp;=\mathbb E\Big[\Big(\prod_{k=0}^{n-2} f_k(X_{t_k})\Big)\,f_{n-1}(X_{t_{n-1}})\,q_{t_{n-1},t_n}(X_{t_{n-1}},C)\Big]\\&amp;=\mathbb E\Big[\prod_{k=0}^{n-2} f_k(X_{t_k})\,h(X_{t_{n-1}})\Big],\end{aligned}\]</span> 其中定义 <span class="math display">\[h(x):=f_{n-1}(x)\,q_{t_{n-1},t_n}(x,C).\]</span> 显然 <span class="math inline">\(h\)</span> 是有界 Borel函数。</p><p>现在可以使用归纳假设 <span class="math inline">\((P_{n-1})\)</span>：它告诉我们，对任意有界 Borel函数 <span class="math inline">\(f_0,\dots,f_{n-2},h\)</span>， <span class="math display">\[\mathbb E\Big[\prod_{k=0}^{n-2} f_k(X_{t_k})\,h(X_{t_{n-1}})\Big]=\int_{\mathcal S}\mu_{t_0}(\mathrm dx_0)\,f_0(x_0)\cdots\int_{\mathcal S}q_{t_{n-2},t_{n-1}}(x_{n-2},\mathrmdx_{n-1})\,h(x_{n-1}).\]</span></p><p>代入当前的 <span class="math inline">\(h\)</span> 得 <span class="math display">\[\begin{aligned}\Lambda(\mathbf 1_C)&amp;=\int_{\mathcal S}\mu_{t_0}(\mathrm dx_0)\,f_0(x_0)\int_{\mathcal S}q_{t_0,t_1}(x_0,\mathrm dx_1)\,f_1(x_1)\cdots\\&amp;\quad\cdots\int_{\mathcal S}q_{t_{n-2},t_{n-1}}(x_{n-2},\mathrm dx_{n-1})\,f_{n-1}(x_{n-1})\,q_{t_{n-1},t_n}(x_{n-1},C).\end{aligned}\]</span></p><p>注意 <span class="math display">\[q_{t_{n-1},t_n}(x_{n-1},C)=\int_{\mathcal S}\mathbf 1_C(x_n)\,q_{t_{n-1},t_n}(x_{n-1},\mathrmdx_n),\]</span> 于是 <span class="math display">\[\begin{aligned}\Lambda(\mathbf 1_C)&amp;=\int_{\mathcal S}\mu_{t_0}(\mathrm dx_0)\,f_0(x_0)\int_{\mathcal S}q_{t_0,t_1}(x_0,\mathrm dx_1)\,f_1(x_1)\cdots\\&amp;\quad\cdots\int_{\mathcal S}q_{t_{n-2},t_{n-1}}(x_{n-2},\mathrmdx_{n-1})\,f_{n-1}(x_{n-1})\int_{\mathcal S}q_{t_{n-1},t_n}(x_{n-1},\mathrm dx_n)\,\mathbf1_C(x_n)\\&amp;=\Phi(\mathbf 1_C).\end{aligned}\]</span></p><p>因此对每个 <span class="math inline">\(C\in\mathcal C\)</span>，<span class="math inline">\(\mathbf 1_C\in\mathcal H\)</span>。</p><p>综上，<span class="math inline">\(\mathcal H\)</span>是一个包含生成族指标函数的函数类，对线性组合和有界单调极限封闭。由Dynkin 函数系引理可知 <span class="math display">\[\mathcal H = \mathcal B_b(\mathcal S),\]</span></p><h1 id="kolmogorovs-extended-extension-theorem">✅ 37.2 Kolmogorov’s(Extended) Extension Theorem</h1><p>怎么构造一个 Markov 过程？</p><p>记 <span class="math inline">\(\Omega = \{\omega: T\to\mathcal{S}\}\)</span> 是所有从时间 <span class="math inline">\(T\)</span> 到状态空间 <span class="math inline">\(\mathcal{S}\)</span> 的映射组成的集合。对 <span class="math inline">\(t\in T\)</span>，令 <span class="math inline">\(\pi_t\)</span> 为坐标映射 <span class="math display">\[\pi_t(\omega) = \omega(t).\]</span> 定义 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\mathcal{B}^{\otimes T} = \sigma(\{\pi_t, t\inT\})\)</span>。即 <span class="math inline">\(\mathcal{B}^{\otimesT}\)</span> 是使得所有坐标映射都是可测映射的最小 <span class="math inline">\(\sigma\)</span>- 域。</p><p>我们希望在这个乘积 <span class="math inline">\(\sigma\)</span>-域上定义测度 <span class="math inline">\(\mathbb{P}\)</span>。我们有的是<span class="math inline">\(\mathbb{P}\)</span> 的所有有限维投影： <span class="math display">\[\pi_\Lambda \mathbb{P}= \mu_{\Lambda}.\]</span>其中 <span class="math inline">\(\Lambda\subset T\)</span>是一个有限集合。<span class="math inline">\(\mathbb{P}\)</span>必须满足<strong>相容性条件</strong>。</p><p>考虑代数 <span class="math display">\[\mathcal{A}= \cup_{\Lambda\subset T\text{ finite}}\sigma(\pi_\Lambda).\]</span> 定义其上的概率为<span class="math display">\[\mathbb{P}(A) = \mu_\Lambda(B),\quad B =\pi_\Lambda(A).\]</span> 这是一个良定义的概率，不依赖于 <span class="math inline">\(\Lambda\)</span>的选择。但是，这只是代数上的有限可加测度，它是可数可加的吗？</p><p>Kolmogorov本质上是一个拓扑结论，在一个可分度量空间上，其测度具有内正则性质： <span class="math display">\[\mu(E)=\sup\{\mu(K)\mid K\subset E,\ K \text{compact }\}.\]</span>并且紧集也满足有限交性质，从而代数上的有限可加测度也是可数可加测度。</p><p>给定指标集 <span class="math inline">\(T\)</span>，每个 <span class="math inline">\(t\in T\)</span> 上有 Polish 空间 <span class="math inline">\((X_t,\Sigma_t)\)</span>（<span class="math inline">\(\Sigma_t\)</span> 为 Borel <span class="math inline">\(\sigma\)</span> 代数）。对每个有限子集 <span class="math inline">\(F\subset T\)</span> 给定概率测度 <span class="math inline">\(P_F\)</span> 于 <span class="math inline">\((X_F,\Sigma_F)\)</span>，并满足相容性：若 <span class="math inline">\(G\subset F\)</span> 且 <span class="math inline">\(E\in\Sigma_F\)</span>，则 <span class="math inline">\(P_F(E)=P_G(\pi_{FG}(E))\)</span>。定义柱状代数<span class="math display">\[\mathcal A=\text{由所有 }A\times X_{-F}\ (F\subset T\ \text{有限},\A\in\Sigma_F)\ \text{生成的代数}.\]</span> 在生成元上置 <span class="math display">\[P(A\times X_{-F})=P_F(A).\]</span> 相容性保证 <span class="math inline">\(P\)</span> 在 <span class="math inline">\(\mathcal A\)</span> 上良定且有限可加；一般而言<span class="math inline">\(P\)</span> 未必可数可加。若 <span class="math inline">\(T\)</span> 无穷，则 <span class="math inline">\(\mathcal A\)</span> 即无限乘积 <span class="math inline">\(X=\prod_{t\in T}X_t\)</span>的有限维柱状代数。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理64.1</span>.</span><span class="statement-spah"> </span>在 Polish 空间<span class="math inline">\((X,\mathcal B(X))\)</span> 上，每个有限Borel 测度 <span class="math inline">\(\mu\)</span> 是紧集内正则：对任意<span class="math inline">\(A\in\mathcal B(X)\)</span> 与任意 <span class="math inline">\(\varepsilon&gt;0\)</span>，存在紧集 <span class="math inline">\(K\subset A\)</span> 使得 <span class="math inline">\(\mu(A)\le \mu(K)+\varepsilon\)</span>。</p></div><p>证明：先取紧致逼近全集。由紧性定理，存在递增紧集 <span class="math inline">\(K_n\uparrow X\)</span> 使 <span class="math inline">\(\mu(K_n)\uparrow\mu(X)\)</span>。对任意开集 <span class="math inline">\(U\)</span> 令 <span class="math display">\[F_{n,m}:=\{x\in U:\ \mathrm{dist}(x,X\setminus U)\ge 1/m\}\cap K_n,\]</span> 则 <span class="math inline">\(F_{n,m}\)</span> 紧且 <span class="math inline">\(F_{n,m}\uparrow U\)</span>，据从下连续性有 <span class="math inline">\(\mu(U)=\sup_{n,m}\mu(F_{n,m})\)</span>。对一般<span class="math inline">\(A\)</span> 取开集 <span class="math inline">\(U\supset A\)</span> 使 <span class="math inline">\(\mu(U)\le \mu(A)+\varepsilon\)</span>，再取某个<span class="math inline">\(F_{n,m}\subset U\)</span> 使 <span class="math inline">\(\mu(U)\le \mu(F_{n,m})+\varepsilon\)</span>，令<span class="math inline">\(K=A\cap F_{n,m}\)</span> 即得 <span class="math inline">\(\mu(A)\le \mu(K)+2\varepsilon\)</span>，令 <span class="math inline">\(\varepsilon\downarrow0\)</span> 即可。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理64.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(E=\big(\prod_{t\in F}E_t\big)\timesX_{-F}\)</span> 为有限维可测矩形，<span class="math inline">\(F\)</span>有限，<span class="math inline">\(E_t\in\Sigma_t\)</span>。对任意 <span class="math inline">\(\varepsilon&gt;0\)</span>，存在紧集 <span class="math inline">\(K_t\subset E_t\)</span> 使 <span class="math display">\[C:=\Big(\prod_{t\in F}K_t\Big)\times X_{-F}\subset E,\qquad P(E)\leP(C)+\varepsilon .\]</span></p></div><p>证明：令 <span class="math inline">\(Q_t\)</span> 为 <span class="math inline">\(P_F\)</span> 的第 <span class="math inline">\(t\)</span> 坐标边缘。由上引理，取紧 <span class="math inline">\(K_t\subset E_t\)</span> 使 <span class="math inline">\(Q_t(E_t)\leQ_t(K_t)+\varepsilon/|F|\)</span>。由联合到边缘的粗估计得 <span class="math inline">\(P(E)-P(C)\le \sum_{t\inF}\big(Q_t(E_t)-Q_t(K_t)\big)&lt;\varepsilon\)</span>。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理64.3</span>.</span><span class="statement-spah"> </span>记 <span class="math display">\[\mathcal C=\Big\{\Big(\prod_{t\in F}K_t\Big)\times X_{-F}: F\subset T\\text{有限},\ K_t\subset X_t\ \text{紧}\Big\}\subset\mathcal A .\]</span> 则对任意有限维可测矩形 <span class="math inline">\(E\)</span>与任意 <span class="math inline">\(\varepsilon&gt;0\)</span>，有 <span class="math display">\[P(E)=\sup\{P(C): C\in\mathcal C,\ C\subset E\}.\]</span></p></div><p>证明：由上一个引理取紧矩形 <span class="math inline">\(C\subsetE\)</span> 使差值小于 <span class="math inline">\(\varepsilon\)</span>，取上确界即得。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理64.4</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\{C_n\}_{n\ge1}\subset\mathcal C\)</span> 且 <span class="math inline">\(\bigcap_{n\ge1}C_n=\varnothing\)</span>，则存在<span class="math inline">\(N\)</span> 使 <span class="math inline">\(\bigcap_{n=1}^NC_n=\varnothing\)</span>。</p></div><p>证明：写作 <span class="math inline">\(C_n=\big(\prod_{t\inF_n}K_{n,t}\big)\times X_{-F_n}\)</span>，令 <span class="math inline">\(J=\bigcup_n F_n\)</span>（可数）。则 <span class="math display">\[\bigcap_{n\ge1}C_n=\Big(\prod_{t\in J}\bigcap_{n:\,t\inF_n}K_{n,t}\Big)\times X_{-J}.\]</span> 若左端为空，则存在 <span class="math inline">\(t_0\inJ\)</span> 使 <span class="math inline">\(\bigcap_{n:\,t_0\inF_n}K_{n,t_0}=\varnothing\)</span>。因紧集族满足有限交性质，存在有限子族已交空，对应得到某个有限<span class="math inline">\(N\)</span> 使 <span class="math inline">\(\bigcap_{n=1}^NC_n=\varnothing\)</span>。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理64.5</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(E_n\downarrow\varnothing\)</span> 于 <span class="math inline">\(\mathcal A\)</span>，则 <span class="math inline">\(P(E_n)\downarrow0\)</span>。</p></div><p>证明：给定 <span class="math inline">\(\varepsilon&gt;0\)</span>，由内逼近引理取 <span class="math inline">\(C_n\in\mathcal C\)</span>，<span class="math inline">\(C_n\subset E_n\)</span>，且 <span class="math inline">\(P(E_n)\le P(C_n)+\varepsilon 2^{-n}\)</span>。若<span class="math inline">\(\bigcap_n C_n\ne\varnothing\)</span> 则与<span class="math inline">\(E_n\downarrow\varnothing\)</span>矛盾，据上引理得某个 <span class="math inline">\(N\)</span> 使 <span class="math inline">\(\bigcap_{n=1}^NC_n=\varnothing\)</span>。由有限可加性与单调性，<span class="math display">\[0=P\Big(\bigcap_{n=1}^N C_n\Big)\ge\sum_{n=1}^N\big(P(C_n)-P(E_{n+1})\big).\]</span> 令 <span class="math inline">\(N\to\infty\)</span> 并代入<span class="math inline">\(P(E_n)\le P(C_n)+\varepsilon 2^{-n}\)</span>得 <span class="math inline">\(\limsup_n P(E_n)\le\varepsilon\)</span>，再令 <span class="math inline">\(\varepsilon\downarrow0\)</span> 即得 <span class="math inline">\(P(E_n)\downarrow0\)</span>。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理64.6</span>.</span><span class="statement-spah"> </span>上述 <span class="math inline">\(P\)</span> 在柱状代数 <span class="math inline">\(\mathcal A\)</span> 上可数可加，故由 Carathéodory定理存在唯一扩张 <span class="math inline">\(\overline P\)</span> 于<span class="math inline">\(\sigma(\mathcal A)=\bigotimes_{t\inT}\Sigma_t\)</span>，并满足对每个有限 <span class="math inline">\(F\)</span> 有 <span class="math inline">\(\overline P\circ\pi_F^{-1}=P_F\)</span>。</p></div><h1 id="path-space">✅ 38.1 Path Space</h1><p>设 <span class="math inline">\(\Omega\)</span> 是一个集合，<span class="math inline">\(\mathcal C\subset\mathcal P(\Omega)\)</span>任意一族集合 （可以是不可数的）。记 <span class="math inline">\(\sigma(\mathcal C)\)</span> 为由它生成的 <span class="math inline">\(\sigma\)</span>-代数。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理65.1</span>.</span><span class="statement-spah"> </span>对任意 <span class="math inline">\(A\in\sigma(\mathcalC)\)</span>，都存在一个<strong>可数子族</strong> <span class="math inline">\(\mathcal C_A\subset\mathcal C\)</span>，使得 <span class="math display">\[A\in\sigma(\mathcal C_A).\]</span></p></div><p>也就是说：<strong>每一个可测集合，只需要可数多个生成元就够了。</strong></p><p><strong>证明</strong>：定义 <span class="math display">\[\mathcal D := \{A\subset\Omega:\ \exists\text{可数 } \mathcalC_0\subset\mathcal C,\ A\in\sigma(\mathcal C_0)\}.\]</span></p><ol type="1"><li><p><span class="math inline">\(\mathcal C\subset\mathcalD\)</span>： 对任意 <span class="math inline">\(E\in\mathcalC\)</span>，取 <span class="math inline">\(\mathcalC_0=\{E\}\)</span>（显然是可数的）， 那么 <span class="math inline">\(E\in\sigma(\mathcal C_0)\)</span>，所以 <span class="math inline">\(E\in\mathcal D\)</span>。</p></li><li><p><span class="math inline">\(\mathcal D\)</span> 是一个 <span class="math inline">\(\sigma\)</span>-代数：</p><ul><li>若 <span class="math inline">\(A\in\mathcal D\)</span>，由某个可数<span class="math inline">\(\mathcal C_0\)</span> 生成， 那 <span class="math inline">\(A^c\in\sigma(\mathcal C_0)\)</span>，故 <span class="math inline">\(A^c\in\mathcal D\)</span>。</li><li>若 <span class="math inline">\(A_n\in\mathcalD\)</span>，各自对应可数 <span class="math inline">\(\mathcalC_n\)</span>， 取 <span class="math inline">\(\mathcalC'=\bigcup_n\mathcal C_n\)</span>， 可数个可数集的并仍然是可数，所以<span class="math inline">\(\mathcal C'\)</span> 可数； 每个 <span class="math inline">\(A_n\in\sigma(\mathcal C_n)\subset\sigma(\mathcalC')\)</span>， 因而 <span class="math inline">\(\bigcup_nA_n\in\sigma(\mathcal C')\)</span>，故 <span class="math inline">\(\bigcup_n A_n\in\mathcal D\)</span>。</li></ul></li></ol><p>由 1 和 2：<span class="math inline">\(\mathcal D\)</span> 是一个<span class="math inline">\(\sigma\)</span>-代数且包含 <span class="math inline">\(\mathcal C\)</span>，所以 <span class="math inline">\(\sigma(\mathcal C)\subset\mathcal D\)</span>。</p><p>另一方面，对任何 <span class="math inline">\(A\in\mathcalD\)</span>，有 <span class="math inline">\(A\in\sigma(\mathcalC_0)\subset\sigma(\mathcal C)\)</span>，所以 <span class="math inline">\(\mathcal D\subset\sigma(\mathcal C)\)</span>。</p><p>于是 <span class="math inline">\(\mathcal D = \sigma(\mathcalC)\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>在路径空间里面，<span class="math inline">\(\mathcal C\)</span>可以取为所有的有限维柱集，它们生成了乘积空间上的 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\mathcal{B}^{\otimesT}\)</span>。所以这里面任何可测集实际上只依赖于可数多个有限维柱集，从而只依赖于可数多个坐标。于是像<span class="math inline">\(\{\omega(t)\text{ is continous}\}\)</span>这种依赖不可数多个坐标的事件就不可能在乘积 <span class="math inline">\(\sigma\)</span>- 域里面。</p><p>在独立增量过程的情形，转移概率核为 <span class="math display">\[q_{s,t}(x, B) = \mathbb{E}[\mathbb{1}_B(x + X_t -X_s)].\]</span> 这是因为 <span class="math display">\[\mathbb{P}(X_t\inB\mid X_s = x) = \mathbb{P}((X_t - X_s) + x\in B).\]</span></p><h1 id="time-homogeneous-markov-processes">38.2 Time Homogeneous MarkovProcesses</h1><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理66.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(X\)</span> 是齐次 Markov 链，<span class="math inline">\(F\in\mathcal{B}(\mathcal{S}^{\otimesT})\)</span>，则 <span class="math display">\[x\to\mathbb{E}^x[F(X)]\]</span> 是可测函数。进一步，对任何初始分布 <span class="math inline">\(\nu_0\)</span>， <span class="math display">\[\mathbb{E}^{\nu_0}[F(X_{t+})\mid\mathcal{F}_t] =\mathbb{E}^{\nu_0}[F(X_{t+})\midX_t]=\mathbb{E}^{X_t}[F(X)].\]</span></p></div><p>注意这里第一个断言不需要齐次性质。但是第二个是需要的。</p><p>这个定理的意义是，记 <span class="math inline">\(g(x)=\mathbb{E}^x[F(X)]\)</span>，根据第一个断言这是关于 <span class="math inline">\(x\)</span> 的可测函数，则第二个断言说： <span class="math display">\[g(X_t) = \mathbb{E}^{X_t}[F(X)].\]</span></p><p><strong>证明</strong>：2 的前半部分是 36.1 节 Markov property中的内容。下面只要证 1 和 2 的后半部分。</p><p>设 <span class="math inline">\(0=t_0&lt;t_1&lt;\cdots&lt;t_n\)</span>，<span class="math inline">\(F\)</span> 形如 <span class="math display">\[F(\omega)=\prod_{k=0}^nf_k(\omega(t_k)).\]</span>我们将对这样的 <span class="math inline">\(F\)</span> 证明，然后使用Dynkin 的函数形式引理。</p><ol type="1"><li>对这样的 <span class="math inline">\(F\)</span> 有 <span class="math display">\[\mathbb{E}^x[F(X)] = \mathbb{E}^x[\prod_{k=0}^nf_k(X_{t_k})]=\int \delta_x\,\mathrm{d}x\intq_{t_0,t_1}(x_0,\,\mathrm{d}x_1)\cdots\intq_{t_{n-1},t_n}(x_{n-1},\,\mathrm{d}x_n)\prod_{k=0}^nf(x_k).\]</span>上式等于 <span class="math display">\[\mathbb{E}_{\delta_x}[f_0Q_{t_0,t_1}(\cdotsf_{n-1}(Q_{t_{n-1},t_n}f_n)\cdots)]=f_0(x)Q_{t_0,t_1}(\cdotsf_{n-1}(Q_{t_{n-1},t_n}f_n)\cdots)(x).\]</span> 没问题。</li><li>还是取 <span class="math display">\[0=t_0&lt;t_1&lt;\dots&lt;t_n,\quadF(\omega)=\prod_{k=0}^n f_k(\omega(t_k)).\]</span> 则 <span class="math display">\[F(X_{t+})=\prod_{k=0}^nf_k\big(X_{t+t_k}\big).\]</span> 设 <span class="math inline">\(s_k=t+t_k\)</span>，于是 <span class="math display">\[t=s_0&lt;s_1&lt;\dots&lt;s_n,\quadF(X_{t+})=\prod_{k=0}^n f_k(X_{s_k}).\]</span> 固定 <span class="math inline">\(x\)</span>，考虑从时间 <span class="math inline">\(t\)</span> 开始、初值为 <span class="math inline">\(x\)</span> 的链 <span class="math inline">\((X_{t+s})_{s\ge0}\)</span>。对这个过程，用 1里已经写出的公式（只是把 <span class="math inline">\(t_0\)</span> 从 0换成 <span class="math inline">\(t\)</span>）得到： <span class="math display">\[\mathbb{E}^x\Big[\prod_{k=0}^n f_k(X_{s_k})\Big]=f_0(x)\,Q_{s_0,s_1}\Big(f_1\,Q_{s_1,s_2}(\cdotsf_{n-1}(Q_{s_{n-1},s_n}f_n)\cdots)\Big)(x).\]</span> 注意这里 <span class="math inline">\(s_0=t,s_1=t+t_1,\dots\)</span>。</li></ol><p>由于链是齐次的，所以 <span class="math inline">\(Q_{s_{k-1},s_k}=Q_{t_{k-1},t_k}\)</span> 对所有<span class="math inline">\(k\)</span> 成立，于是上面的式子化简为 <span class="math display">\[\mathbb{E}^x[F(X_{t+})]= f_0(x)\,Q_{t_0,t_1}\Big(f_1\,Q_{t_1,t_2}(\cdotsf_{n-1}(Q_{t_{n-1},t_n}f_n)\cdots)\Big)(x).\]</span></p><p>但右边正是第 1 点中得到的 <span class="math inline">\(\mathbb{E}^x[F(X)]\)</span>的表达式。所以我们得到一个关键等式： <span class="math display">\[\mathbb{E}^x[F(X_{t+})]=\mathbb{E}^x[F(X)]=g(x)\]</span>对所有 <span class="math inline">\(x\)</span> 均成立。</p><p>也就是说：<strong>从时刻 (t)</strong> 往后的整条“未来路径”的分布与“从0 开始、初值为 <span class="math inline">\(x\)</span>”的那条链是一样的，这一步用到了齐次性。由 36.1 的 Markov 性质，我们已经知道存在某个可测函数 <span class="math inline">\(h\)</span> 使得 <span class="math display">\[\mathbb{E}^{\nu_0}[F(X_{t+})\midX_t]=h(X_t).\]</span> 并且按定义有 <span class="math display">\[h(x)=\mathbb{E}^x[F(X_{t+})].\]</span></p><p>第一步刚刚证明了 <span class="math inline">\(\mathbb{E}^x[F(X_{t+})]=\mathbb{E}^x[F(X)]=g(x)\)</span>，因此<span class="math display">\[h(x)=g(x),\quad\forall x.\]</span> 从而<span class="math display">\[\mathbb{E}^{\nu_0}[F(X_{t+})\midX_t]=g(X_t)=\mathbb{E}^{X_t}[F(X)].\]</span>这就完成了第二点的后半部分，对柱状 <span class="math inline">\(F\)</span> 成立。</p><h1 id="markov-matrix">✅ 39.1 Markov Matrix</h1><p>无要点</p><h1 id="markov-generator">✅ 39.2 Markov Generator</h1><p>这一讲介绍了，Chapman-Kolmogorov 方程给出的算子方程 <span class="math display">\[Q_{t+s}=Q_tQ_s,\quad Q_0=I.\]</span> 其解应该形如<span class="math inline">\(Q = \exp(tA)\)</span>，其中 <span class="math inline">\(A\)</span> 是某个有界算子。</p><p><span class="math inline">\(A\)</span> 不难猜出来，它就是 <span class="math display">\[A = \lim_{t\to 0}\frac{\mathrmd}{\mathrm{d}t}Q_t\bigg|_{t=0}.\]</span></p><h1 id="operator-norm-continuity">✅ 40.1 Operator Norm Continuity</h1><p>介绍了一些泛函中关于算子范数的内容（这里不再整理）。还介绍了可数情形的算子，如果算子可以用矩阵的形式表示时，算子的范数。</p><p>如果 <span class="math inline">\(a=(a_{ij})\)</span> 满足</p><p><span class="math display">\[\|a\|=\sup_{i}\sum_{j}|a_{ij}|&lt;\infty.\]</span></p><p>那么由 <span class="math display">\[Af(i) = \sum_ja_{ij}f(j)\]</span> 定义的算子是有界算子，并且 <span class="math inline">\(\|A\|=\|a\|\)</span>。</p><h1 id="bounded-generators">✅ 40.2 Bounded Generators</h1><p>设 <span class="math inline">\(B_b(S)\)</span> 是测度空间 <span class="math inline">\((S,\mathcal B)\)</span> 上有界可测函数的 Banach空间，范数为 <span class="math inline">\(\|f\|_\infty\)</span>。 <span class="math inline">\((Q_t)_{t\ge0}\)</span> 是一族 <strong>Markov迁移算子</strong>，也就是：</p><ul><li>每个 <span class="math inline">\(Q_t : B_b(S)\to B_b(S)\)</span>是线性的、正的；</li><li><span class="math inline">\(Q_t\mathbf 1=\mathbf 1\)</span>；</li><li>半群性质：<span class="math inline">\(Q_{t+s}=Q_tQ_s\)</span>，<span class="math inline">\(Q_0=I\)</span>（恒等算子）。</li></ul><p>因为 <span class="math inline">\(Q_t\)</span> 是 Markov 算子，在<span class="math inline">\(\|\cdot\|_\infty\)</span>下都是压缩映射，<span class="math inline">\(\|Q_t\|_{\mathrm{op}}\le1\)</span>。</p><p>假设再多一点正则性：</p><p><span class="math display">\[\lim_{t\downarrow 0}\|Q_t -I\|_{\mathrm{op}} = 0.\]</span></p><p>这叫“在 <span class="math inline">\(t=0\)</span>的算子范数连续”，也就是很小时间步 <span class="math inline">\(t\)</span>对任意有界可测函数几乎“不做事”。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理70.1</span>.</span><span class="statement-spah"></span>在上述假设下，存在一个有界线性算子 <span class="math display">\[A= \lim_{t\downarrow0}\frac{Q_t - I}{t}\]</span>（极限在算子范数意义下存在），并且对所有 <span class="math inline">\(t\ge0\)</span>, <span class="math display">\[Q_t =e^{tA} := \sum_{n=0}^\infty \frac{t^n}{n!} A^n.\]</span>级数在算子范数下收敛。</p><p>从而 <span class="math inline">\(t\mapsto Q_t\)</span> 在 <span class="math inline">\([0,\infty)\)</span> 上在算子范数意义下可微，并满足<span class="math display">\[\frac{d}{dt}Q_t = Q_tA = AQ_t, \qquadQ_0=I.\]</span> 这是 Kolmogorov 的正向 / 反向方程的算子形式。</p></div><p><strong>证明</strong>：<strong>第一步：从 <span class="math inline">\(0\)</span> 点连续到各点连续</strong></p><p>利用半群性质和 <span class="math inline">\(\|Q_t\|\le1\)</span>，先说明：只要在 <span class="math inline">\(0\)</span> 点算子范数连续，则在每个 <span class="math inline">\(t\)</span>都算子范数连续，并且在每个有限区间上一致连续。</p><p>对任意固定 <span class="math inline">\(s\ge0\)</span> 以及 <span class="math inline">\(h&gt;0\)</span>，由半群性质有 <span class="math display">\[Q_{s+h}-Q_s=Q_sQ_h-Q_s=Q_s(Q_h-I).\]</span> 于是 <span class="math display">\[\|Q_{s+h}-Q_s\|\le\|Q_s\|\cdot\|Q_h-I\|\le\|Q_h-I\|.\]</span> 由已知 <span class="math inline">\(\|Q_h-I\|\to0\)</span>，得出 <span class="math inline">\(t\mapsto Q_t\)</span> 在任意 <span class="math inline">\(s\)</span> 处右连续。类似地，由 <span class="math display">\[Q_s-Q_{s-h}=Q_{s-h}(Q_h-I)\]</span> 得到左连续。故 <span class="math inline">\(t\mapstoQ_t\)</span> 在每个 <span class="math inline">\(t\ge0\)</span>都算子范数连续。 再注意到上述估计与 <span class="math inline">\(s\)</span> 无关，可知在任意有限区间 <span class="math inline">\([0,T]\)</span> 上 <span class="math inline">\(t\mapsto Q_t\)</span> 一致连续。</p><p><strong>第二步：定义平滑算子 <span class="math inline">\(B_\varepsilon\)</span> 并证明其可逆</strong></p><p>固定 <span class="math inline">\(\varepsilon&gt;0\)</span>，定义有界算子 <span class="math display">\[B_\varepsilon=\frac{1}{\varepsilon}\int_0^\varepsilonQ_s\,\mathrm{d}s.\]</span> 即对 <span class="math inline">\(f\in B_b(S)\)</span> 和 <span class="math inline">\(x\in S\)</span>， <span class="math display">\[(B_\varepsilon f)(x)=\frac{1}{\varepsilon}\int_0^\varepsilonQ_sf(x)\,\mathrm{d}s.\]</span></p><p>由于对任意 <span class="math inline">\(f\in B_b(S)\)</span>，有 <span class="math display">\[\|Q_{s+h}f-Q_sf\|_\infty\le\|Q_{s+h}-Q_s\|\|f\|_\infty\xrightarrow[h\to0]{}0.\]</span> 所以对每个 <span class="math inline">\(x\in S\)</span>，函数<span class="math display">\[s\longmapsto Q_sf(x)\]</span> 在每个 <span class="math inline">\(s\)</span>处连续，从而可积，上式定义良好。并且 <span class="math display">\[\|B_\varepsilon\|\le\frac{1}{\varepsilon}\int_0^\varepsilon\|Q_s\|\,\mathrm{d}s\le1.\]</span></p><p>注意到 <span class="math display">\[B_\epsilon Q_t f =\frac{1}{\epsilon}\int_0^\epsilon Q_{t+s}f\,\mathrm{d}s.\]</span> 即<span class="math display">\[B_\epsilon Q_t  =\frac{1}{\epsilon}\int_0^\epsilon Q_{t+s}\,\mathrm{d}s =\frac{1}{\epsilon}\int_t^{t+\epsilon} Q_{s}\,\mathrm{d}s.\]</span>所以函数 <span class="math inline">\(t\to B_\epsilon Q_t\)</span>是可微的，其导数为 <span class="math display">\[\frac{\mathrmd}{\mathrm{d}t} (B_\epsilon Q_t) = \frac{Q_{t+\epsilon}-Q_t}{\epsilon}\]</span></p><h1 id="hitting-times">42.2 Hitting Times</h1><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理71.1</span>.</span><span class="statement-spah"> </span><span class="math display">\[\mathbb{E}^x[F(X)] = \int_Sq(x,\,\mathrm{d}y)\mathbb{E}^y[F(x, X)].\]</span></p></div><h1 id="invariant-distributions">✅ 44.2 Invariant Distributions</h1><h1 id="stopping-times">✅ 45.1 Stopping Times</h1><p>关于停时的基本知识，无要点。</p><h1 id="the-strong-markov-property">✅ 46.1 The Strong MarkovProperty</h1><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理74.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\nu\)</span> 是 Markov 链的初始分布，<span class="math inline">\(\tau\)</span> 是停时，则 <span class="math display">\[\mathbb{E}^\nu[F(X_{\tau+})\mid\mathcal F_\tau] =\mathbb{E}^x [F(X)]\Big|_{x=X_\tau},\quad \text{a.e. on}\{\tau&lt;\infty\}.\]</span></p></div><p><strong>证明</strong>： <span class="math display">\[\begin{aligned}\mathbb{E}^\nu[F(X_{\tau+})\mid\mathcalF_\tau]\mathbb{1}_{\{\tau&lt;\infty\}}&amp;=\sum_{n=0}^\infty\mathbb{E}^\nu[F(X_{\tau+})\mid\mathcal F_n]\mathbb{1}_{\{\tau=n\}}\\&amp;=\sum_{n=0}^\infty\mathbb{E}^\nu[F(X_{\tau+})\mathbb{1}_{\{\tau=n\}}\mid\mathcal F_n]\\&amp;=\sum_{n=0}^\infty \underbrace{\mathbb{E}^\nu[F(X_{n+})\mid\mathcalF_n]}_{\mathbb{E}^x [F(X)]\Big|_{x=X_n}}\mathbb{1}_{\{\tau=n\}}.\end{aligned}\]</span> 即如果令 <span class="math inline">\(g(x)=\mathbb{E}^x[F(X)]\)</span>，则 <span class="math display">\[\text{The above }=\sum_{n=0}^\inftyg(X_n)\mathbb{1}_{\{\tau=n\}}=g(X_\tau)\mathbb{1}_{\{\tau&lt;\infty\}}.\]</span><span class="math inline">\(\blacksquare\)</span></p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论74.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\((X_n)_{n\ge0}\)</span> 是一个取值在离散空间 <span class="math inline">\(S\)</span> 中的 Markov 链。对任何 <span class="math inline">\(x\in S\)</span>，对 <span class="math inline">\(A_x=\{\tau&lt;\infty,X_\tau=x\}\)</span>取条件，则 <span class="math inline">\(\mathcal F_\tau\)</span> 和 <span class="math inline">\(X_{\tau + n}\)</span> 是独立的，且 <span class="math inline">\((X_{\tau + n})\)</span> 和 <span class="math inline">\((X_n)\)</span> 有相同的分布。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(Y\in\mathbb{B}(\Omega,\mathcalF_\tau)\)</span>，则 <span class="math display">\[\begin{aligned}\mathbb{E}^\nu[F(X_{\tau+})\,Y\mathbb{1}_{A_x}]&amp;=\mathbb{E}^\nu[\mathbb{E}[F(X_{\tau+})\mid\mathcalF_\tau]\,Y\mathbb{1}_{A_x}]\\&amp;\overset{\text{strong Markovproperty}}{=}\mathbb{E}^\nu[\mathbb{E}^{X_\tau}[F(X)]\,Y\mathbb{1}_{A_x}]\\&amp;\overset{\mathbb{E}^x[F(X)]\text{ is ascalar}}{=}\mathbb{E}^x[F(X)]\cdot \mathbb{E}^\nu[Y\mathbb{1}_{A_x}].\end{aligned}\]</span> 两边同时除以 <span class="math inline">\(\mathbb{P}^\nu(A_x)\)</span> 可得 <span class="math display">\[\mathbb{E}^\nu[F(X_{\tau+})Y \mid A_x] =\mathbb{E}^x[F(X)]\cdot \mathbb{E}^\nu[Y\mid A_x].\]</span></p><p>特别地，取 <span class="math inline">\(Y\equiv1\)</span>，得 <span class="math display">\[\mathbb E^\nu[F(X_{\tau+})\mid A_x]=\mathbbE^x[F(X)].\]</span> 所以在事件 <span class="math inline">\(A_x\)</span>条件下， <span class="math display">\[(X_{\tau+}) \overset{d}{=} (X) \\text{under }\mathbb{P}^x.\]</span> 不仅如此，代入以后我们还有对任意有界<span class="math inline">\(Y\in\mathcal F_\tau\)</span> 与任意未来泛函<span class="math inline">\(F\)</span>，都有乘积分解： <span class="math display">\[\mathbb{E}^\nu[F(X_{\tau+})\,Y\mathbb{1}_{A_x}]=\mathbb{E}^\nu[F(X_{\tau+})\mathbb{1}_{A_x}]\cdot\mathbb{E}^\nu[Y\mathbb{1}_{A_x}].\]</span>这表明在 <span class="math inline">\(\mathbb P^\nu(\cdot\midA_x)\)</span> 下 <span class="math inline">\(\mathcal F_\tau\)</span> 与<span class="math inline">\(\sigma(X_{\tau+n},n\ge0)\)</span>条件独立。<span class="math inline">\(\blacksquare\)</span></p><h1 id="markov-chain-ergodic-theorem">46.2 Markov Chain ErgodicTheorem</h1><div id="------------" class="statement sta_____ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">遍历定理</span>.</span><span class="statement-spah"> </span>令 <span class="math inline">\(V_j(N)\)</span> 为前 <span class="math inline">\(N\)</span> 个时刻访问状态 <span class="math inline">\(j\)</span> 的次数： <span class="math display">\[V_j(N)=\sum_{n=0}^N\mathbb{1}_{\{X_n=j\}}.\]</span> 则 <span class="math display">\[\lim_{N\to\infty}\frac{V_j(N)}{N}=\frac{1}{\mathbb{E}^i[\tau_i]}=1,\\text{a.e.}\quad \forall i,j.\]</span></p></div><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义75.1</span>.</span><span class="statement-spah"> </span><span class="math display">\[\sigma_j^{(1)}=\inf\{n\ge 1: X_n=j\}.\]</span><span class="math display">\[\sigma_j^{(n)}=\inf\{n\ge 1:X_{n+\sigma_j^{(n-1)}}=j\}.\]</span></p></div><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理75.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\{\sigma_j^{(n)}\}_{n=1}^\infty\)</span> 是 i.i.d序列。</p></div><p>证明：定义 <span class="math inline">\(\tau_j^{(0)}=0\)</span>，<span class="math display">\[\tau_j^{(n)}=\inf\{n&gt;\tau_{j-1}^{(n)}:\X_n=j\}.\]</span> 注意到 <span class="math display">\[\sigma_j^({n+1})(X_0,X_1,\ldots) =\sigma_j^{(1)}(X_{\tau_j^{(n)}},X_{\tau_j^{(n)}+1},\ldots).\]</span></p><h1 id="walds-identity">✅ 46.3 Wald’s Identity</h1><p>本讲介绍了 Wald 引理。</p><div id="wald-------" class="statement sta_wald___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Wald引理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span> 的随机变量序列，<span class="math inline">\(\tau\)</span> 是一个停时，则在 <span class="math inline">\(\mathbb{E}|X_1|&lt;\infty\)</span> 且 <span class="math inline">\(\mathbb{E}\tau&lt;\infty\)</span> 的条件下有 <span class="math inline">\(\mathbb{E}\sum\limits_{n=1}^\tauX_n=\mathbb{E}X_1\cdot \mathbb{E}\tau\)</span>。</p></div><p>这里的关键在于将上面的求和变成一个二重级数求和，然后交换求和次序。</p><p><span class="math display">\[\begin{aligned}\sum_{n=1}^\tau\mathbb{E}X_n&amp;=\sum_{n=1}^\infty\mathbb{E}X_n\cdot\mathbb{1}_{\tau\geqn}=\sum_{n=1}^\infty\mathbb{E}X_n\cdot\sum_{k=n}^\infty\mathbb{1}_{\tau=k}\\&amp;=\sum_{k=1}^\infty\mathbb{1}_{\tau=k}\sum_{n=1}^k\mathbb{E}X_n\\&amp;=\mathbb{E}X_1\sum_{k=1}^\inftyk\cdot\mathbb{1}_{\tau=k}\\&amp;=\mathbb{E}X_1\cdot\mathbb{E}\tau.\end{aligned}\]</span></p><p>我们为什么可以在第一行的第二个等号处交换求和次序？这是因为上面的推导对<span class="math inline">\(|X_n|\)</span> 是成立的，并且离散积分值<span class="math inline">\(\mathbb{E}|X_1|\cdot\mathbb{E}\tau&lt;\infty\)</span>，所以由控制收敛定理对原序列<span class="math inline">\(X_n\)</span> 交换求和也是 OK 的。</p><h1 id="uniform-integrability">✅ 48.1 Uniform Integrability</h1><p>这一讲介绍了随机变量集合的一致可积性，要点非常多。</p><p>对任何 <span class="math inline">\(L^1\)</span> 的随机变量 <span class="math inline">\(X\)</span>，总是可以找一个紧集 <span class="math inline">\(K\)</span>，使得 <span class="math inline">\(|X|\)</span> 在 <span class="math inline">\(K^c\)</span> 上的积分任意小：对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，存在 <span class="math inline">\(a&gt;0\)</span> 使得 <span class="math inline">\(\mathbb{E}[|X|:\ |X|\geqa]&lt;\epsilon\)</span>。但是如果是一族可积的随机变量的话，这个统一的<span class="math inline">\(a\)</span> 就未必存在了。</p><p>如果这样的 <span class="math inline">\(a\)</span>总是存在的话，我们就称这族随机变量是一致可积的。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义77.1</span>.</span><span class="statement-spah"> </span>随机变量列 <span class="math inline">\(\{X_n\}\)</span> 称作是一致可积的 (UI)的，如果它们满足以下条件：</p><ol type="1"><li>每个 <span class="math inline">\(X_i\)</span> 都是 <span class="math inline">\(L^1\)</span> 的。</li><li>对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，存在<span class="math inline">\(a&gt;0\)</span> 使得 <span class="math inline">\(\sup_n\mathbb{E}[X_n:\ |X_n|\geq a]&lt;\epsilon\)</span>。</li></ol></div><p>不难验证如果 <span class="math inline">\(\{X_n\}\)</span>被一个可积随机变量控制，则它们是一致可积的：</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>如果 <span class="math inline">\(|X_n|\leq Y,\ Y\inL^1\)</span>，则 <span class="math inline">\(\{X_n\}\)</span>是一致可积的。</p></div><p>这是因为被积函数和积分区域都可以放大：<span class="math inline">\(\mathbb{E}[|X_n|:\ |X_n|\geqa]\leq\mathbb{E}[|Y|:\ |Y|\geq a]\)</span>。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>如果 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(L^p,\,p&gt;1\)</span> 一致有界的：<span class="math inline">\(\sup_n\mathbb{E}|X_n|^p&lt;\infty\)</span>，则<span class="math inline">\(\{X_n\}\)</span> 是一致可积的。</p></div><p>这是因为被积函数可以放大： <span class="math display">\[\mathbb{E}[|X|: |X|\geq a]\leq\mathbb{E}[|X|\cdot\frac{|X|^{p-1}}{a^{p-1}}: |X|\geq a] =\frac{1}{a^{p-1}}\mathbb{E}[|X|^p: |X|\geq a]\leq\frac{M}{a^{p-1}}.\]</span></p><p>这个例子中的 <span class="math inline">\(p&gt;1\)</span> 是不能减弱为<span class="math inline">\(p\geq1\)</span> 的。不过我们可以证明 UI的变量族必然是 <span class="math inline">\(L^1\)</span> 一致有界的：</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理77.2</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\{X_n\}\)</span> 一致可积，则 <span class="math inline">\(\sup_n E|X_n| &lt;\infty\)</span>。</p></div><p><strong>证明</strong>：取 <span class="math inline">\(a\)</span> 使得<span class="math inline">\(\sup_n \mathbb{E}[|X_n|: |X_n|\geq a] &lt;1\)</span>，则不难证明 <span class="math inline">\(\mathbb{E}|X_n| &lt;a+1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>现在我们来给出一致绝对连续的概念，并将说明<strong>一致可积 = <span class="math inline">\(L^1\)</span> 一致有界 +一致绝对连续</strong>。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义77.3</span>.</span><span class="statement-spah"> </span>随机变量序列<span class="math inline">\(\{X_n\}\)</span>是一致绝对连续的，如果对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，都存在 <span class="math inline">\(\delta&gt;0\)</span>，使得只要集合 <span class="math inline">\(B\)</span> 满足 <span class="math inline">\(\mu(B)&lt;\delta\)</span>，就有 <span class="math inline">\(\sup_n\mathbb{E}[|X_n|:B]&lt;\epsilon\)</span>。</p></div><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理77.4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\{X_n\}\)</span> 一致可积当且仅当它们 <span class="math inline">\(L^1\)</span> 一致有界且一致绝对连续。</p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>: <span class="math inline">\(L^1\)</span>一致有界已经有了。下证一致绝对连续性质。对任何可测集 <span class="math inline">\(B\)</span>，我们考虑用一个待定的 <span class="math inline">\(a&gt;0\)</span> 把积分 <span class="math inline">\(\mathbb{E}[|X_n|: B]\)</span> 变成 <span class="math display">\[\mathbb{E}[|X_n|: B,\ |X_n|\geq a] +\mathbb{E}[|X_n|: B,\ |X_n|&lt;a].\]</span> 第一项小于等于 <span class="math inline">\(\mathbb{E}[|X_n|: |X_n|\geqa]\)</span>，由一致可积性我们可以取 <span class="math inline">\(a\)</span> 使得它小于 <span class="math inline">\(\epsilon/2\)</span>。第二项小于等于 <span class="math inline">\(a\mu(B)\)</span>。所以只要 <span class="math inline">\(\mu(B)&lt;\delta=\frac{\epsilon}{2a}\)</span>即可。</p><p><span class="math inline">\(\Leftarrow\)</span>: 我们可以料想 <span class="math inline">\(\{|X_n|\geq a\}\)</span>的测度是会一致地越来越小的：</p><p><span class="math display">\[\mathbb{P}(\{|X_n|\geqa\})=\mathbb{E}[1: |X_n|\geq a]\leq \mathbb{E}[\frac{|X_n|}{a}:|X_n|\geq a]\leq \frac{\mathbb{E}|X_n|}{a}=\frac{K}{a}.\]</span> 其中<span class="math inline">\(K\)</span> 是 <span class="math inline">\(\{X_n\}\)</span> 的 <span class="math inline">\(L^1\)</span> 上界。所以确实可以取 <span class="math inline">\(a\)</span> 适当大使得 <span class="math inline">\(\{|X_n|\geq a\}\)</span>的测度一致地小于一致绝对连续性中所需要的那个 <span class="math inline">\(\delta\)</span>。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理77.5</span>.</span><span class="statement-spah"></span>一致可积性是平移不变的： <span class="math inline">\(\{X_n\}\)</span> 一致可积且 <span class="math inline">\(Y\in L^1\)</span>，则 <span class="math inline">\(\{X_n+Y\}\)</span> 也是一致可积的。</p></div><p>为此只要证明它们一致 <span class="math inline">\(L^1\)</span>有界且一致绝对连续。其中一致 <span class="math inline">\(L^1\)</span>有界是显然的。</p><p>对于一致绝对连续，我们有 <span class="math display">\[\mathbb{E}[|X_n+Y|: B]\leq\mathbb{E}[|X_n|:B] +\mathbb{E}[|Y|: B].\]</span> 取 <span class="math inline">\(\delta_1\)</span> 使得只要 <span class="math inline">\(\mu(B)&lt;\delta_1\)</span> 就有 <span class="math inline">\(\mathbb{E}[|X_n|:B]&lt;\frac{\epsilon}{2}\)</span>，再取<span class="math inline">\(\delta_2\)</span> 使得只要 <span class="math inline">\(\mu(B)&lt;\delta_2\)</span> 就有 <span class="math inline">\(\mathbb{E}[|Y|:B]&lt;\frac{\epsilon}{2}\)</span>，则<span class="math inline">\(\delta=\min\{\delta_1,\delta_2\}\)</span>符合要求。</p><p>最后一个重要定理是：<strong>依 <span class="math inline">\(L^1\)</span> 范数收敛 = 一致可积 +依测度收敛</strong>。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理77.6</span>.</span><span class="statement-spah"> </span>随机变量序列<span class="math inline">\(X_n\xrightarrow{L^1} X\)</span> 当且仅当<span class="math inline">\(X_n\xrightarrow{\mathbb{P}}X\)</span> 且<span class="math inline">\(\{X_n\}\)</span> 一致可积。</p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>：<span class="math inline">\(L^1\)</span> 收敛当然可以得出依测度收敛 (Markov不等式一步即得)。要证明一致可积，我们只要根据平移不变性，证明 <span class="math inline">\(Y_n=X_n-X\)</span> 是一致可积的即可。固定 <span class="math inline">\(\epsilon&gt;0\)</span>。取 <span class="math inline">\(N\)</span> 使得 <span class="math inline">\(\sup_{n\geN}\mathbb{E}|Y_n|&lt;\epsilon\)</span>，于是对所有 <span class="math inline">\(a&gt;0\)</span>， <span class="math display">\[\sup_{n\ge N}\mathbb{E}\big[\,|Y_n|\mathbf 1_{\{|Y_n|\ge a\}}\,\big]\le\sup_{n\ge N}\mathbb{E}|Y_n|&lt;\epsilon.\]</span> 对有限个指标 <span class="math inline">\(n&lt;N\)</span>，由于每个 <span class="math inline">\(Y_n\in L^1\)</span>，存在 <span class="math inline">\(a\)</span> 足够大使 <span class="math display">\[\max_{n&lt;N}\mathbb E\big[\,|Y_n|\mathbf 1_{\{|Y_n|\gea\}}\,\big]&lt;\epsilon.\]</span> 综上得到 <span class="math display">\[\sup_{n}\mathbb E\big[\,|Y_n|\mathbf 1_{\{|Y_n|\gea\}}\,\big]&lt;\epsilon\]</span> 即 <span class="math inline">\(\{Y_n\}\)</span> 一致可积。</p><p><span class="math inline">\(\Leftarrow\)</span>: <span class="math inline">\(Y_n\mathbb{1}_{\{|Y_n|&lt;a\}}\)</span>是一个不大于 <span class="math inline">\(a\)</span>的函数序列，且依测度收敛到0，从而由<strong>依测度的控制收敛定理</strong>有 <span class="math inline">\(Y_n\mathbb{1}_{\{|Y_n|&lt;a\}}\xrightarrow{L^1}0\)</span>。从而 <span class="math display">\[\|X_n-X\|_{L^1} =\mathbb{E}[Y_n\mathbb{1}_{\{|Y_n|&lt;a\}}] +\mathbb{E}[Y_n\mathbb{1}_{\{|Y_n|\geq a\}}].\]</span> 第一项取 <span class="math inline">\(n\)</span> 大于某个 <span class="math inline">\(N\)</span> 就可以任意小，第二项对有限多个 <span class="math inline">\(n\le N\)</span>，<span class="math inline">\(a\)</span> 足够大也可以任意小，得证。<span class="math inline">\(\blacksquare\)</span></p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论77.7</span>.</span><span class="statement-spah"> </span>正则鞅 <span class="math inline">\(X_n = \mathbb{E}[X|\mathcal{F}_n]\)</span>是一致可积的。</p></div><p>反过来也是对的：鞅序列如果是一致可积的，则一定是正则鞅。</p><h1 id="optional-stopping-and-sampling">49.1 Optional Stopping andSampling</h1><p>这一节介绍了停时，以及停时鞅序列 <span class="math inline">\(\{X_{n\wedge \tau}\}\)</span> 的性质。</p><p>一个简单的股票市场模型：设 <span class="math inline">\(\{X_n\}_{n=0}^\infty\)</span> 是股票价格，<span class="math inline">\(\{U_n\}_{n=1}^\infty\)</span>是你的投资策略，即在时刻 <span class="math inline">\(n-1\)</span> 买入<span class="math inline">\(U_n\)</span> 并在时刻 <span class="math inline">\(n\)</span> 抛出。或者说，<span class="math inline">\(U_n\)</span> 是你在 <span class="math inline">\((n-1,n]\)</span>这个时间区间内的股票交易数量，那么到时刻 <span class="math inline">\(n\)</span> 时，你的净收益为 <span class="math display">\[I_n(U,X) = \sum_{j=1}^nU_j(X_j-X_{j-1}).\]</span> 这里 <span class="math inline">\(U_n\)</span>必须是关于 <span class="math inline">\(\mathcal{F}_{n-1}=\sigma(X_0,X_1,\ldots,X_{n-1})\)</span>可测。</p><p>第一个重要观察是：</p><div id="martingale-discrete-integration" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理78.1</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\{X_n\}\)</span> 是鞅/下鞅/上鞅，并且 <span class="math inline">\(U_n\geq0\)</span>，则 <span class="math inline">\(I_n(U,X)\)</span> 也是鞅/下鞅/上鞅。</p></div><p>证明：对下面的恒等式两边关于 <span class="math inline">\(\mathcal{F}_n\)</span> 取条件期望即可。 <span class="math display">\[I_{n+1}(U,X) =\underbrace{I_{n}(U,X)}_{\in\mathcal{F}_n} +\underbrace{U_{n+1}}_{\in\mathcal{F}_n}\underbrace{(X_{n+1}-X_{n})}_{\rm(sub/sup)martingale}.\]</span></p><p>我们可以设定两个随机时间，比如 <span class="math inline">\(\sigma\)</span> 是股票首次低于 1 美元的时刻,这时立刻买入；<span class="math inline">\(\tau\)</span> 是股票首次高于10 美元的时刻，这时立刻抛出；在区间 <span class="math inline">\((\sigma,\tau]\)</span> 中保持持有股票，即 <span class="math inline">\(U_j=\mathbb{1}_{\sigma&lt;j\leq\tau}\)</span>。于是 <span class="math inline">\(U_j\mathbb{1}_{n\geqj}=\mathbb{1}_{(\sigma\wedge n, \tau\wedge n]}(j)\)</span>。</p><p>那么净收益 <span class="math display">\[I_n(U,X) = \sum_{j=1}^n\mathbb{1}_{\sigma\wedge n&lt;j\leq \tau\wedge n}(X_j-X_{j-1})=X_{\tau\wedge n} - X_{\sigma\wedge n}.\]</span></p><p>特别地，取 <span class="math inline">\(\sigma=0\)</span>，则 <span class="math inline">\(U_j=\mathbb{1}_{j\leq\tau}\)</span>，则我们有如下结论：</p><div id="stopping-time-also-martingale" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理78.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\{X_n\}\)</span> 是鞅，那么 <span class="math inline">\(\{X_{n\wedge \tau}\}\)</span> 也是鞅。</p></div><p>证明：首先每一项 <span class="math inline">\(X_{n\wedge\tau}\)</span> 可以看成是一个关于 <span class="math inline">\(X_1,\ldots,X_n\)</span> 的部分和：</p><p><span class="math display">\[X_{n\wedge \tau} =\sum_{k=0}^n\mathbb{1}_{\tau=k}X_k.\]</span></p><p>显然 <span class="math inline">\(X_{n\wedge \tau}\)</span>是可积的。</p><p>另一方面在 <a href="#martingale-discrete-integration" title="定理 78.1">定理 78.1</a> 中取 <span class="math inline">\(U_n=\mathbb{1}_{n\leq\tau}\)</span>，则 <span class="math inline">\(X_{n\wedge \tau} - X_0 = I_n(U,X)\)</span>仍然是鞅，那么加上一个 <span class="math inline">\(X_0\)</span> 得到的<span class="math inline">\(X_{n\wedge\tau}\)</span> 当然还是鞅。</p><h1 id="hölders-inequality">✅ 49.2 Hölder’s Inequality</h1><div id="young----------" class="statement sta_young____ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Young不等式</span>.</span><span class="statement-spah"> </span> 给定 <span class="math inline">\(a,b\ge0\)</span>，<span class="math inline">\(p,q&gt;1\)</span> 且 <span class="math inline">\(\tfrac1p+\tfrac1q=1\)</span>，有 <span class="math display">\[ab\le\frac{a^p}{p}+\frac{b^q}{q}.\]</span>且当且仅当 <span class="math inline">\(a^p=b^q\)</span> 取等号。</p></div><p><strong>证明</strong>：对任意 <span class="math inline">\(u,v\ge0\)</span>，<span class="math inline">\(\theta\in(0,1)\)</span>， <span class="math display">\[u^{\theta}v^{1-\theta}\le \thetau+(1-\theta)v.\]</span> 这是因为 <span class="math inline">\(\ln\)</span> 函数凹，Jensen 不等式给出 <span class="math display">\[\ln(\theta u+(1-\theta)v)\ge \theta\lnu+(1-\theta)\ln v.\]</span> 两边取指数即得。</p><p>取 <span class="math inline">\(\theta=\frac1p,1-\theta=\frac1q,u=a^p,v=b^q\)</span>代入即得 Young 不等式，且等号当且仅当 <span class="math inline">\(a^p=b^q\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>设 <span class="math inline">\(1/p+1/q=1\)</span>，<span class="math inline">\(1&lt;p,q&lt;\infty\)</span>。对任意 <span class="math inline">\(a,b\ge 0\)</span> 有 <strong>Young 不等式</strong><span class="math display">\[ab\le\frac{a^{p}}{p}+\frac{b^{q}}{q}.\]</span> 令 <span class="math display">\[u(x)=\frac{|f(x)|}{\|f\|_p},\qquadv(x)=\frac{|g(x)|}{\|g\|_q}.\]</span> 则逐点有 <span class="math display">\[u(x)v(x)\le u(x)^{p}/p+v(x)^{q}/q.\]</span>两边对 <span class="math inline">\(\mu\)</span> 积分并用 <span class="math inline">\(\int u^{p}=1,\ \int v^{q}=1\)</span> 即得 Hölder不等式。</p><p><span class="math inline">\(p=1,q=\infty\)</span> 时 <span class="math display">\[\int |fg|\le \|g\|_{\infty}\int|f|=\|f\|_1\|g\|_{\infty}.\]</span> 故结论成立。</p><h1 id="submartingale-maximal-inequalities">✅ 49.3 (Sub)martingaleMaximal Inequalities</h1><p>下鞅有一个关键性质，就是它们在一个区间的最大值，可以被它们在区间终点处的值所控制。这就是极大不等式。</p><div id="levy---s-maximal-inequality" class="statement sta_levy_s_maximal_inequality plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Levy’smaximal inequality</span>.</span><span class="statement-spah"></span><br></p><p>设 <span class="math inline">\((X_n)_{n\geq0}\)</span> 是下鞅，<span class="math inline">\(N\ge0\)</span> 是非负整数，则对任何 <span class="math inline">\(a\geq0\)</span> 有 <span class="math display">\[\mathbb{P}(X_N^\ast\ge a)\leq\frac{1}{a}\mathbb{E}[X_N:X_N^\ast \ge a].\]</span></p></div><p><strong>证明</strong>：设 <span class="math inline">\(\tau=\inf\{n\geq0\mid X_n\geq a\}\)</span>，则<span class="math inline">\(\tau\)</span> 是停时。根据可料停时定理，<span class="math display">\[\mathbb{E}[X_N\mid \mathcal{F}_{\tau\wedgeN}]\geq  X_{\tau\wedge N}.\]</span> 于是 <span class="math display">\[\mathbb{E}[X_\tau:\tau\leN]=\mathbb{E}[X_{\tau\wedge N}\mathbb{1}_{\tau\leN}]\le\mathbb{E}[\mathbb{E}[X_N\mid \mathcal{F}_{\tau\wedgeN}]\mathbb{1}_{\tau\leq N}]=\mathbb{E}[X_N\mathbb{1}_{\tau\leN}].\]</span> 由于 <span class="math display">\[\{\tau\le N\} =\{X_n\gea \text{ for some } 0\le n\le N\}=\{X_N^\ast \ge a\}.\]</span>所以上面的不等式最右边还等于 <span class="math inline">\(\mathbb{E}[X_N:X_N^\ast \gea]\)</span>。于是我们有 <span class="math display">\[\mathbb{E}[X_\tau:\tau\le N]\le\mathbb{E}[X_N:X_N^\ast \ge a].\]</span> 另一方面在事件 <span class="math inline">\(\{\tau\le N\}\)</span> 上我们有 <span class="math inline">\(X_\tau\ge a\)</span>，所以上式左边 <span class="math display">\[\mathbb{E}[X_\tau:\tau\le N] \ge\mathbb{E}[a:\tau\ le N] = a \mathbb{P}(\tau\le N) =a\mathbb{P}(X_N^\ast\ge a).\]</span> 此即为所证。<span class="math inline">\(\blacksquare\)</span></p><h1 id="versions">51.1 Versions</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义81.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\((X_t)_{t\in T}\)</span> 和 <span class="math inline">\((Y_t)_{t\in T}\)</span> 是两个随机过程，如果对任何<span class="math inline">\(t\)</span> 有 <span class="math inline">\(X_t = Y_t,\,\mathrm{a.e.}\)</span> 成立，就称<span class="math inline">\((Y_t)\)</span> 是 <span class="math inline">\((X_t)\)</span> 的一个 version/modification。</p></div>]]></content>
      
    </entry>
    
    
  
</search>
