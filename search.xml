<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IFS 分形揭秘</title>
      <link href="ifs-demystified/"/>
      <url>ifs-demystified/</url>
      
        <content type="html"><![CDATA[<p>本文整理自我 2024 年 6 月 14日在上海科技大学数学所的一个小报告，标题是「GPU涂鸦与数学可视化」。我保留了报告的技术内容，略去了报告中介绍 demoscene文化和分形文化的部分。</p><span id="more"></span><hr><p>在 Shadertoy上有很多效果酷炫，但是代码非常短的分形作品。我挑选了其中三个优秀的例子展示如下：</p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr><td style="text-align: center;"><a href="https://www.shadertoy.com/view/ltB3DG">Ethereal</a> by Kali</td><td style="text-align: center;"><a href="https://www.shadertoy.com/view/NsVyRz">Apollonian fractal</a> byXor</td><td style="text-align: center;"><a href="https://www.shadertoy.com/view/mdG3Wy">Radiosity</a> by Xor</td></tr><tr><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/ltB3DG.jpg"></td><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/NsVyRz.jpg"></td><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/mdG3Wy.jpg"></td></tr></tbody></table><p>然而代码短可不代表它们容易看懂。特别是很多作者还喜欢故弄玄虚，把代码作了混淆处理以增加神秘感。对我来说，这种被人秀了一脸结果还没搞明白对面是怎么装的逼的感觉让人很不爽。当然我不是在抱怨，这种炫技的行为本身就是黑客文化的一部分，可以理解。后来分形玩的多了，我也慢慢明白了其中的奥妙，这次上科大之行是一次很好的机会，促使我把这些理解完整的写下来。</p><p>在这篇文章中，我将为大家揭示这些作品背后的奥秘。这些分形作品别看场景千变万化，其实都是用同一个套路制作出来的。这个套路可以简述为：首先将像素的2D 坐标映射为空间中的某个 3D 的点，然后用一个 <code>fold</code>函数，即所谓的 <a href="https://en.wikipedia.org/wiki/Iterated_function_system">迭代函数系统</a>（iteratedfunction system，简称IFS）反复作用在该点上。每次迭代结束后，生成一个颜色并将其添加到当前的颜色<code>color</code> 上。当达到一定的迭代次数后，返回 <code>color</code>的值作为像素最终的颜色。</p><p>如果用伪代码来描述，大概是这样：</p><figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec3</span> getPixelColor(<span class="hljs-type">vec2</span> pixel) {<br>    <span class="hljs-type">vec3</span> p = screenToSpace(pixel);  <span class="hljs-comment">// map 2D pixel to 3D space</span><br>    <span class="hljs-type">vec3</span> color = <span class="hljs-type">vec3</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;max_iterations; i++) {<br>        p = fold(p);  <span class="hljs-comment">// transform p in each iteration</span><br>        color += someColorFunc(p);  <span class="hljs-comment">// add a bit color</span><br>    }<br>    <span class="hljs-keyword">return</span> color;<br>}<br></code></pre></td></tr></tbody></table></figure><p>整个过程主要包括三个要素：</p><ol type="1"><li>用 IFS 来构造分形。</li><li>用轨道着色技巧给分形上色。</li><li>在着色器 (shader) 中编程实现。</li></ol><p>下面我来逐一来解释这些步骤。</p><h1 id="ifs-方法">IFS 方法</h1><div id="------------" class="unnumbered statement sta_____ plain"><p><span class="statement-heading"><span class="statement-label">压缩映射</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}^n\)</span>是一个映射，如果存在 <span class="math inline">\(0&lt;r&lt;1\)</span>使得对任何 <span class="math inline">\(x,y\in\mathbb{R}^n\)</span> 有<span class="math display">\[d(f(x),f(y))\leq r\cdot d(x,y)\]</span>成立，我们就称 <span class="math inline">\(f\)</span>是一个压缩映射，<span class="math inline">\(r\)</span> 是压缩比例。这里<span class="math inline">\(d\)</span> 是通常的 Euclidean 距离。</p></div><p>记 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span>中所有紧集组成的集合，可以证明 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 在 <a href="https://en.wikipedia.org/wiki/Hausdorff_distance">Hausdorff度量</a> 下构成一个完备度量空间。读者不必关心 Hausdoff度量的具体细节，只要知道它是一个度量，可以衡量两个紧集的接近程度。</p><p>设 <span class="math inline">\(f_1,\ldots,f_N\)</span> 是 <span class="math inline">\(N\)</span> 个压缩映射，<span class="math inline">\(f_i\)</span> 的压缩比例是 <span class="math inline">\(r_i\)</span>。定义映射 <span class="math inline">\(F:K(\mathbb{R}^n)\to K(\mathbb{R}^n)\)</span>如下： <span class="math display">\[F(X) = f_1(X)\cupf_2(X)\cup\cdots\cup f_N(X),\quad X\in K(\mathbb{R}^n).\]</span> 即<span class="math inline">\(F\)</span> 把 <span class="math inline">\(X\)</span> 变成 <span class="math inline">\(N\)</span> 个更小的集合。</p><p>可以证明 <span class="math inline">\(F\)</span> 是空间 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 上的压缩映射，其压缩比例<span class="math inline">\(r=\max\{r_1,\ldots,r_N\}\)</span>。于是根据<a href="https://en.wikipedia.org/wiki/Banach_fixed-point_theorem">Banach不动点定理</a>，存在唯一的紧集 <span class="math inline">\(A\subset\mathbb{R}^n\)</span> 使得 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(F\)</span> 的不动点： <span class="math display">\[F(A) = A.\]</span> 不仅如此，对 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 中的任何一点（注意 <span class="math inline">\(K(\mathbb{R}^n)\)</span>是紧集组成的度量空间，里面的点都是紧集）<span class="math inline">\(B\subset\mathbb{R}^n\)</span>，都有 <span class="math display">\[\lim_{n\to\infty} F^n(B) =A.\]</span> 紧集 <span class="math inline">\(A\)</span> 叫做 <span class="math inline">\(F\)</span> 的极限集，<span class="math inline">\(A\)</span> 是一个分形，它具有自相似的特征。</p><p>我们以著名的 <a href="https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle">Sierpiński三角形</a> 为例来说明这个过程。我们选择的三个压缩映射分别是</p><p><span class="math display">\[\begin{align}f_1(x,y) &amp;= (x/2, y/2),\\f_2(x,y) &amp;= (x/2, y/2) + (0, 1/2),\\f_3(x,y) &amp;= (x/2, y/2) + (1/2, 0).\\\end{align}\]</span></p><p>这三个压缩映射的压缩比都是 1/2。初始的紧集 <span class="math inline">\(K_0\)</span> 可以随便选，比如就取为一个圆： <span class="math display">\[K_0 =\img{/images/ifs/dot0.svg}{-1.75em}{}{4em}.\]</span></p><p>在第 1 次迭代后，它变成</p><p><span class="math display">\[K_1 = f_1(K_0)\cup f_2(K_0)\cup f_3(K_0)= \img{/images/ifs/dot1.svg}{-1.75em}{}{4em}.\]</span></p><p>在第 2 次迭代后，结果是</p><p><span class="math display">\[K_2 = f_1(K_1)\cup f_2(K_1)\cup f_3(K_1)= \img{/images/ifs/dot2.svg}{-1.75em}{}{4em}.\]</span></p><p>第 3 次迭代：</p><p><span class="math display">\[K_3 = f_1(K_2)\cup f_2(K_2)\cup f_3(K_2)= \img{/images/ifs/dot3.svg}{-1.75em}{}{4em}.\]</span></p><p>当迭代次数趋于无穷，就得到了 Sierpiński 分形：</p><p><span class="math display">\[\lim_{n\to\infty} K_n = K = f_1(K)\cupf_2(K)\cup f_3(K) =\img{/images/ifs/dot6.svg}{-1.75em}{}{4em}.\]</span></p><p>你可以很容易看出来为什么初始紧集的选择是不重要的：因为在压缩的过程中，任何紧集都会逐渐缩小到一个单点，所以<span class="math inline">\(K_0\)</span> 甚至取成一个点也是可以的。</p><p>压缩映射是无穷无尽的，所以 IFS给出的分形也是无穷无尽的。为了避免选择困难，我们一般只使用平移、旋转、反射、缩放、球反演这几种变换（球反演变换是将单位球的外部反演到内部，单位球内部保持不动），通过它们的复合变换来实现空间压缩。</p><p>你可能想问，那应该怎样具体选择 <span class="math inline">\(f_1,\ldots,f_N\)</span>？我会在后面介绍，在着色器中实现IFS 是通过「空间折叠」操作进行的，这个操作可以看作是 <span class="math inline">\(F\)</span>的逆映射，它自动包含了多个压缩映射，所以你根本不需要单独指定每个 <span class="math inline">\(f_i\)</span>！</p><h1 id="轨道着色">轨道着色</h1><p>我们希望给分形染上漂亮的颜色，这个染色应该满足如下的条件：</p><ol type="1"><li>在分形上颜色是连续变化的；</li><li>在分形和非分形的交界处（即 <span class="math inline">\(A\)</span> 和<span class="math inline">\(A^c\)</span>的边界上）颜色应该是不连续的，从而产生泾渭分明的效果。</li></ol><p>做到这一点并不难，但是需要在每一次迭代时考虑当前点的位置信息。</p><p>我们首先取一个底色，比如说<code>color=vec3(0)</code>，在每一次迭代中，根据当前位置 <code>p</code>生成一个颜色，并以一定的权重加到 <code>color</code> 上。理论上颜色的 rgb的取值范围应该是 <span class="math inline">\([0,1]\)</span>，但是多数情况下我们要放宽到 <span class="math inline">\([-1,1]\)</span>之间，即颜色可以增加也可以减少。否则如果颜色只增不减的话，那么多次迭代以后rgb值很可能会溢出，变成白色。此外，随着迭代次数的增加，新颜色的权重应该单调下降，这样才能保证突出分形细节的部分。这也符合我们的生活直觉：想象一下，当一位画家作画时，在开始的时候他可以浓墨重彩地画一个轮廓，但是越到后面描绘更加精细的部分时，他就会换用更细的画笔，小心地蘸一点颜料。</p><p>根据 <code>p</code>生成颜色的着色方案无穷无尽，请随便发挥你的创造力。一般来说你需要反复试验各种不同的方案才能找到最合适的。下面的例子使用了一种非常流行的染色方案，它以<code>cos(vec3(0,1,2))</code> 作为底色，并根据当前时间<code>iTime</code> 以及坐标 <code>uv</code> 进行调整：</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 uv = fragCoord / iResolution.xy;    vec3 col = 0.5 + 0.45 * cos(vec3(0, 1, 2) + iTime + uv.yxy);    fragColor = vec4(col, 1.0);}"></div><h1 id="着色器编程基础">着色器编程基础</h1><p>我简单介绍一下着色器编程的基本概念。打开 shadertoy网站，点击右上角的<code>新建</code>按钮，你会看到一个 <a href="https://www.shadertoy.com/new">最简单的动画</a>：</p><p><img src="/images/ifs/shadertoy.png" class="fig" width="600"></p><p>左边的窗口是画布，显示渲染的结果；右边窗口是代码编辑器，你在这里书写着色器代码。</p><p>画布是由若干像素组成的，你需要根据每个像素的位置，即它的<code>fragCoord</code> 值指定一个颜色。这个过程是在<code>mainImage</code> 函数中实现的：</p><figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> mainImage(<span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> fragColor, <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> fragCoord);<br></code></pre></td></tr></tbody></table></figure><p>其中 <code>fragCoord</code> 是像素的位置，<code>fragColor</code>是需要设置的像素颜色。</p><p>现实生活中有一个很形象的例子可以帮你理解着色器编程：假设你是一场方阵表演的导演，所有演员排成一个<span class="math inline">\(W\times H\)</span>的方阵，每个演员可以改变自己衣服的颜色。你的任务是发出合适的指令让每个演员根据自己的位置计算出正确的颜色，使得整个方阵呈现出漂亮的图案。</p><p><img src="/images/ifs/array.png" class="fig" width="600"></p><p>如果你一个一个地对每个演员下指令，张三你应该显示红色，李四你应该显示蓝色，等等…对成千上万个演员，这么挨个下指令还不得把人累死？正确的做法是，你应该同时对所有演员发出相同的指令，比如：“每个人，根据自己的位置，<span class="math inline">\(x\)</span> 坐标 （即 <code>fragCoord.x</code>）是偶数的显示红色，<span class="math inline">\(x\)</span>坐标是奇数的显示蓝色”。这样你应该会看到红蓝相间、纵向排列的条纹图案。每个演员本质上就是一个单独的GPU计算单元，他们可以根据相同的指令独立计算各自的颜色。这种基于相同指令并行计算的工作方式才是GPU 流水线的机制。</p><p>再举一个例子，比如你希望阵列的中心呈现一个圆盘的图案，那就可以这样下指令：“每个人，把自己的纵坐标转换到区间<span class="math inline">\([-1, 1]\)</span>，然后计算各自到原点 <span class="math inline">\((0,0)\)</span> 的距离。距离大于 0.5的显示黑色，否则就显示红色”。这样一来，每个演员就会首先根据</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">vec2 p = (<span class="hljs-number">2.0</span> * fragCoord  - iResolution.xy) / iResolution.y;<br><span class="hljs-keyword">float</span> d = length(p) - <span class="hljs-number">0.5</span>;<br></code></pre></td></tr></tbody></table></figure><p>将自己的像素坐标 <code>fragCoord</code> 转换为世界坐标下的点<code>p</code>，使得 <code>fragCoord.y</code> 的范围是 <span class="math inline">\([-1,1]\)</span>。然后计算各自到以原点为中心、半径为0.5 的圆的距离 <span class="math inline">\(d\)</span>。最终根据</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (d &gt; <span class="hljs-number">0.0</span>)<br>    fragColor = vec4(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span><br>    fragColor = vec4(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></tbody></table></figure><p>来设置各自的颜色。</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;    float d = length(p) - 0.5;    if (d > 0.0)        fragColor = vec4(0, 0, 0, 1);    else        fragColor = vec4(1, 0, 0, 1);}"></div><p>这个例子其实蕴含了 shader编程的一个非常核心的概念，即<strong>距离场</strong> (distancefield)。当我们想绘制某个图案时，我们通过计算像素到这个图案的距离来对像素进行着色。</p><h1 id="空间折叠">空间折叠</h1><p>在前面关于 IFS 的介绍中我们可以看到，如果有 <span class="math inline">\(N\)</span> 个不同的压缩映射 <span class="math inline">\(f_1,\ldots,f_N\)</span>，那么每次迭代后集合的数目会乘以<span class="math inline">\(N\)</span>，这是指数增长的，10次迭代可能会产生多达 <span class="math inline">\(10^N\)</span>个不同的集合。维护如此数量的集合是计算上不可行的。这该怎么办呢？</p><p>回忆我们之前介绍的，在着色器里面画 IFS就是给每个像素指定一个颜色，这个颜色应该由这个像素对应的空间中的点到分形的距离来决定。假设像素对应的空间中的点是<span class="math inline">\(p\)</span>，初始紧集是 <span class="math inline">\(K\)</span>，我们用迭代 <span class="math inline">\(n\)</span> 次的结果 <span class="math inline">\(F^n(K)\)</span> 作为分形的近似，这里 <span class="math inline">\(n\)</span> 是某个常数，在绝大多数场景下 <span class="math inline">\(n=30\)</span> 就足够了。我们需要计算距离 <span class="math inline">\(d(p,F^n(K))\)</span>并根据这个距离值对像素染色。我们已经看到 <span class="math inline">\(F^n(K)\)</span>是没法计算的，但有个巧妙的做法可以绕过这个困难：把 <span class="math inline">\(F^n\)</span> 挪到另一侧并取逆，转而计算 <span class="math inline">\(d(F^{-n}(p), K)\)</span>！实际上，如果 <span class="math inline">\(F\)</span>只包含旋转、平移、反射、缩放、球反演这些变换的话，<span class="math inline">\(d(p,F^n(K))\)</span> 和 <span class="math inline">\(d(F^{-n}(p), K)\)</span>之间存在非常简单的关系，我们可以通过计算后者来得到前者！这个关系的推导我放在后面介绍。</p><p>所以我们需要将压缩迭代映射的步骤倒过来，采取相反的操作：即将逆映射<span class="math inline">\(F^{-1}\)</span> 迭代作用在 <span class="math inline">\(p\)</span> 上，执行足够的迭代次数后，再绘制紧集<span class="math inline">\(K\)</span>。即我们实际是用一个<strong>空间折叠</strong>的映射作用反复作用在<span class="math inline">\(p\)</span>上，这个映射是<strong>放大距离</strong>的。</p><p>这个先折叠后画图的操作，也可以用一个生活中的例子来形象地解释，即剪纸艺术：</p><p><img src="/images/ifs/papercut.jpg" class="fig" width="480"></p><p>在剪纸过程中，首先把纸张反复折叠，然后在折叠后的纸张上画出某个特定的图形，沿着这个图形裁剪，再将纸张展开得到的就是美丽的图案。</p><p>这里<strong>展开</strong>纸张的操作对应的就是迭代映射 <span class="math inline">\(F\)</span>，它把一个初始的紧集铺开到空间中变成分形，是个「一对多」的映射；<strong>折叠</strong>纸张的操作就是<span class="math inline">\(F^{-1}\)</span>，它把分形折叠回最初的紧集，是个「多对一」的映射。</p><p>在下面的例子中，我们首先用 <code>p = abs(p)</code>将整个空间折叠到第一象限，然后只要在第一象限中画一个圆，就可以同时在其它位置得到总共4 个圆：</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;    p = abs(p); //折叠    float d = length(p - vec2(0.5)) - 0.3; // 中心在 (0.5, 0.5), 半径为 0.3 的圆    d = smoothstep(-0.005, 0.005, d); // 平滑一下边缘    vec3 col = mix(vec3(0), vec3(0.9), d); //染色    fragColor = vec4(col, 1);}"></div><p>如果你去看那些分形作品的代码的话，会发现它们几乎都使用了<code>abs</code>函数。这个函数是多对一的，它会把整个空间折叠到第一象限，这对应了 <span class="math inline">\(F\)</span> 包含 4 个不同的 <span class="math inline">\(f_i\)</span> （这是在 2D 的情形；3D 的情形会有 8个不同的 <span class="math inline">\(f_i\)</span>）。进一步，再叠加关于其它平面/球面的折叠可以产生出更多的<span class="math inline">\(f_i\)</span>。这就解释了为什么在着色器中我们不需要显示地写出每个单独的<span class="math inline">\(f_i\)</span>。</p><p>最后我们来推导 <span class="math inline">\(d(p,F^n(K))\)</span> 和<span class="math inline">\(d(F^{-n}(p), K)\)</span> 之间的关系。</p><p>如果 <span class="math inline">\(F\)</span>是平移、旋转、反射这样的保持 Euclidean 距离不变的刚体运动，那么自然有<span class="math display">\[d(p, F(K)) = d(F^{-1}(p), K).\]</span></p><p>但如果 <span class="math inline">\(F\)</span> 是一个缩放变换，比如<span class="math inline">\(F(x) = x/s\,(s&gt;1)\)</span>，那么 <span class="math display">\[d(p, F(K)) = d(p, 1/s\cdot K) = 1/s\cdot d(s\cdotp, K) = 1/s\cdot d(F^{-1}(p), K).\]</span>即我们要对折叠以后算出来的距离值再除以 <span class="math inline">\(s\)</span>。</p><p>对球的反演变换也有类似的结论，这是因为球反演在空间中每个点的局部是一个缩放。</p><p>既然每次迭代 <span class="math inline">\(F\)</span> 以比例 <span class="math inline">\(1/s\)</span> 缩小，那么用 <span class="math inline">\(F^{-1}\)</span> 迭代 <span class="math inline">\(n\)</span> 次以后累积放大的比例就是 <span class="math inline">\(s^n\)</span>，我们要将 <span class="math inline">\(d(F^{-n}(p), K)\)</span> 再除以 <span class="math inline">\(s^n\)</span> 才是最终正确的距离值。</p><p>对于一般的映射 <span class="math inline">\(F\)</span>，我们可以通过计算 <span class="math inline">\(F^{-1}\)</span> 在 <span class="math inline">\(p\)</span> 处 Jacobian 矩阵的行列式的绝对值，作为<span class="math inline">\(p\)</span> 处缩放的近似。</p><h1 id="实战演示">实战演示</h1><p>我以 Shadertoy 上一个混淆过的 <a href="https://www.shadertoy.com/view/WlGyWK">作品</a>为例子来完整展示上面的理论。下面是重新改写后的可读版本，我在注释中解释了每一步的含义：</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/l3cXR7?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe>]]></content>
      
      
      <categories>
          
          <category> Shadertoy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>咖啡杯中的焦散线</title>
      <link href="envelope-and-caustics/"/>
      <url>envelope-and-caustics/</url>
      
        <content type="html"><![CDATA[<p>春节的晚上，外面鞭炮喧天，家人在看电视，我躲在屋里看数学，还是挺惬意的。</p><p>我看的是 <a href="https://johncarlosbaez.wordpress.com">John Baez</a>和 <a href="https://www.gregegan.net">Greg Egan</a> 的博客。John Baez是一位在科普方面非常高产的数学家，写过不计其数的科普文章。读他的文章非常让人享受，因为他总是从直观的例子入手，一步步启发读者，展开到更高级的数学。GregEgan是澳大利亚的一位非常高产的科幻小说作家，有不少作品已经被国内引入。他的小说属于硬科幻风格，而且是非常硬的那种。他也有不少有趣的<a href="https://www.gregegan.net/SCIENCE/Science.html">博客文章</a>。不过与John Baez 不同的是，Greg Egan的文章不太会去兼顾不同水平的读者，对我来说，要看懂他在说什么经常不是一件容易的事情。</p><p>John Baez 博客上有一个系列 <a href="https://johncarlosbaez.wordpress.com/2012/08/31/rolling-circles-and-balls-part-1/">Rollingcircles and balls</a> 讨论了圆的外摆线和焦散，Greg Egan 也有一篇 <a href="https://www.gregegan.net/SCIENCE/Catacaustics/Catacaustics.html">文章</a>更深入的讨论了曲线的焦散。这个话题非常有意思，我也一时手痒写代码实验了一番并记录在此。</p><span id="more"></span><h1 id="pov-ray-光学实验">POV-Ray 光学实验</h1><p>有个有趣的物理现象，当光线照在咖啡杯的内壁上时，光线反射以后会形成一个亮斑，术语叫做焦散(caustic)。</p><p><img style="margin:0px auto;display:block" width="400" src="/images/caustics/cup.jpg"></p><p>形成焦散的原因是，光线在杯子内壁反射以后，光子的分布是不均匀的，某些区域经过的光子特别密集，所以亮度就更高。</p><p>焦散是一条曲线，它和所有的反射光线相切，即它是所有反射光线的包络(envelope)。焦散的具体形状和杯子的形状、光源的位置都有关。假设杯子是圆形的，则当光源是一个点光源且恰好位于杯子边缘上某一点时，得到的焦散叫做<a href="https://en.wikipedia.org/wiki/Cardioid">心脏线</a>(cardioid)。当光源位于无穷远时（可以视作平行光源），得到的焦散是 <a href="https://en.wikipedia.org/wiki/Nephroid">肾形线</a>(nephroid)。一般情况下焦散的形状介于心脏线和肾形线之间。</p><p>更有意思的是，如果杯子的外形是心脏线，而且光源正好位于心脏线的尖点时，得到的焦散正好是肾形线。我写了一个<a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/catacaustic">POV-Ray脚本</a>，模拟了这一现象：</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr><td style="text-align: center;">圆形杯子给出心脏线</td><td style="text-align: center;">心脏线杯子给出肾形线</td></tr><tr><td style="text-align: center;"><img src="/images/caustics/caustics_cardioid.png" class="fig" width="400"></td><td style="text-align: center;"><img src="/images/caustics/caustics_nephroid.png" class="fig" width="400"></td></tr></tbody></table><p>心脏线和肾形线都是所谓的 <a href="https://en.wikipedia.org/wiki/Epicycloid">外摆线</a>，只是两圆的半径之比不同：</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr><td style="text-align: center;">心脏线</td><td style="text-align: center;">肾形线</td></tr><tr><td style="text-align: center;"><video src="/images/caustics/cardioid.mp4" controls=""></video></td><td style="text-align: center;"><video src="/images/caustics/nephroid.mp4" controls=""></video></td></tr></tbody></table><p>所以我们很容易作出如下的猜想：如果在肾形线的内部或者尖点放一个光源，是不是又会得到下一个外摆线？然而根据Greg Egan 在他博客中的实验，这个应该是不成立的。</p><p>理论上这个 POV-Ray 脚本可以渲染任意的参数曲线反射的效果，但是 POV-Ray渲染 parametric surface + radiosity非常慢，所以如果你想试一试的话，最好还是用 POV-Ray 原生的 CSG来构造曲线。</p><h1 id="求解参数曲线的焦散">求解参数曲线的焦散</h1><p>这一节我们来介绍怎样计算一般的参数曲线 <span class="math inline">\(\mathbf{c}(t)=(x(t),y(t))\)</span>的焦散曲线。</p><p>设点光源的位置是 <span class="math inline">\((a,b)\)</span>，则在曲线上的一点 <span class="math inline">\((x,y)\)</span> 处，入射光线的方向是 <span class="math display">\[\mathbf{l}=(x-a,y-b).\]</span> 不需要把 <span class="math inline">\(\mathbf{l}\)</span>单位化，因为我们列方程的时候只需要光线的方向，并不在乎长度。</p><p>同样是在 <span class="math inline">\((x,y)\)</span>处，曲线的法向量是 <span class="math display">\[\mathbf{n}=\frac{(-y',x')}{\sqrt{(x')^2+(y')^2}}=\frac{(-y',x')}{|\mathbf{c}'|}.\]</span> 这里我们用 <span class="math inline">\(x',y'\)</span> 表示 <span class="math inline">\(x,y\)</span> 关于 <span class="math inline">\(t\)</span> 的导数。</p><p>于是 <span class="math inline">\((x,y)\)</span> 处的反射光线的方向<span class="math inline">\(\mathbf{r}\)</span> 由如下反射公式给出：<span class="math display">\[\mathbf{r}= \mathbf{l}- 2(\mathbf{l}\cdot\mathbf{n})\mathbf{n}.\]</span> 设 <span class="math inline">\((X,Y)\)</span> 是反射光线上的任一点，由于 <span class="math inline">\((x,y)\)</span> 是反射光线的起点，所以 <span class="math inline">\((X-x,Y-y)\)</span> 与 <span class="math inline">\(\mathbf{r}\)</span> 平行。记 <span class="math inline">\(\mathbf{r}=(r_x,r_y)\)</span>，则 <span class="math inline">\((X-x,Y-y)\)</span> 与 <span class="math inline">\((-r_y, r_x)\)</span> 垂直，即 <span class="math display">\[(X-x, Y-y)\cdot(-r_y, r_x)=0.\]</span> 记 <span class="math display">\[F(X,Y,t)=(X-x, Y-y)\cdot(-r_y, r_x),\]</span>则我们得到了反射光线 <span class="math inline">\((X(t), Y(t))\)</span>满足的曲线族方程 <span class="math inline">\(F(X,Y,t)=0\)</span>。于是焦散曲线可以通过联立方程组<span class="math display">\[\begin{align}F(X,Y,t)=0,\\\frac{\partialF}{\partial t}F(X,Y,t)=0.\end{align}\]</span> 也就是 <span class="math display">\[\begin{align}(X-x, Y-y)\cdot(-r_y,r_x)&amp;=0,\\-(x',y')\cdot(-r_y, r_x) +(X-x,Y-y)\cdot(-r_y', r_x') &amp;=0.\end{align}\]</span>然后解出 <span class="math inline">\(X,Y\)</span> 得到。</p><p>如果你还记得 2x2矩阵的逆公式的话，这个方程组其实可以目视写出解来。我们把它写成</p><p><span class="math display">\[\begin{pmatrix}-r_y &amp; r_x\\-r_y'&amp;r_x'\end{pmatrix}\cdot\begin{pmatrix}X-x\\Y-y\end{pmatrix}=\begin{pmatrix}0\\r_xy'-r_yx'\end{pmatrix}.\]</span> 于是 <span class="math display">\[\begin{align}\begin{pmatrix}X-x\\Y-y\end{pmatrix}&amp;=\begin{pmatrix}-r_y&amp; r_x\\ -r_y'&amp;r_x'\end{pmatrix}^{-1}\begin{pmatrix}0\\r_xy'- r_yx'\end{pmatrix}\\&amp;=\frac{1}{r_xr_y'-r_yr_x'}\begin{pmatrix}r_x' &amp;-r_x\\ r_y'&amp;-r_y\end{pmatrix}\begin{pmatrix}0\\r_xy'-r_yx'\end{pmatrix}\\&amp;=\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\end{align}\]</span> 即 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix} +\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span></p><p>按照上面的理论，我写了一个小脚本，用 <code>sympy</code>(version=1.12) 来计算圆的焦散线。其中圆的中心在原点，半径为 1，光源在<span class="math inline">\((1,0)\)</span> 处。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>t, X, Y = symbols(<span class="hljs-string">"t X Y"</span>)<br>C = Matrix([cos(t), sin(t)]) <span class="hljs-comment"># curve</span><br>light = Matrix([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]) <span class="hljs-comment"># light source</span><br>l = C - light <span class="hljs-comment"># incident ray</span><br>dx, dy = diff(C, t)<br>n = Matrix([dy, -dx]) <span class="hljs-comment"># normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n)) <span class="hljs-comment"># reflected ray</span><br>F = (Y - y) * r[<span class="hljs-number">0</span>] - (X - x) * r[<span class="hljs-number">1</span>]<br>dF = diff(F, t)<br>result = solve((F, dF), X, Y) <span class="hljs-comment"># solve the envelope</span><br>print(<span class="hljs-string">f"X(t)=<span class="hljs-subst">{trigsimp(result[X], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br>print(<span class="hljs-string">f"Y(t)=<span class="hljs-subst">{trigsimp(result[Y], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 给出的结果是：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X(t)=<span class="hljs-number">2</span>*cos(t)/<span class="hljs-number">3</span> + cos(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span><br>Y(t)=<span class="hljs-number">2</span>*sin(t)/<span class="hljs-number">3</span> + sin(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>这正是喜闻乐见的心脏线的参数表示： <span class="math display">\[\left\{\begin{align}x(t)&amp;=\frac{\cos(2t) +2\cos(t)}{3},\\ y(t)&amp;=\frac{\sin(2t) +2\sin(t)}{3}.\end{align}\right.\]</span></p><p>使用这个参数表示，我们继续计算当光源放在心脏线的尖点，即 <span class="math inline">\(t=\pi\)</span> 对应的点 <span class="math inline">\((-\frac{1}{3},0)\)</span> 时得到的焦散：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>t, X, Y = symbols(<span class="hljs-string">"t X Y"</span>)<br>C = Matrix([(<span class="hljs-number">2</span>*cos(t) + cos(<span class="hljs-number">2</span>*t)) / <span class="hljs-number">3</span>, (<span class="hljs-number">2</span>*sin(t) + sin(<span class="hljs-number">2</span>*t)) / <span class="hljs-number">3</span>])<br>light = Matrix([S(<span class="hljs-string">'-1/3'</span>, evaluate=<span class="hljs-literal">False</span>), <span class="hljs-number">0</span>])<br>l = C - light <span class="hljs-comment"># incident ray</span><br>dx, dy = diff(C, t)<br>n = Matrix([dy, -dx]) <span class="hljs-comment"># normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n)) <span class="hljs-comment"># reflected ray</span><br>F = (Y - y) * r[<span class="hljs-number">0</span>] - (X - x) * r[<span class="hljs-number">1</span>]<br>dF = diff(F, t)<br>result = solve((F, dF), X, Y) <span class="hljs-comment"># solve the envelope</span><br>print(<span class="hljs-string">f"X(t)=<span class="hljs-subst">{trigsimp(result[X], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br>print(<span class="hljs-string">f"Y(t)=<span class="hljs-subst">{trigsimp(result[Y], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 很快算出了正确的结果：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X(t)=sin(t)*sin(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span> + cos(t)/<span class="hljs-number">3</span><br>Y(t)=-sin(t)*cos(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span> + sin(t)/<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>不难验证</p><p><span class="math display">\[\begin{align}\frac{\sin(t)\sin(2t) +\cos(t)}{3}&amp;=\frac{3\cos(t) - \cos(3t)}{6},\\ \frac{-\sin(t)\cos(2t)+ \sin(t)}{3}&amp;=\frac{3\sin(t) -\sin(3t)}{6}.\end{align}\]</span></p><p>这正是 <a href="https://en.wikipedia.org/wiki/Nephroid#Parametric">维基百科</a>中所列的肾形线的参数方程中取 <span class="math inline">\(a=1/6\)</span>的结果。</p><p>把上面的曲线画出来是这样的：</p><p><img src="/images/caustics/caustics_matplotlib.svg" class="fig" width="400"></p><h1 id="求解多项式曲线的焦散">求解多项式曲线的焦散</h1><p>很多时候曲线的方程是通过隐函数 <span class="math inline">\(P(x,y)=0\)</span> 的形式给出的，其中 <span class="math inline">\(P(x,y)\)</span> 是关于两个变元 <span class="math inline">\(x,y\)</span>的多项式。这样的曲线叫做平面代数曲线。这时求解焦散要用到 Gröbner基的工具。</p><p>让我们回到参数方程的情形，我们已经看到，这时焦散 <span class="math inline">\((X,Y)\)</span> 有显式解</p><p><span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix} +\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span></p><p>其中 <span class="math inline">\(x,y,r_x,r_y\)</span> 都是关于 <span class="math inline">\(t\)</span>的函数，它们的导数也是可计算的，所以可以算出 <span class="math inline">\((X,Y)\)</span> 来。</p><p>但是在隐函数的情形，我们没有 <span class="math inline">\(x,y\)</span>的某种关于 <span class="math inline">\(t\)</span>的表达式。不过没关系，我们先假设有这样的参数表达式，看看能得到什么结论。设<span class="math inline">\(x=x(t),y=y(t)\)</span> 是某个参变元 <span class="math inline">\(t\)</span> 的函数，在 <span class="math inline">\(P(x,y)=0\)</span> 两边对 <span class="math inline">\(t\)</span> 求导可得 <span class="math display">\[\frac{\partial P}{\partial t}=\frac{\partialP}{\partial x}x'(t) + \frac{\partial P}{\partialy}y'(t)=0.\]</span> 记 <span class="math inline">\(k=-\frac{\partialP}{\partial x}/\frac{\partial P}{\partial y}\)</span>，则 <span class="math inline">\(y'(t)=kx'(t)\)</span>。</p><p>对反射光线 <span class="math inline">\(\mathbf{r}\)</span> 的两个分量<span class="math inline">\(r_x,r_y\)</span> 也分别使用链式求导，我们有<span class="math display">\[\begin{align}\frac{\partial r_x}{\partialt}&amp;=\frac{\partial r_x}{\partial x}x'(t) + \frac{\partialr_x}{\partial y}y'(t),\\\frac{\partial r_y}{\partial t}&amp;=\frac{\partial r_y}{\partialx}x'(t) + \frac{\partial r_y}{\partialy}y'(t).\end{align}\]</span> 于是我们发现比值 <span class="math display">\[\begin{align}\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}&amp;=\frac{r_xk-r_y}{r_y(\frac{\partialr_x}{\partial x}+\frac{\partial r_x}{\partial y}k)-r_x(\frac{\partialr_y}{\partial x} + \frac{\partial r_y}{\partial y}k)}\\&amp;=-\frac{r_x\frac{\partial P}{\partial x}+r_y\frac{\partialP}{\partial y}}{r_y(\frac{\partial r_x}{\partial x}\frac{\partialP}{\partial y}-\frac{\partial r_x}{\partial y}\frac{\partial P}{\partialx})-r_x(\frac{\partial r_y}{\partial x}\frac{\partial P}{\partial y} -\frac{\partial r_y}{\partial y}\frac{\partial P}{\partial x})}.\end{align}\]</span> 变成了一个不需要显式用到 <span class="math inline">\(t\)</span> 的量，即变量 <span class="math inline">\(t\)</span> “消掉”了。代入上面焦散的表达式中，我们得到 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix}-\frac{r_x\frac{\partialP}{\partial x}+r_y\frac{\partial P}{\partial y}}{r_y(\frac{\partialr_x}{\partial x}\frac{\partial P}{\partial y}-\frac{\partialr_x}{\partial y}\frac{\partial P}{\partial x})-r_x(\frac{\partialr_y}{\partial x}\frac{\partial P}{\partial y} - \frac{\partialr_y}{\partial y}\frac{\partial P}{\partial x})}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span> 这个式子还可以再简化一点：注意到曲线在 <span class="math inline">\((x,y)\)</span> 处的法向量由 <span class="math inline">\(\mathbf{n}=\frac{\nabla P}{|\nabla P|}\)</span>给出，其中 <span class="math inline">\(\nabla P=(\frac{\partialP}{\partial x},\frac{\partial P}{\partial y})\)</span>。于是由 <span class="math display">\[\mathbf{r}= \mathbf{l}- 2(\mathbf{l}\cdot\mathbf{n})\mathbf{n}\]</span> 可得 <span class="math display">\[\mathbf{r}\cdot \nabla P=-\mathbf{l}\cdot \nablaP.\]</span> 从而 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix}+\frac{\mathbf{l}\cdot\nablaP}{r_y(\frac{\partial r_x}{\partial x}\frac{\partial P}{\partialy}-\frac{\partial r_x}{\partial y}\frac{\partial P}{\partialx})-r_x(\frac{\partial r_y}{\partial x}\frac{\partial P}{\partial y} -\frac{\partial r_y}{\partial y}\frac{\partial P}{\partialx})}\begin{pmatrix}r_x\\ r_y\end{pmatrix}.\]</span></p><p>这是四个变量 <span class="math inline">\(x,y,X,Y\)</span>满足的两个方程，形如 <span class="math inline">\(F(X,x,y)=0\)</span> 和<span class="math inline">\(G(Y,x,y)=0\)</span>。记住我们还有已知的方程<span class="math inline">\(P(x,y)=0\)</span>。为了从这三个方程中消掉<span class="math inline">\(x,y\)</span>，得到一个仅包含 <span class="math inline">\((X,Y)\)</span> 的表达式，我们可以尝试用 <a href="https://en.wikipedia.org/wiki/Gr%C3%B6bner_basis">Gröbnerbasis</a> 方法。Gröbner 基方法会把多项式方程组 <span class="math display">\[F=G=P=0\]</span> 转化为一组等价的新方程组 <span class="math display">\[g_1=g_2=\cdots=g_m=0.\]</span>即它们有完全相同的解集。</p><p><span class="math inline">\(\{g_1,\ldots,g_m\}\)</span> 是 <span class="math inline">\(F,G,P\)</span> 在多项式环 <span class="math inline">\(\mathbb{R}[x,y,X,Y]\)</span> 中生成的理想 <span class="math inline">\(I=\langle F,G,P\rangle\)</span>的一组生成元，<span class="math inline">\(\{g_1,\ldots,g_m\}\)</span>叫做 <span class="math inline">\(I\)</span> 的约化的 Gröbner基。在字典序 <span class="math inline">\(x\succ y\succ X\succ Y\)</span>下，约化的 Gröbner 基会有一个好的属性，即从 <span class="math inline">\(g_1\)</span> 到 <span class="math inline">\(g_m\)</span>，其中的变元会按照从 <span class="math inline">\(x\to y\to X\to Y\)</span>的先后顺序被消除掉。注意这是个不太严格的说法，我们并不是总能消掉顺序靠前的变元，但是如果消除发生的话，它就会按照这个顺序来。这样我们就可以执行类似高斯消元法中的回代操作，从而新方程组的求解会更加简单。</p><p>我们来用 <code>sympy</code> 实验一下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>x, y, X, Y = symbols(<span class="hljs-string">"x y X Y"</span>)<br>P = x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>dx = diff(P, x)  <span class="hljs-comment"># gradient of P</span><br>dy = diff(P, y)<br>curve = Matrix([x, y])<br>light_source = Matrix([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>l = curve - light_source  <span class="hljs-comment"># the incident ray</span><br>n = Matrix([dx, dy])  <span class="hljs-comment"># the normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n))  <span class="hljs-comment"># the reflected ray</span><br>rx, ry = r<br>dxrx = diff(rx, x)<br>dyrx = diff(rx, y)<br>dxry = diff(ry, x)<br>dyry = diff(ry, y)<br>denominator = ry * (dxrx * dy - dyrx * dx) - rx * (dxry * dy - dyry * dx)<br>nominator = dx * l[<span class="hljs-number">0</span>] + dy * l[<span class="hljs-number">1</span>]<br>F = (X - x) * denominator - nominator * rx<br>G = (Y - y) * denominator - nominator * ry<br>eqs = [eq.as_numer_denom()[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> eq <span class="hljs-keyword">in</span> [F, G, P]]<br>gb = groebner(eqs, [x, y, X, Y])<br>print(gb)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 给出的结果的最后一项是</p><p><span class="math display">\[27 X^{4} y^{2} + 54 X^{2} Y^{2} y^{2} -18 X^{2} y^{2} - 8 X y^{2} + 27 Y^{4} y^{2} - 18 Y^{2} y^{2} -y^{2}.\]</span></p><p><span class="math inline">\(x\)</span> 被消掉了！原方程组 <span class="math inline">\(F=G=P\)</span>的解必然是上面这个方程的解的子集。观察它的每一项都带有一个 <span class="math inline">\(y^2\)</span>，这显然不是我们要的解。把 <span class="math inline">\(y^2\)</span> 去掉，剩下的因子</p><p><span class="math display">\[27X^{4}+54X^{2}Y^{2}-18X^{2} -8X +27Y^{4}-18Y^{2}-1=0.\]</span></p><p>就是心脏线的隐函数表示。不信？在 <a href="https://www.desmos.com/geometry/vtjbq3ete1">Desmos</a>里面画出来看看！</p><p><img src="/images/caustics/desmos_cardioid.png" class="fig" width="300"></p><h1 id="注记">注记</h1><p>这篇文章主要覆盖了 Greg Egan博文的前半部分，他的后半部分内容我觉得有点放飞自我，也没怎么仔细看。</p><p>虽然我们用 <code>sympy</code>的实验很成功，但注意并不是所有情况下都能得到焦散曲线（比如光源位于抛物线的焦点时，反射光线都是平行的），而且对复杂的曲线<code>sympy</code> 算起来非常慢。</p><p>我研究生的时候上过计算机代数的课程，当时用的教学软件是 Maple。Maple编程是很不方便的，所以我其实没有多少计算机代数的编程经验。我之前一直觉得<code>sympy</code>运行又慢，输出的表达式也不够简化，所以不太愿意用它。这次实验有点刷新我对<code>sympy</code>的认知。我还记得当时课程要求每人提交一份读书报告，我写的是 <a href="https://link.springer.com/book/10.1007/978-3-319-16721-3">Ideals,Varieties, and Algorithms</a> 的笔记，但毕业多年以来这还是我第一次用到Gröbner 基！</p><p>我写这篇文章的时候正好临近情人节，所以我在想有没有什么曲线的焦散能给出<a href="https://www.desmos.com/geometry/ngdpq0zrei">爱心曲线</a>：</p><p><img src="/images/caustics/heart.png" class="fig" width="300"></p><p>于是我找到了 <a href="https://www.tandfonline.com/doi/full/10.1080/00029890.2020.1722019">这篇文章</a>。不过看起来里面给出的结论计算量很大，很难用在爱心线上（也许是我错了）。</p>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Möbius 变换与球的刚体运动</title>
      <link href="mobius-ball-rigid-motion/"/>
      <url>mobius-ball-rigid-motion/</url>
      
        <content type="html"><![CDATA[<p>五一期间我写了一个 shadertoy 小动画，演示 Möbius变换与球的刚体运动之间的关系：</p><span id="more"></span><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/fljfRm?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><p>这个动画的名字叫做 Möbius transformation revealed，想法源自 DouglasN. Arnold 和 Jonathan Rogness 于 2007 年发布的 <a href="https://www-users.cse.umn.edu/~arnold/moebius/">同名视频</a>。这是一个很有名的视频，它表达的核心思想是，扩充复平面<span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的 Möbius变换可以由球在三维空间中的刚体运动给出：</p><ol type="1"><li>我们称一个球 <span class="math inline">\(S\)</span>是<strong>容许</strong>的，如果 <span class="math inline">\(S\)</span>的最高点，也就是北极点位于半空间 <span class="math inline">\(\{z&gt;0\}\)</span> 中。</li><li>取任何一个可容许的球 <span class="math inline">\(S\)</span>，将<span class="math inline">\(\overline{\mathbb{C}}\)</span>在逆球极投影下对应到 <span class="math inline">\(S\)</span>的球面上。</li><li>对 <span class="math inline">\(S\)</span> 作刚体变换 （平移和旋转）<span class="math inline">\(S\to T(S)\)</span>，使得 <span class="math inline">\(T(S)\)</span> 也是一个容许的球，即 <span class="math inline">\(T(S)\)</span> 的最高点也在半空间 <span class="math inline">\(\{z&gt;0\}\)</span> 中。</li><li>将 <span class="math inline">\(T(S)\)</span>的表面通过球极投影再映射回 <span class="math inline">\(\overline{\mathbb{C}}\)</span>，我们就得到了一个<span class="math inline">\(\overline{\mathbb{C}}\to\overline{\mathbb{C}}\)</span>的变换，此变换是一个 Möbius 变换，且所有 Möbius变换都可以通过此种方式得到。</li></ol><p>整个过程如下所示：</p><p><span class="math display">\[\underbrace{\overline{\mathbb{C}}\xrightarrow{\text{inversestereographic projection}} S\xrightarrow{\text{rigid motion}}T(S)\xrightarrow{\text{stereographicprojection}}\overline{\mathbb{C}}}_{\text{Möbiustransformation}}.\]</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>球极投影使用的北极点始终是球面的最高点。</p></div><p>详细的解释可以见原视频的解释 <a href="https://www-users.cse.umn.edu/~arnold/papers/moebius.pdf">文章</a>。但是从直观上理解也不难：</p><ul><li><p><span class="math inline">\(S\)</span> 在 <span class="math inline">\(xy\)</span> 平面内的平移给出的是 <span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的平移。<video src="/images/mobius/translation.mp4" height="300" controls=""></video></p></li><li><p><span class="math inline">\(S\)</span> 在 <span class="math inline">\(z\)</span> 方向上的平移给出的是 <span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的缩放。<video src="/images/mobius/scale.mp4" height="300" controls=""></video></p></li><li><p>保持 <span class="math inline">\(S\)</span>的北极点不动的旋转给出的是 <span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的旋转。<video src="/images/mobius/rotation.mp4" height="300" controls=""></video></p></li><li><p>绕 <span class="math inline">\(x\)</span> 轴旋转 180 度给出的是<span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的逆变换<span class="math inline">\(z\to 1/z\)</span>。<video src="/images/mobius/inversion.mp4" height="300" controls=""></video></p></li></ul><p>以上几种运动方式的复合可以给出可容许球的任何刚体运动，而任何 Möbius变换都是平移、缩放、旋转、逆变换的复合，所以 Möbius变换确实与可容许球体的刚体运动是对应的。</p><p>反过来对给定的 Möbius 变换 <span class="math inline">\(M\)</span>和容许的球 <span class="math inline">\(S\)</span>，当 <span class="math inline">\(S\)</span> 的初始位置确定以后，给出 <span class="math inline">\(M\)</span> 的刚体运动 <span class="math inline">\(T\)</span> 也是唯一确定的。证明见 <a href="https://scholar.rose-hulman.edu/cgi/viewcontent.cgi?article=1218&amp;context=rhumj">这个论文</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Möbius 变换与二维 Poincaré 双曲空间的等距</title>
      <link href="mobius-poincare/"/>
      <url>mobius-poincare/</url>
      
        <content type="html"><![CDATA[<p>这几天因为疫情居家观察难得多出点时间（不用健步挤地铁），可以写点小文章。我之前写过一篇介绍<a href="/mobius-h3space">Möbius变换分类的文章</a>，今天继续那里的讨论，介绍一个 Möbius 变换 <span class="math inline">\(M\)</span> 作为二维 Poincaré 双曲圆盘 <span class="math inline">\(\mathbb{D}\)</span> 中等距的两种构造方法：</p><ol type="1"><li>指定 <span class="math inline">\(M\)</span>的不动点的个数和位置，不动点的个数和位置可以决定变换的类型。</li><li>指定两个反射镜面的位置：取两条测地线作为镜面，则关于这两个镜面的反演变换的复合变换就是一个Möbius 变换。两个镜面的相对位置可以决定变换的类型。</li></ol><p>这两种方法分别对应在 <span class="math inline">\(M\)</span>作用下保持不变的两个圆族。</p><p>本文的插图使用 <a href="https://matplotlib.org/">matplotlib</a>绘制，代码在 <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/mobius">Github</a>上。</p><span id="more"></span><p>记号约定：</p><ul><li><span class="math inline">\(\mathbb{D}\)</span> 为二维 Poincaré双曲圆盘。</li><li><span class="math inline">\(M\)</span> 为一个 Möbius 变换。</li><li><span class="math inline">\(S^1\)</span> 为单位圆周 <span class="math inline">\(|z|=1\)</span>。</li></ul><h1 id="用不动点构造双曲等距">用不动点构造双曲等距</h1><p>在复分析课程中，我们学过 <span class="math inline">\(\mathbb{D}\)</span> 的保持定向的等距同构是 Möbius群 <span class="math inline">\({\rm PSL}_2(\mathbb{C})\)</span>的一个子群，其元素具有如下的形式： <span class="math display">\[M(z) =\mathrm{e}^{i\theta}\frac{z - a}{1-\overline{a}z},\quad\theta\in\mathbb{R},\, |a|&lt;1.\]</span> 可见 <span class="math inline">\(M\)</span> 的迹 <span class="math inline">\(\mathrm{tr}(M)=\mathrm{e}^{i\theta}+1\)</span>总是满足 <span class="math inline">\(0\leq|\mathrm{tr}(M)|\leq2\)</span>，所以 <span class="math inline">\(M\)</span> 不可能是斜航型的 (loxodromic)，从而<span class="math inline">\(\mathbb{D}\)</span>的保持等向的等距只能是椭圆、抛物、双曲三种。</p><p>也可以这样解释：<span class="math inline">\(\mathbb{D}\)</span>的任何等距变换必然将 <span class="math inline">\(S^1\)</span> 仍然映射为<span class="math inline">\(S^1\)</span>，但斜航型的变换没有不变圆，所以不可能是<span class="math inline">\(\mathbb{D}\)</span> 上的等距变换。</p><p>下面分别介绍这三种情形。</p><h2 id="椭圆型">椭圆型</h2><p>椭圆型变换共轭于旋转 <span class="math inline">\(z\to\mathrm{e}^{i\theta}z\)</span>，它们总是有两个不动点。如果<span class="math inline">\(M\)</span> 是 <span class="math inline">\(\mathbb{D}\)</span> 上的椭圆型等距，则其两个不动点<span class="math inline">\(p_1,\,p_2\)</span> 必然一个在 <span class="math inline">\(\mathbb{D}\)</span> 内，一个在 <span class="math inline">\(\mathbb{D}\)</span>外，且它们关于单位圆互为反演点。设 <span class="math inline">\(p_1\in\mathbb{D}\)</span>，则 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\mathbb{D}\)</span> 上的作用是一个绕着 <span class="math inline">\(p_1\)</span> 的旋转：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/mobius/elliptic.svg"></p><p>图中画出了两族圆：</p><ol type="1"><li>第一族圆是彩色的，它们在双曲度量下的中心都是 <span class="math inline">\(p_1\)</span>，<span class="math inline">\(M\)</span> 保持每个圆不变，同时将圆上的每个点绕着<span class="math inline">\(p_1\)</span> 旋转。</li><li>第二族圆用虚线标注，这些圆都和第一族圆正交、同时经过 <span class="math inline">\(p_1\)</span> 和 <span class="math inline">\(p_2\)</span>，并且都与单位圆正交。<span class="math inline">\(M\)</span>作用在这些圆上会把一个圆变成同族中的另一个。</li></ol><p>双曲空间中的圆也是欧氏空间中的圆，但是它们的圆心未必重合。一个 <span class="math inline">\(\mathbb{D}\)</span>中的圆越靠近边界，它的双曲度量下的圆心也会被「吸引」到靠近边界的位置。</p><h2 id="抛物型">抛物型</h2><p>抛物型变换共轭于平移 <span class="math inline">\(z\toz+1\)</span>，它们总是只有一个不动点。如果 <span class="math inline">\(M\)</span> 是 <span class="math inline">\(\mathbb{D}\)</span>上的抛物型等距，则其唯一的不动点 <span class="math inline">\(p\)</span>必然位于单位圆周 <span class="math inline">\(S^1\)</span> 上，<span class="math inline">\(M\)</span> 在 <span class="math inline">\(\mathbb{D}\)</span>上的作用是一个双曲空间中的平移：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/mobius/parabolic.svg"></p><p>图中也画出了两族圆：</p><ol type="1"><li>第一族圆是彩色的，它们都和 <span class="math inline">\(S^1\)</span>在 <span class="math inline">\(p\)</span> 点处相切。<span class="math inline">\(M\)</span>作用在它们上面保持每个圆不变，同时将圆上的每个点沿着测地线向着 <span class="math inline">\(p\)</span> 移动。这些圆叫做horocycle，它们在双曲度量下的圆心是 <span class="math inline">\(p\)</span>。</li><li>第二族圆用虚线标注，这些圆都和第一族圆正交、互相之间也在 <span class="math inline">\(p\)</span> 点相切，并且都与单位圆正交。<span class="math inline">\(M\)</span>作用在这些圆上会把一个圆变成同族中的另一个。</li></ol><h2 id="双曲型">双曲型</h2><p>双曲型变换共轭于缩放 <span class="math inline">\(z\tocz,\,c\in\mathbb{R}^+\)</span>，它们总是有两个不动点。如果 <span class="math inline">\(M\)</span> 是 <span class="math inline">\(\mathbb{D}\)</span> 上的双曲型等距，则其两个不动点<span class="math inline">\(p_1,p_2\)</span> 必然都位于单位圆周 <span class="math inline">\(S^1\)</span> 上。<span class="math inline">\(M\)</span> 在 <span class="math inline">\(\mathbb{D}\)</span>上的作用以其中一个为源点，另一个为汇点：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/mobius/hyperbolic.svg"></p><p>图中的两族圆中，</p><ol type="1"><li>第一族圆是彩色的，它们同时经过 <span class="math inline">\(p_1\)</span> 和 <span class="math inline">\(p_2\)</span>，<span class="math inline">\(M\)</span>作用在它们上面保持每个圆不变，同时将圆上的每个点沿着圆给出的测地线从源点移动到汇点。</li><li>第二族圆用虚线标注，这些圆都和第一族圆正交、<span class="math inline">\(p_1\)</span> 和 <span class="math inline">\(p_2\)</span>关于它们中的每一个都互为反演点，并且都与单位圆正交。<span class="math inline">\(M\)</span>作用在这些圆上会把一个圆变成同族中的另一个。</li></ol><h1 id="用反演变换的复合构造双曲等距">用反演变换的复合构造双曲等距</h1><p>在上面的三张图中，彩色的圆对应的是 <span class="math inline">\(\mathbb{D}\)</span> 中的点在 <span class="math inline">\(M\)</span>作用下的轨迹，它们都是测地线。我似乎有意冷落了虚线的圆族，把它们画的很不起眼。其实通过它们的反演变换也可以给出<span class="math inline">\(M\)</span> 的构造：</p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr><td style="text-align: center;">椭圆型</td><td style="text-align: center;">抛物型</td><td style="text-align: center;">双曲型</td></tr><tr><td style="text-align: center;"><img src="/images/mobius/elliptic2.svg" width="180"></td><td style="text-align: center;"><img src="/images/mobius/parabolic2.svg" width="180"></td><td style="text-align: center;"><img src="/images/mobius/hyperbolic2.svg" width="180"></td></tr></tbody></table><div class="statement simple plain unnumbered"><ul><li><span class="math inline">\(M\)</span>是椭圆型的，当且仅当它是两个在 <span class="math inline">\(\mathbb{D}\)</span>中<strong>相交</strong>的圆的反演变换的复合。</li><li><span class="math inline">\(M\)</span>是抛物型的，当且仅当它是两个在 <span class="math inline">\(\mathbb{D}\)</span>中<strong>平行</strong>的圆的反演变换的复合。这里平行的意思是两圆相切，且切点位于无穷远边界上。</li><li><span class="math inline">\(M\)</span>是双曲型的，当且仅当它是两个在 <span class="math inline">\(\mathbb{D}\)</span>中<strong>超平行</strong>的圆的反演变换的复合。这里超平行的意思是它们要么不相交，要么一个完全位于另一个的内部。</li></ul></div><p>放到上半空间模型中，这些就都不难理解了：</p><ul><li>椭圆型变换共轭于绕原点的角度为 <span class="math inline">\(\theta\)</span> 的旋转，此旋转是关于两个夹角为<span class="math inline">\(\theta/2\)</span> 的直线反射的复合。</li><li>抛物型变换共轭于平移 <span class="math inline">\(T:z\to z +1\)</span>，<span class="math inline">\(T\)</span>是上半双曲空间模型中的等距，它可以表示为关于两平行直线 <span class="math inline">\(x=0\)</span> 和 <span class="math inline">\(x=1/2\)</span>的反射的复合。我们可以用一个上半空间到 <span class="math inline">\(\mathbb{D}\)</span>的等距变换把实轴变成单位圆周，并把 <span class="math inline">\(\infty\)</span> 点变到边界上的指定点 <span class="math inline">\(p\)</span>。这时所有形如 <span class="math inline">\(x=k\)</span> 的直线，由于它们都经过 <span class="math inline">\(\infty\)</span>、互相平行、与实轴正交，所以都会变成过<span class="math inline">\(p\)</span> 点、两两相切于 <span class="math inline">\(p\)</span>、且与单位圆正交的圆。在这些圆中任取两个圆，作它们反演变换的复合，给出的就是一个抛物型变换。</li><li>双曲型变换共轭于缩放 <span class="math inline">\(S:z\tocz,\,c&gt;0\)</span>，<span class="math inline">\(S\)</span>是上半空间模型中两个同心圆 <span class="math inline">\(|z|=1\)</span> 和<span class="math inline">\(|z|=\sqrt{c}\)</span>的反演变换的复合。<span class="math inline">\(S\)</span>的两个不动点是原点和无穷远点，它们关于这两个同心圆互为反演点。同理我们可以用一个从上半空间到<span class="math inline">\(\mathbb{D}\)</span>的等距变换把实轴变成单位圆，并把原点和无穷远点分别映射到单位圆周上指定的两个不动点。这两个同心圆会被映射为<span class="math inline">\(\mathbb{D}\)</span>中的两条测地线。关于这两条测地线的反演的复合就共轭于上半空间模型中的缩放。</li></ul><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>为什么两个圆的反演变换的复合是一个 Möbius 变换？你可以用一个Möbius 变换 <span class="math inline">\(T\)</span> 将任意给定的圆 <span class="math inline">\(C\)</span> 变为实直线 <span class="math inline">\(\mathbb{R}^1\)</span>，关于 <span class="math inline">\(\mathbb{R}^1\)</span> 的反演就是复共轭 <span class="math inline">\(\mathrm{conj}(z)=\overline{z}\)</span>，所以关于<span class="math inline">\(C\)</span> 的反演为 <span class="math inline">\(S=T^{-1}\cdot\mathrm{conj}\cdot T\)</span>，从而<span class="math inline">\(S\)</span> 形如 <span class="math display">\[S(z) = \frac{a\overline{z} +b}{c\overline{z}+d},\quada,b,c,d\in\mathbb{C},\,z\in\mathbb{C}_{\infty}.\]</span>里面包含了复共轭，所以 <span class="math inline">\(S\)</span> 不是Möbius 变换，但两个反演变换的复合就是 Möbius 变换。</p></div>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（六）：Boyd-Maxwell 球堆</title>
      <link href="coxeter-groups-boyd-maxwell/"/>
      <url>coxeter-groups-boyd-maxwell/</url>
      
        <content type="html"><![CDATA[<p>本文的内容主要来自 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>)</span> 和<span class="citation" data-cites="Maxwell89">(<a href="#ref-Maxwell89" role="doc-biblioref">Maxwell 1989</a>)</span>，并修复了一些错误。Maxwell在 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>, pp81)</span> 中写到：</p><div class="statement simple plain unnumbered"><p>When <span class="math inline">\(\Gamma\)</span> is hyperbolic, thecone</p><p><span class="math display">\[\{v\in V\mid (v,v)\leq0\}\]</span></p><p>has two connected components (after deleting 0), which are also theequivalent classes for the relation <span class="math display">\[u\simv\Leftrightarrow (u,v)\leq0.\]</span></p></div><p>这显然是错误的，因为如果 <span class="math inline">\(u\)</span> 是light-like 的向量，<span class="math inline">\(u\)</span> 和 <span class="math inline">\(-u\)</span> 属于不同的分支。这个错误导致后面 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>, prop 3.1)</span>的证明需要作一些修改。详情见下面的 <a href="#thm-sphere-packing" title="定理 5.5">定理 5.5</a>。</p><h1 id="射影模型">射影模型</h1><p>在这一节中，我们约定 <span class="math inline">\(V=\mathbb{R}^{n+1,1}\)</span> 是 <span class="math inline">\(n+2\)</span> 维的 Lorentzian 空间，<span class="math inline">\(\{e_1,e_2,\ldots,e_{n+2}\}\)</span> 是 <span class="math inline">\(V\)</span> 的一组标准正交基，即在这组基下内积的Gram 矩阵为 <span class="math display">\[\begin{pmatrix}I_{n+1} &amp;\\&amp; -1\end{pmatrix}.\]</span> 令 <span class="math display">\[e_0=\frac{e_{n+2}-e_{n+1}}{2},\quade_\infty=\frac{e_{n+2}+e_{n+1}}{2}.\]</span> 则 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span> 也构成<span class="math inline">\(V\)</span> 的一组基，内积在这组基下的 Gram矩阵为 <span class="math display">\[\begin{pmatrix}0&amp;&amp;&amp;-\frac{1}{2}\\&amp;I_n&amp;&amp;\\-\frac{1}{2}&amp;&amp;&amp;0\end{pmatrix}.\]</span>设 <span class="math display">\[\begin{aligned}v&amp;=ae_0 + \mathbf{x}+ be_\infty,\\w&amp;=ce_0 + \mathbf{y}+ de_\infty.\end{aligned}\]</span> 是两个向量，其中 <span class="math inline">\(\mathbf{x},\mathbf{y}\in\mathrm{span}\{e_1,\ldots,e_n\}\)</span>，<span class="math inline">\(a,b\in\mathbb{R}\)</span>，则 <span class="math inline">\(v,w\)</span> 的内积为 <span class="math display">\[(v,w) = (\mathbf{x}, \mathbf{y}) -\frac{ad+bc}{2}.\]</span> <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span>这组基在处理 <span class="math inline">\(\mathbb{R}^n\)</span>中的球时更方便一些。</p><p>设 <span class="math inline">\(v\in\mathbb{R}^{n+1,1}\)</span>，我们约定用 <span class="math inline">\([v]\)</span> 表示 <span class="math inline">\(v\)</span> 在射影空间 <span class="math inline">\(\mathrm{P}(\mathbb{R}^{n+1,1})\)</span>中的等价类。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>定义光锥 (lightcone/null cone) 为 <span class="math display">\[\mathbb{L}^{n+1}= \{v\in\mathbb{R}^{n+1,1}\mid(v,v)=0\}.\]</span> 以及 <span class="math display">\[\mathrm{P}(\mathbb{L}^{n+1})=\{[v]\midv\in\mathbb{L}^{n+1}\setminus\{0\}\}.\]</span> <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span> 是 <span class="math inline">\(\mathbb{L}^{n+1}\)</span>中所有直线组成的集合。</p></div><p>熟知 <span class="math inline">\(\overline{\mathbb{R}^n}=\mathbb{R}^n\cup\{\infty\}\)</span>和 <span class="math inline">\(\mathbb{R}^{n+1}\)</span> 中的单位球<span class="math inline">\(S^n=\{x_1^2+x_2^2+\cdots+x_{n+1}^2=1\}\)</span>在球极投影下是一一对应的（北极点为 <span class="math inline">\(e_{n+1}\)</span>）。我们来说明它们分别和 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>是一一对应的，并且当 <span class="math inline">\(\mathbf{x}\in\overline{\mathbb{R}^n}\)</span> 和<span class="math inline">\(\mathbf{y}\in S^n\)</span>在球极投影下对应时，它们在 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>中是同一个点。</p><div id="-mathrm-p---mathbb-l---n-1------------------------------" class="statement sta__mathrm_p___mathbb_l___n_1____________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label"><span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>的第一种参数化表示</span>.</span><span class="statement-spah"></span><br></p><p>我们在 <span class="math inline">\(\{e_1,\ldots,e_{n+2}\}\)</span>这组基下计算。</p><p>设 <span class="math inline">\(\mathbf{y}=y_1e_1+\cdots+y_{n+1}e_{n+1}\in\mathbb{R}^{n+1}\)</span>，则<span class="math display">\[\mathbf{y}\in S_n\Leftrightarrow|\mathbf{y}|=1\Leftrightarrow\mathbf{y}+e_{n+2}\in\mathbb{L}^{n+1}.\]</span> 即我们有一一映射： <span class="math display">\[\begin{aligned}S^n&amp;\mapsto S^n_1\\\mathbf{y}&amp;\mapsto \mathbf{y}+e_{n+2}.\end{aligned}\]</span> 其中 <span class="math inline">\(S^n_1\)</span>是平面 <span class="math inline">\(y_{n+2}=1\)</span> 与 <span class="math inline">\(\mathbb{L}^{n+1}\)</span> 相交给出的截线。由于<span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>中每个元素在 <span class="math inline">\(S^n_1\)</span>中有唯一代表元，所以 <span class="math display">\[\jmath\colon\S^n\to\mathrm{P}(\mathbb{L}^{n+1}): \mathbf{y}\to[\mathbf{y}+e_{n+2}],\]</span> 是一一对应，此即为 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>的第一种参数化表示。</p></div><div id="-mathrm-p---mathbb-l---n-1-------------------------------1" class="statement sta__mathrm_p___mathbb_l___n_1____________-1 plain unnumbered"><p><span class="statement-heading"><span class="statement-label"><span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>的第二种参数化表示</span>.</span><span class="statement-spah"></span><br></p><p>我们在 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span>这组基下计算。对 <span class="math inline">\([v]\in\mathrm{P}(\mathbb{L}^{n+1})\)</span>：</p><ul><li>如果 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(e_0\)</span> 分量不为 0，则 <span class="math inline">\(v\)</span> 形如 <span class="math display">\[v=e_0+ \mathbf{x}+ be_\infty,\quad\mathbf{x}\in\mathrm{span}\{e_1,\ldots,e_n\}.\]</span> 由于 <span class="math inline">\(v\in\mathbb{L}^{n+1}\)</span> 所以 <span class="math inline">\(b=|\mathbf{x}|^2\)</span>，即 <span class="math inline">\(v=e_0 + \mathbf{x}+|\mathbf{x}|^2e_\infty\)</span>。</li><li>如果 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(e_0\)</span> 分量等于 0，则 <span class="math inline">\(v\)</span> 形如 <span class="math display">\[v=\mathbf{x}+be_\infty,\quad\mathbf{x}\in\mathrm{span}\{e_1,\ldots,e_n\}.\]</span> <span class="math inline">\(v\in\mathbb{L}^{n+1}\)</span> 说明 <span class="math inline">\(\mathbf{x}=0\)</span>，从而 <span class="math inline">\([v] = [(0,0,b)]=[e_\infty]\)</span>。</li></ul><p>于是我们可以定义如下从 <span class="math inline">\(\overline{\mathbb{R}^n}\)</span> 到 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span> 的一一对应:<span class="math display">\[\imath(\mathbf{x})=\begin{cases}[e_0 + \mathbf{x}+|\mathbf{x}|^2e_\infty] &amp; \mathbf{x}\in\mathbb{R}^n,\\[e_\infty] &amp; \mathbf{x}= \infty.\end{cases}\]</span> 此即为 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>的第二种参数化表示。</p></div><p>我们来验证当 <span class="math inline">\(\mathbf{x}\in\overline{\mathbb{R}^n}\)</span> 和<span class="math inline">\(\mathbf{y}\in S^n\)</span> 是以 <span class="math inline">\(e_{n+1}\)</span>为北极的球极投影下的对应点时，<span class="math inline">\(\mathbf{x},\mathbf{y}\)</span>在这两种参数化表示下给出 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>的同一个点。</p><p>设 <span class="math inline">\(\mathbf{y}=y_1e_1+\cdots+y_{n+1}e_{n+1}\inS^n\)</span>，<span class="math inline">\(\mathbf{y}\)</span> 在以 <span class="math inline">\(e_{n+1}\)</span> 为北极的球极投影下对应的 <span class="math inline">\(\mathbf{x}\in\overline{\mathbb{R}^n}\)</span> 是<span class="math display">\[\mathbf{x}=\begin{cases}\sum\limits_{i=1}^n\dfrac{y_i}{1-y_{n+1}}e_i &amp; y_{n+1}\ne1,\\\infty &amp; y_{n+1}=1.\end{cases}\]</span> 我们来验证 <span class="math inline">\(\jmath(\mathbf{y})=\imath(\mathbf{x})\)</span>，即<span class="math display">\[[\mathbf{y}+ e_{n+2}] = \begin{cases}[e_0 +\mathbf{x}+ |\mathbf{x}|^2e_\infty] &amp; y_{n+1}\ne1\\[e_\infty] &amp; y_{n+1}=1.\end{cases}.\]</span></p><ul><li><p><span class="math inline">\(y_{n+1}=1\)</span> 时 <span class="math inline">\(\mathbf{y}=e_{n+1}\)</span> 从而 <span class="math inline">\(\mathbf{y}+e_{n+2}=e_{n+1}+e_{n+2}=2e_\infty\)</span>，显然与 <span class="math inline">\(e_\infty\)</span> 射影等价。</p></li><li><p><span class="math inline">\(y_{n+1}\ne 1\)</span> 时，由 <span class="math inline">\(\mathbf{y}\in S^n\)</span> 可得 <span class="math inline">\(\sum_{i=1}^ny_i^2=1-y_{n+1}^2\)</span>，从而 <span class="math display">\[|\mathbf{x}|^2=\frac{\sum_{i=1}^ny_i^2}{(1-y_{n+1})^2}= \frac{1+y_{n+1}}{1-y_{n+1}}.\]</span> 把 <span class="math inline">\(\mathbf{y}+e_{n+2}\)</span> 转化为 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span>这组基下的表示： <span class="math display">\[\mathbf{y}+e_{n+2} =\sum_{i=1}^ny_ie_i + (1-y_{n+1})e_0+(1+y_{n+1})e_\infty.\]</span> 从而<span class="math display">\[[\mathbf{y}+e_{n+2}] =\left[e_0+\sum_{i=1}^n\frac{y_i}{1-y_{n+1}}e_i+\frac{1+y_{n+1}}{1-y_{n+1}}e_\infty\right] = [e_0 + \mathbf{x}+|\mathbf{x}|^2e_\infty].\]</span></p></li></ul><h1 id="球面">球面</h1><div id="------" class="statement sta___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">记号</span>.</span><span class="statement-spah"></span>令 <span class="math inline">\(\mathcal{S}=\{v\in\mathbb{R}^{n+1,1}\mid(v,v)=1\}\)</span> 是所有 space-like 单位向量组成的集合。</p></div><p>这一小节我们来建立 <span class="math inline">\(\mathbb{R}^n\)</span>中的球/超平面和 <span class="math inline">\(\mathcal{S}\)</span>之间的一一对应。</p><p>设 <span class="math inline">\(B(\mathbf{a},r)=\{\mathbf{x}\in\mathbb{R}^n\mid|x-\mathbf{a}|=|r|\}\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span> 中以 <span class="math inline">\(\mathbf{a}\)</span> 为中心，半径为 <span class="math inline">\(r\ne 0\)</span> 的球，我们允许 <span class="math inline">\(r\)</span> 是负数以区分 <span class="math inline">\(B\)</span> 的内部和外部：<span class="math inline">\(r&gt;0\)</span> 时 <span class="math inline">\(B\)</span> 的内部就是通常意义下满足 <span class="math inline">\(|\mathbf{x}-\mathbf{a}|&lt; r\)</span>的有界集合；<span class="math inline">\(r&lt;0\)</span> 时 <span class="math inline">\(B\)</span> 的内部是满足 <span class="math inline">\(|\mathbf{x}-\mathbf{a}|&gt;|r|\)</span>的无界集合。如果用球极投影转移到 <span class="math inline">\(S^n\)</span> 中来看的话，<span class="math inline">\(\mathbb{R}^n\)</span> 中的球的内/外之分在 <span class="math inline">\(S^n\)</span> 上其实没有意义，它们不过是 <span class="math inline">\(S^n\)</span>中某个圆两侧的球帽。所以把球的内部和外部统一处理是很自然的。</p><p>我们把 <span class="math inline">\(\mathbf{a}\)</span> 看作 <span class="math inline">\(\mathrm{span}\{e_1,\ldots,e_n\}\cong\mathbb{R}^n\)</span>中的点，记 <span class="math display">\[k_B = \frac{e_0 + \mathbf{a}+(|\mathbf{a}|^2 - r^2)e_\infty}{r}.\]</span> 不难验证 <span class="math inline">\(k_B\)</span> 满足 <span class="math inline">\((k_B,k_B)=1\)</span>，所以 <span class="math inline">\(k_B\in\mathcal{S}\)</span>。</p><p>对 <span class="math inline">\(\mathbf{x}\in\mathbb{R}^n\)</span>，<span class="math inline">\(\imath(\mathbf{x})=e_0+\mathbf{x}+|\mathbf{x}|^2e_\infty\in\mathbb{L}^{n+1}\)</span>，则<span class="math display">\[(\imath(\mathbf{x}),k_B)=\frac{r^2-|\mathbf{x}-\mathbf{a}|^2}{2r}.\]</span></p><p>于是 <span class="math inline">\(\mathbf{x}\in B\)</span> 当且仅当<span class="math inline">\((\imath(\mathbf{x}),k_B)=0\)</span>，以及<span class="math inline">\(\mathbf{x}\)</span> 落在 <span class="math inline">\(B\)</span> 的内部当且仅当 <span class="math inline">\((\imath(\mathbf{x}),k_B)&gt;0\)</span>。鉴于此，我们也把<span class="math inline">\(B\)</span> 的内部叫做 <span class="math inline">\(B\)</span> 的<strong>正半空间</strong>，<span class="math inline">\(k_B\)</span> 是指向 <span class="math inline">\(B\)</span> 的正半空间的单位法向量。</p><p>注意到 <span class="math inline">\(\imath(\mathbf{x})\)</span> 和<span class="math inline">\(\jmath(\mathbf{x})\)</span>只差一个正的倍数，所以 <span class="math inline">\(\mathbf{x}\inB\)</span> 等价于 <span class="math inline">\((\jmath(\mathbf{x}),k_B)=0\)</span>。<span class="math inline">\(V\)</span> 中所有形如 <span class="math inline">\((\jmath(\mathbf{x}),k_B)=0\,(\mathbf{x}\in\mathbb{R}^n)\)</span>的点构成 <span class="math inline">\(S^n_1\)</span> 与超平面 <span class="math inline">\(k_B^\bot\)</span> 的截线。</p><p>当 <span class="math inline">\(B\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span> 中的超平面时，设其方程为<span class="math inline">\((\mathbf{x},\mathbf{n})=d\,(d\in\mathbb{R})\)</span>，其中<span class="math inline">\(\mathbf{n}\)</span> 是 <span class="math inline">\(B\)</span> 的单位法向量。我们将 <span class="math inline">\(B\)</span> 对应到 <span class="math display">\[k_B=\mathbf{n}+ 2d e_\infty.\]</span> 不难验证<span class="math inline">\((k_B,k_B)=1\)</span>，从而 <span class="math inline">\(k_B\in\mathcal{S}\)</span>，并且对 <span class="math inline">\(\imath(\mathbf{x})=e_0+\mathbf{x}+|\mathbf{x}|^2e_\infty\)</span>有 <span class="math display">\[(\imath(\mathbf{x}),k_B)=(\mathbf{x},\mathbf{n})-d.\]</span>于是 <span class="math inline">\(\mathbf{x}\in B\)</span> 当且仅当 <span class="math inline">\((\imath(\mathbf{x}),k_B)=0\)</span>，<span class="math inline">\(\mathbf{x}\)</span> 属于 <span class="math inline">\(B\)</span> 的正半空间当且仅当 <span class="math inline">\((\imath(\mathbf{x}),k_B)&gt;0\)</span>。</p><p>反之任何 <span class="math inline">\(k\in\mathcal{S}\)</span>也都唯一确定了 <span class="math inline">\(\mathbb{R}^n\)</span>中的某个球或者超平面。为此只要将 <span class="math inline">\(k\)</span>表示为 <span class="math display">\[k=be_\infty+\mathbf{a}+ce_\infty\in\mathcal{S},\quadb,c\in\mathbb{R}.\]</span> 并根据 <span class="math inline">\(b\)</span>是否等于 0 将 <span class="math inline">\(k\)</span> 对应为球 <span class="math inline">\(B(\mathbf{a}/b ,1/b)\)</span> 或者超平面 <span class="math inline">\(H(\mathbf{a}, c/2)\)</span> 即可。</p><h1 id="球面的-seperation">球面的 seperation</h1><p>设 <span class="math inline">\(B_1(\mathbf{a}_1,r_1),B_2(\mathbf{a}_2,r_2)\)</span>是 <span class="math inline">\(\mathbb{R}^n\)</span>中的两个球，它们对应的 <span class="math inline">\(\mathcal{S}\)</span>向量分别是 <span class="math display">\[\begin{aligned}k_1&amp;=\frac{1}{r_1}e_0 + \frac{\mathbf{a}_1}{r_1} +\frac{|\mathbf{a}_1|^2-r_1^2}{r_1}e_\infty,\\k_1&amp;=\frac{1}{r_2}e_0 + \frac{\mathbf{a}_2}{r_2} +\frac{|\mathbf{a}_2|^2-r_2^2}{r_2}e_\infty.\\\end{aligned}.\]</span> 不难验证有 <span class="math display">\[(k_1,k_2)=\frac{r_1^2+r_2^2 -|\mathbf{a}_1-\mathbf{a}_2|^2}{2r_1r_2}.\]</span> 我们称内积 <span class="math inline">\((k_1,k_2)\)</span> 为 <span class="math inline">\(B_1\)</span> 和 <span class="math inline">\(B_2\)</span> 的 <strong>seperation</strong>。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span> <span class="statement-info">(<span class="citation" data-cites="ratcliffe">(见 <a href="#ref-ratcliffe" role="doc-biblioref">Ratcliffe 2006, vol. 149, sec.3.2</a>)</span>)</span>：</span><span class="statement-spah"> </span>在Lorentzinian 内积下，两个 space-like 的单位向量 <span class="math inline">\(k_1,k_2\)</span> 之间的 seperation有两种含义：</p><ol type="1"><li>如果 <span class="math inline">\(|(k_1,k_2)|\leq1\)</span>，则 <span class="math inline">\((k_1,k_2)=\cos\theta\)</span>，<span class="math inline">\(\theta\)</span> 是分别以 <span class="math inline">\(x,y\)</span> 为切向量的两条测地线之间的夹角；</li><li>如果 <span class="math inline">\(|(k_1,k_2)|&gt;1\)</span>，则 <span class="math inline">\((k_1,k_2)=\pm\cosh\eta\)</span>，<span class="math inline">\(\eta\)</span> 是分别以 <span class="math inline">\(x,y\)</span>为法向量的两个超平面之间的双曲距离。</li></ol></div><ol type="1"><li><span class="math inline">\(B_1\)</span> 和 <span class="math inline">\(B_2\)</span> 相交或者相切当且仅当 <span class="math inline">\(|(k_1,k_2)|\leq1\)</span>，这时 <span class="math inline">\((k_1,k_2)=\cos\theta\)</span>，<span class="math inline">\(\theta\)</span>是它们球面交点处的内法向量夹角（用外法向量也可以，因为同时将内法向量变成外法向量，夹角的余弦不变）。当<span class="math inline">\((k_1,k_2)=-1\)</span> 时两球外切，<span class="math inline">\((k_1,k_2)=1\)</span> 时两球内切。</li><li><span class="math inline">\(B_1\)</span> 和 <span class="math inline">\(B_2\)</span> 不相交也不相切当且仅当 <span class="math inline">\(|(k_1,k_2)|&gt;1\)</span>，这时 <span class="math inline">\(|(k_1,k_2)|=\cosh\eta\)</span>，<span class="math inline">\(\eta\)</span> 是 <span class="math inline">\(k_1,k_2\)</span>对应的双曲空间中测地线的双曲距离。两球在 <span class="math inline">\((k_1,k_2)&lt;-1\)</span> 时没有公共的内部，在<span class="math inline">\((k_1,k_2)&gt;1\)</span>时一个完全包含另一个。</li></ol><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=\cos\theta(\ell_1,\ell_2)\)</span></td><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=\cosh d(\ell_1,\ell_2)\)</span></td></tr><tr><td style="text-align: center;"><img src="/images/coxeter/image0.jpg" width="150"></td><td style="text-align: center;"><img src="/images/coxeter/image1.jpg" width="150"></td></tr><tr><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=-\cosh d(\ell_1,\ell_2)\)</span></td><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=-\cosh d(\ell_1,\ell_2)\)</span></td></tr><tr><td style="text-align: center;"><img src="/images/coxeter/image2.jpg" width="150"></td><td style="text-align: center;"><img src="/images/coxeter/image3.jpg" width="150"></td></tr></tbody></table><p>上面的结论同样适用于 <span class="math inline">\(B_1\)</span> 和<span class="math inline">\(B_2\)</span> 中有平面的情形。例如设 <span class="math inline">\(B_1,B_2\)</span> 相交，并且 <span class="math inline">\(B_1\)</span> 是球面，<span class="math inline">\(B_2\)</span> 是超平面，<span class="math inline">\(k_2=\mathbf{n}+2de_\infty\)</span>，则 <span class="math display">\[(k_1,k_2)=\frac{(\mathbf{a}_1,\mathbf{n})-d}{r_1}.\]</span>这时 <span class="math inline">\((k_1,k_2)\)</span> 等于 <span class="math inline">\(B_1\)</span> 在球面交点处的内法向量和 <span class="math inline">\(B_2\)</span> 的法向量 <span class="math inline">\(\mathbf{n}\)</span> 夹角的余弦。</p><p>类似地，当 <span class="math inline">\(B_1,B_2\)</span>都是超平面时，<span class="math inline">\((k_1,k_2)=(\mathbf{n}_1,\mathbf{n}_2)\)</span>是它们法向量夹角的余弦。</p><div id="suff-for-disjoint" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(B_1,B_2\)</span> 是两个球，且 <span class="math inline">\(B_1,B_2\)</span> 的内部不相交。设 <span class="math inline">\((k_1,k_2)\)</span> 分别是它们对应的 space-like的单位向量，则 <span class="math inline">\((k_1,k_2)\leq-1\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个命题反过来是不对的。</p></div><p><strong>证明</strong>：<span class="math inline">\(B_1\)</span> 和<span class="math inline">\(B_2\)</span> 内部不相交有如下几种可能：</p><ol type="1"><li><span class="math inline">\(B_1,B_2\)</span> 都是球，半径 <span class="math inline">\(r_1,r_2\)</span> 都大于 0，并且 <span class="math inline">\(r_1+r_2 \geq|\mathbf{a}_1-\mathbf{a}_2|\)</span>。</li><li><span class="math inline">\(B_1,B_2\)</span> 都是球，半径 <span class="math inline">\(r_1&gt;0,\, r_2&lt;0\)</span>，且 <span class="math inline">\(B_1\)</span> 位于 <span class="math inline">\(B_2\)</span> 另一侧的有界区域，即 <span class="math inline">\(-r_2-r_1\geq|\mathbf{a}_1-\mathbf{a}_2|\)</span>。</li><li><span class="math inline">\(B_1\)</span> 是球，其半径 <span class="math inline">\(r_1&gt;0\)</span>；<span class="math inline">\(B_2\)</span> 是超平面，且 <span class="math inline">\(B_1\)</span> 位于 <span class="math inline">\(B_2\)</span> 的负半空间，从而其球心 <span class="math inline">\(\mathbf{a}_1\)</span> 到 <span class="math inline">\((\mathbf{n},\mathbf{x})=d\)</span> 的有向距离<span class="math inline">\(\leq-r_1\)</span>，即 <span class="math inline">\((\mathbf{a}_1,\mathbf{n})-d\leq-r_1\)</span>。</li><li><span class="math inline">\(B_1,B_2\)</span>是互相平行的超平面，且法向量相反的，即 <span class="math inline">\((\mathbf{n}_1,\mathbf{n}_2)=-1\)</span>。</li></ol><p>不难验证这些都可以推出 <span class="math inline">\((k_1,k_2)\leq-1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><h1 id="球面的反演">球面的反演</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义4.1</span>.</span><span class="statement-spah"> </span>关于球 <span class="math inline">\(B(\mathbf{a}, r)\)</span> 的反演定义为 <span class="math display">\[\begin{aligned}\tau\colon\ \overline{\mathbb{R}^n}&amp;\mapsto\overline{\mathbb{R}^n}\\\tau(\mathbf{x})&amp;=\frac{r^2}{|\mathbf{x}-\mathbf{a}|^2}(\mathbf{x}-\mathbf{a})+\mathbf{a}.\end{aligned}\]</span></p></div><p><span class="math inline">\(\tau\)</span> 是 <span class="math inline">\(\overline{\mathbb{R}^n}\)</span> 中关于球面镜<span class="math inline">\(B\)</span> 的反射，它保持 <span class="math inline">\(B\)</span> 的表面不动，将 <span class="math inline">\(B\)</span> 的内部映射为外部（反之亦然），并且<span class="math inline">\(\tau^2=1\)</span>。</p><p><img src="/images/coxeter/cartoon_mirror.png" class="fig" width="400"></p><p>我们来说明 <span class="math inline">\(\tau\)</span> 可以实现为 <span class="math inline">\(\mathrm{P}(\mathbb{R}^{n+1,1})\)</span>中的射影正交变换。</p><p>考察以 <span class="math inline">\(k_B\)</span> 为法向量的镜面反射<span class="math display">\[\begin{aligned}\rho_B\colon\ \mathbb{R}^{n+1,1}&amp;\mapsto\mathbb{R}^{n+1,1}\\\rho_B(v) &amp;= v - 2(v,k_B)k_B.\end{aligned}\]</span> 我们来计算 <span class="math inline">\(\rho_B\)</span> 作用在 <span class="math inline">\(\imath(\mathbf{x})\,(\mathbf{x}\in\mathbb{R}^n)\)</span>上的效果：（注意 <span class="math inline">\((\imath(\mathbf{x}),k_B)=\frac{r^2-|\mathbf{x}-\mathbf{a}|^2}{r}\)</span>）<span class="math display">\[\begin{align*}\begin{pmatrix}1\\\mathbf{x}\\ |\mathbf{x}|^2\end{pmatrix}&amp;\xrightarrow{\rho_B}\begin{pmatrix}1\\\mathbf{x}\\ |\mathbf{x}|^2\end{pmatrix}-\frac{r^2-|\mathbf{x}-\mathbf{a}|^2}{r}\begin{pmatrix}\frac{1}{r}\\\frac{\mathbf{a}}{r}\\\frac{|\mathbf{a}|-r^2}{r}\end{pmatrix}\\&amp;=\begin{pmatrix}\frac{|\mathbf{x}-\mathbf{a}|^2}{r^2}\\\mathbf{x}+\left(\frac{|\mathbf{x}-\mathbf{a}|^2-r^2}{r^2}\right)\mathbf{a}\\\ast \end{pmatrix}\\&amp;\sim\begin{pmatrix}1\\\mathbf{a}+\frac{r^2}{|\mathbf{x}-\mathbf{a}|^2}(\mathbf{x}-\mathbf{a})\\\ast \end{pmatrix}\\&amp;=\begin{pmatrix}1\\\tau(\mathbf{x})\\ |\tau(\mathbf{x})|^2\end{pmatrix}.\end{align*}\]</span> 这里我们不用关心 <span class="math inline">\(\ast\)</span> 是什么，中间的 <span class="math inline">\(\sim\)</span>表示两个向量是射影等价的。实际上我们是对所有分量同时除以了 <span class="math inline">\(\frac{|\mathbf{x}-\mathbf{a}|^2}{r^2}\)</span>，所以<span class="math inline">\(\sim\)</span> 还是正射影等价。</p><p>即我们有如下的交换图：</p><p><span class="math display">\[\require{amsCd}\begin{CD}\overline{\mathbb{R}^n}@&gt;{\imath}&gt;&gt;\mathrm{P}(\mathbb{L}^{n+1})\\@V{\tau}VV  @VV{\rho_B}V \\\overline{\mathbb{R}^n}@&gt;{\imath}&gt;&gt;\mathrm{P}(\mathbb{L}^{n+1})\end{CD}\]</span></p><p>更进一步，将一个球关于另一个球作反演也可以通过 <span class="math inline">\(\rho_B\)</span> 来计算。设 <span class="math inline">\(k'\)</span> 是球 <span class="math inline">\(B'\)</span> 对应的 space-like 的单位向量，则<span class="math inline">\(\rho_B(k')\)</span> 也是 space-like的单位向量，从而对应另一个球 <span class="math inline">\(B''\)</span>。对 <span class="math inline">\(\mathbf{x}\in\mathbb{R}^n\)</span>，根据上面的交换图有<span class="math inline">\(\rho_B\imath=\imath\tau\)</span>，从而 <span class="math display">\[\mathbf{x}\in B'\Leftrightarrow(\imath(\mathbf{x}), k')=0\Leftrightarrow(\rho_B(\imath(\mathbf{x})), \rho_B(k'))=0\Leftrightarrow(\imath(\tau(\mathbf{x})), \rho_B(k'))=0\Leftrightarrow \tau(\mathbf{x})\in B''.\]</span> 即关于 <span class="math inline">\(B\)</span> 的反演 <span class="math inline">\(\tau\)</span> 将 <span class="math inline">\(B'\)</span> 映射为 <span class="math inline">\(B''\)</span>。</p><h1 id="双曲球堆">双曲球堆</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.1</span>.</span><span class="statement-spah"> </span>如果一个非空集合<span class="math inline">\(\mathcal{P}\subset V\)</span>满足下列条件，我们就称 <span class="math inline">\(\mathcal{P}\)</span>是一个<strong>球堆</strong>：</p><ol type="1"><li>对任何 <span class="math inline">\(k\in\mathcal{P}\)</span> 有 <span class="math inline">\((k,k)=1\)</span>。</li><li>对 <span class="math inline">\(\mathcal{P}\)</span> 中任何 <span class="math inline">\(k\ne k'\)</span> 有 <span class="math inline">\((k,k')\leq -1\)</span>。</li></ol></div><p>我们称形如 <span class="math inline">\(\mathcal{P}=\{k,-k\}\)</span>的球堆是平凡的，因为它由一个球的内部和外部组成。否则就称 <span class="math inline">\(\mathcal{P}\)</span>是非平凡的。非平凡的球堆中的点必然两两互不共线。如果 <span class="math inline">\(\mathcal{P}\)</span> 是非平凡的球堆，则 <span class="math inline">\(-\mathcal{P}=\{-k\mid k\in\mathcal{P}\}\)</span>也是非平凡的，它是通过翻转 <span class="math inline">\(\mathcal{P}\)</span>中每个球的内部和外部得到的。</p><p>记 <span class="math inline">\(\mathcal{H}\)</span> 是超平面 <span class="math inline">\(\{v_{n+2}=1\}\)</span> 与 <span class="math inline">\(\mathcal{Q}_+\)</span> 的截面，对任何满足 <span class="math inline">\((k,k)=1\)</span> 的点 <span class="math inline">\(k\)</span>，定义球帽 <span class="math display">\[C_k = \{v\in\mathcal{H}\mid(v,k)\geq0\}.\]</span></p><div id="disjoint-pair" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span> 是球堆且 <span class="math inline">\(k_1\ne k_2\in\mathcal{P}\)</span>，则集合 <span class="math inline">\(C_{k_1}\cap C_{k_2}\)</span> 和 <span class="math inline">\(C_{-k_1}\cap C_{-k_2}\)</span>中必有一个至多只包含一个点。并且当这两个集合中的某个恰好只含一个点时，此点与<span class="math inline">\(k_1+k_2\)</span> 共线，并且有 <span class="math inline">\((k_1,k_2)=-1\)</span> 成立。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(u\inC_{k_1}\cap C_{k_2}\)</span>，<span class="math inline">\(v\inC_{-k_1}\cap C_{-k_2}\)</span>，则 <span class="math display">\[(u,k_1+k_2)\geq0\quad\text{and}\quad(v,k_1+k_2)\leq0.\]</span> 由于 <span class="math inline">\((k_1+k_2,k_1+k_2)=2+2(k_1,k_2)\leq0\)</span>，所以<span class="math inline">\(k_1+k_2\)</span> 是 time-like 或者light-like 的。如果 <span class="math inline">\(k_1+k_2\)</span> 是time-like 的，则 <span class="math inline">\(u\not\sim k_1+k_2\)</span>且 <span class="math inline">\(v\sim k_1+k_2\)</span>，这与 <span class="math inline">\(u\sim v\)</span> 矛盾。所以 <span class="math inline">\(k_1+k_2\)</span> 必须是 light-like 的，从而 <span class="math inline">\((k_1,k_2)=-1\)</span>。</p><p>进一步如果 <span class="math inline">\((u,k_1+k_2)&gt;0\)</span> 且<span class="math inline">\((v,k_1+k_2)&lt;0\)</span>，则 <span class="math inline">\(v\sim k_1+k_2\)</span> 但是 <span class="math inline">\(u\not\sim k_1+k_2\)</span>，这与 <span class="math inline">\(u\sim v\)</span> 矛盾。所以 <span class="math inline">\((u,k_1+k_2)\)</span> 和 <span class="math inline">\((v,k_1+k_2)\)</span> 中必然有一个是 0，即 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(v\)</span> 中必有一个是 <span class="math inline">\(k_1+k_2\)</span> 的倍数，然而 <span class="math inline">\(\mathcal{H}\)</span> 中与 <span class="math inline">\(k_1+k_2\)</span> 共线的点是唯一确定的，所以 <span class="math inline">\(C_{k_1}\cap C_{k_2}\)</span> 和 <span class="math inline">\(C_{-k_1}\cap C_{-k_2}\)</span>中必有一个至多包含一个点，且此点与 <span class="math inline">\(k_1+k_2\)</span> 共线。<span class="math inline">\(\blacksquare\)</span></p><div id="contain-time-like" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span> 是球堆且 <span class="math inline">\(k_1\ne k_2\in\mathcal{P}\)</span>。如果 <span class="math inline">\(|C_{k_1}\cap C_{k_2}|&gt;1\)</span>，则 <span class="math inline">\(C_{k_1}\cap C_{k_2}\)</span> 中必然包含某个time-like 的向量。</p></div><p><strong>证明</strong>： 设 <span class="math inline">\(u,v\inC_{k_1}\cap C_{k_2}\)</span> 是两个不同点，则 <span class="math inline">\(u\sim v\)</span> 且 <span class="math inline">\(u,v\)</span> 线性无关，从而 <span class="math inline">\((u,v)&lt;0\)</span>。<span class="math inline">\(z=u+v\)</span> 满足 <span class="math inline">\(z\sim u\)</span> 和 <span class="math inline">\((z,z)&lt;0\)</span>，从而 <span class="math inline">\(z\)</span> 的某个正倍数 <span class="math inline">\(z'\)</span> 属于 <span class="math inline">\(\mathcal{H}\)</span>。<span class="math inline">\(z'\)</span> 即为所求。 <span class="math inline">\(\blacksquare\)</span></p><div id="intersect-pair" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span> 是球堆且 <span class="math inline">\(k_1\ne k_2\in\mathcal{P}\)</span>。如果 <span class="math inline">\(v\in\mathcal{H}\)</span> 满足 <span class="math display">\[(v,k_1)\geq0\quad \text{and}\quad(v,k_2)&gt;0.\]</span> 则 <span class="math inline">\(|C_{k_1}\capC_{k_2}|&gt;1\)</span>。</p></div><p><strong>证明</strong>：记 <span class="math inline">\(a=(v,k_2)&gt;0\)</span>，考虑向量 <span class="math inline">\(u=v-tk_2\)</span>，其中 <span class="math inline">\(t\in(0, a)\)</span> 是实数。</p><p>由于 <span class="math inline">\((u,u)=(v,v)+t^2-2at&lt;0\)</span> 是time-like 的，以及 <span class="math inline">\((u,v)=(v,v)-at&lt;0\)</span>，所以 <span class="math inline">\(u\sim v\)</span>。从而 <span class="math inline">\(u\)</span> 的某个正倍数 <span class="math inline">\(u'=cu\,(c&gt;0)\)</span> 属于 <span class="math inline">\(\mathcal{H}\)</span>。由于</p><p><span class="math display">\[\begin{aligned}(u,k_1)&amp;=\overbrace{(v,k_1)}^{\geq0} -\overbrace{t}^{&gt;0}\cdot\overbrace{(k_1,k_2)}^{\leq-1}&gt;0,\\(u,k_2)&amp;=a-t&gt;0.\end{aligned}\]</span> 所以 <span class="math inline">\((u',k_1)&gt;0,\,(u',k_2)&gt;0\)</span>，从而<span class="math inline">\(u'\in C_{k_1}\cap C_{k_2}\)</span>。由于<span class="math inline">\(t\in(0,a)\)</span>有无穷多个取值，并且不难验证不同的 <span class="math inline">\(t\)</span> 给出的 <span class="math inline">\(u'\)</span> 互不相同，所以 <span class="math inline">\(|C_{k_1}\cap C_{k_2}|=\infty&gt;1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="thm-sphere-packing" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.5</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span> 是 <span class="math inline">\(V\)</span>的一个非空子集，则下面两点是等价的：</p><ol type="1"><li><span class="math inline">\(\mathcal{P}\)</span>是一个非平凡的球堆。</li><li>对 <span class="math inline">\(\mathcal{P}\)</span> 或者 <span class="math inline">\(-\mathcal{P}\)</span> 之一，其包含的任何两个球帽<span class="math inline">\(C_k\)</span> 和 <span class="math inline">\(C_{k'}\)</span> 至多有一个公共点。</li></ol></div><p><strong>证明</strong>：</p><p>1 <span class="math inline">\(\Rightarrow\)</span> 2：根据 <a href="#disjoint-pair" title="引理 5.2">引理 5.2</a>，不妨设 <span class="math inline">\(k_1,k_2\in\mathcal{P}\)</span> 使得 <span class="math inline">\(C_{k_1}\cap C_{k_2}\)</span>至多包含一个点。我们来证明任何两个球帽 <span class="math inline">\(k\nek'\in\mathcal{P}\)</span> 之间至多只有一个公共点。不妨设 <span class="math inline">\(k\notin\{k_1,k_2\}\)</span>。用反证法，若 <span class="math inline">\(|C_k\capC_{k'}|&gt;1\)</span>，我们来说明这时同样也有 <span class="math inline">\(|C_{-k}\cap C_{-k'}|&gt;1\)</span>，从而与 <a href="#disjoint-pair" title="引理 5.2">引理 5.2</a> 矛盾。</p><p>根据 <a href="#contain-time-like" title="引理 5.3">引理 5.3</a>，存在time-like 的向量 <span class="math inline">\(v\in C_k\capC_{k'}\)</span>。我们来找 <span class="math inline">\(w\simv\)</span> 满足 <span class="math inline">\((w, k)&lt;0\)</span> 和<span class="math inline">\((w,k')\leq0\)</span>，这样的话 <span class="math inline">\(w\)</span> 的某个正倍数 <span class="math inline">\(w'\in\mathcal{H}\)</span> 并且 <span class="math inline">\((w',-k)&gt;0,\,(w',-k')\geq0\)</span>，根据<a href="#intersect-pair" title="引理 5.4">引理 5.4</a> 即得 <span class="math inline">\(|C_{-k}\cap C_{-k'}|&gt;1\)</span>。</p><p><span class="math inline">\(w\)</span> 的构造很容易，<span class="math inline">\(w=k_1-(k_1,k_2)k_2\)</span> 就满足要求。不难验证<span class="math inline">\((w, k)&lt;0\)</span> 和 <span class="math inline">\((w,k')\leq0\)</span>。麻烦的地方在于证明 <span class="math inline">\(w\sim v\)</span>。由于 <span class="math inline">\(v\)</span> 是 time-like 的，所以只要 <span class="math inline">\((v,w)\leq0\)</span> 即可保证 <span class="math inline">\(w\sim v\)</span>（实际上严格的不等号成立）。我们有<span class="math display">\[(v,w)=(v,k_1)-(k_1,k_2)(v,k_2)=(v-(v,k_2)k_2,k_1).\]</span> 记 <span class="math inline">\(u=v-(v,k_2)k_2\)</span>，则目标变为证明 <span class="math inline">\((u,k_1)\leq0\)</span>。注意到</p><p><span class="math display">\[\begin{aligned}(u,k_2) &amp;= (v,k_2) - (v,k_2)(k_2,k_2)=0,\\(u,u)&amp;=(u,v),\\(u,u)&amp;=\underbrace{(v,v)}_{&lt;0}-\underbrace{(v,k_2)^2}_{\leq0}&lt;0.\end{aligned}\]</span> 即 <span class="math inline">\((u,u)=(u,v)&lt;0\)</span>，从而<span class="math inline">\(u\sim v\)</span>。于是 <span class="math inline">\(u\)</span> 的某个正倍数 <span class="math inline">\(u'\)</span> 属于 <span class="math inline">\(\mathcal{H}\)</span>。如果 <span class="math inline">\((u,k_1)&gt;0\)</span> 的话由 <a href="#intersect-pair" title="引理 5.4">引理 5.4</a> 可得 <span class="math inline">\(|C_{k_1}\cap C_{k_2}|&gt;1\)</span>，矛盾。从而<span class="math inline">\((v,w)\leq0\)</span>。这就证明了 <span class="math inline">\(w\sim v\)</span>。</p><p>2 <span class="math inline">\(\Rightarrow\)</span> 1: 不妨设 <span class="math inline">\(\mathcal{P}\)</span>中任何两个球帽至多只有一个交点。则对任何 <span class="math inline">\(k_1,k_2\in\mathcal{P}\)</span>，内积 <span class="math inline">\((\cdot,\cdot)\)</span> 限制在二维子空间 <span class="math inline">\(U=\mathrm{span}\{k_1,k_2\}\)</span>上肯定不是正定的，否则的话 <span class="math inline">\(U^\bot=k_1^\bot\cap k_2^\bot\)</span> 是 time-like的，从而 <span class="math inline">\(C_{k_1}\)</span> 和 <span class="math inline">\(C_{k_2}\)</span> 会在 <span class="math inline">\(\mathcal{H}\)</span> 的内部有交点，所以 <span class="math inline">\(|(k_1,k_2)|\geq1\)</span>。如果 <span class="math inline">\((k_1,k_2)\geq1\)</span>，则 <span class="math inline">\(C_{k_1}\cap C_{-k_2}\)</span> 和 <span class="math inline">\(C_{-k_1}\cap C_{k_2}\)</span>中必有一个至多只包含一个点，不妨设 <span class="math inline">\(|C_{k_1}\cap C_{-k_2}|\leq1\)</span>。但是根据已知<span class="math inline">\(C_{k_1}\cap C_{k_2}\)</span>也至多只包含一个点，从而 <span class="math inline">\(C_{k_1}\)</span>作为二者的并至多只有一个点，矛盾。<span class="math inline">\(\blacksquare\)</span></p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.6</span>.</span><span class="statement-spah"> </span>记 <span class="math inline">\(\Omega_r=\{\omega\in\Omega\mid(\omega,\omega)&gt;0\}\)</span> 是所有实权组成的集合，<span class="math inline">\(\mathcal{C}_r=\mathrm{cone}(\Omega_r)\)</span>是由所有实权生成的凸锥，以及 <span class="math display">\[\hat{\Omega}_r=\{\hat{\omega}\mid\omega\in\Omega_r\}.\]</span> 其中 <span class="math inline">\(\hat{\omega}=\omega/\sqrt{(\omega,\omega)}\)</span>是将 <span class="math inline">\(\omega\)</span>归一化得到的单位向量。</p></div><div id="real-cone-closure" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.7</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(W\)</span> 是不可约、双曲的，且 level 大于等于2，则 <span class="math inline">\(\overline{\mathcal{C}_r}= \overline{\mathcal{C} }\)</span>。</p></div><p><strong>证明</strong>：只要证明 <span class="math inline">\(\overline{\mathcal{C}_r}\)</span>包含那些非实的基本权 <span class="math inline">\((\omega_s,\omega_s)\leq 0\)</span> 即可。若如此，则 <span class="math inline">\(\overline{\mathcal{C}_r}\)</span> 包含全部基本权<span class="math inline">\(\Delta^\ast\)</span>，从而也包含 <span class="math inline">\(\mathrm{cone}(\Delta^\ast)=\overline{\mathcal{D}}\)</span>，再结合<span class="math inline">\(\overline{\mathcal{C}_r}\)</span> 是 <span class="math inline">\(W\)</span>- 不变的，即得 <span class="math inline">\(\overline{\mathcal{C}_r}\)</span> 包含 <span class="math inline">\(\bigcup\limits_{w\inW}w\overline{\mathcal{D}}=\mathcal{C}\)</span>，从而包含 <span class="math inline">\(\overline{ \mathcal{C} }\)</span>。</p><p>设 <span class="math inline">\(\omega_s\)</span>是任一非实的基本权，记 <span class="math inline">\(I=S-\{s\}\)</span>，<span class="math inline">\(W_I\)</span> 为标准椭圆子群。</p><p><span class="math inline">\((\omega_s,\omega_s)&lt;0\)</span>的情形比较容易，这时 <span class="math inline">\(\omega_s\)</span> 是time-like 的，其正交补 <span class="math inline">\(V_I=\mathrm{span}\{\alpha_t\mid t\ne s\}\)</span>是 space-like 的，从而 <span class="math inline">\(W_I\)</span>是有限群。任取一个实的基本权 <span class="math inline">\((\omega_t,\omega_t)&gt;0\,(t\in I)\)</span> 并考虑<span class="math display">\[v = \sum_{w\in W_I}w(\omega_t),\]</span>显然 <span class="math inline">\(v\in\overline{\mathcal{C}_r}\)</span>，并且 <span class="math inline">\(W_I\)</span> 保持 <span class="math inline">\(v\)</span> 不动。特别地对任何 <span class="math inline">\(t\in I\)</span> 都有 <span class="math inline">\(t(v)=v\)</span>。这是 <span class="math inline">\(n-1\)</span>个独立的线性约束，其解空间是一维的，所以 <span class="math inline">\(v\)</span> 和 <span class="math inline">\(\omega_s\)</span> 共线：存在 <span class="math inline">\(a\in\mathbb{R}\)</span> 使得 <span class="math inline">\(v=a\omega_k\)</span>。两边同时与 <span class="math inline">\(\alpha_s\)</span> 作内积得到 <span class="math display">\[a = (\alpha_s,v)=\sum_{w\inW_I}(\alpha_s,w(\omega_t))=\sum_{w\in W_I}(w^{-1}(\alpha_s),\omega_t)=\sum_{w\in W_I}(w(\alpha_s), \omega_t).\]</span> 对任何 <span class="math inline">\(w\in W_I\)</span>，<span class="math inline">\(w\alpha_s\)</span> 形如 <span class="math inline">\(w\alpha_s=\alpha_s+\sum_{i\inI}c_i\alpha_i\)</span>，所以 <span class="math inline">\(w\alpha_s\)</span> 仍然是正根，所有的系数 <span class="math inline">\(c_i\)</span> 都非负。所以上式右边的每一项 <span class="math display">\[(w(\alpha_s), \omega_t)=\sum_{i\inI}c_i(\alpha_i, w_t) = c_t\geq0.\]</span> 我们来选择一个特殊的 <span class="math inline">\(w\in W_I\)</span> 使得 <span class="math inline">\(c_t&gt;0\)</span>：由于 <span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(\Gamma\)</span> 中存在一条从 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(t\)</span> 的路径 <span class="math inline">\(s=s_0\sim s_1\sim\cdots\sims_m=t\)</span>，其中每个 <span class="math inline">\(s_i\,(i\geq1)\inI\)</span> 且互不相同。不难验证对 <span class="math inline">\(w=s_m\cdots s_1\in W_I\)</span>，<span class="math inline">\(w\alpha_s\)</span> 的系数 <span class="math inline">\(c_t&gt;0\)</span>，所以 <span class="math inline">\(a\)</span> 严格大于 0，所以 <span class="math inline">\(\omega_s=v/a\in\overline{\mathcal{C}_r}\)</span>。</p><p><span class="math inline">\((\omega_s, \omega_s)=0\)</span>的情形稍微麻烦一些：这时 <span class="math inline">\(\omega_s\)</span>的正交补 <span class="math inline">\(\omega_s^\bot\)</span> 是light-like 的，即子图 <span class="math inline">\(\Gamma\setminus\{s\}\)</span>是仿射的。特别地，<span class="math inline">\(\Gamma\setminus\{s\}\)</span>由一些仿射或者有限的连通成分组成，并且有且恰有一个连通成分是仿射的（否则两个线性无关的light-like 的向量的组合会给出 time-like 的向量）。任取一个实的基本权<span class="math inline">\((\omega_t,\omega_t)&gt;0\)</span>，我们需要讨论两种情况：</p><ol type="1"><li><p>如果 <span class="math inline">\(\omega_t\)</span>属于某个有限型的连通成分 <span class="math inline">\(Y\)</span>，类似上面的讨论，<span class="math inline">\(v = \sum_{w\inW_Y}w(\omega_t)\in\overline{\mathcal{C}_r}\)</span> 满足对任何 <span class="math inline">\(t\ne s\)</span> 都有 <span class="math inline">\(t(v)=v\)</span>，从而 <span class="math inline">\(v\)</span> 等于 <span class="math inline">\(\omega_s\)</span> 乘以一个正实数，从而 <span class="math inline">\(\omega_s\in\overline{\mathcal{C}_r}\)</span>。</p></li><li><p>如果 <span class="math inline">\(\omega_t\)</span>属于某个仿射型的连通成分 <span class="math inline">\(X\)</span>，设<span class="math inline">\(Y=\Gamma\setminus(X\cup\{s\})\)</span> 是<span class="math inline">\(\Gamma\setminus\{s\}\)</span> 除去 <span class="math inline">\(X\)</span> 以外其它连通成分的并，则 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 互不连通，从而 <span class="math display">\[\omega_s = \underbrace{(\omega_s,\omega_s)}_{=0}\alpha_s + \sum_{t\ne s} (\omega_s,\omega_t)\alpha_t=\sum_{t\in X} (\omega_s,\omega_t)\alpha_t + \sum_{t\inY} (\omega_s,\omega_t)\alpha_t=v_1+v_2.\]</span> 这里 <span class="math inline">\(v_1\)</span> 和 <span class="math inline">\(v_2\)</span> 是正交的。于是 <span class="math display">\[(\omega_s, \omega_s)=0\Rightarrow(v_1+v_2,v_1+v_2)=0\Rightarrow (v_1,v_1) + (v_2,v_2) = 0.\]</span> 由于<span class="math inline">\(v_1\in V_X\)</span> 来自不可约仿射型，<span class="math inline">\(v_2\in V_Y\)</span> 来自有限型，所以 <span class="math inline">\(\mathbb{R}v_1=\mathrm{rad}(V_X)\)</span> 并且<span class="math inline">\(v_2=0\)</span>，从而 <span class="math inline">\(\omega_s=v_1\)</span>。于是 <span class="math inline">\(\mathbb{R}\omega_s=\mathrm{rad}(V_X)\)</span>。从而<span class="math inline">\(\omega_s\)</span> 表示为 <span class="math inline">\(\{\alpha_i\mid i\in X\}\)</span>的线性组合时，所有的系数 <span class="math inline">\((\omega_s,\omega_i)\)</span>系数都是非零且同号的。我们断言它们都小于 0。实际上在 <span class="math display">\[\omega_s=\sum_{i\in X}(\omega_s,\omega_i)\alpha_i\]</span> 两边同时用 <span class="math inline">\(\alpha_s\)</span> 作内积有 <span class="math display">\[1=(\omega_s,\alpha_s)=\sum_{i\in X} (\omega_s,\omega_i)\underbrace{(\alpha_s,\alpha_i)}_{\leq0}.\]</span> 所以必须所有<span class="math inline">\((\omega_s, \omega_i)&lt;0\)</span>。所以<span class="math inline">\(X\cup \{s\}\)</span> 构成的子图满足 <a href="/coxeter-groups-level/#ideal-vertex">这个结论</a>的条件，于是我们得到 <span class="math display">\[\omega_s\in\overline{\mathrm{cone}(\bigcup_{w\in W_I}w(\omega_t))}\subset\overline{\mathcal{C}_r}.\]</span></p></li></ol><p><span class="math inline">\(\blacksquare\)</span></p><div id="max-packing" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.8</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(W\)</span> 是双曲的，则 <span class="math inline">\(\hat{\Omega}_r\)</span> 是非平凡的球堆当且仅当<span class="math inline">\(\Gamma\)</span> 的 level 是 2，这时 <span class="math inline">\(\hat{\Omega}_r\)</span> 还是极大球堆。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(\Gamma\)</span>的 level 是 2，则 <a href="/coxeter-groups-level#level-12"><span class="math inline">\(\Omega_r\)</span>中的元素两两分离</a>，将其归一化后得到的 <span class="math inline">\(\hat{\Omega}_r\)</span> 仍然两两分离，所以 <span class="math inline">\(\hat{\Omega}_r\)</span> 的元素两两之间的内积 <span class="math inline">\(\leq -1\)</span>，从而 <span class="math inline">\(\hat{\Omega}_r\)</span> 给出一个球堆。如果存在某个space-like 的向量 <span class="math inline">\(k\)</span> 满足 <span class="math inline">\((k,k)=1\)</span> 且 <span class="math inline">\(k\)</span> 对应的球与 <span class="math inline">\(\hat{\Omega}_r\)</span>中的任何球都没有公共内部的话，有 <span class="math inline">\((k,\hat{\omega})\leq -1\)</span> 对任何 <span class="math inline">\(\hat{\omega}\in\hat{\Omega}_r\)</span> 成立，从而<span class="math inline">\((k,\omega)&lt;0\)</span> 对任何 <span class="math inline">\(\omega\in\Omega_r\)</span> 成立，从而 <span class="math inline">\((k,y)\leq0\)</span> 对任何 <span class="math inline">\(y\in\overline{\mathcal{C}_r}=\mathrm{cone}(\Omega_r)\)</span>成立。根据 <a href="#real-cone-closure" title="定理 5.7">定理5.7</a>，<span class="math inline">\(\overline{\mathcal{C}_r}=\overline{\mathcal{C} }\)</span>，这意味着 <span class="math inline">\((k,y)\leq0\)</span> 对任何 <span class="math inline">\(y\in\mathcal{C}\)</span> 成立，即 <span class="math inline">\(-k\in\mathcal{C}^\ast\)</span>。由于 <a href="/coxeter-groups-tits-cone/#dual-cone-nonspace">对偶锥 <span class="math inline">\(\mathcal{C}^\ast\)</span> 中的向量范数 <span class="math inline">\(\leq0\)</span></a>，<span class="math inline">\((k,k)=(-k,-k)\leq0\)</span>，矛盾。这就证明了level 2 时 <span class="math inline">\(\Omega_r\)</span>是极大球堆。</p><p>反之若 <span class="math inline">\(\hat{\Omega}_r\)</span>是一个非平凡球堆，则 <span class="math inline">\(W\)</span> 的 level必然大于 1，且所有的实权之间两两分离。于是任何两个基本权生成的二维子空间<span class="math inline">\(\mathrm{span}\{\omega_i,\omega_j\}\)</span>都是 time-like 或者 light-like 的。又由于 <span class="math inline">\(W\)</span> 是双曲的，从而 <span class="math inline">\(\Gamma\setminus\{i,j\}\)</span> 是 space-like 或者light-like 的，所以 <span class="math inline">\(\Gamma\)</span> 的 level只能是 2。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Maxwell82" class="csl-entry" role="listitem">Maxwell, George. 1982. <span>“Sphere Packings and Hyperbolic ReflectionGroups.”</span> <em>Journal of Algebra</em> 79 (1): 78–97. <a href="https://doi.org/10.1016/0021-8693(82)90318-0">https://doi.org/10.1016/0021-8693(82)90318-0</a>.</div><div id="ref-Maxwell89" class="csl-entry" role="listitem">———. 1989. <span>“Wythoff’s Construction for Coxeter Groups.”</span><em>Journal of Algebra</em> 123 (2): 351–77. <a href="https://doi.org/10.1016/0021-8693(89)90051-3">https://doi.org/10.1016/0021-8693(89)90051-3</a>.</div><div id="ref-ratcliffe" class="csl-entry" role="listitem">Ratcliffe, John G. 2006. <em>Foundations of Hyperbolic Manifolds</em>.Second. Vol. 149. Graduate Texts in Mathematics. Springer.</div></div>]]></content>
      
      
      <categories>
          
          <category> Coxeter Groups </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（五）：Coxeter 群的 level</title>
      <link href="coxeter-groups-level/"/>
      <url>coxeter-groups-level/</url>
      
        <content type="html"><![CDATA[<p>本文主要改写自 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>)</span>和<span class="citation" data-cites="Maxwell89">(<a href="#ref-Maxwell89" role="doc-biblioref">Maxwell1989</a>)</span>。</p><p>我们来介绍 Coxeter 群的 level 的概念，并证明 level 等于 1 或 2的群都是双曲的。</p><h1 id="level-的定义">level 的定义</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span> <span class="statement-info">(<span class="citation" data-cites="Maxwell82">Maxwell (<a href="#ref-Maxwell82" role="doc-biblioref">1982</a>)</span>)</span>.</span><span class="statement-spah"> </span><span class="math inline">\((W,S)\)</span> 的 level 定义为最小的非负整数 <span class="math inline">\(l\)</span>，使得在 <span class="math inline">\(\Gamma\)</span> 中删去任何 <span class="math inline">\(l\)</span>个顶点后，剩下的部分每个连通分支都是仿射或者有限的。</p></div><p>根据定义有限和仿射 Coxeter 群的 level 都是0（因为不需要删去任何顶点）。</p><p>我们来看几个 level 大于 0 的例子：</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span></p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr><td style="text-align: center;">level=1</td><td style="text-align: center;">level=2</td><td style="text-align: center;">level=3</td></tr><tr><td style="text-align: center;"><img src="/images/coxeter/level1.svg" class="fig" width="120"></td><td style="text-align: center;"><img src="/images/coxeter/level2.svg" class="fig" width="120"></td><td style="text-align: center;"><img src="/images/coxeter/level3.svg" class="fig" width="120"></td></tr></tbody></table><ul><li>左图的三条边标号分别是 <span class="math inline">\((3,3,7)\)</span>，它是双曲的；但是删去任何一个顶点后剩下的两个顶点给出一个有限二面体群，所以其level 等于 1。</li><li>中间图的三条边标号（采用了 Vinberg 记号）分别是 <span class="math inline">\((3, 4,-1.1)\)</span>，它删去红色顶点以后剩下的两个顶点仍然构成一个双曲群，所以level 大于 1；删去任何两个顶点的话只剩一个顶点当然是有限的，所以这个群的level 就是 2。</li><li>右图删去两个红色顶点以后剩下的两个顶点仍然构成一个 Vinberg记号下的双曲群，所以 level 大于2；删去任何三个顶点以后只剩一个顶点当然是有限的，所以这个群的 level 等于3。</li></ul></div><div id="level-l" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\Gamma\)</span> 是连通的，且 level 等于 <span class="math inline">\(l\)</span>，则在 <span class="math inline">\(\Gamma\)</span> 中删去任何 <span class="math inline">\(l+1\)</span>个顶点后，剩下的每个连通成分都是有限的。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(l\)</span>归纳。当 <span class="math inline">\(l=0\)</span>时，由于在一个有限或者仿射的连通图中删去任何一个顶点后剩下的一定是有限子图<span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.2.6</a>)</span>，所以结论成立。</p><p>假设结论对所有小于 <span class="math inline">\(l\)</span>的正整数成立，考虑 <span class="math inline">\(l\)</span>的情形。用反证法。</p><p>假设从 <span class="math inline">\(\Gamma\)</span> 中删去 <span class="math inline">\(\{i_1,\ldots,i_{l+1}\}\)</span> 这 <span class="math inline">\(l+1\)</span>个顶点后，剩下的部分中某个连通分支是仿射的。不妨设 <span class="math inline">\(\Gamma\setminus\{i_1,\ldots,i_{l+1}\}=\Gamma'\cup\Gamma''\)</span>，其中<span class="math inline">\(\Gamma'\)</span>是一个仿射的连通分支，<span class="math inline">\(\Gamma''\)</span>（可能为空集）和 <span class="math inline">\(\Gamma'\)</span> 之间没有边相连。</p><p><img src="/images/coxeter/lemma.svg" class="fig" width="400"></p><p>由于 <span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(\Gamma'\)</span> 必然和 <span class="math inline">\(\{i_1,\ldots,i_{l+1}\}\)</span>中某个顶点有边连接，不妨设为 <span class="math inline">\(i_{l+1}\)</span>。</p><p>由于 <span class="math inline">\(\Gamma\)</span> 的 level 是 <span class="math inline">\(l\)</span>，所以 <span class="math inline">\(\{i_{l+1}\}\cup\Gamma'\subseteq\Gamma\setminus\{i_1,\ldots,i_l\}\)</span>是一个仿射的连通子图，这个仿射子图删除 <span class="math inline">\(i_{l+1}\)</span> 后得到的 <span class="math inline">\(\Gamma'\)</span> 仍然是仿射的，这与 <span class="math inline">\(l=0\)</span> 的情形矛盾，所以结论得证。<span class="math inline">\(\blacksquare\)</span></p><h1 id="准备">准备</h1><p>这一节是纯技术性的，我会介绍几个关于 <span class="math inline">\(\Delta=\{\alpha_s\mid s\in S\}\)</span> 和对偶基<span class="math inline">\(\Delta^\ast=\{\omega_s\mid s\in S\}\)</span>之间关系的显然等式，这样下文用到它们时就不必再重复说明。</p><p>在本节中我们都假定内积 <span class="math inline">\((\cdot,\cdot)\)</span>是非退化的，于是我们可以通过 <span class="math inline">\((\cdot,\cdot)\)</span> 将 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 等同起来：对任何 <span class="math inline">\(\alpha_s\in\Delta\)</span> 和 <span class="math inline">\(\omega_t\in\Delta^\ast\)</span> 有 <span class="math inline">\((\alpha_s,\omega_t)=\delta_{st}\)</span>。</p><p>内积 <span class="math inline">\((\cdot,\cdot)\)</span> 在 <span class="math inline">\(\Delta\)</span> 这组基下的 Gram 矩阵记作 <span class="math display">\[A=\big((\alpha_s,\alpha_t)\big)_{s,t\in S}\.\]</span> 则 <span class="math inline">\((\cdot,\cdot)\)</span> 在<span class="math inline">\(\Delta^\ast\)</span> 这组基下的 Gram矩阵就是 <span class="math display">\[A^{-1}=\big((\omega_s,\omega_t)\big)_{s,t\in S}\.\]</span> <span class="math inline">\(A\)</span> 的第 <span class="math inline">\(s\)</span> 行与 <span class="math inline">\(A^{-1}\)</span> 的第 <span class="math inline">\(s\)</span> 列的点积是 1，所以 <span class="math display">\[1=\sum_{t\in S}(\alpha_s,\alpha_t)\cdot(\omega_t,\omega_s)=(\omega_s,\omega_s)+\sum_{t\nes}(\omega_t,\omega_s)\cdot(\alpha_s,\alpha_t).\tag{I}\label{eq:idI}\]</span>这是我们的第一个恒等式。</p><p>设 <span class="math inline">\(\mathbf{A}\)</span> 是 <span class="math inline">\(V\)</span> 上的线性变换，满足对每个 <span class="math inline">\(s\in S\)</span> 有 <span class="math inline">\(\mathbf{A}(\omega_s)=\alpha_s\)</span>，则 <span class="math inline">\(\mathbf{A}\)</span> 在 <span class="math inline">\(\{\omega_s\}\)</span> 这组基下的矩阵就是 <span class="math inline">\(A\)</span>： <span class="math display">\[(\alpha_1,\ldots,\alpha_n)=(\omega_1,\ldots,\omega_n)A.\]</span> 于是 <span class="math display">\[(\omega_1,\ldots,\omega_n)=(\alpha_1,\ldots,\alpha_n)A^{-1}.\]</span>在两边取下标为 <span class="math inline">\(s\)</span> 的列，得到 <span class="math display">\[\omega_s = \sum_{t\in S}\alpha_t \cdot(\omega_t,\omega_s)=(\omega_s,\omega_s)\alpha_s + \sum_{t\ne s}(\omega_s,\omega_t)\alpha_t.\tag{II}\label{eq:idII}\]</span>这是我们的第二个恒等式。</p><h1 id="level-1-是双曲的">Level 1 是双曲的</h1><p>本节来证明 level 等于 1 的群都是双曲的。</p><p>首先是一个定义：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义3.1</span>.</span></p><ul><li>如果 <span class="math inline">\(v\in V\)</span> 满足 <span class="math inline">\((v, v)&gt;0\)</span>，我们就称 <span class="math inline">\(v\)</span> 是<strong>实的</strong>。</li><li>如果 <span class="math inline">\(u,v\in V\)</span> 满足 <span class="math inline">\((u,v)\leq 0\)</span> 且 <span class="math inline">\(u,v\)</span> 张成的二维子空间 <span class="math inline">\(\mathrm{span}\{u,v\}\)</span><strong>不是正定</strong>的，就称 <span class="math inline">\(u,v\)</span> 是<strong>分离</strong>的(disjoint)。</li></ul></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在 <span class="math inline">\((\cdot,\cdot)\)</span> 是Lorentzian 内积时，<span class="math inline">\(v\)</span> 是实的等价于<span class="math inline">\(v\)</span> 是 space-like 的。</p></div><div id="lemma-uv" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\Gamma\)</span> 的 level 大于等于1，并且不是双曲的，则 <span class="math inline">\(V\)</span>中存在两个互相正交的向量 <span class="math inline">\(u,v\)</span> 满足<span class="math inline">\((u,u)&lt;0\)</span> 和 <span class="math inline">\((v,v)=0\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(\Gamma\)</span> 的 level 大于等于 1，所以 <span class="math inline">\((\cdot,\cdot)\)</span>不可能是正定或者半正定的，显然也不可能是负定/半负定的（因为所有根 <span class="math inline">\(\alpha\)</span> 的范数都是 1），所以 <span class="math inline">\((\cdot,\cdot)\)</span> 的正负惯性指数都非 0。如果<span class="math inline">\(W\)</span> 不是双曲的，那么有两种可能：</p><ol type="1"><li><span class="math inline">\((\cdot,\cdot)\)</span> 的负惯性指数是 1且 <span class="math inline">\(\mathrm{rad}(V)\ne\{0\}\)</span>。</li><li><span class="math inline">\((\cdot,\cdot)\)</span>的负惯性指数至少是 2。</li></ol><p>情形 1 可以取 <span class="math inline">\(V\)</span>的一组正交基包含两个向量 <span class="math inline">\(u,v\)</span> 满足<span class="math inline">\((u, u)=-1\)</span> 和 <span class="math inline">\((v,v)=0\)</span>。情形 2 可以取 <span class="math inline">\(V\)</span> 的一组正交基包含三个向量 <span class="math inline">\(x,y,z\)</span> 满足 <span class="math inline">\((x,x)=1\)</span> 和 <span class="math inline">\((y, y)=(z,z)=-1\)</span>，然后取 <span class="math inline">\(u=z\)</span> 和 <span class="math inline">\(v=x+y\)</span>，则 <span class="math inline">\(u,v\)</span> 正交且 <span class="math inline">\((u,u)=-1,\,(v,v)=0\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="level-1" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.3</span> <span class="statement-info">(<span class="citation" data-cites="Maxwell82">Maxwell (<a href="#ref-Maxwell82" role="doc-biblioref">1982</a>)</span>)</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\Gamma\)</span> 的 level 是 1，则 <span class="math inline">\(\Gamma\)</span> 是双曲的。所有的 <a href="/coxeter-groups-tits-cone#fundamental-weights">基本权</a>都不是实的并且两两分离。</p></div><p><strong>证明</strong>：首先注意到 <span class="math inline">\(\Gamma\)</span> 的 level 是 1 蕴含了 <span class="math inline">\(\Gamma\)</span> 是连通的，若不然，设 <span class="math inline">\(\Gamma=\Gamma_1\cup\cdots\cup\Gamma_k\)</span>是多于一个连通分支的并，则每个分支 <span class="math inline">\(\Gamma_i\)</span>作为删去其它分支后剩下的子图必须都是有限或者仿射的，但这导致 <span class="math inline">\(\Gamma\)</span> 的 level 是 0，矛盾。</p><p>我们需要证明三件事情：</p><ol type="1"><li>内积 <span class="math inline">\((\cdot,\cdot)\)</span>的正负惯性指数是 <span class="math inline">\((n-1, 1)\)</span>；</li><li>任何基本权 <span class="math inline">\(\omega_s\)</span> 满足 <span class="math inline">\((\omega_s,\omega_s)\leq0\)</span>；</li><li>任何两个基本权 <span class="math inline">\(\omega_s,\omega_t\)</span> 满足 <span class="math inline">\((\omega_s,\omega_t)\leq0\)</span>并且它们生成的二维子空间 <span class="math inline">\(\mathrm{span}\{\omega_i,\omega_j\}\)</span>不是正定的。</li></ol><p>先证明 1。用反证法，如果 <span class="math inline">\(\Gamma\)</span>的 level 是 1 但不是双曲的，则根据 <a href="#lemma-uv" title="引理 3.2">引理 3.2</a> 我们可以取两个正交的非零向量 <span class="math inline">\(u,v\)</span> 满足 <span class="math inline">\((u,u)&lt;0,\, (v,v)=0\)</span>。</p><p>我们有如下两个断言：</p><div id="------" class="statement sta___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">断言</span>.</span><span class="statement-spah"></span><br></p><ol type="1"><li>任何满足 <span class="math inline">\((u,u)&lt;0\)</span> 的向量<span class="math inline">\(u=\sum_{s\in S}u_s\alpha_s\)</span> 其系数<span class="math inline">\(u_s\)</span> 都非零且同号。</li><li>任何满足 <span class="math inline">\((v,v)=0\)</span> 的向量 <span class="math inline">\(v=\sum_{s\in S}v_s\alpha_s\)</span> 其系数 <span class="math inline">\(v_s\)</span> 至多只有一个为 0，其余都同号。</li></ol></div><p>我把这两个断言的证明放在附录中，先承认它们是正确的，用它们来导出矛盾：</p><p>取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(v_s\ne 0\)</span>，则 <span class="math inline">\(u'=v_su-u_sv\)</span> 满足 <span class="math inline">\((u',u')=v_s^2(u,u)&lt;0\)</span>，且 <span class="math inline">\(u'\)</span> 的 <span class="math inline">\(\alpha_s\)</span> 项系数 <span class="math inline">\(u'_s=0\)</span>，这与断言 1 矛盾。所以 <span class="math inline">\(\Gamma\)</span> 是双曲的。</p><p>再来证明 2。</p><p>由于 <span class="math inline">\(\Gamma\)</span> 的 level 是1，对任何 <span class="math inline">\(s\in S\)</span>，子空间 <span class="math inline">\(\omega_s^\bot=\mathrm{span}\{\alpha_t\mid t\nes\}\)</span> 是有限或者仿射的，从而 <a href="/coxeter-groups-three-cases/#orth-complement-lorentzian"><span class="math inline">\(\omega_s\)</span> 不是 space-like 的</a>，即 <span class="math inline">\((\omega_s,\omega_s)\leq 0\)</span>。于是任何 <span class="math inline">\(\omega_s\,(s\in S)\)</span> 都不是实的。</p><p>再来证明 3。</p><p>观察恒等式 <span class="math inline">\((\ref{eq:idII})\)</span>：<span class="math display">\[\omega_s = (\omega_s,\omega_s)\alpha_s +\sum_{t\ne s} (\omega_s,\omega_t)\alpha_t.\]</span></p><p>结论 2 中已经证明了必然有 <span class="math inline">\((\omega_s,\omega_s)\leq0\)</span>。根据断言 1 和 2我们有：</p><ol type="1"><li>如果 <span class="math inline">\((\omega_s,\omega_s)&lt;0\)</span>，则后面所有的系数<span class="math inline">\((\omega_s,\omega_t)\)</span> 都小于 0。</li><li>如果 <span class="math inline">\((\omega_s,\omega_s)=0\)</span>，则后面所有的系数<span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span>都不为 0 且同号。我们来确定它们的符号：根据恒等式 <span class="math inline">\((\ref{eq:idI})\)</span> <span class="math display">\[1 = (\omega_s,\omega_s) + \sum_{t\ne s}(\omega_s,\omega_t)(\alpha_t,\alpha_s)=\sum_{t\ne s}(\omega_s,\omega_t)\underbrace{(\alpha_t,\alpha_s)}_{\leq0},\]</span>显然只能是 <span class="math inline">\((\omega_s,\omega_t)&lt;0\)</span>。</li></ol><p>总之我们说明了对任何 <span class="math inline">\(s\ne t\)</span> 都有<span class="math inline">\((\omega_s,\omega_t)&lt;0\)</span>。此外二维子空间<span class="math inline">\(U_{s,t}={\rmspan}\{\omega_s,\omega_t\}\)</span> 的正交补是 <span class="math inline">\(U_{s,t}^\bot=\mathrm{span}\{\alpha_{k}\mid k\nes,t\}\)</span>，根据 <a href="#level-l" title="定理 1.2">定理 1.2</a><span class="math inline">\(U_{s,t}^\bot\)</span> 是 space-like 的，从而<span class="math inline">\(U_{s,t}\)</span> 是 time-like 的，从而 <span class="math inline">\(\{\omega_s,\omega_t\}\)</span> 是分离的。</p><p>至此定理得证。<span class="math inline">\(\blacksquare\)</span></p><div id="level-1-tits" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论3.4</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(W\)</span> 的 level 为 1，则 Tits 锥的闭包 <span class="math inline">\(\overline{ \mathcal{C} }\)</span> 等于 <span class="math inline">\(\mathcal{Q}_+\)</span> 或者 <span class="math inline">\(\mathcal{Q}_-\)</span> 之一。</p></div><p><strong>证明</strong>：由于 level 1 的群是双曲的，根据 <a href="/coxeter-groups-three-cases#tits-closure">双曲情形 Tits锥的结论</a>，<span class="math inline">\(\mathcal{C}\)</span> 包含<span class="math inline">\(\mathcal{N}_+,\mathcal{N}_-\)</span>之一，不妨设为 <span class="math inline">\(\mathcal{C}\supset\mathcal{N}_+\)</span>，则 <span class="math inline">\(\overline{ \mathcal{C} }\supset\overline{\mathcal{N}_+}=\mathcal{Q}_+\)</span>。还要再证明反向的包含关系。为此只要证明 <span class="math inline">\(\overline{ \mathcal{C}}\subset\mathcal{Q}\)</span> 和 <span class="math inline">\(\overline{\mathcal{C} }\cap\mathcal{Q}_-=\{0\}\)</span>。</p><p>根据 <a href="#level-1" title="定理 3.3">定理 3.3</a>，所有的基本权<span class="math inline">\(\{\omega_s\}\)</span>都不是实的且两两分离。设 <span class="math inline">\(x=\sum_{s\inS}c_s\omega_s\,(c_s\geq0)\)</span> 是 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 中任意一点，则<span class="math display">\[(x,x)=\sum_{s,t\inS}c_sc_t\underbrace{(\omega_s,\omega_t)}_{\leq0}\leq0.\]</span> 即 <span class="math inline">\(\overline{\mathcal{D}}\subset\mathcal{Q}\)</span>。<span class="math inline">\(W\)</span> 作为正交变换群保持 <span class="math inline">\(\mathcal{Q}\)</span> 不变，所以 <span class="math inline">\(\mathcal{C}=\bigcup\limits_{w\inW}w\overline{\mathcal{D}}\subset\mathcal{Q}\)</span>，从而 <span class="math inline">\(\overline{ \mathcal{C}}\subset\mathcal{Q}\)</span>。</p><p>再来说明 <span class="math inline">\(\overline{ \mathcal{C}}\cap\mathcal{Q}_-=\{0\}\)</span>。我们知道 <a href="/coxeter-groups-three-cases/#dual-cone-non-trivial"><span class="math inline">\(\mathcal{C}^\ast\ne\{0\}\)</span></a>。我们断言<span class="math inline">\(\mathcal{C}^\ast\)</span> 必然包含某个time-like 的向量 <span class="math inline">\((z,z)&lt;0\)</span>。否则<a href="/coxeter-groups-tits-cone#dual-cone-nonspace"><span class="math inline">\(\mathcal{C}^\ast\)</span> 中的非零向量都是light-like 的</a>。但是 <span class="math inline">\(\mathcal{C}^\ast\)</span> 不能包含两个线性无关的light-like 的向量（否则由于 <a href="/coxeter-groups-three-cases/#dual-cone-belongs-branch">它们属于<span class="math inline">\(\mathcal{Q}\)</span> 的同一个分支</a> 从而<a href="/coxeter-groups-three-cases/#connected-component-dot">内积小于0</a>，从而它们的任何正线性组合是属于 <span class="math inline">\(\mathcal{C}^\ast\)</span> 的 time-like的向量），再结合 <span class="math inline">\(\mathcal{C}^\ast\)</span>是 <a href="/coxeter-groups-tits-cone/#tits-cone-dual-pointed">点锥</a>，所以<span class="math inline">\(\mathcal{C}^\ast=\mathbb{R}_{\geq0}\delta\)</span>，其中<span class="math inline">\(\delta\)</span> 是一个 light-like的向量。取对偶得到 <span class="math display">\[\overline{ \mathcal{C}}=\mathcal{C}^{\ast\ast}=\{v\in V\mid (v,\delta)\geq0\}.\]</span>这是一个半空间，显然包含 space-like 的向量，这与 <span class="math inline">\(\overline{ \mathcal{C}}\subset\mathcal{Q}\)</span> 矛盾。所以确实存在 <span class="math inline">\(z\in\mathcal{C}^\ast\)</span> 满足 <span class="math inline">\((z,z)&lt;0\)</span>。又因为 <span class="math inline">\(\mathcal{Q}_+\subset\overline{ \mathcal{C}}\)</span>，所以 <span class="math inline">\(z\in\mathcal{Q}_-\)</span>。</p><p>设 <span class="math inline">\(x\ne0\in\overline{ \mathcal{C}}\cap\mathcal{Q}_-\)</span>，则 <span class="math inline">\((x,z)&lt;0\)</span>，这与 <span class="math inline">\(z\in\mathcal{C}^\ast\)</span> 和 <span class="math inline">\(x\in\overline{ \mathcal{C} }\)</span> 矛盾。所以<span class="math inline">\(\overline{ \mathcal{C}}\cap\mathcal{Q}_-=\{0\}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="ideal-vertex" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.5</span> <span class="statement-info">(<span class="citation" data-cites="Maxwell89">(<a href="#ref-Maxwell89" role="doc-biblioref">Maxwell 1989</a>, proposition5.15)</span>)</span>.</span><span class="statement-spah"> </span>设<span class="math inline">\(s\in S\)</span> 使得如下条件成立：</p><ol type="1"><li><span class="math inline">\((\omega_s,\omega_s)=0\)</span>。</li><li>子图 <span class="math inline">\(\Gamma\setminus\{s\}\)</span>是不可约、仿射的。</li><li>对任何 <span class="math inline">\(t\ne s\)</span> 有 <span class="math inline">\((\omega_s,\omega_t)&lt;0\)</span>。</li></ol><p>记 <span class="math inline">\(I=S\setminus\{s\}\)</span>，则对任意点<span class="math inline">\(p\in\overline{\mathcal{D}}\)</span> 都有<span class="math inline">\(\omega_s\in\overline{\mathrm{cone}(\bigcup_{w\in W_I}wp) }\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这里没有限制 <span class="math inline">\(W\)</span> 的level。</p><p>此外 <span class="math inline">\(\bigcup_{w\in W_I}wp\)</span>是无限集，<span class="math inline">\(\mathrm{cone}(\bigcup_{w\inW_I})\)</span> 未必是闭集，因此闭包记号不可少。</p><p>当 <span class="math inline">\(W\)</span> 的 level 是 1 时，若 <span class="math inline">\(\omega_s\)</span>是一个位于双曲空间边界上的理想顶点，则命题的条件都满足。这时经过 <span class="math inline">\(\omega_s\)</span>的那些镜面生成的椭圆子群会把基本区域无限压缩到 <span class="math inline">\(\omega_s\)</span> 附近，如下图所示：</p><p><img src="/images/coxeter/ideal-vertex.jpg" class="fig" width="350"></p></div><p><strong>证明</strong>：由已知子空间 <span class="math inline">\(V_I=\mathrm{span}\{\alpha_t\mid t\ne s\}\)</span>是仿射的，并且 <span class="math inline">\(\mathrm{rad}(V_I)\)</span>是一维的。根据恒等式 <span class="math inline">\((\ref{eq:idII})\)</span> <span class="math display">\[\omega_s =\underbrace{(\omega_s,\omega_s)}_{=0}\alpha_s +  \sum_{t\ne s}(\omega_s,\omega_t)\alpha_t = \sum_{t\ne s}(\omega_s, \omega_t)\alpha_t\inV_I\]</span> 可得 <span class="math inline">\(\mathrm{rad}(V_I)=\mathbb{R}\omega_s\)</span>。于是<span class="math inline">\(W_I\)</span> 保持 <span class="math inline">\(\omega_s\)</span> 不动，即 <span class="math display">\[\mathbb{R}\omega_s\xrightarrow{\ W_I\, -\, 1\ }0.\]</span> <span class="math inline">\(W_I\)</span> 同样作用在商空间<span class="math inline">\(V_I/\mathbb{R}\omega_s\)</span>上，此作用给出了一个同态 <span class="math inline">\(W_I\to\mathrm{GL}(V_I/\mathbb{R}\omega_s)\)</span>。令<span class="math inline">\(K\)</span> 为此同态的核，则对任何 <span class="math inline">\(w\in K\)</span>， <span class="math display">\[w(v+ \mathbb{R}\omega_s) = v + \mathbb{R}\omega_s,\quad v\in V_I.\]</span>即 <span class="math inline">\(wv-v\in\mathbb{R}\omega_s\)</span>，从而<span class="math display">\[V_I\xrightarrow{\ K - 1\}\mathbb{R}\omega_s\xrightarrow{\ W_I\, -\, 1\ } 0.\]</span> 由于 <span class="math inline">\(K\leqslant W_I\)</span>，所以 <span class="math display">\[V_I\xrightarrow{\ K - 1\}\mathbb{R}\omega_s\xrightarrow{\ K-1\ }0.\]</span> 即 <span class="math inline">\((K-1)^2\)</span> 在整个 <span class="math inline">\(V_I\)</span> 上恒为 0。</p><p>更进一步，对任何 <span class="math inline">\(w\in K\)</span>，<span class="math inline">\(w\alpha_s\)</span> 形如 <span class="math inline">\(w\alpha_s=\alpha_s+\sum\limits_{t\nes}c_t\alpha_t\)</span>，所以 <span class="math inline">\((w-1)\alpha_s\in V_I\)</span>，从而 <span class="math inline">\(w-1\)</span> 将整个 <span class="math inline">\(V\)</span> 也映入 <span class="math inline">\(V_I\)</span>，于是 <span class="math display">\[V\xrightarrow{\ K-1\ } V_I\xrightarrow{\ K - 1\}\mathbb{R}\omega_s\xrightarrow{\ K-1\ }0.\]</span> 即 <span class="math inline">\((K-1)^2V\subset\mathbb{R}\omega_s\)</span>，<span class="math inline">\((K-1)^3V\equiv0\)</span>。</p><p>取 <span class="math inline">\(w\in K\)</span> 且 <span class="math inline">\(w\ne 1\)</span> <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，由于 <span class="math inline">\(w\)</span> 在 <span class="math inline">\(V_I\)</span> 上不是恒等变换，所以存在 <span class="math inline">\(t\in I\)</span> 使得 <span class="math inline">\(w\alpha_t\ne\alpha_t\)</span>。设 <span class="math display">\[\beta = w\alpha_t=\alpha_t+a\omega_s\,(a\ne0).\]</span> 则 <span class="math inline">\(s_\beta=wtw^{-1}\)</span>，从而对任何 <span class="math inline">\(p\in V\)</span>， <span class="math display">\[\begin{align*}s_\beta(p)&amp;=p - 2(p,\beta)\beta\\&amp;=p-2(p,\alpha_t+a\omega_s)(\alpha_t+a\omega_s)\\&amp;=p-2(p,\alpha_t)\alpha_t- 2a(p, \omega_s)\alpha_t - c\omega_s\\&amp;=t(p) - 2a(p, \omega_s)\alpha_t - c\omega_s.\end{align*}\]</span> 其中 <span class="math inline">\(c=2(p,\alpha_t+a\omega_s)a\)</span> 是实数。<span class="math inline">\(c\)</span> 具体是多少不用关心。</p><p>构造换位子 <span class="math inline">\(w_1=twtw^{-1}\inK\)</span>，则由 <span class="math inline">\((K-1)^2V\subset\mathbb{R}\omega_s\)</span> 有<span class="math inline">\((w_1-1)^2p=b\omega_s\,(b\in\mathbb{R})\)</span>。我们来计算<span class="math inline">\(b\)</span>。首先，</p><p><span class="math display">\[(w_1-1)p=ts_\beta(p)-p=-2a(p,\omega_s)\alpha_t -c\omega_s.\label{eq:wp1}\tag{1}\]</span> 其中我们利用了 <span class="math inline">\(t(\alpha_t)=-\alpha_t\)</span> 和 <span class="math inline">\(t(\omega_s)=\omega_s\)</span>。</p><p>到目前为止，我们的计算对任何 <span class="math inline">\(p\inV\)</span> 都是成立的。我们可以在 <span class="math inline">\((\ref{eq:wp1})\)</span> 式中取 <span class="math inline">\(p=\alpha_t\)</span>，得到 <span class="math display">\[(w_1-1)\alpha_t=2a\underbrace{(\alpha_t,\omega_s)}_{=0}\alpha_t-c\omega_s=-c\omega_s=-2(\alpha_t,\alpha_t+a\omega_s)a\omega_s=-2a\omega_s.\label{eq:wp2}\tag{2}\]</span></p><p>继续，将 <span class="math inline">\(w_1-1\)</span> 作用在 <span class="math inline">\((\ref{eq:wp1})\)</span> 两端，由于 <span class="math inline">\((w_1-1)\omega_s=0\)</span>，所以 <span class="math display">\[(w_1-1)^2p =2a(p,\omega_s)(w_1-1)\alpha_t.\label{eq:wp3}\tag{3}\]</span></p><p>将 <span class="math inline">\((\ref{eq:wp2})\)</span> 代入 <span class="math inline">\((\ref{eq:wp3})\)</span> 的右边，我们得到 <span class="math display">\[(w_1-1)^2p=-4a^2(p,\omega_s)\omega_s.\]</span> 即<span class="math inline">\(b=-4a^2(\omega_s,p)\)</span>。</p><p>我们来判断 <span class="math inline">\(b\)</span> 的符号。这里要用到<span class="math inline">\(p\in\overline{\mathcal{D}}=\mathrm{cone}(\Delta^\ast)\)</span>的条件。如果 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(\omega_s\)</span> 的正倍数，显然 <span class="math inline">\(\omega_s\in\overline{ \mathrm{cone}(\bigcup_{w\inW_I}wp) }\)</span>，命题自然成立。所以我们可以假设 <span class="math inline">\(p\)</span> 与 <span class="math inline">\(\omega_s\)</span> 不共线。</p><p>设 <span class="math inline">\(p=\sum_{t\in S}c_t\omega_t\,(c_t\geq0)\)</span>，则至少有一个 <span class="math inline">\(t\ne s\)</span> 满足 <span class="math inline">\(c_t&gt;0\)</span>。于是 <span class="math display">\[(\omega_s,p)=\sum_{t\ne s}\underbrace{c_t}_{\geq0\text{ 且至少有一个 } &gt;0}\ \cdot\\underbrace{(\omega_s,\omega_t)}_{\text{已知 }&lt;0}&lt;0.\]</span> 从而<span class="math inline">\(b&gt;0\)</span>。</p><p>最后利用 <span class="math inline">\((w_1-1)^3=0\)</span> 和 <span class="math inline">\((w_1-1)^2p=b\omega_s\)</span> 我们得到对任何 <span class="math inline">\(N\geq 1\)</span> 有 <span class="math display">\[w_1^N(p)=(1 + w_1-1)^N(p)= p +\binom{N}{1}(w_1-1)(p) + \binom{N}{2}b\omega_s,\]</span> 可见 <span class="math inline">\(\lim\limits_{N\to\infty}\dfrac{w_1^Np}{\binom{N}{2}b}= \omega_s\)</span>，即得所证。<span class="math inline">\(\blacksquare\)</span></p><h1 id="处理-level-2-的基本技巧">处理 level 2 的基本技巧</h1><p>本节我们在上一小节的结论中再进一步，证明 level 2的群也是双曲的。由于接下来的证明篇幅更长，包含更多的细节，读者难免在阅读时感到吃力。我这里借鉴编程中的模块化思想，先解释接下来的证明中会用到的主要思想。</p><p>处理 level 2 的情形的基本思路是转化为 level 1 的情形。具体讲，设<span class="math inline">\(\Gamma\)</span> 是 level 为 2 的 Coxeter图，取一个实的基本权 <span class="math inline">\((\omega_s,\omega_s)&gt;0\)</span>，则子图 <span class="math inline">\(\Gamma\setminus\{s\}\)</span> 的 level 就是 1。记<span class="math inline">\(I = S\setminus\{s\}\)</span>，<span class="math inline">\(W_I\)</span> 是标准椭圆子群， <span class="math display">\[V_I=\omega_s^\bot=\mathrm{span}\{\alpha_t\midt\ne s\}.\]</span> <span class="math inline">\(W_I\)</span> 在 <span class="math inline">\(V_I\)</span> 上作用的基本区域的闭包就是 <span class="math display">\[\overline{\mathcal{D}}_I= \{v\in V_I\mid (v,\alpha_t)&gt;0,\, \forall t\in I\}=\mathrm{cone}(\{\omega_t\mid t\inI\}).\]</span></p><p>根据 <a href="#level-1-tits" title="推论 3.4">推论 3.4</a>，<span class="math inline">\(\overline{\mathcal{D}}_I\)</span> 包含在 <span class="math inline">\(\mathcal{Q}_I=\{v\in V_I\mid (v,v)\leq0\}\)</span>的上下两个分支之一中，所以任何 <span class="math inline">\(x,y\in\overline{\mathcal{D}}_I\)</span>之间的内积小于等于 0： <span class="math display">\[(x,y)\leq0, \quad\forall x,y\in \overline{\mathcal{D}}_I.\]</span> 特别地，对任何 <span class="math inline">\(x\in\overline{\mathcal{D}}_I\)</span> 有 <span class="math display">\[(x,x)\leq0 \text{ and } (x,\omega_t)\leq0\text{for all }t\in I.\]</span> 于是对 <span class="math inline">\(v\inV\)</span>，如果它在 <span class="math inline">\(V_I\)</span> 上的投影<span class="math inline">\(v_I\)</span> 满足 <span class="math inline">\(v_I\in\overline{\mathcal{D}}_I\)</span>，那么我们就可以利用上面的关系得出关于<span class="math inline">\(v\)</span> 的信息来。</p><div id="observeA" class="statement sta____a definition unnumbered"><p><span class="statement-heading"><span class="statement-label">观察A</span>：</span><span class="statement-spah"> </span>取 <span class="math inline">\(v=\alpha_s\)</span>，<span class="math inline">\(\alpha_s'=\alpha_s-\omega_s/(\omega_s,\omega_s)\)</span>是 <span class="math inline">\(\alpha_s\)</span> 在 <span class="math inline">\(\omega_s^\bot=V_I\)</span> 上的投影，则对任何<span class="math inline">\(t\in I\)</span> 有 <span class="math display">\[(\alpha_s',\alpha_t)=(\alpha_s,\alpha_t)\leq0.\]</span> 这说明 <span class="math inline">\(-\alpha_s'\in\overline{\mathcal{D}}_I\)</span>，于是我们有<span class="math display">\[\begin{aligned}&amp;(\alpha_s',\alpha_s')=1-\frac{1}{(\omega_s,\omega_s)}\leq0,\\&amp;(-\alpha_s',\omega_t)=\frac{(\omega_s,\omega_t)}{(\omega_s,\omega_s)}\leq0\text{ for all }t\in I.\end{aligned}\]</span> 从而有 <span class="math inline">\(0&lt;(\omega_s,\omega_s)\leq1\)</span>，以及 <span class="math inline">\((\omega_s,\omega_t)\leq0\)</span> 对任何 <span class="math inline">\(t\in I\)</span> 成立。</p></div><p>真不错！我们轻松得到了一个关于 level 2 情形实的基本权 <span class="math inline">\(\omega_s\)</span> 的重要结论！</p><div id="observeB" class="statement sta____b definition unnumbered"><p><span class="statement-heading"><span class="statement-label">观察B</span>：</span><span class="statement-spah"> </span>这次我们取 <span class="math inline">\(v\in\mathcal{C}\)</span> 是 Tits 锥中的一点，则<span class="math inline">\(v\)</span> 形如 <span class="math inline">\(v=wx\,(w\inW,x\in\overline{\mathcal{D}})\)</span>。并且 <span class="math display">\[v_I = v -\frac{(v,\omega_s)}{(\omega_s,\omega_s)}\omega_s.\]</span> 由于 <span class="math inline">\((v-v_I)\bot V_I\)</span>，所以对任何 <span class="math inline">\(\alpha_k\,(k\ne i)\)</span> 有 <span class="math display">\[(v_I,\alpha_k)=(v,\alpha_k)=(wx,\alpha_k)=(x,w^{-1}\alpha_k).\]</span> 为了保证让 <span class="math inline">\(v_I\)</span> 落在 <span class="math inline">\(\overline{\mathcal{D}}_I\)</span>中，我们需要让这些 <span class="math inline">\((x,w^{-1}\alpha_k)\geq0\)</span>。但是 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，所以只要让每个<span class="math inline">\(w^{-1}\alpha_k\,(k\in I)\)</span>都是负根，也就是让 <span class="math inline">\(l(s_kw)&lt;l(w)\)</span>即可。</p><p>总结起来就是，如果对任何 <span class="math inline">\(k\in I\)</span>有 <span class="math inline">\(l(s_kw)&lt;l(w)\)</span>，那么就有 <span class="math inline">\(v_I\in\overline{\mathcal{D}}_I\)</span> 成立。</p></div><p>这个例子看起来附加了比较强的条件，但是它确实会在后面用到。</p><h1 id="level-2-也是双曲的">Level 2 也是双曲的</h1><div id="level-2" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.1</span>.</span><span class="statement-spah"> </span>level 等于 2的群都是双曲的，所有的基本权 <span class="math inline">\(\{\omega_s\mids\in S\}\)</span> 两两分离。<span class="math inline">\(\omega_s\)</span> 是实的当且仅当 <span class="math inline">\(T\setminus\{s\}\)</span> 的 level 等于1，且对这样的 <span class="math inline">\(\omega_s\)</span> 有 <span class="math inline">\(0&lt;(\omega_s,\omega_s)\leq 1\)</span>。</p></div><p><strong>证明</strong>：我们先来证明 <span class="math inline">\(\Gamma\)</span> 是双曲的。</p><p>如果 <span class="math inline">\(\Gamma\)</span> 是不连通的，则 <span class="math inline">\(\Gamma\)</span> 必须是一个 level 为 1的子图和一个孤立顶点的并，由于 <a href="#level-1" title="定理 3.3">定理3.3</a> 已经证明了 level 1的群是双曲的，再加上一个孤立顶点仍然是双曲的，所以 <span class="math inline">\(\Gamma\)</span> 是双曲的。于是我们不妨假设 <span class="math inline">\(\Gamma\)</span> 是连通的。</p><p>再针对 <span class="math inline">\(\Gamma\)</span> 的顶点个数是否大于3 分别处理。在 <span class="math inline">\(\Gamma\)</span> 只包含 3个顶点的情形，<span class="math inline">\(\Gamma\)</span> 的 level 是 2说明其必然有一条边的 Vinberg 标号小于 -1。不妨设 <span class="math inline">\((\cdot,\cdot)\)</span> 的 Gram 矩阵形如 <span class="math display">\[\begin{pmatrix}1&amp;a&amp;b\\a&amp;1&amp;c\\b&amp;c&amp;1\end{pmatrix}.\]</span>其中 <span class="math inline">\(a,\,b,\,c\leq0\)</span> 且 <span class="math inline">\(a &lt; -1\)</span>。这个矩阵的行列式是 <span class="math display">\[1 - a^2 + 2abc - b^2-c^2 = 1-a^2 +2bc(a+1)-(b+c)^2&lt;0.\]</span> 由于矩阵的迹等于 3，所以其符号必然是<span class="math inline">\((2, 1)\)</span>，从而是双曲的。</p><p>再处理 <span class="math inline">\(\Gamma\)</span> 包含至少 4个顶点的情形。</p><p>仍然根据 <a href="#lemma-uv" title="引理 3.2">引理 3.2</a>，如果<span class="math inline">\(\Gamma\)</span>不是双曲的，则我们可以取两个非零且正交的向量 <span class="math inline">\(u,v\)</span> 满足 <span class="math inline">\((u,u)&lt;0,\,(v, v)=0\)</span>。</p><p>我们也有如下两个断言：</p><ol type="1"><li>任何满足 <span class="math inline">\((u,u)&lt;0\)</span> 的向量<span class="math inline">\(u=\sum_{s\in S}u_s\alpha_s\)</span>除去至多一个系数 <span class="math inline">\(u_j\)</span> 之外，其它的<span class="math inline">\(u_s\)</span> 都非零且同号。</li><li>任何满足 <span class="math inline">\((v,v)=0\)</span> 的向量 <span class="math inline">\(v=\sum_{s\in S}v_s\alpha_s\)</span> 除了满足断言 1的情形之外，还有一种情形是 <span class="math inline">\(\{v_s\}\)</span>中有两个是 0，其余的非零且同号。</li></ol><p>我仍然把断言的证明放在附录中，先承认它们是正确的并完成证明。</p><p>由于 <span class="math inline">\(u\)</span> 的系数 <span class="math inline">\(\{u_s\}\)</span> 中至多只有一个是 0，<span class="math inline">\(v\)</span> 的系数 <span class="math inline">\(\{v_s\}\)</span> 中至多只有两个是 0，而 <span class="math inline">\(|\Gamma|\geq4\)</span>，所以存在下标 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(u_i,\,v_i\)</span> 均不为 0。于是 <span class="math inline">\(u'=v_iu-u_iv\)</span> 仍然满足 <span class="math inline">\(u'\)</span> 与 <span class="math inline">\(v\)</span> 正交和 <span class="math inline">\((u',u')&lt;0\)</span>，但是它的下标 <span class="math inline">\(i\)</span> 的系数 <span class="math inline">\(u'_i=0\)</span>，所以我们不妨一开始就取 <span class="math inline">\(u\)</span> 为 <span class="math inline">\(u'\)</span>，于是 <span class="math inline">\(u\)</span> 有一个系数 <span class="math inline">\(u_i=0\)</span>，其它系数都非 0且同号，不妨假设这些非零系数都大于 0。</p><p>现在我们已经有了 <span class="math inline">\(v_i\ne0\)</span>，由于<span class="math inline">\(\{v_s\}\)</span> 中至多只有两个为 0，而<span class="math inline">\(|\Gamma|\geq4\)</span>，所以 <span class="math inline">\(\{v_j,\,j\ne i\}\)</span> 中至少还有一个非零。</p><ul><li><p>如果 <span class="math inline">\(\{v_j,\,j\ne i\}\)</span>中仅有一个非零，则这时必有 <span class="math inline">\(|\Gamma|=4\)</span> 且 <span class="math inline">\(v\)</span> 形如 <span class="math inline">\(v=v_i\alpha_i + v_j\alpha_j\)</span>。根据 <a href="#level-l" title="定理 1.2">定理 1.2</a> <span class="math inline">\({\rm span}\{\alpha_i,\alpha_j\}\)</span>是有限/或者仿射的，但是由于此平面包含 <span class="math inline">\((v,v)=0\)</span>，所以是仿射的，从而 <span class="math inline">\((\alpha_i,\alpha_j)=-1\)</span>。我们可以不妨把<span class="math inline">\(v\)</span> 取为 <span class="math inline">\(v=\alpha_i+\alpha_j\)</span>。</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(i\)</span></th><th style="text-align: center;"><span class="math inline">\(j\)</span></th><th style="text-align: center;"><span class="math inline">\(k\)</span></th><th style="text-align: center;"><span class="math inline">\(m\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(u\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(\ne0\)</span></td><td style="text-align: center;"><span class="math inline">\(\ne0\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><p><span class="math inline">\(u_i=0\)</span> 说明 <span class="math inline">\(u\)</span> 形如 <span class="math inline">\(u=u_j\alpha_j+u_k\alpha_k+u_m\alpha_m\)</span>。由 <span class="math inline">\((u,v)=0\)</span> 有 <span class="math display">\[(u, v)=(u_j\alpha_j+u_k\alpha_k+u_m\alpha_m,v)=(u_k\alpha_k+u_m\alpha_m, \alpha_i+\alpha_j)=0,\]</span> 由于 <span class="math inline">\(\{\alpha_k,\alpha_m\}\)</span> 和 <span class="math inline">\(\{\alpha_i,\alpha_j\}\)</span>之间的内积都小于等于 0，而 <span class="math inline">\(u_k,u_m\)</span>大于 0，这说明 <span class="math display">\[(\alpha_k,\alpha_i) =(\alpha_k,\alpha_j) =(\alpha_m, \alpha_i)=(\alpha_m,\alpha_j)=0.\]</span> 即顶点 <span class="math inline">\(\{i,j\}\)</span> 与 <span class="math inline">\(\{k,m\}=\Gamma\setminus\{i,j\}\)</span>是不连通的，与 <span class="math inline">\(\Gamma\)</span>连通矛盾。</p></li><li><p>如果 <span class="math inline">\(\{v_j,\,j\ne i\}\)</span>至少有两个非零，则可以取下标 <span class="math inline">\(j,k\)</span>使得 <span class="math inline">\(v_j/u_j\ne0,\,v_k/u_k\ne0\)</span>。</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(i\)</span></th><th style="text-align: center;"><span class="math inline">\(j\)</span></th><th style="text-align: center;"><span class="math inline">\(k\)</span></th><th style="text-align: center;"><span class="math inline">\(\cdots\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(u\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(&lt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(\ne0\)</span></td><td style="text-align: center;"><span class="math inline">\(\ne0\)</span></td><td style="text-align: center;"><span class="math inline">\(\cdots\)</span></td></tr></tbody></table><p>由于 <span class="math inline">\(v_i\ne0\)</span>，通过选择 <span class="math inline">\(v\)</span> 或者 <span class="math inline">\(-v\)</span> 可以不妨设 <span class="math inline">\(v_i&lt;0\)</span>，并不妨设 <span class="math inline">\(v_j/u_j\leq v_k/u_k\)</span>。记 <span class="math inline">\(a=v_j/u_j\)</span>，则 <span class="math inline">\(u'=au-v\)</span> 满足 <span class="math inline">\((u',u')&lt;0\)</span>，但是 <span class="math inline">\(u'_i=-v_i&gt;0\)</span>，<span class="math inline">\(u'_j=0\)</span>，<span class="math inline">\(u'_k\leq 0\)</span>，这与上面断言中 <span class="math inline">\(u'\)</span>的系数除去至多一个例外，剩下的均非零且同号矛盾。</p></li></ul><p>至此我们证明了当 <span class="math inline">\(\Gamma\)</span> 的 level等于 2 时是双曲的。</p><p>我们接下来证明所有的基本权 <span class="math inline">\(\{\omega_s\}\)</span>是两两分离的。我们先来说明不论 <span class="math inline">\((\omega_s,\omega_s)\)</span>的符号如何，它与其它的基本权 <span class="math inline">\(\omega_t\,(t\nes)\)</span> 的内积满足 <span class="math inline">\((\omega_s,\omega_t)\leq0\)</span>。</p><p>分情况讨论：</p><ul><li><p>如果 <span class="math inline">\((\omega_s,\omega_s)&gt;0\)</span>，由 <a href="#observeA" title="观察 A">观察 A</a> 的讨论即得。</p></li><li><p>如果 <span class="math inline">\((\omega_s,\omega_s)\leq0\)</span>，则根据 <span class="math inline">\((\ref{eq:idII})\)</span>，<span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span>中必然至少有一个严格小于 0，从而根据断言，在 <span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span>中至多有一个为正。但我们将证明这不可能。否则不妨设 <span class="math inline">\(k\ne s\)</span> 使得 <span class="math inline">\((\omega_s,\omega_k)&gt;0\)</span>。在 <span class="math inline">\((\ref{eq:idII})\)</span> 两边用 <span class="math inline">\(\alpha_k\)</span> 内积得到 <span class="math display">\[0=(\omega_s,\omega_s)(\alpha_s,\alpha_k)+\sum_{t\ne s,k} (\omega_s,\omega_t)(\alpha_t,\alpha_k) +(\omega_s,\omega_k).\]</span> 上面的和项前两个都非负，最后一个大于0，矛盾。所以所有的 <span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span>都非正。</p></li></ul><p>又因为对任何 <span class="math inline">\(s,t\)</span>，<span class="math inline">\(\Gamma\setminus\{s,t\}\)</span>是有限或者仿射的，所以其正交补，即 <span class="math inline">\(\{\omega_s,\omega_t\}\)</span>张成的二维子空间不是正定的，从而 <span class="math inline">\(\{\omega_s\}\)</span> 之间是两两分离的。</p><h1 id="level-1-2-等价于双曲和分离">level = 1, 2 等价于双曲和分离</h1><div id="level-12" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理6.1</span>.</span><span class="statement-spah"></span>下面两点是等价的：</p><ol type="1"><li><span class="math inline">\(\Gamma\)</span> 的 level 等于 1 或2；</li><li><span class="math inline">\(\Gamma\)</span>是双曲的，且任何两个权都互相分离。</li></ol></div><p><strong>证明</strong>：</p><p><span class="math inline">\(1\Rightarrow 2\)</span>：只要再证明对任何<span class="math inline">\(w\in W\)</span>，以及两个基本权 <span class="math inline">\(\omega_i,\,\omega_j\)</span>，如果有 <span class="math inline">\(\omega_i\ne w(\omega_j)\)</span>，则 <span class="math inline">\((\omega_i,w(\omega_j))\leq0\)</span>，并且二维子空间<span class="math inline">\(\{\omega_i,w(\omega_j)\}\)</span>不是正定的。</p><p>对 <span class="math inline">\(l(w)\)</span> 归纳：<span class="math inline">\(l(w)=0\)</span> 的情形在 <a href="#level-1" title="定理 3.3">定理 3.3</a> 和 <a href="#level-2" title="定理 5.1">定理 5.1</a> 中已经证明。下面假设 <span class="math inline">\(l(w)&gt;0\)</span>，且结论对所有长度 <span class="math inline">\(&lt;l(w)\)</span> 的元素成立。</p><ol type="1"><li><p>如果存在 <span class="math inline">\(k\ne i\)</span> 使得 <span class="math inline">\(l(s_kw)&lt;l(w)\)</span>，则由于反射 <span class="math inline">\(s_k\)</span> 是正交变换，并且保持 <span class="math inline">\(\omega_i\)</span> 不动，有 <span class="math display">\[(\omega_i,s_kw(\omega_j))\xrightarrow{\ s_k\ }(\omega_i,w(\omega_j)).\]</span>由归纳假设左边是分离的，从而右边也是分离的。</p></li><li><p>如果对任何 <span class="math inline">\(k\ne i\)</span> 都有 <span class="math inline">\(l(s_kw)&gt;l(w)\)</span>，则 <span class="math inline">\(w\)</span> 的任一既约表示必然以 <span class="math inline">\(s_i\)</span> 开头，即 <span class="math inline">\(w\)</span> 形如 <span class="math inline">\(w=s_iw'\)</span> 且 <span class="math inline">\(l(w)&gt;l(w')\)</span>。从而 <span class="math display">\[(\omega_i,w(\omega_j))\xrightarrow{\ s_i\}(\omega_i-2\alpha_i, w'(\omega_j)) =(\omega_i,w'(\omega_j))-2(\alpha_i,w'(\omega_j)).\]</span></p><ul><li>如果 <span class="math inline">\(\omega_i\new'(\omega_j)\)</span>，则由归纳假设上面第一项 <span class="math inline">\((\omega_i,w'(\omega_j))\leq0\)</span>。第二项由于 <span class="math display">\[l(s_iw')&gt;l(w')\Rightarroww'^{-1}\alpha_i\in\Phi^+\Rightarrow (w'^{-1}\alpha_i,\omega_j)\geq0 \Rightarrow (\alpha_i, w'(\omega_j))\geq0.\]</span>所以 <span class="math inline">\((\omega_i,w(\omega_j))\leq0\)</span>成立。</li><li>如果 <span class="math inline">\(\omega_i=w'(\omega_j)\)</span>，则 <span class="math inline">\(w(\omega_j)=s_iw'(\omega_j)=s_i(\omega_i)\)</span>，于是<span class="math display">\[(\omega_i, w(\omega_j))=(\omega_i,s_i(\omega_i))\xrightarrow{\ s_i\}(\omega_i-2\alpha_i,\omega_i)=(\omega_i, \omega_i)-2 &lt;0.\]</span>其中最后一个不等号是利用了 <a href="#level-1" title="定理 3.3">定理3.3</a> 和 <a href="#level-2" title="定理 5.1">定理 5.1</a> 的结论：若<span class="math inline">\(\Gamma\)</span> 的 level 是 1 则 <span class="math inline">\((\omega_i, \omega_i)\leq0\)</span>，若 <span class="math inline">\(\Gamma\)</span> 的 level 是 2 则 <span class="math inline">\((\omega_i,\omega_i)\leq 1\)</span>。</li></ul><p>我们已经证明了 <span class="math inline">\((\omega_i,w(\omega_j))\)</span> 总是 <span class="math inline">\(\leq0\)</span> 的。还需要说明 <span class="math inline">\(\mathrm{span}\{\omega_i,w(\omega_j)\}\)</span>不是正定的。记 <span class="math inline">\(U=\mathrm{span}\{\omega_i,w(\omega_j)\}\)</span>。用反证法，如果<span class="math inline">\(U\)</span> 是正定的，则 <span class="math inline">\((\omega_i,\omega_i)&gt;0\)</span> 是实的。记 <span class="math display">\[v_I = w(\omega_j) -\frac{(\omega_i,w(\omega_j))}{(\omega_i,\omega_i)} \omega_i\]</span> 是<span class="math inline">\(w(\omega_j)\)</span> 在 <span class="math inline">\(\omega_i^\bot\)</span> 上的投影，则 <span class="math inline">\(v_I\in U\)</span> 是 space-like 的向量。但是根据<a href="#observeB" title="观察 B">观察 B</a> 中的讨论，<span class="math inline">\(v_I\in\overline{\mathcal{D}}_I\)</span>，从而<span class="math inline">\((v_I, v_I)\leq0\)</span>，矛盾。</p></li></ol><p><span class="math inline">\(2\Rightarrow 1\)</span>：由于内积 <span class="math inline">\((\cdot,\cdot)\)</span> 是双曲的，而子空间 <span class="math inline">\(\mathrm{span}\{\omega_i,\omega_j\}\)</span>不是正定的，所以其正交补是正定或者半正定的。于是 <span class="math inline">\(\Gamma\setminus\{i,j\}\)</span>是有限或者仿射的，从而 <span class="math inline">\(\Gamma\)</span> 的level 等于 1 或 2。</p><h1 id="附录">附录</h1><h2 id="level-1-情形断言的证明">level 1 情形断言的证明</h2><p>首先是断言 1 的证明。记</p><p><span class="math display">\[I_+=\{s\in S\mid u_s&gt;0\},\quadI_-=\{s\in S\mid u_s&lt;0\},\quad I_0=\{s\in S\mid u_s=0\}.\]</span>并记 <span class="math inline">\(u_+=\sum_{s\inI_+}u_s\alpha_s\)</span>，<span class="math inline">\(u_-=\sum_{t\inI_-}u_t\alpha_t\)</span>，则 <span class="math inline">\(u=u_++u_-\)</span> 且 <span class="math display">\[(u,u)=(u_+,u_+) + (u_-,u_-) +2(u_+,u_-)&lt;0.\]</span> 但是注意到 <span class="math display">\[(u_+,u_-)=\sum_{s\in I_+}\sum_{t\inI_-}\underbrace{u_s}_{&gt;0}\underbrace{u_t}_{&lt;0}\underbrace{(\alpha_s,\alpha_t)}_{\leq0}\geq0.\]</span> 所以 <span class="math inline">\((u_+, u_+) &lt; 0\)</span>和 <span class="math inline">\((u_-, u_-)&lt;0\)</span>中至少有一个成立，不妨设 <span class="math inline">\((u_+,u_+)&lt;0\)</span>。如果 <span class="math inline">\(I_-\cupI_0\)</span> 不是空集，那么 <span class="math inline">\(I_+\)</span>作为从 <span class="math inline">\(\Gamma\)</span> 中删去 <span class="math inline">\(I_-\cup I_0\)</span> 后得到的真子图包含 time-like的向量 <span class="math inline">\(u_+\)</span>，这与 <span class="math inline">\(\Gamma\)</span> 的 level 等于 1 矛盾。所以 <span class="math inline">\(I=I_+\)</span>，即所有系数 <span class="math inline">\(u_s\)</span> 都大于 0。相应地如果是 <span class="math inline">\((u_-,u_-)&lt;0\)</span> 的话则所有 <span class="math inline">\(u_s\)</span> 都小于 0。</p><p>对断言 2 我们仍然采用类似的记号，记 <span class="math display">\[I_+=\{s\in S\mid v_s&gt;0\},\quad I_-=\{s\inS\mid v_s&lt;0\},\quad I_0=\{s\in S\mid v_s=0\}.\]</span> 并记 <span class="math inline">\(v_+=\sum_{s\in I_+}v_s\alpha_s\)</span>，<span class="math inline">\(v_-=\sum_{t\in I_-}v_t\alpha_t\)</span>，则同样有<span class="math inline">\((v_+,v_-)\geq0\)</span>。</p><p>我们想证明 <span class="math inline">\(|I_0|\leq1\)</span>，并且<span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 中必有一个是空集。</p><p>如果 <span class="math inline">\(|I_0|\geq2\)</span>，那么 <span class="math inline">\((v, v)=0\)</span> 说明删除 <span class="math inline">\(I_0\)</span> 以后得到的子图不是有限的，这与 <span class="math inline">\(\Gamma\)</span> 的 level 是 1 和 <a href="#level-l" title="定理 1.2">定理 1.2</a> 矛盾。所以 <span class="math inline">\(|I_0|\leq 1\)</span>。</p><p>如果 <span class="math inline">\(I_+,\,I_-\)</span>都不是空集的话，则 <span class="math inline">\(v_+,v_-\)</span>都非零，并且必然有 <span class="math inline">\((v_+, v_+)\geq0\)</span>且 <span class="math inline">\((v_-, v_-)\geq0\)</span>，否则删掉 <span class="math inline">\(I_+\)</span> 或者 <span class="math inline">\(I_-\)</span> 以后剩下的子图不是有限或者仿射的，与<span class="math inline">\(\Gamma\)</span> 的 level 是 1 矛盾。然而<span class="math display">\[0=(v, v) = (v_+,v_+) + (v_-,v_-) +2(v_+,v_-).\]</span> 三个非负数的和等于 0，只能是 <span class="math inline">\((v_+,v_+) = (v_-,v_-) =(v_+,v_-)=0\)</span>。现在分情况讨论：</p><ol type="1"><li>如果 <span class="math inline">\(|I_0|=1\)</span>，那么删掉 <span class="math inline">\(I_-\cup I_0\)</span> 会至少删掉两个顶点，但 <span class="math inline">\((v_+,v_+)=0\)</span> 说明剩下的子图不是有限的，与<span class="math inline">\(\Gamma\)</span> 的 level 是 1 和 <a href="#level-l" title="定理 1.2">定理 1.2</a> 矛盾。</li><li>如果 <span class="math inline">\(I_0=\emptyset\)</span>，则 <span class="math inline">\(S=I_+\cup I_-\)</span>。然而 <span class="math inline">\((v_+,v_-)=\sum_{s\in I_+,\,t\inI_-}v_sv_t(\alpha_s,\alpha_t)=0\)</span> 说明对任何 <span class="math inline">\(s\in I_+,\,t\in I_-\)</span> 有 <span class="math inline">\((\alpha_s,\alpha_t)=0\)</span>，从而 <span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 将 <span class="math inline">\(\Gamma\)</span> 分成互不连通的两个集合，这与 <span class="math inline">\(\Gamma\)</span> 连通矛盾。</li></ol><p>总之 <span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 必有一个是空集，断言 2 得证。</p><h2 id="level-2-情形断言的证明">level 2 情形断言的证明</h2><p>首先是断言 1 的证明。和 level 1 那里的证明一样，我们仍然记 <span class="math display">\[I_+=\{s\in S\mid u_s&gt;0\},\quad I_-=\{s\inS\mid u_s&lt;0\},\quad I_0=\{s\in S\mid u_s=0\}.\]</span> 并记 <span class="math inline">\(u_+=\sum_{s\in I_+}u_s\alpha_s\)</span>，<span class="math inline">\(u_-=\sum_{t\in I_-}u_t\alpha_t\)</span>。则 <span class="math inline">\((u,u)&lt;0\)</span> 和 <span class="math inline">\((u_+,u_-)\geq0\)</span> 说明 <span class="math inline">\((u_+, u_+) &lt; 0\)</span> 和 <span class="math inline">\((u_-, u_-)&lt;0\)</span> 中至少有一个成立。</p><p>如果 <span class="math inline">\(|I_0|\geq2\)</span>，则 <span class="math inline">\((u,u)&lt;0\)</span> 与 <span class="math inline">\(\Gamma\)</span> 的 level 是 2 矛盾。所以 <span class="math inline">\(|I_0|\leq 1\)</span>。</p><ol type="1"><li>如果 <span class="math inline">\(I_+,I_-\)</span> 都不是空集，则<span class="math inline">\(u_+,\,u_-\)</span> 均不为 0。由于 <span class="math inline">\((u_+, u_+) &lt; 0\)</span> 和 <span class="math inline">\((u_-, u_-)&lt;0\)</span> 中至少有一个成立，不妨设<span class="math inline">\((u_+,u_+)&lt;0\)</span>，结合 <span class="math inline">\(\Gamma\)</span> 的 level 是 2，这要求 <span class="math inline">\(|I_-\cup I_0|\leq 1\)</span>，从而只能是 <span class="math inline">\(|I_-|=1,\, I_0=\emptyset\)</span>。即系数全部非 0且恰好有一个异号。</li><li>如果 <span class="math inline">\(I_+,I_-\)</span>中有一个是空集，不妨设 <span class="math inline">\(I_-=\emptyset\)</span>，我们仍然有 <span class="math inline">\(|I_-\cupI_0|=|I_0|\leq1\)</span>。即系数至多有一个为 0 且其它的均同号。</li></ol><p>总之我们证明了除去至多一个系数之外，其它的系数均非 0 且同号。断言 1得证。</p><p>对断言 2，类似地我们记 <span class="math display">\[I_+=\{s\in S\midv_s&gt;0\},\quad I_-=\{s\in S\mid v_s&lt;0\},\quad I_0=\{s\in S\midv_s=0\}.\]</span> 并记 <span class="math inline">\(v_+=\sum_{s\inI_+}v_s\alpha_s\)</span>，<span class="math inline">\(v_-=\sum_{t\inI_-}v_t\alpha_t\)</span>。</p><p>首先 <span class="math inline">\(|I_0|\leq2\)</span> 是显然的，否则<span class="math inline">\((v,v)=0\)</span> 与 <span class="math inline">\(\Gamma\)</span> 的 level 是 2 和 <a href="#level-l" title="定理 1.2">定理 1.2</a> 矛盾。</p><ol type="1"><li>如果 <span class="math inline">\(I_0\ne\emptyset\)</span>，则 <span class="math inline">\(I_+,I_-\)</span> 中必有一个为空。否则 <span class="math inline">\(|I_+\cup I_0|\geq2,\,|I_-\cupI_0|\geq2\)</span>。level 2 要求 <span class="math inline">\((v_+,v_+)\geq0,\,(v_-,v_-)\geq0\)</span>，从而<span class="math inline">\((v,v)=0\)</span> 和 <span class="math inline">\((v_+,v_-)\geq0\)</span> 导致 <span class="math inline">\((v_+,v_+)=(v_-, v_-)=(v_+,v_-)=0\)</span>。由于<span class="math inline">\(\Gamma\)</span> 至少包含 4 个顶点，所以<span class="math inline">\(I_+,\,I_-\)</span>中必有一个包含两个或者更多的顶点。不妨设 <span class="math inline">\(|I_+|\geq2\)</span>，则删除 <span class="math inline">\(I_+\cup I_0\)</span> 会至少删掉 3个顶点，但得到的子图不是正定的，与 <span class="math inline">\(\Gamma\)</span> 的 level 等于 2 矛盾。所以系数<span class="math inline">\(\{v_s\}\)</span> 中如果有 0的话，则至多只有两个 0，且剩下的都同号。</li><li>如果 <span class="math inline">\(I_0=\emptyset\)</span>是空集，则要么 <span class="math inline">\(I_+,I_-\)</span>中有一个也是空集，从而所有的系数都非 0 且同号；要么 <span class="math inline">\(v_+,\,v_-\)</span> 均不为 0。这时 <span class="math inline">\(\Gamma\)</span> 连通说明 <span class="math inline">\((v_+,v_-)&gt;0\)</span>，结合 <span class="math inline">\((v,v)=0\)</span> 可以得出 <span class="math inline">\((v_+,v_+) &lt; 0\)</span> 和 <span class="math inline">\((v_-, v_-)&lt;0\)</span> 中至少有一个成立。不妨设<span class="math inline">\((v_+,v_+)&lt;0\)</span>，则 level 2 要求<span class="math inline">\(|I_-|\leq1\)</span>，即 <span class="math inline">\(\{v_s\}\)</span>均非零且恰有一个元素与其它元素异号。</li></ol><p>至此断言 2 得证，从而定理得证。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div><div id="ref-Maxwell82" class="csl-entry" role="listitem">Maxwell, George. 1982. <span>“Sphere Packings and Hyperbolic ReflectionGroups.”</span> <em>Journal of Algebra</em> 79 (1): 78–97. <a href="https://doi.org/10.1016/0021-8693(82)90318-0">https://doi.org/10.1016/0021-8693(82)90318-0</a>.</div><div id="ref-Maxwell89" class="csl-entry" role="listitem">———. 1989. <span>“Wythoff’s Construction for Coxeter Groups.”</span><em>Journal of Algebra</em> 123 (2): 351–77. <a href="https://doi.org/10.1016/0021-8693(89)90051-3">https://doi.org/10.1016/0021-8693(89)90051-3</a>.</div></div><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>这里解释下为什么在 <span class="math inline">\(K\)</span> 中一定可以找到一个非平凡的元素。由于<span class="math inline">\(\Gamma\setminus\{s\}\)</span>是不可约仿射的，<span class="math inline">\(\mathrm{rad}(V_I)=\mathbb{R}\omega_s\)</span>，所以<span class="math inline">\((\cdot,\cdot)\)</span> 在 <span class="math inline">\(V_I/\mathbb{R}\omega_s\)</span>上诱导了一个正定内积。商群 <span class="math inline">\(W_I/K\)</span> 是<span class="math inline">\(V_I/\mathbb{R}\omega_s\)</span>中的反射群，并且保持这个正定内积不变，所以根据 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec. 6.4</a>)</span> 的结论，<span class="math inline">\(W_I/K\)</span> 是有限群。于是 <span class="math inline">\(W_I\)</span> 作为仿射 Coxeter 群是无限群，对 <span class="math inline">\(K\)</span> 取商群是有限群，所以 <span class="math inline">\(K\)</span> 必然是无限群。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> Coxeter Groups </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（四）：有限、仿射、双曲三种情形的 Tits 锥</title>
      <link href="coxeter-groups-three-cases/"/>
      <url>coxeter-groups-three-cases/</url>
      
        <content type="html"><![CDATA[<p>本文主要参考了 <span class="citation" data-cites="Howlett1997">(<a href="#ref-Howlett1997" role="doc-biblioref">Howlett, Rowley, and Taylor1997</a>)</span>。</p><p>书接 <a href="coxeter-groups-tits-cone">上回</a>，我们来研究内积<span class="math inline">\((\cdot,\cdot)\)</span>分别是有限、仿射和双曲三种情形时，其 Tits 锥 <span class="math inline">\(\mathcal{C}\)</span> 和对偶锥 <span class="math inline">\(\mathcal{C}^\ast\)</span> 的结构。</p><h1 id="有限">有限</h1><p>一个熟知的结论是，内积 <span class="math inline">\((\cdot,\cdot)\)</span> 是正定的当且仅当 <span class="math inline">\((W,S)\)</span> 是有限群 <span class="citation" data-cites="Humphreys90">(见 <a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.6.4</a>)</span>。我这里略过对此结论的证明（否则篇幅会拉的太长）。我们来证明这还等价于<span class="math inline">\(\mathcal{C}=V^\ast\)</span>：</p><div id="finite-tits-V" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 是有限群当且仅当 Tits 锥 <span class="math inline">\(\mathcal{C}=V^\ast\)</span>。</p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>: 由 <span class="math inline">\(\mathcal{C}=V^\ast\)</span> 可得 <span class="math inline">\(-\mathcal{D}\in\mathcal{C}\)</span>（<span class="math inline">\(\mathcal{D}\)</span> 是基本区域），而对任何 <span class="math inline">\(x\in-\mathcal{D}\)</span> 都有 <span class="math inline">\(\Phi^+\subseteq \mathrm{Neg}(x)\)</span>，根据 <a href="/coxeter-groups-tits-cone/#tits-neg-finite">Tits锥的刻画</a>，<span class="math inline">\(|\Phi^+|=|\mathrm{Neg}(x)|&lt;\infty\)</span>，<a href="/coxeter-groups-root-system/#w-phi-both-finite-infinite">从而<span class="math inline">\(W\)</span> 是有限群</a>。</p><p><span class="math inline">\(\Leftarrow\)</span>: <span class="math inline">\(W\)</span> 是有限群说明 <span class="math inline">\(\Phi\)</span> 也是有限的，从而对任何 <span class="math inline">\(x\in V^\ast\)</span> 都有 <span class="math inline">\(|\mathrm{Neg}(x)|\leq|\Phi^+|&lt;\infty\)</span>，从而 <span class="math inline">\(x\in\mathcal{C}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>在下图中，<span class="math inline">\(W\)</span> 是正二十面体群<span class="math inline">\(H_3\)</span>，红色的锥是基本区域，它在 <span class="math inline">\(W\)</span> 的作用下铺满了整个空间，所以 <span class="math inline">\(\mathcal{C}=\mathbb{R}^3\)</span>。<span class="math inline">\(\mathcal{C}\)</span>与球面的交给出球面上的密铺。如果用直线而不是球面上的弧连接顶点的话，得到的是正二十面体。</p><p><img src="/images/coxeter/Tits_finite.png" class="fig" width="350"></p></div><h1 id="无限群的-tits-锥">无限群的 Tits 锥</h1><p>在仿射和双曲的情形，Coxeter 群都是无限群。我们来介绍一点关于无限Coxeter 群 Tits 锥的一般结论。</p><div id="phi-J-finite" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题2.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(W\)</span> 是不可约 Coxeter 群。如果存在 <span class="math inline">\(J\subsetneqq S\)</span> 使得 <span class="math inline">\(\Phi\setminus\Phi_J\)</span> 是有限集，则 <span class="math inline">\(W\)</span> 必然是有限群。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(J\subsetneqqS\)</span>，所以可以设 <span class="math inline">\(S\setminusJ=\{s_1,\ldots,s_r\}\,(r\geq1)\)</span>。由于 <span class="math inline">\(W\)</span> 不可约，<span class="math inline">\(W\)</span> 的 Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是连通的，<span class="math inline">\(J\)</span> 中的任何顶点都可以通过某条路径与 <span class="math inline">\(S\setminus J\)</span> 中的顶点相连。记 <span class="math inline">\(d(s)\)</span> 是顶点 <span class="math inline">\(s\)</span> 与 <span class="math inline">\(S\setminus J\)</span> 之间的最短距离，将 <span class="math inline">\(S\)</span> 按如下方式重新排序为 <span class="math inline">\(S=\{s_1,\ldots,s_n\}\)</span>： <span class="math display">\[S =\underbrace{\overbrace{\{s_1,\ldots,s_r\}}^{d(s)=0}}_{S\setminusJ}\cup\underbrace{\overbrace{\{s_{r+1},\ldots,s_{r+k}\}}^{d(s)=1},\overbrace{\{s_{r+k+1},\ldots\}}^{d(s)=2},\cdots}_{J}\,.\]</span></p><p>即 <span class="math inline">\(S\setminus J\)</span>中的顶点排在最前面，接下来是那些与 <span class="math inline">\(S\setminus J\)</span> 距离为 1 的顶点，然后是与<span class="math inline">\(S\setminus J\)</span> 距离为 2的顶点，等等。</p><p>记 <span class="math inline">\(\Phi_i^+\)</span> 是所有可以由 <span class="math inline">\(\{\alpha_i,\ldots,\alpha_n\}\)</span> 张成，且<span class="math inline">\(\alpha_i\)</span> 项系数不为 0的正根组成的集合： <span class="math display">\[\Phi_i^+=\{\lambda\mid\lambda\in\Phi^+,\ \lambda=\sum_{j=i}^nc_j\alpha_j,\ c_i\ne0\}.\]</span> 则不难看出有 <span class="math inline">\(\Phi^+=\Phi_1^+\sqcup\cdots\sqcup\Phi^+_n\)</span>，以及<span class="math inline">\(\Phi^+\setminus\Phi_J^+=\Phi_1^+\cup\cdots\cup\Phi^+_r\)</span>。由于假设了<span class="math inline">\(\Phi\setminus\Phi_J\)</span> 是有限的，所以<span class="math inline">\(\Phi_1^+,\ldots,\Phi^+_r\)</span>都是有限的。</p><p>我们用归纳法依次论证 <span class="math inline">\(\Phi^+_{r+1},\ldots,\Phi^+_{n}\)</span>也都是有限集：设 <span class="math inline">\(r+1\leq i\leq n\)</span>且已知对所有 <span class="math inline">\(j&lt;i\)</span>，<span class="math inline">\(\Phi_1^+,\ldots,\Phi^+_j\)</span> 都是有限集，现在考察 <span class="math inline">\(\Phi^+_i\)</span>，注意必然有 <span class="math inline">\(d(s_i)\geq1\)</span>，所以存在 <span class="math inline">\(j&lt;i\)</span> 使得 <span class="math inline">\(d(s_j)&lt;d(s_i)\)</span> 且 <span class="math inline">\(s_j\sim s_i\)</span>。</p><p>我们发现：</p><ol type="1"><li><span class="math inline">\(s_j\Phi_i^+\)</span>的元素都是正根。这是因为用 <span class="math inline">\(s_j\)</span>作用不改变 <span class="math inline">\(\Phi^+_i\)</span> 中元素的 <span class="math inline">\(\alpha_i\)</span> 项系数；</li><li><span class="math inline">\(s_j\Phi_i^+\subset\Phi^+_j\)</span>。这是因为若<span class="math inline">\(\lambda=\sum_{k\geqi}c_k\alpha_k\in\Phi^+_i\)</span>，则 <span class="math display">\[s_j\lambda=\lambda-2\left(\sum_{k\geqi}c_k(\alpha_k,\alpha_j)\right)\alpha_j.\]</span> 上面每一项 <span class="math inline">\(c_k(\alpha_k,\alpha_j)\)</span> 都非正，且由于顶点<span class="math inline">\(s_i,s_j\)</span> 相邻所以 <span class="math inline">\(c_i(\alpha_i,\alpha_j)&lt;0\)</span>。所以 <span class="math inline">\(s_j\lambda\)</span> 的 <span class="math inline">\(\alpha_j\)</span> 项系数严格大于 0。</li></ol><p>于是 <span class="math inline">\(|\Phi_i^+|\leq |\Phi^+_j|\)</span>也是有限集。从而所有 <span class="math inline">\(\Phi^+_1,\ldots,\Phi^+_n\)</span> 都是有限集，从而<span class="math inline">\(\Phi\)</span> 也是有限的。所以 <span class="math inline">\(W\)</span> 是有限群，命题得证。<span class="math inline">\(\blacksquare\)</span></p><p><a href="#phi-J-finite" title="命题 2.1">命题 2.1</a>有如下的推论：</p><div id="tits-cone-pointed" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(W\)</span> 不可约且是无限群，则 Tits 锥 <span class="math inline">\(\mathcal{C}\)</span> 满足 <span class="math inline">\(\mathcal{C}\cap-\mathcal{C}=\{0\}\)</span>，从而<span class="math inline">\(\mathcal{C}\)</span> 是一个点锥 (pointedcone)。</p></div><p><strong>证明</strong>：由于 <span class="math display">\[\mathcal{C}\cap-\mathcal{C}=\bigcup_{w_1,w_2\inW}w_1\overline{\mathcal{D}}\cap w_2(-\overline{\mathcal{D}}),\]</span>所以若 <span class="math inline">\(\mathcal{C}\cap-\mathcal{C}\ne\{0\}\)</span>则存在 <span class="math inline">\(x\ne0\in\overline{\mathcal{D}}\)</span> 和 <span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(-wx\in\overline{\mathcal{D}}\)</span>。令 <span class="math display">\[J=\{s\in S\mid \langle\alpha_s,\,x\rangle=0\}\]</span> 是经过 <span class="math inline">\(x\)</span> 的那些镜子。<span class="math inline">\(x\ne 0\)</span> 说明 <span class="math inline">\(J\subsetneqq S\)</span> 是真子集。</p><p>对任何 <span class="math inline">\(\lambda\in\Phi^+\setminus\Phi^+_J\)</span>，显然<span class="math inline">\(\langle\lambda,\,x\rangle&gt;0\)</span>，并且对这样的 <span class="math inline">\(\lambda\)</span> 有 <span class="math display">\[\langle w\lambda,\,-wx\rangle = \langle\lambda,\,-x\rangle&lt;0.\]</span> 而 <span class="math inline">\(-wx\in\overline{\mathcal{D}}\)</span>，所以 <span class="math inline">\(w\lambda\)</span> 是负根，从而 <span class="math inline">\(\Phi^+\setminus\Phi^+_J\subset\mathrm{Neg}(w)\)</span>，从而<span class="math display">\[|\Phi^+\setminus\Phi^+_J|\leq|\mathrm{Neg}(w)|=l(w)&lt;\infty.\]</span> 由 <a href="#phi-J-finite" title="命题 2.1">命题 2.1</a> <span class="math inline">\(W\)</span>是有限群，这与已知矛盾。<span class="math inline">\(\blacksquare\)</span></p><div id="dual-cone-non-trivial" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(W\)</span> 不可约且是无限群，则对偶锥 <span class="math inline">\(\mathcal{C}^\ast\ne\{0\}\)</span>。</p></div><p><strong>证明</strong>：用反证法，若不然，则 <span class="math inline">\(\overline{\mathcal{C}}=\mathcal{C}^{\ast\ast}=V^\ast\)</span>是全空间。由于一个凸集的内点和它的闭包的内点集相同（证明见这个 <a href="/papers/sCONVs.pdf">附件</a>），所以 <span class="math inline">\(\mathcal{C}=V\)</span>，这与 <a href="#tits-cone-pointed" title="推论 2.2">推论 2.2</a> 的结论 <span class="math inline">\(\mathcal{C}\)</span> 是点锥矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 id="仿射">仿射</h1><p>在本节中，我们需要如下关于不可约仿射 Coxeter 群的事实 <span class="citation" data-cites="Humphreys90">(见 <a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, secs. 2.6, 6.5</a>)</span>。</p><div id="affine-facts" class="statement simple plain unnumbered"><p>设 <span class="math inline">\(W\)</span> 是不可约、仿射 Coxeter群，则：</p><ol type="1"><li><span class="math inline">\(\mathrm{rad}(V)\)</span> 的维数是1，它由一个向量 <span class="math inline">\(\delta=\sum_{s\inS}z_s\alpha_s\)</span> 生成，其中每个 <span class="math inline">\(z_s&gt;0\)</span>。</li><li><span class="math inline">\(\delta\)</span> 的坐标 <span class="math inline">\(z=(z_1,\ldots,z_s)^T\)</span> 满足 <span class="math inline">\(Az=z^TAz=0\)</span>，其中 <span class="math inline">\(A=((\alpha_s, \alpha_t))_{s,t\in S}\)</span>是内积 <span class="math inline">\((\cdot,\cdot)\)</span> 的 Gram矩阵。</li><li><span class="math inline">\(w\delta=\delta\)</span> 对所有 <span class="math inline">\(w\in W\)</span> 成立。</li><li><span class="math inline">\(A\)</span> 的任何 <span class="math inline">\(\leq n-1\)</span> 阶主子式都是正定的。</li></ol></div><p>我们花点笔墨解释一下这几个事实的含义。回忆 <span class="math inline">\(W\)</span> 称作仿射是指内积 <span class="math inline">\((\cdot,\cdot)\)</span>是半正定但不是正定的。这个定义中没有要求 <span class="math inline">\((\cdot,\cdot)\)</span> 的 Sylvester 符号中有几个0，但是上面的 1, 2 告诉我们，在 <span class="math inline">\(W\)</span>不可约的前提下，<span class="math inline">\((\cdot,\cdot)\)</span>的符号中有且只有一个 0，并且 <span class="math inline">\(\mathrm{rad}(V)\)</span> 由一个向量 <span class="math inline">\(\delta\)</span> 生成。<span class="math inline">\(\delta\)</span> 的所有系数都非零并且同号，并且<span class="math inline">\(W\)</span> 保持 <span class="math inline">\(\delta\)</span> 不动。</p><p>3 是因为 <span class="math inline">\(W\)</span> 限制在 <span class="math inline">\(\mathrm{rad}(V)\)</span> 上是恒等变换，自然保持<span class="math inline">\(\delta\)</span> 不动。</p><p>4 说的是对任何 <span class="math inline">\(I\subsetneqqS\)</span>，标准椭圆子群 <span class="math inline">\(W_I\)</span>都是有限群；或者等价地，从 <span class="math inline">\(W\)</span> 的Coxeter 图 <span class="math inline">\(\Gamma\)</span>中删去至少一个顶点以后，剩下的子图是有限的。</p><div id="tits-cone-affine" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.1</span>.</span><span class="statement-spah"> </span>在仿射的情形<span class="math inline">\(\mathcal{C}^\ast\)</span> 是一条射线：<span class="math inline">\(\mathcal{C}^\ast=\mathbb{R}_{\geq0}\delta\)</span>，Tits锥 <span class="math inline">\(\mathcal{C}\)</span> 是以 <span class="math inline">\(\delta\)</span> 为法向量的半空间加上原点：<span class="math inline">\(\mathcal{C}=\{0\}\cup\{\delta &gt;0\}\)</span>。</p></div><p><strong>证明</strong>：根据 <a href="#dual-cone-non-trivial" title="推论 2.3">推论 2.3</a> 可知 <span class="math inline">\(\mathcal{C}^\ast\ne\{0\}\)</span>。结合 <a href="/coxeter-groups-tits-cone/#dual-cone-nonspace">对偶锥中的向量范数非正</a>以及 <span class="math inline">\((\cdot,\cdot)\)</span> 半正定可得 <span class="math inline">\(\mathcal{C}^\ast\subseteq\mathbb{R}\delta\)</span>。又因为<a href="/coxeter-groups-tits-cone/#tits-cone-dual-pointed"><span class="math inline">\(\mathcal{C}^\ast\)</span> 是点锥</a>，所以 <span class="math inline">\(\mathcal{C}^\ast\)</span> 等于 <span class="math inline">\(\mathbb{R}_{\geq0}\delta\)</span> 或者 <span class="math inline">\(\mathbb{R}_{\leq0}\delta\)</span> 之一。由于 <a href="/coxeter-groups-tits-cone/#tits-cone-dual"><span class="math inline">\(\mathcal{C}^\ast\subset\mathrm{cone}(\Delta)\)</span></a>，以及<span class="math inline">\(\delta\)</span> 是 <span class="math inline">\(\Delta\)</span> 的正线性组合，所以 <span class="math inline">\(\mathcal{C}^\ast=\mathbb{R}_{\geq0}\delta\)</span>。这就给出了对偶锥<span class="math inline">\(\mathcal{C}^\ast\)</span> 的刻画。</p><p>再来分析 Tits 锥 <span class="math inline">\(\mathcal{C}\)</span>。取对偶得到 <span class="math inline">\(\overline{\mathcal{C}}=\mathcal{C}^{\ast\ast}=\{\delta\geq0\}\)</span>。由于一个凸集的内点和它的闭包的内点集相同，所以<span class="math inline">\(\mathcal{C}^\circ=\{\delta&gt;0\}\)</span>，于是<span class="math display">\[\{\delta&gt;0\}\subset\mathcal{C}\subset\overline{\mathcal{C} }=\{\delta\geq0\}.\]</span></p><p>对任何 <span class="math inline">\(x\in\{\delta=0\}\)</span>，若<span class="math inline">\(x\in\mathcal{C}\)</span>，则存在 <span class="math inline">\(w\in W\)</span> 和 <span class="math inline">\(y\in\overline{\mathcal{D}}\)</span> 使得 <span class="math inline">\(x=wy\)</span>。于是 <span class="math display">\[0= \langle \delta,\,x\rangle=\langle \delta,\,wy\rangle=\langlew^{-1}\delta,\,y\rangle=\langle \delta,\,y\rangle=\sum_{s\inS}z_s\langle \alpha_s,\,y\rangle.\]</span> 然而每个 <span class="math inline">\(z_s&gt;0\)</span>，并且由于 <span class="math inline">\(y\in\overline{\mathcal{D}}\)</span> 所以每个 <span class="math inline">\(\langle\alpha_s,\,y\rangle\geq0\)</span>，这只能是 <span class="math inline">\(\langle \alpha_s,\,y\rangle=0\)</span> 对所有<span class="math inline">\(\alpha_s\in\Delta\)</span> 成立，这导致<span class="math inline">\(y=0\)</span>，从而 <span class="math inline">\(x=0\)</span>，所以超平面 <span class="math inline">\(\{\delta=0\}\)</span> 中属于 <span class="math inline">\(\mathcal{C}\)</span> 的只有 0。这就证明了 <span class="math inline">\(\mathcal{C}=\{0\}\cup\{\delta&gt;0\}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>在下图中，<span class="math inline">\(W\)</span> 是仿射 <span class="math inline">\(\widetilde{A}_2\)</span>，红色的锥是基本区域，它在<span class="math inline">\(W\)</span> 的作用下铺满了整个上半空间，所以<span class="math inline">\(\mathcal{C}=\{z&gt;0\}\cup\{0\}\)</span>。<span class="math inline">\(\mathcal{C}\)</span> 与平面 <span class="math inline">\(z=1\)</span> 的交给出二维的 Euclidean 密铺。</p><p><img src="/images/coxeter/Tits_affine.png" class="fig" width="350"></p></div><h1 id="双曲">双曲</h1><p>双曲的情形 Tits 锥的结构要复杂许多，一般来说没有完整的刻画。</p><p>我们首先来介绍一些关于 Lorentzian 内积的基本知识。这些内容在 <span class="citation" data-cites="ratcliffe">(<a href="#ref-ratcliffe" role="doc-biblioref">Ratcliffe 2006, vol. 149, chap. 3</a>)</span>中都可以找到。</p><p>设 <span class="math inline">\(V\)</span> 是一个 Lorentzian空间。我们称 <span class="math inline">\(v\in V\)</span> 是</p><ol type="1"><li>space-like 的，如果 <span class="math inline">\((v,v)&gt;0\)</span>；</li><li>light-like 的，如果 <span class="math inline">\((v,v)=0\)</span>；</li><li>time-like 的，如果 <span class="math inline">\((v,v)&lt;0\)</span>。</li></ol><p>这个定义也可以推广到 <span class="math inline">\(V\)</span>的子空间中：如果 <span class="math inline">\(U\subset V\)</span>是一个子空间，我们称 <span class="math inline">\(U\)</span> 是</p><ol type="1"><li>space-like 的，如果 <span class="math inline">\((\cdot,\cdot)\mid_U\)</span> 是正定的；</li><li>light-like 的，如果 <span class="math inline">\((\cdot,\cdot)\mid_U\)</span>是半正定的，但不是正定的；</li><li>time-like 的，如果 <span class="math inline">\(U\)</span> 包含time-like 的向量。</li></ol><p>由于 Lorentzian 内积是非退化的，所以对任何子空间 <span class="math inline">\(U\)</span> 都有 <span class="math inline">\(\dim U+ \dim U^\bot=n\)</span> 成立。</p><p>下面的命题是关于二次型知识的简单练习，我省略它们的证明。</p><div id="orth-complement-lorentzian" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.1</span>.</span></p><ol type="1"><li><span class="math inline">\(U\)</span> 是 space-like 的当且仅当<span class="math inline">\(U^\bot\)</span> 是 time-like 的；</li><li><span class="math inline">\(U\)</span> 是 light-like 的当且仅当<span class="math inline">\(U^\bot\)</span> 是 light-like 的。</li></ol></div><div id="lorentzinian-decomposition"></div><p>取 <span class="math inline">\(z\)</span> 是任一满足 <span class="math inline">\((z,z)=-1\)</span> 的 time-like 的向量，则 <span class="math inline">\((\mathbb{R}z)^\bot\)</span> 是 space-like的子空间并且有 <span class="math inline">\(V=\mathbb{R}z\oplus(\mathbb{R}z)^\bot\)</span> 成立。任何 <span class="math inline">\(v\inV\)</span> 可以写成 <span class="math inline">\(v = x + cz\,(x\in(\mathbb{R}z)^\bot,c\in\mathbb{R})\)</span> 的形式。记 <span class="math display">\[\mathcal{Q}=\{v\in V\mid (v,v)\leq 0\}\]</span>是所有非 space-like 的向量组成的集合，则 <span class="math display">\[v=x+cz\in\mathcal{Q}\Leftrightarrow(x,x)-c^2\leq0.\]</span></p><p><span class="math inline">\(\mathcal{Q}\)</span> 由上、下两个分支<span class="math inline">\(\mathcal{Q}_+,\,\mathcal{Q}_-\)</span>组成，它们分别由 <span class="math inline">\(\mathcal{Q}\)</span> 中满足<span class="math inline">\(c\geq0\)</span> 和 <span class="math inline">\(c\leq0\)</span> 的点组成。<span class="math inline">\(\mathcal{Q}_+=-\mathcal{Q}_-\)</span> 并且 <span class="math inline">\(\mathcal{Q}_+\cap\mathcal{Q}_-=\{0\}\)</span>。</p><p><img src="/images/coxeter/hyperboloid.svg" class="fig" width="350"></p><p>设 <span class="math inline">\(u,v\)</span>是两个非零向量，我们用记号 <span class="math inline">\(u\sim v\)</span>表示 <span class="math inline">\(u,v\)</span> 属于同一个分支，即 <span class="math inline">\(u,v\)</span> 同时属于 <span class="math inline">\(\mathcal{Q}_+\)</span> 或者同时属于 <span class="math inline">\(\mathcal{Q}_-\)</span>；用记号 <span class="math inline">\(u\not\sim v\)</span> 表示 <span class="math inline">\(u,v\)</span> 属于不同的分支，即 <span class="math inline">\(u,v\)</span> 一个属于 <span class="math inline">\(\mathcal{Q}_+\)</span>，另一个属于 <span class="math inline">\(\mathcal{Q}_-\)</span>。</p><div id="connected-component-dot" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.2</span> <span class="statement-info">(<span class="citation" data-cites="ratcliffe">(<a href="#ref-ratcliffe" role="doc-biblioref">Ratcliffe 2006</a>, thm.3.1.1)</span>)</span>.</span><span class="statement-spah"> </span><br></p><p>设 <span class="math inline">\(u,v\in\mathcal{Q}-\{0\}\)</span>。</p><ol type="1"><li>如果 <span class="math inline">\(u\sim v\)</span> 则 <span class="math inline">\((u,v)\leq0\)</span>。</li><li><span class="math inline">\((u,v)=0\)</span> 当且仅当 <span class="math inline">\(u,v\)</span> 是共线的 light-like 的向量。</li><li>如果 <span class="math inline">\(u,v\)</span> 中至少有一个是time-like 的向量，则 <span class="math inline">\(u\sim v\)</span>当且仅当 <span class="math inline">\((u,v)&lt;0\)</span>。</li></ol></div><p><strong>证明</strong>：</p><p>设 <span class="math inline">\(u=x+cz,\, v=y+dz\)</span>，则 <span class="math inline">\((x,x)\leq c^2\)</span>，<span class="math inline">\((y,y)\leq d^2\)</span>。</p><ol type="1"><li>若 <span class="math inline">\(u\sim v\)</span>，则 <span class="math inline">\(c,d\)</span> 同为正或者同为负。由于 <span class="math inline">\(z^\bot\)</span> 是正定子空间，<span class="math inline">\(x,y\in z^\bot\)</span>，由 Cauchy-Schwartz不等式有 <span class="math display">\[(u,v)=(x,y)-cd\leq\sqrt{(x,x)\cdot (y,y)}-cd \leq\sqrt{c^2d^2}-cd=|cd|-cd=0.\]</span></li><li>如果 <span class="math inline">\(u,v\)</span> 不共线，则 <span class="math inline">\(U=\mathrm{span}\{u,v\}\)</span> 是二维子空间，设<span class="math inline">\(w=au+bv\,(a,b\in\mathbb{R})\)</span> 是<span class="math inline">\(U\)</span> 中任一向量，由 <span class="math inline">\((u,v)=0\)</span> 可得 <span class="math display">\[(w,w)=a^2(u,u) + b^2(v,v)\leq0.\]</span> 即 <span class="math inline">\(U\)</span> 不包含 space-like 的向量。这与 <span class="math inline">\(\dim U=2\)</span> 和 <span class="math inline">\(V\)</span> 的 Sylvester 符号是 <span class="math inline">\((n-1,1)\)</span> 矛盾，所以 <span class="math inline">\(u,v\)</span> 必须共线。进一步显然 <span class="math inline">\(u,v\)</span> 都是 light-like的。反方向是显然的。</li><li>不妨设 <span class="math inline">\(u\)</span> 是 time-like的向量。<span class="math inline">\(\Rightarrow\)</span>：如果 <span class="math inline">\(u\sim v\)</span>，1 证明了 <span class="math inline">\((u,v)\leq0\)</span>。结合 <span class="math inline">\(u\)</span> 是 time-like 的和 2的结论，严格的不等号成立。<span class="math inline">\(\Leftarrow\)</span>：如果 <span class="math inline">\(u\not\sim v\)</span> 则 <span class="math inline">\(u\sim -v\)</span>，根据 1 的结论，<span class="math inline">\((u,-v)\leq0\)</span>，从而 <span class="math inline">\((u,v)\geq0\)</span>，矛盾。</li></ol><p><span class="math inline">\(\blacksquare\)</span></p><p>记 <span class="math inline">\(\mathcal{Q}_+\)</span> 和 <span class="math inline">\(\mathcal{Q}_-\)</span> 的内点分别为 <span class="math inline">\(\mathcal{N}_+\)</span> 和 <span class="math inline">\(\mathcal{N}_-\)</span>，<span class="math inline">\(\mathcal{N}_+\)</span> 和 <span class="math inline">\(\mathcal{N}_-\)</span> 分别是 <span class="math inline">\(\mathcal{N}=\{v\in V\mid (v,v)&lt;0\}\)</span>的两个连通分支。</p><p>由于 Lorentzinian 内积是非退化的，所以我们可以把 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 等同起来，这样 <span class="math inline">\(\mathcal{C}\)</span> 和 <span class="math inline">\(\mathcal{C}^\ast\)</span> 都在 <span class="math inline">\(V\)</span> 中。我们将证明这时 Tits 锥的闭包 <span class="math inline">\(\overline{ \mathcal{C} }\)</span> 必然包含 <span class="math inline">\(\mathcal{Q}_+,\,\mathcal{Q}_-\)</span>中的一个，同时与另一个的交只有 <span class="math inline">\(\{0\}\)</span>。</p><p>首先由 <a href="/coxeter-groups-tits-cone/#dual-cone-nonspace">前文中证明的结论</a>，<span class="math inline">\(\mathcal{C}^\ast\)</span>中的向量相互之间的内积非正，特别地对任何 <span class="math inline">\(v\in\mathcal{C}^\ast\)</span> 有 <span class="math inline">\((v,v)\leq0\)</span>，所以 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}\)</span>。</p><div id="dual-cone-trivial-intersection" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.3</span>.</span><span class="statement-spah"> </span>在 <span class="math inline">\(W\)</span> 不可约且双曲的情形，<span class="math inline">\(\mathcal{C}^\ast\cap\mathcal{Q}_+,\,\mathcal{C}^\ast\cap\mathcal{Q}_-\)</span> 中必有一个是<span class="math inline">\(\{0\}\)</span>。</p></div><p>这个结论应该是很直观的，如果 <span class="math inline">\(\mathcal{C}^\ast\)</span> 同时包含 <span class="math inline">\(\mathcal{Q}_+,\mathcal{Q}_-\)</span>中的非零向量的话，由于 <span class="math inline">\(\mathcal{C}^\ast\)</span>是点锥，这两个向量必然不共线，从而它们的非负线性组合可以给出 space-like的向量，这与 <span class="math inline">\(\mathcal{C}^\ast\)</span> 不含space-like 的向量矛盾。</p><p><strong>证明</strong>：若不然，设 <span class="math inline">\(u\in\mathcal{C}^\ast\cap\mathcal{Q}_+,\,u'\in\mathcal{C}^\ast\cap\mathcal{Q}_-\)</span> 是非零向量，<span class="math inline">\(u=x+cz,\,u'=y+dz\)</span> 是 <a href="#lorentzinian-decomposition">如前所述的分解</a>，则 <span class="math inline">\(c&gt;0,\,d&lt;0\)</span>。考察 <span class="math display">\[v=cu'-du=cy-dx\in(\mathbb{R}z)^\bot.\]</span><span class="math inline">\(v\)</span> 是 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(u'\)</span> 的非负线性组合，所以 <span class="math inline">\(v\)</span> 也属于 <span class="math inline">\(\mathcal{C}^\ast\)</span>，从而 <a href="/coxeter-groups-tits-cone/#dual-cone-nonspace"><span class="math inline">\((v,v)\leq0\)</span></a>。结合 <span class="math inline">\((\mathbb{R}z)^\bot\)</span> 是 space-like 的可得<span class="math inline">\(v=0\)</span>，于是 <span class="math inline">\(cu'=du\)</span>。由于 <span class="math inline">\(c,d\)</span> 异号所以 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(-u\)</span> 同时属于 <span class="math inline">\(\mathcal{C}^\ast\)</span>，但 <span class="math inline">\(\mathcal{C}^\ast\)</span> 是点锥，所以 <span class="math inline">\(u=0\)</span>。从而 <span class="math inline">\(\mathcal{C}^\ast\cap\mathcal{Q}_+\)</span> 和<span class="math inline">\(\mathcal{C}^\ast\cap\mathcal{Q}_-\)</span>中必有一个等于 <span class="math inline">\(\{0\}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="dual-cone-belongs-branch" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论4.4</span>.</span><span class="statement-spah"></span>在双曲的情形，必有 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_+\)</span> 或者<span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_-\)</span>之一成立。</p></div><p><strong>证明</strong>：结合 <a href="#dual-cone-trivial-intersection" title="命题 4.3">命题 4.3</a> 和 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}=\mathcal{Q}_+\cup\mathcal{Q}_-\)</span>即得。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-closure" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论4.5</span>.</span><span class="statement-spah"></span>在双曲的情形，如果 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_+\)</span> 则<span class="math inline">\(\mathcal{C}\supset\mathcal{N}_-\)</span>。反之若 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_-\)</span> 则<span class="math inline">\(\mathcal{C}\supset\mathcal{N}_+\)</span>。</p></div><p><strong>证明</strong>：首先注意到对任何 <span class="math inline">\(x\in\mathcal{Q}_+\)</span> 和 <span class="math inline">\(y\in\mathcal{Q}_-\)</span> 有 <span class="math inline">\((x,y)\geq0\)</span>，所以 <span class="math inline">\(\mathcal{Q}_+\)</span> 和 <span class="math inline">\(\mathcal{Q}_-\)</span>互相包含在对方的对偶锥中。</p><p>由 <a href="#dual-cone-belongs-branch" title="推论 4.4">推论4.4</a>，不妨设 <span class="math inline">\(\mathcal{C}^\ast\subseteq\mathcal{Q}_+\)</span>，<a href="/coxeter-groups-tits-cone/#dual-dual-cone">取对偶以后有</a> <span class="math inline">\(\overline{\mathcal{C}}=\mathcal{C}^{\ast\ast}\supseteq\mathcal{Q}_+^\ast\supseteq\mathcal{Q}_-\)</span>，即 <span class="math inline">\(\overline{\mathcal{C}}\supset\mathcal{Q}_-\)</span>。由于凸集的内点等于其闭包的内点，所以<span class="math display">\[\mathcal{C}^\circ=(\overline{ \mathcal{C}})^\circ\supset\mathcal{Q}_-^\circ=\mathcal{N}_-.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>以双曲群 <span class="math inline">\((7,3)\)</span>为例，红色的锥是 <span class="math inline">\(\overline{\mathcal{D}}\)</span>，Tits 锥 <span class="math inline">\(\mathcal{C}=\mathcal{N}_+\)</span>。取 <span class="math inline">\(\mathcal{C}\)</span> 与 hyperboloid的交给出双曲密铺。</p><p><img src="/images/coxeter/Tits_hyperbolic.png" class="fig" width="350"></p><p>注意这里光锥是理想边界，光锥上的点（除 <span class="math inline">\(0\)</span>以外）无法经过有限次反射变换到基本区域中，所以理想边界不属于 <span class="math inline">\(\mathcal{C}\)</span>。即 <span class="math inline">\(\mathcal{C}\subsetneqq\mathcal{Q}_+\)</span>。</p></div><h1 id="总结">总结</h1><p>下面的表格总结了有限、仿射、双曲三种情形 <span class="math inline">\(\mathcal{C}\)</span> 和 <span class="math inline">\(\mathcal{C}^\ast\)</span> 的结论：</p><table><tbody><tr><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\mathcal{C}\)</span></td><td style="text-align: center;"><span class="math inline">\(\mathcal{C}^\ast\)</span></td></tr><tr><td style="text-align: center;">有限</td><td style="text-align: center;"><span class="math inline">\(V^\ast\)</span></td><td style="text-align: center;"><span class="math inline">\(\{0\}\)</span></td></tr><tr><td style="text-align: center;">仿射</td><td style="text-align: center;"><span class="math inline">\(\{\delta&gt;0\}\cup\{0\}\)</span></td><td style="text-align: center;"><span class="math inline">\(\mathbb{R}_{\geq0}\delta\)</span></td></tr><tr><td style="text-align: center;">双曲</td><td style="text-align: center;">点锥且包含 <span class="math inline">\(\mathcal{N}_+,\mathcal{N}_-\)</span> 之一</td><td style="text-align: center;">属于 <span class="math inline">\(\mathcal{Q}_+,\mathcal{Q}_-\)</span> 之一</td></tr></tbody></table><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Howlett1997" class="csl-entry" role="listitem">Howlett, Robert B., Peter Rowley, and D. E. Taylor. 1997. <span>“OnOuter Automorphism Groups of Coxeter Groups.”</span> <em>ManuscriptaMathematica</em> 93: 499–513. <a href="https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/HowRowTay/1996-26.html">https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/HowRowTay/1996-26.html</a>.</div><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div><div id="ref-ratcliffe" class="csl-entry" role="listitem">Ratcliffe, John G. 2006. <em>Foundations of Hyperbolic Manifolds</em>.Second. Vol. 149. Graduate Texts in Mathematics. Springer.</div></div>]]></content>
      
      
      <categories>
          
          <category> Coxeter Groups </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（三）：Tits 锥</title>
      <link href="coxeter-groups-tits-cone/"/>
      <url>coxeter-groups-tits-cone/</url>
      
        <content type="html"><![CDATA[<p>本文主要参考了 Bob Howlett 教授的讲义 <span class="citation" data-cites="Howlett-note">(<a href="#ref-Howlett-note" role="doc-biblioref">Howlett 1996</a>)</span>。</p><h1 id="tits-锥">Tits 锥</h1><p>在获得了 <span class="math inline">\(V\)</span>中关于根系的一些知识后，我们下面转移到 <span class="math inline">\(V\)</span> 的对偶空间 <span class="math inline">\(V^\ast\)</span> 中讨论万花筒的结构。</p><p>设 <span class="math inline">\(V^\ast\)</span> 是 <span class="math inline">\(V\)</span> 的对偶空间，<span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 之间有一个自然的双线性映射 <span class="math display">\[V\times V^\ast\to\mathbb{R}: \langlev,\,f\rangle= f(v).\]</span> 注意 <span class="math inline">\(\langle\,,\,\rangle\)</span> 和内积 <span class="math inline">\((\cdot,\cdot)\)</span> 的区别：<span class="math inline">\(\langle \,,\,\rangle\)</span> 是 <span class="math inline">\(V\times V^\ast\)</span>的自然配对，用尖括号表示；<span class="math inline">\((\cdot,\cdot)\)</span> 是 <span class="math inline">\(V\)</span> 上的内积。</p><p><span class="math inline">\(V\)</span> 上的可逆线性变换 <span class="math inline">\(g\in\mathrm{GL}(V)\)</span> 同样作用在 <span class="math inline">\(V^\ast\)</span> 上：对 <span class="math inline">\(f\in V^\ast\)</span>，线性泛函 <span class="math inline">\(g\cdot f\)</span> 定义为 <span class="math display">\[(g\cdot f)(v) = f(g^{-1} v).\]</span>为了简便我们省略 <span class="math inline">\(g\cdot f\)</span> 中的<span class="math inline">\(\cdot\)</span>，把它写作 <span class="math inline">\(gf\)</span>。</p><p>这样定义的目的是为了让 <span class="math inline">\(g\)</span>保持双线性映射 <span class="math inline">\(\langle \,,\,\rangle\)</span>不变： <span class="math display">\[\langle gv,\,gf\rangle = \langlev,\,f\rangle.\]</span> 用 <span class="math inline">\(g^{-1}f\)</span>代替 <span class="math inline">\(f\)</span>，我们得到 <span class="math display">\[\langle gv,\,f\rangle = \langlev,\,g^{-1}f\rangle.\]</span> 特别当 <span class="math inline">\(g=s\)</span> 是一个反射时，由于 <span class="math inline">\(s=s^{-1}\)</span> 所以 <span class="math display">\[\langle sv,\,f\rangle = \langlev,\,sf\rangle.\]</span> 这种将单个反射在 <span class="math inline">\((\cdot,\cdot){\,}{}\)</span>两边「跳来跳去」的技巧后面会经常用到。</p><p>由于 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 互为对偶空间，所以 <span class="math inline">\(\Delta=\{\alpha_s\}\)</span> 是 <span class="math inline">\(V^\ast\)</span>上的一组线性无关的泛函，定义它们的正半空间的交为 <span class="math display">\[\mathcal{D}= \bigcap_{s\in S}\{x\in V^\ast\mid\langle \alpha_s,\,x\rangle &gt; 0\}.\]</span> <span class="math inline">\(\mathcal{D}\)</span> 总是 <span class="math inline">\(V^\ast\)</span> 中的非空开集，其闭包记作 <span class="math inline">\(\overline{\mathcal{D}}\)</span>。你可以把 <span class="math inline">\(\mathcal{D}\)</span>理解为万花筒中原像所在的房间，超平面的集合 <span class="math inline">\(\{\alpha_s=0\}\)</span> 是房间的墙壁。<span class="math inline">\(\overline{\mathcal{D}}\)</span> 就是 <span class="math inline">\(\mathcal{D}\)</span> 加上了房间四周的墙壁。</p><p><span class="math inline">\(W\)</span> 同样作用在 <span class="math inline">\(V^\ast\)</span> 上： <span class="math display">\[\langle v,\,w f\rangle = \langlew^{-1}v,\,f\rangle.\quad v\in V,\,f\in V^\ast.\]</span> 在 <a href="/coxeter-groups-root-system/#faithful">上文</a> 中我们已经证明了<span class="math inline">\(W\)</span> 忠实地作用在 <span class="math inline">\(V\)</span> 上。不难验证在此定义下，<span class="math inline">\(W\)</span> 也忠实地作用在 <span class="math inline">\(V^\ast\)</span> 上，即如果 <span class="math inline">\(wf=f\)</span> 对任何 <span class="math inline">\(f\in V^\ast\)</span> 成立，则 <span class="math inline">\(w=1\)</span>。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>定义 <strong>Tits锥</strong>为 <span class="math display">\[\mathcal{C}= \bigcup_{w\in W}w\overline{\mathcal{D}}.\]</span></p></div><p>Tits 锥 <span class="math inline">\(\mathcal{C}\)</span>可以理解为万花筒，它是由原像房间 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 在 <span class="math inline">\(W\)</span> 下的所有虚像构成的。容易看到 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(W\)</span>- 不变的。</p><p>读者可能有疑问为什么 Tits 锥位于对偶空间 <span class="math inline">\(V^\ast\)</span>中。一个看起来更自然的想法是，直接把 <span class="math inline">\(V\)</span> 中所有以 <span class="math inline">\(\Delta\)</span> 为法向量的正半空间之交 <span class="math display">\[\bigcap_{s\in S}\{v\in V\mid(\alpha_s,v)&gt;0\}\]</span> 作为基本区域 <span class="math inline">\(\mathcal{D}\)</span>。在内积 <span class="math inline">\((\cdot,\cdot)\)</span>非退化时，这样做是可以的，但是在 <span class="math inline">\((\cdot,\cdot)\)</span> 退化时，可能会出现 <span class="math inline">\(\mathcal{D}\)</span> 是空集的问题。我们以仿射<span class="math inline">\(\widetilde{A_1}\)</span> 为例，它的 Coxeter矩阵是 <span class="math display">\[\begin{pmatrix}1 &amp;\infty\\\infty&amp;1\end{pmatrix}.\]</span> 在 <span class="math inline">\(a_{s,t}=1\)</span> 时它给出的内积的 Gram 矩阵是<span class="math display">\[\begin{pmatrix}(\alpha_s,\alpha_s) &amp;(\alpha_s,\alpha_t)\\(\alpha_t,\alpha_t)&amp;(\alpha_t,\alpha_t)\end{pmatrix}=\begin{pmatrix}1&amp;-1\\-1&amp;1\end{pmatrix}.\]</span> 假设 <span class="math inline">\(v=a\alpha_s+b\alpha_t\in\mathcal{D}\)</span> 满足<span class="math inline">\((v,\alpha_s)&gt;0\)</span> 且 <span class="math inline">\((v,\alpha_t)&gt;0\)</span>，你会发现这要求 <span class="math inline">\(a&gt;b\)</span> 且 <span class="math inline">\(b&gt;a\)</span>，不存在这样的 <span class="math inline">\(v\)</span>！但是通过区分 <span class="math inline">\(W\)</span> 在 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 上的作用就可以避免这个问题。因为<span class="math inline">\(\Delta\)</span> 作为 <span class="math inline">\(V\)</span> 的一组基构成 <span class="math inline">\(V^\ast\)</span> 上一组线性无关的泛函，它们在 <span class="math inline">\(V^\ast\)</span>中正半空间的交是非空的拓扑开集。</p><p>读者可能注意到了：我们使用了 Tits 锥这个称呼，但 <span class="math inline">\(\mathcal{C}\)</span>真的是一个锥吗？这可不显然。要证明 Tits锥确实是锥，我们需要它的另一种等价刻画。</p><p>我们先回顾一下锥的概念：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(C\)</span> 是某实向量空间的子集。如果对任何实数<span class="math inline">\(\alpha\geq0\)</span> 都有 <span class="math inline">\(\alpha C\subset C\)</span>，就称 <span class="math inline">\(C\)</span> 是一个<strong>锥</strong>。如果 <span class="math inline">\(C\)</span> 还是凸集，就称 <span class="math inline">\(C\)</span> 是<strong>凸锥</strong>。凸锥满足对任何<span class="math inline">\(x,y\in C\)</span> 和非负实数 <span class="math inline">\(\alpha,\beta\geq0\)</span>，<span class="math inline">\(\alpha x + \beta y\)</span> 仍然属于 <span class="math inline">\(C\)</span>。</p></div><p>设 <span class="math inline">\(X\)</span>是某实向量空间的子集，我们用记号 <span class="math inline">\(\mathrm{cone}(X)\)</span> 表示 <span class="math inline">\(X\)</span> 中元素的所有有限非负线性组合： <span class="math display">\[\mathrm{cone}(X) = \left\{\sum_{i=1}^n c_ix_i,\,x_1,\ldots,x_n\in X,\, c_i\geq0.\right\}.\]</span> 显然 <span class="math inline">\(\mathrm{cone}(X)\)</span> 总是凸锥，并且它还是包含<span class="math inline">\(X\)</span> 的最小凸锥。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>当 <span class="math inline">\(X\)</span> 是有限集时，<span class="math inline">\(\mathrm{cone}(X)\)</span> 总是闭集；但是当 <span class="math inline">\(X\)</span> 是无限集时则未必。例如当 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(\mathbb{R}^2\)</span> 中直线 <span class="math inline">\(y=1\)</span> 上的全体整点时，<span class="math inline">\(\mathrm{cone}(X)=\{y&gt;0\}\cup\{0\}\)</span>不是闭集。</p></div><div id="fundamental-weights" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\Delta^\ast=\{\omega_t\}\subset V^\ast\)</span> 是<span class="math inline">\(\Delta\)</span> 的一组对偶基，满足 <span class="math inline">\(\langle\alpha_s,\,\omega_t\rangle=\delta_{st}\)</span>，<span class="math inline">\(\Delta^\ast\)</span>叫做<strong>基本权</strong>。记 <span class="math display">\[\Omega=\bigcup_{w\in W}w\Delta^\ast.\]</span><span class="math inline">\(\Omega\)</span>中的元素叫做<strong>权</strong>。</p></div><div id="fund-cone" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题1.4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\overline{\mathcal{D}}=\mathrm{cone}(\Delta^\ast)\)</span>。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(x\inV^\ast\)</span>，设 <span class="math inline">\(x=\sum_{s\inS}c_s\omega_s\)</span>，注意到 <span class="math inline">\(c_s=\langle\alpha_s,\,x\rangle\)</span>，所以 <span class="math display">\[x\in\mathrm{cone}(\Delta^\ast)\Leftrightarrowc_s\geq0 \text{ for all } s \in S \Leftrightarrow \langle\alpha_s,\,x\rangle\geq 0 \text{ for all } s\in S \Leftrightarrowx\in\overline{\mathcal{D}}.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.5</span>.</span><span class="statement-spah"> </span>对任一 <span class="math inline">\(x\in V^\ast\)</span>，定义 <span class="math display">\[\mathrm{Neg}(x)= \{\lambda\in \Phi^+\mid \langle\lambda,\,x\rangle&lt;0\}.\]</span> <span class="math inline">\(\mathrm{Neg}(x)\)</span> 是正根 <span class="math inline">\(\Phi^+\)</span> 的子集，表示 <span class="math inline">\(x\)</span> 位于哪些镜子的「背面」。即这些镜子挡在<span class="math inline">\(x\)</span> 和基本区域 <span class="math inline">\(\mathcal{D}\)</span> 之间。</p></div><p>显然 <span class="math inline">\(\overline{\mathcal{D}}=\{x\inV^\ast\mid\mathrm{Neg}(x)=\emptyset\}\)</span>。房间 <span class="math inline">\(\overline{\mathcal{D}}\)</span>和它在镜子中的所有虚像构成了 Tits 锥 <span class="math inline">\(\mathcal{C}\)</span>。<span class="math inline">\(\mathcal{C}\)</span> 中每个点都是 <span class="math inline">\(\overline{\mathcal{D}}\)</span>中某个点经过有限次反射后得到的。这启发我们给出 <span class="math inline">\(\mathcal{C}\)</span> 的另一种刻画：</p><div id="tits-neg-finite" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.6</span>.</span><span class="statement-spah"> </span>Tits 锥 <span class="math inline">\(\mathcal{C}= \{x\in V^\ast \mid |\mathrm{Neg}(x)|&lt; \infty\}\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个定理的几何意义是，Tits 锥恰好由那些和基本区域 <span class="math inline">\(\overline{\mathcal{D}}\)</span>之间只隔着有限多个镜子的点组成，这样的点一定可以通过有限次单反射变换到<span class="math inline">\(\overline{\mathcal{D}}\)</span>中。换言之，Tits 锥中的点使得下面的 <code>while</code>循环可以在有限次后结束：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> dot(x, alpha_s) &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> some s <span class="hljs-keyword">in</span> S:<br>    x = reflect(x, alpha_s)<br></code></pre></td></tr></tbody></table></figure><p>下面的动画展示了双曲 Coxeter 群 <span class="math inline">\(\Delta(3,3,7)\)</span> 的 Tits 锥中那些反射次数<span class="math inline">\(\leq10\)</span> 的点：</p><p><img src="/images/coxeter/337-anim.gif" class="fig" width="400"></p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>：设 <span class="math inline">\(x\in\mathcal{C}\)</span>，则 <span class="math inline">\(x\)</span> 可以表示为 <span class="math inline">\(x=wv\)</span>，其中 <span class="math inline">\(w\in W,v\in\overline{\mathcal{D}}\)</span>。设<span class="math inline">\(\lambda\in\mathrm{Neg}(x)\)</span>，则 <span class="math display">\[0&gt;\langle \lambda,\,x\rangle=\langle\lambda,\,wv\rangle=\langle w^{-1}\lambda,\,v\rangle.\]</span> 然而<span class="math inline">\(v\in\overline{\mathcal{D}}\)</span>，这说明<span class="math inline">\(w^{-1}\lambda\in\Phi^-\)</span>，从而 <span class="math inline">\(\mathrm{Neg}(x)\subseteq N(w^{-1})\)</span>，从而<span class="math display">\[|\mathrm{Neg}(x)|\leq|N(w^{-1})|=l(w)&lt;\infty.\]</span></p><p><span class="math inline">\(\Leftarrow\)</span>：反之若 <span class="math inline">\(|\mathrm{Neg}(x)|&lt;\infty\)</span>，我们来论证存在<span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(wx\in\overline{\mathcal{D}}\)</span>。这里的想法是，每次选择一个单根<span class="math inline">\(\alpha_s\)</span> 对应的镜面，使得 <span class="math inline">\(x\)</span> 落在这个镜子的背面，然后将 <span class="math inline">\(x\)</span> 关于 <span class="math inline">\(\alpha_s\)</span> 反射过去变到 <span class="math inline">\(\alpha_s\)</span> 的正面，这个操作会将遮挡在 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(\overline{\mathcal{D}}\)</span>之间的镜子个数严格减少 1。如此这般直到 <span class="math inline">\(x\)</span> 落入 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 为止。</p><p>严格的论证如下：</p><p>若 <span class="math inline">\(\mathrm{Neg}(x)=\emptyset\)</span>这显然成立，因为这时 <span class="math inline">\(x\)</span> 本身就落在<span class="math inline">\(\overline{\mathcal{D}}\)</span> 中。当 <span class="math inline">\(\mathrm{Neg}(x)\ne\emptyset\)</span> 时，<span class="math inline">\(\mathrm{Neg}(x)\)</span> 中一定包含一个单根 <span class="math inline">\(\alpha_s\in\Delta\)</span>，于是 <span class="math inline">\(\langle \alpha_s,\,x\rangle&lt; 0\)</span>。考虑<span class="math inline">\(x\)</span> 关于 <span class="math inline">\(\alpha_s\)</span> 的镜像点 <span class="math inline">\(sx\)</span>，<span class="math inline">\(sx\)</span> 位于 <span class="math inline">\(\alpha_s\)</span> 的正面，所以 <span class="math inline">\(\alpha_s\notin\mathrm{Neg}(sx)\)</span>，从而对任何<span class="math inline">\(\lambda\in\mathrm{Neg}(sx)\)</span>，<a href="/coxeter-groups-root-system/#simple-ref"><span class="math inline">\(s\lambda\)</span> 仍然是正根</a>。于是 <span class="math display">\[\lambda\in\mathrm{Neg}(sx)\Rightarrow\langle\lambda,\,sx\rangle&lt;0\Rightarrow\langles\lambda,\,x\rangle&lt;0\Rightarrow s\lambda\in\mathrm{Neg}(x).\]</span>当然 <span class="math inline">\(s\lambda\ne\alpha_s\)</span>，否则<span class="math inline">\(\lambda=-\alpha_s\)</span> 与 <span class="math inline">\(\lambda\)</span> 是正根矛盾，所以上式说明<span class="math display">\[s\cdot\mathrm{Neg}(sx)\subseteq\mathrm{Neg}(x)\setminus\{\alpha_s\}.\]</span>从而 <span class="math inline">\(\mathrm{Neg}(sx)\)</span>的元素个数严格小于 <span class="math inline">\(\mathrm{Neg}(x)\)</span>。</p><p>重复此过程我们可以取一组 <span class="math inline">\(s_1,\ldots,s_k\)</span> 使得 <span class="math inline">\(y=s_1\cdots s_k\cdot x\)</span> 满足 <span class="math inline">\(\mathrm{Neg}(y)=\emptyset\)</span>，从而 <span class="math inline">\(y\in\overline{\mathcal{D}}\)</span>，这就证明了结论。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-convex" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.7</span>.</span><span class="statement-spah"> </span>Tits 锥 <span class="math inline">\(\mathcal{C}\)</span> 是凸锥。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(x,y\in\mathcal{C}\)</span> 和 <span class="math inline">\(\alpha,\beta\geq0\)</span>，我们需要证明 <span class="math inline">\(z=\alpha x+\beta y\)</span> 也属于 <span class="math inline">\(\mathcal{C}\)</span>。但是 <span class="math display">\[\mathrm{Neg}(z)\subseteq\mathrm{Neg}(x)\cup\mathrm{Neg}(y),\]</span>根据 <a href="#tits-neg-finite" title="定理 1.6">定理 1.6</a> <span class="math inline">\(\mathrm{Neg}(x),\,\mathrm{Neg}(y)\)</span>都有限，所以 <span class="math inline">\(\mathrm{Neg}(z)\)</span>也有限，从而 <span class="math inline">\(z\in\mathcal{C}\)</span>，即<span class="math inline">\(\mathcal{C}\)</span> 是凸锥。<span class="math inline">\(\blacksquare\)</span></p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.8</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathcal{C}=\mathrm{cone}(\Omega)\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(\Omega\supset\Delta^\ast\)</span>，以及根据 <a href="#fund-cone" title="命题 1.4">命题 1.4</a> 有 <span class="math inline">\(\mathrm{cone}(\Delta^\ast)=\overline{\mathcal{D}}\)</span>，所以<span class="math display">\[\mathrm{cone}(\Omega)\supset\mathrm{cone}(\Delta^\ast)=\overline{\mathcal{D}}.\]</span>再结合 <span class="math inline">\(\mathrm{cone}(\Omega)\)</span> 是<span class="math inline">\(W\)</span>- 不变的，所以它包含 <span class="math inline">\(\bigcup_{w\inW}w\overline{\mathcal{D}}=\mathcal{C}\)</span>。</p><p>另一方面 <span class="math inline">\(\mathcal{C}\supset\overline{\mathcal{D}}\supset\Delta^\ast\)</span>，并且<span class="math inline">\(\mathcal{C}\)</span> 也是 <span class="math inline">\(W\)</span>- 不变的，所以 <span class="math display">\[\mathcal{C}\supset\bigcup_{w\inW}w\Delta^\ast=\Omega.\]</span> 而 <a href="#tits-convex" title="推论 1.7">推论 1.7</a> 证明了 <span class="math inline">\(\mathcal{C}\)</span> 是凸锥，所以 <span class="math inline">\(\mathcal{C}\supset\mathrm{cone}(\Omega)\)</span>。<span class="math inline">\(\blacksquare\)</span></p><h1 id="tits-锥的内点">Tits 锥的内点</h1><p>接下来我们来讨论 <span class="math inline">\(\mathcal{C}\)</span>的内点集 <span class="math inline">\(\mathcal{C}^\circ\)</span>。我们将证明 <span class="math inline">\(\mathcal{C}^\circ\)</span>由那些稳定化子群是有限群的点组成： <span class="math display">\[\mathcal{C}^\circ = \{x\in V^\ast \mid|\mathrm{Stab}(x)| &lt; \infty\}.\]</span></p><div id="stabilizer-parabolic-subgroup" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span>对任何 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，记 <span class="math inline">\(J=\{s\in S \mid \langle\alpha_s,\,x\rangle=0\}\)</span>，则 <span class="math inline">\(\mathrm{Stab}(x) = W_J\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个定理的含义是，对原像房间 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 中的一点 <span class="math inline">\(x\)</span>，其稳定化子群 <span class="math inline">\(\mathrm{Stab}(x)\)</span>是一个标准椭圆子群，由那些包含 <span class="math inline">\(x\)</span>的镜子 <span class="math inline">\(\{\alpha_s\in\Delta \mid \langle\alpha_s,\,x\rangle=0\}\)</span> 对应的反射生成。</p></div><p><strong>证明</strong>：</p><p>对任何 <span class="math inline">\(s\in J\)</span> 和 <span class="math inline">\(v\in V\)</span> 我们有 <span class="math display">\[\langle v,\,sx\rangle = \langlesv,\,x\rangle=\langle v-2(v,\alpha_s)\alpha_s,\,x\rangle=\langlev,\,x\rangle-2(v,\alpha_s)\langle \alpha_s,\,x\rangle=\langlev,\,x\rangle.\]</span> 由 <span class="math inline">\(v\)</span>的任意性可得 <span class="math inline">\(sx=x\)</span>，从而 <span class="math inline">\(W_J\subseteq\mathrm{Stab}(x)\)</span>。</p><p>为了证明反向的包含关系，设 <span class="math inline">\(w=s_1\cdotss_k\in\mathrm{Stab}(x)\)</span> 是一个既约表示，我们从最末一个元素 <span class="math inline">\(s_k\)</span> 开始，向左逐个验证它们属于 <span class="math inline">\(J\)</span>。</p><p>记 <span class="math inline">\(w'=s_1\cdots s_{k-1}\)</span>，则<span class="math inline">\(l(ws_k)=l(w')&lt;l(w)\)</span>，于是<span class="math inline">\(w\alpha_k\in\Phi^-\)</span>。我们有 <span class="math display">\[0\geq \langle w\alpha_k,\,x\rangle = \langle\alpha_k,\,wx\rangle = \langle \alpha_k,\,x\rangle\geq0.\]</span>其中第一个不等号是因为 <span class="math inline">\(w\alpha_k\)</span>是负根和 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>。于是上面的不等式中等号都成立，从而<span class="math inline">\(\langle \alpha_k,\,x\rangle=0\)</span>，即<span class="math inline">\(s_k\in J\)</span> 且 <span class="math inline">\(s_kx=x\)</span>。进一步 <span class="math inline">\(w'\)</span> 也满足 <span class="math inline">\(w'x=x\)</span>。对 <span class="math inline">\(w'\)</span> 重复此论证，便得到 <span class="math inline">\(s_1,\ldots,s_k\)</span> 都属于 <span class="math inline">\(J\)</span>，从而定理得证。<span class="math inline">\(\blacksquare\)</span></p><div id="fd-finite-stabilizer" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题2.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，<span class="math inline">\(J\)</span> 的定义如 <a href="#stabilizer-parabolic-subgroup" title="定理 2.1">定理 2.1</a>，则<span class="math inline">\(x\in\mathcal{C}^\circ\)</span> 当且仅当<span class="math inline">\(W_J\)</span> 是有限群。</p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>：思路：如果 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(\mathcal{C}\)</span> 的内点，并且经过 <span class="math inline">\(x\)</span> 的镜面有无穷多个，那么可以在 <span class="math inline">\(x\)</span> 的附近取一点 <span class="math inline">\(z\)</span>，<span class="math inline">\(z\)</span>仍然是 <span class="math inline">\(\mathcal{C}\)</span>的内点，使得这无穷多个镜子都挡在基本区域和 <span class="math inline">\(z\)</span> 之间，从而 <span class="math inline">\(\mathrm{Neg}(z)\)</span> 是无限集，从而 <span class="math inline">\(z\notin\mathcal{C}\)</span>，导致矛盾。</p><p>严格的论证如下：</p><figure><img src="/images/coxeter/WJ.svg" width="300" alt="一个示意图，z 落在所有 \Phi_J 中镜子的背面"><figcaption aria-hidden="true">一个示意图，<span class="math inline">\(z\)</span> 落在所有 <span class="math inline">\(\Phi_J\)</span> 中镜子的背面</figcaption></figure><p>任取 <span class="math inline">\(y\in\mathcal{D}\)</span>。由于 <span class="math inline">\(x\in\mathcal{C}^\circ\)</span>，所以在线段 <span class="math inline">\(\overline{[y, x]}\)</span> 上我们可以朝着 <span class="math inline">\(x\)</span> 的方向延伸一点点，得到点 <span class="math inline">\(z\)</span>，使得 <span class="math inline">\(z\)</span> 仍然位于 <span class="math inline">\(\mathcal{C}^\circ\)</span> 中。<span class="math inline">\(z\)</span> 可以表示为 <span class="math display">\[z=(1-t)x+ty,\quad t&lt;0.\]</span> 于是对所有<span class="math inline">\(s\in J\)</span> 都有 <span class="math inline">\(\langle \alpha_s,\,z\rangle=t\langle\alpha_s,\,y\rangle &lt; 0\)</span>，从而 <span class="math inline">\(\Phi_J^+\subset\mathrm{Neg}(z)\)</span>。如果<span class="math inline">\(W_J\)</span> 是无限群那么 <span class="math inline">\(\Phi_J^+\)</span> 也是无限的，从而 <span class="math inline">\(\mathrm{Neg}(z)\)</span> 是无限集，从而 <span class="math inline">\(z\notin\mathcal{C}^\circ\)</span>，矛盾！</p><p><span class="math inline">\(\Leftarrow\)</span>：反之若 <span class="math inline">\(W_J\)</span> 是有限群，仍然任取 <span class="math inline">\(y\in\mathcal{D}\)</span>。</p><figure><img src="/images/coxeter/WJ2.svg" width="300" alt="y 在 W_J 下的像全部位于镜面 \alpha_s=0 的正侧，故 \langle \alpha_s,\,wy\rangle 对 w\in W_J 总为正"><figcaption aria-hidden="true"><span class="math inline">\(y\)</span> 在<span class="math inline">\(W_J\)</span> 下的像全部位于镜面 <span class="math inline">\(\alpha_s=0\)</span> 的正侧，故 <span class="math inline">\(\langle \alpha_s,\,wy\rangle\)</span> 对 <span class="math inline">\(w\in W_J\)</span> 总为正</figcaption></figure><p>对任何镜面 <span class="math inline">\(s\in S\setminusJ\)</span>，由于 <span class="math inline">\(x\)</span>不属于此镜面，所以 <span class="math inline">\(\langle\alpha_s,\,x\rangle&gt;0\)</span>。</p><p>另一方面对任何 <span class="math inline">\(w\in W_J\)</span>，<a href="/coxeter-groups-root-system#remain-positive-root"><span class="math inline">\(w^{-1}\alpha_s\)</span> 仍然是正根</a>，所以 <span class="math display">\[\langle \alpha_s,\,wy\rangle=\langlew^{-1}\alpha_s,\,y\rangle&gt;0.\]</span> 于是 <span class="math display">\[\delta = \min\left\{\frac{\langle\alpha_s,\,x\rangle}{\langle \alpha_s,\,wy\rangle}\,\middle|\,\alpha_s\in S\setminus J,\, w\in W_J\right\}&gt;0.\]</span>将上面的分母乘到左边然后对 <span class="math inline">\(w\in W_J\)</span>求和，我们有 <span class="math display">\[\delta\cdot\langle\alpha_s,\,\sum_{w\in W_J}wy\rangle\leq \langle \alpha_s,\,x\rangle\cdot|W_J| &lt; 2\langle \alpha_s,\,x\rangle\cdot |W_J|,\quad s\in S\setminusJ.\tag{1}\label{eq:strict}\]</span> 注意这个不等式两边关于 <span class="math inline">\(\alpha_s\)</span> 都是线性的。</p><p>既然对 <span class="math inline">\(s\in S\setminus J\)</span>上面的不等式是严格的，那么对 <span class="math inline">\(s\in J\)</span>又如何呢？这时右边 <span class="math inline">\(\langle\alpha_s,\,x\rangle=0\)</span>。又因为 <span class="math inline">\(\sum_{w\in W_J}wy\)</span> 在 <span class="math inline">\(W_J\)</span> 下保持不变，所以根据 <a href="#stabilizer-parabolic-subgroup" title="定理 2.1">定理 2.1</a> 可得<span class="math inline">\(\langle \alpha_{s},\,\sum_{w\inW_J}wy\rangle=0\)</span>，从而上面的不等式变成了等式（两边都是 0）：<span class="math display">\[0=\delta\cdot\langle \alpha_s,\,\sum_{w\inW_J}wy\rangle= 2\langle \alpha_s,\,x\rangle\cdot |W_J|,\quad s\inJ.\tag{2}\label{eq:equal}\]</span> 对任何 <span class="math inline">\(\lambda\in\Phi^+\setminus\Phi_J^+\)</span>，设<span class="math display">\[\lambda=\sum_{s\in S\setminus J}c_s\alpha_s+ \sum_{t\in J}d_t\alpha_t,\quad c_s,d_t\geq0.\]</span> 其中至少有一项<span class="math inline">\(c_s\)</span> 严格大于 0。将 <span class="math inline">\(\lambda\)</span> 代入 <span class="math inline">\((\ref{eq:strict})\)</span> 中 <span class="math inline">\(\alpha_s\)</span> 的位置，严格不等式仍然成立。即<span class="math display">\[\delta\cdot\langle \lambda,\,\sum_{w\inW_J}wy\rangle&lt; 2\langle \lambda,\,x\rangle\cdot |W_J|.\]</span>注意对 <span class="math inline">\(w\in W_J\)</span>，<span class="math inline">\(w^{-1}\lambda\)</span> 作为 <span class="math inline">\(\lambda\)</span> 和 <span class="math inline">\(\{\alpha_s\mid s\in J\}\)</span>的线性组合仍然是正根，并且不在 <span class="math inline">\(\Phi_J^+\)</span> 中，所以上面的求和中每一项 <span class="math inline">\(\langle \lambda,\,wy\rangle=\langlew^{-1}\lambda,\,y\rangle&gt;0\)</span>，我们可以只取 <span class="math inline">\(w=1\)</span> 的一项，其余全扔掉，得到 <span class="math display">\[\delta\cdot\langle \lambda,\,y\rangle&lt;2\langle \lambda,\,x\rangle\cdot |W_J|.\]</span> 记 <span class="math inline">\(z = 2|W_J|x - \delta y\)</span>，我们得到 <span class="math inline">\(\langle \lambda,\,z\rangle&gt;0\)</span> 对任何<span class="math inline">\(\lambda\in\Phi^+\setminus\Phi_J^+\)</span>成立。</p><p>另一方面对任何 <span class="math inline">\(\mu\in\Phi_J^+\)</span>，由于 <span class="math inline">\(\langle \mu,\,x\rangle=0\)</span>，所以 <span class="math inline">\(\langle \mu,\,z\rangle=-\delta\langle\mu,\,y\rangle&lt;0\)</span>，于是 <span class="math inline">\(\mathrm{Neg}(z)=\Phi_J^+\)</span> 是有限集，从而<span class="math inline">\(z\in\mathcal{C}\)</span>。</p><p>实际上我们有 <span class="math inline">\(z\in\mathcal{C}^\circ\)</span>，这是因为对任何<span class="math inline">\(\lambda\in\Phi\)</span>，<span class="math inline">\(\lambda\)</span> 必然属于 <span class="math inline">\(\pm\Phi^+_J,\pm(\Phi^+\setminus\Phi^+_J)\)</span>之一，而我们已经看到 <span class="math inline">\(\langle\lambda,\,z\rangle\)</span> 总不是 0，所以 <span class="math inline">\(z\)</span> 不落在任何镜面上。设 <span class="math inline">\(z=wv,\,v\in\overline{\mathcal{D}}\)</span>，那么<span class="math display">\[\langle \alpha_s,\,v\rangle=\langlew\alpha_s,\,wv\rangle=\langle w\alpha_s,\,z\rangle\ne0\]</span> 对任何<span class="math inline">\(\alpha_s\in\Delta\)</span> 成立，所以 <span class="math inline">\(v\in\mathcal{D}\subset\mathcal{C}^\circ\)</span>，从而<span class="math inline">\(z=wv\inw\mathcal{D}\subset\mathcal{C}^\circ\)</span>。</p><figure><img src="/images/coxeter/WJ3.svg" width="300" alt="我们证明 z 只落在 \Phi_J 中镜面的背面，从而 z\in\mathcal{C}；并证明 z 不属于任何镜面，从而 z\in\mathcal{C}^\circ"><figcaption aria-hidden="true">我们证明 <span class="math inline">\(z\)</span> 只落在 <span class="math inline">\(\Phi_J\)</span> 中镜面的背面，从而 <span class="math inline">\(z\in\mathcal{C}\)</span>；并证明 <span class="math inline">\(z\)</span> 不属于任何镜面，从而 <span class="math inline">\(z\in\mathcal{C}^\circ\)</span></figcaption></figure><p>现在 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(z\)</span> 和 <span class="math inline">\(y\)</span> 的线性组合 <span class="math inline">\(x = \frac{1}{2|W_J|}(z + \deltay)\)</span>。我们来说明 <span class="math inline">\(x\)</span> 也属于<span class="math inline">\(\mathcal{C}^\circ\)</span>。由于 <span class="math inline">\(z,y\in\mathcal{C}^\circ\)</span>，所以 <span class="math inline">\(\frac{1}{2|W_J|}z,\frac{\delta}{2|W_J|}y\in\mathcal{C}^\circ\)</span>，即存在开集 <span class="math inline">\(A,B\)</span> 满足 <span class="math inline">\(\frac{1}{2|W_J|}z\inA\subset\mathcal{C}^\circ\)</span>，<span class="math inline">\(\frac{\delta}{2|W_J|}y\in B\subset\mathcal{C}^\circ\)</span>，于是 <span class="math inline">\(x\inA+B=\cup_{p\in B}(A+p)\)</span>，这是一组开集的并，所以 <span class="math inline">\(x\in\mathcal{C}^\circ\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-int-finite-stabilizer" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(y\in\mathcal{C}\)</span>，则 <span class="math inline">\(y\in\mathcal{C}^\circ\)</span> 当且仅当 <span class="math inline">\(\mathrm{Stab}(y)\)</span> 是有限群。</p></div><p><strong>证明</strong>：<span class="math inline">\(y\)</span>可以写成 <span class="math inline">\(y=wx\,(w\inW,\,x\in\overline{\mathcal{D}})\)</span> 的形式，从而 <span class="math inline">\({\rm Stab}(y)=w{\rmStab}(x)w^{-1}\)</span>，二者同为有限群或者无限群；而且 <span class="math inline">\(x,y\)</span> 同时属于或者同时不属于 <span class="math inline">\(\mathcal{C}^\circ\)</span>。由 <a href="#fd-finite-stabilizer" title="命题 2.2">命题 2.2</a>即得结论。<span class="math inline">\(\blacksquare\)</span></p><h1 id="tits-锥的对偶锥">Tits 锥的对偶锥</h1><p>这一节来讨论 Tits 锥的对偶锥。研究对偶锥对理解 Tits锥本身的结构也很有帮助。</p><div id="dual-cone" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(C\)</span> 是 <span class="math inline">\(V\)</span> 中的一个锥，定义 <span class="math inline">\(C\)</span> 的对偶锥 <span class="math inline">\(C^\ast\in V^\ast\)</span> 为 <span class="math display">\[C^\ast = \{f\in V^\ast\mid f(v)\geq0,\ \forallv\in C\}.\]</span> 即 <span class="math inline">\(C^\ast\)</span>是对偶空间中那些在 <span class="math inline">\(C\)</span>上取值均非负的线性泛函组成的集合。</p></div><p>不难看出 <span class="math inline">\(C^\ast\)</span> 也构成 <span class="math inline">\(V^\ast\)</span>中的一个锥，所以我们又可以取其对偶锥 <span class="math inline">\(C^{\ast\ast}\subset V\)</span>。</p><div id="dual-dual-cone" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(C^{\ast\ast} = \overline{C}\)</span>。其中 <span class="math inline">\(\overline{C}\)</span> 是 <span class="math inline">\(C\)</span> 的拓扑闭包。</p></div><p><strong>证明</strong>：显然 <span class="math inline">\(\overline{C}\subseteqC^{\ast\ast}\)</span>，只要论证 <span class="math inline">\(C^{\ast\ast}\subseteq \overline{C}\)</span> 即可。</p><p>对任何 <span class="math inline">\(x\notin\overline{C}\)</span>，根据凸集分离定理，存在超平面<span class="math inline">\(H\)</span>，其法向量 <span class="math inline">\(n\)</span> 满足 <span class="math inline">\((n,C)\geq 0\)</span> 但是 <span class="math inline">\((n,x) &lt; 0\)</span>。于是线性泛函 <span class="math inline">\((n,\cdot)\in C^\ast\)</span> 且由于 <span class="math inline">\((n,x)&lt;0\)</span> 从而 <span class="math inline">\(x\notin C^{\ast\ast}\)</span>。反向包含得证。<span class="math inline">\(\blacksquare\)</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>对不熟悉凸集分离定理的读者，下面是一点细节补充：设 <span class="math inline">\(u\in\overline{C}\)</span> 是 <span class="math inline">\(\overline{C}\)</span> 中与 <span class="math inline">\(x\)</span> 距离最近的点：<span class="math inline">\(|x-u|=\inf_{z\in\overline{C}}|x-z|\)</span>。对任何 <span class="math inline">\(z\in\overline{C}\)</span>，考虑线段 <span class="math inline">\([u,z]\)</span> 上的点与 <span class="math inline">\(x\)</span> 的距离 <span class="math display">\[f(t) = |u + t(z-u) - x|,\quad 0\leqt\leq1.\]</span> <span class="math inline">\(f\)</span> 在 <span class="math inline">\(t=0\)</span> 时取得最小值： <span class="math display">\[ |u-x|^2 \leq |u-x|^2 + 2t(u-x, z-u) +t^2|z-u|^2.\]</span> 即 <span class="math display">\[0\leqt\cdot\left(2(u-x,z-u) + t|z-u|^2\right)\leq 2(u-x,z-u) +t|z-u|^2.\]</span> 令 <span class="math inline">\(t\to0^+\)</span> 可得<span class="math inline">\((u-x,z-u)\geq 0\)</span>。 这个式子对任何<span class="math inline">\(z\in\overline{C}\)</span> 成立，特别地取<span class="math inline">\(z=tu\)</span> 代入有 <span class="math display">\[(1-t)\cdot(u-x, u)\geq0.\]</span> 上式对任何<span class="math inline">\(t\geq0\)</span> 成立必须只能是 <span class="math inline">\((u-x, u)=0\)</span>。于是不等式 <span class="math display">\[(u-x,z-u)\geq 0\]</span> 可以改写为 <span class="math display">\[(u-x,z)\geq0\]</span> 对任何 <span class="math inline">\(z\in\overline{C}\)</span> 成立。而 <span class="math inline">\((u-x,x)=-(u-x,u-x)&lt;0\)</span>。所以 <span class="math inline">\(u-x\)</span> 即为所求的法向量 <span class="math inline">\(n\)</span>。</p></div><p>回到 Tits 锥 <span class="math inline">\(\mathcal{C}\)</span>的讨论上来。由于 <span class="math inline">\(\mathcal{C}\inV^\ast\)</span> 所以 <span class="math inline">\(\mathcal{C}^\ast\inV\)</span>。我们有如下定理：</p><div id="tits-cone-dual" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.3</span>.</span><span class="statement-spah"> </span>Tits 锥 <span class="math inline">\(\mathcal{C}\)</span> 的对偶锥为 <span class="math inline">\(\mathcal{C}^\ast=\bigcap\limits_{w\inW}w(\mathrm{cone}(\Delta))\)</span>。</p></div><p>显然 <span class="math inline">\(\mathrm{cone}(\Delta)\)</span> 是<span class="math inline">\(V\)</span> 中的一个闭凸锥，它在 <span class="math inline">\(V^\ast\)</span> 中的对偶锥正是基本区域的闭包 <span class="math inline">\(\overline{\mathcal{D}}\)</span>： <span class="math display">\[\overline{\mathcal{D}}= \{x\in V^\ast\mid \langle\lambda,\,x\rangle\geq0,\ \forall\lambda\in\mathrm{cone}(\Delta)\}.\]</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>由定理结论可见 Tits 锥的对偶锥同样是 <span class="math inline">\(W\)</span>- 不变的。</p></div><p><strong>证明</strong>：</p><p><span class="math display">\[\begin{align}\mathcal{C}^\ast &amp;=\{v\in V \mid \langle v,\,x\rangle\geq 0 \text{for all } x \in \mathcal{C}\}\\&amp;= \{v\in V \mid \langle v,\,wz\rangle\geq0 \text{ for all }z\in\overline{\mathcal{D}}\text{ and } w \in W\}\\&amp;= \{v\in V \mid \langle w^{-1}v,\,z\rangle\geq0 \text{ for all }v\in\overline{\mathcal{D}}\text{ and } w \in W\}\\&amp;= \{v\in V \mid w^{-1}v\in (\overline{\mathcal{D}})^\ast \text{ forall } w \in W\}\\&amp;\stackrel{(\ast)}{=} \{v\in V \mid w^{-1}v\in \mathrm{cone}(\Delta)\text{ for all } w \in W\}\\&amp;= \{v\in V \mid v\in w(\mathrm{cone}(\Delta)) \text{ for all } w\in W\}.\end{align}\]</span></p><p>其中 <span class="math inline">\((\ast)\)</span> 一步正是将 <a href="#dual-dual-cone" title="定理 3.2">定理 3.2</a> 应用在 <span class="math inline">\(C=\mathrm{cone}(\Delta),\,C^\ast=\overline{\mathcal{D}}\)</span>上得到的。注意我们使用了 <span class="math inline">\(\mathrm{cone}(\Delta)\)</span> 是闭集这一点：<span class="math inline">\(\mathrm{cone}(\Delta)=\overline{\mathrm{cone}(\Delta)}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-cone-dual-pointed" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论3.4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathcal{C}^\ast\)</span> 是点锥：<span class="math inline">\(\mathcal{C}^\ast\cap-\mathcal{C}^\ast=\{0\}\)</span>。</p></div><p><strong>证明</strong>：根据 <a href="#tits-cone-dual" title="定理 3.3">定理 3.3</a> 有 <span class="math inline">\(\mathcal{C}^\ast\subset\mathrm{cone}(\Delta)\)</span>，但显然<span class="math inline">\(\mathrm{cone}(\Delta)\cap-\mathrm{cone}(\Delta)=\{0\}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>虽然我们得到了上面关于 <span class="math inline">\(\mathcal{C}^\ast\)</span>的刻画，但是它并不好用。我们下面用内积的形式给出 <span class="math inline">\(\mathcal{C}^\ast\)</span> 的一个更好的刻画。</p><div id="dual-cone-dot-neg" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.5</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(v\in\mathrm{cone}(\Delta)\)</span> 满足对任何<span class="math inline">\(\alpha_s\in\Delta\)</span> 有 <span class="math inline">\((v,\alpha_s)\leq0\)</span>，则 <span class="math inline">\(v\in\mathcal{C}^\ast\)</span>。</p></div><p><strong>证明</strong>：只要证明对任何 <span class="math inline">\(w\)</span> 都有 <span class="math inline">\(wv\in\mathrm{cone}(\Delta)\)</span> 即可。对 <span class="math inline">\(l(w)\)</span> 归纳：<span class="math inline">\(l(w)=0\)</span> 的情形是已知，假设结论对小于 <span class="math inline">\(l(w)\)</span> 都成立，对 <span class="math inline">\(l(w)\)</span> 的情形设 <span class="math inline">\(w=w's\)</span>，其中 <span class="math inline">\(l(w')&lt;l(w)\)</span>，则 <span class="math inline">\(w'\alpha_s\in\Phi^+\)</span>。于是</p><p><span class="math display">\[\begin{align}wv &amp;= w'sv\\&amp;=w'(v - 2(v,\alpha_s)\alpha_s)\\&amp;=w'v - 2(v,\alpha_s)w'\alpha_s.\end{align}\]</span></p><p>根据归纳假设 <span class="math inline">\(w'v\in\mathrm{cone}(\Delta)\)</span>，再结合<span class="math inline">\(w'\alpha_s\in\Phi^+\subset\mathrm{cone}(\Delta)\)</span>，所以结论成立。<span class="math inline">\(\blacksquare\)</span></p><div id="dual-cone-nonspace" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.6</span>.</span><span class="statement-spah"> </span>对任何 <span class="math inline">\(u,v\in\mathcal{C}^\ast\)</span> 有 <span class="math inline">\((u,v)\leq 0\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>我是在与 <a href="https://www.maths.usyd.edu.au/u/bobh/">BobHowlett</a> 教授的邮件交流中学到这个结论的。这个证明我相信改进自 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(\Delta\)</span> 构成 <span class="math inline">\(V\)</span> 的一组基，所以任何 <span class="math inline">\(v\in V\)</span> 可以表示为 <span class="math inline">\(\Delta\)</span> 的线性组合：<span class="math inline">\(v = \sum_{s\in S}c_s\alpha_s\)</span>。定义 <span class="math inline">\(S(v)=\sum_{s\in S}c_s\)</span>为所有系数的和。特别地，当 <span class="math inline">\(v\in\mathcal{C}^\ast\subset\mathrm{cone}(\Delta)\)</span>时，每个 <span class="math inline">\(c_s\)</span> 都是非负的，所以 <span class="math inline">\(S(v)\geq0\)</span>。</p><p>用反证法，设 <span class="math inline">\(u,v\in\mathcal{C}^\ast\)</span> 满足 <span class="math inline">\((u,v)&gt;0\)</span>，不妨设 <span class="math inline">\((u,v)=1\)</span>。记 <span class="math inline">\(n=|S|\)</span> 和 <span class="math inline">\(M=S(u)\)</span>。定义</p><p><span class="math display">\[X=\{x\in\mathcal{C}^\ast\mid S(x)\leqS(v) \text{ and $(z,x)\geq1$ for some $z\in\mathcal{C}^\ast$ with$S(z)\leq M$}\}.\]</span></p><p>显然 <span class="math inline">\(v\in X\)</span>。</p><p>记 <span class="math inline">\(\epsilon=2/(nM)\)</span>，我们将证明对任何 <span class="math inline">\(x\in X\)</span>，都存在 <span class="math inline">\(y\in X\)</span> 使得 <span class="math inline">\(S(y)\leq S(x)-\epsilon\)</span>。</p><p>对 <span class="math inline">\(x\in X\)</span>，设 <span class="math inline">\(z=\sum_{s\inS}z_s\alpha_s\in\mathcal{C}^\ast\)</span> 满足 <span class="math inline">\(S(z)\leq M\)</span> 和 <span class="math inline">\((z,x)\geq1\)</span>，则 <span class="math display">\[(z,x)=\sum_{s\in S}z_s(\alpha_s,x)\geq1.\]</span> 所以必有某个 <span class="math inline">\(\alpha_s\)</span> 使得 <span class="math inline">\(z_s(\alpha_s,x)\geq 1/n\)</span>。由于 <span class="math inline">\(z_s\leq S(z)\leq M\)</span>，我们有 <span class="math inline">\((\alpha_s,x)\geq 1/(nz_s)\geq1/(nM)=\epsilon/2\)</span>。</p><p>考察 <span class="math display">\[y=sx=x-2(x,\alpha_s)\alpha_s.\]</span> 由于 <span class="math inline">\(x\in\mathcal{C}^\ast\)</span>以及 <span class="math inline">\(\mathcal{C}^\ast\)</span> 是 <span class="math inline">\(W-\)</span> 不变的所以 <span class="math inline">\(y\in\mathcal{C}^\ast\)</span>。又注意到 <span class="math inline">\(S(y)=S(x)-2(x,\alpha_s)\leqS(x)-\epsilon\)</span>，所以要证明 <span class="math inline">\(y\)</span> 符合要求，只要再找到某个 <span class="math inline">\(z'\in\mathcal{C}^\ast\)</span> 满足 <span class="math inline">\(S(z')\leq M\)</span> 和 <span class="math inline">\((z',y)\geq1\)</span> 即可。</p><p>如果 <span class="math inline">\((z,\alpha_s)&lt;0\)</span>，那么<span class="math inline">\(z'=z\)</span> 就满足要求，因为这时 <span class="math display">\[(z,y)=(z,x-2(x,\alpha_s)\alpha_s)=(z,x)-2\underbrace{(x,\alpha_s)}_{\geq\epsilon/2}\underbrace{(z,\alpha_s)}_{&lt;0}&gt;(z,x)\geq1.\]</span></p><p>反之如果 <span class="math inline">\((z,\alpha_s)&gt;0\)</span>，我们来验证 <span class="math inline">\(z'=sz=z-2(z,\alpha_s)\alpha_s\)</span>满足要求：由于 <span class="math inline">\(z\in\mathcal{C}^\ast\)</span>所以 <span class="math inline">\(z'\in\mathcal{C}^\ast\)</span>，并且 <span class="math inline">\(S(z')=S(z)-2(z,\alpha_s)&lt;S(z)\)</span>，以及<span class="math display">\[(z', y)=(sz,sx)=(z,x)\geq1.\]</span></p><p>所以从 <span class="math inline">\(v=x\)</span>开始出发，我们经过有限次后取到 <span class="math inline">\(y\inX\)</span> 使得 <span class="math inline">\(S(y)\)</span> 是负数，这与<span class="math inline">\(y\in\mathcal{C}^\ast\)</span> 矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Howlett-note" class="csl-entry" role="listitem">Howlett, Robert B. 1996. <span>“Introduction to Coxeter Groups.”</span><a href="https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html">https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html</a>.</div><div id="ref-Maxwell82" class="csl-entry" role="listitem">Maxwell, George. 1982. <span>“Sphere Packings and Hyperbolic ReflectionGroups.”</span> <em>Journal of Algebra</em> 79 (1): 78–97. <a href="https://doi.org/10.1016/0021-8693(82)90318-0">https://doi.org/10.1016/0021-8693(82)90318-0</a>.</div></div>]]></content>
      
      
      <categories>
          
          <category> Coxeter Groups </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（二）：根系</title>
      <link href="coxeter-groups-root-system/"/>
      <url>coxeter-groups-root-system/</url>
      
        <content type="html"><![CDATA[<p>我们先回顾 <a href="/coxeter-groups-geometric-realization/">第一篇笔记</a>的主要内容。</p><p>设 <span class="math inline">\((W,S)\)</span> 是一个 Coxeter 系。在<a href="/coxeter-groups-geometric-realization/">上文</a>中，我们按照如下方式，将 <span class="math inline">\((W,S)\)</span>表示为一个实向量空间 <span class="math inline">\(V\)</span>上的正交反射群：</p><ol type="1"><li>取一个 <span class="math inline">\(n=|S|\)</span> 维实向量空间 <span class="math inline">\(V\)</span>，<span class="math inline">\(V\)</span>的一组基为 <span class="math inline">\(\{\alpha_s\mid s\inS\}\)</span>；</li><li>规定了 <span class="math inline">\(V\)</span> 上的内积 <span class="math inline">\((\cdot,\cdot)\)</span>；</li><li>对每个生成元 <span class="math inline">\(s\in S\)</span>，规定 <span class="math inline">\(s\)</span> 在 <span class="math inline">\(V\)</span> 上的作用为关于 <span class="math inline">\(\alpha_s\)</span> 的反射 <span class="math inline">\(\rho_s\)</span>；</li><li>我们证明了 <span class="math inline">\(\rho\)</span> 是从 <span class="math inline">\(W\to\mathrm{O}(V)\)</span> 的群同态。</li></ol><p>但是我们还有一个未完成的工作：证明 <span class="math inline">\(\rho\)</span>是同构。本文会完成它。此外我还会介绍关于根系的一些知识。如果你直接翻到本文后面，会发现我罗列了很多关于根系的推论。这并不是我在故故意掉书袋，这些推论每一条后面都会用到。不过读者初次阅读时只要大致浏览它们即可，等后面用到时再跳转过来查看细节。</p><span id="more"></span><h1 id="根系">根系</h1><p>记 <span class="math inline">\(\Delta=\{\alpha_s\mid s\inS\}\)</span> 是如前所取的 <span class="math inline">\(V\)</span>的一组基。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>我们称集合 <span class="math display">\[\Phi=W\cdot\Delta=\{w\alpha_s\mid w\in W, \,\alpha_s\in\Delta\}\]</span> 为 <span class="math inline">\((W,S)\)</span> 的<strong>根系</strong>，任何 <span class="math inline">\(\lambda\in\Phi\)</span>叫做根向量，简称为<strong>根</strong>。<span class="math inline">\(\Delta\)</span> 叫做<strong>单根系</strong>，<span class="math inline">\(\Delta\)</span>中的元素叫做<strong>单根</strong>。</p></div><p>一个简单观察是，任何 <span class="math inline">\(\lambda\in\Phi\)</span> 都是内积 <span class="math inline">\((\cdot,\cdot)\)</span> 下的单位向量：设 <span class="math inline">\(\lambda=w\alpha_s,\,w\inW,\alpha_s\in\Delta\)</span>。由于 <span class="math inline">\(w\)</span> 保持 <span class="math inline">\((\cdot,\cdot)\)</span>，所以 <span class="math display">\[(\lambda,\lambda) =(w\alpha_s,w\alpha_s)=(\alpha_s,\alpha_s)=1.\]</span></p><p>紧跟着的另一个简单观察是，如果两个根 <span class="math inline">\(\alpha,\beta\in\Phi\)</span> 共线则必有 <span class="math inline">\(\alpha=\pm\beta\)</span>。这是因为设 <span class="math inline">\(\alpha=k\beta,\,k\in\mathbb{R}\)</span>，利用<span class="math inline">\(\alpha,\beta\)</span> 都是单位向量可得 <span class="math display">\[1=(\alpha,\alpha)=k^2(\beta,\beta)=k^2.\]</span>所以 <span class="math inline">\(k\in\pm1\)</span>。</p><p>由于 <span class="math inline">\(\Delta\)</span> 构成 <span class="math inline">\(V\)</span> 的一组基，所以 <span class="math inline">\(\Phi\)</span> 中任何根 <span class="math inline">\(\lambda\)</span> 都是单根的线性组合： <span class="math display">\[\lambda = \sum_{s\in S}c_s\alpha_s,\quadc_s\in\mathbb{R}.\]</span> 如果上面的所有系数 <span class="math inline">\(c_s\)</span> 都非负，就称 <span class="math inline">\(\lambda\)</span>是<strong>正根</strong>；若所有系数 <span class="math inline">\(c_s\)</span> 都非正，就称 <span class="math inline">\(\lambda\)</span>是<strong>负根</strong>。正根和负根组成的集合分别记作 <span class="math inline">\(\Phi^+\)</span> 和 <span class="math inline">\(\Phi^-\)</span>。显然 <span class="math inline">\(\Phi^+\cap\Phi^-=\emptyset\)</span>。</p><p>这就引出了一个问题：每个根都必然是正根或者负根吗？即是否有 <span class="math inline">\(\Phi=\Phi^+\cup\Phi^-\)</span>成立？虽然答案是肯定的，但这并不显然。为此我们需要一个关键引理。这个引理的证明有点长，但是它非常重要，Coxeter群的几乎所有性质的证明多少都会用到它。在引入它之前，我们需要做一点小小的准备。</p><p>设 <span class="math inline">\(I\subseteq S\)</span> 是 <span class="math inline">\(S\)</span> 的子集，<span class="math inline">\(I\)</span> 中的生成元在 <span class="math inline">\((W,S)\)</span> 中生成一个子群 <span class="math inline">\(W_I \leqslant (W,S)\)</span>，<span class="math inline">\(W_I\)</span> 叫做<strong>标准椭圆子群</strong>。记<span class="math inline">\(l_I(\cdot)\)</span> 是 <span class="math inline">\(W_I\)</span> 上的长度函数，则显然对任何 <span class="math inline">\(w\in W_I\)</span> 有 <span class="math inline">\(l(w)\leq l_I(w)\)</span> 成立（因为 <span class="math inline">\(W_I\)</span> 中的既约表示放到 <span class="math inline">\(W\)</span> 里可能进一步缩短）。我们后面会看到<span class="math inline">\(l_I=l\mid_{W_I}\)</span>，但现在我们暂时还证明不了它。</p><p>现在请出我们的重要引理：</p><div id="key-lemma" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(s\in S,\, w\in W\)</span>，则</p><ol type="1"><li><span class="math inline">\(l(ws) &gt; l(w)\)</span> 当且仅当 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>。</li><li><span class="math inline">\(l(ws) &lt; l(w)\)</span> 当且仅当 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>。</li></ol></div><p><strong>证明</strong>：这里 1 和 2 是等价的：如果 1 成立，则</p><p><span class="math display">\[\begin{align*}l(ws)&lt;l(w)&amp;\Leftrightarrow l((ws)s) &gt; l(ws)\\&amp;\Leftrightarrow ws(\alpha_s)\in\Phi^+\\&amp;\Leftrightarrow w(-\alpha_s)\in\Phi^+\\&amp;\Leftrightarrow w\alpha_s\in\Phi^-.\end{align*}\]</span></p><p>所以只需要证明 1 即可。</p><p>我们先证明充分性：若 <span class="math inline">\(l(ws)&gt;l(w)\)</span> 则 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>。</p><p>对 <span class="math inline">\(l(w)\)</span> 归纳：<span class="math inline">\(l(w)=0\)</span> 时 <span class="math inline">\(w=1\)</span>，结论显然成立。下面设结论对所有长度小于<span class="math inline">\(l(w)\)</span> 的元素成立。</p><p>我们总是可以取 <span class="math inline">\(t\in S\)</span> 使得 <span class="math inline">\(l(wt)&lt;l(w)\)</span>，比如 <span class="math inline">\(t\)</span> 取为 <span class="math inline">\(w\)</span> 的某个既约表达式的最后一项。显然 <span class="math inline">\(t\ne s\)</span>，因为 <span class="math inline">\(l(ws)&gt;l(w)\)</span>。令 <span class="math inline">\(I=\{s,t\}\)</span>，定义 <span class="math display">\[A = \{(x,x_I)\in W\times W_I\midw=xx_I,\,l(w)=l(x)+l_I(x_I)\}.\]</span> 由于 <span class="math inline">\((wt,t)\in A\)</span> 所以 <span class="math inline">\(A\)</span> 非空。取 <span class="math inline">\((v,v_I)\in A\)</span> 使得 <span class="math inline">\(l(v)\)</span> 是最小的，则 <span class="math display">\[l(v)\leq l(wt)=l(w)-1.\]</span> 我们断言对任何<span class="math inline">\(u\in I\)</span> 都有 <span class="math inline">\(l(vu)&gt;l(v)\)</span>。若不然，则 <span class="math inline">\(l(vu)=l(v)-1\)</span>，于是 <span class="math display">\[\begin{align*}l(w)&amp;=l(vu\cdot uv_I)\leq l(vu) + l(uv_I) = (l(v) -1) + l(uv_I)\\&amp;\leq (l(v) -1) + l_I(uv_I)\\&amp;\leq (l(v) -1) + (l_I(v_I) + 1)\\&amp; = l(v) + l_I(v_I)=l(w).\end{align*}\]</span> 于是所有的不等号都是等式，从而 <span class="math inline">\((vu,uv_I)\in A\)</span>，但这与 <span class="math inline">\((v,v_I)\)</span> 的选择矛盾。所以不论 <span class="math inline">\(u=s\)</span> 或是 <span class="math inline">\(u=t\)</span> 都有 <span class="math inline">\(l(vu)&gt;l(v)\)</span>。</p><p>由于 <span class="math inline">\(l(v)\leq l(w)-1\)</span>所以根据归纳假设 <span class="math inline">\(v\alpha_s,\,v\alpha_t\)</span>都是正根。如果我们能够证明 <span class="math inline">\(v_I\alpha_s\)</span> 是 <span class="math inline">\(\alpha_s\)</span> 和 <span class="math inline">\(\alpha_t\)</span> 的非负线性组合：<span class="math display">\[v_I\alpha_s = a\alpha_s + b\alpha_t,\quada,\,b\geq0.\]</span> 则 <span class="math display">\[w\alpha_s=vv_I\alpha_s=v(a\alpha_s +b\alpha_t)=av\alpha_s + bv\alpha_t\in\Phi^+.\]</span>这就证明了结论。</p><p>首先注意到 <span class="math inline">\(v_I\in W_I\)</span>的任何既约表示都是 <span class="math inline">\(s,t\)</span>的交错乘积，而且不能以 <span class="math inline">\(s\)</span> 结尾，否则<span class="math inline">\(l_I(v_Is)=l_I(v_I)-1\)</span>，从而 <span class="math display">\[l(ws)=l(vv_Is)\leq l(v) + l(v_Is)\leql(v)+l_I(v_Is)=l(v)+l_I(v_I)-1=l(w)-1.\]</span> 这与 <span class="math inline">\(l(ws) &gt; l(w)\)</span> 矛盾！</p><p>于是 <span class="math inline">\(v_I\)</span> 形如 <span class="math inline">\(v_I=st\cdots t\)</span> 或者 <span class="math inline">\(v_I=ts\cdots t\)</span>，问题归结为分析这样的<span class="math inline">\(v_I\)</span> 在 <span class="math inline">\(\alpha_s\)</span> 上的作用。这个我们已经在 <a href="/coxeter-groups-geometric-realization#rank2-roots">前一篇文章中计算过了</a>：</p><ol type="1"><li><p><span class="math inline">\(m=m_{s,t}&lt;\infty\)</span>时，<span class="math display">\[\alpha_s\xrightarrow{\ t\ }\dfrac{\sin\theta}{\sin\theta}\alpha_s+\dfrac{\sin2\theta}{\sin\theta}\alpha_t\xrightarrow{\ s\ }\dfrac{\sin3\theta}{\sin\theta}\alpha_s+\dfrac{\sin2\theta}{\sin\theta}\alpha_t\xrightarrow{\ t\ }\cdots\]</span> 其中<span class="math inline">\(\theta=\pi/m\)</span>。这个链的第 <span class="math inline">\(k\)</span> 项形如 <span class="math display">\[\begin{cases}\dfrac{\sin k\theta}{\sin\theta}\alpha_s + \dfrac{\sin(k-1)\theta}{\sin\theta}\alpha_t, &amp; \text{$k$ odd},\\\newline\dfrac{\sin (k-1)\theta}{\sin\theta}\alpha_s + \dfrac{\sink\theta}{\sin\theta}\alpha_t, &amp; \text{$k$ even}.\end{cases}\]</span> 看起来并不是每一项都是 <span class="math inline">\(\alpha_s,\alpha_t\)</span>的非负线性组合，但是它的前 <span class="math inline">\(m\)</span>项确实都是 <span class="math inline">\(\alpha_s,\alpha_t\)</span>的非负线性组合，这就足够了：由于 <span class="math inline">\(v_I\)</span> 的任何既约表示不能以 <span class="math inline">\(s\)</span> 结尾，所以 <span class="math inline">\(v_I\)</span> 可能的取值是二面体群 <span class="math inline">\(D_m\)</span> 中所有长度小于 <span class="math inline">\(m\)</span> 且以 <span class="math inline">\(t\)</span> 结尾的那些元素： <span class="math display">\[1,\ t,\ st,\ \ldots,\ \overbrace{\ast\cdotsst}^{m-1},\]</span> 这些元素作用在 <span class="math inline">\(\alpha_s\)</span> 上正好给出序列的前 <span class="math inline">\(m\)</span> 项。</p><p>为什么 <span class="math inline">\(v_I\)</span> 的长度不能等于 <span class="math inline">\(m\)</span>？因为根据辫关系 <span class="math display">\[\overbrace{sts\cdots}^{m_{s,t}}=\overbrace{tst\cdots}^{m_{s,t}}.\]</span>即 <span class="math inline">\(v_I\)</span> 会等于以 <span class="math inline">\(s\)</span> 结尾的另一个既约表示，与 <span class="math inline">\(v_I\)</span> 的任何既约表示不能以 <span class="math inline">\(s\)</span> 结尾矛盾。</p></li></ol><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>以 <span class="math inline">\(m=5\)</span> 为例，所有 <span class="math inline">\(m\)</span> 个正根都位于 <span class="math inline">\(\alpha_s,\alpha_t\)</span> 张成的楔形区域内：</p><figure><img src="/images/coxeter/finite2d.svg" width="400" alt="m=5 的例子"><figcaption aria-hidden="true"><span class="math inline">\(m=5\)</span>的例子</figcaption></figure><p>从 <span class="math inline">\(\alpha_s\)</span>一侧开始，这些正根形如 <span class="math display">\[\dfrac{\sink\theta}{\sin\theta}\alpha_s+\dfrac{\sin(k-1)\theta}{\sin\theta}\alpha_t,\quad k=1,2,\ldots,m.\]</span> 从 <span class="math inline">\(\alpha_t\)</span> 一侧开始，它们形如 <span class="math display">\[\dfrac{\sin(k-1)\theta}{\sin\theta}\alpha_s+\dfrac{\sink\theta}{\sin\theta}\alpha_t,\quad k=1,2,\ldots,m.\]</span> 当 <span class="math inline">\(k\)</span> 跑遍 <span class="math inline">\(1,\ldots,m\)</span> 时，第一个序列从 <span class="math inline">\(\alpha_s\)</span> 开始过渡到 <span class="math inline">\(\alpha_t\)</span>，第二个序列从 <span class="math inline">\(\alpha_t\)</span> 开始过渡到 <span class="math inline">\(\alpha_s\)</span>。它们最接近的位置是在 <span class="math inline">\(k=\lfloor(m+1)/2\rfloor\)</span> 处（<span class="math inline">\(m\)</span> 为奇数时重合）。这两个序列的前 <span class="math inline">\(\lfloor(m+1)/2\rfloor\)</span>项合起来正好给出全部 <span class="math inline">\(m\)</span> 个正根。这<span class="math inline">\(m\)</span> 个正根可以通过将 <span class="math inline">\(1,t,st,\ldots,\overbrace{\ast\cdotsst}^{m-1}\)</span> 这 <span class="math inline">\(m\)</span>个元素作用在 <span class="math inline">\(\alpha_s\)</span> 上得到。</p></div><ol start="2" type="1"><li><span class="math inline">\(m=m_{s,t}=\infty\)</span> 时，仍然记<span class="math inline">\(\cosh\theta=a_{s,t},\,\theta\geq0\)</span>，则<span class="math display">\[\alpha_s\xrightarrow{\ t\ }\dfrac{\sinh\theta}{\sinh\theta}\alpha_s+\dfrac{\sinh2\theta}{\sinh\theta}\alpha_t\xrightarrow{\ s\ }\dfrac{\sinh3\theta}{\sinh\theta}\alpha_s+\dfrac{\sinh2\theta}{\sinh\theta}\alpha_t\xrightarrow{\ t\ }\cdots\]</span>每一项都是 <span class="math inline">\(\alpha_s,\alpha_t\)</span>的非负线性组合。</li></ol><p>当 <span class="math inline">\(\theta=0\)</span> 时，<span class="math inline">\(W_{s,t}\)</span>是一维直线上两个平行镜面生成的（仿射）反射群（包含了平移），它可以处理成二维平面上的线性反射群：</p><p><img src="/images/coxeter/affine2d.svg" class="fig" width="500"></p><p>当 <span class="math inline">\(\theta&gt;0\)</span> 时，<span class="math inline">\(W_{s,t}\)</span>是双曲空间中两个超平行的镜面生成的双曲反射群，它也可以处理成二维平面上的线性反射群：</p><p><img src="/images/coxeter/hyperbolic2d.svg" class="fig" width="400"></p><p>必要性的证明：</p><p>我们要证明若 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>则 <span class="math inline">\(l(ws)&gt;l(w)\)</span>。若不然，则 <span class="math inline">\(l(w)=l(wss)&gt;l(ws)\)</span>，从而由充分性的证明知道<span class="math inline">\(ws\alpha_s\in\Phi^+\)</span>，即 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>，矛盾！至此关键引理得证。<span class="math inline">\(\blacksquare\)</span></p><p>从 <a href="#key-lemma" title="引理 1.2">引理 1.2</a>出发我们可以得到许多重要推论：</p><div id="faithful" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(w\in W\)</span> 满足对任何 <span class="math inline">\(v\in V\)</span> 有 <span class="math inline">\(wv=v\)</span> 则 <span class="math inline">\(w=1\)</span>。即表示 <span class="math inline">\(\rho: W\to{\rm GL}(V)\)</span> 是忠实的。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(w\ne1\)</span>，则存在 <span class="math inline">\(s\in S\)</span> 使得<span class="math inline">\(l(ws)&lt;l(w)\)</span>，从而 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>，这与 <span class="math inline">\(w\alpha_s=\alpha_s\)</span> 矛盾。<span class="math inline">\(\blacksquare\)</span></p><div id="pos-neg" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.4</span>.</span><span class="statement-spah"></span>每个根不是正根就是负根，即 <span class="math inline">\(\Phi=\Phi^+\cup\Phi^-\)</span>。</p></div><p><strong>证明</strong>：由 <span class="math inline">\(\Phi\)</span>的定义任何 <span class="math inline">\(\lambda\in\Phi\)</span>可以表示为 <span class="math inline">\(\lambda=w\alpha_s\)</span>。若<span class="math inline">\(l(ws)&gt;l(w)\)</span> 则 <span class="math inline">\(\lambda\in\Phi^+\)</span>，否则 <span class="math inline">\(\lambda\in\Phi^-\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="simple-ref" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.5</span>.</span><span class="statement-spah"> </span>任何单反射 <span class="math inline">\(s\)</span> 置换 <span class="math inline">\(\Phi^+\setminus\{\alpha_s\}\)</span>中的正根，同时将 <span class="math inline">\(\alpha_s\)</span> 变为<span class="math inline">\(-\alpha_s\)</span>。</p></div><p><strong>证明</strong>：这是因为对任何正根 <span class="math inline">\(\lambda\ne\alpha_s\in\Phi^+\)</span>，<span class="math inline">\(\lambda\)</span> 不可能与 <span class="math inline">\(\alpha_s\)</span> 共线，所以其作为单根的线性组合<span class="math inline">\(\lambda=\sum_{t\in S}c_t\alpha_t\)</span>中必有某个 <span class="math inline">\(t\ne s\)</span> 使得 <span class="math inline">\(c_t&gt;0\)</span>，于是 <span class="math inline">\(s\lambda=\lambda-2(\lambda,\alpha_s)\alpha_s\)</span>的 <span class="math inline">\(\alpha_t\)</span>分量保持不动仍然为正，从而根据 <a href="#pos-neg" title="推论 1.4">推论1.4</a> <span class="math inline">\(s\lambda\)</span>必须仍然是正根。<span class="math inline">\(\blacksquare\)</span></p><div id="lw-nw" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.6</span>.</span><span class="statement-spah"> </span>对 <span class="math inline">\(w\in W\)</span>，定义 <span class="math inline">\(N(w)\)</span> 为被 <span class="math inline">\(w\)</span> 变成负根的那些正根组成的集合： <span class="math display">\[N(w)=\{\lambda\in\Phi^+\midw\lambda\in\Phi^-\}.\]</span> 则 <span class="math inline">\(|N(w)|=l(w)\)</span>。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(l(w)\)</span>归纳。<span class="math inline">\(l(w)=0\)</span> 时 <span class="math inline">\(w=1\)</span>，结论成立。下设 <span class="math inline">\(l(w)&gt;0\)</span> 且结论对长度小于 <span class="math inline">\(l(w)\)</span> 的元素成立。取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(w=w's\)</span> 且 <span class="math inline">\(l(w')&lt;l(w)\)</span>。由 <a href="#key-lemma" title="引理 1.2">引理 1.2</a>，<span class="math inline">\(\alpha_s\in N(w)\)</span> 但是 <span class="math inline">\(\alpha_s\notin N(w')\)</span>。对任何正根<span class="math inline">\(\lambda\ne\alpha_s\)</span>，<span class="math inline">\(s\lambda\)</span> 仍然是正根。由恒等式 <span class="math display">\[w'\lambda\in\Phi^- \Leftrightarroww(s\lambda)\in\Phi^-\]</span> 可得 <span class="math inline">\(\lambda\leftrightarrow s\lambda\)</span> 给出了<span class="math inline">\(N(w')\)</span> 和 <span class="math inline">\(N(w)\setminus\{\alpha_s\}\)</span>之间的一一对应，即 <span class="math display">\[N(w)=s\cdotN(w')\cup\{\alpha_s\}.\]</span> 从而由归纳假设 <span class="math display">\[|N(w)|=|N(w')|+1=l(w')+1=l(w).\]</span><span class="math inline">\(\blacksquare\)</span></p><div id="nw-zero-means-identity" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.7</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(w(\Phi^+)\subseteq\Phi^+\)</span>，则 <span class="math inline">\(w=1\)</span>。</p></div><p><strong>证明</strong>：根据 <a href="#lw-nw" title="推论 1.6">推论1.6</a> 有 <span class="math inline">\(l(w)=|N(w)|=0\)</span>，从而<span class="math inline">\(w=1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="w-phi-both-finite-infinite" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.8</span>.</span><span class="statement-spah"> </span><span class="math inline">\(|W|&lt;\infty\)</span> 当且仅当 <span class="math inline">\(|\Phi|&lt;\infty\)</span>。</p></div><p><strong>证明</strong>：如果 <span class="math inline">\(W\)</span>是有限群，由于 <span class="math inline">\(\Phi=W\cdot\Delta\)</span>，<span class="math inline">\(|\Phi|\leq |W|\cdot|\Delta|\)</span> 也是有限的。</p><p>反之若 <span class="math inline">\(|\Phi|&lt;\infty\)</span>，由于<span class="math inline">\(W\)</span> 保持 <span class="math inline">\(\Phi\)</span> 不变，所以 <span class="math inline">\(W\)</span> 置换地作用在 <span class="math inline">\(\Phi\)</span> 上，即有 <span class="math inline">\(W\)</span> 到置换群 <span class="math inline">\(S_{|\Phi|}\)</span> 的同态 <span class="math inline">\(W\xrightarrow{\varphi} S_{|\Phi|}\)</span>。<a href="#nw-zero-means-identity" title="推论 1.7">推论 1.7</a> 说明 <span class="math inline">\(\varphi\)</span> 是嵌入，从而 <span class="math inline">\(W\)</span> 也是有限的。<span class="math inline">\(\blacksquare\)</span></p><div id="longest" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.9</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(W\)</span> 是一个有限群，则存在唯一的元素 <span class="math inline">\(w_0\)</span>，<span class="math inline">\(w_0\)</span> 是 <span class="math inline">\(W\)</span> 中长度最大者，它交换 <span class="math inline">\(\Phi^+\)</span> 和 <span class="math inline">\(\Phi^-\)</span>：<span class="math inline">\(w_0(\Phi^+)=\Phi^-\)</span>，且 <span class="math inline">\(w_0\)</span> 是一个对合：<span class="math inline">\(w_0^2=1\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(W\)</span>有限所以存在一个长度最大的元素 <span class="math inline">\(w_0\)</span>，对任何 <span class="math inline">\(s\in S\)</span> 只能有 <span class="math inline">\(l(w_0s)&lt;l(w)\)</span>，从而 <span class="math inline">\(w_0\alpha_s\in\Phi^-\)</span>，从而 <span class="math inline">\(w_0\)</span> 把 <span class="math inline">\(\Phi^+\)</span> 变为 <span class="math inline">\(\Phi^-\)</span>。</p><p>进一步 <span class="math inline">\(w_0^2\)</span> 仍然把 <span class="math inline">\(\Phi^+\)</span> 映射为 <span class="math inline">\(\Phi^+\)</span>，所以由 <a href="#nw-zero-means-identity" title="推论 1.7">推论 1.7</a> <span class="math inline">\(w_0^2=1\)</span>，因此 <span class="math inline">\(w_0\)</span> 是一个对合。</p><p>如果存在 <span class="math inline">\(w_1\ne w_0\)</span> 使得 <span class="math inline">\(l(w_1)=l(w_0)\)</span> 的话，则 <span class="math inline">\(w_1\)</span> 也满足 <span class="math inline">\(w_1(\Phi^+)=\Phi^-\)</span>，从而 <span class="math inline">\(w_0^{-1}w_1\)</span> 保持 <span class="math inline">\(\Phi^+\)</span> 不变，根据 <a href="#nw-zero-means-identity" title="推论 1.7">推论 1.7</a> 有 <span class="math inline">\(w_0^{-1}w_1=1\)</span>，即 <span class="math inline">\(w_0=w_1\)</span>。所以这样的 <span class="math inline">\(w_0\)</span> 是唯一的。<span class="math inline">\(\blacksquare\)</span></p><div id="remain-positive-root" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.10</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(I\subsetneqq S\)</span> 是真子集，<span class="math inline">\(\lambda\in \Phi^+\setminus\Phi^+_I\)</span>是正根，则对任何 <span class="math inline">\(w\in W_I\)</span>，<span class="math inline">\(w\lambda\)</span> 仍然是正根。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(w\)</span> 是<span class="math inline">\(I\)</span> 中生成元的乘积，所以 <span class="math inline">\(w\lambda\)</span> 是 <span class="math inline">\(\lambda\)</span> 和 <span class="math inline">\(\{\alpha_t\mid t\in I\}\)</span>中向量的线性组合： <span class="math display">\[w\lambda=\lambda +\sum_{t\in I}c_t\alpha_t.\]</span> <span class="math inline">\(\lambda\in\Phi^+\setminus\Phi^+_I\)</span> 说明将<span class="math inline">\(\lambda\)</span>表示为单根的线性组合时，其至少有一项 <span class="math inline">\(\alpha_s\,(s\notin I)\)</span> 的系数大于 0，从而<span class="math inline">\(w\lambda\)</span> 的 <span class="math inline">\(\alpha_s\)</span> 项的系数也大于 0，所以 <span class="math inline">\(w\lambda\)</span> 必然是正根。<span class="math inline">\(\blacksquare\)</span></p><div id="lI-equals-l" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.11</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(w\in W_I\)</span>，则对 <span class="math inline">\(w\)</span> 的任何既约表示 <span class="math inline">\(w=s_1\cdots s_k\)</span> 都有 <span class="math inline">\(s_1,\ldots,s_k\in I\)</span>，特别地 <span class="math inline">\(l_I(w)=l(w)\)</span>。</p></div><p><strong>证明</strong>：我们从右到左依次验证 <span class="math inline">\(s_k,\ldots,s_1\in I\)</span>。记 <span class="math inline">\(s=s_k\)</span>，由于 <span class="math inline">\(l(ws)&lt;l(w)\)</span> 所以 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>。又由于 <span class="math inline">\(w\in W_I\)</span> 所以 <span class="math inline">\(w\alpha_s\)</span> 是 <span class="math inline">\(\alpha_s\)</span> 和一些 <span class="math inline">\(\{\alpha_t\mid t\in I\}\)</span> 的线性组合：<span class="math display">\[w\alpha_s=\alpha_s+\sum_{t\in I}c_t\alpha_t.\]</span> 由于 <span class="math inline">\(w\alpha_s&lt;0\)</span> 所以必然有某个 <span class="math inline">\(t\in I\)</span> 使得 <span class="math inline">\(s=t\)</span>，即 <span class="math inline">\(s\inI\)</span>。对 <span class="math inline">\(ws=s_1\cdots s_{k-1}\inW_I\)</span> 重复此论证即得每个 <span class="math inline">\(s_i\inI\)</span>。<span class="math inline">\(\blacksquare\)</span></p>]]></content>
      
      
      <categories>
          
          <category> Coxeter Groups </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群笔记（一）：抽象 Coxeter 群与几何实现</title>
      <link href="coxeter-groups-geometric-realization/"/>
      <url>coxeter-groups-geometric-realization/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象-coxeter-群">抽象 Coxeter 群</h1><p>设 <span class="math inline">\(S\)</span> 是一个集合，一个基于 <span class="math inline">\(S\)</span> 的 Coxeter 矩阵 <span class="math inline">\(M=(m_{s,t})_{s,t\in S}\)</span>是一个对称矩阵，其对角线上都是 1，非对角线元素取值范围为 <span class="math inline">\(\{2,3,\ldots,\infty\}\)</span>。<span class="math inline">\(|S|\)</span> 叫做 <span class="math inline">\(M\)</span> 的秩 (rank)。在这个系列中我们只考虑<span class="math inline">\(|S|&lt;\infty\)</span> 的情形。</p><p>矩阵 <span class="math inline">\(M\)</span> 确定了一个有限表现群<span class="math inline">\(W\)</span>，其生成元为集合 <span class="math inline">\(S\)</span>，群表现如下： <span class="math display">\[W = \langle s\in S\ |\ (st)^{m_{s,t}}=1\ {\rmif}\ m_{s,t}&lt;\infty\rangle.\]</span></p><p>即 <span class="math inline">\(S\)</span> 满足的生成关系是：</p><ol type="1"><li>对任何 <span class="math inline">\(s\in S\)</span> 有 <span class="math inline">\(s^2=1\)</span>。</li><li>对任何 <span class="math inline">\(s\ne t\)</span> 且 <span class="math inline">\(m_{s,t}&lt;\infty\)</span>有<strong>辫关系</strong> (braid relation) <span class="math display">\[\overbrace{sts\cdots}^{m_{s,t}}=\overbrace{tst\cdots}^{m_{s,t}}\]</span>成立。（当 <span class="math inline">\(m_{s,t}=\infty\)</span>时的关系是无用的）</li></ol><p>我们称 <span class="math inline">\((W, S)\)</span> 是一个<strong>Coxeter 系</strong>，<span class="math inline">\(W\)</span>是一个<strong>有限生成 Coxeter 群</strong>。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>我们总是用 <span class="math inline">\((W,S)\)</span> 来表示一个Coxeter 群。即我们在提到一个 Coxeter 群 <span class="math inline">\(W\)</span> 时需要同时指明 <span class="math inline">\(W\)</span> 的生成元集合 <span class="math inline">\(S\)</span>。这是因为，可能存在不同的生成元集合<span class="math inline">\(S\)</span> 和 <span class="math inline">\(S'\)</span>，它们给出同一个群 <span class="math inline">\(W\)</span>。但是像长度函数 <span class="math inline">\(l(w)\)</span>、Bruhat序这些重要的概念，只有在指定生成元集 <span class="math inline">\(S\)</span> 的前提下才有意义。</p></div><p>用 Coxeter 矩阵或者群表现来描述 Coxeter群还是太不方便了。我们可以用一个有限图 <span class="math inline">\(\Gamma\)</span> 更直观地表示 <span class="math inline">\((W,S)\)</span>，<span class="math inline">\(\Gamma\)</span> 叫做 <span class="math inline">\((W,S)\)</span> 的 <strong>Coxeter图</strong>：</p><ul><li><span class="math inline">\(\Gamma\)</span> 的顶点集是 <span class="math inline">\(S\)</span>。</li><li>如果 <span class="math inline">\(m_{s,t}\ne 2\)</span>，就在顶点<span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 之间连一条边，并且给这条边标上记号<span class="math inline">\(m_{s,t}\)</span>。</li><li>但是如果 <span class="math inline">\(m_{s,t}=3\)</span>的话，就省略这个记号不写。</li></ul><p>此外如果 <span class="math inline">\(\Gamma\)</span> 是连通的，就称<span class="math inline">\((W,S)\)</span>是<strong>不可约的</strong>。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>Coxeter 矩阵 <span class="math display">\[\begin{pmatrix}1 &amp;4 &amp; 2\\4&amp;1&amp;3\\2&amp;3&amp;1\end{pmatrix}\]</span> 对应的Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是</p><figure><img src="/images/coxeter/cube43.svg" class="fig" width="120" alt="正方体对称群 (4,3) 的 Coxeter 图，注意标号 3 省略了"><figcaption aria-hidden="true">正方体对称群 <span class="math inline">\((4,3)\)</span> 的 Coxeter 图，注意标号 3省略了</figcaption></figure><p><span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(W\)</span>是不可约的。这个群是三维正方体的对称群：</p><video src="/images/coxeter/cube.mp4" width="300" controls=""></video><p>去掉最后一个顶点，前两个顶点构成二面体群 <span class="math inline">\(D_4\)</span>，对应正方体的每个面是正四边形；去掉第一个顶点，后两个顶点构成二面体群<span class="math inline">\(D_3\)</span>，对应每个顶点处有 3个面相遇。</p></div><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>设 <span class="math inline">\(m\geq4\)</span> 是正整数，Coxeter矩阵 <span class="math display">\[\begin{pmatrix}1 &amp; m &amp;2\\m&amp;1&amp;2\\2&amp;2&amp;1\end{pmatrix}\]</span> 对应的 Coxeter 图<span class="math inline">\(\Gamma\)</span> 是</p><p><img src="/images/coxeter/prism.svg" class="fig" width="120"></p><p><span class="math inline">\(\Gamma\)</span> 有两个连通分支，所以<span class="math inline">\(W\)</span>是可约的。这个群是三维空间中棱柱的对称群，前两个相邻的顶点给出二面体群<span class="math inline">\(D_m\)</span>，它负责在 <span class="math inline">\(xy\)</span> 平面内生成正 <span class="math inline">\(m\)</span> 边形；最后的孤立顶点在 <span class="math inline">\(z\)</span>轴方向上将多边形作反射形成棱柱结构：</p><video src="/images/coxeter/prism-6.mp4" width="300" controls=""></video></div><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>Coxeter 矩阵 <span class="math display">\[\begin{pmatrix}1 &amp;3 &amp; 4\\3&amp;1&amp;\infty\\4&amp;\infty&amp;1\end{pmatrix}\]</span>对应的 Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是</p><figure id="3-4-inf"><img src="/images/coxeter/3-4-inf.svg" width="120" alt="三角形群 \Delta(3,4,\infty) 的 Coxeter 图 \Gamma，注意标号 3 被省略了"><figcaption aria-hidden="true">三角形群 <span class="math inline">\(\Delta(3,4,\infty)\)</span> 的 Coxeter 图 <span class="math inline">\(\Gamma\)</span>，注意标号 <span class="math inline">\(3\)</span> 被省略了</figcaption></figure><p><span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(W\)</span>是不可约的。这个群给出的是双曲空间中的密铺：</p><p><img src="/images/coxeter/parallel.png" class="fig" width="250"></p></div><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>Coxeter 矩阵 <span class="math display">\[\begin{pmatrix}1 &amp;5 &amp; 2 &amp;2\\5&amp;1&amp;3&amp;2\\2&amp;3&amp;1&amp;4\\2&amp;2&amp;4&amp;1\end{pmatrix}\]</span>对应的 Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是</p><p><img src="/images/coxeter/534.svg" id="534" class="fig" width="180"></p><p><span class="math inline">\(W\)</span>是不可约的。这个群给出的是三维双曲空间中的密铺：</p><p><img src="/images/coxeter/534-1000.jpg" class="fig" width="500"></p><p>去掉最后一个顶点，前三个顶点给出正十二面体的对称群 <span class="math inline">\((5,3)\)</span>，说明这个密铺由正十二面体组成；去掉第一个顶点，剩下三个顶点给出正方体的对称群<span class="math inline">\((3,4)\cong(4,3)\)</span>，说明每个顶点处有 8个正十二面体相遇。</p></div><p>我们主要关心 <span class="math inline">\(\Gamma\)</span>不可约的情形。因为如果 <span class="math inline">\(\Gamma=\Gamma_1\cup\cdots\cup\Gamma_k\,(k&gt;1)\)</span>是多个连通分支的并的话，则对任何 <span class="math inline">\(s\in\Gamma_i\)</span> 和 <span class="math inline">\(t\in\Gamma_j\)</span> 有 <span class="math inline">\(m_{s,t}=2\)</span>，从而 <span class="math inline">\(st=ts\)</span>，于是 <span class="math inline">\(\Gamma_i\)</span> 中的生成元与 <span class="math inline">\(\Gamma_j\)</span> 中的生成元两两交换，这时 <span class="math inline">\(W\)</span> 有直积分解 <span class="math display">\[W=W_1\times\cdots\times W_k.\]</span> 其中 <span class="math inline">\(W_1,\ldots,W_k\)</span> 分别是 <span class="math inline">\(\Gamma_1,\ldots,\Gamma_k\)</span> 对应的 Coxeter群。所以我们只要研究 <span class="math inline">\(\Gamma\)</span>不可约的情形即可。</p><p>还有一种给 <span class="math inline">\(\Gamma\)</span>的边标号的方式，叫做 Vinberg 记号，允许给 <span class="math inline">\(m_{s,t}=\infty\)</span> 的边用 <span class="math inline">\(\leq-1\)</span>的实数作为标号。比如像下面这样：</p><p><img src="/images/coxeter/level2.svg" id="level2" class="fig" width="120"></p><p>作为抽象 Coxeter 群，它和前面的 <a href="#3-4-inf"><span class="math inline">\(\Delta(3,4,\infty)\)</span></a>是同一个群，但是这里 <span class="math inline">\(\infty\)</span>边的标号变成了 <span class="math inline">\(-1.1\)</span>。我后面会解释，Vinberg记号相当于指定了这条边的两个顶点在几何实现中对应的两个镜面的「双曲距离」。在后文介绍Boyd-Maxwell 球堆时，我们也会采用这种记号。</p><p>Coxeter 图除了直观上的好处外，它还能告诉我们一些关于 <span class="math inline">\((W,S)\)</span> 的结构信息。比如当 <span class="math inline">\(\Gamma\)</span> 包含回路，或者有某个顶点的度数<span class="math inline">\(\geq4\)</span> 时，你可以立刻知道 <span class="math inline">\((W,S)\)</span> 一定是无限群 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.2.7</a>)</span>。还有一些更微妙的信息也可以从 <span class="math inline">\(\Gamma\)</span> 中读出来。</p><h1 id="长度函数">长度函数</h1><p>对 <span class="math inline">\(W\)</span> 中的任一元素 <span class="math inline">\(w\)</span>，存在许多种不同的方式将 <span class="math inline">\(w\)</span> 表示为 <span class="math inline">\(S\)</span>中生成元的乘积。在所有这些表示中，长度最短者叫做 <span class="math inline">\(w\)</span> 的<strong>既约表示</strong>：即，如果<span class="math inline">\(w=s_1s_2\cdots s_k\)</span> 是一个长度为<span class="math inline">\(k\)</span> 的表示，且 <span class="math inline">\(w\)</span> 不存在任何长度小于 <span class="math inline">\(k\)</span> 的表示，就称 <span class="math inline">\(s_1s_2\cdots s_k\)</span> 是 <span class="math inline">\(w\)</span> 的既约表示。<span class="math inline">\(w\)</span>的既约表示可能不唯一，但它们都具有相同的长度。定义 <span class="math inline">\(l(w)\)</span> 为 <span class="math inline">\(w\)</span> 的任意一个既约表示的长度。</p><p><span class="math inline">\(l(w)\)</span> 具有如下的性质：</p><ol type="1"><li><span class="math inline">\(l(xy)\leq l(x) + l(y)\)</span>。</li><li><span class="math inline">\(l(w) = l(w^{-1})\)</span>。</li><li><span class="math inline">\(l(w)=0\)</span> 当且仅当 <span class="math inline">\(w=1\)</span>。</li><li><span class="math inline">\(l(ws)=l(w)\pm 1\)</span>，其中 <span class="math inline">\(w\in W, s\in S\)</span>。</li></ol><p>前三点都是显然的，只有 4 需要证明。显然 <span class="math inline">\(|l(ws)-l(w)|\leq 1\)</span>，所以只要说明 <span class="math inline">\(l(ws)\)</span> 和 <span class="math inline">\(l(s)\)</span>不相等即可。这一步需要用到自由群的泛性质：</p><p>设 <span class="math inline">\(F\)</span> 是由集合 <span class="math inline">\(S\)</span> 生成的 <a href="https://en.wikipedia.org/wiki/Free_group">自由群</a>，定义群同态<span class="math inline">\({\rm sgn}: F\to{\pm1}\)</span> 如下：对<span class="math inline">\(F\)</span> 的每个生成元 <span class="math inline">\(s\in S\)</span> 规定 <span class="math inline">\({\rm sgn}(s)=-1\)</span>，然后将此映射扩充为 <span class="math inline">\(F\)</span> 到 <span class="math inline">\({\pm1}\)</span> 的群同态。容易验证 <span class="math inline">\((W,S)\)</span>的所有生成关系都属于这个同态的核，因此根据 <a href="https://en.wikipedia.org/wiki/Free_group#Universal_property">自由群的泛性质</a>，<span class="math inline">\({\rm sgn}\)</span> 诱导了一个从 <span class="math inline">\((W,S)\)</span> 到 <span class="math inline">\({\pm1}\)</span> 的群同态。在此同态下，若 <span class="math inline">\(w=s_1s_2\cdots s_k\)</span> 是 <span class="math inline">\(w\)</span> 的任一既约表示，则 <span class="math display">\[{\rm sgn}(w)={\rm sgn}(s_1){\rmsgn}(s_2)\cdots{\rm sgn}(s_k)=(-1)^k=(-1)^{l(w)}.\]</span> 从而 <span class="math inline">\({\rm sgn}(ws)={\rm sgn}(w){\rm sgn}(s)=-{\rmsgn}(w)\)</span> 说明 <span class="math inline">\(l(ws)\nel(w)\)</span>。</p><h1 id="几何实现">几何实现</h1><p>抽象 Coxeter群是用生成元和生成关系定义的，直接从这种定义出发研究群结构是非常困难的。在这一节中，我们介绍如何将抽象的Coxeter群实现为一个内积空间中的正交反射群，从而可以使用几何、线性代数等多种工具来研究它。</p><p>设 <span class="math inline">\((W,S)\)</span> 是一个 Coxeter系，<span class="math inline">\(M=(m_{s,t})_{s,t\in S}\)</span> 是Coxeter 矩阵，<span class="math inline">\(V\)</span> 是一个维数为 <span class="math inline">\(n=|S|\)</span> 的实向量空间，其一组基为 <span class="math inline">\(\{\alpha_s \mid s\in S\}\)</span>。我们规定 <span class="math inline">\(V\)</span> 上的内积 <span class="math inline">\((\cdot,\cdot)\)</span> 如下：</p><p><span class="math display">\[(\alpha_s,\alpha_t)=\begin{cases}1 &amp; s=t,\\-\cos(\pi/m_{s,t}) &amp; m_{s,t}&lt;\infty,\\-a_{s,t} &amp; m_{s,t}=\infty.\end{cases}\]</span> 这里 <span class="math inline">\(a_{s,t}=a_{t,s}\geq1\)</span> 是实数，它对应的是<span class="math inline">\(\infty\)</span> 边的 Vinberg 记号。不同的<span class="math inline">\(s,t\)</span> 对可以使用不同的 <span class="math inline">\(a_{s,t}\)</span>。</p><p>根据定义 <span class="math inline">\((\alpha_s,\alpha_s)=1\)</span>，即每个 <span class="math inline">\(\alpha_s\)</span> 都是单位向量。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span><span class="math inline">\(a_{s,t}=1\)</span> 表示 Euclidean空间中两个平行的镜面（或者双曲空间中两个平行的镜面）；<span class="math inline">\(a_{s,t}&gt;1\)</span>表示双曲空间中两个超平行的镜面；<span class="math inline">\(2\leqm_{s,t}&lt;\infty\)</span> 表示两个相交的镜面。</p><p>下图显示了对前面的 <a href="#3-4-inf"><span class="math inline">\(\Delta(3,4,\infty)\)</span></a> 群，对标号为 <span class="math inline">\(\infty\)</span> 的边取 <span class="math inline">\(a_{s,t}=1.15\)</span> 时给出的效果：</p><p><img src="/images/coxeter/hypparallel.png" class="fig" width="250"></p><p>你可以看到每个三角形都不再是封闭的，它们的墙壁中有两条「超平行」的测地线，这两条测地线交点落在双曲空间的外面。</p></div><p>内积 <span class="math inline">\((\cdot,\cdot)\)</span> 未必是通常的Euclidean 内积，即它未必是正定的。但我们最关心的情形有三种：</p><ol type="1"><li>如果 <span class="math inline">\((\cdot,\cdot)\)</span>是正定的，就称 <span class="math inline">\((\cdot,\cdot)\)</span>是<strong>有限</strong>型的；</li><li>如果 <span class="math inline">\((\cdot,\cdot)\)</span>是半正定的，但不是正定的，就称 <span class="math inline">\((\cdot,\cdot)\)</span>是<strong>仿射</strong>型的；</li><li>如果 <span class="math inline">\((\cdot,\cdot)\)</span> 的符号是<span class="math inline">\((n-1, 1)\)</span>，就称 <span class="math inline">\((\cdot,\cdot)\)</span>是<strong>双曲</strong>型的。</li></ol><p>不属于以上三种类型的一律称为<strong>不定</strong>的。</p><p>正如名字所暗示的那样，<span class="math inline">\((\cdot,\cdot)\)</span> 是有限型的当且仅当 <span class="math inline">\(W\)</span> 是有限反射群，这时 <span class="math inline">\(W\)</span> 给出的万花筒是球面上的密铺；<span class="math inline">\((\cdot,\cdot)\)</span> 是仿射型的当且仅当 <span class="math inline">\(W\)</span> 可以实现为 Euclidean 空间上的仿射 Weyl群，这时 <span class="math inline">\(W\)</span> 给出的万花筒是 Euclidean空间中的密铺；<span class="math inline">\((\cdot,\cdot)\)</span>是双曲型的意味着 <span class="math inline">\(W\)</span>给出的是双曲空间中的密铺。这些我们会在后面作更详细的讨论。</p><p>给定 <span class="math inline">\(s\in S\)</span>，定义 <span class="math inline">\(V\)</span> 上的反射 <span class="math inline">\(\rho_s\)</span> 为 <span class="math display">\[\rho_s(v) = v -2(v,\alpha_s)\alpha_s ,\quad v\inV.\]</span> 容易验证 <span class="math inline">\(\rho_s\)</span>满足以下几点：</p><ol type="1"><li><span class="math inline">\(\rho_s(\alpha_s)=-\alpha_s\)</span>；</li><li><span class="math inline">\(\rho_s\)</span> 保持超平面 <span class="math inline">\(\{v\in V\mid (v,\alpha_s)=0\}\)</span>上的点不动；</li><li><span class="math inline">\(\rho_s\)</span> 保持 <span class="math inline">\((\cdot,\cdot)\)</span> 不变：<span class="math inline">\((\rho_s(u),\rho_s(v)) = (u,v),\,\forall u,v\inV\)</span>。</li></ol><p>即 <span class="math inline">\(\rho_s\in \mathrm{O}(V)\)</span> 是以<span class="math inline">\(\alpha\)</span> 为法向量的镜面反射。</p><p>我们来证明 <span class="math inline">\(s\to\rho_s\)</span>实际上给出了 <span class="math inline">\((W,S)\)</span> 到 <span class="math inline">\(\mathrm{O}(V)\)</span> 的群同态，从而 <span class="math display">\[\rho: W\to\rho(W)\leqslant\mathrm{O}(V)\]</span>是一个线性表示。为此只要证明 <span class="math inline">\(\{\rho_s\mids\in S\}\)</span> 满足与 <span class="math inline">\((W,S)\)</span>相同的生成关系即可，这样根据商群的泛性质，即得存在群同态 <span class="math inline">\(W\to \langle\,\rho_s\mid s\in S\,\rangle\)</span>将每个 <span class="math inline">\(s\)</span> 被映射到 <span class="math inline">\(\rho_s\)</span>。即我们只要证明：</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\((\rho_s\rho_t)^{m_{s,t}}=1\)</span> 对任何 <span class="math inline">\(s,t\in S\)</span> 成立。</p></div><p>这个结论的证明在 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.5.3</a>)</span> 和 <span class="citation" data-cites="Howlett-note">Howlett (<a href="#ref-Howlett-note" role="doc-biblioref">1996</a>)</span> 中都可以找到，但我更喜欢 Howlett的做法，把 rank 2情形的根系具体的算出来。这是最简单，但又非平凡的根系的例子，熟悉它的重要性怎么强调也不为过。</p><p><strong>证明</strong>：当 <span class="math inline">\(s=t\)</span>时所证即为 <span class="math inline">\(\rho_s^2=1\)</span>，由于 <span class="math inline">\(\rho_s\)</span> 是反射这当然是成立的。</p><p>下设 <span class="math inline">\(s\ne t\)</span>，令 <span class="math inline">\(V_{s,t}={\rm span}\{\alpha_s,\alpha_t\}\)</span>是 <span class="math inline">\(\alpha_s,\alpha_t\)</span>张成的二维子空间，并记 <span class="math inline">\(V_{s,t}^\bot\)</span>是 <span class="math inline">\(V_{s,t}\)</span> 在 <span class="math inline">\((\cdot,\cdot)\)</span> 下的正交补空间。不难验证<span class="math inline">\(\rho_s\)</span> 和 <span class="math inline">\(\rho_t\)</span> 限制在 <span class="math inline">\(V_{s,t}^\bot\)</span> 上都是恒等变换。</p><p>注意不一定有 <span class="math inline">\(V=V_{s,t}\oplusV_{s,t}^\bot\)</span> 成立，因为 <span class="math inline">\((\cdot,\cdot)\)</span> 有可能是退化的。但是如果<span class="math inline">\((\cdot,\cdot)\)</span> 限制在 <span class="math inline">\(\mid_{V_{s,t}}\)</span> 是非退化的，就有 <span class="math inline">\(V=V_{s,t}\oplus V_{s,t}^\bot\)</span>就成立。这是双线性型的一个基本结论。</p><p>我们来计算 <span class="math inline">\(\sigma=\rho_s\rho_t\)</span>的阶。记 <span class="math inline">\(m=m_{s,t}\)</span>，分情况讨论：</p><div id="rank2-roots" class="plain"></div><ol type="1"><li><p><span class="math inline">\(m&lt;\infty\)</span>。这时 <span class="math inline">\((\cdot,\cdot)\)</span> 限制在 <span class="math inline">\(V_{s,t}\)</span> 上的 Gram 矩阵是 <span class="math display">\[\begin{pmatrix}1&amp;-\cos\theta\\-\cos\theta&amp;1\end{pmatrix},\quad\theta=\frac{\pi}{m}.\]</span> 这个矩阵是正定的，从而 <span class="math inline">\((\cdot,\cdot)\mid_{V_{s,t}}\)</span> 非退化，这时<span class="math inline">\(V=V_{s,t}\oplus V_{s,t}^\bot\)</span>是成立的，而 <span class="math inline">\(\sigma\)</span> 限制在正交补<span class="math inline">\(V_{s,t}^\bot\)</span> 上是恒等变换，所以<span class="math inline">\(\sigma\)</span> 在 <span class="math inline">\(V\)</span> 上的阶就等于它在 <span class="math inline">\(V_{s,t}\)</span>上的阶。为了简化记号（否则我们的表达式会超出页面），令 <span class="math inline">\(a_k=\sin(k\theta)/\sin\theta\)</span>，直接计算不难得到 <span class="math display">\[\begin{align*}&amp;\alpha_s\xrightarrow{\ \rho_t\}a_1\alpha_s+a_2\alpha_t\xrightarrow{\ \rho_s\}a_3\alpha_s+a_2\alpha_t\xrightarrow{\ \rho_t\}a_3\alpha_s+a_4\alpha_t\xrightarrow{\ \rho_s\ }\cdots\\&amp;\alpha_t\xrightarrow{\ \rho_s\}a_2\alpha_s+a_1\alpha_t\xrightarrow{\ \rho_t\}a_2\alpha_s+a_3\alpha_t\xrightarrow{\ \rho_s\}a_4\alpha_s+a_3\alpha_t\xrightarrow{\ \rho_t\ }\cdots\end{align*}\]</span> 这两个链的周期都是 <span class="math inline">\(2m\)</span>，因为它们的第 <span class="math inline">\(2m+1\)</span> 项分别是 <span class="math display">\[a_{2m+1}\alpha_s+a_{2m}\alpha_t=\dfrac{\sin(2m+1)\theta}{\sin\theta}\alpha_s+\dfrac{\sin(2m)\theta}{\sin\theta}\alpha_t=\alpha_s.\]</span> 和 <span class="math display">\[a_{2m}\alpha_s+a_{2m+1}\alpha_t=\dfrac{\sin(2m)\theta}{\sin\theta}\alpha_s+\dfrac{\sin(2m+1)\theta}{\sin\theta}\alpha_t=\alpha_t.\]</span>又回到了各自的第一项。所以 <span class="math inline">\(\sigma\)</span>的阶等于 <span class="math inline">\(m\)</span>。</p></li><li><p><span class="math inline">\(m=\infty\)</span>。这时未必有 <span class="math inline">\(V=V_{s,t}\oplusV_{s,t}^\bot\)</span>。但我们可以证明 <span class="math inline">\(\sigma\)</span> 在 <span class="math inline">\(V_{s,t}\)</span> 上的阶是无穷，那么自然它在 <span class="math inline">\(V\)</span> 上的阶也是无穷。 设 <span class="math inline">\(\theta\geq0\)</span> 使得 <span class="math inline">\(a_{s,t}=\cosh\theta\)</span>。同样为了简化记号，令<span class="math inline">\(b_k=\sinh(k\theta)/\sinh\theta\)</span>，不难验证有<span class="math display">\[\begin{align*}&amp;\alpha_s\xrightarrow{\\rho_t\ }b_1\alpha_s+b_2\alpha_t\xrightarrow{\ \rho_s\}b_3\alpha_s+b_2\alpha_t\xrightarrow{\ \rho_t\}b_3\alpha_s+b_4\alpha_t\xrightarrow{\ \rho_s\ }\cdots\\&amp;\alpha_t\xrightarrow{\ \rho_s\}b_2\alpha_s+b_1\alpha_t\xrightarrow{\ \rho_t\}b_2\alpha_s+b_3\alpha_t\xrightarrow{\ \rho_s\}b_4\alpha_s+b_3\alpha_t\xrightarrow{\ \rho_t\ }\cdots\end{align*}\]</span>（当 <span class="math inline">\(a_{s,t}=1\)</span> 时 <span class="math inline">\(\theta=0\)</span>，<span class="math inline">\(b_k\)</span> 应当理解为 <span class="math inline">\(\lim_{\theta\to0}\sinh(k\theta)/\sinh(\theta)=k\)</span>）</p><p>这两个链条都是永不重复的，所以 <span class="math inline">\(\sigma\)</span> 的阶是无穷。</p></li></ol><p>至此命题得证。<span class="math inline">\(\blacksquare\)</span></p><p>后面我们会看到 <span class="math inline">\(\rho\)</span>实际是一个同构，这样就把抽象的 Coxeter 群 <span class="math inline">\(W\)</span> 实现为具体的反射群 <span class="math inline">\(\rho(W)\)</span>。由于 <span class="math inline">\(\rho\)</span> 是同构，研究 <span class="math inline">\(\rho(W)\)</span> 并不会丢失 <span class="math inline">\(W\)</span> 的信息。</p><p>最后是一个记号的简化：我们把 <span class="math inline">\(w\inW\)</span> 在 <span class="math inline">\(V\)</span> 上的作用简写为<span class="math inline">\(wv=\rho(w)(v)\)</span>。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Howlett-note" class="csl-entry" role="listitem">Howlett, Robert B. 1996. <span>“Introduction to Coxeter Groups.”</span><a href="https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html">https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html</a>.</div><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div></div>]]></content>
      
      
      <categories>
          
          <category> Coxeter Groups </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>遛狗中的数学：曲线的环绕数、Rouché 定理和开映射定理</title>
      <link href="Rouche-theorem-winding-number/"/>
      <url>Rouche-theorem-winding-number/</url>
      
        <content type="html"><![CDATA[<p>我写了一个 <a href="https://www.shadertoy.com/view/fdK3RD">shadertoy小动画</a>，演示 <span class="citation" data-cites="Needham1997">(<a href="#ref-Needham1997" role="doc-biblioref">Needham 1997</a>)</span>书中第 7 章 “Winding numbers and topology” 中的结论：</p><span id="more"></span><div class="statement simple plain unnumbered"><p>一个人和他的狗在公园里绕着一棵树散步，人和狗各自走的路径都是闭曲线，即经过一段时间后都会回到起点。如果人把狗绳抓的紧一些，使得整个过程中狗<strong>无法接触</strong>到树，则结束后人和狗绕着树走的圈数是一样的，这就是下面这个动画演示的：（树的位置是原点，用一个表盘标记）</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/fdK3RD?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe></div><p>对应的数学结论是：两条闭曲线 <span class="math inline">\(\gamma_1,\gamma_2\)</span> 如果都不经过原点，且<span class="math inline">\(\gamma_1\)</span>可以在不碰触到原点的前提下通过连续的形变变为 <span class="math inline">\(\gamma_2\)</span>（同伦），则 <span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点的环绕数相等。</p><p>注意这个结论只要求 <span class="math inline">\(\gamma_1,\gamma_2\colon\[0,1]\to\mathbb{R}^2\)</span>是两条连续曲线，并不涉及解析性。因为环绕数和同伦都是拓扑概念，只涉及连续性。</p><p>当 <span class="math inline">\(\gamma_1=f(S^1),\gamma_2=g(S^1)\)</span>分别是单位圆 <span class="math inline">\(S^1\colon\\{z\in\mathbb{C}:|z|=1\}\)</span> 在两个解析函数 <span class="math inline">\(f,g\)</span> 下的像时，<a href="https://en.wikipedia.org/wiki/Argument_principle">幅角原理</a>告诉我们 <span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点的环绕数分别等于 <span class="math inline">\(f,g\)</span> 在<span class="math inline">\(S^1\)</span> 内部的零点个数。进一步 <a href="https://en.wikipedia.org/wiki/Rouch%C3%A9%27s_theorem">Rouché定理</a> 告诉我们，如果对任何 <span class="math inline">\(z\inS^1\)</span> 都有 <span class="math inline">\(|f(z)|&gt;|f(z)-g(z)|\)</span> 成立，即可保证<span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点有相同的环绕数，从而 <span class="math inline">\(f,g\)</span> 在<span class="math inline">\(S^1\)</span>内部的零点个数也是相同的。Rouché 定理的条件说的就是，假设人的位置是<span class="math inline">\(f(z)\)</span>，狗的位置是 <span class="math inline">\(g(z)\)</span>，绳子 <span class="math inline">\(l(z)=f(z)-g(z)\)</span> 的长度 <span class="math inline">\(|l(z)|\)</span> 始终小于人到原点的距离 <span class="math inline">\(|f(z)|\)</span>，就可以保证狗始终够不到原点。</p><p>动画中左下角的圆周是 <span class="math inline">\(S^1\)</span>，动画右边红、绿两条路径分别是 <span class="math inline">\(f(S^1)\)</span> 和 <span class="math inline">\(g(S^1)\)</span>。这里的 <span class="math inline">\(f\)</span> 我取的形如 <span class="math display">\[f(z)=\frac{z-a}{1-\overline{a}z}\frac{z-b}{1-\overline{b}z}\frac{z-c}{1-\overline{c}z}(z-2-2i),\quad |a|,|b|,|c|&lt;1.\]</span> <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(S^1\)</span> 的内部有 3 个根（我用红点标出来了），在 <span class="math inline">\(S^1\)</span> 上不为0，在 <span class="math inline">\(S^1\)</span>外部有一个根（图中没有画）。<span class="math inline">\(f(z)\)</span>的前三个因子构成一个 Blaschke 乘积，它把 <span class="math inline">\(S^1\)</span> 的内部仍然映射为内部，把 <span class="math inline">\(S^1\)</span> 仍然映射为 <span class="math inline">\(S^1\)</span>，于是对任何 <span class="math inline">\(z\in S^1\)</span> 有 <span class="math display">\[|f(z)| = |z - 2 - 2i| \geq 2\sqrt{2} - 1,\quadz\in S^1.\]</span> 所以只要绳子 <span class="math inline">\(l(z)\)</span> 满足 <span class="math inline">\(|l(S^1)| &lt; 2\sqrt{2}-1\)</span>，则狗走的路径<span class="math inline">\(g(S^1)=f(S^1)+l(S^1)\)</span>就不可能接触到原点。我这里取了 <span class="math inline">\(l(z) =cz\)</span>，其中 <span class="math inline">\(c\)</span> 是一个小于<span class="math inline">\(2\sqrt{2}-1\)</span> 的正实数。</p><p>Needham 的书中还介绍了曲线 <span class="math inline">\(\gamma\)</span> 的环绕数在 <span class="math inline">\(\mathbb{C}\setminus\gamma\)</span>的每个连通分支上都是常数。对不在 <span class="math inline">\(\gamma\)</span> 上的一点 <span class="math inline">\(z\)</span>，我们可以稍稍移动 <span class="math inline">\(z\)</span> 到另一个点 <span class="math inline">\(z'\)</span>，只要保持 <span class="math inline">\(z'\)</span> 仍然位于 <span class="math inline">\(z\)</span> 所在的连通分支内，<span class="math inline">\(\gamma\)</span> 关于 <span class="math inline">\(z\)</span> 和 <span class="math inline">\(z'\)</span>的环绕数就一定相同。利用这个事实并结合幅角原理不难得出下面的结论：</p><div id="connected-component" class="unnumbered statement sta___ plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(\gamma\)</span>是一条简单闭曲线，内部围的区域为 <span class="math inline">\(\Omega\)</span>，<span class="math inline">\(f(z)\)</span> 是一个非常数的解析函数，<span class="math inline">\(f\)</span> 在包含 <span class="math inline">\(\gamma\)</span>的某个区域内解析。假设有两棵树分别位于 <span class="math inline">\(w_0,\,w_1\)</span> 两点，且人行走的路线 <span class="math inline">\(f(\gamma)\)</span> 到 <span class="math inline">\(w_0\)</span> 的距离始终大于两棵树之间的距离：<span class="math display">\[|f(z)-w_0| &gt; |w_0-w_1|,\quad\forallz\in\gamma.\]</span></p><figure><img src="/images/rouche/winding_number.svg" width="250" alt="注意两棵树位于 \mathbb{C}\backslash f(\gamma) 的同一个连通分支中"><figcaption aria-hidden="true">注意两棵树位于 <span class="math inline">\(\mathbb{C}\backslash f(\gamma)\)</span>的同一个连通分支中</figcaption></figure><p>则 <span class="math inline">\(f(\gamma)\)</span> 关于 <span class="math inline">\(w_0,w_1\)</span> 的环绕数相等，从而 <span class="math inline">\(w_0,w_1\)</span> 在 <span class="math inline">\(\gamma\)</span> 内部的原像个数相同： <span class="math display">\[\sharp\{z\in \Omega: f(z)=w_0\} = \sharp\{z\in\Omega: f(z)=w_1\}.\]</span></p></div><p><strong>证明</strong>：这是因为根据条件，从 <span class="math inline">\(w_0\)</span> 沿着线段 <span class="math inline">\([w_0,w_1]\)</span> 移动到 <span class="math inline">\(w_1\)</span> 的过程中始终不会碰触到曲线 <span class="math inline">\(f(\gamma)\)</span>，所以 <span class="math inline">\(w_0,w_1\)</span> 必然位于同一连通分支内。<span class="math inline">\(\blacksquare\)</span></p><p>利用此推论我们不难得出复分析中的 <a href="https://en.wikipedia.org/wiki/Open_mapping_theorem_(complex_analysis)">开映射定理</a>：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>如果 <span class="math inline">\(U\subseteq\mathbb{C}\)</span>是开集，<span class="math inline">\(f\colon\ U\to\mathbb{C}\)</span>是非常数的解析函数，则 <span class="math inline">\(f(U)\)</span>也是开集。</p></div><p><strong>证明</strong>：任取 <span class="math inline">\(z_0\inU\)</span>，记 <span class="math inline">\(w_0=f(z_0)\)</span>。由于<span class="math inline">\(f\)</span> 不是常数，所以 <span class="math inline">\(f(z)-w_0\)</span> 的零点都是孤立的。我们可以取<span class="math inline">\(z_0\)</span> 的一个充分小的闭圆盘 <span class="math inline">\(B_\delta=\{z\in U\mid |z-z_0|\leq\delta\}\)</span>使得 <span class="math inline">\(f(z)-w_0\)</span> 在 <span class="math inline">\(B_\delta\)</span> 中除了 <span class="math inline">\(z_0\)</span> 以外没有其它零点。特别地，<span class="math inline">\(f(z)-w_0\)</span> 在 <span class="math inline">\(B_\delta\)</span> 的边界 <span class="math inline">\(\gamma =\{|z-z_0|=\delta\}\)</span> 上恒不为0，从而 <span class="math inline">\(|f(z)-w_0|\)</span> 在 <span class="math inline">\(\gamma\)</span> 上有正的极小值 <span class="math inline">\(e\)</span>，即对任何 <span class="math inline">\(z\in\gamma\)</span> 有 <span class="math inline">\(|f(z)-w_0|\geq e\)</span>。</p><p>现在我们考虑 <span class="math inline">\(w_0\)</span> 的邻域 <span class="math inline">\(V_e=\{|w-w_0|&lt;e\}\)</span>。则任何 <span class="math inline">\(w_1\in V_e\)</span> 都满足 <a href="#connected-component" title="推论">推论</a> 中的条件：</p><p><span class="math display">\[|f(z)- w_0| \geq e &gt; |w_1-w_0|,\quadz\in \gamma.\]</span></p><p>所以 <span class="math inline">\(w_1\)</span> 在 <span class="math inline">\(\gamma\)</span> 内部至少有一个原像。由 <span class="math inline">\(w_1\)</span> 的任意性可得 <span class="math inline">\(V_e\subset f(U)\)</span> 是 <span class="math inline">\(w_0\)</span> 在 <span class="math inline">\(f(U)\)</span> 中的开邻域，从而 <span class="math inline">\(f(U)\)</span> 是开集。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Needham1997" class="csl-entry" role="listitem">Needham, Tristan. 1997. <em>Visual Complex Analysis</em>. The ClarendonPress, Oxford University Press, New York.</div></div>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静电场与 Marden 定理</title>
      <link href="Marden-theorem/"/>
      <url>Marden-theorem/</url>
      
        <content type="html"><![CDATA[<p>我昨晚刚完成了一个 <a href="https://www.shadertoy.com/view/7lf3Wn">shadertoy小动画</a>，演示平面几何中的 <a href="https://en.wikipedia.org/wiki/Marden%27s_theorem">Marden定理</a>、复分析中的 <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Lucas_theorem">Gauss-Lucas定理</a> 和静电场之间的关系：</p><span id="more"></span><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/7lf3Wn?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><p>这个动画的含义如下：</p><ol type="1"><li><p>在复平面上三角形 <span class="math inline">\(\Delta ABC\)</span>的三个顶点处各自放置一个单位正电荷，则平面上电场强度为 0的点有两个（这两个点可能重合），它们位于 <span class="math inline">\(\Delta ABC\)</span> 的内部，并且是三次复多项式<span class="math inline">\(P(z) = (z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span> 的零点。</p></li><li><p>不仅如此，这两个零点还是一个内切于 <span class="math inline">\(\Delta ABC\)</span>的椭圆的两个焦点，此椭圆是所有内切于 <span class="math inline">\(\DeltaABC\)</span> 的椭圆中面积最大者，并且其与 <span class="math inline">\(\Delta ABC\)</span>的三边的切点均为各边中点。这个椭圆叫做 <a href="https://en.wikipedia.org/wiki/Steiner_inellipse">Steiner内切椭圆</a>。</p></li></ol><p>这个动画是受几天前 Albert Chern 的 <a href="https://twitter.com/theAlbertChern/status/1395468792788967428?s=20">一篇推文</a>启发所作，John Baez 也写了一篇关于这个话题的 <a href="https://johncarlosbaez.wordpress.com/2021/05/24/electrostatics-and-the-gauss-lucas-theorem/">文章</a>。我是由此才了解到Marden 定理还有如此有趣的物理学解释，的确大开眼界！</p><hr><p>在平面上不全共线的 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(a_1,\ldots,a_n\)</span>处放置若干单位正电荷，这规定了一个平面上的电势函数 <span class="math inline">\(V(z)\)</span> （标量） 和一个电场 <span class="math inline">\(\mathbf{E}(z)\)</span>（二维向量场）。电学知识告诉我们，在忽略物理常数意义下有 <span class="math display">\[V(z)=\sum_{i=1}^n\ln|z-a_i|=\ln\prod_{i=1}^n|z-a_i|=\ln|P(z)|.\]</span> 其中<span class="math inline">\(P(z)=(z-a_1)(z-a_2)\cdots(z-a_n)\)</span>是以 <span class="math inline">\(a_1,\ldots,a_n\)</span>为根的多项式。</p><p>此外 <span class="math inline">\(\mathbf{E}(z) = -\nablaV(z)\)</span> 为电势的梯度向量取负。</p><blockquote><p><strong>问题</strong>：怎样确定平面上场强为 0 的点呢？</p></blockquote><p>场强为 0的点也叫做<strong>平衡点</strong>、<strong>鞍点</strong>，因为在这一点处的电荷不受电场的库仑力。</p><p>答案有点出人意料：平衡点必然是 <span class="math inline">\(P'(z)\)</span> 的零点，而且这些点都属于 <span class="math inline">\(a_1,\ldots,a_n\)</span> 的凸包！</p><p>注意 <span class="math inline">\(V(z)\)</span> 是 <span class="math inline">\(\ln P(z) = \ln |P(z)| + i\arg{P(z)}\)</span>的实部，由 Cauchy-Riemann 方程不难看出使得亚纯函数实部梯度为 0的点一定是其导数的零点，即满足 <span class="math inline">\(\nablaV=0\)</span> 的点都是 <span class="math inline">\((\lnP(z))'=P'(z)/P(z)\)</span> 的零点，所以平衡点都是 <span class="math inline">\(P'(z)\)</span> 的零点。平衡点属于 <span class="math inline">\(\{a_1,\ldots,a_n\}\)</span> 的凸包是根据 <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Lucas_theorem">Gauss-Lucas定理</a>：任何复多项式 <span class="math inline">\(f\)</span>的导数的零点都属于 <span class="math inline">\(f\)</span>的零点构成的凸包！</p><p>John Baez 的文章中利用凸集分离定理给出了 Gauss-Lucas定理的一个简洁证明。</p><p>需要注意的是，反过来 <span class="math inline">\(P'(z)\)</span>的零点未必都是电场的平衡点，当 <span class="math inline">\(P(z)\)</span>有重根时，重根也是 <span class="math inline">\(P'(z)\)</span>的零点，但不是 <span class="math inline">\(P'(z)/P(z)\)</span>的零点，所以不是平衡点。</p><p>此外平衡点是鞍点 (saddle point) 是由于 <span class="math inline">\(V(z)\)</span>的调和性质，其不存在局部的极大极小值，所以使得 <span class="math inline">\(\nabla V=0\)</span> 的点都是鞍点。</p><p>在三个点电荷 <span class="math inline">\(A,B,C\)</span>的情形，平衡点有两个，它们位于 <span class="math inline">\(\DeltaABC\)</span> 的内部，且是多项式 <span class="math inline">\(P(z) =(z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span>的零点。那关于这两个点的具体位置我们可以说什么吗？这就是优美的 Marden定理，要表述这个定理，我们需要先介绍 Steiner 内切椭圆的概念：</p><div id="steiner-inellipse" class="unnumbered statement sta_steiner_inellipse plain"><p><span class="statement-heading"><span class="statement-label">Steinerinellipse</span>.</span><span class="statement-spah"></span>在所有内切于 <span class="math inline">\(\Delta ABC\)</span>的椭圆中，存在唯一的一个面积最大者，叫做 Steiner inellipse，此椭圆与<span class="math inline">\(\Delta ABC\)</span>三边的切点为各边的中点。</p></div><p>Marden 定理断言 <span class="math inline">\(P'(z)\)</span>的两个根正是 Steiner 内切椭圆的两个焦点：</p><div id="marden-------" class="unnumbered statement sta_marden___ plain"><p><span class="statement-heading"><span class="statement-label">Marden定理</span>.</span><span class="statement-spah"> </span>复多项式 <span class="math inline">\(P(z)=(z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span> 的两个零点正是 <span class="math inline">\(\Delta ABC\)</span> 的 Steiner inellipse的两个焦点。</p></div><p>Steiner inellipse 和 Marden定理的证明并不复杂，美国数学月刊上出现过两篇介绍其证明的文章，都非常值得一读：</p><ol type="1"><li><p><a href="https://www.researchgate.net/publication/228698127_Triangles_Ellipses_and_Cubic_Polynomials">Triangles,Ellipses, and Cubic Polynomials</a>.</p></li><li><p><a href="https://www.researchgate.net/publication/263136028_An_Elementary_Proof_of_Marden%27s_Theorem">AnElementary Proof of Marden’s Theorem</a>.</p></li></ol><p>其中第一篇文章采用了复数和仿射变换的途径，第二篇使用了椭圆的光学性质。</p>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Todd-Coxeter 算法和 3D/4D 均匀多胞体</title>
      <link href="Todd-Coxeter-and-uniform-polytopes/"/>
      <url>Todd-Coxeter-and-uniform-polytopes/</url>
      
        <content type="html"><![CDATA[<p>本文介绍我写的一个高颜值的、脱离了低级趣味的小程序：用 Python 和POV-Ray 绘制各种三维多面体和四维多胞体，代码在 <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/polytopes">Github</a>上。</p><p>以下是用这个程序渲染的一些例子，其中不同颜色的顶点/边/面表示它们在对称群的作用下位于不同的轨道中，具体解释见后。</p><span id="more"></span><h1 id="例子">例子</h1><ul><li><p>所有的 Platonic 多面体，Archimedean 多面体，比如 snubdodecahedron:</p><p><video src="/images/polytopes/snub-dodecahedron.mp4" controls=""></video></p></li><li><p>所有的 Kepler-Poinsot 多面体，比如 great icosahedron:</p><p><video src="/images/polytopes/great-icosahedron.mp4" controls=""></video></p></li><li><p>所有的四维均匀多胞体 （除去一个特例 <a href="https://en.wikipedia.org/wiki/Grand_antiprism">The grandantiprism</a>），比如我的 Github 头像 (runcinated 120-cell)：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/github-favicon.png"></p></li><li><p>截断的四维正方体 truncated tesseract:</p><p><video src="/images/polytopes/truncated-tesseract.mp4" controls=""></video></p></li><li><p>4d cube:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/4-cube.png"></p></li><li><p>也可以是非凸的，比如星状正多胞体中的 grand stellated120-cell:</p><p><video src="/images/polytopes/grand-stellated-120-cell.mp4" controls=""></video></p></li><li><p>甚至是 5 维欧氏空间中的均匀多胞体，如 5-cube:</p><p><video src="/images/polytopes/5-cube.mp4" controls=""></video></p></li></ul><p>等等，可玩的效果是非常多的。</p><p>以上这些都是在 Python 中做好计算以后，将多胞体的数据导出到 POV-Ray中渲染得到的。你完全可以通过改写代码中的 POV-Ray的部分来渲染得出不同的效果，当然前提是需要掌握 POV-Ray的场景描述语言，不过这属于另一段故事，就不在本文的讨论范围内了。</p><p>下面介绍程序背后的数学原理。</p><h1 id="这些图画的都是什么">这些图画的都是什么？</h1><p>这些图都是三维或者四维<strong>欧氏空间</strong>中<strong>凸/非凸</strong>的<strong>均匀</strong>多胞体(polytope)，三维的情形更常用的称呼是多面体。这里有几个关键词需要注意：凸/非凸、均匀。</p><p>凸比较好理解，就是指多胞体上任意两点间的连线仍然属于此多胞体，否则就是非凸。上面的例子中Platonic 多面体、Archimedean 多面体都是凸的，Kepler-Poinsot多面体、星状正多胞体都是非凸的。</p><p>均匀这个词就不太好理解了。简单说就是：多胞体的所有顶点都一样，且每个面都是正多边形，每个胞腔都是三维的均匀多面体（这是个递归的定义）。</p><p>要准确解释什么叫所有顶点都一样，就要用到群论的语言：一个多胞体 <span class="math inline">\(P\)</span> 的对称群 <span class="math inline">\(G\)</span>是欧氏空间中一组正交变换构成的有限群，<span class="math inline">\(G\)</span> 作用在 <span class="math inline">\(P\)</span> 上保持 <span class="math inline">\(P\)</span> 不变。所有顶点都一样的严格说法是 <span class="math inline">\(G\)</span> 传递地作用在 <span class="math inline">\(P\)</span> 的顶点集上，即对 <span class="math inline">\(P\)</span> 的任何两个顶点 <span class="math inline">\(u,v\)</span>，都存在 <span class="math inline">\(g\in G\)</span>，<span class="math inline">\(g\)</span> 把 <span class="math inline">\(u\)</span> 映射为 <span class="math inline">\(v\)</span>。</p><h1 id="这些图是怎么画出来的">这些图是怎么画出来的？</h1><p>这些多胞体看起来样子大不相同，但它们都可以用同一种方法计算出来，叫做<a href="https://en.wikipedia.org/wiki/Wythoff_construction">Wythoff构造法</a>，也称万花筒构造法。它的原理跟我们小时候玩的万花筒的原理是一样的：在空间中放置若干过原点的反射平面（镜子），镜面之间的夹角是精心设计好的，都形如 <span class="math inline">\(\pi-\pi/p\)</span>，其中 <span class="math inline">\(p\)</span> 为有理数。在空间中选定一个初始顶点<span class="math inline">\(v_0\)</span>，将 <span class="math inline">\(v_0\)</span>关于这些镜子反复作反射变换，得到的全部镜像就是多胞体的顶点。如果 <span class="math inline">\(v_0\)</span> 关于第 <span class="math inline">\(i\)</span> 面镜子反射后得到的镜像是 <span class="math inline">\(v_1\)</span>，则 <span class="math inline">\((v_0,v_1)\)</span> 构成一条类型为 <span class="math inline">\(i\)</span>的边，我们把它以及在对称群作用下同轨道的所有边都染成 <span class="math inline">\(i\)</span> 号色。如果 <span class="math inline">\(v_0\)</span> 先关于镜面 <span class="math inline">\(i\)</span> 作反射，再关于镜面 <span class="math inline">\(j\)</span>作反射，则由于两个反射变换的复合是一个旋转变换，<span class="math inline">\(v_0\)</span>实际上是绕着某个面的中心和原点的连线作了一次旋转，旋转的角度为 <span class="math inline">\(2\pi/m\)</span> （假设镜面 <span class="math inline">\(i\)</span> 和镜面 <span class="math inline">\(j\)</span> 的法向量夹角是 <span class="math inline">\(\pi-\pi/m\)</span>），重复此旋转 <span class="math inline">\(m\)</span> 次即可得到多胞体的一个类型为 <span class="math inline">\((i,j)\)</span>的面，我们把它在对称群作用下同轨道的所有面都染成同一颜色。</p><p>这里的关键问题有两个：</p><ol type="1"><li>对于不同的均匀多胞体，应该如何放置这些镜面，并选择初始顶点？</li><li>摆好镜面和初始顶点以后，怎样不重复不遗漏地计算初始顶点的所有镜像？</li></ol><p>第一个问题的答案叫做 <a href="https://en.wikipedia.org/wiki/Coxeter%E2%80%93Dynkin_diagram">Coxeter-Dynkin图</a>，Coxeter-Dynkin图是一个带标记信息的无向图，它编码了多胞体的全部信息，即只要知道了多胞体对应的Coxeter-Dynkin 图，就可以求出该多胞体的所有数据（仅缩放大小和在空间中的摆放位置除外）。每个均匀多胞体都有一个Coxeter-Dynkin 图与之对应，但是不同的 Coxeter-Dynkin图可能描述的是相同的多胞体。</p><p>比如正方体的 Coxeter-Dynkin 图为：</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="200"></p><p>我们来解释这个图的含义：</p><p>在一个 Coxeter-Dynkin图中，每个顶点代表一面镜子，在上图中有三个顶点，所以有三面镜子。将这三面镜子从左到右依次记作<span class="math inline">\(m_0, m_1,m_2\)</span>，顶点之间的边记录了镜子间的夹角：</p><ol type="1"><li>若两个镜面之间的夹角为 <span class="math inline">\(\pi/2\)</span>则它们之间没有边相连。</li><li>若两个镜面之间的夹角为 <span class="math inline">\(\pi-\pi/3\)</span>则它们之间用一条无标记的边相连。</li><li>若两个镜面之间的夹角为 <span class="math inline">\(\pi-\pi/m\)</span> (<span class="math inline">\(m\)</span> 为有理数且 <span class="math inline">\(m&gt;2, m\ne3\)</span>)，则它们之间用一条标号为<span class="math inline">\(m\)</span> 的边相连。</li></ol><p>此外用圈出的镜面来标记初始顶点的位置，<strong>一个镜面被圈出当且仅当初始顶点不在这个镜面上</strong>。</p><p>从而在正方形的情形 <span class="math inline">\(\langlem_0,m_1\rangle=\pi-\pi/4\)</span>，<span class="math inline">\(\langlem_1,m_2\rangle=\pi-\pi/3\)</span>，<span class="math inline">\(\langlem_0,m_2\rangle=\pi/2\)</span>。初始顶点落在 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 上但是不属于 <span class="math inline">\(m_0\)</span>。</p><p>于是这三面镜子可以这样摆放：</p><ol type="1"><li>镜子 <span class="math inline">\(m_0\)</span> 的法向量可以随意，比如<span class="math inline">\(n_0=(1, 0, 0)\)</span>。</li><li>镜子 <span class="math inline">\(m_1\)</span> 的法向量 <span class="math inline">\(n_1\)</span> 与 <span class="math inline">\(n_0\)</span> 夹角为 <span class="math inline">\(3\pi/4\)</span>，于是 <span class="math inline">\(n_1\)</span> 可以取为 <span class="math inline">\((\cos\dfrac{3\pi}{4}, \sin\dfrac{3\pi}{4},0)\)</span>。</li><li>镜子 <span class="math inline">\(m_2\)</span> 的法向量 <span class="math inline">\(n_2\)</span> 与 <span class="math inline">\(n_0\)</span> 垂直，所以 <span class="math inline">\(n_2\)</span> 形如 <span class="math inline">\((0,y_3,z_3)\)</span>，它与 <span class="math inline">\(n_1\)</span> 夹角是 <span class="math inline">\(2\pi/3\)</span>，所以 <span class="math inline">\(y_3\sin\dfrac{3\pi}{4}=\cos\dfrac{2\pi}{3}\)</span>，再结合 <span class="math inline">\(n_2\)</span> 是单位向量，<span class="math inline">\(z_3=\sqrt{1-y_3^2}\)</span>，解出 <span class="math inline">\(y_3, z_3\)</span> 即可。</li></ol><p>要选择一个落在 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 上但是不落在 <span class="math inline">\(m_0\)</span> 上的初始点 <span class="math inline">\(v_0\)</span>，我们可以让 <span class="math inline">\(v_0\)</span> 到平面 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 的距离为 0，到平面 <span class="math inline">\(m_0\)</span> 的距离为 1，即</p><p><span class="math display">\[\langle v_0, n_0\rangle=1,\quad \langlev_0, n_1\rangle=0,\quad\langle v_0, n_2\rangle=0.\]</span></p><p>求解这个线性方程组即可。</p><p>我们前面提到过，要使得初始顶点的所有镜像恰好构成一个均匀多胞体，镜子之间的夹角必须精心设置，这实际上只有有限种可能。换句话说，只有有限个Coxeter-Dynkin 图可以给出 3D/4D 的均匀多胞体。在 <a href="https://en.wikipedia.org/wiki/Uniform_polytope">维基百科</a>上完整的列出了每种均匀多胞体对应的 Coxeter-Dynkin图，这里就不再专门列举了，但是特别指出两点：</p><ol type="1"><li>Coxeter-Dynkin图的标号完全决定了多胞体的对称性，而初始顶点的位置则决定了多胞体的截断类型。</li><li>对偶的多胞体具有相同的 Coxeter-Dynkin图，只不过要把边的标号从右到左反过来。比如正八面体和正方体的Coxeter-Dynkin 图是一样的，但是边的标号是 (3, 4)。</li></ol><p>第二个问题的答案叫做 Todd-Coxeter算法，展开讲的话比较复杂，我们单列一节专门谈谈。</p><h1 id="有限表现群和-todd-coxeter-算法">有限表现群和 Todd-Coxeter算法</h1><p>怎样求出初始顶点在所有镜子中的镜像？有个简单的办法：只要反复地将初始顶点关于每个镜面作反射，算出得到的镜像点的坐标，并与之前得到的点的坐标相比较（浮点数比较需要在一定的误差范围内考虑），直到不再有新的镜像点出现为止，不就得到全部顶点集吗？这个方法确实可行，但是既笨又丑陋：它完全没有用到多胞体具有对称性这一事实！</p><p>这个程序采用的是基于符号计算的途径，这个方法可以精准地得出所有顶点/边/面的信息，代价就是涉及的数学略复杂。我们先回忆一下群在集合上的作用的轨道—稳定化子定理：</p><div id="-----------------------------" class="unnumbered statement sta____________ plain"><p><span class="statement-heading"><span class="statement-label">轨道 —稳定化子定理</span>.</span><span class="statement-spah"> </span>设群<span class="math inline">\(G\)</span> 传递地作用在集合 <span class="math inline">\(S\)</span> 上，设 <span class="math inline">\(x\inS\)</span> 的稳定化子群是 <span class="math inline">\(H\)</span>，则集合<span class="math inline">\(S\)</span> 与 <span class="math inline">\(G/H\)</span> 中的右陪集之间有一一对应：<span class="math inline">\(x\cdot g\leftrightarrow Hg\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>和一般的约定不同，这里群在集合上的作用为作用在右边，主要是为了编程方便，实际上左边右边都一样。</p></div><p>这个定理告诉我们，如果群 <span class="math inline">\(G\)</span>传递地作用在一个集合 <span class="math inline">\(S\)</span> 上，而且对<span class="math inline">\(S\)</span> 中某个元素 <span class="math inline">\(x\)</span> 我们知道了它的稳定化子群 <span class="math inline">\(H\)</span>，则只要对 <span class="math inline">\(G/H\)</span> 的每个陪集代表元 <span class="math inline">\(g\)</span>，将 <span class="math inline">\(g\)</span> 作用在 <span class="math inline">\(x\)</span> 上就可以得到整个 <span class="math inline">\(S\)</span>。</p><p>于是给定一个均匀多胞体 <span class="math inline">\(P\)</span>，要求出其全部顶点集合，我们只要：</p><ol type="1"><li>根据 <span class="math inline">\(P\)</span> 的 Coxeter-Dynkin图确定其对称群 <span class="math inline">\(G\)</span> 和初始顶点 <span class="math inline">\(v_0\)</span>。</li><li>定出 <span class="math inline">\(v_0\)</span> 的稳定化子群 <span class="math inline">\(H\)</span> 并求出 <span class="math inline">\(G/H\)</span> 的一组陪集代表元。</li><li>将 <span class="math inline">\(G/H\)</span> 中的每个陪集代表元作用在<span class="math inline">\(v_0\)</span> 上即得 <span class="math inline">\(P\)</span> 的全部顶点。</li></ol><p>我们仍然以正方体为例来讲解：正方体的 Coxeter-Dynkin 图是</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="200"></p><p>仍然记三个镜面为 <span class="math inline">\(m_0,m_1,m_2\)</span>，其法向量分别为 <span class="math inline">\(n_0,n_1,n_2\)</span>，设 <span class="math inline">\(\rho_0,\rho_1,\rho_2\)</span>分别是关于它们的反射变换，<span class="math inline">\(\rho_i\)</span>对应的矩阵为 <span class="math inline">\(M_i=I-2n_in_i^T\)</span>（见 <a href="https://en.wikipedia.org/wiki/Householder_transformation">Householder变换</a>）。</p><p>正方体的对称群 <span class="math inline">\(G\)</span> 由 <span class="math inline">\(\rho_0,\rho_1,\rho_2\)</span>这三个基本反射生成，其表现为： <span class="math display">\[G =\langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span>这是因为反射的平方总是恒等变换，所以 <span class="math inline">\(\rho_i^2=1\)</span>。<span class="math inline">\(\rho_0,\rho_1\)</span> 是两个夹角为 <span class="math inline">\(3\pi/4\)</span> 的反射，所以 <span class="math inline">\(\rho_0\rho_1\)</span> 是一个角度为 <span class="math inline">\(3\pi/2\)</span> 的旋转，旋转轴为 <span class="math inline">\(m_0\)</span> 和 <span class="math inline">\(m_1\)</span> 的交线，从而 <span class="math inline">\((\rho_0\rho_1)^4=1\)</span>。<span class="math inline">\(\rho_1\rho_2,\rho_0\rho_2\)</span>的情形是类似的。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>利用 Todd-Coxeter 算法 （后面有解释） 不难求出这个群包含 48个元素，罗列如下： <span class="math display">\[\begin{array}{lll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{0}&amp;\rho_{1}&amp;\rho_{0}\rho_{2}\\\rho_{2}&amp;\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\end{array}\]</span> 由于在正方形的 Coxeter-Dynkin 图中只有镜面 <span class="math inline">\(m_0\)</span> 是被圈出的，即初始顶点 <span class="math inline">\(v_0\)</span> 落在 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 上，但不属于 <span class="math inline">\(m_0\)</span>，所以反射 <span class="math inline">\(\rho_1,\rho_2\)</span> 保持 <span class="math inline">\(v_0\)</span> 不动，<span class="math inline">\(\rho_0\)</span> 将 <span class="math inline">\(v_0\)</span> 映射为其关于 <span class="math inline">\(m_0\)</span> 的镜像，于是 <span class="math inline">\(v_0\)</span> 的稳定化子群是 <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a><span class="math display">\[H=\langle \rho_1, \rho_2\ |\\rho_1^2=\rho_2^2=(\rho_1\rho_2)^3=e\rangle.\]</span> 显然 <span class="math inline">\(H\)</span> 就是二面体群 <span class="math inline">\(D_3\)</span>，所以 <span class="math inline">\(|H|=6\)</span>，从而 <span class="math inline">\(|G/H|=8\)</span>。利用 Todd-Coxeter算法可得其一组右陪集代表元为 <span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span> 将它们作用在 <span class="math inline">\(v_0\)</span>上即可得到正方体的 8 个顶点。例如 <span class="math inline">\(\rho_0\rho_1\)</span> 作用在 <span class="math inline">\(v_0\)</span> 上为 <span class="math display">\[v_0(\rho_0\rho_1)=(v_0\rho_0)\rho_1=(v_0M_0)\rho_1=v_0M_0M_1.\]</span>其中 <span class="math inline">\(v_0\)</span> 写成行向量的形式，每个<span class="math inline">\(M_i\)</span> 是对称矩阵。</p><p>计算边/面/胞腔的原理是类似的，但考虑的细节要多一些。比如我们想求出所有关于第<span class="math inline">\(i\,(i=0,1,2)\)</span> 个镜面 <span class="math inline">\(m_i\)</span> 反射生成的类型为 <span class="math inline">\(i\)</span> 的边，可以这样做：</p><ol type="1"><li>检查初始顶点 <span class="math inline">\(v_0\)</span> 是否落在 <span class="math inline">\(m_i\)</span>上。如果答案为是，那么关于此镜面的反射保持 <span class="math inline">\(v_0\)</span> 不变，此多面体不含类型 <span class="math inline">\(i\)</span> 的边。否则设 <span class="math inline">\(v_0\)</span> 关于 <span class="math inline">\(m_i\)</span> 的镜像为 <span class="math inline">\(v_1\)</span>，则 <span class="math inline">\((v_0,v_1)\)</span> 构成一条类型为 <span class="math inline">\(i\)</span> 的边<span class="math inline">\(e\)</span>。</li><li>关于 <span class="math inline">\(m_i\)</span> 的反射 <span class="math inline">\(\rho_i\)</span> 把 <span class="math inline">\(v_0\)</span> 和 <span class="math inline">\(v_1\)</span> 互换，从而保持 <span class="math inline">\(e\)</span> 不变。<strong>注意其它任何与 <span class="math inline">\(m_i\)</span> 垂直并且包含初始点 <span class="math inline">\(v_0\)</span> 的镜面反射也会保持 <span class="math inline">\(e\)</span> 不变</strong>。在正方形的情形中，反射<span class="math inline">\(\rho_0\)</span> 互换 <span class="math inline">\(e\)</span> 的两端因而保持 <span class="math inline">\(e\)</span> 不变，此外镜面 <span class="math inline">\(m_0\)</span> 和 <span class="math inline">\(m_2\)</span> 是垂直的，且 <span class="math inline">\(v_0\)</span> 包含在 <span class="math inline">\(m_2\)</span> 中，所以反射 <span class="math inline">\(\rho_2\)</span> 保持 <span class="math inline">\(e\)</span> 上的每个点不变，于是 <span class="math inline">\(e\)</span> 的稳定化子群为 <span class="math inline">\(H=\langle \rho_0,\rho_2 \rangle\)</span>。显然<span class="math inline">\(H\)</span> 同构于 <span class="math inline">\(\mathbb{Z}_2\times\mathbb{Z}_2\)</span>，所以<span class="math inline">\(|H|=4\)</span>，从而 <span class="math inline">\(|G/H|=12\)</span>，即正方体有 12 条边 <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>。</li><li>求出 <span class="math inline">\(G/H\)</span>的一组陪集代表元并作用在 <span class="math inline">\(e\)</span>上得出全部类型为 <span class="math inline">\(i\)</span> 的边。</li></ol><p>求面的情形复杂一些，基本原理是这样的：</p><ol type="1"><li>对 <span class="math inline">\(i\ne j\)</span>，如果初始顶点 <span class="math inline">\(v_0\)</span> 不同时属于镜面 <span class="math inline">\(i\)</span> 和镜面 <span class="math inline">\(j\)</span>，则旋转 <span class="math inline">\(\rho_i\rho_j\)</span> 就可以生成一个面 <span class="math inline">\(f\)</span>。需要注意的是，如果这两个镜面恰好垂直，则必须二者均不包含<span class="math inline">\(v_0\)</span>才能得到一个非退化的面，这个面是个正方形。在正方体的情形，<span class="math inline">\(\rho_0\rho_1\)</span> 可以生成一个面，<span class="math inline">\(\rho_0\rho_2\)</span>（两镜面垂直但只有一个镜面包含<span class="math inline">\(v_0\)</span>）和 <span class="math inline">\(\rho_1\rho_2\)</span>（两镜面均包含 <span class="math inline">\(v_0\)</span>）都不能给出面。</li><li><span class="math inline">\(f\)</span> 的稳定化子群是由 <span class="math inline">\(\rho_i,\rho_j\)</span> 和那些包含 <span class="math inline">\(v_0\)</span> 且与 <span class="math inline">\(m_i,m_j\)</span>均垂直的镜面反射生成。在正方形的情形是 <span class="math inline">\(H=\langle \rho_0,\rho_1 \rangle\)</span> <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>，显然 <span class="math inline">\(H\)</span> 同构于二面体群 <span class="math inline">\(D_8\)</span>，因此 <span class="math inline">\(|H|=8\)</span>，<span class="math inline">\(|G/H|=6\)</span>，即正方体有 6 个面。</li></ol><p>总之关键的步骤都是给定群 <span class="math inline">\(G\)</span>和某个子群 <span class="math inline">\(H\)</span>，求 <span class="math inline">\(G/H\)</span> 的一组陪集代表元。</p><p>这里用到的算法叫做 <a href="https://en.wikipedia.org/wiki/Todd%E2%80%93Coxeter_algorithm">Todd-Coxeter算法</a>。</p><p>Todd-Coxeter算法在许多抽象代数或者群论的教材都有，用到的数学知识并不复杂。但完整描述并证明一份程序实现的细节还是很费功夫的，恐怕要好几页纸才能说清楚。限于篇幅，我这里仅用正方体的情形为例说明算法的步骤，具体的证明和更多的细节读者请参考</p><blockquote><p>Handbook of Computational Group Theory, Holt, D., Eick, B., O’Brien,E.</p></blockquote><p>中的 coset enumeration 一章。我个人认为这是讲解 Todd-Coxeter算法最棒的文献。</p><p>Todd-Coxeter 算法非常类似玩数独游戏，这里要填的表是一个变化的二维数组<span class="math inline">\(T\)</span>，<span class="math inline">\(T\)</span> 的行 <span class="math inline">\(i\)</span> 代表第 <span class="math inline">\(i\)</span> 个右陪集，<span class="math inline">\(T\)</span> 的列 <span class="math inline">\(j\)</span> 代表第 <span class="math inline">\(j\)</span> 个生成元 <span class="math inline">\(\rho_j\)</span>，<span class="math inline">\(T[i][j]\)</span> 的值等于 <span class="math inline">\(\rho_j\)</span> 右乘以第 <span class="math inline">\(i\)</span>个陪集后得到的陪集。初始时，我们知道肯定有一个陪集，就是 <span class="math inline">\(H\)</span>自身，还有没有其它的陪集我们不清楚。算法的主要流程就是根据 <span class="math inline">\(G\)</span> 和 <span class="math inline">\(H\)</span>的表现中包含的关系来发现新的陪集并填入表中，直到无法找到新的陪集为止。最终得到的<span class="math inline">\(T\)</span> 实际上是 <span class="math inline">\(G/H\)</span> 的 schreier 图的邻接矩阵，它记录了<span class="math inline">\(G/H\)</span> 的陪集间的乘法关系，由 <span class="math inline">\(T\)</span> 出发我们很容易求出这些陪集的 word表示。</p><div class="unnumbered statement example definition"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>设 <span class="math inline">\(G\)</span>是正方体的对称群，其表现为 <span class="math display">\[G =\langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span>子群 <span class="math inline">\(H=\langle \rho_1,\rho_2\rangle\)</span> 是初始顶点的稳定化子群，求 <span class="math inline">\(G/H\)</span> 的一组右陪集代表元。</p></div><p>我们先罗列一下这个数独游戏已知的关系：</p><p><strong>已知关系</strong>：</p><ol type="1"><li>对 <span class="math inline">\(H\)</span> 的任何生成字 <span class="math inline">\(w\)</span> 有 <span class="math inline">\(H\cdotw=H\)</span>，即 <span class="math inline">\(H\rho_1=H\rho_2=H\)</span>。注意此关系仅要求对<span class="math inline">\(H\)</span> 成立。</li><li>对任何陪集 <span class="math inline">\(K\)</span> 和 <span class="math inline">\(G\)</span> 的任何生成关系 <span class="math inline">\(r\)</span> 有 <span class="math inline">\(K\cdotr=K\)</span>，即 <span class="math inline">\(K\rho_i^2=K,i=0,1,2\)</span> 以及 <span class="math inline">\(K(\rho_0\rho_1)^4=K(\rho_1\rho_2)^3=K(\rho_0\rho_2)^2=K\)</span>。注意此关系要求对所有陪集成立。</li></ol><p>这些关系可以存储在两个列表里面，每个关系用一个数组表示。</p><p>第一个列表存储的是 <span class="math inline">\(H\)</span>的生成字，即</p><blockquote><p><strong><span class="math inline">\(H\)</span>的生成字列表</strong>：</p><ol start="0" type="1"><li>(1,)</li><li>(2,)</li></ol></blockquote><p>第二个列表存储的是 <span class="math inline">\(G\)</span>的生成关系，即</p><blockquote><p><strong><span class="math inline">\(G\)</span>的生成关系列表</strong>：</p><ol start="2" type="1"><li>(0, 0)</li><li>(1, 1)</li><li>(2, 2)</li><li>(0, 1, 0, 1, 0, 1, 0, 1)</li><li>(1, 2, 1, 2, 1, 2)</li><li>(0, 2, 0, 2)</li></ol></blockquote><p>其中每条关系前面的数字是我们加上的编号以便于称呼。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在非 Coxeter 群的情形还要把每个生成元的逆也作为生成元加入，其在<span class="math inline">\(T\)</span> 中也占据一列，所以实际上 <span class="math inline">\(T\)</span> 的列的个数要 <span class="math inline">\(\times2\)</span>。但是在 Coxeter群的情形每个生成元是 2阶的，其逆元素等于自身，所以不需要额外考虑逆元素。</p></div><p>初始时刻表格 <span class="math inline">\(T\)</span> 是这样的：</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>其中 <span class="math inline">\(H_0\)</span> 代表 <span class="math inline">\(H\)</span> 对应的陪集。程序首先验证 <span class="math inline">\(H_0\)</span> 所在的行满足第一个关系列表 （<span class="math inline">\(H\)</span>的生成字列表，随后此列表可以被丢弃），然后依次从上到下扫描 <span class="math inline">\(T\)</span> 的每一行，假设当前扫描的是第 <span class="math inline">\(i\)</span> 行，对应的陪集为 <span class="math inline">\(H_i\)</span>，程序验证确保对第二个列表 （<span class="math inline">\(G\)</span> 的生成关系列表） 中的每条关系 <span class="math inline">\(w\)</span>，<span class="math inline">\(H_i\)</span> 满足 <span class="math inline">\(H_iw=H_i\)</span>，这个过程中可能发现新的陪集，也可能发现已有的某些陪集是重复的，也有可能需要强行定义新的陪集来使得这个验证能够完成。</p><hr><p>我们来开始扫描 <span class="math inline">\(H_0\)</span>所在的行：首先检查第一个列表中的关系，<strong>这个列表仅在扫描 <span class="math inline">\(H_0\)</span>时使用一次，扫描完就可以丢弃</strong>。</p><p>(1). 对第 0 条关系 <span class="math inline">\(H_0\rho_1=H_0\)</span>，即 <span class="math inline">\(T[0][1]=0\)</span>。对第 1 条关系 <span class="math inline">\(H_0\rho_2=H_0\)</span>，即 <span class="math inline">\(T[0][2]=0\)</span>，这时 <span class="math inline">\(T\)</span> 变成了</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><p>第一个列表扫描完毕，接下来扫描第二个列表。</p><p>(2). 对第 2 条关系 <span class="math inline">\(H_0\rho_0^2=H_0\)</span>，由于 <span class="math inline">\(H_0\rho_0\)</span> 还不知道，我们将其定义为新陪集<span class="math inline">\(H_1\)</span> 并将 1 填入 <span class="math inline">\(T[0][0]\)</span> 位置，此外还要为 <span class="math inline">\(H_1\)</span> 开辟新的一行：</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>每次定义新陪集时，比如定义 <span class="math inline">\(H_i\rho_j=H_k\)</span>，我们同时自动得到了与之对称的关系<span class="math inline">\(H_k\rho_j=H_i\rho_j^2=H_i\)</span>，因此每次填表时我们都填写一对数字而不是一个，这样可以保证表格<span class="math inline">\(T\)</span> 的 “对称性”。</p></div><p>(3). 第 3 条和第 4 条关系已经满足，继续。</p><p>(4). 第 5 条关系，<span class="math inline">\(H_0\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1=H_0\)</span>，我们已经知道<span class="math inline">\(H_0\rho_0=H_1\)</span> 但是 <span class="math inline">\(H_1\rho_1\)</span> 还不知道，将其定义为 <span class="math inline">\(H_2\)</span>，于是 <span class="math inline">\(T\)</span> 中又添两项，并开辟新的一行给 <span class="math inline">\(H_2\)</span>：</p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>但是 <span class="math inline">\(H_2\rho_0\)</span>还是不知道，所以继续定义 <span class="math inline">\(H_2\rho_0=H_3\)</span>，于是 <span class="math inline">\(T\)</span> 变成</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>于是现在关系变成了</p><p><span class="math display">\[\underbrace{\overbrace{\underbrace{H_0\rho_0}_{=H_1}\,\rho_1}^{=H_2}\,\rho_0}_{=H_3}\,\rho_1\rho_0\rho_1\rho_0\rho_1=H_0.\]</span></p><p>但是 <span class="math inline">\(H_3\rho_1\)</span>还是不知道，你可能会想把它继续定义为新的陪集 <span class="math inline">\(H_4\)</span>，然后继续扫描。<strong>这样做不是不可以，但是每次都定义新陪集会生成大量重复的陪集，导致<span class="math inline">\(T\)</span>增长的非常快，对更复杂的群非常耗费计算资源</strong>。我们采用更聪明的办法：倒着扫描整个关系，即从右到左扫描<span class="math inline">\(H_0\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1=H_0\)</span>这条关系。记住我们现在已经正向 （从左到右） 扫描到了下面的位置： <span class="math display">\[\underbrace{H_0\rho_0\rho_1\rho_0}_{=H_3}\,\rho_1|\rho_0\rho_1\rho_0\rho_1=H_0.\]</span>反向扫描意味着我们把上式左边末尾的 <span class="math inline">\(\rho_0\rho_1\rho_0\rho_1\)</span>挪到右边去，变形为 <span class="math display">\[\underbrace{H_0\rho_0\rho_1\rho_0}_{=H_3}\,\rho_1=\underbrace{H_0\rho_1}_{=H_0}\rho_0\rho_1\rho_0=H_0\rho_0\rho_1\rho_0=H_3.\]</span> 从而 <span class="math inline">\(H_3\rho_1=H_3\)</span>。这样通过反向扫描我们就推断出了<span class="math inline">\(H_3\rho_1\)</span>的值，避免了定义冗余的陪集。按照 Holt 书中的说法这叫做一个deduction。这时 <span class="math inline">\(T\)</span> 为</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在实际的程序实现中，我们总是从关系的两头同时开始扫描，直到它们相遇为止。</p></div><p>(5). 关系 6 已经满足，继续。</p><p>(6). 对关系 7 <span class="math inline">\(H_0\rho_0\rho_2\rho_0\rho_2=H_0\)</span>，从两头扫描我们得到<span class="math display">\[\underbrace{H_0\rho_0}_{=H_1}\,\rho_2=\underbrace{\overbrace{H_0\rho_2}^{=H_0}\rho_0}_{=H_1}.\]</span>即 <span class="math inline">\(H_1\rho_2=H_1\)</span>，我们又得到了一个deduction，从而 <span class="math inline">\(T\)</span> 变成</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>至此对 <span class="math inline">\(H_0\)</span>的扫描全部完成，我们转入扫描 <span class="math inline">\(H_1\)</span>所在的行。</p><hr><p><strong>注意：从现在起至程序结束，我们不再使用第一个列表</strong>。</p><p>下面开始扫描 <span class="math inline">\(H_1\)</span> 所在的行。</p><p>(1). 经检查关系 2, 3, 4, 5 已经满足，继续。</p><p>(2). 对关系 6 有 <span class="math inline">\(H_1\rho_1\rho_2\rho_1\rho_2\rho_1\rho_2=H_1\)</span>，其中<span class="math inline">\(H_1\rho_1=H_2\)</span> 已知但 <span class="math inline">\(H_2\rho_2\)</span> 未知。反向的扫描也会卡在这里：<span class="math display">\[\underbrace{H_1\rho_1}_{=H_2}\rho_2\rho_1=H_1\rho_2\rho_1\rho_2=H_2\rho_2.\]</span>所以我们定义新陪集 <span class="math inline">\(H_2\rho_2=H_4\)</span>，于是 <span class="math inline">\(H_4\rho_1=H_4\)</span>，从而此时 <span class="math inline">\(T\)</span> 为</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr></tbody></table><p>(3). 关系 7 已经满足，从而 <span class="math inline">\(H_1\)</span>检查完毕，接下来开始扫描 <span class="math inline">\(H_2\)</span>的行。</p><hr><p>下面开始扫描 <span class="math inline">\(H_2\)</span> 的行。</p><p>(1). 经检查关系 2, 3, 4, 5, 6 都已经满足，继续。</p><p>(2). 对关系 7 有 <span class="math inline">\(H_2\rho_0\rho_2\rho_0\rho_2=H_2\)</span>，两边同时扫描的结果为：<span class="math display">\[\underbrace{H_2\rho_0}_{=H_3}\rho_2\rho_0=H_2\rho_2=H_4.\]</span>即 <span class="math inline">\(H_3\rho_2\rho_0=H_4\)</span>，但是继续正向扫描<span class="math inline">\(H_3\rho_2\)</span> 不知道，继续反向扫描<span class="math inline">\(H_4\rho_0\)</span> 不知道。定义新陪集 <span class="math inline">\(H_3\rho_2=H_5\)</span>，于是 <span class="math inline">\(H_5\rho_0=H_4\)</span>，我们又可以填入两对 4个数字，此时 <span class="math inline">\(T\)</span> 为：</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">3</td></tr></tbody></table><p><span class="math inline">\(H_2\)</span> 扫描完毕，下面扫描 <span class="math inline">\(H_3\)</span> 的行。</p><hr><p>我把 <span class="math inline">\(H_3, H_4, H_5\)</span>的扫描过程留给你作为练习，<span class="math inline">\(H_3\)</span>扫描结束后你得到的 <span class="math inline">\(T\)</span>应该如下图：</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr></tbody></table><p><span class="math inline">\(H_4\)</span> 扫描结束后你得到的 <span class="math inline">\(T\)</span> 应该如下图：</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><span class="math inline">\(H_5\)</span> 的扫描给不出新的信息。</p><p>扫描 <span class="math inline">\(H_6\)</span> 时，关系 2, 3, 4, 5, 6都已经满足，由关系 7 <span class="math inline">\(H_6\rho_0\rho_2\rho_0\rho_2=H_6\)</span> 可得deduction <span class="math inline">\(H_7\rho_2=H_7\)</span>，于是 <span class="math inline">\(T\)</span> 可以补全为</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td></tr></tbody></table><p>扫描 <span class="math inline">\(H_7\)</span>发现所有关系都已经满足。</p><p>至此 <span class="math inline">\(T\)</span>的空白位置都已经填满，没有新的陪集可以发现，数独游戏结束，这时得到的<span class="math inline">\(T\)</span> 就是 <span class="math inline">\(G/H\)</span> 的最终乘法表。</p><p>由此利用宽度优先搜索不难得出陪集间的关系为： <span class="math display">\[\begin{array}{l}H_0 = H_0\cdot e,\\H_1=H_0\cdot\rho_0,\\H_2=H_1\cdot\rho_1=H_0\cdot\rho_0\rho_1,\\H_3=H_2\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0,\\H_4=H_2\cdot\rho_2=H_0\cdot\rho_0\rho_1\rho_2,\\H_5=H_3\cdot\rho_2=H_0\cdot \rho_0\rho_1\rho_0\rho_2,\\H_6=H_5\cdot\rho_1=H_0\cdot \rho_0\rho_1\rho_0\rho_2\rho_1,\\H_7=H_6\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0\rho_2\rho_1\rho_0.\end{array}\]</span></p><p>从而其一组陪集代表元可以选为 <span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span></p><p>这正是我们前面看到过的。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个例子看似有点长，但还是一个比较简单的例子，其中并没有出现已知陪集重复的情形（Holt的书中称之为coincidence）。这种情形的处理麻烦一些，因为一旦出现重复的陪集，就有可能顺藤摸瓜找到更多重复的陪集。这时就要立刻暂停扫描，流程跳转到处理coincidence：开辟一个栈来存放已知的coincidence，每次弹出一对，将它们合并，然后把新发现的 coincidence压入栈中。</p></div><h1 id="星状多胞体的计算">星状多胞体的计算</h1><p>星状多胞体也可以使用 Wythoff构造法来生成，但是直接套用上面的方法一般是行不通的，我们需要在生成元中加入额外的生成关系。</p><p>这里以 <a href="https://en.wikipedia.org/wiki/Great_dodecahedron">Greatdodecahedron</a> 为例来说明：其 Coxeter-Dynkin 图为</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/coxeter552.svg" width="200"></p><p>于是三面镜子的法向量夹角分别为 <span class="math inline">\(\pi-2\pi/5, \pi/2,\pi-\pi/5\)</span>。如果我们仍然沿用以前的分析，会得出其对称群的表现为<span class="math display">\[K=\langle\tau_0,\tau_1,\tau_2 \|\  \tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=(\tau_0\tau_2)^2=1\rangle.\]</span></p><p>这是一个无限群，而且顶点的稳定化子的商群也是无限的，所以还想按以前的方法计算就行不通了。</p><p>实际上我们只要在生成关系中再加上一条 <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>即可，即对称群的表现为</p><p><span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>注意到我使用了字母 <span class="math inline">\(\tau\)</span>来表示反射，<span class="math inline">\(K\)</span> 表示 Greatdodecahedron的对称群，这个记号选择是有意的。这是怎么回事呢？先看视频：</p><video src="/images/polytopes/great-dodecahedron.mp4" width="480" controls=""></video><p>（请忽略左边错误的 Coxeter 图，这个 ui 界面我改不动）</p><p>由视频可见，Great dodecahedron 与正二十面体 (icosahedron)共用相同的顶点，并且看起来 Great dodecahedron 可以通过在 icosahedron表面挖一些三角形的洞得到。这个结论也可以推广：一般地如果星状多面体的洞是一个有<span class="math inline">\(h\)</span>条边的多边形，则对应的额外生成关系就是 <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^h=1\)</span>。</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/star.png" width="600"></p><p>在上图中，<span class="math inline">\(\Delta ABC\)</span>是正二十面体的基本区域，三个内角分别是 <span class="math inline">\(\angle CAB=\pi/5\)</span>，<span class="math inline">\(\angle CBA=\pi/2\)</span>，<span class="math inline">\(\angle ACB=\pi/3\)</span>，<span class="math inline">\(\rho_0,\rho_1,\rho_2\)</span> 分别是关于弧 <span class="math inline">\(BC, AC, AB\)</span>的反射。正二十面体的对称群的表现为 <span class="math display">\[G =\langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^3=(\rho_1\rho_2)^5=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p>Great dodecahedron 可以这样得到：沿着正二十面体的边从顶点 <span class="math inline">\(Q\)</span> 走到 <span class="math inline">\(A\)</span>，右手边的面是三角形 <span class="math inline">\(\Delta OAQ\)</span>，接下来的第一条边应该是 <span class="math inline">\(AO\)</span>，我们跳过这条边，选择第二条边 <span class="math inline">\(AK\)</span>，到达 <span class="math inline">\(K\)</span> 后继续选择右手边的第二条边，这样绕着<span class="math inline">\(O\)</span> 一圈下来共经过 5条边，它们正好围成 Great dodecahedron的一个面。对正二十面体的其它边也如此操作会得到 Great dodecahedron其它的面。</p><p>像这样对一个多面体，保持它的顶点和边的集合不变，但是每次选择右手边的第<span class="math inline">\(k\)</span>个边走下去绕一圈获得一个面，这样构造新多面体的方法叫做 <strong>Facetting手术</strong>。在我们这个项目中 <span class="math inline">\(k\)</span>总是等于 2。</p><p>我们来导出正二十面体的对称群 <span class="math inline">\(G\)</span>和 Great dodecahedron 的对称群 <span class="math inline">\(K\)</span>之间的关系。</p><p>来看三角形 <span class="math inline">\(\DeltaOAB\)</span>，它的三个内角分别是 <span class="math inline">\(\angleOAB=2\pi/5\)</span>，<span class="math inline">\(\angleOBA=\pi/2\)</span>，<span class="math inline">\(\angleAOB=\pi/5\)</span>，它包含三个与 <span class="math inline">\(\DeltaABC\)</span> 全等的三角形，关于其三条边 <span class="math inline">\(OA,OB,AB\)</span> 的反射分别是 <span class="math inline">\(\tau_1=\rho_1\rho_2\rho_1,\tau_0=\rho_0,\tau_2=\rho_2\)</span><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>。</p><p>Facetting 操作 <span class="math inline">\(\varphi_k\)</span>用群的语言来描述就是（记住 <span class="math inline">\(k=2\)</span>）<span class="math display">\[G=\langle\rho_0,\rho_1,\rho_2\rangle\xrightarrow{\ \varphi_k\}\langle\rho_0,\rho_1(\rho_2\rho_1)^{k-1},\rho_2\rangle=\langle\tau_0,\tau_1,\tau_2\rangle=K.\]</span>一般来说 <span class="math inline">\(K\)</span> 是 <span class="math inline">\(G\)</span> 的子群，但在这里 <span class="math inline">\(G\)</span> 和 <span class="math inline">\(K\)</span> 就是同一个群。我们不解释为什么 <span class="math inline">\(G=K\)</span>，这里只承认这一点，然后借助这个事实来说明<span class="math inline">\(K\)</span> 就是 Great dodecahedron的对称群。</p><p>首先 <span class="math inline">\(\langle \tau_1,\tau_2\rangle=\langle\rho_1,\rho_2\rangle\)</span> 是顶点 <span class="math inline">\(A\)</span> 的稳定化子群，所以 Great dodecahedron和正二十面体的顶点集是一样的。但 <span class="math inline">\(\tau_1\tau_2\)</span> 是一个角度为 144度的旋转，这一点和 <span class="math inline">\(\rho_1\rho_2\)</span>是一个 72 度的旋转不同，所以 Great dodecahedron 的 vertex configure是一个五角星，而不像正二十面体那样是一个五边形。</p><p>其次 <span class="math inline">\(\langle\tau_0,\tau_2\rangle=\langle\rho_0,\rho_2\rangle\)</span>为边 <span class="math inline">\(AQ\)</span> 的稳定化子群，所以 Greatdodecahedron 的边集和正二十面体也是一样的。</p><p>它俩的区别在于边组成面的方式不一样。<span class="math inline">\(\langle\tau_0,\tau_1\rangle\)</span> 是 Greatdodecahedron 面的稳定化子群，注意到 <span class="math inline">\(\tau_1\)</span> 是关于 <span class="math inline">\(AO\)</span> 的反射，它会把 <span class="math inline">\(AQ\)</span> 映射为 <span class="math inline">\(AK\)</span>，这正对应选择第 <span class="math inline">\(k\)</span> 条边的操作。<span class="math inline">\(\tau_0\tau_1\)</span> 是一个绕着顶点 <span class="math inline">\(O\)</span> 的角度为 <span class="math inline">\(2\pi/5\)</span> 的旋转，所以 <span class="math inline">\(AQ\)</span> 在子群 <span class="math inline">\(\langle \tau_0,\tau_1\rangle\)</span> 作用下会绕<span class="math inline">\(O\)</span> 转一圈，正对应 Facetting操作得到的一个面。</p><p>我们来找出 <span class="math inline">\(\tau_0,\tau_1,\tau_2\)</span>之间隐藏的一条生成关系：</p><p>注意到 <span class="math inline">\(\tau_1\tau_2\tau_1=\tau_1\rho_2\tau_1\)</span>是关于 <span class="math inline">\(AP\)</span> 的反射，它和 <span class="math inline">\(\tau_0=\rho_0\)</span> 的复合是绕着 <span class="math inline">\(P\)</span> 点角度为 <span class="math inline">\(2\pi/3\)</span> 的旋转，所以 <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>。加入这个额外的生成关系得到的就是<span class="math inline">\(K\)</span> 的正确的表现： <span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>所以我们就可以对 <span class="math inline">\(K\)</span>照搬之前的绘制步骤了。</p><p>这个额外的生成关系其实也有背后的解释：对 Faceting手术得到的新多面体再进行一次 Faceting 手术是可以回到原来的多面体的。对great dodecahedron每次沿着它的边，选择当前离开的边的右手第二个边走下去，即从 <span class="math inline">\(Q\)</span> 走到 <span class="math inline">\(A\)</span> 时，不是选择 <span class="math inline">\(AK\)</span> 继续走下去，而是选择 <span class="math inline">\(AO\)</span>，这样走下去又会得到正二十面体的三角形的面，这对应的就是额外的生成关系中的指数3。</p><p>这一点从群上也可以得到验证。</p><p><span class="math display">\[K=\langle\tau_0,\tau_1,\tau_2\rangle\xrightarrow{\ \varphi_2\}\langle\tau_0,\tau_1\tau_2\tau_1,\tau_2\rangle=\langle\rho_0,\rho_2\rho_1\rho_2,\rho_2\rangle=G.\]</span></p><blockquote><p>关于 Faceting 手术可以在 McMullen 和 Schulte 所著的 <a href="https://doi.org/10.1017/CBO9780511546686">Abstract RegularPolytopes</a> 一书中找到。</p></blockquote><h1 id="snub-cube-的计算">Snub cube 的计算</h1><p>如果你理解了上面的内容，snub 多面体的情形也是不难理解的。我以 snubcube 来说明：</p><p>Snub cube 和 cube 的区别在于它的对称群只包含旋转，我们已经看到 cube的对称群 <span class="math inline">\(G\)</span> 的表现为 <span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span>它有 48 个元素，其中 24 个是旋转。这些旋转可以由 <span class="math inline">\(r_0=\rho_0\rho_1,r_1=\rho_1\rho_2,r_2=\rho_0\rho_2\)</span> 生成 （由于 <span class="math inline">\(r_0r_1=r_2\)</span> 因此实际上可以由 <span class="math inline">\(r_0\)</span> 和 <span class="math inline">\(r_1\)</span> 生成）。这 24 个旋转就构成了 Snubcube 的对称群 <span class="math inline">\(\widetilde{G}\)</span>。</p><p>不难写出 <span class="math inline">\(\widetilde{G}\)</span> 的表现为<span class="math display">\[\widetilde{G}=\langle r_0,r_1\ |\r_0^4=r_1^3=(r_0r_1)^2=1\rangle.\]</span></p><p>利用 Todd-Coxeter 算法不难求出这个群的所有 24 个元素：</p><p><span class="math display">\[\begin{array}{lll}e&amp;r_{0}&amp;r_{0}r_{0}\\r_{0}r_{0}r_{0}&amp;r_{1}&amp;r_{1}r_{1}\\r_{0}r_{1}&amp;r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{1}\\r_{0}r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}\\r_{1}r_{0}r_{0}&amp;r_{1}r_{0}r_{0}r_{0}&amp;r_{1}r_{1}r_{0}\\r_{1}r_{1}r_{0}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}\\r_{0}r_{0}r_{1}r_{1}r_{0}&amp;r_{1}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}r_{0}r_{1}r_{1}\\r_{1}r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{1}r_{0}r_{0}r_{1}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}r_{1}\end{array}\]</span></p><p>注意在 snub 的情形初始顶点 <span class="math inline">\(v_0\)</span>不属于任何镜面，所以其稳定化子群只有单位元 1，即每个 <span class="math inline">\(g\in\widetilde{G}\)</span> 把 <span class="math inline">\(v_0\)</span> 变换为不同的顶点。将它们作用在 <span class="math inline">\(v_0\)</span> 上即得 snub cube 的所有顶点。</p><p>我们现在利用轨道—稳定化子的理论来求 snub cube 的边。snub cube的边也是分类型的，每个 <span class="math inline">\(r_i(i=0,1,2)\)</span>作用在 <span class="math inline">\(v_0\)</span> 上可得一个类型为 <span class="math inline">\(i\)</span> 的边 <span class="math inline">\(e_i=(v_0, v_0\cdot r_i)\)</span> <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>，我们来定出 <span class="math inline">\(e_i\)</span> 的稳定化子群 <span class="math inline">\(H\)</span>。</p><p>首先注意到任何 <span class="math inline">\(g\in G\)</span> 如果保持<span class="math inline">\(e_i\)</span>不变，则只有两种可能，要么它保持 <span class="math inline">\(e_i\)</span> 上每个点不变，要么它将 <span class="math inline">\(e_i\)</span> 关于其中点进行翻转。这一点对 <span class="math inline">\(g\in\widetilde{G}\)</span> 自然也成立。所以若<span class="math inline">\(g\in\widetilde{G}\)</span> 保持 <span class="math inline">\(e_i\)</span> 不变，则要么 <span class="math inline">\(v_0g = v_0, v_0r_i=v_0r_ig\)</span>，要么 <span class="math inline">\(v_0g = v_0r_i,v_0r_ig=v_0\)</span>。前一种情形说明<span class="math inline">\(g\)</span> 属于 <span class="math inline">\(v_0\)</span>的稳定化子群从而只能是单位元；后一种情形说明 <span class="math inline">\(r_ig\)</span> 和 <span class="math inline">\(r_ig^{-1}\)</span> 都属于 <span class="math inline">\(v_0\)</span> 的稳定化子群从而 <span class="math inline">\(r_ig=r_ig^{-1}=1\)</span>，即 <span class="math inline">\(g=r_i\)</span> 且 <span class="math inline">\(r_i^2=1\)</span>。总之我们证明了只有在 <span class="math inline">\(r_i^2=1\)</span> 时 <span class="math inline">\(e_i\)</span>才有非平凡的稳定化子群，这时稳定化子群是二阶循环群 <span class="math inline">\(\langle r_i\rangle\)</span>。</p><p>于是 snub cube 的类型为 <span class="math inline">\(r_0\)</span> 和<span class="math inline">\(r_1\)</span> 的边的个数都是 24/1=24个；类型为 <span class="math inline">\(r_2\)</span> 的边的个数为 24/2=12个，从而 snub cube 总共有 24+24+12=60 条边。</p><p>snub cube 的面可以这样求：由于 <span class="math inline">\(r_0^4=1\)</span> 所以 <span class="math inline">\(r_0\)</span> 可以生成一个正四边形的面，类似地由于<span class="math inline">\(r_1^3=1\)</span> 所以 <span class="math inline">\(r_1\)</span> 可以生成一个正三角形的面，而由于<span class="math inline">\(r_2^2=1\)</span> 所以 <span class="math inline">\(r_2\)</span>生成的面是退化的。这种由单个旋转生成的面的稳定化子群是很好求的：若 <span class="math inline">\(g\)</span> 保持 <span class="math inline">\(r_i\)</span> 生成的面不变，则其必然把某个形如<span class="math inline">\(v_0r_i^k\)</span> 的顶点变换为 <span class="math inline">\(v_0\)</span>，即 <span class="math inline">\(g=r_i^{-k}\)</span> 是 <span class="math inline">\(r_i\)</span> 的某次幂，反之易见 <span class="math inline">\(r_i\)</span>的任何幂都保持此面不变，所以其稳定化子群即为循环群 <span class="math inline">\(\langle r_i\rangle\)</span>。</p><p>于是 <span class="math inline">\(r_0\)</span> 生成的面的个数为24/4=6，<span class="math inline">\(r_1\)</span> 生成的面的个数为24/3=8，<span class="math inline">\(r_2\)</span>生成的面都退化因而个数是 0，总计 14 个面。</p><p>小心！我们还漏掉了一种三角面，它源自 <span class="math inline">\(r_0r_1=r_2\)</span> 这个关系。考虑 <span class="math inline">\(\{v_0, v_0r_1, v_0r_2\}\)</span>这三个顶点，这三个顶点中 <span class="math inline">\((v_0,v_0r_1)\)</span> 构成一条类型为 <span class="math inline">\(r_1\)</span> 的边， <span class="math inline">\((v_0,v_0r_2)\)</span> 构成一条类型为 <span class="math inline">\(r_2\)</span> 的边，而 <span class="math inline">\(r_0r_1=r_2\)</span> 这个关系告诉我们 <span class="math display">\[(v_0, v_0r_0)\xrightarrow{\ r_1\ }(v_0r_1,v_0r_0r_1) = (v_0r_1, v_0r_2).\]</span> 即 <span class="math inline">\((v_0r_1, v_0r_2)\)</span> 是一条类型为 <span class="math inline">\(r_0\)</span> 的边，它是由将 <span class="math inline">\(r_1\)</span> 作用在类型为 <span class="math inline">\(r_0\)</span> 的初始边 <span class="math inline">\((v_0, v_0r_0)\)</span> 上得到的，于是 <span class="math inline">\(\{v_0, v_0r_1, v_0r_2\}\)</span>构成一个三角形的三个顶点，其三条边在对称群作用下属于不同的轨道，所以这个三角形的稳定化子必然保持每条边不变，从而只能是恒等元，从而这样的面有24/1=24 个。</p><p>于是 snub cube 一共有 14+24=38 个不同的面。</p><p>这里介绍的方法也适用于其它的 snub 多面体以及 snub 24-cell。</p><h1 id="多面体的顶点投影到-coxeter-平面">多面体的顶点投影到 Coxeter平面</h1><p>项目中还实现了一个<code>draw_on_coxeter_plane(*args, **kwargs)</code>方法，用于绘制将多面体的顶点投影到其 Coxeter平面上后得到的图案，例如下图显示的是将 600-cell 的 120 个顶点投影到其Coxeter 平面上的结果：</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/600-cell.svg" width="350"></p><p>你可以和 <a href="https://en.wikipedia.org/wiki/600-cell#2D_projections">wikipedia上的效果</a> 比较一下。</p><h1 id="附录手算-todd-coxeter">附录：手算 Todd-Coxeter</h1><p>对简单的群，Todd-Coxeter 算法完全可以用手算快速得出结果。我非常推荐Borcherds 的视频，他的演示非常精彩：</p><iframe width="560" height="315" src="https://www.youtube.com/embed/BHezLvEH1DU?si=fw7X2z37wZEYcIG-" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe><p>仿照 Borcherds 的方法，前面正方形的例子可以很快写出来：</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/todd-coxeter.svg" width="600"></p><p>我来解释一下步骤：我们将画出一个有限图，图的每个顶点代表 <span class="math inline">\(H=\langle s_0,s_1\rangle\)</span>的一个陪集，每个顶点有三条不同颜色的边，表示此陪集在生成元 <span class="math inline">\(s_i\)</span> 作用下的结果。</p><ol type="1"><li>首先我们在空白纸上画出第一个顶点，它对应的陪集是 <span class="math inline">\(H=H_0\)</span> 自身。<span class="math inline">\(H\)</span> 包含 <span class="math inline">\(s_0,s_1\)</span>，所以红、绿边是自边。<span class="math inline">\(s_2\)</span>，即蓝色的边，会把它映射为一个新顶点<span class="math inline">\(H_1\)</span>。</li><li>从 <span class="math inline">\(H_0\)</span>出发，利用红蓝交换，可得红色保持 <span class="math inline">\(H_1\)</span> 不动。但是绿蓝不交换，所以绿色将<span class="math inline">\(H_1\)</span> 映射为新顶点 <span class="math inline">\(H_2\)</span>。</li><li><span class="math inline">\((\text{绿蓝})^3=1\)</span>，即 <span class="math inline">\(H_2\xrightarrow{(\text{绿蓝})^3}H_2\)</span>，所以<span class="math display">\[H_2\xrightarrow{\text{绿}}H_1\xrightarrow{\text{蓝}} H_0\xrightarrow{\text{绿}}H_0\xrightarrow{\text{蓝}} H_1\xrightarrow{\text{绿}}H_2\xrightarrow{\text{蓝}} H_2.\]</span> 所以蓝色保持 <span class="math inline">\(H_2\)</span> 不动。红绿不交换，所以红色将 <span class="math inline">\(H_2\)</span> 映射为新顶点 <span class="math inline">\(H_3\)</span>。</li><li>仿照上面的分析继续下去，可以发现到 <span class="math inline">\(H_5\)</span> 时，三种颜色的边不会给出新顶点。所以<span class="math inline">\(\{H_0,\ldots,H_5\}\)</span> 就是 <span class="math inline">\(G/H\)</span> 的全部陪集。</li></ol><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>你可能要问了，你怎么就敢肯定这个群的表现恰好就包含这些生成关系，而不会包含其它什么隐藏的生成关系呢？这是个好问题，回答起来并不容易，答案是对凸的多胞体而言这些生成关系确实给出了其对称群的一个表现，但是对星状多面体而言则未必。事实上星状多面体都和某个凸多面体有相同的对称群，但是群表现是不一样的（需要补上额外的生成关系）。这其中的根本原因是凸多面体的镜面法向量之间的夹角都形如<span class="math inline">\(\pi-\pi/m\)</span>，这里 <span class="math inline">\(m\)</span>是整数，这保证了所有镜面围成的凸锥构成一个基本区域。而星状多面体的镜面所夹的二面角至少有一个形如<span class="math inline">\(\pi-\pi/p\)</span>，其中 <span class="math inline">\(p\)</span>是一个非整数的有理数，这时所有镜面围成的凸锥并不是基本区域，在对称群的作用下这个凸锥会被覆盖若干次。见Vinberg 的文章 “Discrete linear groups generated by reflections” 和Coxeter 的著作 “The beauty of geometry: twelve essays”.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>以本文介绍的知识，这里似乎应该说 <span class="math inline">\(H\)</span> 保持 <span class="math inline">\(v_0\)</span> 不变，从而 <span class="math inline">\(v_0\)</span> 的稳定化子群包含 <span class="math inline">\(H\)</span>，怎么能断言 <span class="math inline">\(v_0\)</span> 的稳定化子群就等于 <span class="math inline">\(H\)</span> 呢？这实际上是 Coxeter 群的一个性质：在Coxeter 群 <span class="math inline">\(W\)</span>的标准几何实现中，对其基本区域闭包中的任何一点 <span class="math inline">\(v\)</span>，<span class="math inline">\(v\)</span>的稳定化子群是一个标准椭圆子群，其生成元恰好由超平面包含 <span class="math inline">\(v\)</span> 的那些单反射组成。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p>道理与注解 2 类似。易见边 <span class="math inline">\(e\)</span> 的稳定化子群 <span class="math inline">\(H\)</span> 就是 <span class="math inline">\(e\)</span>的中点的稳定化子群，这也是一个标准椭圆子群，由那些包含 <span class="math inline">\(e\)</span>的中点的镜面对应的单反射生成。这样的镜面只能是 <span class="math inline">\(\rho_i\)</span> 和那些与 <span class="math inline">\(m_i\)</span> 垂直且包含 <span class="math inline">\(v_0\)</span> 的镜面。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>解释与注解 2, 3 类似。<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p>有这么一个结论：如果 <span class="math inline">\(s_\alpha\)</span> 是关于镜面 <span class="math inline">\(\alpha\)</span> 的反射，镜面 <span class="math inline">\(\beta=g\alpha\)</span>，这里 <span class="math inline">\(g\)</span> 是空间中的可逆线性变换，则关于 <span class="math inline">\(\beta\)</span> 的反射 <span class="math inline">\(s_\beta=gs_\alpha g^{-1}\)</span>。令 <span class="math inline">\(\alpha=AB\)</span>，<span class="math inline">\(g=\rho_1\)</span>，<span class="math inline">\(\beta=AD\)</span> 即为结论。<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p>注意本文没有解释为什么这些边确实是不同类型的，即它们在对称群的作用下处于不同的轨道。严格说明这一点也要用到Coxeter 群的几何实现。<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Möbius 变换的分类与上半双曲空间的等距</title>
      <link href="mobius-h3space/"/>
      <url>mobius-h3space/</url>
      
        <content type="html"><![CDATA[<p>本文的想法源自 Roice Nelson 的 <a href="https://www.shadertoy.com/view/MstcWr">shadertoy项目</a>，我觉得他的创意很棒，就是效果有点糙，于是 <a href="https://www.shadertoy.com/view/4scfR2">动手改进了一番</a>。乍一看，这个动画的场景很简单，其实它背后的数学并不平凡。</p><p>这个动画从三个角度了演示 Möbius 变换，这三个角度是密切相关的：</p><ol type="1"><li>Möbius 变换作为扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 到自身的全纯函数。</li><li>Möbius 变换作为 Riemann 球面 <span class="math inline">\(S^2\)</span> 到自身的全纯函数。</li><li>Möbius 变换作为上半双曲空间中的等距变换。</li></ol><p>本文只作概括性的介绍，并不展开详细的数学证明。读者可以参考下面的资料：</p><blockquote><ol type="1"><li><a href="https://en.wikipedia.org/wiki/M%C3%B6bius_transformation">维基百科</a>.</li><li><span class="citation" data-cites="Needham1997">Needham (<a href="#ref-Needham1997" role="doc-biblioref">1997</a>)</span> .</li><li><span class="citation" data-cites="indra">Mumford, Series, andWright (<a href="#ref-indra" role="doc-biblioref">2002</a>)</span>,chapter 3.</li><li><span class="citation" data-cites="palka1991">Palka (<a href="#ref-palka1991" role="doc-biblioref">1991</a>)</span>, chapter IX,section 2.</li></ol></blockquote><p>本文的动画应该可以帮助你更好地理解这些资料中的内容。</p><span id="more"></span><h1 id="预备知识之正交圆族">预备知识之正交圆族</h1><p>设 <span class="math inline">\(z_1,z_2\)</span>是复平面上的两点，我们考虑两个不同的圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span>：</p><ol type="1"><li><span class="math inline">\(\mathcal{C}_1\)</span> 由所有同时过<span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 的圆组成（包含过 <span class="math inline">\(z_1,z_2\)</span> 的直线）。</li><li><span class="math inline">\(\mathcal{C}_2\)</span> 由所有使得 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 关于 <span class="math inline">\(C\)</span> 互为反演点的圆 <span class="math inline">\(C\)</span> 组成（包含线段 <span class="math inline">\([z_1,z_2]\)</span> 的垂直平分线）。</li></ol><p>则圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 中的任何圆<span class="math inline">\(C_1\)</span> 与 <span class="math inline">\(\mathcal{C}_2\)</span> 中的任何圆 <span class="math inline">\(C_2\)</span> 正交（交点处的切线互相垂直）。</p><p>我们将考察当 <span class="math inline">\(z_1,z_2\)</span> 是一个Möbius 变换 <span class="math inline">\(M\)</span> 的两个不动点时，<span class="math inline">\(M\)</span> 作用在 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span> 上的效果。</p><h1 id="möbius-变换的共轭分类">Möbius 变换的共轭分类</h1><p>一个 Möbius 变换 <span class="math inline">\(M\)</span>是一个分式线性变换，它将扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 一对一地映射为自身：<span class="math display">\[M(z) = \frac{az+b}{cz+d},\quada,b,c,d\in\mathbb{C},ad-bc\ne0, z\in \hat{\mathbb{C}}.\]</span> 所有的Möbius 变换构成一个群 <span class="math inline">\({\rmPSL}_2(\mathbb{C})\)</span>。</p><p>我们称两个 Möbius 变换 <span class="math inline">\(M_1,M_2\)</span>是共轭的，当且仅当存在 <span class="math inline">\(g\in{\rmPSL}_2(\mathbb{C})\)</span> 使得 <span class="math display">\[M_1=gM_2g^{-1}.\]</span></p><p>可以证明，在共轭的意义下，任何非恒等元的 Möbius变换都属于下面四种类型之一：</p><ol type="1"><li><span class="math inline">\(M\)</span> 称作是抛物型的(parabolic)，如果它共轭于平移：<span class="math inline">\(z\toz+1\)</span>。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上仅有一个不动点。</li><li><span class="math inline">\(M\)</span> 称作是椭圆型的(elliptic)，如果它共轭于旋转：<span class="math inline">\(z\toe^{i\theta}z\)</span>，其中 <span class="math inline">\(\theta\in\mathbb{R}\)</span> 且 <span class="math inline">\(\theta\ne0\)</span>。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li><li><span class="math inline">\(M\)</span> 称作是双曲型的(hyperbolic)，如果它共轭于缩放：<span class="math inline">\(z\to\lambdaz\)</span>，其中 <span class="math inline">\(\lambda&gt;0\)</span>是实数且不为 1。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li><li><span class="math inline">\(M\)</span> 称作是斜航型的(loxodromic)，如果它共轭于一个缩放和一个旋转的复合：<span class="math inline">\(z\to cz\)</span>，其中 <span class="math inline">\(c\in\mathbb{C}\setminus \mathbb{R}\)</span>。这时<span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li></ol><p>我们把形如 <span class="math inline">\(z\to z+a\)</span> 和 <span class="math inline">\(z\to\lambda z\)</span>的变换称作<strong>特殊位置</strong>的变换，前者是抛物型的，以 <span class="math inline">\(\infty\)</span>为唯一不动点，后者包含了所有非抛物型的变换，它的两个不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>。这两种 Möbius变换具有简单的表现形式，并且它们在两个圆族上的作用也很容易分析，所以在研究每种类型的变换时，我们都先考虑这种简单的形式，然后再通过取共轭扩展到一般的情形。</p><h2 id="抛物型">1. 抛物型</h2><p>我们先考察最简单的抛物型变换 <span class="math inline">\(z\toz+1\)</span>。</p><p>这时唯一的不动点是 <span class="math inline">\(\infty\)</span>，<span class="math inline">\(\mathcal{C}_1\)</span> 是直线族 <span class="math inline">\(\{y=k\mid k\in\mathbb{R}\}\)</span>，<span class="math inline">\(\mathcal{C}_2\)</span> 是直线族 <span class="math inline">\(\{x=l\mid l\in\mathbb{R}\}\)</span>。<span class="math inline">\(M\)</span> 保持 <span class="math inline">\(\mathcal{C}_1\)</span> 中的每条直线不变，把 <span class="math inline">\(\mathcal{C}_2\)</span>中的每条直线变成同族中的另一条直线：</p><object data="/images/mobius/parabolic-plane.svg"></object><p>由动画可见所有点都向着不动点 <span class="math inline">\(\infty\)</span> 的方向「前进」。</p><p>对一般的抛物型变换 <span class="math inline">\(M\)</span> 且 <span class="math inline">\(M\)</span> 的唯一不动点 <span class="math inline">\(z_0\)</span> 有限的情形，结论仍然类似：圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 中的圆都在 <span class="math inline">\(z_0\)</span> 处相切且共用同一条切线 <span class="math inline">\(\ell_1\)</span>，圆族 <span class="math inline">\(\mathcal{C}_2\)</span> 也都在 <span class="math inline">\(z_0\)</span> 处相切且共用同一条切线 <span class="math inline">\(\ell_2\)</span>，<span class="math inline">\(\ell_1\)</span> 和 <span class="math inline">\(\ell_2\)</span> 互相垂直：</p><object data="/images/mobius/parabolic-plane2.svg"></object><p>由动画可见左右两侧的圆在旋转，但是圆本身保持不变，它们是圆族 <span class="math inline">\(\mathcal{C}_1\)</span>；上下两侧的圆在「扩散」，它们是圆族<span class="math inline">\(\mathcal{C}_2\)</span>。可以证明对任何 <span class="math inline">\(z\in\mathbb{C}\)</span> 都有 <span class="math inline">\(\lim\limits_{n\to\infty}M^n(z)=z_0\)</span>，即任何点在<span class="math inline">\(M\)</span> 反复作用下的轨迹都朝着 <span class="math inline">\(z_0\)</span> 的位置移动。</p><p>在 <a href="http://klein.math.okstate.edu/IndrasPearls/">Indra’spearls</a> 一书中，把 <span class="math inline">\(\mathcal{C}_1\)</span>和 <span class="math inline">\(\mathcal{C_2}\)</span>形象地比喻为两组「扇贝壳」：</p><figure><img src="/images/mobius/seashell.jpeg" width="200" alt="我从网上找了一张扇贝壳的图片"><figcaption aria-hidden="true">我从网上找了一张扇贝壳的图片</figcaption></figure><h2 id="椭圆型">2. 椭圆型</h2><p>我们先考察最简单的椭圆型变换 <span class="math inline">\(z\toe^{i\theta}z\)</span>。</p><p>这时两个不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>。圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 由所有过 <span class="math inline">\(0\)</span> 的直线组成，<span class="math inline">\(\mathcal{C}_2\)</span> 由所有以 <span class="math inline">\(0\)</span> 为中心的同心圆组成。<span class="math inline">\(M\)</span> 是个旋转，所以会把 <span class="math inline">\(\mathcal{C}_1\)</span>中的直线变成同族的另一条直线，同时保持 <span class="math inline">\(\mathcal{C}_2\)</span> 中的每个圆不变：</p><object data="/images/mobius/elliptic-plane.svg"></object><p>对两个不动点 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 都有限的情形，结论同样成立，<span class="math inline">\(M\)</span> 保持 <span class="math inline">\(\mathcal{C}_2\)</span> 中的每个圆不变，把 <span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆变为同族中的另一个圆：</p><object data="/images/mobius/elliptic-plane2.svg"></object><h2 id="双曲型">3. 双曲型</h2><p>与椭圆变换 <span class="math inline">\(z\to e^{i\theta}z\)</span>的情形类似，<span class="math inline">\(z\to\lambda z\)</span> 也以<span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span> 为不动点，但是圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span> 的运动方式发生了互换：这次<span class="math inline">\(\mathcal{C}_1\)</span>中的每条直线在放缩下保持不变，<span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆在放缩下变成同族的另一个圆：</p><object data="/images/mobius/hyperbolic-plane.svg"></object><p>对两个不动点 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 都有限的双曲变换，结论仍然成立，圆族<span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆保持不变，<span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆被变成同族的另一个：</p><object data="/images/mobius/hyperbolic-plane2.svg"></object><p>这时在 <span class="math inline">\(M\)</span> 的作用下 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span>一个是「源点」，另一个是「汇点」，轨迹从源点源源不竭地发出，汇聚到汇点中。</p><h2 id="斜航型">4. 斜航型</h2><p>仍然先看 <span class="math inline">\(z\to cz\)</span> 的情形。</p><p>这时不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>，<span class="math inline">\(M\)</span> 把圆族 <span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆变为同族中的另一个圆，同样地也把圆族 <span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆变为同族中的另一个圆，<strong>所以斜航型的变换没有不变圆</strong>：</p><object data="/images/mobius/loxodromic-plane.svg"></object><p>这时平面上一点 <span class="math inline">\(z\)</span> 在 <span class="math inline">\(M\)</span>的反复作用下的轨迹是一条形如「旋臂」的曲线，方程为 <span class="math inline">\(\gamma(t)=c^tz\)</span>，这是一条对数螺线(spiral)，其与 <span class="math inline">\(\mathcal{C}_1\)</span> 和<span class="math inline">\(\mathcal{C}_2\)</span> 的夹角都是常数。</p><p>这个结论对一般的斜航型变换也成立：</p><object data="/images/mobius/loxodromic-plane2.svg"></object><p>由于斜航型变换包含双曲变换作为组成成分，因此看起来它也有一个源点和一个汇点。这时任意一点<span class="math inline">\(z\)</span> 在 <span class="math inline">\(M\)</span> 的反复作用下的轨迹是一条双螺线 (doublespiral)，其与 <span class="math inline">\(\mathcal{C}_1\)</span> 和<span class="math inline">\(\mathcal{C}_2\)</span> 的夹角仍然都是常数（Möbius 变换是保角的）。</p><p>判断 Möbius 变换 <span class="math inline">\(M\)</span>具体属于哪一类可以根据其迹的平方 <span class="math inline">\(\mu=(a+d)^2\)</span> 来判断（当然，需要把 <span class="math inline">\(M\)</span> 归一化使得 <span class="math inline">\(ad-bc=1\)</span>）：</p><ol type="1"><li><span class="math inline">\(M\)</span> 是抛物型的当且仅当 <span class="math inline">\(\mu=4\)</span>。</li><li><span class="math inline">\(M\)</span> 是椭圆型的当且仅当 <span class="math inline">\(0\leq\mu&lt;4\)</span>。</li><li><span class="math inline">\(M\)</span> 是双曲型的当且仅当 <span class="math inline">\(\mu&gt;4\)</span>。</li><li><span class="math inline">\(M\)</span> 是斜航型的当且仅当 <span class="math inline">\(\mu&lt;0\)</span> 或者 <span class="math inline">\(\mu\notin\mathbb{R}\)</span>。</li></ol><h2 id="斜航-loxodromic-是什么意思">斜航 (loxodromic) 是什么意思？</h2><p>斜航这个词听起来好像和船的航行有关，怎么就用来给 Möbius变换分类了呢？这里面肯定有故事，值得扒一扒。</p><p>斜航线 (loxodrome)指的是地球上的一条航行路径，其在每个点处的切线与过该点的经线的夹角为定值。比如说，如果船始终朝着东北方向30 度行驶，走过的轨迹就是一条斜航线。Loxodrome 最初是一个希腊词，loxos的意思是 oblique，即倾斜的，dromos 意为bearing，方位的意思，后来拉丁化以后成为现在的样子。葡萄牙数学家 PedroNunes (1492-1577)第一个认识到斜航线并非两点之间最短路径，而且它无限接近但永不可能到达极点。</p><p><img style="margin:0px auto;display:block" width="300" src="/images/mobius/loxodrome.png"></p><p>在大航海的时代，没有卫星导航，只能靠罗盘或者星座来标识船的航向，而星座的方法在遇到恶劣天气的时候又不能使用，只有罗盘是最可靠的方法。理论上地球表面两点之间的最短路径是过球心的大圆，但罗盘只能定出经线的方向（原理是地球的磁极和南北极近似重合），这二者的夹角不是固定的，要保持沿着大圆的弧走就必须不停调整船的航向，但现实中的船不可能一直有人守在船舵处调整方向，一般是事先定好航向以后接下来的若干天都沿着这个方向走，所以在一定路程内船实际上走的是斜航线。</p><p>荷兰地图学家墨卡托 (Mercator) 据此于 1569年提出了墨卡托地图，将地球投影至墨卡托地图是一个保角变换，即曲线的夹角保持不变。不仅如此，球面上的斜航线在墨卡托地图中成为一条直线：</p><figure><img src="/images/mobius/mercator.jpg" width="500" alt="网上找了一张墨卡托地图"><figcaption aria-hidden="true">网上找了一张墨卡托地图</figcaption></figure><p>所以要从地球上的 <span class="math inline">\(A\)</span> 点航向到<span class="math inline">\(B\)</span>点，只要找到它们在墨卡托地图上的对应点 <span class="math inline">\(A',B'\)</span>，算出地图上的直线 <span class="math inline">\(A'B'\)</span> 与经线的夹角 <span class="math inline">\(\theta\)</span>，航行时只要让罗盘与经线一直保持角度为<span class="math inline">\(\theta\)</span> 就可以按照斜航线从 <span class="math inline">\(A\)</span> 航行到 <span class="math inline">\(B\)</span>了。这个路径虽不是最短，但是好在不容易迷失航向。</p><p>那这和 Möbius 变换有什么关系呢？</p><h1 id="möbius-变换作用在-riemann-球面上">Möbius 变换作用在 Riemann球面上</h1><p>由于 Möbius 变换都是扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 到 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 的自同构，而 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 在球极投影下等同于Riemann 球面 <span class="math inline">\(S^2\)</span>，所以 Möbius变换也都是 Riemann 球面的自同构。我们来看看 Möbius 变换作用在 Riemann球面上是什么样子的。</p><p>这是一个作用在 Riemann 球上的斜航型变换：</p><object data="/images/mobius/loxodromic-sphere.svg"></object><p>我来解释一下这个动画的含义：从动画可见 Riemann球面上有一对源点和汇点，这对源点和汇点可以理解为球面的「北极」和「南极」，它们在球极投影下对应于<span class="math inline">\(M\)</span>在扩充复平面上的两个不动点。当这两个不动点分别是原点和无穷远点时，这两个极点就是通常意义下的北极和南极。这时球面上的「经线」是所有过两个极点的大圆，在球极投影下它们对应于同时过两个不动点的圆族<span class="math inline">\(\mathcal{C}_1\)</span>；球面上的「纬线」是所有与经线正交的圆，在球极投影下它们对应于反演圆族<span class="math inline">\(\mathcal{C}_2\)</span>，球面上每个点的轨迹是对数螺线轨迹在逆球极投影下在球面上的对应曲线，这条曲线与经线纬线的夹角都是常数（因为球极投影是保角的），从而是一条斜航线！</p><div class="unnumbered statement exercise-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">练习</span>：</span><span class="statement-spah"> </span>解释下面这个动画的含义：</p><object data="/images/mobius/parabolic-sphere.svg"></object></div><p>提示：这个动画有两种解释，它既可以看作是一个抛物型变换在 Riemann球面上作用的效果，也可以看作是一个上半双曲空间中的 horosphere在抛物型变换下作用的效果。horosphere 是指上半双曲空间中与无穷远平面<span class="math inline">\(z=0\)</span>相切的球，其半径为无穷大。Möbius变换在上半双曲空间上的作用见下一节。</p><h1 id="möbius-变换作为上半双曲空间的等距">Möbius变换作为上半双曲空间的等距</h1><p>上半双曲空间 <span class="math inline">\(\mathbb{H}_3\)</span>的定义为 <span class="math display">\[\mathbb{H}_3 =\{(x,y,t)\in\mathbb{R}^3\ |\ t&gt;0\}.\]</span>这个空间中的度量是双曲度量：</p><p><span class="math display">\[\mathrm{d}s=\frac{(\mathrm{d}x)^2+(\mathrm{d}y)^2+(\mathrm{d}t)^2}{t}.\]</span></p><p>注意 <span class="math inline">\(xy\)</span> 平面，即复平面不属于<span class="math inline">\(\mathbb{H}_3\)</span>，它是 <span class="math inline">\(\mathbb{H}_3\)</span> 的无穷远边界，<span class="math inline">\(\mathbb{H}_3\)</span> 中任何一点到 <span class="math inline">\(xy\)</span> 平面的距离是无穷大。</p><p>一个复分析教材中不太常讲到的事实是：<strong>任何 Möbius变换都可以唯一地扩展为 <span class="math inline">\(\mathbb{H}_3\)</span>的一个等距变换 <span class="math inline">\(\overline{M}\)</span></strong>，此即所谓的Poincaré Extension。这个扩展用四元数来描述的话很简单：设 <span class="math display">\[M\colon\ z\to\frac{az+b}{cz+d},\quadad-bc=1.\]</span> 是任一 Möbius 变换。注意我们这里要求 <span class="math inline">\(ad-bc\)</span> 的值是1，其实任何非零实数都可以。这是可以做到的，因为给 Möbius 变换中的 <span class="math inline">\(a,b,c,d\)</span>同时乘以一个非零复数并不改变这个变换，所以同时乘以 <span class="math inline">\(1/\sqrt{ad-bc}\)</span> 就可以使得 <span class="math inline">\(ad-bc=1\)</span>。</p><p>对 <span class="math inline">\(p=(x,y,t)\in\mathbb{H}^3\)</span>，令<span class="math inline">\(q=x+yi+tj\)</span> 为与 <span class="math inline">\(p\)</span> 对应的四元数，定义 <span class="math display">\[\overline{M}(p) = (aq+b)(cq+d)^{-1}.\]</span>这里的运算都是在四元数体中进行。则 <span class="math inline">\(\overline{M}(p)\)</span> 是 <span class="math inline">\(\mathbb{H}_3\)</span> 到自身的等距，并且它限制在<span class="math inline">\(xy\)</span> 平面上与 <span class="math inline">\(M\)</span> 的作用一致。</p><p>关于 Poincaré Extension 读者可以参考 <span class="citation" data-cites="Bea95">(<a href="#ref-Bea95" role="doc-biblioref">Beardon1995, vol. 91, secs. 3.3, 4.1</a>)</span>。</p><p>我们还能像上面那样用动画演示 Möbius 变换 <span class="math inline">\(\overline{M}\)</span> 在 <span class="math inline">\(\mathbb{H}_3\)</span>上的作用吗？可以！比如下图是一个形如 <span class="math inline">\(z\tocz\)</span> 的斜航型变换扩展到 <span class="math inline">\(\mathbb{H}_3\)</span>后作用在一个<strong>圆柱</strong>体上的效果：</p><object data="/images/mobius/loxodromic-cone.svg"></object><p>你可能要问了：这明明是个圆锥体，你怎么说它是圆柱体呢？是不是笔误了啊？</p><p>其实是因为我们现在是在双曲空间里看待它，在双曲度量下，锥面上所有点到<span class="math inline">\(t\)</span>轴的距离都是一样的，实际上如果设锥的顶角为 <span class="math inline">\(2\alpha\)</span>，则锥面上任何一点到 <span class="math inline">\(t\)</span> 轴的双曲距离 <span class="math inline">\(d\)</span> 满足（见 <span class="citation" data-cites="Bea95">(<a href="#ref-Bea95" role="doc-biblioref">Beardon1995, vol. 91, sec. 7.9.1</a>)</span>） <span class="math display">\[\sinh d\cdot \cot\alpha = 1.\]</span> 即 <span class="math inline">\(d\)</span> 是定值。所以虽然在 <span class="math inline">\(\mathbb{R}^3\)</span> 中它是一个锥体，但是在 <span class="math inline">\(\mathbb{H}_3\)</span> 中它其实是圆柱体。</p><p>你可以看到这时 <span class="math inline">\(\overline{M}\)</span>有两个不动点，都位于无穷远边界上，这样的点叫做「理想点」。两个不动点之间的连线构成圆柱的轴。两个不动点一个是源点，一个是汇点，空间中的点在变换的作用下远离源点，趋向汇点。</p><p>对于一般的斜航型变换 <span class="math inline">\(M\)</span>，且其两个不动点都是扩充复平面上的有限点时，<span class="math inline">\(M\)</span> 在 <span class="math inline">\(\mathbb{H}_3\)</span> 上的扩展 <span class="math inline">\(\overline{M}\)</span> 仍然保持一个 <span class="math inline">\(\mathbb{H}_3\)</span> 中的圆柱体不变：</p><object data="/images/mobius/loxodromic-dupin.svg"></object><p>这个曲面叫做 <a href="https://www.maths.ox.ac.uk/about-us/departmental-art/dupin-cyclides">Dupincyclide</a>，它的两个端点恰好是 <span class="math inline">\(M\)</span>的两个不动点。但在双曲空间中它其实是一个圆柱体，由于其两端落在无穷远平面上，因此也是无限长的。圆柱体的轴是连接两个端点的测地线。如果<span class="math inline">\(M\)</span> 是椭圆型的话，那么 <span class="math inline">\(\overline{M}\)</span> 将该圆柱绕着轴旋转：</p><object data="/images/mobius/elliptic-dupin.svg"></object><h1 id="这些动画是怎么生成的">这些动画是怎么生成的？</h1><p>我以 Dupin cyclide 的动画为例子来说明动画的绘制过程。</p><p>一个非抛物型的变换 <span class="math inline">\(M\)</span>总是可以表示为 <span class="math inline">\(M = gM_\lambdag^{-1}\)</span> 的形式，其中 <span class="math inline">\(M_\lambda=z\to\lambda z\)</span>。我这里的 <span class="math inline">\(g\)</span> 取的是 <span class="math display">\[g^{-1}(z)=\frac{z-1}{z+1}.\]</span>注意我这里写的是 <span class="math inline">\(g^{-1}\)</span>，原因是我们不需要 <span class="math inline">\(g\)</span> 的显式表达式，相反我们只需要 <span class="math inline">\(g^{-1}\)</span>。</p><p>不难验证 <span class="math inline">\(g^{-1}(1)=0\)</span> 和 <span class="math inline">\(g^{-1}(-1)=\infty\)</span>，从而 <span class="math inline">\(g(0)=1\)</span> 和 <span class="math inline">\(g(\infty)=-1\)</span>，即 <span class="math inline">\(g\)</span> 将 <span class="math inline">\(M_\lambda\)</span> 的不动点 <span class="math inline">\(\{0,\infty\}\)</span> 分别映射为 <span class="math inline">\(M\)</span> 的不动点 <span class="math inline">\(\{1,-1\}\)</span>。<span class="math inline">\(g\)</span> 同时将 <span class="math inline">\(M_\lambda\)</span> 对应的圆族 <span class="math inline">\(\{\mathcal{C}_i,i=1,2\}\)</span> 映射为 <span class="math inline">\(M\)</span> 的圆族 <span class="math inline">\(\{g(\mathcal{C}_i),i=1,2\}\)</span>。</p><p><span class="math inline">\(g\)</span> 当然也可以扩展为 <span class="math inline">\(\mathbb{H}_3\)</span> 的等距，我们把扩展以后的<span class="math inline">\(g\)</span> 仍然记作 <span class="math inline">\(g\)</span>。</p><p>由 <span class="math inline">\(M = gM_\lambda g^{-1}\)</span> 可得<span class="math display">\[Mg(\mathcal{C}_i) = gM_\lambda(\mathcal{C}_i),\quad i=1,2.\]</span> 左边的 <span class="math inline">\(Mg(\mathcal{C}_i)\)</span> 是我们真正想绘制的<span class="math inline">\(M\)</span> 在其自己的圆族 <span class="math inline">\(g(\mathcal{C}_i)\)</span>上的作用，这等价于绘制右边的 <span class="math inline">\(gM_\lambda(\mathcal{C})_i\)</span>。<span class="math inline">\(M_\lambda(\mathcal{C}_i)\)</span>很好画，就是把一些同心圆和过原点的直线旋转或者放缩一下；但是它前面加了一个畸变<span class="math inline">\(g\)</span>。为此我们只要用 <span class="math inline">\(g^{-1}\)</span>作用在当前场景的物体上，把它们「去畸变」即可。所以在动画中，我其实根本没有计算Dupin cyclide 的任何显式或者隐式的曲面方程，而是直接用 <span class="math inline">\(g^{-1}\)</span> 作用在场景上。由于 <span class="math inline">\(g^{-1}\)</span> 是 <span class="math inline">\(\mathbb{H}_3\)</span> 上的等距，它一定会把连接<span class="math inline">\(\{\pm1\}\)</span> 的测地线映射为连接 <span class="math inline">\(\{0,\infty\}\)</span>的测地线，即锥面。换言之，判断场景中的一个点 <span class="math inline">\(p\)</span> 是不是落在 Dupin cyclide 上，只要判断<span class="math inline">\(g^{-1}(p)\)</span>是不是落在锥面上。这就好办了。</p><p>抛物的情形更简单一些，可以用 <span class="math inline">\(g(z)=1/z\)</span>把位于无穷远的不动点变到原点。</p><p>动画使用的是 GLSL 语言和 raymarching 的技术。我在 Roice的代码基础上作了许多优化，但肯定还可以更精炼。限于我写 shader的能力不足，做出更美轮美奂的效果就不指望了 …</p><p>严格讲，这些动画其实还是尝试在 Euclidean空间中去观察双曲空间中的对象，因为 raymarching技术假定的是光走直线，但在双曲空间中光一般不走直线，所以我们这里看到的效果与真实的生活在双曲空间中的“外星人”所看到的还是有差别的。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Bea95" class="csl-entry" role="listitem">Beardon, Alan F. 1995. <em>The Geometry of Discrete Groups</em>. Vol.91. Graduate Texts in Mathematics. Springer-Verlag, New York.</div><div id="ref-indra" class="csl-entry" role="listitem">Mumford, David, Caroline Series, and David J. Wright. 2002. <em>Indra’sPearls: An Atlas of Kleinian Groups</em>. Cambridge University Press.</div><div id="ref-Needham1997" class="csl-entry" role="listitem">Needham, Tristan. 1997. <em>Visual Complex Analysis</em>. The ClarendonPress, Oxford University Press, New York.</div><div id="ref-palka1991" class="csl-entry" role="listitem">Palka, B. P. 1991. <em>An Introduction to Complex Function Theory</em>.An Introduction to Complex Function Theory. World PublishingCorporation.</div></div>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>碉堡的小程序：用 Python 制作演示各种算法的 GIF 动画</title>
      <link href="gifmaze-cn/"/>
      <url>gifmaze-cn/</url>
      
        <content type="html"><![CDATA[<p>本文要介绍的是我写的一个有趣的 Python小程序，一个脱离了低级趣味的程序，一个有益于广大人民了解算法的程序。代码在<a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/gifmaze">Github</a>上。</p><p>这个程序可以用来制作各种各样的算法动画，包含但不限于：</p><span id="more"></span><ul><li><p>Wilson 均匀生成树算法：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/wilson-bfs.gif"></p></li><li><p>Prim 算法：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/prim.gif"></p></li><li><p>Kruskal 算法：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/kruskal.gif"></p></li><li><p>Langton 蚂蚁：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/langton-ant.gif"></p></li><li><p>Hilbert 曲线：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/hilbert.gif"></p></li><li><p>Conway 的生命游戏 (gosper glider gun)：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/gosperglidergun.gif"></p></li></ul><p>以上这些动画有一个共同特点：它们都位于二维的网格图上，这也是这个程序的一个限制。</p><p>这个程序有如下特点：</p><ol type="1"><li><p>所有代码全部由纯 Python写成，没有用到任何第三方库或者外部软件，也不包含任何 <code>draw</code>,<code>fill</code> 之类的函数调用，仅使用了内置的 <code>struct</code>,<code>random</code> 模块和一些内置函数。后来的版本中为了显示进度条引入了<code>tqdm</code>；为了把整个动画嵌入一张背景图片引入了<code>pillow</code>，这些都属于特效，本质不需要。</p></li><li><p>实现了一个小型但高效的 GIF编码器，<strong>通过直接将动画过程编码为字节流</strong>，可以在数秒之内生成高度优化的动态图。比如前面那张Langton ant 的动图，它包含 2300 帧，但是大小只有158KB，而且只需要一秒多一点就可以生成。这是这个程序最让人意外的一点：Python生成图像的慢是出了名的，它居然能在几秒内生成一张包含几千帧的 GIF动图？这是个大新闻啊！</p></li><li><p>严格遵循 GIF89a 协议，生成的图片在 chrome, firefox, IE 和 Eog中都可以正常显示。</p></li></ol><p>程序运行的相当快，生成一副 600x400 像素，演示 Wilson算法的动图只要数秒，得到的文件包含 1000~3000 帧，但大小不超过 1M左右。没想到吧？<span class="emoji" data-alias="astonished" style="" data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f632.png?v8">😲</span></p><p>这个程序是怎么来的呢？许多年前我在网上闲逛的时候，偶然发现了 d3.js <a href="https://bl.ocks.org/mbostock">作者的网站</a>（原链接已重定向，作者现在已经创业搞<a href="https://observablehq.com/">observablehq</a>去了），当时我对上面展示的各种丰富炫酷的动态效果惊羡不已，尤其是其中 <a href="https://bl.ocks.org/mbostock/11357811">Wilson算法的演示</a>，让我对此算法有了更直观和深入的理解。我立刻萌发了用Python 制作一个 GIF版本动画演示的想法，但是思考了许久也不知道从何入手。这里困难的地方在于Wilson算法是一个随机算法，其运行时间是不确定的，一个动画里面可能包含数千帧，如果采用把每一帧保存为图像再合并到一起的话，最终得到的文件会非常庞大。而且这种纯暴力的做法逼格不高，我实在不屑于采用。限于能力不足，这个想法只好被暂时压在心底，但是一直念念不忘。过了几年后，一个偶然的机会我接触到了GIF图像的编码协议，豁然开朗：为什么不直接把动画过程编码为字节流呢？通过精确定位每一帧的位置，控制LZW压缩过程的编码长度，文件过大的问题是可以解决的！前后捣鼓了半个月，反复研究协议细节，debug了无数次后，这才作出了上面的效果。后来慢慢又加上了其它迷宫算法和元胞自动机的演示。</p><p>关键的地方有这么几个：</p><ol type="1"><li><p>由于 GIF图像的每一帧占据的是整个图像窗口的一个矩形子区域，在一个包含很多帧的动图中，相邻的两帧之间的变动可能很小，没有必要每次都将整个图像全部编码。我们只需要记录帧和帧之间的变化情况，得出每一帧所占的矩形子区域，每次编码时只针对这个子区域编码即可，这样就大大减小了生成的文件体积。</p></li><li><p>采用变长的 LZW 压缩算法。GIF89a协议允许每个打包的数据块指明其所使用的最小码字的长度，如果你事先知道这一帧图像用到的颜色数目，比如4 种颜色，那么 2 个比特就足以表示这 4 种颜色，从而最小编码长度可以设置为2。这样根据具体情况采用不同的编码长度能有效减少文件体积。</p></li><li><p>因为要频繁的进行字节流的操作，所以每次将编码后的数据先写入一个<code>BytesIO</code> 对象中，放在内存里，最后一次性输出到硬盘。</p></li></ol><p>代码的组织结构是简单的三层论：顶层是抽象的 <code>Maze</code>类，其本质就是一个 2D网格图，用来跑各种图算法，它不关心动图的任何细节。底层是<code>GIFSurface</code> 类，负责维护 GIF图片的全局信息，比如图片宽高，循环次数，背景颜色，全局调色板等。中间层是<code>Animation</code>类，用来控制帧的信息，在算法运行过程中它按照一定的频率将<code>Maze</code> 染色并编码写入 <code>GIFSurface</code>。</p><p>目前程序的核心代码加起来大约在 1000行左右，但是如果牺牲一些可读性和功能的话，是可以压缩到 500行以内的。我曾经把这个项目投稿到 Github 上的 <a href="https://github.com/aosabook/500lines">500lines</a>上，可惜未能入选。但是我始终觉得它的优雅、奇妙并不逊色于那些大神们的作品。</p>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模任何素数都可约的整系数不可约多项式</title>
      <link href="reducible-mod-p/"/>
      <url>reducible-mod-p/</url>
      
        <content type="html"><![CDATA[<p>几年前在知乎上有这么 <a href="https://www.zhihu.com/question/38156113/answer/139354565">一个问题</a>：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>有哪些 <span class="math inline">\(\mathbb{Z}[x]\)</span> 中的多项式，它们在有理数域<span class="math inline">\(\mathbb{Q}\)</span>上是不可约的，而对任意素数 <span class="math inline">\(p\)</span>，模<span class="math inline">\(p\)</span> 以后在 <span class="math inline">\(\mathbb{Z}_p[x]\)</span> 上都是可约的？</p></div><p>当时我给了回答，后来账号注销了，答案也一并删除了。现在把我的原答案贴在这里：</p><span id="more"></span><p>我所知道的有两大类多项式：</p><p>第一类是所有的 Swinnerdon-Dyer 多项式，它们形如 <span class="math display">\[f(x)=\prod(x\pm\sqrt{p_1}\pm\sqrt{p_2}\cdots\pm\sqrt{p_n}),\]</span>其中 <span class="math inline">\(p_1,\ldots,p_n\)</span>是互不相同的素数，乘积跑遍所有 <span class="math inline">\(2^n\)</span>种不同的组合。这种多项式都是不可约的整系数多项式，但是模任何素数 <span class="math inline">\(p\)</span>以后都分解为一次或者二次因式的乘积。</p><p>第二类来自分圆多项式，分圆多项式 <span class="math inline">\(\Phi_n(x)\)</span> 是本原 <span class="math inline">\(n\)</span> 次单位根在 <span class="math inline">\(\mathbb{Q}\)</span> 上的首 1 极小多项式，其次数为<span class="math inline">\(\phi(n)\)</span>，这里 <span class="math inline">\(\phi(\cdot)\)</span> 是 Euler totient函数。绝大多数分圆多项式模任何素数 <span class="math inline">\(p\)</span> 都是可约的！实际上我们有如下结论：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>分圆多项式 <span class="math inline">\(\Phi_n(x)\)</span>模任何素数 <span class="math inline">\(p\)</span> 都可约当且仅当 <span class="math inline">\(n\ne1,2,p,2p^k\)</span>，其中 <span class="math inline">\(p\)</span> 是奇素数，<span class="math inline">\(k\)</span> 是正整数。</p></div><p>你可以看到知乎那个问题下的回答中举的例子都是最简单的 Swinnerdon-Dyer多项式或者分圆多项式。</p><p>我知道这个结论还是研究生时上夏壁灿老师的符号计算课程，讲到分解整系数多项式的Zassenhaus算法，这两类多项式被用来分析算法的最差复杂度。我还在校园书摊上淘到了一本破损的<a href="https://www.cambridge.org/core/books/modern-computer-algebra/DB3563D4013401734851CF683D2F03F0">ModernComputer Algebra</a>，在 15.3 节 “Frobenius’ and Chebotarev’s densitytheorems” 中有介绍。</p><p>这两类多项式属于比较容易分析的，还有别的例子吗？也是有的，<a href="https://projecteuclid.org/euclid.rmjm/1289916905">这篇文章</a>给出了更多不那么显然的构造。</p>]]></content>
      
      
      <categories>
          
          <category> 代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Coupling from the past</title>
      <link href="coupling-from-the-past/"/>
      <url>coupling-from-the-past/</url>
      
        <content type="html"><![CDATA[<p>今天我要介绍一个 Markov 链采样中的精彩算法，叫做 coupling from thepast(CFTP)。这个算法看似简单，实则充满玄机。我相信你可以在五分钟内理解算法的步骤，然后再花五分钟左右看懂算法的证明，但是我打赌你需要几个星期甚至更久的时间来细细回味其中奥妙。</p><p>作为启发，我们从一个计数问题开始：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>下图是一个边长分别为 <span class="math inline">\(a,b,c\)</span> 的平行六边形，其中 <span class="math inline">\(a,b,c\)</span> 都是正整数，内角均为 120 度：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/cftp/hexagon.svg"></p><p>请问：用边长为 1 的菱形密铺它，有多少种不同的方法？</p></div><span id="more"></span><p>比如下图就是一种密铺的示例：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/cftp/random_lozenge_tiling.svg"></p><p>图中三种不同摆放角度的菱形被染成了不同的颜色。</p><p>这个问题的答案很不容易猜到，叫做 Macmahon 公式：</p><div id="macmahon-------" class="unnumbered statement sta_macmahon___ plain"><p><span class="statement-heading"><span class="statement-label">Macmahon 公式</span>.</span><span class="statement-spah"> </span>记 <span class="math inline">\(H(a,b,c)\)</span>为所求的六边形的不同菱形密铺的个数，则 <span class="math display">\[H(a,b,c)=\prod_{i=1}^a\prod_{j=1}^b\prod_{k=1}^c\frac{i+j+k-1}{i+j+k-2}.\]</span></p></div><p>关于 Macmahon 公式，以及它背后的 plane partition理论是另一段精彩的故事，这里不作介绍。需要注意的是，<span class="math inline">\(H(a,b,c)\)</span> 的值是指数级增长的，比如对 <span class="math inline">\(a=b=c=10\)</span> 这种比较小的情形 <span class="math inline">\(H(a,b,c)\approx9.265\times10^{33}\)</span>，已经是一个天文数字了。</p><p>真正的问题来了：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>怎样在全部 <span class="math inline">\(H(a,b,c)\)</span>种不同的密铺中完全随机地任选一种？（即按照均匀分布采样）</p></div><p>由于 <span class="math inline">\(H(a,b,c)\)</span>太太太大了，我们不可能先把所有密铺都列出来然后再挑选，那样的话全世界的计算机内存加起来也装不下。所以得设计一个聪明点的方法，这就是CFTP 要做的。</p><h1 id="markov-链的随机取样">Markov 链的随机取样</h1><p>设 <span class="math inline">\(M\)</span> 是一个有限遍历的 Markov链，其状态空间为 <span class="math inline">\(S\)</span>，平稳分布为<span class="math inline">\(\pi\)</span>，我们希望以分布 <span class="math inline">\(\pi\)</span> 从 <span class="math inline">\(S\)</span> 中随机地取样，即对任何 <span class="math inline">\(s\in S\)</span>，取样抽到 <span class="math inline">\(s\)</span> 的概率为 <span class="math inline">\(\pi(s)\)</span>。这在许多实际应用中都有重要意义。通常的方法是任选一个初始状态<span class="math inline">\(s_0\)</span> 然后从 <span class="math inline">\(s_0\)</span> 出发跑这个 Markov链。可以证明只要运行的时间 <span class="math inline">\(n\)</span>足够大，其 <span class="math inline">\(n\)</span> 时刻的状态 <span class="math inline">\(s_n\)</span> 服从的分布就可以任意逼近平稳分布：<span class="math display">\[|\mathbb{P}(s_n=s) - \pi(s)| &lt;\epsilon,\quad\forall s\in S,\ \forall\epsilon&gt;0.\]</span>这个方法非常简单易行，但是它有两个缺陷：首先它只是一个近似算法，不管<span class="math inline">\(n\)</span> 取得多么大，返回的 <span class="math inline">\(s_n\)</span> 的分布只是近似而非严格等于平稳分布<span class="math inline">\(\pi\)</span>；其次为了获得足够的精度采样所需的时间<span class="math inline">\(n\)</span> （叫做 mixingtime）也不总是那么容易估计的。那么有没有什么办法可以获得精确地服从 <span class="math inline">\(\pi\)</span> 的采样呢？</p><p>Propp 和 Wilson 提出了如下的想法：既然从初始状态出发向未来 （<span class="math inline">\(+\infty\)</span> 方向） 跑 Markov链得不到真正的平稳分布，我们何不从无穷远的过去 （<span class="math inline">\(-\infty\)</span> 方向） 向现在 （时刻 0）跑呢？可以想象当这个链经过了无穷次迭代后，其 0 时刻的状态 <span class="math inline">\(s^\ast\)</span> 服从的分布就是 <span class="math inline">\(\pi\)</span>。当然，一个可行的算法必须在有限时间内输出结果，我们不可能做到真的从无穷远的过去出发。我们能做的只是选择一个足够大的<span class="math inline">\(n\)</span> 然后从 <span class="math inline">\(-n\)</span> 时刻出发向时刻 0 跑，但是这种做法和从0 时刻向时刻 <span class="math inline">\(n\)</span>跑没有什么区别。Propp 和 Wilson的观察的关键之处在于，只跑一个链是不行的，我们需要从每个 <span class="math inline">\(s\in S\)</span> 出发，同时跑 <span class="math inline">\(M\)</span> 的 <span class="math inline">\(|S|\)</span> 个不同的版本，并且观察它们是否在时刻0 时耦合在一起 (coupled together)，即相遇到了相同的状态 <span class="math inline">\(s^\ast\)</span>。一旦这件事情发生的话，那么假设我们还有一个额外的从无穷远出发、初始分布是<span class="math inline">\(\pi\)</span> 的链，由于它来到 0时刻必然也处于状态 <span class="math inline">\(s^\ast\)</span>，所以<span class="math inline">\(s^\ast\)</span> 就服从分布 <span class="math inline">\(\pi\)</span>。如果没有相遇呢？那就从某个更久远的位置开始再来一遍，直到耦合出现为止，这就是coupling from the past 的由来。</p><p>用不太准确的话说，我们是在时间 <span class="math inline">\(-n\)</span> 处设置了 <span class="math inline">\(|S|\)</span>个不同的链，封死了从无穷远过去出发的链在 <span class="math inline">\(-n\)</span>处的所有可能状态，然后通过将所有链在时刻 0“坍缩”为单个状态来获得采样。</p><p>其实我上面的描述仍然遗漏了 CFTP 的一些关键细节。为了准确的描述CFTP，我们首先引入 Markov 链的随机映射表示 (random mappingrepresentation)。</p><h1 id="markov-链的随机映射表示">Markov 链的随机映射表示</h1><p>随机映射表示能够让我们用计算机程序来模拟 Markov链，它是一个由随机数流驱动的更新函数 <span class="math inline">\(f:S\times [0, 1]\to S\)</span>。<span class="math inline">\(f\)</span>本身是确定的，对任何状态 <span class="math inline">\(s\in S\)</span> 和<span class="math inline">\(u\in [0,1]\)</span>，<span class="math inline">\(s'=f(s,u)\)</span> 给出 Markov链更新后的状态。我们要求 <span class="math inline">\(f\)</span> 满足当<span class="math inline">\(U\)</span> 是服从 <span class="math inline">\([0, 1]\)</span> 上的均匀分布的随机变量时，<span class="math inline">\(\mathbb{P}(f(s,U)=s')=P_{s,s'}\)</span>。这里 <span class="math inline">\(P_{s,s'}\)</span> 是 Markov 链从 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(s'\)</span> 的转移概率。任何有限 Markov链都存在随机映射表示，而且表示方法不是唯一的。最简单的构造方式是用一个阶梯函数：<span class="math display">\[f(s_i, u) =\begin{cases}\begin{array}{ll}s_1, &amp;\text{for } u\in[0,P_{i,1}),\\s_2, &amp;\text{for } u\in[P_{i,1}, P_{i,1}+P_{i,2}),\\\vdots&amp;\vdots\\s_j, &amp;\text{for } u\in\left[\sum_{k=1}^{j-1}P_{i,k},\sum_{k=1}^jP_{i,k}\right),\\\vdots &amp;\vdots\\s_n, &amp;\text{for }u\in\left[\sum_{k=1}^{n-1}P_{i,k},1\right].\end{array}\end{cases}\]</span></p><p>假设有一个随机数发生器可以产生独立且服从 <span class="math inline">\([0,1]\)</span> 上均匀分布的随机变量序列 <span class="math inline">\(U_0,U_{-1},U_{-2},\ldots\)</span>，则我们可以由此来驱动Markov 链 <span class="math inline">\(M\)</span>从过去的某个时刻向现在运行： <span class="math display">\[s_{-n}\xrightarrow{f(s_{-n+1},\,U_{-n+1})}s_{-n+1}\xrightarrow{f(s_{-n+2},\,U_{-n+2})}\cdots\xrightarrow{f(s_0,\,U_0)}s_0.\]</span></p><h1 id="coupling-from-the-past-算法">Coupling from the past 算法</h1><p>现在我们可以来表述 coupling from the past 算法了。</p><p>设 <span class="math inline">\(M\)</span> 是一个有限遍历的 Markov链，状态空间为 <span class="math inline">\(S\)</span>，<span class="math inline">\(f: S\times [0, 1]\to S\)</span>是其随机映射表示。<span class="math inline">\(U_0,U_{-1},\ldots\)</span>是一列随机数，它们分别来自一列独立且服从 <span class="math inline">\([0,1]\)</span> 上均匀分布的随机变量。记 <span class="math inline">\((N_1,N_2,\ldots)=(1,2,4,8,\ldots)\)</span>，<span class="math inline">\(-N_{m}\)</span> 将作为我们第 <span class="math inline">\(m\)</span> 次重启的出发时间。</p><blockquote><p><strong>Coupling from the past 算法</strong>：</p><ol type="1"><li>令 <span class="math inline">\(m=1\)</span>。</li><li>对每个 <span class="math inline">\(s\in S\)</span>，以 <span class="math inline">\(s\)</span> 为初始状态，以 <span class="math inline">\(-N_m\)</span> 为初始时刻向时刻 0 的方向运行 Markov链 <span class="math inline">\(M\)</span>，所有 <span class="math inline">\(|S|\)</span> 个链使用的随机数流是一样的，都是<span class="math inline">\((U_{-N_m+1},\ldots,U_{-1},U_0)\)</span>。</li><li>如果步骤 2 中的 <span class="math inline">\(|S|\)</span> 个链在时刻0 给出的状态相同，记此状态为 <span class="math inline">\(s^\ast\)</span>，则输出 <span class="math inline">\(s^\ast\)</span> 并退出程序。否则将 <span class="math inline">\(m\)</span> 的值加 1 并重复步骤 2。</li></ol><p>下图显示了算法的每个重启时刻，相同颜色的随机数是在同一批中生成的。</p><p><img style="margin:0px auto;display:block" src="/images/cftp/random_numbers.svg"></p><p><strong>断言</strong>：如果上述步骤以概率 1在有限时间内结束，则其返回值 <span class="math inline">\(s^\ast\)</span>服从平稳分布 <span class="math inline">\(\pi\)</span>: <span class="math display">\[\mathbb{P}(s^\ast = s) = \pi(s),\quad \foralls\in S.\]</span></p></blockquote><p>注意这里的两个细节：</p><ol type="1"><li>我们强调了前提<strong>如果算法以概率 1在有限时间内结束，则返回值服从平稳分布</strong>。为了保证这个前提成立更新函数<span class="math inline">\(f\)</span>的选择就不能是任意的，特别地在后面的 monotone CFTP 中更新函数还要与<span class="math inline">\(S\)</span>上的偏序相容，更不能是任意的。</li><li>当第 <span class="math inline">\(m\)</span> 次执行步骤 2时，使用的随机数为 <span class="math inline">\((U_{-N_m+1},U_{-N_m+2},\ldots,U_{-1},U_0)\)</span>，其中的后半部分<span class="math inline">\((U_{-N_{m-1}+1},U_{-N_{m-1}+2},\ldots,U_{-1},U_0)\)</span>需要与上一次使用的相同，<strong>即每一次都重复使用上一次的随机数作为后半段的随机源</strong>，否则每次都重新生成一列新的随机数的话得到的最终状态未必服从平稳分布。</li></ol><p><strong>证明</strong>：任取 <span class="math inline">\(s_i\inS\)</span>，只要证明对任何 <span class="math inline">\(\epsilon&gt;0\)</span> 都有 <span class="math display">\[|\mathbb{P}(s^\ast=s_i) -\pi(s_i)|&lt;\epsilon.\]</span> 设 <span class="math inline">\(\Omega=\{(U_{-1},U_{-2},\ldots)\mid U_i \text{i.i.d on } [0,1]\}\)</span> 是所有随机数流组成的样本空间， <span class="math display">\[A=\{\text{the algorithm terminates in finitetime}\}.\]</span> 即 <span class="math inline">\(A\)</span>为那些可以使得算法在有限时间内结束的序列组成的集合，则 <span class="math inline">\(\mathbb{P}(A)=1\)</span>。</p><p>又记 <span class="math display">\[A_i = \{ \text{the algorithm doesnot need to try starting times earlier than} -N_i\}.\]</span> 即 <span class="math inline">\(A_i\)</span> 为事件「算法从 <span class="math inline">\(-N_i\)</span> 或者更早的时间出发可以结束」。</p><p>显然我们有 <span class="math inline">\(A_i\uparrow A\)</span>，<span class="math inline">\(\mathbb{P}(A_i)\uparrow\mathbb{P}(A)=1\)</span>。因此对充分大的<span class="math inline">\(K\)</span> 有 <span class="math inline">\(\mathbb{P}(A_K) \geq1-\epsilon\)</span>。取定这样的 <span class="math inline">\(K\)</span>，则在事件 <span class="math inline">\(A_K\)</span> 上，所有的链在时刻 0 耦合到相同的状态<span class="math inline">\(s^\ast\)</span>。</p><p>除了以上 <span class="math inline">\(|S|\)</span>条链之外，我们再额外跑一条单独的链 <span class="math inline">\(Y\)</span>，这条链的初始状态选自平稳分布 <span class="math inline">\(\pi\)</span>，也从时刻 <span class="math inline">\(-N_K\)</span> 出发，也使用相同的随机数 <span class="math inline">\((U_{-N_K+1},\ldots,U_0)\)</span> 运行至时刻0，并设这个链在时刻 0 的状态为 <span class="math inline">\(Y_0\)</span>，则 <span class="math inline">\(Y_0\)</span> 服从平稳分布。</p><p>在事件 <span class="math inline">\(A_K\)</span>上，不管这条单独的链初始状态是什么，由于它使用了同样的随机数序列，所以它最后一定会和其余<span class="math inline">\(|S|\)</span> 条链一起耦合，所以 <span class="math display">\[\mathbb{P}(s^\ast=Y_0) \geq \mathbb{P}(A_K)\geq 1- \epsilon.\]</span> 从而对任何 <span class="math inline">\(s_i\inS\)</span>， <span class="math display">\[\begin{aligned}\mathbb{P}(s^\ast =s_i)-\pi(s_i)&amp;= \mathbb{P}(s^\ast = s_i)-\mathbb{P}(Y_0 =s_i)\\&amp;\leq\mathbb{P}(s^\ast=s_i, Y_0\ne s_i)\\&amp;\leq\mathbb{P}(Y_0\nes^\ast)\\&amp;\leq\epsilon.\end{aligned}\]</span> 类似地 <span class="math display">\[\begin{aligned}\pi(s_i)-\mathbb{P}(s^\ast =s_i)&amp;=\mathbb{P}(Y_0 = s_i)-\mathbb{P}(s^\ast =s_i)\\&amp;\leq\mathbb{P}(Y_0=s_i, s^\ast\ne s_i)\\&amp;\leq\mathbb{P}(Y_0\nes^\ast)\\&amp;\leq\epsilon.\end{aligned}\]</span> 从而 <span class="math display">\[|\mathbb{P}(s^\ast = s_i)-\pi(s_i)| \leq\epsilon.\]</span> 令 <span class="math inline">\(K\to\infty\)</span>，则 <span class="math inline">\(\epsilon\downarrow0\)</span>。注意到对任何样本点<span class="math inline">\(\omega\in A_K\)</span>，如果 <span class="math inline">\(\omega\)</span> 给出的所有链的耦合状态是 <span class="math inline">\(s^\ast=s_i\)</span>，则从更久远的时刻出发，<span class="math inline">\(\omega\)</span> 给出的耦合状态仍然是 <span class="math inline">\(s_i\)</span>，即 <span class="math inline">\(\omega\)</span> 输出的采样结果 <span class="math inline">\(s^\ast\)</span> 是不会随着 <span class="math inline">\(K\)</span> 增大而改变的，所以由 <span class="math inline">\(\epsilon\)</span> 的任意性即得 <span class="math inline">\(s^\ast\)</span> 服从平稳分布。</p><h1 id="算法中的若干陷阱">算法中的若干陷阱</h1><p>CFTP算法的证明看似不难，但其实微妙之处不少，值得细细品味。最主要的地方有三个：</p><blockquote><p><strong>问题 1</strong>：为什么说更新函数 <span class="math inline">\(f\)</span> 的选择不能是任意的？</p><p><strong>问题 2</strong>：既然 「coupling from the past」 可以，那「coupling to the future」 可不可以？从时刻 0 开始从每个 <span class="math inline">\(s\in S\)</span> 出发跑 <span class="math inline">\(|S|\)</span> 个不同的链，直到它们在未来某个时刻<span class="math inline">\(n\)</span>耦合为止，然后输出第一次耦合时的状态不行吗？</p><p><strong>问题 3</strong>：每次重启步骤 2时需要复用之前的随机数，这一点在证明中哪里用到了？使用一列新的随机数为什么不可以？</p></blockquote><p>我们用几个例子来说明这三个问题。</p><h2 id="为什么更新函数不能是任意的">为什么更新函数不能是任意的</h2><p>考虑含有两个状态 <span class="math inline">\(S=\{s_1, s_2\}\)</span>的 Markov 链，其转移矩阵为 <span class="math inline">\(P=\begin{bmatrix}0.5 &amp; 0.5\\0.5 &amp;0.5\end{bmatrix}\)</span>，更新函数为 <span class="math display">\[f(s_1, u) =\begin{cases}\begin{array}{ll}s_1&amp; \text{for } u \in [0, 0.5)\\s_2 &amp; \text{for } u \in [0.5,1]\end{array}\end{cases}\]</span> 和 <span class="math display">\[f(s_2,u) =\begin{cases}\begin{array}{ll}s_2 &amp; \text{for } u \in [0,0.5)\\s_1 &amp; \text{for } u \in [0.5,1]\end{array}\end{cases}\]</span> 于是若从 <span class="math inline">\(s_1,s_2\)</span>分别出发跑两个不同的链，但是每次使用相同的随机数，则它们要么保持不动，要么交换状态，永不耦合。</p><h2 id="为什么-coupling-into-the-future-不行">为什么 Coupling into thefuture 不行</h2><p>我打赌任何看到 CFTP算法的人都会想到同样的问题：为什么不能向未来耦合呢？</p><blockquote><p><strong>Coupling into the future</strong>: 从时刻 0 出发同时跑 <span class="math inline">\(|S|\)</span> 个不同的链，其中链 <span class="math inline">\(i\)</span> 的初始状态是 <span class="math inline">\(s_i\)</span>。当所有链首次耦合到同一状态 <span class="math inline">\(s^\ast\)</span> 时，终止算法并输出 <span class="math inline">\(s^\ast\)</span> 作为采样状态。</p></blockquote><p>向未来耦合与 CFTP有一个根本不同：向未来耦合的结束时间是一个随机时间，而在 CFTP中，我们总是在固定的时刻 0 观察所有链是否耦合。</p><p>我们来试试把上面 CFTP 的证明照抄在这里：设 <span class="math inline">\(\tau\)</span> 是所有 <span class="math inline">\(|S|\)</span> 条链首次耦合的时间，<span class="math inline">\(Y\)</span> 是额外的从时刻 0出发的、初始分布为平稳分布的链，并且使用相同的随机数流，则对任何时刻<span class="math inline">\(n\ge0\)</span>，<span class="math inline">\(Y_n\)</span>都服从平稳分布。但是当把下标换成随机时间 <span class="math inline">\(\tau\)</span> 时，<span class="math inline">\(Y_\tau\)</span>未必仍然服从平稳分布，所以之前的证明不再可用。</p><p>我们用一个反例来说明：仍然考虑两个状态 <span class="math inline">\(S=\{s_1, s_2\}\)</span> 的 Markov 链，其转移矩阵为<span class="math inline">\(P=\begin{bmatrix}0.5 &amp; 0.5\\1 &amp;0\end{bmatrix}\)</span>，即从 <span class="math inline">\(s_1\)</span>出发的话以 0.5 的概率待在原地，以 0.5 的概率跳到 <span class="math inline">\(s_2\)</span>，从 <span class="math inline">\(s_2\)</span> 出发的话则总是跳到 <span class="math inline">\(s_1\)</span>。</p><p><img style="margin:0px auto;display:block" width="250" src="/images/cftp/counter_example.svg"></p><p>这个链的平稳分布为 <span class="math inline">\(\pi=(\frac{2}{3},\frac{1}{3})\)</span>。现在假设从<span class="math inline">\(s_1,s_2\)</span> 分别出发，从时刻 0 开始向<span class="math inline">\(+\infty\)</span> 方向跑两个不同的链，<span class="math inline">\(\tau\)</span> 是它们首次耦合的时间，则 <span class="math inline">\(\tau-1\)</span> 时刻它俩必然一个位于 <span class="math inline">\(s_1\)</span>，一个位于 <span class="math inline">\(s_2\)</span>。但是位于 <span class="math inline">\(s_2\)</span> 的状态只能转移到 <span class="math inline">\(s_1\)</span>，所以 <span class="math inline">\(\tau\)</span> 时刻的输出永远是 <span class="math inline">\(s_1\)</span>，从而得到的采样 <span class="math inline">\(Y_\tau\)</span> 不满足平稳分布。</p><h2 id="为什么每次不能重新生成随机数">为什么每次不能重新生成随机数</h2><p>思考一下，在算法的证明当中，如果在每次迭代中都使用全新的随机数序列的话，那么事件<span class="math inline">\(A\)</span> 的定义会变成什么？难道是 <span class="math inline">\(\Omega\)</span>的某个有限子集，使得其包含一个可以耦合的序列？Hmm，这就不太对劲了。直观上看，在第<span class="math inline">\(m\)</span>次迭代时，由于生成的序列是全新的，有可能它实际上对某个 <span class="math inline">\(i&lt;m\)</span>，从 <span class="math inline">\(-N_i\)</span>出发就可以耦合，这会导致算法过度采样那些很快就可以耦合的短链，从而使得最终的分布不服从平稳分布。</p><p>我们继续用上一小节中的例子来说明。我们指定其更新函数 <span class="math inline">\(f\)</span>为随机映射表示一节中给出的阶梯函数形式。假设算法每次都使用一列新的随机数，其最终输出为<span class="math inline">\(s^\ast\)</span>。定义随机变量 <span class="math inline">\(\tau\)</span> 为正整数 <span class="math inline">\(m\)</span> 使得算法中使用的最早的出发时间为 <span class="math inline">\(-N_m\)</span>，则 <span class="math display">\[\begin{aligned}\mathbb{P}(s^\ast=s_1)&amp;=\sum_{m=1}^\infty\mathbb{P}(s^\ast=s_1,\tau=m)\\&amp;\geq\mathbb{P}(s^\ast=s_1,\tau=1)+\mathbb{P}(s^\ast=s_1,\tau=2)\\&amp;=\mathbb{P}(\tau=1)\mathbb{P}(s^\ast=s_1|\tau=1)+\mathbb{P}(\tau=2)\mathbb{P}(s^\ast=s_1|\tau=2)\end{aligned}\]</span> 注意事件 <span class="math inline">\(\{\tau=1\}\)</span> 包含两种不同的演化路径： <span class="math display">\[\begin{aligned}(1)\quad &amp; s_1\to s_1,\quads_2\to s_1.\\(2)\quad &amp; s_1\to s_2,\quad s_2\to s_1.\end{aligned}\]</span>其中只有前者能成功耦合，所以 <span class="math inline">\(\mathbb{P}(\tau=1)=\frac{1}{2}\)</span>，这时输出的状态只能是<span class="math inline">\(s_1\)</span>，所以<span class="math inline">\(\mathbb{P}(s^\ast=s_1|\tau=1)=1\)</span>。</p><p>可以看到这个长度是 1 的短链的耦合只发生在状态 <span class="math inline">\(s_1\)</span> 上，它非常偏爱 <span class="math inline">\(s_1\)</span>。</p><p>事件 <span class="math inline">\(\{\tau=2\}\)</span>包含四种不同的演化路径： <span class="math display">\[\begin{align*}(1)\quad &amp; s_1\to s_1\tos_1,\quad s_2\to s_1 \to s_1.\\(2)\quad &amp; s_1\to s_2\to s_1,\quad s_2\to s_1 \to s_1.\\(3)\quad &amp; s_1\to s_1\to s_2,\quad s_2\to s_1 \to s_2.\\(4)\quad &amp; s_1\to s_2\to s_1,\quad s_2\to s_1 \tos_2.\end{align*}\]</span>注意以下两种演化路径是非法的，因为每个时刻两个链使用的随机数一样，不可能在某个时刻同时出现一个链<span class="math inline">\(s_1\to s_2\)</span>，另一个 <span class="math inline">\(s_1\to s_1\)</span> 的情况： <span class="math display">\[\begin{array}{ll}(*)\quad &amp; s_1\to s_1\to s_2,\quad &amp;s_2\to s_1 \to s_1.\\(**)\quad &amp; s_1\to s_1\to s_1,\quad &amp;s_2\to s_1 \to s_2.\\\end{array}\]</span></p><p>在我们现在这个错误的版本中，由于使用了全新的随机数流，四种路径都是合法的。这四个路径中前三种都成功耦合，两个耦合于<span class="math inline">\(s_1\)</span> 一个耦合于 <span class="math inline">\(s_2\)</span>，所以 <span class="math inline">\(\mathbb{P}(s^\ast=s_1|\tau=2)=\frac{2}{3}\)</span>。</p><p>注意到其中第二条路径 <span class="math display">\[(2)\quad  s_1\tos_2\to s_1,\quad s_2\to s_1 \to s_1.\]</span> 从时刻 <span class="math inline">\(-1\)</span> 出发就可以耦合，它不应该属于事件 <span class="math inline">\(\{\tau=2\}\)</span>。每次使用全新的随机数流会导致偏爱<span class="math inline">\(s_1\)</span> 的短链被过度采样。</p><p>我们来具体验证一下： <span class="math display">\[\mathbb{P}(\tau=2)=\mathbb{P}(\tau\ne1)\cdot\mathbb{P}(\tau=2\\text{时耦合})=\frac{1}{2}\cdot\frac{3}{4}=\frac{3}{8}.\]</span></p><p>所以 <span class="math display">\[\begin{align*}\mathbb{P}(s^\ast=s_1)&amp;\geq\mathbb{P}(\tau=1)\mathbb{P}(s^\ast=s_1|\tau=1)+\mathbb{P}(\tau=2)\mathbb{P}(s^\ast=s_1|\tau=2)\\&amp;=\frac{1}{2}\cdot1+ \frac{3}{8}\cdot\frac{2}{3}\\&amp;=\frac{3}{4}&gt;\pi(s_1).\end{align*}\]</span></p><p>确实如我们的预言，<span class="math inline">\(s_1\)</span>被过度采样了。</p><h1 id="monotone-coupling-from-the-past">Monotone coupling from thepast</h1><p>在 CFTP 算法中，我们需要同时跑 <span class="math inline">\(|S|\)</span> 个不同的链并要求它们在时刻 0处耦合，当 <span class="math inline">\(|S|\)</span>很大时所耗的时间和计算量都很不划算，所以这个算法在应用中是有限制的。但是有一种情形它是非常好用的：如果<span class="math inline">\(S\)</span> 是一个偏序集 <span class="math inline">\((S, \preceq)\)</span>，有最大最小元 <span class="math inline">\(s_\max, s_\min\)</span>，并且更新函数 <span class="math inline">\(f\)</span> 与偏序 <span class="math inline">\(\preceq\)</span> 相容，即对任何 <span class="math inline">\(s,s'\in S\)</span>，<span class="math inline">\(u\in[0,1]\)</span>， <span class="math display">\[s\preceq s' \Rightarrow f(s, u) \preceqf(s', u),\]</span> 则我们只要对 <span class="math inline">\(s_\max,s_\min\)</span>这两个状态跑两个不同的链即可，当它俩耦合时，所有其它的链也会被“挤压”到相同的状态。这就是前面六边形的菱形密铺取样所采取的方法。</p><p>我们在所有菱形密铺组成的集合 <span class="math inline">\(S\)</span>上定义一个偏序 <span class="math inline">\(\preceq\)</span>，这个偏序的定义颇有技巧性，它需要将任一密铺对应到一个不相交的格点路径组，如下图所示：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/non-intersecting_paths_lozenge.svg"></p><p>图中一共出现了 <span class="math inline">\(c+2\)</span>条不相交的路径，其中最上方和最下方两条路径对任何密铺都是固定的（它俩是用来约束中间的 <span class="math inline">\(c\)</span>条路径，让它们在翻转的过程不要越界），中间的 <span class="math inline">\(c\)</span>条路径，每条路径的起点和终点也是固定的，它们从菱形最左边的边的每个单位线段中点出发，每一步分别向右上或者右下走一步，经过<span class="math inline">\(a+b\)</span>步后到达最右边的边的对应位置。</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/two_paths.svg"></p><p>上图中从菱形的最左边到最右边共有 <span class="math inline">\(a+b+1\)</span>条竖直的网格线，每一步向右上或者右下走一步会向右移动到下一个网格线，所以总共需要<span class="math inline">\(a + b\)</span>次到达最右边。不同的路径互不相交，所以它们的终点必须互不相同，因此这些终点必然分别依次是菱形最右边的单位线段的中点。</p><p>不难说明所有的菱形密铺和所有不相交路径组之间的一一对应关系：当密铺给定时，从左边每个起点出发开始，根据当前菱形的倾斜方向依次描出路径即可；反之当路径组给定时，可以沿着每条路径铺砖，这样确定所有的“斜”菱形的位置，余下的空白位置只有唯一的方式可以被水平的菱形填充。</p><p>我们在所有不相交的路径组之间定义一个偏序：两个路径组 <span class="math inline">\(\mathcal{P}\preceq\mathcal{P}'\)</span>当且仅当对任何 <span class="math inline">\(1\leq i\leqc+2\)</span>，<span class="math inline">\(\mathcal{P}\)</span> 中的第<span class="math inline">\(i\)</span> 条路径 <span class="math inline">\(p_i\)</span> 整体地位于 <span class="math inline">\(\mathcal{P}'\)</span> 中第 <span class="math inline">\(i\)</span> 条路径 <span class="math inline">\(p_i'\)</span>的下方。在这个偏序下的最大元就是所有路径尽可能地「向上拱」：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/max_state.svg"></p><p>而最小元则是所有路径尽可能地「向下走」：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/min_state.svg"></p><p>有了偏序，我们还要定义一个与之相容的更新函数 <span class="math inline">\(f\)</span>。<span class="math inline">\(f\)</span>的定义是这样的：对一个不相交路径组 <span class="math inline">\(\mathcal{P}\)</span>，我们每次在 <span class="math inline">\(\mathcal{P}\)</span> 的中间 <span class="math inline">\(c\)</span> 条路径中，在路径内部 （两头端点除外）任选一个顶点 <span class="math inline">\(v\)</span>：</p><ol type="1"><li>如果 <span class="math inline">\(v\)</span> 是一个「山峰」，即形如<span class="math inline">\(\wedge\)</span>，则我们以 1/2 的概率保持<span class="math inline">\(\mathcal{P}\)</span> 不变，以 1/2的概率尝试将 <span class="math inline">\(\mathcal{P}\)</span> 在 <span class="math inline">\(v\)</span> 处翻转为一个「山谷」 <span class="math inline">\(\vee\)</span>，如果翻转之后得到的路径组 <span class="math inline">\(\mathcal{P}'\)</span>仍然满足路径之间不相交的约束，则规定 <span class="math inline">\(\mathcal{P}'=f(\mathcal{P})\)</span>，否则仍然保持<span class="math inline">\(\mathcal{P}\)</span> 不变。</li><li>如果 <span class="math inline">\(v\)</span> 是一个「山谷」，即形如<span class="math inline">\(\vee\)</span>，则与上面的情形类似，我们以1/2 的概率保持 <span class="math inline">\(\mathcal{P}\)</span> 不变，以1/2 的概率尝试将 <span class="math inline">\(\mathcal{P}\)</span> 在<span class="math inline">\(v\)</span> 处翻转为一个「山峰」 <span class="math inline">\(\wedge\)</span>，如果翻转之后得到的路径组满足不相交的约束，则规定<span class="math inline">\(\mathcal{P}'=f(\mathcal{P})\)</span>，否则仍然保持<span class="math inline">\(\mathcal{P}\)</span> 不变。</li><li>如果 <span class="math inline">\(v\)</span>既不是「山峰」也不是「山谷」，则保持 <span class="math inline">\(\mathcal{P}\)</span> 不变。</li></ol><p>菱形密铺在三维空间中看起来像是「堆箱子」，这个翻转路径的操作就相当于从中添加/移除一个箱子，并且必须保证这个箱子有三个面可见：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/cftp/flip_lozenge.svg"></p><p>我们来验证 <span class="math inline">\(f\)</span>是和路径组之间的偏序 <span class="math inline">\(\preceq\)</span>相容的：设 <span class="math inline">\(\mathcal{P}\preceq\mathcal{P}'\)</span>是两个不相交路径组，对给定的随机操作 <span class="math inline">\(u\)</span>，<span class="math inline">\(f(\mathcal{P}, u)\)</span> 和 <span class="math inline">\(f(\mathcal{P}', u)\)</span> 就是对 <span class="math inline">\(\mathcal{P}\)</span> 和 <span class="math inline">\(\mathcal{P}'\)</span> 的同一个位置 <span class="math inline">\((k, j)\)</span>（即第 <span class="math inline">\(k\)</span> 条路径中的第 <span class="math inline">\(j\)</span> 个顶点）同时尝试进行一个 <span class="math inline">\(\vee\to\wedge\)</span> 或者 <span class="math inline">\(\wedge\to\vee\)</span> 的操作。不妨假设这个操作是<span class="math inline">\(\vee\to\wedge\)</span>，则有四种可能的结果：<span class="math inline">\(\mathcal{P}\)</span> 和 <span class="math inline">\(\mathcal{P}'\)</span>都操作成功，都保持不变或者一个操作成功另一个保持不变。不难验证这四种情况下都有<span class="math inline">\(f(\mathcal{P},u)\preceq f(\mathcal{P}',u)\)</span>。</p><p>由于每个不相交的路径组都可以通过适当操作变为最大元或者最小元，所以这个链是个互通的Markov 链。并且由于 <span class="math inline">\(\mathcal{P}\)</span>以至少 1/2 的概率在 <span class="math inline">\(f\)</span>下保持不变，这个链还是非周期的，因此是一个遍历的 Markov链，所以有唯一的平稳分布。但是不难看到这个链还是对称的，所以这个唯一的平稳分布是均匀分布。即从最大元和最小元出发跑CFTP，最终得到的样本服从全体菱形密铺上的均匀分布。</p><p>Monotone CFTP 也可以应用在其它许多密铺问题的均匀采样中，例如下图是在<span class="math inline">\(20\times 20\)</span>的矩形区域的所有多米诺骨牌密铺中均匀采样，同样可以把密铺一一对应到不相交的路径组：</p><p><img style="margin:0px auto;display:block" width="600" src="/images/cftp/domino_tiling_example.svg"></p><h1 id="参考文献">参考文献</h1><ol type="1"><li>Finite Markov chains and algorithmic applications, OlleHäggström.</li><li><a href="https://pages.uoregon.edu/dlevin/MARKOV/mcmt2e.pdf">Markovchains and mixing times</a>, Yuval Peres, Elizabeth L. Wilmer, David A.Levin.</li><li><a href="https://www.researchgate.net/publication/2455641_Markov_Chain_Algorithms_for_Planar_Lattice_Structures">MarkovChain Algorithms for Planar Lattice Structures</a>, Michael Luby, DanaRandall, Alistair Sinclair.</li><li><a href="https://arxiv.org/abs/math/0102193">Mixing times of lozengetiling and card shuffling Markov chains</a>, David B. Wilson.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 完美采样 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Wilson 均匀生成树算法</title>
      <link href="wilson-algorithm/"/>
      <url>wilson-algorithm/</url>
      
        <content type="html"><![CDATA[<div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>给定一个有限、无向的连通图 <span class="math inline">\(G= ( V,E )\)</span>，设 <span class="math inline">\(\mathcal{T}\)</span> 是 <span class="math inline">\(G\)</span> 的所有生成树组成的集合，怎样在 <span class="math inline">\(\mathcal{T}\)</span>中按照均匀分布进行采样？即设计一个算法，能够随机地给出 <span class="math inline">\(G\)</span> 的一个生成树，并且 <span class="math inline">\(\mathcal{T}\)</span>中每个生成树被取到的概率是相等的。</p></div><p>常见的生成树算法如 DFS/BFS 算法、Prim 算法、Kruskal算法等给出的生成树都不是完全随机的。例如，取 <span class="math inline">\(G\)</span> 为 <span class="math inline">\(\mathbb{Z}^2\)</span> 中 <span class="math inline">\(m\times n\)</span> 的网格图，<span class="math inline">\(G\)</span>的任何生成树都是一个迷宫，把背景平面涂黑，把生成树的边涂白，就可以清楚地看到迷宫的结构。迷宫的任何两个房间( 即顶点 ) 可以通过生成树中唯一的路径相连，这样的迷宫叫做完美迷宫。</p><p>DFS 算法 ( 每次将新顶点的顺序打乱再入栈 )倾向于尽可能深地探索整个图，因此得到的迷宫往往包含长且蜿蜒的路径，死角 (即叶节点 ) 是很少的：</p><p><img style="margin:0px auto;display: block" width="500" src="/images/gifmaze/random_dfs.gif"></p><span id="more"></span><p>与之相反，Prim算法由于每次是在当前树上随机添加一个叶节点，因此得到的迷宫往往包含很多死角：</p><p><img style="margin:0px auto;display: block" width="500" src="/images/gifmaze/prim.gif"></p><p>总之从直观上就可以看出这两个算法得到的生成树都不是完全随机的。</p><p>目前最快的生成均匀生成树的算法是 Wilson算法，它借助于擦圈的随机游动来实现。</p><div id="wilson-algo" class="statement sta_wilson___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Wilson算法</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(G\)</span> 是一个有限简单连通图。</p><ol type="1"><li>任取一个顶点 <span class="math inline">\(r\)</span>，维护一个树<span class="math inline">\(T\)</span>，初始时 <span class="math inline">\(T=\{r\}\)</span>。</li><li>任取一个不属于 <span class="math inline">\(T\)</span> 的顶点 <span class="math inline">\(v\)</span>，从 <span class="math inline">\(v\)</span>出发作图上的随机游动，一边走一边随时擦掉路径中出现的圈 ( 此谓之 looperased random walk ) ，即每当走到一个以前访问过的顶点 <span class="math inline">\(x\)</span>，则两次访问 <span class="math inline">\(x\)</span>之间的路径都被擦掉。按此规则持续行走直到与 <span class="math inline">\(T\)</span> 相遇为止，这时得到一条从 <span class="math inline">\(v\)</span> 到 <span class="math inline">\(T\)</span> 的不含圈的路径 <span class="math inline">\(p\)</span>，把 <span class="math inline">\(p\)</span> 加入到 <span class="math inline">\(T\)</span> 中，将 <span class="math inline">\(T\)</span> 更新为 <span class="math inline">\(T=T\cup p\)</span>。</li><li>重复步骤 2 直到 <span class="math inline">\(T\)</span> 包含 <span class="math inline">\(G\)</span> 的所有顶点，这时 <span class="math inline">\(T\)</span> 是一个服从均匀分布的生成树。</li></ol></div><p>下面是 Wilson 算法的 Javascript演示，你可以随时单击鼠标来重启动画。</p><script type="text/javascript" src="/code/wilson.js"></script><canvas id="wilson" width="600" height="600"></canvas><div id="two-arbitrary"><p>注意 Wilson 算法的描述中有两个<strong>任意</strong>：</p><ol type="1"><li>初始时可以任选一个初始根节点 <span class="math inline">\(r\)</span>。</li><li>每次可以任选一个不属于 <span class="math inline">\(T\)</span>的顶点出发作随机游动。</li></ol></div><p>Wilson 的 <a href="https://dl.acm.org/doi/10.1145/237814.237880">论文</a>中给出的证明相当有技巧性，而且有一些晦涩的部分，我是花了很久才真正理解。本文就来介绍这个证明。</p><h1 id="证明思路">证明思路</h1><p>先不管均匀分布的事情，我们来说明 Wilson 算法以概率 1会在有限时间内结束。</p><div id="algo-success" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题1.1</span>.</span><span class="statement-spah"> </span>Wilson 算法以概率1 在有限时间内返回一个生成树。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(G\)</span>有限且连通，所以其上的随机游动是常返的，在算法第 2步中，每次从一个新顶点 <span class="math inline">\(v\)</span>出发的随机游动以概率 1 在有限时间内撞到 <span class="math inline">\(T\)</span>。这样的循环只能执行有限多次 ( 次数以<span class="math inline">\(|V|\)</span> 为上界 ) ，所以算法以概率 1在有限时间内结束。<span class="math inline">\(\blacksquare\)</span></p><p>所以真正有挑战性的地方在于论证得到的生成树服从均匀分布。</p><p>证明的大致想法是这样的：我们构造概率空间 <span class="math inline">\(( \Omega,\mathbb{P} )\)</span> 和映射 <span class="math inline">\(\phi:\Omega\to\mathcal{T}\)</span>，使得它们满足如下的条件：</p><div id="requirements" class="statement simple plain unnumbered"><ol type="1"><li><span class="math inline">\(\phi\)</span> 对几乎处处的 <span class="math inline">\(\omega\in\Omega\)</span> 有定义 ( 不是所有的 <span class="math inline">\(\omega\)</span>都对应一个生成树，但这种例外发生的概率是 0 ) 。</li><li><span class="math inline">\(\phi\)</span> 是满射。 ( 不能漏掉任何树)</li><li>对任何树 <span class="math inline">\(T\in\mathcal{T}\)</span>，其在<span class="math inline">\(\Omega\)</span> 中的原像 <span class="math inline">\(\phi^{-1} ( T )\)</span> 的测度是一个与 <span class="math inline">\(T\)</span> 无关的常数。</li></ol></div><p>一旦找到了这样的概率空间 <span class="math inline">\((\Omega,\mathbb{P} )\)</span> 和映射 <span class="math inline">\(\phi\)</span>，则 <span class="math inline">\(\phi( \omega )\)</span> 以概率 1 是一个生成树，且服从 <span class="math inline">\(\mathcal{T}\)</span> 上的均匀分布。</p><p>构造 <span class="math inline">\(( \Omega,\mathbb{P} )\)</span> 和<span class="math inline">\(\phi\)</span> 的关键，是把 <span class="math inline">\(( \Omega,\mathbb{P} )\)</span>看作一个游戏的系统随机性，Wilson算法看作玩家的一种操作策略，但是这个策略对结果没有影响，即实际上任何游戏策略都会得到相同的结果，从而游戏结果完全由系统随机性<span class="math inline">\(\omega\in\Omega\)</span> 决定，这就是映射<span class="math inline">\(\phi\)</span>！</p><p>直接介绍 Wilson算法背后的游戏可能有点难以理解。作为热身，我们先来看看大家都熟悉的Tetris游戏（俄罗斯方块）。我希望你能从中理解「系统随机性」与「玩家策略」的区别。</p><p>经典的 Tetris 游戏是这样的，系统每次会随机从屏幕顶端落下 <span class="math inline">\(\{I,L,J,O,S,T,Z\}\)</span> 七种四方块 ( tetromino)中的一个。玩家可以在方块下落的过程中移动或者旋转它，尽可能地形成完整的水平行。每当出现完整的水平行时，这些行会被立刻消掉，同时玩家获得一定的分数。玩家的目的是获得尽可能高的分数。</p><p><img style="margin:0px auto;display: block" width="500" src="/images/wilson/tetris.gif"></p><p>Tetris游戏的结果由两个因素决定：系统的随机性和玩家的操作。这里系统的随机性是指每次落下的方块的随机性。</p><p>系统的随机性可以用一个概率空间 <span class="math inline">\((\Omega,\mathbb{P} )\)</span> 来描述：任何样本点 <span class="math inline">\(\omega\in\Omega\)</span> 是一个无穷序列 <span class="math inline">\(\omega=\{X_i\}_{i=1}^\infty\)</span>，其中 <span class="math inline">\(X_i\)</span> 表示第 <span class="math inline">\(i\)</span> 个落下的方块的类型，它来自对集合 <span class="math inline">\(\{I,L,J,O,S,T,Z\}\)</span>的独立且服从均匀分布的采样。<span class="math inline">\(\Omega\)</span>上的概率测度 <span class="math inline">\(\mathbb{P}\)</span>是无穷乘积测度。</p><p>例如，一个样本点 <span class="math inline">\(\omega\)</span>可能是这样的 <span class="math display">\[\omega=\{J, S, I, O, J, I, T,T, S, Z, Z, Z,\ldots\}.\]</span> 即第一个落下的方块是 <span class="math inline">\(J\)</span>，第二个是 <span class="math inline">\(S\)</span>，第三个是 <span class="math inline">\(I\)</span>，等等。</p><p>一旦给定了 <span class="math inline">\(\omega\)</span>，游戏的结果将只依赖于玩家的操作。</p><p>现在我要告诉你，Wilson 算法背后是一个类似 Tetris 的游戏，但又和Tetris 游戏有一个关键不同：Wilson算法的结果只依赖于系统的随机性，不依赖于玩家的操作。换句话说：对给定的<span class="math inline">\(\omega\)</span>，要么玩家的任何操作都会得到同一个生成树；要么任何操作都不能。即<span class="math inline">\(T\)</span> 是由 <span class="math inline">\(\omega\)</span>完全决定的。于是我们有一个确定的映射 <span class="math inline">\(\phi (\omega ) =T\)</span>！并且根据 <a href="#algo-success" title="命题 1.1">命题 1.1</a>, Wilson 算法以概率 1成功得到一个生成树，所以 <span class="math inline">\(\phi\)</span>对几乎处处的 <span class="math inline">\(\omega\)</span>是有定义的！</p><p>下面来具体介绍这个游戏。</p><h1 id="wilson-算法作为游戏策略">Wilson 算法作为游戏策略</h1><p>我们来玩一个叫做回路弹出 ( cycle popping )的游戏。我先介绍这个游戏背后的系统随机性 <span class="math inline">\((\Omega,\mathbb{P} )\)</span>。</p><div id="----------------omega--mathbb-p-------------" class="statement sta_________omega__mathbb_p_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">概率空间 <span class="math inline">\((\Omega,\mathbb{P} )\)</span> 的构造</span>.</span></p><ol type="1"><li>固定一个顶点 <span class="math inline">\(r\)</span>。对每个 <span class="math inline">\(v\ne r\)</span>，定义栈 <span class="math inline">\(S_v=\{S_{v,1},S_{v,2},\ldots\}\)</span>。<span class="math inline">\(S_v\)</span> 的长度是无穷，其元素 <span class="math inline">\(S_{v,i}\)</span> 都是来自 <span class="math inline">\(v\)</span>的邻居的均匀采样。所有栈元素都是独立的。顶点 <span class="math inline">\(r\)</span> 的栈是空栈：<span class="math inline">\(S_r=\emptyset\)</span>。</li><li>概率空间 <span class="math inline">\(\Omega\)</span> 是所有栈 <span class="math inline">\(\{S_v\mid v\ne r\}\)</span>的所有可能的状态组成的集合。这是一个无穷离散的概率空间，其上的测度 <span class="math inline">\(\mathbb{P}\)</span> 为乘积测度。</li></ol></div><p>为了方便，我们称 <span class="math inline">\(S_v\)</span> 的第 <span class="math inline">\(i\)</span> 个元素 <span class="math inline">\(S_{v,i}\)</span> 的颜色是 <span class="math inline">\(i\)</span>。</p><p>在任何时刻，这些栈 <span class="math inline">\(\{S_v,v\ner\}\)</span> 的栈顶元素都定义了一个有向图 <span class="math inline">\(\overrightarrow{G}_S\)</span>：在 <span class="math inline">\(\overrightarrow{G}_S\)</span> 中 <span class="math inline">\(v\rightarrow u\)</span> 当且仅当 <span class="math inline">\(u\)</span> 是 <span class="math inline">\(S_v\)</span> 的栈顶元素。每个 <span class="math inline">\(v\ne r\)</span> 的出度都恰好是 1，顶点 <span class="math inline">\(r\)</span> 的出度是 0。于是若 <span class="math inline">\(\overrightarrow{G}_S\)</span>不含回路的话它就是一个以 <span class="math inline">\(r\)</span>为根的生成树。</p><div id="------------------" class="statement sta_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">回路弹出游戏</span>.</span><span class="statement-spah"> </span>给定栈的一个状态 <span class="math inline">\(\omega\in\Omega\)</span>，<span class="math inline">\(\overrightarrow{G}_S\)</span> 是 <span class="math inline">\(\omega\)</span> 对应的栈顶图，若 <span class="math inline">\(\overrightarrow{G}_S\)</span>不含回路的话则它已经是一个生成树，游戏结束；否则设 <span class="math inline">\(C\)</span> 是 <span class="math inline">\(\overrightarrow{G}_S\)</span>中的一个回路，我们可以将其「弹出」：对每个 <span class="math inline">\(v\in C\)</span>，弹出 <span class="math inline">\(S_v\)</span> 的栈顶元素 ( 于是若当前 <span class="math inline">\(S_v\)</span> 的栈顶元素为 <span class="math inline">\(S_{v,i}\)</span>，则弹出 <span class="math inline">\(S_{v,i}\)</span> 以后栈顶元素变为 <span class="math inline">\(S_{v,i+1}\)</span> ) ，这样得到更新的 <span class="math inline">\(\overrightarrow{G}_S\)</span>。玩家每次可以任选<span class="math inline">\(\overrightarrow{G}_S\)</span>中的一个回路并将其弹出。如果玩家能够经过有限多次弹出操作后使得 <span class="math inline">\(\overrightarrow{G}_S\)</span> 中不含任何回路，即<span class="math inline">\(\overrightarrow{G}_S\)</span>是一个生成树，则玩家获胜。</p></div><p>在回路弹出游戏中，玩家能做的就是每次选择一个需要弹出的回路，别的什么也做不了。游戏开始之前，<span class="math inline">\(\overrightarrow{G}_S\)</span> 中所有顶点的颜色都是1，但是随着游戏的进行，<span class="math inline">\(\overrightarrow{G}_S\)</span>会变得「五颜六色」。一个回路中可以包含不同颜色的顶点。</p><div id="wilson-------------------------" class="statement sta_wilson_________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Wilson算法作为游戏策略</span>.</span><span class="statement-spah"></span>每次任选一个不属于 <span class="math inline">\(T\)</span> 的顶点<span class="math inline">\(v\)</span>，从 <span class="math inline">\(v\)</span> 出发按照 <span class="math inline">\(\overrightarrow{G}_S\)</span>的边的指引来搜索下一个要弹出的回路。</p></div><p>树 <span class="math inline">\(T\)</span>的作用是维护那些已经完全确定下来、必然属于最终生成树的那些边。这是因为，<span class="math inline">\(T\subset\overrightarrow{G}_S\)</span> 始终是一个以<span class="math inline">\(r\)</span> 为根节点的有向树，从 <span class="math inline">\(T\)</span> 中的任何顶点出发沿着 <span class="math inline">\(\overrightarrow{G}_S\)</span>的有向边都会走到根节点 <span class="math inline">\(r\)</span>。而 <span class="math inline">\(r\)</span> 是个死胡同 ( <span class="math inline">\(r\)</span> 的出度是 0 ) ，所以 <span class="math inline">\(T\)</span> 中的顶点不可能属于任何回路。</p><p>我们前面剧透过，回路弹出游戏的结果不依赖于玩家的操作。我们把这个事实的证明放在后面，先承认它是正确的，于是我们可以定义映射<span class="math inline">\(\phi\)</span>：</p><div id="-phi----------" class="statement sta__phi____ plain unnumbered"><p><span class="statement-heading"><span class="statement-label"><span class="math inline">\(\phi\)</span> 的构造</span>.</span><span class="statement-spah"> </span>设使用 Wilson 算法对 <span class="math inline">\(\omega\)</span> 执行操作以后得到的生成树为 <span class="math inline">\(T\)</span>，定义 <span class="math inline">\(\phi( \omega ) =T\)</span>。</p></div><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(T\)</span> 服从所有生成树组成的集合 <span class="math inline">\(\mathcal{T}\)</span> 上的均匀分布。</p></div><p>这个结论解释了为什么 Wilson 算法中的 <a href="#two-arbitrary">两个任意</a> 对最终结果是没有影响的。</p><p><strong>证明</strong>：我们来计算如下事件的概率：依次弹出回路 <span class="math inline">\(\mathcal{C}= ( C_1,\ldots,C_n )\)</span>后得到的生成树是 <span class="math inline">\(T\)</span>。注意 <span class="math inline">\(\mathcal{C}\)</span> 和 <span class="math inline">\(T\)</span>的顶点必然<strong>无缝隙</strong>地填满栈 <span class="math inline">\(\{S_v\}\)</span> 的上面的部分，所以这个概率就是<span class="math inline">\(\mathcal C\)</span> 和 <span class="math inline">\(T\)</span> 中的边各自指向正确位置的概率： <span class="math display">\[\mathbb{P} ( \mathcal{C},T ) =\prod_{e\in\mathcal{C}\cup T} p_e=\Phi ( T ) \cdot \Phi ( \mathcal{C} ).\]</span> 这里 <span class="math inline">\(\Phi ( \bullet )\)</span>返回集合 <span class="math inline">\(\bullet\)</span>中所有边的概率的乘积。</p><p>设 <span class="math inline">\(\mathcal{C}_T\)</span> 是所有可能得到<span class="math inline">\(T\)</span> 的那些 <span class="math inline">\(\mathcal{C}\)</span> 组成的集合，在上式两边对<span class="math inline">\(\mathcal{C}_T\)</span> 求和，则 <span class="math display">\[\mathbb{P} ( T ) =\left (\sum_{\mathcal{C}\in\mathcal{C}_T}\Phi ( \mathcal C ) \right ) \cdot\Phi( T ) .\]</span> 然而 <span class="math inline">\(\mathcal{C}_T\)</span>是一个与 <span class="math inline">\(T\)</span>无关的集合，这是因为在给定 <span class="math inline">\(\mathcal{C}\)</span> 后，任何生成树 <span class="math inline">\(T\)</span> 都有可能出现 ( 解释见后面 ) ，因此<span class="math display">\[\mathbb{P} ( T ) ={\rm const}\cdot \Phi ( T) .\]</span> 而 <span class="math inline">\(\Phi ( T ) =\prod\limits_{v\ne r} ( 1/d_v )\)</span> 是与 <span class="math inline">\(T\)</span> 无关的量，从而 <span class="math inline">\(\mathbb{P} ( T )\)</span> 是常数，这就证明了 <span class="math inline">\(\phi\)</span> 满足 <a href="#requirements" title="条件 3">条件 3</a> 。</p><p>为什么给定 <span class="math inline">\(\mathcal{C}\)</span> 以后任何<span class="math inline">\(T\)</span>都可能出现？打个比方，想象一个向弹夹里面压子弹的过程：把树 <span class="math inline">\(T\)</span> 放在栈顶，然后依次用 <span class="math inline">\(C_n,\ldots,C_1\)</span> 将 <span class="math inline">\(T\)</span> 往下压，得到一个栈的状态 <span class="math inline">\(\{S_v\}\)</span>，对这个状态执行回路弹出，显然依次弹出的就是<span class="math inline">\(C_1,\ldots,C_n\)</span>，最终得到的树是<span class="math inline">\(T\)</span>。这顺便也说明了 <span class="math inline">\(\phi\)</span> 是满射的。</p><p>现在 <span class="math inline">\(\phi\)</span> 满足前面提到的全部 <a href="#requirements" title="三个条件">三个条件</a> ，这就证明了 Wilson算法的正确性。</p><h1 id="游戏结果与策略无关">游戏结果与策略无关</h1><p>最后我们证明最关键的部分：Wilson算法的结果与每次选择弹出的回路无关。</p><p>假设有若干玩家分别玩回路弹出的游戏，每个人采取的策略是不同的。我们想知道，对给定的系统随机性<span class="math inline">\(\omega\)</span>，这些玩家都能获胜吗？他们最终得到的生成树一样吗？需要的操作次数相同吗？</p><p>答案是：不管这些玩家采取怎样的策略，只有两种可能的结果出现：</p><ol type="1"><li>所有人都不能获胜。</li><li>所有人都能获胜，而且每个人使用的操作次数也相同，最终得到的栈顶图<span class="math inline">\(\overrightarrow{G}_S\)</span>也相同。不仅如此，每个人弹出的回路组成的集合 <span class="math inline">\(\{C_1,\ldots,C_n\}\)</span>也都是相同的。注意这里的回路 <span class="math inline">\(C_i\)</span>是带有颜色标记的，两个回路相同不仅要求包含的顶点相同，也要求对应顶点的颜色相同。仅仅弹出的顺序可能不同。</li></ol><p>我们只要证明如下的结论即可：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>对任一栈状态 <span class="math inline">\(\omega\in\Omega\)</span>，若玩家 <span class="math inline">\(A\)</span> 可以经过 <span class="math inline">\(n\)</span> 次操作后获胜，其弹出的回路依次为 <span class="math inline">\(C_1,\ldots,C_n\)</span>，则不论玩家 <span class="math inline">\(B\)</span> 的策略如何，其必然也经过 <span class="math inline">\(n\)</span> 次操作后获胜，其弹出的回路集合 <span class="math inline">\(\{D_1,\ldots,D_n\}\)</span> 与 <span class="math inline">\(\{C_1,\ldots,C_n\}\)</span> 是相同的，即适当重排<span class="math inline">\(\{D_1,\ldots,D_n\}\)</span> 后有 <span class="math inline">\(D_i=C_i\)</span>。</p></div><p><strong>证明</strong>：对玩家 <span class="math inline">\(A\)</span>的操作次数 <span class="math inline">\(n\)</span> 归纳。<span class="math inline">\(n=0\)</span> 时结论显然成立 ( 双方均无任何操作 )，下面设 <span class="math inline">\(n\geq1\)</span> 且结论对所有小于<span class="math inline">\(n\)</span> 的情形成立。</p><p>设 <span class="math inline">\(B\)</span> 第一次弹出的回路是 <span class="math inline">\(D_1\)</span>，如果 <span class="math inline">\(C_1=D_1\)</span> 则这一步操作后 <span class="math inline">\(A,B\)</span> 到达了相同的状态，而 <span class="math inline">\(A\)</span> 可以继续经过 <span class="math inline">\(n-1\)</span> 次操作后获胜，于是根据归纳假设 <span class="math inline">\(B\)</span> 也一定经过 <span class="math inline">\(n-1\)</span> 次操作获胜且后续操作 <span class="math inline">\(\{D_2,\ldots,D_n\}=\{C_2,\ldots,C_n\}\)</span>。</p><p>如果 <span class="math inline">\(C_1\ne D_1\)</span>，我们断言 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(D_1\)</span> 没有公共的顶点。否则若 <span class="math inline">\(v\in C_1\cap D_1\)</span>，由于第一次操作时 <span class="math inline">\(C_1,D_1\)</span> 属于同一个栈顶图中，以及 <span class="math inline">\(v\)</span> 的出度是 1，所以 <span class="math inline">\(v\)</span> 在 <span class="math inline">\(G_S\)</span> 中的后继 <span class="math inline">\(v_1\)</span> 也同时属于 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(D_1\)</span>，进而 <span class="math inline">\(v_1\)</span> 的后继 <span class="math inline">\(v_2\)</span> 也是如此，这样一直下去回到 <span class="math inline">\(v\)</span> 就会有 <span class="math inline">\(C_1=D_1\)</span>，矛盾。</p><p>既然 <span class="math inline">\(C_1\)</span> 和 <span class="math inline">\(D_1\)</span> 没有相同顶点，那说明不论先弹 <span class="math inline">\(C_1\)</span> 后弹<span class="math inline">\(D_1\)</span>，或是先弹 <span class="math inline">\(D_1\)</span> 后弹 <span class="math inline">\(C_1\)</span>，得到的栈顶图是一样的。</p><p>接下来的论述是钻石引理 ( diamond lemma )的典型操作：我们引入两个新玩家 <span class="math inline">\(A'\)</span> 和 <span class="math inline">\(B'\)</span>：<span class="math inline">\(A'\)</span> 的前两步操作是先弹出 <span class="math inline">\(C_1\)</span> 后弹出 <span class="math inline">\(D_1\)</span>，<span class="math inline">\(B'\)</span> 的前两步操作是先弹出 <span class="math inline">\(D_1\)</span> 后弹出 <span class="math inline">\(C_1\)</span>。</p><ol type="1"><li><span class="math inline">\(A\)</span> 和 <span class="math inline">\(A'\)</span> 第一步操作相同，因此由归纳假设<span class="math inline">\(A'\)</span> 可以经过 <span class="math inline">\(n-2\)</span> 步后获胜；</li><li><span class="math inline">\(A'\)</span> 和 <span class="math inline">\(B'\)</span> 前两步操作后到达相同的状态，而已知<span class="math inline">\(A'\)</span> 可以在 <span class="math inline">\(n-2\)</span> 步后获胜，所以由归纳假设 <span class="math inline">\(B'\)</span> 也可以在 <span class="math inline">\(n-2\)</span> 步后获胜；</li><li><span class="math inline">\(B'\)</span> 和 <span class="math inline">\(B\)</span> 第一步操作相同，而已知 <span class="math inline">\(B'\)</span> 可以在 <span class="math inline">\(n-1\)</span> 步后获胜，所以由归纳假设 <span class="math inline">\(B\)</span> 也可以在 <span class="math inline">\(n-1\)</span> 步后获胜。</li></ol><p><span class="math inline">\(A,B,A',B'\)</span>弹出的回路集合相同是显然的。</p><p>至此我们就说明了 <span class="math inline">\(\phi\)</span>的定义是合理的，它是一个确定的映射。</p><p>对没有接触过钻石引理的读者，我这个论述比 Wilson的原证明的论述要繁琐，但是这个角度更本质地揭示了为什么游戏的结果不依赖于具体的策略。</p>]]></content>
      
      
      <categories>
          
          <category> 完美采样 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter element</title>
      <link href="coxeter-element/"/>
      <url>coxeter-element/</url>
      
        <content type="html"><![CDATA[<p>如果你对 Lie 代数有所了解的话，相信很大概率你会见过下面的图案： (参考维基百科的 <a href="https://en.wikipedia.org/wiki/Lie_algebra">Liealgebra 词条</a> )</p><p><img style="margin:0px auto;display: block" src="/images/coxeter-element/e8.svg" width="350"></p><p>它展示的是 Lie 代数 <span class="math inline">\(E_8\)</span>的根系图。<span class="math inline">\(E_8\)</span> 的根系由 8 维欧式空间<span class="math inline">\(\mathbb{R}^8\)</span> 中的 240个向量组成，将这 240 个向量投影到一个特殊的 2 维平面 ( 叫做 Coxeter 平面) 上就会呈现出一个具有旋转对称性的图案。在上图中可以看到，240个投影点分布在 8 个圆周上，每个圆周包含 30个均匀分布的点，整个图案在角度为 <span class="math inline">\(2\pi/30\)</span> 的旋转下是不变的。<span class="math inline">\(h=30\)</span> 正是 <span class="math inline">\(E_8\)</span> 的 Coxeter 数。</p><p>本文目的是介绍 Coxeter 元的一些基础知识，然后教大家怎样在 Python中编写一个程序绘制上面的投影图案。我主要参考了 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990</a>)</span> 和 <span class="citation" data-cites="CasselmanCoxeterElement">(<a href="#ref-CasselmanCoxeterElement" role="doc-biblioref">Casselman2017</a>)</span>。虽然这里面涉及的数学并不复杂，但是真正动手编程实现的时候会有一些魔鬼藏在细节中，而这些细节是仅凭念书很难发现的。</p><p>本文的代码在 <a href="https://github.com/neozhaoliang/pywonderland/raw/master/src/misc/E8.py">Github上</a> 。David Madore 也有一个很棒的 <a href="http://www.madore.org/~david/math/e8w.html">交互式网页</a>可以绘制 <span class="math inline">\(E_8\)</span>的多种不同风格的图案。</p><span id="more"></span><h1 id="coxeter-元">Coxeter 元</h1><p>设 <span class="math inline">\((W,S)\)</span> 是一个有限不可约Coxeter 群。<span class="math inline">\(S\)</span>中的生成元满足关系：对任何 <span class="math inline">\(s_i,s_j\inS\)</span> 有 <span class="math inline">\((s_is_j)^{m_{ij}}=1\)</span>。其中 <span class="math inline">\(m_{ij}\geq 2\)</span> 是正整数，并且每个 <span class="math inline">\(m_{ii}=1\)</span>。记 <span class="math inline">\(|S|=n\)</span>。</p><p>设 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(n\)</span> 维实向量空间，<span class="math inline">\(\Delta=\{\alpha_1,\ldots,\alpha_n\}\)</span> 是<span class="math inline">\(V\)</span> 的一组基，<span class="math inline">\(\Delta\)</span> 叫做一组单根。定义 <span class="math inline">\(V\)</span> 上的内积 <span class="math inline">\(\bullet\)</span> 如下： <span class="math display">\[\alpha_i\bullet\alpha_j=-\cos\frac{\pi}{m_{ij}}.\]</span>在这个内积下，每个 <span class="math inline">\(\alpha_i\in\Delta\)</span> 都是单位向量：<span class="math inline">\(\alpha_i\bullet\alpha_i=1\)</span>。</p><p><span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, secs.6.2–6.4</a>)</span> 中证明了 <span class="math inline">\(( W,S)\)</span> 是有限群当且仅当 <span class="math inline">\(\bullet\)</span>是正定的。</p><p>记 <span class="math inline">\(A= ( \alpha_i\bullet\alpha_j )_{1\leqi,j\leq n}\)</span> 是 <span class="math inline">\(\bullet\)</span> 在<span class="math inline">\(\Delta\)</span> 这组基下的 Gram 矩阵，<span class="math inline">\(A\)</span> 叫做 Cartan 矩阵。</p><p>规定每个生成元 <span class="math inline">\(s_i\in S\)</span> 在 <span class="math inline">\(V\)</span> 上的作用为 <span class="math display">\[s_i ( v ) = v - 2 ( v\bullet\alpha_i )\alpha_i,\quad v\in V.\]</span> 即 <span class="math inline">\(s_i\)</span> 是关于以 <span class="math inline">\(\alpha_i\)</span>为法向量的超平面的反射。这个作用将 <span class="math inline">\(W\)</span> 同构地映射为 <span class="math inline">\(O ( V )\)</span> 的一个有限反射子群。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{i_1,i_2,\ldots,i_n\}\)</span> 是集合 <span class="math inline">\(\{1,2,\ldots,n\}\)</span> 的一个置换，乘积 <span class="math inline">\(s_{i_1}s_{i_2}\cdots s_{i_n}\)</span> 叫做<strong>Coxeter 元</strong>。</p></div><p>换句话说，Coxeter 元就是把 <span class="math inline">\(W\)</span>的生成元 <span class="math inline">\(s_1,\ldots,s_n\)</span>按照任意顺序排列，然后相乘得到的群元素。</p><div id="coxeter-conjugate" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span> <span class="statement-info">(<span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.3.16</a>)</span>)</span>.</span><span class="statement-spah"></span>所有 Coxeter 元都是互相共轭的。</p></div><p>由于 Coxeter元都是共轭的，所以它们有相同的阶、特征多项式和特征值。任一 Coxeter元的阶叫做 <span class="math inline">\(W\)</span> 的 <strong>Coxeter数</strong>，记作 <span class="math inline">\(h\)</span>。</p><p>设 <span class="math inline">\(\gamma\)</span> 是一个 Coxeter元，由于 <span class="math inline">\(\gamma\)</span> 满足 <span class="math inline">\(\gamma^h=1\)</span>，所以 <span class="math inline">\(\gamma\)</span> 的特征值必然都是 <span class="math inline">\(h\)</span>- 次单位根，而且复特征值成对共轭出现：<span class="math display">\[\{\zeta^{m_1},\ldots,\zeta^{m_n},0\leqm_i&lt;h\}.\]</span> 其中 <span class="math inline">\(\zeta\)</span>是本原 <span class="math inline">\(h\)</span>- 次单位根。在 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec. 3.16</a>)</span> 中证明了 1不可能是 <span class="math inline">\(\gamma\)</span>的特征值，所以实际上每个指数 <span class="math inline">\(1\leq m_i\leqh-1\)</span>。<span class="math inline">\(\gamma\)</span>如果有实特征值的话只可能是 <span class="math inline">\(-1\)</span>( 对应<span class="math inline">\(\zeta^{h/2}\)</span> ) 。</p><p>我们取一种特殊的 Coxeter 元如下：设 <span class="math inline">\((W,S)\)</span> 的 Coxeter 图为 <span class="math inline">\(\Gamma\)</span>，由于 <span class="math inline">\(W\)</span> 是有限 Coxeter 群，<span class="math inline">\(\Gamma\)</span> 是一个树。任取 <span class="math inline">\(\Gamma\)</span> 的一个顶点作为 <span class="math inline">\(s_n\)</span>，将 <span class="math inline">\(\Gamma\)</span> 的顶点按照与 <span class="math inline">\(s_n\)</span> 的图距离分成两个不相交的集合 <span class="math inline">\(\Gamma=I\sqcup J\)</span>：<span class="math inline">\(I\)</span> 由所有与 <span class="math inline">\(s_n\)</span> 的距离为偶数的顶点组成（包含 <span class="math inline">\(s_n\)</span>）；<span class="math inline">\(J\)</span> 由所有与 <span class="math inline">\(s_n\)</span> 的距离为奇数的顶点组成。<span class="math inline">\(\Gamma\)</span>是树这一点保证了顶点之间的距离是唯一确定的。于是 <span class="math inline">\(I\)</span> 中的顶点两两不相邻，从而 <span class="math inline">\(\{s_i,i\in I\}\)</span> 中的生成元两两交换。<span class="math inline">\(J\)</span> 也是如此。记 <span class="math display">\[x=\prod_{i\in I}s_i,\quad y=\prod_{j\inJ}s_j.\]</span> 则 <span class="math inline">\(\gamma=xy\)</span> 是Coxeter 元。我们下面对 <span class="math inline">\(\gamma\)</span>进行分析。</p><h1 id="coxeter-平面">Coxeter 平面</h1><p>设 <span class="math inline">\(\{\omega_i\}_{i=1}^n\)</span> 是 <span class="math inline">\(\{\alpha_i\}_{i=1}^n\)</span> 在内积 <span class="math inline">\(\bullet\)</span> 下的对偶基： <span class="math display">\[(\alpha_i\bullet\omega_j)=\delta_{ij}.\]</span><span class="math inline">\({\bf A}\)</span> 是把每个 <span class="math inline">\(\omega_i\)</span> 映射为 <span class="math inline">\(\alpha_i\)</span> 的线性变换： <span class="math display">\[{\bf A}\omega_i=\alpha_i,\quad \forall 1\leqi\leq n.\]</span> 则 <span class="math inline">\({\bf A}\)</span> 在<span class="math inline">\(\{\omega_i\}_{i=1}^n\)</span>这组基下的矩阵就是 Cartan 矩阵 <span class="math inline">\(A\)</span>。</p><p>在 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.2.6</a>)</span> 中证明了矩阵 <span class="math inline">\(A\)</span>的极小特征值 <span class="math inline">\(c&gt;0\)</span> 的重数是1，并且对应的特征向量 <span class="math inline">\({\bfc}=(c_1,\ldots,c_n)\)</span> 的所有分量都是正的。于是 <span class="math display">\[{\bf A}\sum_{i=1}^nc_i\omega_i =c\left(\sum_{i=1}^nc_i\omega_i\right).\]</span> 特征向量 <span class="math inline">\(\sum_{i=1}^nc_i\omega_i\)</span> 可以写成两个向量<span class="math inline">\(\lambda,\mu\)</span> 的和，其中 <span class="math display">\[\lambda=\sum_{i\in I} c_i\omega_i,\quad\mu=\sum_{j\in J}c_j\omega_j.\]</span> <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec. 3.17</a>)</span> 中证明了<span class="math inline">\(\lambda,\mu\)</span> 张成一个二维子空间<span class="math inline">\(P\)</span>，<span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 限制在 <span class="math inline">\(P\)</span> 上分别是保持直线 <span class="math inline">\(\mathbb{R}\mu\)</span> 和 <span class="math inline">\(\mathbb{R}\lambda\)</span> 不动的反射，从而 <span class="math inline">\(\gamma=xy\)</span> 限制在 <span class="math inline">\(P\)</span> 上是一个旋转，并且这个旋转的阶与 <span class="math inline">\(\gamma\)</span> 的阶相同，也是 <span class="math inline">\(h\)</span>，从而旋转的角度等于 <span class="math inline">\(2\pi/h\)</span>。由于 <span class="math inline">\(\gamma\)</span> 置换根系 <span class="math inline">\(\Phi\)</span>，所以如果我们把 <span class="math inline">\(\Phi\)</span> 投影到 <span class="math inline">\(P\)</span> 上，就会看到一个具有 <span class="math inline">\(h\)</span> 阶旋转对称性的图案。</p><p>不过直接使用上面 <span class="math inline">\(\lambda,\mu\)</span>的定义来计算 <span class="math inline">\(P\)</span>是很不方便的，因为其中涉及了对偶基 <span class="math inline">\(\{\omega_i\}\)</span>。我们可以绕开对偶基的计算，这一点其实隐藏在<span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990,78</a>)</span> 中，那里证明了 <span class="math display">\[\begin{aligned}(c-1)\mu+\lambda &amp;=\sum_{i\in I}c_i\alpha_i,\\(c-1)\lambda+\mu &amp;=\sum_{j\in J}c_j\alpha_j.\end{aligned}\]</span></p><p>由于 <span class="math inline">\(c\ne 1\)</span>（1 不是 Coxeter元的特征值），上式告诉我们 <span class="math display">\[P=\mathop{\mathrm{span}}\{\lambda,\,\mu\}=\mathop{\mathrm{span}}\left\{\sum_{i\inI}c_i\alpha_i,\,\sum_{j\inJ}c_j\alpha_j\right\}.\tag{$\ast$}\label{eq:alpha}\]</span>所以我们完全可以通过特征向量 <span class="math inline">\({\bfc}\)</span> 和 <span class="math inline">\(\Delta\)</span> 得出 <span class="math inline">\(P\)</span> 的一组基。</p><h1 id="进一步改进">进一步改进</h1><p>如果你去看 <a href="https://github.com/neozhaoliang/pywonderland/blob/master/src/misc/E8.py">Github代码</a> 的话，会发现它并不是完全按上面的逻辑写的。这是怎么回事呢？</p><p>前面的计算有个美中不足之处，就是我们需要显式地将 <span class="math inline">\(S\)</span> 的划分为两个不相交的子集 <span class="math inline">\(S=I\sqcup J\)</span>，使得 <span class="math inline">\(I,J\)</span>各自的生成元之间互相交换。这一步是可以避免的，下面的方法我是从 <span class="citation" data-cites="CasselmanCoxeterElement">(<a href="#ref-CasselmanCoxeterElement" role="doc-biblioref">Casselman2017</a>)</span> 中学到的。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.1</span> <span class="statement-info">(<span class="citation" data-cites="CasselmanCoxeterElement">(<a href="#ref-CasselmanCoxeterElement" role="doc-biblioref">Casselman 2017,lemma. 3.3</a>)</span>)</span>.</span><span class="statement-spah"></span><span class="math inline">\(2I + \gamma + \gamma^{-1}= ( 2I-A)^2\)</span>。</p></div><p>根据这个结论，如果 <span class="math inline">\(s=e^{i\theta}\)</span>和 <span class="math inline">\(\bar{s}=e^{-i\theta}\)</span> 是 <span class="math inline">\(\gamma\)</span> 的一对共轭的复特征值，<span class="math inline">\(V_s,V_{\bar{s}}\)</span>分别是对应的特征子空间，记 <span class="math inline">\(U=V_s\oplusV_{\bar{s}}\)</span>，则对 <span class="math inline">\(v\in U\)</span>有 <span class="math display">\[( 2I-A )^2 ( v ) = (2+e^{i\theta}+e^{-i\theta} ) v= 4\cos^2(\theta/2) v.\]</span> 即 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(( 2I-A)^2\)</span> 的特征值为 <span class="math inline">\(4\cos^2(\theta/2)\)</span> 的特征子空间。</p><p>我们想把这个结论中的平方去掉，即证明 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(2I-A\)</span> 的特征值为 <span class="math inline">\(\pm 2\cos(\theta/2)\)</span>的特征子空间的直和。</p><div id="u-pm" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(U_{\pm}\)</span> 分别是 <span class="math inline">\(2I-A\)</span> 的 <span class="math inline">\(\pm2\cos(\theta/2)\)</span> 特征子空间，则 <span class="math inline">\(\dim U_+=\dim U_-\)</span> 并且 <span class="math inline">\(U=U_+\oplus U_-\)</span>。</p></div><p><strong>证明</strong>：显然 <span class="math inline">\(U_+\oplusU_-\subseteq U\)</span>。下面证明反向包含。</p><p>显然 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(2I-A\)</span> 的不变子空间。由于 <span class="math inline">\(2I-A\)</span> 是可对角化的，所以 <span class="math inline">\(2I-A\)</span> 限制在 <span class="math inline">\(U\)</span> 上也可以对角化，即 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(2I-A\)</span> 的特征子空间的直和。显然 <span class="math inline">\(2I-A\)</span> 在 <span class="math inline">\(U\)</span> 上的特征值只有可能是 <span class="math inline">\(\pm 2\cos(\theta/2)\)</span>，从而 <span class="math inline">\(U\subseteq U_+\oplus U_-\)</span>，即 <span class="math inline">\(U=U_+\oplus U_-\)</span>。</p><p>为了说明 <span class="math inline">\(\dim U_+=\dimU_-\)</span>，我们需要下面的引理：</p><div id="same-characteristic" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.3</span> <span class="statement-info">(<span class="citation" data-cites="CasselmanCoxeterElement">(<a href="#ref-CasselmanCoxeterElement" role="doc-biblioref">Casselman 2017,lemma. 3.5</a>)</span>)</span>.</span><span class="statement-spah"></span><span class="math inline">\(2I-A\)</span> 和 <span class="math inline">\(A-2I\)</span> 有同样的特征多项式。</p></div><p>这个引理告诉我们，若 <span class="math inline">\(\lambda\)</span> 是<span class="math inline">\(A-2I\)</span> 的特征值，则 <span class="math inline">\(-\lambda\)</span>也是，并且二者对应的特征子空间的维数相同（注意 <span class="math inline">\(A-2I\)</span> 是可对角化的）。于是 <span class="math inline">\(\dim U_+=\dim U_-\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p><a href="#u-pm" title="命题 3.2">命题 3.2</a> 的等价说法是 <span class="math inline">\(U_{\pm}\)</span> 分别是 <span class="math inline">\(A\)</span> 的特征值为 <span class="math inline">\(2\mp2\cos(\theta/2)\)</span>的特征子空间，所以我们有如下推论：</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论3.4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(A\)</span> 的不等于 2 的特征值成对出现，它们形如<span class="math inline">\(2\mp2\cos(\theta/2)\)</span>，并且它们对应的特征子空间<span class="math inline">\(U_{\pm}\)</span> 的维数是相等的。<span class="math inline">\(U=U_+\oplus U_-\)</span> 是 <span class="math inline">\(\gamma\)</span> 的复特征值 <span class="math inline">\(e^{\pm i\theta}\)</span>对应的特征子空间的直和。</p></div><p>一般来说 <span class="math inline">\(U\)</span> 的维数未必是 2，所以<span class="math inline">\(U\)</span> 不一定是平面。</p><p>设 <span class="math inline">\(c_\min=2-2\cos(\theta_0/2)\)</span> 是<span class="math inline">\(A\)</span> 的极小特征值，则 <span class="math inline">\(c_\max=2+2\cos(\theta_0/2)\)</span> 是 <span class="math inline">\(A\)</span> 的极大特征值。我们知道 <span class="math inline">\(c_\min\)</span> 的重数是 1，从而 <span class="math inline">\(c_\max\)</span> 的重数也是 1，这时 <span class="math inline">\(U\)</span> 就是一个二维平面，并且 <span class="math inline">\(\gamma\)</span> 在 <span class="math inline">\(U\)</span> 上的作用是角度为 <span class="math inline">\(\theta_0\)</span> 的旋转。这个 <span class="math inline">\(U\)</span> 就是要找的 Coxeter 平面 <span class="math inline">\(P\)</span>。</p><p>于是计算 <span class="math inline">\(P\)</span> 归结为计算线性变换<span class="math inline">\({\bf A}\)</span> 在 <span class="math inline">\(\{\omega_i\}_{i=1}^n\)</span>这组基下极小/极大特征值对应的特征向量。设 <span class="math inline">\((c_1,\ldots,c_n)\)</span> 和 <span class="math inline">\((c_1',\ldots,c_n')\)</span> 分别是矩阵<span class="math inline">\(A\)</span> 对应 <span class="math inline">\(c_\min,c_\max\)</span> 的特征向量，则 <span class="math inline">\(\sum_{i=1}^nc_i\omega_i\)</span> 和 <span class="math inline">\(\sum_{i=1}^nc_i'\omega_i\)</span> 就是 <span class="math inline">\({\bf A}\)</span> 对应 <span class="math inline">\(c_\min,c_\max\)</span> 的特征向量。它们被 <span class="math inline">\({\bf A}\)</span>作用以后与自身相差一个常数倍，从而 <span class="math inline">\(P\)</span> 由这两个向量张成： <span class="math display">\[P=\mathop{\mathrm{span}}\left\{\sum_{i=1}^nc_i\alpha_i,\,\sum_{i=1}^nc_i'\alpha_i\right\}.\]</span>这样我们就找到了只用 Cartan 矩阵和单根系 <span class="math inline">\(\Delta\)</span> 计算 <span class="math inline">\(P\)</span> 的方法。</p><h1 id="e_8-的例子"><span class="math inline">\(E_8\)</span> 的例子</h1><p>在这一节中，我们以 <span class="math inline">\(E_8\)</span>​为例，应用上述理论进行实际计算。</p><p>设 <span class="math inline">\(e_i=(0,\ldots,1,\ldots,0)\)</span> 是<span class="math inline">\(\mathbb{R}^8\)</span> 中第 <span class="math inline">\(i\)</span> 个分量为 1，其它分量都是 0的坐标方向。<span class="math inline">\(\bullet\)</span> 是标准Euclidean 内积，即对 <span class="math inline">\(x=\sum_{i=1}^8x_ie_i\)</span> 和 <span class="math inline">\(y=\sum_{i=1}^8y_ie_i\)</span> 有 <span class="math display">\[x\bullet y= \sum_{i=1}^8x_iy_i.\]</span> 则 <span class="math inline">\(\{e_i\}_{i=1}^8\)</span>是内积 <span class="math inline">\(\bullet\)</span> 下的标准正交基。</p><p><span class="math inline">\(E_8\)</span> 的 Coxeter 图如下：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter-element/e8-dynkin.svg" width="400"></p><p>图中编号为 <span class="math inline">\(i\)</span> 的顶点对应单根<span class="math inline">\(\alpha_i\)</span>，<span class="math inline">\(\alpha_i\)</span> 在 <span class="math inline">\(\{e_i\}_{i=1}^8\)</span>这组基下的系数由下面矩阵的第 <span class="math inline">\(i\)</span>行给出： <span class="math display">\[\begin{bmatrix}1&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\0&amp;1&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;-1&amp;0&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;1&amp;-1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;0&amp;1&amp;-1&amp;0&amp;0\\0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;1&amp;0\\-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}\\0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;-1&amp;0\end{bmatrix}.\]</span>所有 8 个单根 <span class="math inline">\(\{\alpha_i\}_{i=1}^8\)</span>构成 <span class="math inline">\(E_8\)</span> 的单根系 <span class="math inline">\(\Delta\)</span>。</p><p>注意这里每个单根的长度是 <span class="math inline">\(\sqrt{2}\)</span>，并不是单位向量，这样主要是为了书写代码更方便。</p><p>Cartan 矩阵 <span class="math inline">\(A\)</span>由单根之间两两内积给出： <span class="math display">\[A=(\alpha_i\bullet\alpha_j)_{1\leq i,j\leq8}=-2\cos\frac{\pi}{m_{ij}}=\begin{pmatrix}2&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\-1&amp;2&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0\\0&amp;-1&amp;2&amp;-1&amp;0&amp;0&amp;0&amp;0\\0&amp;0&amp;-1&amp;2&amp;-1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;-1&amp;2&amp;-1&amp;0&amp;-1\\0&amp;0&amp;0&amp;0&amp;-1&amp;2&amp;-1&amp;0\\0&amp;0&amp;0&amp;0&amp;0&amp;-1&amp;2&amp;0\\0&amp;0&amp;0&amp;0&amp;-1&amp;0&amp;0&amp;2\end{pmatrix}.\]</span></p><p>用代码来写的话，就是</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># A set of simple roots listed by rows of 'delta'</span><br>delta = np.array([<br>    [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>    [-<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>])<br><br><span class="hljs-comment"># The cartan matrix:</span><br>cartan = np.dot(delta, delta.transpose())<br></code></pre></td></tr></tbody></table></figure><p>所有单反射 <span class="math inline">\(\{s_i\}_{i=1}^8\)</span>生成的群 <span class="math inline">\(W\)</span> 叫做 <span class="math inline">\(E_8\)</span> 的 Weyl 群，这个群包含 696729600个元素。单根系在 <span class="math inline">\(W\)</span> 作用下生成的集合<span class="math inline">\(\Phi = \{w\cdot\alpha\,|\, w\in W,\alpha\in\Delta\}\)</span> 叫做 <span class="math inline">\(E_8\)</span>的根系，<span class="math inline">\(\Phi\)</span> 中包含 240个不同的向量，<span class="math inline">\(W\)</span> 置换 <span class="math inline">\(\Phi\)</span> 中的向量。</p><p><span class="math inline">\(\Phi\)</span>中的向量从形式上看分为两类：</p><ol type="1"><li>第一类包含 <span class="math inline">\((\pm1,\pm1,0,0,0,0,0,0)\)</span>的所有置换，即有两个分量是 <span class="math inline">\(+1\)</span> 或者<span class="math inline">\(-1\)</span>，其余６个分量都是 0的向量。这样的向量有 112 个。</li><li>第二类包含所有形如 <span class="math inline">\(1/2\times(\pm1,\pm1,\cdots,\pm1)\)</span>的向量，其中 <span class="math inline">\(-1\)</span>的个数是偶数。这样的向量有 128 个。</li></ol><p>为了编程方便，我们可以把所有根都乘以2，使得它们都是整数向量。于是生成根系 <span class="math inline">\(\Phi\)</span> 的代码可以这样写：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br>roots = []<br><br><span class="hljs-comment"># Roots of the form (+-1, +-1, 0, 0, 0, 0, 0, 0),</span><br><span class="hljs-comment"># signs can be chosen independently and the two non-zeros can be anywhere.</span><br><span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> combinations(<span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>), <span class="hljs-number">2</span>):<br>    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> product([-<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], repeat=<span class="hljs-number">2</span>):<br>        v = np.zeros(<span class="hljs-number">8</span>)<br>        v[i] = x<br>        v[j] = y<br>        roots.append(v)<br><br><span class="hljs-comment"># Roots of the form 1/2 * (+-1, +-1, ..., +-1), signs can be chosen</span><br><span class="hljs-comment"># indenpendently except that there must be an even numer of -1s.</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> product([-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], repeat=<span class="hljs-number">8</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(v) % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>:<br>        roots.append(v)<br>roots = np.array(roots).astype(<span class="hljs-built_in">int</span>)<br><br><span class="hljs-comment"># Connect a root to its nearest neighbors,</span><br><span class="hljs-comment"># two roots are connected if and only if they form an angle of pi/3.</span><br>edges = []<br><span class="hljs-keyword">for</span> i, r <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(roots):<br>    <span class="hljs-keyword">for</span> j, s <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(roots[i + <span class="hljs-number">1</span> :], i + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">sum</span>((r - s) ** <span class="hljs-number">2</span>) == <span class="hljs-number">8</span>:<br>            edges.append([i, j])<br></code></pre></td></tr></tbody></table></figure><p>我们来计算 Coxeter 平面 <span class="math inline">\(P\)</span>的一组基。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">eigenvals, eigenvecs = np.linalg.eigh(cartan)<br>u = eigenvecs[:, <span class="hljs-number">0</span>]<br>v = eigenvecs[:, -<span class="hljs-number">1</span>]<br><br>u = np.dot(u, delta)<br>v = np.dot(v, delta)<br></code></pre></td></tr></tbody></table></figure><p>其中 <code>eigenvals</code> 返回 Cartan矩阵的特征值，按照从小到大排列；<code>eigenvecs</code> 的列向量是 Cartan矩阵的特征向量，也是按照特征值递增的顺序排列，第一列<code>u = eigenvecs[:, 0]</code> 和最后一列<code>v = eigenvecs[:, -1]</code>就是最小和最大特征值对应的特征向量。</p><p>把 <code>eigenvals</code> 中的特征值打印出来：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">0.01095621</span> <span class="hljs-number">0.51371035</span> <span class="hljs-number">1.18652671</span> <span class="hljs-number">1.58417662</span> <span class="hljs-number">2.41582338</span> <span class="hljs-number">2.81347329</span> <span class="hljs-number">3.48628965</span> <span class="hljs-number">3.98904379</span>]<br></code></pre></td></tr></tbody></table></figure><p>可以看到最小的特征值 <span class="math display">\[0.01095621 \approx2-2\cos\frac{\theta_0}{2},\quad \theta_0\approx2\arccos0.994521895\approx\frac{2\pi}{30}.\]</span> 所以我们验证了 <span class="math inline">\(\gamma\)</span> 在 <span class="math inline">\(P\)</span> 上的作用是一个 30 阶的旋转，即 <span class="math inline">\(W\)</span> 的 Coxeter 数是 30。</p><p>根据上一节末尾的介绍，<span class="math inline">\(\sum_{i=1}^8u_i\alpha_i\)</span> 和 <span class="math inline">\(\sum_{i=1}^8v_i\alpha_i\)</span> 构成 <span class="math inline">\(P\)</span> 的一组基。作为对称矩阵 <span class="math inline">\(A\)</span> 的不同特征值对应的特征向量，它们在内积<span class="math inline">\(\bullet\)</span>下一定是正交的。把它们归一化为单位向量，然后计算根系 <code>roots</code>到 <span class="math inline">\(P\)</span> 的投影：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">u /= np.linalg.norm(u)<br>v /= np.linalg.norm(v)<br><br>roots_2d = [(np.dot(u, x), np.dot(v, x)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> roots]<br></code></pre></td></tr></tbody></table></figure><p>剩下的就是具体的绘图过程了，这里不再赘述。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-CasselmanCoxeterElement" class="csl-entry" role="listitem">Casselman, Bill. 2017. <span>“Coxeter Elements in Finite CoxeterGroups”</span> Essays on Coxeter groups. <a href="https://personal.math.ubc.ca/~cass/research/pdf/Element.pdf">https://personal.math.ubc.ca/~cass/research/pdf/Element.pdf</a>.</div><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div></div>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Birkhoff 遍历定理</title>
      <link href="Birkhoff-ergodic-theorem/"/>
      <url>Birkhoff-ergodic-theorem/</url>
      
        <content type="html"><![CDATA[<p>我念研究生时的高等概率论课用的是 Durrett 的教材 “Probability: TheoryandExamples”。这本书的好处我就不再介绍了，院长陈大岳老师在世图影印版的前言中已经夸了一遍。我个人的体会是，Durrett的书在讲解证明的时候非常简练，很少写为什么要这样证，我有时候读了半天也没搞明白思路。Birkhoff遍历定理算是其中一个，于是我重新整理了一下书中的证明，作此文留念。</p><p>Birkhoff 遍历定理最初由 Birkhoff 本人在 1931 年发表，原文长达 50页。随后在 1939 年 K.Yosida （吉田耕作） 和 S.Kakutani （角谷）利用极大遍历定理给出了一个 10页的简洁证明，不过他们关于极大遍历定理的证明还是啰嗦了点，后来 Garsia给出了极大遍历定理的一个仅有寥寥数行的惊人证明，这也是当前大多数教材采用的途径，本文就来介绍这一证明。</p><span id="more"></span><h1 id="准备工作">准备工作</h1><p>给定一个概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span>，我们称两个可测集<span class="math inline">\(A,B\in F\)</span>几乎处处相等，是指它们的示性函数 <span class="math inline">\(\mathbb{1}_A,\mathbb{1}_B\)</span>几乎处处相等，记作 <span class="math inline">\(A\stackrel{\mathrm{a.e.}}{=}B\)</span>。等价的说法是<span class="math inline">\(A,B\)</span> 只差一个零测集，或者差集 <span class="math inline">\(A\Delta B\)</span> 是零测集。</p><p>设 <span class="math inline">\(T:\Omega\rightarrow \Omega\)</span>是一个可测变换，即对任何 <span class="math inline">\(E\in\mathcal{F}\)</span> 有 <span class="math inline">\(T^{-1}E\in\mathcal{F}\)</span>。</p><div id="def-1" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>如果可测集 <span class="math inline">\(E\)</span> 满足 <span class="math inline">\(T^{-1}E\stackrel{\mathrm{a.e.}}{=}E\)</span>，就称<span class="math inline">\(E\)</span> 是一个 <span class="math inline">\(T-\)</span> 不变集合。不难验证所有的 <span class="math inline">\(T-\)</span> 不变集合 <span class="math display">\[\mathcal{I}=\{E\in\mathcal{F}\ |\T^{-1}E\stackrel{\mathrm{a.e.}}{=}E\}\]</span> 构成 <span class="math inline">\(\mathcal{F}\)</span> 的一个子 <span class="math inline">\(\sigma-\)</span> 代数。</p></div><div id="def-2" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.2</span>.</span><span class="statement-spah"> </span>如果对任何可测集<span class="math inline">\(E\in\mathcal{F}\)</span> 有 <span class="math inline">\(\mu(T^{-1}E)=\mu(E)\)</span>，就称 <span class="math inline">\(T\)</span> 是一个保测变换。</p></div><p>在本文中，<span class="math inline">\(T\)</span>始终代表一个保测变换。</p><p>保测变换有如下性质：</p><div id="lemma-1" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(f\in L^1(\Omega)\)</span>是一个可积的随机变量，<span class="math inline">\(T\)</span>是保测变换，则 <span class="math display">\[\int_\Omegaf\,\mathrm{d}\mu=\int_\Omega f\circ T\,\mathrm{d}\mu.\]</span></p></div><p><strong>证明</strong>：若 <span class="math inline">\(E\in\mathcal{F}\)</span> 是可测集，由于 <span class="math display">\[\omega\in T^{-1}E\Leftrightarrow T(\omega)\inE\Leftrightarrow(\mathbb{1}_E\circ T) (\omega)=1.\]</span> 所以 <span class="math inline">\(\mathbb{1}_{E}\circT=\mathbb{1}_{\{T^{-1}E\}}\)</span>，因此 <span class="math display">\[\int_\Omega\mathbb{1}_E\,\mathrm{d}\mu=\mu(E)=\mu(T^{-1}E)=\int_\Omega\mathbb{1}_{\{T^{-1}E\}}\,\mathrm{d}\mu=\int_\Omega \mathbb{1}_E\circT\,\mathrm{d}\mu.\]</span>从而结论对集合的示性函数成立，进一步由积分的线性性质对任何简单函数也成立，再取极限即得对一般的可积函数结论成立。</p><div id="lemma-2" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.4</span>.</span><span class="statement-spah"> </span>一个 <span class="math inline">\(\Omega\)</span> 上的随机变量 <span class="math inline">\(X\)</span> 关于 <span class="math inline">\(\mathcal{I}\)</span> 可测，当且仅当有 <span class="math display">\[X\circ T=X\quad \text{a.e.}\]</span>成立。这时我们称 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(T-\)</span> 不变的随机变量。</p></div><p>这是 Durrett书中的一道习题，我一直觉得它很平凡，其实之前文章中的处理有问题，这个结论还是需要论证一番的。</p><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>：如果 <span class="math inline">\(X\)</span> 关于 <span class="math inline">\(\mathcal{I}\)</span> 可测，则对任何 Borel 集 <span class="math inline">\(B\in\mathcal{B}(\mathbb{R}^1)\)</span> 有 <span class="math inline">\(X^{-1}B\in\mathcal{I}\)</span>，即 <span class="math inline">\(T^{-1}(X^{-1}B)\stackrel{\mathrm{a.e.}}{=}X^{-1}B\)</span>，这说明<span class="math inline">\(\{X\circ T\inB\}\stackrel{\mathrm{a.e.}}{=}\{X\in B\}\)</span>。特别地取 <span class="math inline">\(B=(-\infty, t)\)</span> 我们得到 <span class="math inline">\(\{X\circT&lt;t\}\stackrel{\mathrm{a.e.}}{=}\{X&lt;t\}\)</span>。我们来证明如果<span class="math inline">\(\xi,\,\eta\)</span>是两个可测函数且对任何实数 <span class="math inline">\(t\)</span> 有<span class="math inline">\(\{\xi&lt;t\}\stackrel{\mathrm{a.e.}}{=}\{\eta&lt;t\}\)</span>，则<span class="math inline">\(\xi=\eta,\,\mathrm{a.e.}\)</span>。然后对<span class="math inline">\(\xi=X\circ T,\,\eta=T\)</span>应用此结论即可。若不然，不妨设 <span class="math inline">\(\{\xi&gt;\eta\}\)</span> 具有正测度，则存在有理数<span class="math inline">\(c\)</span> 使得集合 <span class="math inline">\(\{\xi&gt;c&gt;\eta\}\)</span>具有正测度，这个集合在 <span class="math inline">\(\{\eta&lt;c\}\)</span> 中，但是不在 <span class="math inline">\(\{\xi&lt;c\}\)</span> 中，这与 <span class="math inline">\(\{\eta&lt;c\}\)</span> 和 <span class="math inline">\(\{\xi&lt;c\}\)</span> 只差一个零测集矛盾。</p><p><span class="math inline">\(\Leftarrow\)</span>：如果 <span class="math inline">\(X\circ T=X\)</span> 几乎处处成立，则对任何 <span class="math inline">\(B\in\mathcal{B}(\mathbb{R}^1)\)</span> 有 <span class="math inline">\(X^{-1}B\stackrel{\mathrm{a.e.}}{=}T^{-1}X^{-1}B\)</span>，这说明<span class="math inline">\(X^{-1}B\in\mathcal{I}\)</span>，即 <span class="math inline">\(X\)</span> 关于 <span class="math inline">\(\mathcal{I}\)</span> 可测。</p><h1 id="birkhoff-遍历定理">Birkhoff 遍历定理</h1><p>设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\Omega\)</span> 上的随机变量，对每个整数 <span class="math inline">\(n\geq 1\)</span>，令 <span class="math display">\[S_n(\omega)= \sum_{k=0}^{n-1}f(T^k(\omega)).\]</span> 我们有如下的定理：</p><div id="birkhoff" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span>（Birkhoff遍历定理）</p><p>设 <span class="math inline">\(T\)</span> 是概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span>上的保测变换，则对任何 <span class="math inline">\(f\inL^1(\Omega)\)</span> 有 <span class="math display">\[\lim_{n\to\infty}\frac{S_n}{n}\rightarrow\mathbb{E}[f\,|\,\mathcal{I}]\quad\text{a.e.}\]</span></p></div><p>证明 Birkhoff遍历定理定理的关键是证明如下的极大遍历定理：（极大遍历定理这个名字来源于分析中的Hardy-Littlewood 极大函数，这一类的不等式统称为极大不等式）</p><div id="max-ergodic" class="statement sta_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">极大遍历定理</span>.</span><span class="statement-spah"> </span>定义极大算子 <span class="math display">\[M_f(\omega)=\sup_{n\geq1}\frac{1}{n}S_n(\omega),\]</span> 则对 <span class="math inline">\(f\inL^1(\Omega)\)</span> 和任一 <span class="math inline">\(a\in\mathbb{R}\)</span>，有 <span class="math display">\[\int_{\{M_f&gt;a\}} f\,\mathrm{d}\mu\geqa\mu(\{M_f&gt;a\}).\]</span></p></div><p>极大遍历定理是整个 Birkhoff遍历定理的证明中最不直观的部分，而且我也确实不知道怎么解释引入它的动机。我第一次看到这个式子的时候是很懵的。一个直观的理解是，观察下面这个显然成立的不等式：<span class="math display">\[\int_{\{M_f&gt;a\}} M_f\,\mathrm{d}\mu\geqa\mu(\{M_f&gt;a\}).\]</span> 极大遍历定理是说把其中的积分函数换成 <span class="math inline">\(f\)</span>，积分范围保持不变的话，不等式仍然成立。</p><p>我把极大遍历定理的证明放在最后，先用它来证明 Birkhoff 遍历定理。</p><h1 id="birkhoff-遍历定理的证明">Birkhoff 遍历定理的证明</h1><p>首先可以假定条件期望 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]=0\)</span>，否则我们可以用<span class="math inline">\(f-\mathbb{E}[f\,|\,\mathcal{I}]\)</span>代替 <span class="math inline">\(f\)</span>，注意到 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]\)</span> 是 <span class="math inline">\(T-\)</span> 不变的，所以根据上面的 <a href="#lemma-2" title="引理 1.4">引理 1.4</a> 有 <span class="math display">\[\mathbb{E}[f\,|\,\mathcal{I}]\circ T^k =\mathbb{E}[f\,|\,\mathcal{I}],\quad \mathrm{a.e.}\]</span>对所有的正整数 <span class="math inline">\(k\)</span> 都成立，这时 <a href="#birkhoff" title="定理 2.1">定理 2.1</a> 的左边 <span class="math inline">\(S_n\)</span> 中每一项都会多出来一个 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]\)</span>，除以 <span class="math inline">\(n\)</span> 正好和右边的 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]\)</span>抵消掉。</p><p>这样问题变成在 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]=0\)</span>的前提下证明 <span class="math display">\[\lim\limits_{n\to\infty}\frac{S_n}{n}=0.\quad\text{a.e.}\]</span> 设 <span class="math inline">\(a\)</span>是任一正数，考虑集合 <span class="math display">\[A= \left\{\omega \mid\varlimsup_{n\to\infty}\frac{S_n}{n}&gt;a\right\}.\]</span> 我们想证明<span class="math inline">\(\mu(A)=0\)</span>。若真如此，则有 <span class="math inline">\(\varlimsup\limits_{n\to\infty}S_n/n\leq a\)</span>几乎处处成立，根据 <span class="math inline">\(a\)</span> 的任意性就得到<span class="math inline">\(\varlimsup\limits_{n\to\infty}S_n/n\leq0\)</span> 几乎处处成立。再把这个结果用在 <span class="math inline">\(-f\)</span> 上就得到 <span class="math inline">\(\varliminf\limits_{n\to\infty}S_n/n\geq 0\)</span>也几乎处处成立，这样就证明了 <span class="math inline">\(\lim\limits_{n\to\infty}S_n/n=0\)</span>几乎处处成立。（拗口）</p><p>为了证明 <span class="math inline">\(\mu(A)=0\)</span>，我们希望对函数 <span class="math inline">\(f\)</span> 和集合 <span class="math inline">\(A\)</span> 应用极大不等式： <span class="math display">\[\int_A f\,\mathrm{d}\mu\geq a\mu(A).\]</span>这是因为，<span class="math inline">\(A\)</span> 其实是一个 <span class="math inline">\(T-\)</span> 不变的集合，即 <span class="math inline">\(A\in\mathcal{I}\)</span>，我们会在证明末尾再验证这一点。于是根据条件期望的性质，<span class="math display">\[\int_A f\,\mathrm{d}\mu = \int_A\mathbb{E}[f\,|\,\mathcal{I}]\,\mathrm{d}\mu =0.\]</span> 即 <span class="math inline">\(0\geq a\mu(A)\)</span>，结合 <span class="math inline">\(a&gt;0\)</span> 即得 <span class="math inline">\(\mu(A)=0\)</span>。</p><p>但是，我们能对 <span class="math inline">\(A\)</span>使用极大不等式吗？请注意 <span class="math inline">\(\varlimsup\limits_{n\to\infty}\)</span> 和 <span class="math inline">\(\sup\limits_{n\geq 1}\)</span>的区别，它们定义的是两个不同的随机变量。<span class="math inline">\(A\)</span> 是用 <span class="math inline">\(\varlimsup\limits_{n\to\infty}\)</span>定义的，而极大遍历定理中说的是 <span class="math inline">\(\sup\limits_{n\geq 1}\)</span>。注意到 <span class="math display">\[A=\left\{\varlimsup_{n\to\infty}\frac{S_n}{n}&gt;a\right\}\subseteq\left\{\sup_{n\geq 1}\frac{S_n}{n}&gt;a\right\}=\left\{M_f&gt;a\right\},\]</span>所以我们只需要证明下面的结论就好了：</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\subseteq \{M_f&gt;a\}\)</span> 而且 <span class="math inline">\(A\)</span> 是一个 <span class="math inline">\(T-\)</span> 不变集合，那么极大遍历定理仍然成立：<span class="math display">\[\int_A f\,\mathrm{d}\mu\geqa\mu(A).\]</span></p></div><p><strong>引理的证明</strong>：对函数 <span class="math inline">\(g=f\cdot\mathbb{1}_A\)</span> 应用极大遍历定理：<span class="math display">\[\int_{\{M_g&gt;a\}}f\cdot\mathbb{1}_A\,\mathrm{d}\mu\geq a\mu(\{M_g&gt;a\}).\]</span> 但是<span class="math inline">\(M_g=M_f\cdot\mathbb{1}_A\)</span>，这一点要用到<span class="math inline">\(A\)</span> 是 <span class="math inline">\(T-\)</span> 不变集合这个条件，因此 <span class="math display">\[\{M_g&gt;a\}=\{M_f&gt;a\}\cap A=A.\]</span>因此确实有 <span class="math display">\[\int_Af\,\mathrm{d}\mu\geq a \mu(A).\]</span> 这样就证明了 Birkhoff遍历定理。</p><p>实际上定理中的收敛也是一个依 <span class="math inline">\(L^1\)</span>范数的收敛，这点的证明相比几乎处处收敛就容易多了，这里不再赘述。</p><p>最后我们来补上证明中遗漏的部分，即验证集合 <span class="math inline">\(A=\left\{\varlimsup\limits_{n\to\infty}S_n/n&gt;a\right\}\)</span>确实是 <span class="math inline">\(T-\)</span> 不变的：</p><p>利用 <span class="math inline">\(S_{n+1} = f + S_n\circ T\)</span>可得 <span class="math display">\[\frac{S_{n+1}}{n+1} = \frac{f}{n+1} +\frac{S_n\circ T}{n}\cdot \frac{n}{n+1}.\]</span>对两边同时取上极限，注意由于 <span class="math inline">\(f\inL^1(\Omega)\)</span> 所以 <span class="math inline">\(f\)</span>几乎处处有限，从而 <span class="math inline">\(\lim\limits_{n\to\infty}f/(n+1)=0,\,\text{a.e.}\)</span>。所以<span class="math display">\[\varlimsup_{n\to\infty} \frac{S_{n+1}}{n+1}= \varlimsup_{n\to\infty}\frac{S_{n}\circ T}{n}.\]</span> 这正说的是<span class="math inline">\(\varlimsup\limits_{n\to\infty}S_n/n\)</span>是 <span class="math inline">\(T-\)</span> 不变的随机变量，从而 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(T-\)</span> 不变的集合。</p><p>最后来证明极大遍历定理。</p><h1 id="极大遍历定理的证明">极大遍历定理的证明</h1><p>只要证明 <span class="math inline">\(a=0\)</span>的情形，然后对一般的 <span class="math inline">\(a\)</span>，将结论应用在函数 <span class="math inline">\(f-a\)</span> 上即可。定义 <span class="math inline">\(S_0=0\)</span> 以及 <span class="math inline">\(M_n =\max\{S_0,S_1,\cdots,S_n\}\)</span>。对每个<span class="math inline">\(k=1,\ldots,n\)</span> 有 <span class="math display">\[S_k=f+S_{k-1}\circ T\leq f+M_n \circ T.\]</span>从而 <span class="math display">\[\max_{1\leq k\leq n}S_k\leq f+M_n\circ T.\]</span></p><p>但是在集合 <span class="math inline">\(\{M_n&gt;0\}\)</span>上，<span class="math inline">\(M_n\)</span> 作为 <span class="math inline">\(S_0,S_1,\ldots,S_n\)</span> 中的最大者肯定不能来自<span class="math inline">\(S_0=0\)</span>，所以 <span class="math inline">\(M_n=\max\limits_{1\leq k\leq n}S_k\)</span>，因此<span class="math display">\[M_n\leq f+M_n \circ T,\quad \omega\in\{M_n&gt;0\}.\]</span> 注意 <span class="math inline">\(M_n\)</span>总是非负的随机变量，从而 <span class="math display">\[\begin{align*}\int_{\{M_n&gt;0\}} f &amp;\geq\int_{\{M_n&gt;0\}}M_n -\int_{\{M_n&gt;0\}}M_n\circ T\\ &amp; =\int_\Omega M_n- \int_{\{M_n&gt;0\}}M_n\circ T\\&amp;\geq \int_\OmegaM_n-\int_\Omega M_n\circ T\\&amp;=0.\end{align*}\]</span> 最后由于 <span class="math inline">\(\{M_n&gt;0\}\uparrow\{M_f&gt;0\}\)</span>，所以由控制收敛定理即可得到 <span class="math display">\[\int_{\{M_f&gt;0\}}f\geq 0.\]</span>极大遍历定理得证。</p>]]></content>
      
      
      <categories>
          
          <category> Durrett 概率论批判 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实表示和复表示</title>
      <link href="real-and-complex-representations/"/>
      <url>real-and-complex-representations/</url>
      
        <content type="html"><![CDATA[<p>在数学中有许多「三分天下」的例子，比如：</p><ol type="1"><li>常曲率空间只有 Euclidean、球面、双曲三种。</li><li>三类典型的偏微分方程：热方程 （抛物）、Laplace 方程 （椭圆）、波方程（双曲）。</li><li>复平面上全纯等价下只有三种单连通区域：单位圆 <span class="math inline">\(\mathbb{D}\)</span>、复平面 <span class="math inline">\(\mathbb{C}\)</span>、扩充复平面 <span class="math inline">\(\overline{\mathbb{C}}\)</span>。</li><li>不可约代数簇 （素理想） 在扩张下的三种行为：分解、惯性、分歧。</li><li>随机游动可以分为零常返、正常返、暂态。</li><li>实数域 <span class="math inline">\(\mathbb{R}\)</span>上的有限维结合可除代数只有三种：<span class="math inline">\(\mathbb{R}\)</span>、复数域 <span class="math inline">\(\mathbb{C}\)</span>、四元数 <span class="math inline">\(\mathbb{H}\)</span>。</li></ol><p>本文要介绍的是另外两个三分天下的例子，它们来自群表示论，即有限群的不可约实表示在复数域上的分解，和不可约复表示在实数域上的实现。这两个例子是紧密相关的。</p><span id="more"></span><h1 id="不可约实表示在复数域上的分解">不可约实表示在复数域上的分解</h1><p>在有限群的表示论中，第一个遇到的重要结论大概非 Schur 引理莫属：</p><div id="schur-------" class="statement sta_schur___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Schur引理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(G\)</span> 是一个有限群，<span class="math inline">\(k\)</span> 是一个特征为 0 的域，<span class="math inline">\(V\)</span> 是一个不可约左 <span class="math inline">\(kG\)</span>- 模。则 <span class="math inline">\(D=\mathrm{Hom}_{kG}(V,V)\)</span> 是 <span class="math inline">\(k\)</span> 上的有限维结合可除代数。</p></div><p>我记得还是本科生的时候，在自学到这个结论时就曾经想过这个问题： 如果<span class="math inline">\(k=\mathbb{R}\)</span> 是实数域的话，那么<span class="math inline">\(D\)</span> 作为 <span class="math inline">\(\mathbb{R}\)</span>上的有限维结合可除代数只有三种：实数域 <span class="math inline">\(\mathbb{R}\)</span>，复数域 <span class="math inline">\(\mathbb{C}\)</span>，四元数体 <span class="math inline">\(\mathbb{H}\)</span>。这三种可能性分别对应 <span class="math inline">\(\mathbb{R}G\)</span>- 模 <span class="math inline">\(V\)</span> 的什么性质呢？</p><p>答案是，<span class="math inline">\(D\)</span> 决定了 <span class="math inline">\(V\)</span>作为复表示时分解为不可约表示的方式。等等，把 <span class="math inline">\(V\)</span> 看作复表示是什么意思来着？</p><p>有两种途径可以解释怎样把 <span class="math inline">\(V\)</span>看作复表示，第一种方式使用纯矩阵的语言，第二种则使用张量积的语言。它们本质是一回事。</p><p>使用矩阵的语言最为直观。让我们回忆，<span class="math inline">\(V\)</span> 是 <span class="math inline">\(G\)</span> 的实表示意味着有群同态 <span class="math display">\[G\overset{\rho}{\longrightarrow} {\rmGL}(n,\mathbb{R}),\quad n=\dim V.\]</span> 但实矩阵也是复矩阵，所以<span class="math inline">\(\rho\)</span> 也是 <span class="math inline">\(G\to {\rm GL}(n,\mathbb{C})\)</span> 的同态。所以<span class="math inline">\(\rho\)</span> 自然也是 <span class="math inline">\(G\)</span> 的复表示。</p><p>使用张量积的语言就很不直观了，但是我更偏好这种方式，因为这可以让我们在更高的抽象层次上进行计算。为了把<span class="math inline">\(V\)</span> 看作 <span class="math inline">\(\mathbb{C}G\)</span>- 模，我们需要把 <span class="math inline">\(V\)</span> 中数和向量的乘法扩展到 <span class="math inline">\(\mathbb{C}\)</span> 上。所以我们考虑 <span class="math inline">\(V\)</span> 的 <a href="https://en.wikipedia.org/wiki/Complexification">复化</a> <span class="math inline">\(V_\mathbb{C}=\mathbb{C}\otimes_\mathbb{R}V\)</span>。<span class="math inline">\(V_\mathbb{C}\)</span> 中复数与向量的乘法由 <span class="math display">\[z(c\otimes v)=zc\otimes v,\quadz,c\in\mathbb{C},v\in V.\]</span> 给出。<span class="math inline">\(V\)</span> 可以等同于 <span class="math inline">\(V_\mathbb{C}\)</span> 的实子空间 <span class="math inline">\(1\otimes V\)</span>。在这个等同下，<span class="math inline">\(V\)</span> 的一组 <span class="math inline">\(\mathbb{R}\)</span>- 基也是 <span class="math inline">\(V_\mathbb{C}\)</span> 的一组 <span class="math inline">\(\mathbb{C}\)</span>- 基。任何 <span class="math inline">\(T\in\mathrm{End}_\mathbb{R}(V)\)</span> 通过 <span class="math inline">\(T\to 1_\mathbb{C}\otimes T\)</span> 变成 <span class="math inline">\(V_\mathbb{C}\)</span> 上的 <span class="math inline">\(\mathbb{C}\)</span>- 线性变换。<span class="math inline">\(T\)</span> 和 <span class="math inline">\(1_\mathbb{C}\otimes T\)</span>在同一组基下具有相同的矩阵。</p><p>特别地，<span class="math inline">\(G\)</span> 在 <span class="math inline">\(V_\mathbb{C}\)</span> 上的作用定义为 <span class="math inline">\(1_\mathbb{C}\otimes g\)</span> 在 <span class="math inline">\(V_\mathbb{C}\)</span> 上的作用： <span class="math display">\[g(c\otimes v) = c\otimes gv.\]</span> 这个作用是<span class="math inline">\(\mathbb{C}\)</span>- 线性的，在此作用下<span class="math inline">\(V_\mathbb{C}\)</span> 成为一个 <span class="math inline">\(\mathbb{C}G\)</span>- 模。</p><p>怎么计算 <span class="math inline">\(V_\mathbb{C}\)</span>的分解呢？这就要用到群表示论中关于半单代数结构的一个基本结论：</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(W\)</span> 是一个 <span class="math inline">\(\mathbb{C}G\)</span>- 模，<span class="math inline">\(W = n_1W_1\oplus n_2W_2\oplus\cdots\oplusn_rW_r\)</span>，其中 <span class="math inline">\(W_i\)</span>是互不同构的 <span class="math inline">\(\mathbb{C}G\)</span>- 模，<span class="math inline">\(n_i\)</span> 是 <span class="math inline">\(W_i\)</span> 出现在 <span class="math inline">\(W\)</span> 中的重数，则有 <span class="math inline">\(\mathbb{C}\)</span>- 代数同构 <span class="math display">\[\mathrm{End}_{\mathbb{C}G}(W) \cong\mathrm{Mat}_{n_1}(\mathbb{C})\times\mathrm{Mat}_{n_2}(\mathbb{C})\times\cdots\times\mathrm{Mat}_{n_r}(\mathbb{C}).\]</span></p></div><p>用 <span class="math inline">\(V_\mathbb{C}\)</span> 代替 <span class="math inline">\(W\)</span>，上面的结论告诉我们可以通过将 <span class="math inline">\(\mathrm{End}_{\mathbb{C}G}(V_\mathbb{C})\)</span>表示为矩阵代数的直积来获得 <span class="math inline">\(V_\mathbb{C}\)</span> 的分解。根据自然同构 <span class="math display">\[\mathrm{End}_{\mathbb{C}G}(V_\mathbb{C})\cong\mathbb{C}\otimes_{\mathbb{R}}\mathrm{End}_{\mathbb{R}G}(V)=\mathbb{C}\otimes_\mathbb{R}D.\]</span>问题最终归结为将 <span class="math inline">\(\mathbb{C}\otimes_{\mathbb{R}}D\)</span>表示为矩阵代数的直积。</p><p>我们来论证 <span class="math inline">\(V_\mathbb{C}\)</span>的分解具有如下的「三分性质」：</p><ol type="1"><li><span class="math inline">\(D=\mathbb{R}\)</span>：由 <span class="math inline">\(\mathbb{R}\otimes_\mathbb{R}\mathbb{C}\cong\mathbb{C}\)</span>，因此<span class="math inline">\(V_\mathbb{C}\)</span> 仍然是不可约的。</li><li><span class="math inline">\(D=\mathbb{C}\)</span>：根据 <span class="math inline">\(\mathbb{C}\)</span>- 代数同构 <span class="math inline">\(\mathbb{C}\otimes_\mathbb{R}\mathbb{C}\cong\mathbb{C}\times\mathbb{C}\)</span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，因此 <span class="math inline">\(V_\mathbb{C}\)</span> 的分解为 <span class="math inline">\(V_\mathbb{C}=V_1\oplus V_2\)</span>，即 <span class="math inline">\(V_\mathbb{C}\)</span>是两个不同构的复表示的直和。注意 <span class="math inline">\(V_\mathbb{C}\)</span> 的特征与 <span class="math inline">\(V\)</span> 相同，是个实特征，所以 <span class="math inline">\(V_1\)</span> 和 <span class="math inline">\(V_2\)</span> 是共轭的，即 <span class="math inline">\(V_2=V_1^\ast\)</span>。</li><li><span class="math inline">\(D=\mathbb{H}\)</span>：根据 <span class="math inline">\(\mathbb{C}\)</span>- 代数同构 <span class="math inline">\(\mathbb{H}\otimes_\mathbb{R}\mathbb{C}\cong\mathrm{Mat}_2(\mathbb{C})\)</span><a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>，因此 <span class="math inline">\(V_\mathbb{C}\)</span> 的分解为 <span class="math inline">\(V_\mathbb{C}=2V_1\)</span>，即 <span class="math inline">\(V_\mathbb{C}\)</span>是某个不可约模的二重和。</li></ol><h1 id="不可约复表示在实数域上的实现">不可约复表示在实数域上的实现</h1><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>设 <span class="math inline">\(G\)</span>是一个有限群，<span class="math inline">\(V\)</span> 是一个不可约的<span class="math inline">\(\mathbb{C}G-\)</span> 模，其特征为 <span class="math inline">\(\chi\)</span>。我们想知道这个表示是否能在实数域上实现？即是否存在一个<span class="math inline">\(\mathbb{R}G\)</span>- 模 <span class="math inline">\(W\)</span>，使得 <span class="math inline">\(W\)</span> 的特征也是 <span class="math inline">\(\chi\)</span>？</p></div><p>显然 <span class="math inline">\(V\)</span>可以在实数域上可以实现的一个必要条件是 <span class="math inline">\(\chi\)</span> 是实特征，即对任何 <span class="math inline">\(g\in G\)</span>，<span class="math inline">\(\chi(g)\)</span>都是实数，但这个条件是否也是充分的呢？</p><p>答案是否定的。</p><div id="------" class="statement sta___ definition unnumbered"><p><span class="statement-heading"><span class="statement-label">反例</span>：</span><span class="statement-spah"> </span>四元数群 <span class="math inline">\(Q_8=\{\bf \pm1, \pm i,\pm j, \pm k\}\)</span>是一个 8 阶群，它只有一个次数大于 1 的不可约复表示，其次数为2，但是它没有次数为 2的不可约实表示，所以这个复表示肯定不能在实数域上实现。</p><p>具体讲，<span class="math inline">\(Q_8\)</span>有四个不可约一维复表示，这四个复表示同时也是实表示。此外 <span class="math inline">\(Q_8\)</span> 在四元数体 <span class="math inline">\(\mathbb{H}\)</span> 上的左乘给出其一个不可约 4维实表示（除环作为自己的左正则模必然是不可约的），因此我们有群代数分解<span class="math display">\[\mathbb{R}Q_8 \cong4\mathbb{R}\oplus\mathbb{H}.\]</span> 另一方面 <span class="math inline">\(Q_8\)</span> 有一个不可约的二维复表示，这个表示由Pauli 矩阵给出： <span class="math display">\[{\bfi}\to\begin{pmatrix}0&amp;i\\i&amp;0\end{pmatrix},\quad {\bfj}\to\begin{pmatrix}0&amp;-1\\1&amp;0\end{pmatrix},\quad {\bfk}\to\begin{pmatrix}i&amp;0\\0&amp;-i\end{pmatrix}.\]</span>这三个矩阵和恒等矩阵一起构成 <span class="math inline">\(\mathrm{Mat}_2(\mathbb{C})\)</span>的一组基，因此有群代数分解 <span class="math display">\[\mathbb{C}Q_8\cong4\mathbb{C}\oplus\mathrm{Mat}_2(\mathbb{C}).\]</span>由于 <span class="math inline">\(Q_8\)</span>没有二维不可约实表示，因此这个二维不可约复表示不能在实数域上实现。</p></div><p>那要使得一个不可约复表示可以在实数域上实现，它应该满足怎样的条件？假定你对实向量空间的复化有足够的了解<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>，那就可以直接看到本质：这等价于存在一个与<span class="math inline">\(G\)</span> 交换的 <a href="https://en.wikipedia.org/wiki/Complex_conjugate">复共轭</a> <span class="math inline">\(J\colon\ V\to V\)</span>。即 <span class="math inline">\(J\)</span> 是 <a href="https://en.wikipedia.org/wiki/Antilinear_map">共轭线性</a>的，满足 <span class="math inline">\(J^2=1\)</span> 并且对任何 <span class="math inline">\(g\in G\)</span> 有 <span class="math inline">\(gJ=Jg\)</span>。我们会看到，存在三种互斥的情形：</p><ol type="1"><li>不存在与 <span class="math inline">\(G\)</span> 交换的共轭线性变换<span class="math inline">\(J\)</span></li><li>或者如果存在的话，这样的 <span class="math inline">\(J\)</span>在只差一个常数的意义下是唯一确定的，在适当缩放以后有两种可能：<span class="math inline">\(J^2=\pm1\)</span>。</li></ol><p>1 和 2 互斥是显然的，但是 2中的两种情形为什么互斥就不那么显然了。注意不要以为 <span class="math inline">\(J^2= 1\)</span> 的话会有 <span class="math inline">\((iJ)^2=-1\)</span>。实际上由于 <span class="math inline">\(iJ=\overline{i}J\)</span>，所以 <span class="math inline">\((iJ)^2=iJiJ=J^2\)</span>。</p><p>记 <span class="math inline">\(V^\ast\)</span> 为 <span class="math inline">\(V\)</span> 的对偶表示。<span class="math inline">\(V^\ast\)</span> 的特征是 <span class="math inline">\(\overline{\chi}\)</span>。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.1</span>.</span></p><ol type="1"><li>如果 <span class="math inline">\(V\ncong V^\ast\)</span>，就称 <span class="math inline">\(V\)</span> 是复的 (complex type)；</li><li>如果 <span class="math inline">\(V\cong V^\ast\)</span> 且 <span class="math inline">\(V\)</span> 是某个不可约 <span class="math inline">\(\mathbb{R}G\)</span>- 模 <span class="math inline">\(W\)</span> 的复化：<span class="math inline">\(V\congW\otimes_{\mathbb{R}}\mathbb{C}\)</span>，就称 <span class="math inline">\(V\)</span> 是实的 (real type)；</li><li>如果 <span class="math inline">\(V\cong V^\ast\)</span> 且 <span class="math inline">\(V\)</span> 是某个不可约 <span class="math inline">\(\mathbb{H}G\)</span>- 模在复数域上的限制，就称<span class="math inline">\(V\)</span> 是四元数的 (quaterniontype)。</li></ol></div><p>我们将论证 <span class="math inline">\(V\)</span>具有如下的「三分性质」：</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(V\)</span>必然恰好属于复、实、四元数三种类型之一，即这三种类型是互斥的。</p></div><p>复类型显然与后面两种类型是互斥的。所以我们只需要讨论 <span class="math inline">\(V\cong V^\ast\)</span> 时会发生什么。</p><p>根据 Schur 引理，<span class="math inline">\(\mathrm{Hom}_G(V,V^\ast)\cong\mathbb{C}\)</span>是一维的。但是我们有 <span class="math inline">\(G\)</span>- 模同构<span class="math display">\[\mathrm{Hom}_G(V,V^\ast)\cong\mathrm{Bil}(V) \cong V^\ast\otimes V^\ast.\]</span></p><p>所以 <span class="math inline">\(V^\ast\otimes V^\ast\)</span> 作为<span class="math inline">\(\mathbb{C}G\)</span>- 模也是一维的。但是<span class="math inline">\(V^\ast\otimes V^\ast\)</span>总是可以分解为两个 <span class="math inline">\(G\)</span>-不变子空间的直和，即对称和反对称的双线性形式：</p><p><span class="math display">\[V^\ast\otimesV^\ast=S^2V^\ast\oplus\Lambda^2V^\ast.\]</span> 其中 <span class="math inline">\(S^2V^\ast\)</span> 是二阶对称张量组成的空间，<span class="math inline">\(\Lambda^2V^\ast\)</span>是二阶反对称张量组成的空间。</p><p>于是 <span class="math inline">\(V\)</span> 上的任何 <span class="math inline">\(G\)</span>- 不变双线性型 <span class="math inline">\(B\)</span> 要么是对称的： <span class="math display">\[B(v,w)=B(w,v).\]</span> 要么是反对称的： <span class="math display">\[B(v,w)=-B(w,v).\]</span> 二者必居其一。</p><p>取 <span class="math inline">\(\langle\,,\,\rangle\)</span> 为 <span class="math inline">\(V\)</span> 上的任一 <span class="math inline">\(G\)</span>- 不变的正定 Hermite 内积。其中 <span class="math inline">\(\langle\,,\,\rangle\)</span>关于第一个分量是共轭线性的，关于第二个分量是线性的。从而在一组标准正交基<span class="math inline">\(\{e_i\}_{i=1}^n\)</span>下 <span class="math inline">\(\langle\,,\,\rangle\)</span> 形如 <span class="math display">\[\langle\sum_{i=1}^n x_ie_i,\,\sum_{i=1}^ny_ie_i\rangle=\sum_{i=1}^n\overline{x}_i y_i.\]</span></p><p>由于 <span class="math inline">\(\langle\,,\,\rangle\)</span>是正定的当然非退化，从而对任何 <span class="math inline">\(V\)</span>上的 <span class="math inline">\(\mathbb{C}\)</span>- 线性泛函 <span class="math inline">\(f\)</span>，都存在唯一的 <span class="math inline">\(z\in V\)</span> 使得 <span class="math inline">\(f=\langle z,\,\cdot\rangle\)</span>。特别地，固定<span class="math inline">\(v\in V\)</span>，对线性泛函 <span class="math inline">\(\phi_v\colon\ w\mapsto B(v,w)\)</span>，存在唯一的<span class="math inline">\(z\in V\)</span> 使得 <span class="math display">\[\langle z,\, w\rangle = \phi_v(w) =B(v,w).\]</span> 这里 <span class="math inline">\(z\)</span> 依赖于<span class="math inline">\(v\)</span>。我们记这个从 <span class="math inline">\(v\)</span> 到 <span class="math inline">\(z\)</span> 的映射为 <span class="math inline">\(J\colon\ v\mapsto z\)</span>。从而 <span class="math display">\[B(v, w) = \langle Jv, w\rangle.\]</span> 由于<span class="math inline">\(B\)</span> 和 <span class="math inline">\(\langle\,,\,\rangle\)</span> 都是 <span class="math inline">\(G\)</span>- 不变的，因此 <span class="math inline">\(J\)</span> 必然与 <span class="math inline">\(G\)</span> 的作用交换 <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>。</p><p>注意到 <span class="math inline">\(B\)</span>关于第一个分量是线性的，但是 <span class="math inline">\(\langle\,,\,\rangle\)</span>关于第一个分量是共轭线性的，所以 <span class="math inline">\(J\)</span>必然也是共轭线性的，即对任何 <span class="math inline">\(c\in\mathbb{C}\)</span> 有 <span class="math display">\[J(cv) = \overline{c}z.\]</span></p><p>由于共轭线性变换的平方是 <span class="math inline">\(\mathbb{C}\)</span>- 线性的，所以 <span class="math inline">\(J^2\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span>- 线性的且与 <span class="math inline">\(G\)</span> 的作用交换。由 Schur 引理存在 <span class="math inline">\(c\in\mathbb{C}\)</span> 使得 <span class="math inline">\(J^2=cI\)</span>，<span class="math inline">\(c\ne0\)</span>。我们来说明必有 <span class="math inline">\(c&gt;0\)</span> 或者 <span class="math inline">\(c&lt;0\)</span>。这两种情形分别取决于 <span class="math inline">\(B\)</span> 是对称的或者反对称的。</p><ol type="1"><li><p>如果 <span class="math inline">\(B\)</span> 是对称的，则 <span class="math display">\[\langle Jv, w\rangle= \langle Jw,v\rangle.\]</span> 取 <span class="math inline">\(v=Jw\)</span>带入上式得到 <span class="math display">\[\langle J^2w, w\rangle=\langleJw, Jw\rangle\geq0.\]</span> 由于 <span class="math inline">\(J^2=cI\)</span>，所以必然有 <span class="math inline">\(c&gt;0\)</span>。</p></li><li><p>类似地当 <span class="math inline">\(B\)</span> 反对称时可得<span class="math inline">\(c&lt;0\)</span>。</p></li></ol><p>于是通过给 <span class="math inline">\(J\)</span> 除以 <span class="math inline">\(\sqrt{|c|}\)</span>，我们就得到了一个新的共轭线性变换，把它仍然记作<span class="math inline">\(J\)</span>，则 <span class="math inline">\(J\)</span> 满足 <span class="math inline">\(J^2=\pm1\)</span>。我们来说明这两种情形分别对应<span class="math inline">\(V\)</span> 是实类型或者四元数类型。</p><ol type="1"><li>如果 <span class="math inline">\(J^2=1\)</span>，由于 <span class="math inline">\(J\)</span> 是共轭线性的，<span class="math inline">\(J\)</span> 实际上给出了 <span class="math inline">\(V\)</span> 上的一个共轭结构。记 <span class="math inline">\(W=\{w\in V\mid J(w)=w\}\)</span> 是 <span class="math inline">\(J\)</span> 的不动点，则 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(W\)</span> 的复化：<span class="math inline">\(V\cong\mathbb{C}\otimes_{\mathbb{R}}W\)</span>。由于 <span class="math inline">\(G\)</span> 的作用与 <span class="math inline">\(J\)</span> 交换，所以 <span class="math inline">\(G\)</span> 在 <span class="math inline">\(V\)</span> 上的作用 <span class="math inline">\(\rho(g)\)</span> 都形如 <span class="math inline">\(\rho(g)=1\otimes\rho_W(g)\)</span>，其中 <span class="math inline">\(\rho_W(g)\)</span> 是 <span class="math inline">\(W\)</span> 上的 <span class="math inline">\(\mathbb{R}\)</span>- 线性变换。即表示 <span class="math inline">\(\rho\)</span> 是表示 <span class="math inline">\(\rho_W\)</span> 的复化。所以 <span class="math inline">\(V\)</span> 是实的。</li><li>如果 <span class="math inline">\(J^2=-1\)</span>，那么 <span class="math inline">\(1,\, I=i,\,J,\, K=IJ\)</span>满足通常的四元数乘法，它们都和 <span class="math inline">\(G\)</span>的作用交换，所以 <span class="math inline">\(V\)</span> 可以变成一个左<span class="math inline">\(\mathbb{H}G\)</span>-模，将此模限制在复数域上即为表示 <span class="math inline">\(V\)</span>，从而表示 <span class="math inline">\(V\)</span> 是四元数的。</li></ol><p>实类型和四元数类型是互斥的，否则 <span class="math inline">\(V\)</span>上将同时存在一个对称双线性型和一个反对称双线性型，与 <span class="math inline">\(\dim_\mathbb{C}(V^\ast\otimes V^\ast)=1\)</span>矛盾。</p><p>总之我们证明了表示 <span class="math inline">\(V\)</span>必然恰好属于实、复、四元数三种类型之一，其中只有实类型可以在实数域上实现。而且由上面的分析不难得出下面的推论：</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.3</span>.</span></p><ol type="1"><li><span class="math inline">\(V\)</span> 是复的当且仅当 <span class="math inline">\(V\)</span> 上不存在任何非零的 <span class="math inline">\(G\)</span>- 不变双线性型。</li><li><span class="math inline">\(V\)</span> 是实的当且仅当 <span class="math inline">\(V\)</span> 上存在一个非零的 <span class="math inline">\(G\)</span>- 不变对称双线性型。</li><li><span class="math inline">\(V\)</span> 是四元数的当且仅当 <span class="math inline">\(V\)</span> 上存在一个非零的 <span class="math inline">\(G\)</span>- 不变反对称双线性型。</li></ol></div><p>这三种情形分别对应 <span class="math inline">\(\dim_{\mathbb{C}}(S^2V^\ast)-\dim_{\mathbb{C}}(\Lambda^2V^\ast)\)</span>的值是 0, +1 和 -1。通过一些简单的计算不难得到 <span class="math display">\[\dim_{\mathbb{C}}(S^2V^\ast)-\dim_{\mathbb{C}}(\Lambda^2V^\ast)=\frac{1}{|G|}\sum_{g\inG}\chi(g^2).\]</span></p><p><span class="math inline">\(F(\chi)=\dfrac{1}{|G|}\sum\limits_{g\inG}\chi(g^2)\)</span> 叫做 <span class="math inline">\(\chi\)</span> 的Frobenius-Schur 指标，于是我们有</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.4</span>.</span><span class="statement-spah"> </span>（Frobenius-Schur指标）</p><ol type="1"><li><span class="math inline">\(V\)</span> 是复的当且仅当 <span class="math inline">\(F(\chi)=0\)</span>。</li><li><span class="math inline">\(V\)</span> 是实的当且仅当 <span class="math inline">\(F(\chi)=1\)</span>。</li><li><span class="math inline">\(V\)</span> 是四元数的当且仅当 <span class="math inline">\(F(\chi)=-1\)</span>。</li></ol></div><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>一个同构由 <span class="math inline">\(z_1\otimes z_2\to(z_1z_2, z_1\overline{z}_2)\)</span> 给出。首先此映射是一个 <span class="math inline">\(\mathbb{C}\)</span>- 代数同态。此同态是满射，因为<span class="math inline">\(\frac{1}{2}(1\otimes1+ i\otimes i)\)</span>被映射为 <span class="math inline">\((1,0)\)</span>，<span class="math inline">\(\frac{1}{2}(1\otimes1 - i\otimes i)\)</span>被映射为 <span class="math inline">\((0, 1)\)</span>。此外由于两边作为<span class="math inline">\(\mathbb{C}\)</span>- 代数的维数相同，都是2，所以是一个同构。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>有个一般性的结论：设 <span class="math inline">\(D\)</span> 是域 <span class="math inline">\(F\)</span> 上的有限维可除代数且 <span class="math inline">\(D\)</span> 的中心为 <span class="math inline">\(F\)</span>，<span class="math inline">\(K\)</span>是 <span class="math inline">\(D\)</span> 的极大子域，<span class="math inline">\(n=[D:K]\)</span>。则有 <span class="math inline">\(K\)</span>- 代数同构 <span class="math inline">\(K\otimes_FD\cong\mathrm{Mat}_n(K)\)</span>。将此结论应用于 <span class="math inline">\(D=\mathbb{H}\)</span>，<span class="math inline">\(F=\mathbb{R}\)</span>，<span class="math inline">\(K=\mathbb{C}\)</span> 即可。</p><p>不过针对四元数 <span class="math inline">\(\mathbb{H}\)</span>我们可以给一个直接的证明：把 <span class="math inline">\(\mathbb{H}\)</span> 看作 <span class="math inline">\(\mathbb{C}\)</span>上的<strong>二维右向量空间</strong>（即 <span class="math inline">\(\mathbb{C}\)</span> 的数乘写在右边），则 <span class="math inline">\(\mathbb{H}=1\mathbb{C}\oplusj\mathbb{C}\)</span>。任何 <span class="math inline">\(a\in\mathbb{H}\)</span> 在自身上的左乘给出了一个<span class="math inline">\(\mathbb{C}\)</span>- 线性变换：<span class="math display">\[a(xc) = (ax)c\quada,x\in\mathbb{H},\,c\in\mathbb{C}.\]</span> 这是因为 <span class="math inline">\(\mathbb{H}\)</span> 是结合的，所以 <span class="math inline">\(a\)</span> 在 <span class="math inline">\(\mathbb{H}\)</span> 上的左乘与 <span class="math inline">\(\mathbb{C}\)</span> 在 <span class="math inline">\(\mathbb{H}\)</span> 上的右乘交换。于是这给出了一个<span class="math inline">\(\mathbb{H}\to\mathrm{Mat}_2(\mathbb{C})\)</span>的嵌入。</p><p>设 <span class="math inline">\(a=z+jw\in\mathbb{H}\)</span>，我们来计算 <span class="math inline">\(a\)</span> 的左乘在 <span class="math inline">\(\{1,j\}\)</span> 这组基下的矩阵： <span class="math display">\[\begin{aligned}(z+jw)\cdot 1 &amp;= z+jw,\\(z+jw)\cdot j&amp;= zj+jwj=-\overline{w}+j\overline{z}.\end{aligned}\]</span> 所以 <span class="math inline">\(z+jw\)</span> 在 <span class="math inline">\(\mathrm{Mat}_2(\mathbb{C})\)</span> 中对应的矩阵为<span class="math inline">\(\begin{pmatrix}z&amp;-\overline{w} \\ w&amp; \overline{z}\end{pmatrix}\)</span>。由于 <span class="math inline">\(\mathbb{H}\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span> 上的二维右向量空间，所以它嵌入<span class="math inline">\(\mathrm{Mat}_2(\mathbb{C})\)</span>以后的像也是二维的，并不构成整个 <span class="math inline">\(\mathrm{Mat}_2(\mathbb{C})\)</span>。</p><p>但是对 <span class="math inline">\(D=\mathbb{H}\otimes_\mathbb{R}\mathbb{C}\)</span>，事情就不一样了：<span class="math inline">\(D\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span> 上的 4维右向量空间，并且它也作用在二维的右 <span class="math inline">\(\mathbb{C}\)</span>- 向量空间 <span class="math inline">\(\mathbb{H}\)</span> 上：对任何 <span class="math inline">\(a,x\in\mathbb{H}\)</span> 和 <span class="math inline">\(c\in\mathbb{C}\)</span> 我们定义 <span class="math inline">\(a\otimes c\)</span> 在 <span class="math inline">\(\mathbb{H}\)</span> 上的作用为 <span class="math display">\[(a\otimes c)x=axc,\quada,x\in\mathbb{H},c\in\mathbb{C}.\]</span> 这个作用是右 <span class="math inline">\(\mathbb{C}\)</span>- 线性的，从而给出了 <span class="math inline">\(D\)</span> 到 <span class="math inline">\(\mathrm{Mat}_2(\mathbb{C})\)</span>的同态。你可以用 <span class="math inline">\(D\)</span>是单代数来说明这是一个单射，然后再比较维数来说明它是同构，但这需要一些关于中心单代数的知识；也可以换一种方法来验证：<span class="math inline">\(D\)</span> 在 <span class="math inline">\(\mathbb{H}\)</span> 上的作用，相比前面 <span class="math inline">\(\mathbb{H}\)</span> 在自身上的左乘，还额外包含了<span class="math inline">\(i\)</span> 的右乘。这个右乘在 <span class="math inline">\(\{1,j\}\)</span> 这组基下的矩阵是对角矩阵 <span class="math inline">\(\begin{pmatrix}i&amp;\\ &amp;i\end{pmatrix}\)</span>。所以 <span class="math inline">\(D\)</span> 在<span class="math inline">\(\mathbb{H}\)</span>上的作用包含了所有如下形式的矩阵： <span class="math display">\[\begin{pmatrix}z&amp;-\overline{w} \\ w &amp;\overline{z}\end{pmatrix}\quad\text{and}\quad\begin{pmatrix}z&amp;-\overline{w}\\ w &amp; \overline{z}\end{pmatrix}\cdot\begin{pmatrix}i&amp;\\ &amp;i\end{pmatrix}.\]</span> 不难验证这两种矩阵的线性组合生成了整个 <span class="math inline">\(\mathrm{Mat}_2(\mathbb{C})\)</span>，从而这是一个<span class="math inline">\(D\to\mathrm{Mat}_2(\mathbb{C})\)</span>的满同态，再比较维数即可。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p>如果你对复化不够熟悉的话，可以参考我的一篇 <a href="/real-complex">旧文</a>。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>对任何 <span class="math inline">\(g\inG\)</span>，我们有 <span class="math display">\[\langle Jv,w\rangle=B(v,w)=B(gv,gw)=  \langle Jgv, gw\rangle =  \langle g^{-1}Jgv,w\rangle.\]</span> 即 <span class="math inline">\(g^{-1}Jg =J\)</span>，从而 <span class="math inline">\(J\)</span> 与 <span class="math inline">\(G\)</span> 的作用交换。<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 有限群表示与结合代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>相亲问题与倒向归纳法</title>
      <link href="optimal-stopping-and-backward-induction/"/>
      <url>optimal-stopping-and-backward-induction/</url>
      
        <content type="html"><![CDATA[<div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>假设你是一位大龄男士，准备参加 100 场相亲（别介意具体数字）。你打算依次与每个女士 <span class="math inline">\(i\)</span> 约会，然后根据印象给她打一个分数 <span class="math inline">\(X_i\)</span>，<span class="math inline">\(X_i\)</span> 的值介于 <span class="math inline">\([0,1]\)</span> 之间。如果你对女士 <span class="math inline">\(i\)</span>很满意，那么就和她结婚，否则就放弃她，参加下一场相亲，当然拒绝了人家可就没有回头的机会了。如果你拒绝了前99 位女士，那么不论第 100次相亲结果如何你都只能和最后这位女士结婚。在相亲之前，你对这些女士的情况一无所知，所以姑且假定她们的分数<span class="math inline">\(X_i\)</span> 都是 <span class="math inline">\([0,1]\)</span>上均匀分布的独立的随机变量。问题是：应该采取怎样的相亲策略，才能娶到你最中意的女士？</p></div><span id="more"></span><p>再费点笔墨解释下。每次相亲结束以后，你可以选择和当前的女士结婚，或者继续见下一位女士，这依赖于你已经相亲的结果：如果你挑挑拣拣到了90号女士还拿不定主意，最后发现「糟了，我快要变剩男了！」，那很可能接下来你就会放低择偶标准，遇到一个还凑合的就结婚了，即使她比你前面拒绝过的很多女士都有不如。当然也不排除你对第一位女士就一见钟情的可能，因此你最终选择的女士的编号<span class="math inline">\(\tau\)</span>是一个随机变量，你要做的就是让你的未来太太的期望分数 <span class="math inline">\(\mathbb{E}X_\tau\)</span> 尽可能的高。</p><p>那么应该采取怎样的策略为好呢？就像买东西讨价还价时总有一个心理价位一样，似乎可以先设定一个心理的期望值，如果遇到的女士的分数大于等于这个值，那就和她结婚；否则就继续下一位女士。这个思路很合理，但是问题是，期望值应该设定为多少呢？</p><p>在概率论里面我们学过如下关于顺序统计量的经典结论：设 <span class="math inline">\(X_1,\cdots,X_N\)</span> 是 <span class="math inline">\([0,1]\)</span> 上独立同分布的均匀随机变量，则<span class="math inline">\(Y=\max_{1\leq i\leq N}X_i\)</span> 的期望是<span class="math inline">\(\frac{N}{N+1}\)</span>。所以如果你把 100次相亲全部进行完，得分最高的女士的期望值理论上应该是 <span class="math inline">\(\frac{100}{101}\)</span>，于是你应该把心理门槛设置在<span class="math inline">\(\frac{100}{101}\)</span>，是这样吗？</p><p>答案是NO！首先门槛值应该是一个随着相亲的进行而逐渐降低的数列，这才符合实际的情形：如果前面太挑剔，为了不当剩男你后面的标准就会放低。其次我们会用倒向归纳法计算出最优策略下初始的门槛值并不是最中意的女士的期望值<span class="math inline">\(\frac{100}{101}\)</span>，实际上它更接近于得分第二高的女士的期望值<span class="math inline">\(\frac{99}{101}\)</span>。正如梅艳芳在《似是故人来》中唱的那样：「但凡未得到，但凡是过去，总是最登对」— 得不到的才是最好的。</p><h1 id="倒向归纳法">倒向归纳法</h1><p>相亲问题是应用倒向归纳法的一个典型例子。</p><p>我们从最后的情形开始分析，假设只剩一位女士可选，那么你只能去和她结婚，而她的期望值是1/2，我们记作 <span class="math inline">\(a_1=1/2\)</span>。</p><p>假设还剩两位女士可选呢？这种情况下应该先和其中一个相亲，如果她的分数大于等于1/2，那就应该和她结婚 （后者的期望只有 1/2，很可能不如她），而小于 1/2的话则去和第二位女士相亲 （后者的期望是1/2，所以我没道理现在娶一个分数小于 1/2 的）。而第一位女士分数大于等于1/2 的概率是 1/2，在大于等于 1/2 的条件下她的分数服从 <span class="math inline">\([1/2,1]\)</span> 上的均匀分布，期望值是3/4；第二位女士的期望分数就是 1/2。所以你以 1/2 的概率娶到一个期望值为3/4 的女士，以 1/2 的概率娶到一个期望值为 1/2的女士。因此有两位女士可选时这个策略的期望分数为 <span class="math display">\[a_2=\frac{1}{2}\cdot\frac{3}{4}+\frac{1}{2}\cdot\frac{1}{2}=\frac{5}{8}.\]</span></p><p>一般地，假设还剩下 <span class="math inline">\(i\)</span>位女士的时候你的心理期望值是 <span class="math inline">\(a_i\)</span>，我们来导出 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{i+1}\)</span>之间的递推关系：首先和其中一位女士相亲，如果她的分数大于等于 <span class="math inline">\(a_i\)</span> 那么就和她结婚，否则就拒绝她（因为后面 <span class="math inline">\(i\)</span> 个人的心理期望是 <span class="math inline">\(a_i\)</span>，我没道理现在娶一个分数小于 <span class="math inline">\(a_i\)</span> 的）。前一种情形的期望是 <span class="math inline">\(\frac{1+a_i}{2}\)</span> 但是发生的概率是 <span class="math inline">\(1-a_i\)</span>，后一种情形的期望是 <span class="math inline">\(a_i\)</span> 发生的概率也是 <span class="math inline">\(a_i\)</span>，因此 <span class="math display">\[a_{i+1}=(1-a_i)\left(\frac{1+a_i}{2}\right)+a_i\cdota_i=\frac{1+a_i^2}{2}.\]</span> 结合初值 <span class="math inline">\(a_1=\frac{1}{2}\)</span>就可以算出整个序列来，因此我们的相亲策略应该是：</p><blockquote><p>假设当前还剩 <span class="math inline">\(i\)</span>位女士。就把心里期望设定在 <span class="math inline">\(a_i\)</span>，然后进行一次相亲。如果相亲结果大于等于<span class="math inline">\(a_i\)</span>，那就和这位女士结婚；否则就把心里期望降低为<span class="math inline">\(a_{i-1}\)</span>，然后继续去见下一位女士。这里序列<span class="math inline">\(\{a_i\}\)</span> 由 <span class="math inline">\(a_1=1/2\)</span>，<span class="math inline">\(a_{i+1}=\frac{1+a_i^2}{2}\)</span> 给出。</p></blockquote><p>在这个策略下，你最终娶到的女士得分期望是 <span class="math inline">\(a_{100}\)</span>。</p><p>序列 <span class="math inline">\((a_n)_{n\geq1}\)</span> 是所谓的QuadraticMap，它的通项公式是求不出来的，只能用计算机来算。不过可以用归纳法证明<span class="math inline">\(\frac{N-1}{N+1}&lt;a_{N}&lt;\frac{N-0.5}{N+1}\)</span>，即<span class="math inline">\(a_N\)</span> 的值更接近于次优女士的期望值<span class="math inline">\(\frac{N-1}{N+1}\)</span>。当 <span class="math inline">\(N=100\)</span> 时，<span class="math inline">\(a_{100}\approx0.981\)</span>，<span class="math inline">\(\frac{N-1}{N+1}\approx 0.98\)</span> 而 <span class="math inline">\(\frac{N}{N+1}=100/101\approx 0.99\)</span>，可见<span class="math inline">\(a_{100}\)</span> 与 <span class="math inline">\(\frac{N-1}{N+1}\)</span>更接近。这印证了之前说过的：和你结婚的往往不是你最中意的那个。</p><p>请注意，虽然我们已经设计出了一个不错的策略，但这个策略到底是不是最优的呢？我们还没有严格证明。而且就算这个策略是最优的，是否只有这一种最优策略呢？没准还有其它最优策略能让你更省时省心地娶到好太太呢！要严格的解释这些，就要用到鞅的理论。</p><h1 id="翻译为鞅的语言">翻译为鞅的语言</h1><p>用鞅的语言重新表述上面的问题，会给人一种画风突变的感觉，看起来非常晦涩，不像是在说人话：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>设 <span class="math inline">\(N\)</span>是一个给定的正整数，<span class="math inline">\(\{\mathcal{F}_n\}_{n=0}^N\)</span>是某概率空间上的递增的 <span class="math inline">\(\sigma\)</span>-域流，<span class="math inline">\(\{X_n\}_{n=0}^N\)</span>是一列可积的随机变量且 <span class="math inline">\(X_k\in\mathcal{F}_k\)</span>。设 <span class="math inline">\(\mathcal{M}\)</span> 是所有满足 <span class="math inline">\(0\leq\tau\leq N\)</span> 的停时 <span class="math inline">\(\tau\)</span> 组成的集合。我们想求出值函数 <span class="math display">\[V= \sup_{\tau\in\mathcal{M}}\mathbb{E}X_\tau\]</span> 以及使得这个最大值取到的停时 <span class="math inline">\(\tau\)</span>。</p></div><p>这里我把下标改成了 从 0 开始到 <span class="math inline">\(N\)</span>，以符合大多数文献的习惯。<span class="math inline">\(\mathcal{F}_n=\{X_0,\ldots,X_n\}\)</span> 是前<span class="math inline">\(n+1\)</span> 位女士得分生成的 <span class="math inline">\(\sigma\)</span>- 域，它包含了所有你第 <span class="math inline">\(n+1\)</span> 次相亲后可能知道的信息。<span class="math inline">\(\mathcal{F}_n\)</span>显然是递增的。你的一个相亲策略对应一个停时 <span class="math inline">\(\tau\)</span>，所有停时构成的集合 <span class="math inline">\(\mathcal{M}\)</span> 就是你所有可能的策略。</p><p>定义 <span class="math inline">\(\{X_n\}\)</span> 的 <strong>Snell包络</strong>为 <span class="math display">\[S_n=\begin{cases}X_N&amp;n=N,\\\max\{X_n,\,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}&amp;n=N-1,\ldots,0.\end{cases}\]</span> 这里的 <span class="math inline">\(S_n\)</span> 是从 <span class="math inline">\(N\)</span> 开始倒向递归定义的。注意 <span class="math inline">\(S_n\)</span> 关于 <span class="math inline">\(\mathcal{F}_n\)</span> 可测。</p><p><span class="math inline">\(S_n\)</span>的直观意义很好理解，它就是在时刻 <span class="math inline">\(n\)</span>对当下女士的分数和后面所有女士期望分数的比较：如果和当前的女士 <span class="math inline">\(n\)</span> 结婚，那么分数就是 <span class="math inline">\(X_n\)</span>；否则继续前进到下一个时刻 <span class="math inline">\(n+1\)</span>，未来太太的期望分数就是 <span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>，二者取最大值<span class="math inline">\(\max\{X_n,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}\)</span>即为 <span class="math inline">\(n\)</span>时刻对最佳分数的估计。注意这里 <span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>要取条件期望，因为一般情况下 <span class="math inline">\(\{X_n\}\)</span>之间不是独立的，从而对未来最佳收益的估计依赖于历史信息。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>在相亲问题中，<span class="math inline">\(\{X_n\}\)</span> 是<span class="math inline">\(\mathrm{i.i.d}\)</span> 序列，<span class="math inline">\(S_{n+1}\)</span> 与 <span class="math inline">\(\mathcal{F}_n\)</span> 独立（你可以倒着从 <span class="math inline">\(S_N\)</span> 开始验证 <span class="math inline">\(S_{n+1}\)</span> 完全由 <span class="math inline">\(X_{n+1},\ldots,X_N\)</span> 决定），从而 <span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]=\mathbb{E}S_{n+1}\)</span>，所以</p><p><span class="math display">\[S_n=\begin{cases}X_N&amp;n=N,\\\max\{X_n,\,\mathbb{E}S_{n+1}\}&amp;n=N-1,\ldots,0.\end{cases}\]</span></p><p>记事件 <span class="math inline">\(A_n=\{X_n&gt;\mathbb{E}S_{n+1}\}\)</span>，于是序列<span class="math inline">\(\{\mathbb{E}S_n\}\)</span> 满足倒向递推关系<span class="math display">\[\mathbb{E}S_n=\mathbb{E}\max\{X_n,\,\mathbb{E}S_{n+1}\}=\mathbb{E}[X_n\mathrm{1}_{A_n}]+ \mathbb{E}S_{n+1}\cdot(1-\mathbb{P}(A_n)).\]</span>这正是我们前一节中看到的递推关系。</p></div><p>设 <span class="math inline">\(\tau=\inf\,\{n:\,S_n=X_n\}\)</span>，则 <span class="math inline">\(\tau\)</span>是停时。由于 <span class="math inline">\(S_N=X_N\)</span>，因此 <span class="math inline">\(0\leq\tau\leq N\)</span>。<span class="math inline">\(\tau\)</span> 就是我们采取的相亲策略：在 <span class="math inline">\(\tau\)</span> 时刻，由于这时 <span class="math inline">\(\max\{X_n,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}=X_n\)</span>，即<span class="math inline">\(n\)</span> 号女士的分数 <span class="math inline">\(X_n\)</span>大于等于后面继续相亲所能获得的最佳收益 <span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>，剩下的相亲就不必再进行了。</p><p>到目前为止，我们已经把相亲问题完整地翻译成了鞅的语言。我们来证明<span class="math inline">\(\tau\)</span>确实是最优策略。为此我们需要做一些准备：</p><div id="super" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\{S_n\}\)</span> 是控制 <span class="math inline">\(\{X_n\}\)</span> 的最小上鞅。</p></div><p><strong>证明</strong>：由 <span class="math inline">\(S_n=\max\{X_n,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}\)</span>直接可见 <span class="math inline">\(S_n\geq X_n\)</span> 并且 <span class="math inline">\(\{S_n\}\)</span> 是上鞅。设 <span class="math inline">\(\{Y_n\}\)</span> 是任意满足 <span class="math inline">\(Y_n\geq X_n\)</span> 的上鞅序列，我们要证明必有<span class="math inline">\(Y_n\geq S_n\)</span>。这只要从最后一项 <span class="math inline">\(n=N\)</span> 开始逐项验证即可。由定义 <span class="math inline">\(Y_N\geq X_N=S_N\)</span>，这一项没问题。假设 <span class="math inline">\(Y_n\geq S_n\)</span>，两边对 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 取条件期望可得 <span class="math display">\[Y_{n-1}\geq \mathbb{E}[Y_n|\mathcal{F}_{n-1}]\geq \mathbb{E}[S_n|\mathcal{F}_{n-1}].\]</span>其中第一个不等号是根据上鞅的定义，第二个不等号是根据条件期望的单调性。再结合<span class="math inline">\(Y_{n-1}\geq X_{n-1}\)</span> 可得 <span class="math inline">\(Y_{n-1}\geq\max\{X_{n-1},\mathbb{E}[S_n|\mathcal{F}_{n-1}]\}=S_{n-1}\)</span>，所以<span class="math inline">\(n-1\)</span>项也没有问题。这样倒着向前递推即得结论成立。<span class="math inline">\(\blacksquare\)</span></p><div id="martingale" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\{S_{n\wedge\tau}\}\)</span> 是一个鞅。</p></div><p><strong>证明</strong>：<span class="math display">\[S_{(n+1)\wedge\tau}-S_{n\wedge\tau}=1_{\{\tau&gt;n\}}(S_{n+1}-S_n).\]</span></p><p>对上式右边求条件期望： <span class="math display">\[\mathbb{E}[1_{\{\tau&gt;n\}}(S_{n+1}-S_n)|\mathcal{F}_n]=1_{\{\tau&gt;n\}}\mathbb{E}[(S_{n+1}-S_n)|\mathcal{F}_n]=0.\]</span></p><p>这是因为如果 <span class="math inline">\(\tau&gt;n\)</span>的话那么由 <span class="math inline">\(\tau\)</span> 的定义 <span class="math inline">\(S_n=\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="expectation-tau" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathbb{E}X_\tau=\mathbb{E}S_0\)</span>。</p></div><p><strong>证明</strong>：注意 <span class="math inline">\(X_\tau=S_\tau\)</span>，利用 <span class="math inline">\(0\leq\tau\leq N\)</span> 和鞅性质即可： <span class="math display">\[\mathbb{E}X_\tau=\mathbb{E}S_\tau=\mathbb{E}S_{\tau\wedgeN}=\mathbb{E}S_{\tau\wedge0}=\mathbb{E}S_0.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div id="optimal" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{M}\)</span> 是所有满足 <span class="math inline">\(0\leq T\leq N\)</span> 的停时 <span class="math inline">\(T\)</span> 组成的集合，则 <span class="math inline">\(\tau\)</span> 是其中最优的： <span class="math display">\[\mathbb{E}S_0=\mathbb{E}X_\tau=\sup_{T\in\mathcal{M}}\mathbb{E}X_T.\]</span></p></div><p><strong>证明</strong>：设 <span class="math inline">\(T\)</span>是任意停时，我们要证明 <span class="math inline">\(\mathbb{E}X_\tau\geq\mathbb{E}X_T\)</span>。为此只要注意到 <span class="math display">\[\mathbb{E}X_\tau =\mathbb{E}S_0\geq \mathbb{E}S_T\geq\mathbb{E}X_T.\]</span> 第一个等号是根据 <a href="#expectation-tau" title="推论 2.3">推论 2.3</a>，中间的不等号是因为 <span class="math inline">\(\{S_n\}\)</span> 是上鞅，所以对任何停时 <span class="math inline">\(T\)</span> 都有 <span class="math inline">\(\mathbb{E}S_T\leq\mathbb{E}S_0\)</span>。最后的不等号是因为 <span class="math inline">\(S_n\)</span> 控制 <span class="math inline">\(X_n\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>至此我们就从数学上严格论证了前面的相亲策略确实是最优的。</p><p>回顾上面的分析，可以发现我们实际上使用了 <span class="math inline">\(\tau\)</span> 的两个性质：<span class="math inline">\(S_\tau=X_\tau\)</span> 和 <span class="math inline">\(\{S_{n\wedge\tau}\}\)</span>是鞅。这两个性质保证了 <span class="math inline">\(\tau\)</span>是最优策略。那这是不是说明还有其它最优的策略呢？</p><div id="suff-nece" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.5</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\nu\in\mathcal{M}\)</span>是最优停时的充要条件是：</p><ol type="1"><li><span class="math inline">\(S_\nu=X_\nu\)</span>。</li><li><span class="math inline">\(\{S_{n\wedge\nu}\}\)</span> 是鞅。</li></ol></div><p><a href="#suff-nece" title="定理 2.5">定理 2.5</a>告诉我们，前面采用的相亲策略是所有最优策略中时间成本最低的：即若 <span class="math inline">\(\nu\)</span> 是任意最优停时，则 <span class="math inline">\(\tau\leq\nu\)</span> （回顾一下 <span class="math inline">\(\tau\)</span> 的定义）。</p><p>我们还可以给出最优策略中最大的一个来：</p><div id="largest" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.6</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(S_n=M_n-A_n\)</span> 是 Snell 包络 <span class="math inline">\(\{S_n\}\)</span> 的 Doob-Meyer 分解，其中 <span class="math inline">\(\{M_n\}\)</span> 是鞅，<span class="math inline">\(A_n\)</span> 是可料递增过程，由 <span class="math display">\[A_n=\sum_{k=1}^n(S_{k-1}-\mathbb{E}[S_k|\mathcal{F}_{k-1}]) \]</span> 给出。定义</p><p><span class="math display">\[\tau_\max = \begin{cases}N &amp; A_N=0,\\\min\{n\geq0 \mid A_{n+1}&gt;0\} &amp; A_N&gt;0.\end{cases}\]</span></p><p>则 <span class="math inline">\(\tau_\max\)</span>是所有最优停时中最大的。</p></div><p>这个策略在现实很有用，它是以最优方式行使美式期权的最大停时。</p><p><a href="#suff-nece" title="定理 2.5">定理 2.5</a> 和 <a href="#largest" title="定理 2.6">定理 2.6</a>的证明都不难，这里就省略了。读者可以参考 <span class="citation" data-cites="RiskNeutralValuation">(<a href="#ref-RiskNeutralValuation" role="doc-biblioref">Bingham and Kiesel 2004, sec. 3.6</a>)</span>。</p><p>我猜某些读者可能会对 <span class="math inline">\(\tau_\max\)</span>对应的相亲策略感兴趣，因为这个策略有点渣男：它会在保证娶到最优女士的前提下和尽可能多的女士相亲。不过在<span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span>的情形，你还是死了这份心吧。因为这时 <span class="math display">\[A_n=\sum_{k=1}^n(S_{k-1}-\mathbb{E}S_k)=\sum_{k=1}^n\max\{X_{k-1}-\mathbb{E}S_k,0\}.\]</span>所以使得 <span class="math inline">\(A_{n+1}&gt;0\)</span> 成立的最小<span class="math inline">\(n\)</span> 正是使得 <span class="math inline">\(X_n&gt;\mathbb{E}S_{n+1}\)</span> 成立的最小 <span class="math inline">\(n\)</span>，即使得 <span class="math inline">\(X_n=S_n\)</span> 成立的最小 <span class="math inline">\(n\)</span>。这不就是前面见好就收的策略 <span class="math inline">\(\tau\)</span> 嘛！换句话说，在 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span>的情形，只有一种最优相亲策略！</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-RiskNeutralValuation" class="csl-entry" role="listitem">Bingham, N. H., and Rüdiger Kiesel. 2004. <em>Risk-Neutral Valuation :Pricing and Hedging of Financial Derivatives / n.h. Bingham and r.Kiesel.</em> Second edition. Springer Finance. London: Springer.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三质点弹簧系统的简正模式</title>
      <link href="three-mass-spring-system/"/>
      <url>three-mass-spring-system/</url>
      
        <content type="html"><![CDATA[<p>今天的问题是群表示论在物理中的一个小应用：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>平面上有三个质量均为 <span class="math inline">\(m\)</span> 的质点 <span class="math inline">\(A,B,C\)</span>，它们位于正三角形的三个顶点。质点之间两两由弹簧相连，三个弹簧完全一样。弹簧质量忽略不计。</p><p><img src="/images/mass-spring/abc.png" class="fig" width="250"></p><p>初始时所有质点都处于静止状态，弹簧之间没有张力。假设给这三个质点分别施加一个初始速度，使这三个质点在平面内作刚体运动，不考虑任何摩擦力和空气阻力，那么这个系统的简正模式(normal mode) 是什么？</p></div><p>这里 <a href="https://en.wikipedia.org/wiki/Normal_mode">简正模式</a>的含义是所有质点按照一个共同的频率和固定的相位关系相对于各自的平衡位置作简谐振动。</p><span id="more"></span><p>比较容易发现的简正模式有：</p><ol type="1"><li><p>平移。初始时给所有质点以同样的速度，它们会继续以相同的速度移动。</p><p><img src="/images/mass-spring/trans.gif" class="fig" width="250"></p></li><li><p>旋转。初始时给所有质点以相同的切向速度，它们会继续绕中心旋转。</p><p><img src="/images/mass-spring/rot.gif" class="fig" width="250"></p></li><li><p>呼吸。初始时给每个质点相同的径向速度，系统会重复膨胀 —收缩的过程。</p><p><img src="/images/mass-spring/breath.gif" class="fig" width="250"></p></li></ol><p>但是要找出其它的简正模式，并保证没有遗漏，就不能只靠想象了。</p><p>我们把这个物理问题转换为一个线性代数问题，然后用一些群表示论的知识解决它。</p><p>这个质点弹簧系统有 6 个自由度 <span class="math inline">\(\{q_1,\ldots,q_6\}\)</span>，其中 <span class="math inline">\((q_1,q_2)\)</span>，<span class="math inline">\((q_3,q_4)\)</span>，<span class="math inline">\((q_5,q_6)\)</span> 分别是质点 <span class="math inline">\(A,B,C\)</span> 在 <span class="math inline">\(x,y\)</span>方向上相对于其平衡位置的位移，如下图所示：</p><figure><img src="/images/mass-spring/coords.svg" width="300" alt="建立坐标系，水平向右为 x 轴，竖直向上为 y 轴"><figcaption aria-hidden="true">建立坐标系，水平向右为 <span class="math inline">\(x\)</span> 轴，竖直向上为 <span class="math inline">\(y\)</span> 轴</figcaption></figure><p>设弹簧的弹性系数为 <span class="math inline">\(k\)</span>，原点在三角形中心，<span class="math inline">\(x\)</span>轴水平向右，于是三个弹簧所含的弹性势能为 （将形变投影到弹簧所在的方向）<span class="math display">\[\begin{align*}V=&amp;\frac{1}{2}k(q_3-q_1)^2+\frac{1}{2}k\left[\frac{-1}{2}(q_5-q_3) +\frac{\sqrt{3}}{2}(q_6-q_4)\right]^2+\\&amp;\frac{1}{2}k\left[\frac{1}{2}(q_1-q_5)+ \frac{\sqrt{3}}{2}(q_2-q_6)\right]^2.\end{align*}\]</span> 这是一个关于 <span class="math inline">\(\mathbf{q}=(q_1,q_2,\ldots,q_6)^T\)</span>的二次型： <span class="math display">\[V=\frac{1}{2}k\,\mathbf{q}^TU\mathbf{q}.\]</span> 其中 <span class="math display">\[U=\frac{1}{4}\begin{pmatrix}5&amp;\sqrt{3}&amp;-4&amp;0&amp;-1&amp;-\sqrt{3}\\\sqrt{3}&amp;3&amp;0&amp;0&amp;-\sqrt{3}&amp;3\\-4&amp;0&amp;5&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}\\0&amp;0&amp;-\sqrt{3}&amp;3&amp;\sqrt{3}&amp;-3\\-1&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}&amp;2&amp;0\\-\sqrt{3}&amp;-3&amp;\sqrt{3}&amp;-3&amp;0&amp;6\end{pmatrix}.\]</span></p><p>由牛顿第二定律我们有 <span class="math display">\[m\frac{\mathrm{d}^2q_i}{\mathrm{d}t^2}=-\frac{\partialV}{\partial q_i}=-k\sum_{j=1}^6U_{ij}q_j.\]</span>系统的简正模式就是所有 <span class="math inline">\(q_i\)</span>按照同一个频率 <span class="math inline">\(\omega\)</span>作简谐振动，但振幅可以不同，故而可以设 <span class="math inline">\(q_i=\overline{q}_i\mathrm{e}^{i\omegat}\)</span>，其中 <span class="math inline">\(\overline{q}_i\)</span>是振幅，与时间 <span class="math inline">\(t\)</span> 无关。代入上式得到<span class="math display">\[\frac{m\omega^2}{k}\overline{q}_i =\sum_{j=1}^6U_{ij}\overline{q}_j.\]</span> 即 <span class="math inline">\(U\overline{\mathbf{q}}=\lambda\overline{\mathbf{q}}\)</span>，<span class="math inline">\(\lambda=m\omega^2/k\)</span>，于是简正模式的振幅<span class="math inline">\(\overline{\mathbf{q}}=(\overline{q}_1,\overline{q}_2,\ldots,\overline{q}_6)\)</span>是 <span class="math inline">\(U\)</span> 的特征向量，频率可以从特征值<span class="math inline">\(\lambda\)</span> 得出，从而问题转化为求矩阵<span class="math inline">\(U\)</span> 的特征值和特征向量。由于 <span class="math inline">\(U\)</span> 是一个实对称矩阵，所以一定存在 6个线性无关的特征向量。</p><p>你当然可以直接硬算，但是手动求一个 6阶矩阵的特征值还是一件挺麻烦的事情，鉴于搞数学的人一般比较懒，我们可以换个思路想一想。</p><p>注意到这个系统具有对称性，其对称群是 <span class="math inline">\(S_3\)</span>。<span class="math inline">\(S_3\)</span> 这个群是集合 <span class="math inline">\(\{1,2,3\}\)</span>的置换群，同时也是平面上正三角形的对称群，在后者的情形通常称为二面体群<span class="math inline">\(D_3\)</span>。</p><p>回忆 <span class="math inline">\(S_3\)</span> 的一个表现为 <span class="math display">\[S_3=\{a,b\mid a^2=b^3=(ab)^2=1\}.\]</span>当作为置换群时，<span class="math inline">\(a=(12),\,b=(123)\)</span>。当作为二面体群时，<span class="math inline">\(a=\left(\begin{smallmatrix}-1&amp;0\\0&amp;1\end{smallmatrix}\right)\)</span>是关于 <span class="math inline">\(y\)</span> 轴的反射，<span class="math inline">\(b=\left(\begin{smallmatrix}\cos2\pi/3&amp;-\sin2\pi/3\\\sin2\pi/3&amp;\cos2\pi/3\end{smallmatrix}\right)\)</span>是关于原点角度为 <span class="math inline">\(2\pi/3\)</span>的旋转。</p><p>系统状态 <span class="math inline">\(\mathbf{q}\)</span> 所在的空间<span class="math inline">\(\mathbb{R}^6\)</span> 是三个 <span class="math inline">\(\mathbb{R}^2\)</span> 的直和：<span class="math inline">\(\mathbb{R}^6=\mathbb{R}^2_A\oplus\mathbb{R}^2_B\oplus\mathbb{R}^2_C\)</span>。其中<span class="math inline">\(\mathbb{R}^2_A,\mathbb{R}^2_B,\mathbb{R}^2_C\)</span>分别是 <span class="math inline">\(A,B,C\)</span> 的坐标空间。<span class="math inline">\(S_3\)</span> 在置换这三个直和项的同时，又以 <span class="math inline">\(D_3\)</span>的方式作用在每个直和项上，所以这个表示是 <span class="math inline">\(S_3\)</span> 的置换表示和在 <span class="math inline">\(\mathbb{R}^2\)</span> 上二维表示的张量积。</p><p>例如，对换 <span class="math inline">\((12)\)</span> 交换 <span class="math inline">\(A,B\)</span>，同时将它们的坐标关于 <span class="math inline">\(y\)</span> 轴作反射： <span class="math display">\[\begin{aligned}A\otimes (q_1,q_2) &amp;\xrightarrow{(12)} B\otimes(-q_1,q_2),\\B\otimes (q_3,q_4) &amp;\xrightarrow{(12)} A\otimes(-q_3,q_4).\end{aligned}\]</span></p><p>我们把这个张量积表示记作 <span class="math inline">\(\rho\)</span>，并记 <span class="math display">\[R=\begin{pmatrix}\cos\frac{2\pi}{3}&amp;-\sin\frac{2\pi}{3}\\\sin\frac{2\pi}{3}&amp;\cos\frac{\pi}{3}\end{pmatrix},\quadS=\begin{pmatrix}-1&amp;0\\0&amp;1\end{pmatrix}.\]</span></p><p>我们可以明确写出 <span class="math inline">\(a=(12)\)</span>在这个张量积表示下的矩阵：<span class="math inline">\(a\)</span>作为置换对应的矩阵是 <span class="math display">\[A=\begin{pmatrix}0&amp;1&amp;0\\1&amp;0&amp;0\\0&amp;0&amp;1\end{pmatrix}.\]</span>在二面体群 <span class="math inline">\(D_3\)</span> 中，<span class="math inline">\(a\)</span> 是关于 <span class="math inline">\(y\)</span> 轴的反射，其矩阵为 <span class="math inline">\(S\)</span>，所以 <span class="math inline">\(a\)</span> 在 <span class="math inline">\(\mathbb{R}^3\otimes\mathbb{R}^2\)</span>上的作用对应的矩阵是 Kronecker 乘积 <span class="math inline">\(A\otimesS\)</span>。</p><p>下面列出了 <span class="math inline">\(S_3\)</span> 的各个元素在<span class="math inline">\(\rho\)</span> 下对应的矩阵：</p><p><span class="math display">\[\begin{align*}\rho(e)&amp;=I_3\otimesI_2=\begin{pmatrix}I_2&amp;0&amp;0\\0&amp;I_2&amp;0\\0&amp;0&amp;I_2\end{pmatrix},\\\rho(a)&amp;=\begin{pmatrix}0&amp;1&amp;0\\1&amp;0&amp;0\\0&amp;0&amp;1\end{pmatrix}\otimesS=\begin{pmatrix}0&amp;S&amp;0\\S&amp;0&amp;0\\0&amp;0&amp;S\end{pmatrix},\\\rho(b)&amp;=\begin{pmatrix}0&amp;1&amp;0\\0&amp;0&amp;1\\1&amp;0&amp;0\end{pmatrix}\otimesR=\begin{pmatrix}0&amp;R&amp;0\\0&amp;0&amp;R\\R&amp;0&amp;0\end{pmatrix},\\\rho(b^2)&amp;=\begin{pmatrix}0&amp;0&amp;1\\1&amp;0&amp;0\\0&amp;1&amp;0\end{pmatrix}\otimesR^2=\begin{pmatrix}0&amp;0&amp;R^2\\R^2&amp;0&amp;0\\0&amp;R^2&amp;0\end{pmatrix},\\\rho(ab)&amp;=\begin{pmatrix}0&amp;0&amp;1\\0&amp;1&amp;0\\1&amp;0&amp;0\end{pmatrix}\otimesSR=\begin{pmatrix}0&amp;0&amp;SR\\0&amp;SR&amp;0\\SR&amp;0&amp;0\end{pmatrix},\\\rho(ab^2)&amp;=\begin{pmatrix}1&amp;0&amp;0\\0&amp;0&amp;1\\0&amp;1&amp;0\end{pmatrix}\otimesSR^2=\begin{pmatrix}SR^2&amp;0&amp;0\\0&amp;0&amp;SR^2\\0&amp;SR^2&amp;0\end{pmatrix}.\end{align*}\]</span></p><p><span class="math inline">\(S_3\)</span> 在表示 <span class="math inline">\(\rho(g)\)</span>下显然都是正交矩阵，而且保持系统的势能不变，所以对任何状态 <span class="math inline">\(\mathbf{q}\)</span> 有 <span class="math display">\[V(\rho(g)\mathbf{q})=V(\mathbf{q}),\]</span> 即<span class="math display">\[{\bf q^T}\rho(g)^TU\rho(g){\bfq}=U.\]</span> 由于 <span class="math inline">\(\rho(g)\)</span>正交所以 <span class="math inline">\(\rho(g)U=U\rho(g)\)</span>，从而<span class="math inline">\(U\)</span> 是表示 <span class="math inline">\(\rho\)</span> 的一个自同态。</p><p>在数学上，我们非常喜欢这种与一个表示 <span class="math inline">\(\rho\)</span>交换的矩阵，因为这种矩阵的任何特征子空间都是 <span class="math inline">\(\rho\)</span> 的不变子空间，即 <span class="math inline">\(\rho\)</span> 的子表示，从而可以帮助我们将 <span class="math inline">\(\rho\)</span>分解为一些更简单表示的直和。不过在这个问题中，我们要反过来借助 <span class="math inline">\(\rho\)</span> 的分解来分析 <span class="math inline">\(U\)</span> 的特征子空间的结构。</p><p>我们来确定表示 <span class="math inline">\(\rho\)</span>的结构。注意到 <span class="math inline">\(S_3\)</span> 在 <span class="math inline">\(\{1,2,3\}\)</span>上的置换表示，其特征只有在单位元 <span class="math inline">\(e\)</span>处不为 0（值是 3），在任何非单位元 <span class="math inline">\(g\inS_3\)</span> 处都是 0。这个表示是张量积表示 <span class="math inline">\(\rho\)</span> 的分量，所以 <span class="math inline">\(\rho\)</span> 的特征 <span class="math inline">\(\chi\)</span> 也具有此性质。显然 <span class="math inline">\(\chi(e)=6\)</span>，于是 <span class="math inline">\(\chi\)</span> 与 <span class="math inline">\(S_3\)</span>的正则表示的特征完全相同，从而同构于正则表示，从而 <span class="math inline">\(\chi\)</span>可以分解为两个一次表示和两个二次不可约表示的和： <span class="math display">\[\chi = \chi_1 + \chi_2 + \chi_3+\chi_4.\]</span>其中 <span class="math inline">\(\chi_1\)</span> 是平凡表示的特征，<span class="math inline">\(\chi_2\)</span> 是符号表示的特征（偶置换为+1，奇置换为 -1），这两个特征都是一次的。<span class="math inline">\(\chi_3=\chi_4\)</span> 是 <span class="math inline">\(S_3\)</span>作为二面体群的二维不可约表示的特征。</p><p>记 <span class="math inline">\(\chi_i\)</span> 对应的不可约模是 <span class="math inline">\(V_i\)</span>，则 <span class="math inline">\(\dimV_1=\dim V_2=1\)</span>，<span class="math inline">\(\dim V_3=\dimV_4=2\)</span> 并且 <span class="math display">\[\mathbb{R}^6=V_1\oplusV_2\oplus V_3\oplus V_4.\]</span></p><p><span class="math inline">\(\mathbb{R}^6\)</span> 是 <span class="math inline">\(U\)</span> 的特征子空间的直和，而 <span class="math inline">\(U\)</span> 的特征子空间都是 <span class="math inline">\(\rho\)</span> 的不变子空间，从而可以分解为 <span class="math inline">\(\rho\)</span> 的不可约模的直和。这说明每个 <span class="math inline">\(V_i\)</span> 都包含在 <span class="math inline">\(U\)</span> 的某个特征值 <span class="math inline">\(\lambda_i\)</span> 的特征子空间中。即 <span class="math inline">\(U\)</span> 在 <span class="math inline">\(V_i\)</span> 上的作用是数乘 <span class="math inline">\(\lambda_i\)</span>。</p><p>从 <span class="math inline">\(V_1,\ldots,V_4\)</span>中分别选择一组基，它们合起来构成 <span class="math inline">\(\mathbb{R}^6\)</span> 的一组基。在这组基下 <span class="math inline">\(U\)</span> 是对角矩阵，形如 <span class="math display">\[U=\begin{pmatrix}\lambda_1&amp;0&amp;0&amp;0\\0&amp;\lambda_2&amp;0&amp;0\\0&amp;0&amp;\lambda_3I_2&amp;0\\0&amp;0&amp;0&amp;\lambda_4I_2\end{pmatrix}.\]</span>同时 <span class="math inline">\(\rho(g)\)</span> 形如 <span class="math display">\[\rho(g)=\begin{pmatrix}D_1&amp;0&amp;0&amp;0\\0&amp;D_2&amp;0&amp;0\\0&amp;0&amp;D_3&amp;0\\0&amp;0&amp;0&amp;D_4\end{pmatrix}.\]</span></p><p>我们来计算 <span class="math inline">\(\rho(g)U\)</span> 对不同 <span class="math inline">\(g\in S_3\)</span> 的迹。首先注意到 <span class="math display">\[\mathop{\mathrm{tr}}{\rho(g)U}=\mathop{\mathrm{tr}}{\begin{pmatrix}\lambda_1D_1&amp;0&amp;0&amp;0\\0&amp;\lambda_2D_2&amp;0&amp;0\\0&amp;0&amp;\lambda_3D_3&amp;0\\0&amp;0&amp;0&amp;\lambda_4D_4\end{pmatrix}}=\sum_{i=1}^4\lambda_i\chi_i(g).\]</span></p><p>另一方面，我们对 <span class="math inline">\(S_3\)</span> 中的 <span class="math inline">\(e,a,b\)</span> 这三个元素，根据前面列出的 <span class="math inline">\(\rho(g)\)</span> 矩阵，计算其与 <span class="math inline">\(U\)</span>的乘积，再求迹得到（这是本文计算量最大的部分！） <span class="math display">\[\begin{align*}\mathop{\mathrm{tr}}{\rho(e)U}&amp;=\mathop{\mathrm{tr}}{U}=\frac{1}{4}(5+3+5+3+2+6)=6,\\\mathop{\mathrm{tr}}{\rho(a)U}&amp;=\mathop{\mathrm{tr}}{\begin{pmatrix}0&amp;S&amp;0\\S&amp;0&amp;0\\0&amp;0&amp;S\end{pmatrix}\frac{1}{4}\begin{pmatrix}5&amp;\sqrt{3}&amp;-4&amp;0&amp;-1&amp;-\sqrt{3}\\\sqrt{3}&amp;3&amp;0&amp;0&amp;-\sqrt{3}&amp;3\\-4&amp;0&amp;5&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}\\0&amp;0&amp;-\sqrt{3}&amp;3&amp;\sqrt{3}&amp;-3\\-1&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}&amp;2&amp;0\\-\sqrt{3}&amp;-3&amp;\sqrt{3}&amp;-3&amp;0&amp;6\end{pmatrix}}\\&amp;=\frac{1}{4}(4+0+4+0-2+6)=3,\\\mathop{\mathrm{tr}}{\rho(b)U}&amp;=\mathop{\mathrm{tr}}{\begin{pmatrix}0&amp;R&amp;0\\0&amp;0&amp;R\\R&amp;0&amp;0\end{pmatrix}\frac{1}{4}\begin{pmatrix}5&amp;\sqrt{3}&amp;-4&amp;0&amp;-1&amp;-\sqrt{3}\\\sqrt{3}&amp;3&amp;0&amp;0&amp;-\sqrt{3}&amp;3\\-4&amp;0&amp;5&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}\\0&amp;0&amp;-\sqrt{3}&amp;3&amp;\sqrt{3}&amp;-3\\-1&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}&amp;2&amp;0\\-\sqrt{3}&amp;-3&amp;\sqrt{3}&amp;-3&amp;0&amp;6\end{pmatrix}}\\&amp;=\frac{1}{4}(2+0-1+3+2+0)=\frac{3}{2}.\end{align*}\]</span> 于是我们得到三个方程 <span class="math display">\[\begin{align*}6&amp;=\lambda_1+\lambda_2+2(\lambda_3+\lambda_4),\\3&amp;=\lambda_1-\lambda_2,\\3/2&amp;=\lambda_1+\lambda_2-(\lambda_3+\lambda_4).\end{align*}\]</span> 于是 <span class="math inline">\(\lambda_1=3\)</span>，<span class="math inline">\(\lambda_2=0\)</span>，<span class="math inline">\(\lambda_3+\lambda_4=3/2\)</span>。</p><p>我们还缺一个方程！可以用 <span class="math inline">\(\mathop{\mathrm{tr}}{U^2}=\lambda_1^2+\lambda_2^2+2(\lambda_3^2+\lambda_4^2)\)</span>来做，但手算 <span class="math inline">\(U^2\)</span>的话计算量还是不小的。更简单的办法是用物理直观：我们已经看到平移和旋转是两种简正模式，这两种模式下质点的振动频率是0，而平移包含了 <span class="math inline">\(x\)</span> 轴和 <span class="math inline">\(y\)</span> 轴两个线性无关的方向上的平移，所以<strong>0 作为 <span class="math inline">\(U\)</span>的特征值至少是三重的</strong>。我们已经解得 <span class="math inline">\(\lambda_2=0\)</span> 是一个，所以 <span class="math inline">\(\lambda_3\)</span> 和 <span class="math inline">\(\lambda_4\)</span> 中必然还有一个是 0，不妨设<span class="math inline">\(\lambda_3=0\)</span>，则 <span class="math inline">\(\lambda_4=3/2\)</span>。</p><p>得到了 <span class="math inline">\(\lambda_1,\lambda_2,\lambda_3,\lambda_4\)</span>，对应的频率就可以用<span class="math inline">\(\omega_i=\sqrt{\lambda_ik/m}\)</span>算出来。</p><p>总结一下，系统总共有 4 种简正模式：</p><ol type="1"><li><p>平凡表示 (<span class="math inline">\(\lambda_1=3\)</span>)对应的简正模式是呼吸，其频率为 <span class="math inline">\(\omega=\sqrt{3k/m}\)</span>：</p><figure><img src="/images/mass-spring/breath.gif" width="250" alt="呼吸　\omega=\sqrt{3k/m}"><figcaption aria-hidden="true">呼吸　<span class="math inline">\(\omega=\sqrt{3k/m}\)</span></figcaption></figure></li><li><p>符号表示 (<span class="math inline">\(\lambda_2=0\)</span>)对应的简正模式是旋转，其频率 <span class="math inline">\(\omega=0\)</span>：</p><figure><img src="/images/mass-spring/rot.gif" width="250" alt="旋转　\omega=0"><figcaption aria-hidden="true">旋转　<span class="math inline">\(\omega=0\)</span></figcaption></figure></li><li><p>第一个二维不可约表示 (<span class="math inline">\(\lambda_3=0\)</span>)包含了两种简正模式，它们分别是沿着 <span class="math inline">\(x\)</span> 方向和 <span class="math inline">\(y\)</span> 方向的平移，其频率 <span class="math inline">\(\omega=0\)</span>。</p><figure><img src="/images/mass-spring/trans.gif" width="250" alt="平移　\omega=0"><figcaption aria-hidden="true">平移　<span class="math inline">\(\omega=0\)</span></figcaption></figure></li><li><p>第二个二维不可约表示 (<span class="math inline">\(\lambda_4=3/2\)</span>)也包含了两种简正模式，它们分别是两个不同方向上的“鼓掌”：</p><figure><img src="/images/mass-spring/clap.gif" width="250" alt="鼓掌　\omega=\sqrt{\frac{3k}{2m}}"><figcaption aria-hidden="true">鼓掌　<span class="math inline">\(\omega=\sqrt{\frac{3k}{2m}}\)</span></figcaption></figure><p>另一种可以由上面的旋转 <span class="math inline">\(2\pi/3\)</span>后得到。这两个简正模式的频率都是 <span class="math inline">\(\omega=\sqrt{\frac{3k}{2m}}\)</span>。</p></li></ol><p>至此我们就求出了系统的全部简正模式。</p>]]></content>
      
      
      <categories>
          
          <category> 有限群表示与结合代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模式的等待时间与反直觉概率</title>
      <link href="pattern-occurrence/"/>
      <url>pattern-occurrence/</url>
      
        <content type="html"><![CDATA[<p>著名概率学家 Feller 在他的名著 “An introduction to probability andits applications” 中提到了这样一个实验：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>重复抛掷一枚均匀的硬币，用 <code>H</code>代表正面向上，<code>T</code> 代表背面向上，一直到连续出现 6 次<code>H</code> 为止。这里连续 6 个 <code>Ｈ</code> 组成的模式记作<code>HHHHHH</code>，所需要抛掷硬币的次数叫做等待时间。等待时间是一个随机变量，最小值是6，最大值可以是无限。Feller 问：等待时间的均值是多少？</p></div><p>这个问题可以用 Markov链来解，但是非常繁琐。香港中文大学李硕彦教授在他的论文 <span class="citation" data-cites="Li1980">(<a href="#ref-Li1980" role="doc-biblioref">Li 1980</a>)</span>中用离散鞅的知识给出了一个简洁而巧妙的解法，本文就来介绍他的方法。</p><span id="more"></span><h1 id="鞅和赌博序列">鞅和赌博序列</h1><p>我们用 <code>HTHT</code>这个模式为例子，来演示如何求出它的平均等待时间。</p><p>假设有一个赌徒，怀里揣着 1 元钱来到一家赌场，他的目标是赌中<code>HTHT</code> 这个序列。</p><ul><li><p>第一天，他押上这 1 元钱，赌第一次掷硬币的结果是<code>H</code>。如果他赌错了就得空手走人，而赌对的话则可以赢得 2 元（资金翻番） 并留在赌场。</p></li><li><p>第二天，他押上全部的 2 元，赌第二次掷硬币的结果是<code>Ｔ</code>。跟以前一样，赌错了空手走人，赌对了的话则资金翻番变成 4元并留在赌场。</p></li><li><p>第三天，他押上全部的 4 元，赌第三次掷硬币的结果是<code>H</code>。赌错了空手走人，赌对了的话则资金翻番变成 8元并留在赌场。</p></li><li><p>第四天，他押上全部的 8 元，赌第四次掷硬币的结果是<code>T</code>。赌错了空手走人，赌对了资金翻番变成 16元，赌局结束。</p></li></ul><p>这个赌局很像电视节目里的闯关游戏，赌局一共有 4关，赌徒要一关一关的闯，中间任何一关输了都要空手走人。</p><p>赌局对赌徒和庄家来讲都是公平的：大家在期望的意义下都是不赔不赚。每一天，赌徒都以1/2 的概率输光赌本，也以 1/2 的概率将赌本翻番。</p><p>现在假设有一个赌博团伙，他们每天都派一个人到赌场赌博，每个赌徒的赌局与上面的描述相同，不同的赌徒的赌局互相独立。我们用<span class="math inline">\(\{X_n,n=0,1,2,\ldots\}\)</span> 表示第 <span class="math inline">\(n\)</span> 天结束以后这个团伙的「净收益」，其中<span class="math inline">\(X_0=0\)</span>。由于赌局是公平的，因此 <span class="math inline">\(\{X_n\}\)</span> 是一个鞅。</p><p>设 <span class="math inline">\(\tau\)</span> 是模式 <code>HTHT</code>的等待时间，则 <span class="math inline">\(\tau\)</span>是一个停时。不难验证 <span class="math inline">\(\{X_n\}\)</span> 和<span class="math inline">\(\tau\)</span> 满足 <a href="https://en.wikipedia.org/wiki/Optional_stopping_theorem">Doob可料停时定理</a> 的条件</p><div id="doob-------------------" class="statement sta_doob_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Doob可料停时定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{X_n, n=0,1,2,\ldots\}\)</span> 是一个鞅，<span class="math inline">\(\tau\)</span> 是停时且满足</p><ol type="1"><li><span class="math inline">\(\mathbb{E}\tau &lt;\infty\)</span>，</li><li>存在常数 <span class="math inline">\(M\)</span> 使得 <span class="math inline">\(|X_{n+1}-X_{n}|\leq M\)</span> 对任何 <span class="math inline">\(n\)</span> 都几乎处处成立。</li></ol><p>则 <span class="math inline">\(\mathbb{E}X_\tau =\mathbb{E}X_0\)</span>。</p></div><p>因此在我们的问题中 <span class="math inline">\(\mathbb{E}X_\tau =\mathbb{E}X_0 = 0\)</span>。</p><p>显然 <span class="math inline">\(X_\tau=W-\tau\)</span>，这里 <span class="math inline">\(W\)</span> 表示第 <span class="math inline">\(\tau\)</span>天结束时留在赌场内的赌徒的资金之和，<span class="math inline">\(\tau\)</span> 表示第 <span class="math inline">\(\tau\)</span> 天结束时赌博团伙总共派出了 <span class="math inline">\(\tau\)</span> 个赌徒，他们带入赌场的赌本总共是<span class="math inline">\(\tau\)</span> 元。根据上面的讨论，有 <span class="math inline">\(\mathbb{E}W=\mathbb{E}\tau\)</span>成立。这里的关键在于 <span class="math inline">\(W\)</span>不是一个随机变量，而是一个可以算出来的常数！</p><p>我们仔细分析一下当第 <span class="math inline">\(\tau\)</span>天结束的时候，哪些赌徒还在赌场内，他们各自有多少钱。由于 <span class="math inline">\(\tau\)</span>是首次有某个赌徒闯关成功的时刻，所以只有第 <span class="math inline">\(\tau-3\)</span> 到第 <span class="math inline">\(\tau\)</span> 天来赌场的这 4个赌徒还有可能留在赌场，更早的赌徒都输光走人了。其中第 <span class="math inline">\(\tau-3\)</span>天来的赌徒最幸运，赌对了全部的序列，他还有 16 元；第 <span class="math inline">\(\tau-1\)</span> 天来的赌徒也不错，他赌对了<code>HT</code>，他还有 4 元，因此赌徒们总共有 <span class="math inline">\(W=16+4=20\)</span> 元，即 <span class="math inline">\(\mathbb{E}\tau=20\)</span>。</p><p>这里第 <span class="math inline">\(\tau-1\)</span>天来的赌徒最有趣：他赌的明明是 <code>HTHT</code> 的前缀<code>HT</code>，但是由于 <code>HT</code> 恰好也是 <code>HTHT</code>的后缀，因此他也能赢到钱！</p><p>这个推理完全适用于一般的情形：设 <span class="math inline">\(P=(a_1,a_2,\cdots,a_m)\)</span> 是一个给定的由<code>T</code> 和 <code>H</code>组成的模式，我们计算它的全部既是前缀又是后缀的子序列的长度，设为 <span class="math inline">\(l_1,\cdots,l_r\)</span>，则 <span class="math inline">\(P\)</span> 的等待时间 <span class="math inline">\(\tau\)</span> 的期望为 <span class="math display">\[\mathbb{E}\tau =2^{l_1}+\cdots+2^{l_r}.\]</span></p><p>回到开头的例子：<code>HHHHHH</code>的每一个前缀都同时是它的后缀，因此它的平均等待时间为 <span class="math display">\[2^6+2^5+2^4+2^3+2^2+2^1 = 126.\]</span>所以一个模式的平均等待时间完全由它的自匹配的程度决定。</p><p>把上面的方法稍作修改，还可以用来计算 <span class="math inline">\(\tau\)</span> 的生成函数 <span class="math display">\[ \mathbb{E}[s^\tau] =\sum_{n=1}^\infty\mathbb{P}(\tau=n)s^n.\]</span> 为此只要假设第 <span class="math inline">\(n\)</span> 天来的赌徒怀里揣的钱是 <span class="math inline">\(s^n(0&lt;s&lt;1)\)</span> 即可，这里不再赘述。</p><h1 id="多个模式的等待时间与获胜概率">多个模式的等待时间与获胜概率</h1><p>假设同时有多个模式 <span class="math inline">\(A_1,\ldots,A_m\)</span>加入「赛跑」，我们想计算它们各自胜出的概率。用数学公式表示，就是设 <span class="math inline">\(A_i\)</span> 的等待时间为 <span class="math inline">\(\tau_i\)</span>，令 <span class="math display">\[\tau=\min\{\tau_1,\ldots,\tau_m\},\]</span> 则<span class="math inline">\(\tau\)</span>表示赛跑过程中冠军「撞线」的时刻，又令 <span class="math inline">\(p_i=\mathbb{P}(\tau=\tau_i)\)</span>，则 <span class="math inline">\(p_i\)</span> 表示模式 <span class="math inline">\(A_i\)</span> 「夺冠」 的概率。我们想计算出每个<span class="math inline">\(p_i\)</span> 的值来。</p><p>为此先给一个定义：</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 是两个给定的模式，且 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>都不是对方的连续子序列。我们计算所有既是 <span class="math inline">\(A\)</span> 的后缀又是 <span class="math inline">\(B\)</span> 的前缀的全部子序列，设它们的长度为<span class="math inline">\(l_1,\cdots,l_r\)</span>，定义 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 的匹配指数为 <span class="math display">\[A\ast B = 2^{l_1}+\cdots+2^{l_r}.\]</span> 如果<span class="math inline">\(A\)</span> 的任何后缀都不是 <span class="math inline">\(B\)</span> 的前缀则 <span class="math inline">\(A\ast B\)</span> 定义为 0。特别当 <span class="math inline">\(A=B\)</span> 时，<span class="math inline">\(A\astA\)</span> 就是前面计算的 <span class="math inline">\(A\)</span>的平均等待时间，这个值又叫做 <span class="math inline">\(A\)</span>的自匹配指数。</p></div><p>我们要证明这样一个引理 ：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>如果已知掷硬币的结果是以模式 <span class="math inline">\(A\)</span> 开头的，那么距离模式 <span class="math inline">\(B\)</span> 出现还需要等待的时间的期望为 <span class="math display">\[\mathbb{E}\tau_{AB} = B\ast B -A\astB.\]</span></p></div><p>引理的证明：仍然是采用赌博序列的方法，每天来的赌徒赌的是模式 <span class="math inline">\(B\)</span>，只不过这个时候我们已经知道了前 <span class="math inline">\(k\)</span> 次赌博的结果是模式 <span class="math inline">\(A\)</span>（假设序列 <span class="math inline">\(A\)</span> 的长度为 <span class="math inline">\(k\)</span>），所以不难算出前 <span class="math inline">\(k\)</span> 天赌博团伙的总资金为 <span class="math inline">\(A\ast B\)</span> 元。由于赌局始终是公平的，所以从<span class="math inline">\(k+1\)</span> 天起，直到模式 <span class="math inline">\(B\)</span> 出现的这 <span class="math inline">\(\tau_{AB}\)</span> 天里，赌徒们的净收益期望应该是0。到模式 <span class="math inline">\(B\)</span>出现时，赌徒们的资金将变成 <span class="math inline">\(B\ast B\)</span>元，所以这 <span class="math inline">\(\tau_{AB}\)</span>天中赌徒们的资金增加了 <span class="math inline">\(B\ast B-A\astB\)</span> 元，扣除他们的投入 <span class="math inline">\(\tau_{AB}\)</span>元，就是这段时间的净收益，其期望为 0： <span class="math display">\[\mathbb{E} [B\ast B-A\ast B-\tau_{AB}]=0.\]</span> 引理证毕。</p><p>接下来叙述并证明一个一般的结论：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(A_1\)</span>, <span class="math inline">\(A_2\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(A_m\)</span> 是 <span class="math inline">\(m\)</span>个事先给定的且两两互不嵌套的模式，记矩阵 <span class="math display">\[M=\begin{pmatrix} A_1\ast A_1 &amp; A_1\astA_2&amp;\cdots&amp; A_1\ast A_m\\ A_2\ast A_1&amp;A_2\astA_2&amp;\cdots&amp; A_2\ast A_m\\\cdots&amp;\cdots&amp;\cdots&amp;\cdots\\ A_m\ast A_1&amp;A_m\astA_2&amp;\cdots&amp;A_m\ast A_m\end{pmatrix},\]</span> <span class="math display">\[\pi = (p_1,p_2,\cdots,p_m)^T,\quad\mathbf{1}=(1,1,\cdots,1)^T,\]</span> 则 <span class="math inline">\(M\)</span> 是可逆矩阵，并且 <span class="math display">\[M\pi =\mathbb{E}[\tau]\mathbf{1}.\]</span></p></div><p>在证明定理之前，先说说怎样根据定理的结论来计算 <span class="math inline">\(\mathbb{E}[\tau]\)</span> 和概率分布向量 <span class="math inline">\(\pi\)</span>。首先解出 <span class="math inline">\(MY=\mathbf{1}\)</span> 的解 <span class="math inline">\(Y=(y_1,y_2,\cdots,y_m)^T\)</span>来。根据可逆矩阵解的唯一性，必然有 <span class="math inline">\(\pi=\mathbb{E}[\tau]Y\)</span>。但是 <span class="math inline">\(\pi\)</span> 是一个概率分布，它的所有分量之和为1，因此 <span class="math display">\[\mathbb{E}[\tau]=\frac{1}{y_1+y_2+\cdots+y_m}.\]</span></p><p><span class="math inline">\(M\)</span>是可逆矩阵这一点是需要证明的，本文就省略了。事实上 <span class="math inline">\(A_i\)</span> 之间两两互不嵌套这个条件就可以保证<span class="math inline">\(M\)</span> 是可逆的。</p><p>有了 <span class="math inline">\(Y\)</span> 和 <span class="math inline">\(\mathbb{E}[\tau]\)</span> 自然立刻就得到了 <span class="math inline">\(\pi\)</span>。</p><p>定理的证明：我们有 <span class="math display">\[\mathbb{E}[\tau_i] =\mathbb{E}[\tau] + \mathbb{E}[\tau_i-\tau] =\mathbb{E}[\tau]+\sum_{j=1}^m p_j\mathbb{E}[\tau_i-\tau|\tau=\tau_j].\]</span>根据引理， <span class="math display">\[\mathbb{E}[\tau_i-\tau|\tau=\tau_j] = A_i\astA_i-A_j\ast A_i,\]</span> 因此 <span class="math display">\[A_i\astA_i=\mathbb{E}[\tau]+A_i\ast A_i-\sum_{j=1}^np_j A_j\ast A_i.\]</span>这就证明了定理。</p><h1 id="penney-游戏">Penney 游戏</h1><p>Penney 游戏是两个玩家 Bob 和 Alice的博弈游戏，它以掷硬币为工具：游戏开始前，两人各自选择一个长度为 3 的由<code>H</code> 和 <code>T</code> 组成的模式，比如说 Bob 选择<code>HHH</code>，Alice 选择<code>THH</code>，然后掷硬币直到其中一人选择的模式首先出现，先出现的一方获胜。</p><p>Penney 游戏有一个独特之处：</p><blockquote><p>假设 Bob 先选择他的序列，则不论 Bob 怎样选，Alice总可以「针锋相对」地选一个合适的序列，使得自己的获胜概率更高。总而言之，Penney游戏是所谓的「后发制人，先发者制于人」。</p></blockquote><p>这个有点类似于我们都熟悉的「剪子，石头，布」游戏。在 Penney游戏中，各种策略循环相克，<a href="http://en.wikipedia.org/wiki/Penney's_game">维基百科</a>中给出了各种情形下二人的获胜概率之比。在这个例子中，Alice 的获胜概率为7/8。</p><p>Penney 游戏是非传递博弈的典型例子：策略 <span class="math inline">\(A\)</span> 优于 <span class="math inline">\(B\)</span>，<span class="math inline">\(B\)</span>优于 <span class="math inline">\(C\)</span> 并不能推出 <span class="math inline">\(A\)</span> 优于 <span class="math inline">\(C\)</span>。</p><p>在只有两个模式 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>的情形，二者各自获胜的概率有一个很简单的表达式：</p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(A,B\)</span>是两个给定的序列，它们互不为对方的连续子序列，则序列 <span class="math inline">\(B\)</span> 和序列 <span class="math inline">\(A\)</span> 的获胜概率之比为 <span class="math inline">\(p_B:p_A = (A\ast A-A\ast B):(B\ast B-B\astA)\)</span>。</p></div><h1 id="还有更不可思议的事情">还有更不可思议的事情</h1><p>我们已经介绍了怎样计算一个模式的平均等待时间，以及多个模式同时「赛跑」时各自的获胜概率。我们现在来看看<code>THTH</code> 和 <code>HTHH</code> 比赛的结果如何。</p><p>首先不难算出 <code>THTH</code> 的平均等待时间是 20，<code>HTHH</code>的平均等待时间是 18，也就是说 <code>THTH</code>跑的慢一些，<code>HTHH</code>跑的快一些，那这是不是意味着让它俩赛跑的话，<code>HTHH</code>获胜的概率更大啊？</p><p>答案是否定的，这其实是一个一面倒的竞赛：</p><blockquote><p>看起来慢一些的模式 <code>THTH</code>，其与 <code>HTHH</code>的胜算之比为 9 比 5，即平均每 14 场赛跑，<code>THTH</code> 会赢 9场，而貌似快一些的 <code>HTHH</code> 倒只赢 5 场。</p></blockquote><p>为什么会出现这种反直觉的现象呢？其实「跑得慢」和「赢得多」并不矛盾。我们随便看一个由<code>H</code> 和 <code>T</code> 组成的随机序列：</p><p>HHTHT<font color="red">H</font><font color="green">H</font>THT<font color="red">H</font><font color="green">H</font>TTTHHTH<font color="green">H</font>HHTTHHTTHTTHT<font color="red">H</font><font color="green">H</font>TH<font color="green">H</font>TH<font color="green">H</font>TH<font color="green">H</font>HHTTHTTTTTTHTTHT<font color="red">H</font>TTHHTH<font color="green">H</font>HHHHTTHT<font color="red">H</font><font color="green">H</font>THT<font color="red">H</font><font color="green">H</font>TTTTTHTTHHHHHHTH<font color="green">H</font>HTTTHTTTHTTTHHHTH<font color="green">H</font>THT<font color="red">H</font>TTTHTTHTTHT<font color="red">H</font><font color="green">H</font>TH<font color="green">H</font>TTHT<font color="red">H</font><font color="green">H</font>HTTHH…</p><p>其中分别用红色和绿色标记了模式 <code>THTH</code> 和 <code>HTHH</code>的出现的位置。注意到任何绿色 <code>H</code>后面连续的三个字符中绝对不会出现红色 <code>H</code>，而大约一半的红色的<code>H</code> 后面紧跟一个绿色的<code>H</code>。所以从一个随机序列中任选一点作为起点开始比赛，那么在红色<code>H</code> 先撞线的比赛中，第二个撞线的绿色 <code>H</code>往往会只落后一个身位，但是在绿色 <code>H</code> 先撞线的比赛中，红色的<code>H</code> 至少要落后四个身位以上。</p><p>用足球来类比，领先一个身位就好比取得一个净胜球。净胜球少和积分领先并不矛盾。<code>THTH</code>击败 <code>HTHH</code> 的方法类似「一比零主义」：虽然平均下来<code>THTH</code>耗时长一些（每场净胜球少），但积分是领先的（赢的场数多）。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Li1980" class="csl-entry" role="listitem">Li, Shuo-Yen Robert. 1980. <span>“<span class="nocase">A MartingaleApproach to the Study of Occurrence of Sequence Patterns in RepeatedExperiments</span>.”</span> <em>The Annals of Probability</em> 8 (6):1171–76. <a href="https://doi.org/10.1214/aop/1176994578">https://doi.org/10.1214/aop/1176994578</a>.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洛奇绵羊问题</title>
      <link href="mabinogion-sheep-problem/"/>
      <url>mabinogion-sheep-problem/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/midjourney/mabinogion.png" class="fig" width="350"></p><p>今天的问题源自中世纪威尔士人的故事集《Mabinogion》中的一段：</p><blockquote><p>一个男孩来到了一个美丽的山谷，有一条小河在谷中流淌。他看到河一边的草地上有一群黑绵羊，另一边的草地上有一群白绵羊。羊群被施以一种魔法：每个时刻都恰有一只绵羊发出咩咩的叫声。如果发出叫声的是白绵羊，就会有一只黑绵羊趟过小河跑过来并且变成白绵羊；如果发出叫声的是黑绵羊，则会有一只白绵羊趟过小河跑过去并且变成黑绵羊。每个时刻发出叫声的绵羊是完全随机的，整个过程没有绵羊出生或者死亡，一直持续到所有绵羊都变成同一种颜色为止。</p></blockquote><p>问题是这样的：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>如果男孩可以选择在初始时刻 <span class="math inline">\(0\)</span>，或者是每个魔法时刻 <span class="math inline">\(1,2,\ldots\)</span>结束后将任意数量的白绵羊赶出山谷，那么为了最终得到尽可能多的黑绵羊，他应该采取怎样的策略？</p></div><span id="more"></span><p>洛奇绵羊问题出自 <span class="citation" data-cites="Williams1991">(<a href="#ref-Williams1991" role="doc-biblioref">Williams1991</a>)</span>，是一个很有趣的问题。这种在随机的环境中施加一个控制的力，以最大化期望收益的问题属于随机控制的范畴。</p><p>我们首先说明不论男孩采取怎样的策略，最终羊群都会以概率 1全部变成同一种颜色。</p><p>设 <span class="math inline">\(\Omega=\{(w,b)\in\mathbb{Z}_{\geq0}\times\mathbb{Z}_{\geq0}\}\)</span>是羊群所有可能的状态组成的集合，其中 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span>分别表示白绵羊和黑绵羊的数目。男孩采取的一个策略 <span class="math inline">\(S\)</span> 就是从一个状态 <span class="math inline">\((w,b)\)</span> 移动到另一个状态 <span class="math inline">\((w',b')\)</span> 的规则：根据当前 <span class="math inline">\((w,b)\)</span> 的值，男孩决定到底是按兵不动（不做任何干预），还是赶走 <span class="math inline">\(c\)</span>只白绵羊，把状态 <span class="math inline">\((w,b)\)</span> 变成状态<span class="math inline">\((w-c,b)\)</span>，这里 <span class="math inline">\(0&lt;c\leq w\)</span>是一个正整数。如果男孩始终不做任何干预的话，那么羊群状态将始终保持在线段<span class="math display">\[\{ (x,y)\mid x\geq0, y\geq0,x+y=w+b\}\]</span> 上，这是一个互通的 Markov 链，因此以概率 1撞到吸收状态 <span class="math inline">\((0,w+b)\)</span> 或 <span class="math inline">\((w+b,0)\)</span>，即最终变成同一种颜色。如果男孩在某个时刻移走了<span class="math inline">\(c\)</span>只白绵羊，那么系统将会被强制转移到线段 <span class="math display">\[\{(x,y)\mid x\geq0, y\geq0, x+y=w+b-c\}\]</span>上，如此下去。由于男孩只能进行有限次移走绵羊的操作，可见不论男孩策略如何，羊群总是会最终变成同色的。</p><p>对任何策略 <span class="math inline">\(S\)</span>，我们用 <span class="math inline">\(V_S(w,b)\)</span> 表示从 <span class="math inline">\((w,b)\)</span> 状态出发，在策略 <span class="math inline">\(S\)</span> 下最终得到的黑绵羊数量的期望值。这里<span class="math inline">\(V_S\)</span> 是一个由 <span class="math inline">\(S\)</span> 决定的确定的函数，它不包含随机性。<span class="math inline">\(V_S\)</span> 叫做策略 <span class="math inline">\(S\)</span> 的值函数。显然 <span class="math inline">\(V_S\)</span> 总是满足边界条件 <span class="math display">\[V_S(0,b)=b,\quadV_S(w,0)=0\label{eq:boundary}\tag{$\ast$}.\]</span></p><p>假设我们能够找到这样一个策略 <span class="math inline">\(A\)</span>，它的值函数 <span class="math inline">\(V_A\)</span> 有如下性质，那么它就是最佳策略：</p><blockquote><p><strong>最优策略的充分条件</strong>：如果策略 <span class="math inline">\(A\)</span> 的值函数 <span class="math inline">\(V_A\)</span> 满足如下条件：对任何初始状态 <span class="math inline">\((w,b)\)</span> 和任何的策略 <span class="math inline">\(S\)</span>，设羊群在策略 <span class="math inline">\(S\)</span> 下第 <span class="math inline">\(n\)</span> 个魔法时刻结束后的状态为 <span class="math inline">\((W_n,B_n)\)</span>，序列 <span class="math inline">\(\{V_A(W_n,B_n),n=0,1,\ldots\}\)</span>是上鞅，则策略 <span class="math inline">\(A\)</span> 就是最优的。</p></blockquote><p>注意这里是把任一策略 <span class="math inline">\(S\)</span>下的状态序列 <span class="math inline">\((W_n, B_n)\)</span> 代入策略<span class="math inline">\(A\)</span> 的值函数中。</p><p>其中的道理非常简单：对任何策略 <span class="math inline">\(S\)</span>，由于其吸收状态 <span class="math inline">\((W_\infty,B_\infty)\)</span> 中必有一个分量是0，从而由值函数边界条件 <span class="math inline">\((\ref{eq:boundary})\)</span> 有 <span class="math inline">\(B_\infty=V_A(W_\infty,B_\infty)\)</span>，所以<span class="math display">\[\mathbb{E}[B_\infty]=\mathbb{E}[V_A(W_\infty,B_\infty)]\leq\mathbb{E}[V_A(w,b)]=V_A(w,b).\]</span> 其中最后一个等号是因为 <span class="math inline">\(V_A(w,b)\)</span>是一个常数，常数的期望等于自身。</p><p>在教材中，Williams 直接「猜出」了策略 <span class="math inline">\(A\)</span>：</p><blockquote><p><strong>策略 <span class="math inline">\(A\)</span></strong>：如果当前黑绵羊的数量多于白绵羊，则什么也不做；否则就把白绵羊的数量变为黑绵羊的数量减1。</p></blockquote><p>显然 <span class="math inline">\(V_A\)</span> 有如下性质：</p><div id="recurrence" class="statement sta_v_a______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label"><span class="math inline">\(V_A\)</span> 的递推关系</span>.</span></p><ol type="1"><li>边界条件 <span class="math inline">\(V_A(0,b)=b\)</span>，<span class="math inline">\(V_A(w,0)=0\)</span>。</li><li><span class="math inline">\(V_A(w,b)=V_A(w-1,b), w\geqb&gt;0\)</span>。</li><li><span class="math inline">\(V_A(w,b)=\frac{w}{w+b}V_A(w+1,b-1)+\frac{b}{w+b}V_A(w-1,b+1)\)</span>,<span class="math inline">\(b&gt;w&gt;0\)</span>。</li></ol></div><p><span class="math inline">\(V_A\)</span> 由边界条件 1 和递推关系 2, 3完全决定。</p><p>从定义上看，关系 2 只在一半的区域上成立，而关系 3则在另一半的区域上成立。但是花费一番功夫，我们其实可以证明它们各自的「弱形式」在整个区域上都是对的：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>在区域 <span class="math inline">\(\Omega\)</span> 上，<span class="math inline">\(V_A\)</span> 函数满足如下的不等式：</p><ol start="4" type="1"><li><span class="math inline">\(V_A(w,b)\geq V_A(w-1,b),w&gt;0\)</span>。</li><li><span class="math inline">\(V_A(w,b)\geq\frac{w}{w+b}V_A(w+1,b-1)+\frac{b}{w+b}V_A(w-1,b+1),w&gt;0,b&gt;0\)</span>。</li></ol></div><p>4, 5 合起来说的就是无论男孩策略如何，<span class="math inline">\(\{V_A(W_n,B_n)\}\)</span> 总是一个上鞅！因此策略 <span class="math inline">\(A\)</span> 确实是最优的。</p><p>引理的证明是纯粹的分析，过程比较繁琐，我把它留给 Williams 的教材第15.3 节。写出 <span class="math inline">\(V(w,b)\)</span>的显式表达式来是很难的，Williams 证明了 <span class="math display">\[\lim_{k\to\infty}V(k,k)-(2k+\frac{\pi}{4}-\sqrt{\pik})=0.\label{eq:vkk}\tag{$\ast\ast$}\]</span> 因此如果开始有黑、白绵羊各10000 只，则策略 <span class="math inline">\(A\)</span>下黑绵羊的期望数目大约是 19824 只。</p><p>我对 Williams给出的估计不太放心，于是用书中给出的递推关系写了一段代码验证了一下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> *<br><br>pi = <span class="hljs-number">3.14159265358979</span><br>getcontext().prec = <span class="hljs-number">20</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve_sheep</span>(<span class="hljs-params">n</span>):</span><br>    p = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    v = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    v[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    p[<span class="hljs-number">1</span>] = Decimal(<span class="hljs-number">0.5</span>)<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        p[k] = (<span class="hljs-number">1</span> - <span class="hljs-number">1</span> / Decimal(<span class="hljs-number">2</span> * k)) * p[k - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        w = (<span class="hljs-number">1</span> - p[k]) / (<span class="hljs-number">1</span> + p[k])<br>        v[k + <span class="hljs-number">1</span>] = w * v[k] + (<span class="hljs-number">1</span> - w) * (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">return</span> v[n]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">estimate_sheep</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * n + pi / <span class="hljs-number">4</span> - (pi * n)**<span class="hljs-number">0.5</span><br><br>print(solve_sheep(<span class="hljs-number">10000</span>))<br>print(estimate_sheep(<span class="hljs-number">10000</span>))<br></code></pre></td></tr></tbody></table></figure><p>递推公式给出的真实值结果是 19823.5422285701，渐进公式给出的结果是19823.540013，准确的有点离谱啊！这真的有点刷新我对 Stirling公式的认知。</p><p>猜出最优策略、证明弱化的不等式、给出渐进公式，每一步都是神操作啊。</p><h1 id="附录">附录</h1><p>Williams 书中对渐进公式 <span class="math inline">\((\ref{eq:vkk})\)</span>的证明比较难读，我这里解释下其中的想法。关键是用对角线上的值 <span class="math inline">\(v_k=V(k,k)\)</span> 来表示出所有的 <span class="math inline">\(V(w, b),b&gt;w&gt;0\)</span>：</p><p><span class="math display">\[\begin{cases}V(k-c,k+c)=v_k+(2k-v_k)a_c,\\ V(k+1-c,k+c)=v_k+(2k+1-v_k)b_c.\end{cases}\]</span></p><p>其中</p><p><span class="math display">\[\begin{cases}a_c=2^{-(2k-2)}\sum\limits_{j=k}^{k+c-1}\dbinom{2k-1}{j},\\b_c=\left(2^{2k-1}+\frac{1}{2}\dbinom{2k}{k}\right)^{-1}\sum\limits_{j=k}^{k+c-1}\dbinom{2k}{j}.\end{cases}\]</span></p><p>Williams没有解释这组公式是怎么求出来的，它看起来很吓人，其实道理不复杂。我们用<span class="math inline">\(V(k-c,k+c)\)</span> 为例子来说明：</p><p>记 <span class="math inline">\(g(c) = V(k-c, k+c),0\leq c\leqk\)</span>，则 <span class="math inline">\(g(0)=v_k,\,g(k)=2k\)</span>，由前面 <a href="#recurrence" title="V_A 的递推关系"><span class="math inline">\(V_A\)</span> 的递推关系</a> 中的 3知其满足递推关系</p><p><span class="math display">\[g(c) = \frac{k-c}{2k}g(c-1) +\frac{k+c}{2k}g(c+1),\quad 1\leq c \leq k-1.\]</span> 这是一个 <span class="math inline">\([0,k]\)</span> 上的递推序列，并且已知边界条件<span class="math inline">\(g(0)\)</span> 和 <span class="math inline">\(g(k)\)</span>，我们来求解这个序列。</p><p>记</p><p><span class="math display">\[h(c) = \frac{g(c) - g(0)}{g(k)-g(0)} =\frac{g(c) - v_k}{g(k)-v_k}.\label{eq:hc}\tag{1}\]</span></p><p>则 <span class="math inline">\(h(c)\)</span>同样满足上述递推关系，但是边界条件为 <span class="math inline">\(h(0)=0\)</span>，<span class="math inline">\(h(k)=1\)</span>。于是</p><p><span class="math display">\[\begin{align}h(c+1)-h(c)&amp;=\frac{k-c}{k+c}(h(c)-h(c-1))\\&amp;=\cdots\\&amp;=\frac{(k-c)\cdots(k-1)}{(k+c)\cdots(k+1)}(h(1)-h(0))\\&amp;=\frac{\dbinom{2k-1}{k+c}}{\dbinom{2k-1}{k}}h(1).\label{eq:hrec}\tag{2}\end{align}\]</span></p><p>利用 <span class="math inline">\((\ref{eq:hrec})\)</span>我们可以解出 <span class="math inline">\(h(1)\)</span> 来：</p><p><span class="math display">\[1=h(k)=\sum_{c=0}^{k-1}\big(h(c+1)-h(c)\big)=h(1)\frac{\sum_{c=0}^{k-1}\dbinom{2k-1}{k+c}}{\dbinom{2k-1}{k}}=h(1)\dfrac{2^{2k-2}}{\dbinom{2k-1}{k}}.\]</span></p><p>即 <span class="math inline">\(h(1)=2^{-(2k-2)}\binom{2k-1}{k}\)</span>。再次利用<span class="math inline">\((\ref{eq:hrec})\)</span> 可得</p><p><span class="math display">\[h(c)=\sum_{j=0}^{c-1}\big(h(j)-h(j-1)\big)=\sum_{j=0}^{c-1}\frac{\dbinom{2k-1}{k+j}}{\dbinom{2k-1}{k}}h(1)=2^{-(2k-2)}\sum_{j=k}^{k+c-1}\dbinom{2k-1}{j}.\]</span></p><p>将上式代入 <span class="math inline">\((\ref{eq:hc})\)</span>即得结论。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Williams1991" class="csl-entry" role="listitem">Williams, David. 1991. <em>Probability with Martingales</em>. CambridgeUniversity Press.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>飞船空间跳跃问题</title>
      <link href="spaceship-jump/"/>
      <url>spaceship-jump/</url>
      
        <content type="html"><![CDATA[<p>本文的问题出自 Williams 的教材 <a href="https://www.cambridge.org/highereducation/books/probability-with-martingales/B4CFCE0D08930FB46C6E93E775503926#overview">ProbabilitywithMartingales</a>，虽然不算很难但是综合使用了许多知识，展示了抽象的鞅理论其实有着丰富多彩的应用。</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"></span>一艘太空船正在宇宙中做星际航行时，飞船的控制系统出了故障，飞船不能正常地进行空间跳跃，而是只能预先设定一个距离，然后以此距离进行一次方向完全随机的跳跃。现在飞船想要返回太阳系。假设太阳系的半径是<span class="math inline">\(r\)</span>，发生故障时飞船与太阳的距离为<span class="math inline">\(R&gt;r\)</span>。好消息是在每个时刻，飞船能够知道自身与太阳系的距离。</p><p>求证：不论采用怎样的跳跃策略，飞船返回太阳系的概率都小于 <span class="math inline">\(r/R\)</span>；但是对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，可以采取适当的策略，使得飞船返回太阳系的概率大于<span class="math inline">\((r-\epsilon)/R\)</span>，即 <span class="math inline">\(r/R\)</span> 是最优概率。这个最优策略是什么？</p></div><span id="more"></span><h1 id="预备知识">预备知识</h1><h2 id="条件期望的预备知识">条件期望的预备知识</h2><p>设 <span class="math inline">\(X,Y\)</span> 是两个随机变量，<span class="math inline">\(\varphi\)</span> 是可测函数。我们考虑条件期望<span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|X]\)</span>，这是一个关于<span class="math inline">\(\sigma(X)\)</span> 可测的随机变量，根据Doob-Dynkin 引理，它可以写成 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|X]=g(X)\]</span>的形式，其中 <span class="math inline">\(g\)</span> 是一个 Borel可测函数。但是这个 <span class="math inline">\(g\)</span>具体是什么呢？下面的 freezing lemma <span class="citation" data-cites="Williams1991">(<a href="#ref-Williams1991" role="doc-biblioref">Williams 1991, sec. 9.10</a>)</span> or <span class="citation" data-cites="Durrett2019">(<a href="#ref-Durrett2019" role="doc-biblioref">Durrett 2019, sec. 4.1</a>)</span>告诉我们，在一定条件下我们可以先将 <span class="math inline">\(X\)</span> 冻结为一个实数值 <span class="math inline">\(x\)</span>，上式的右边变成 <span class="math inline">\(g(x)\)</span>，左边变成 <span class="math inline">\(\{X=x\}\)</span> 条件下的期望 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|X=x]=\mathop{\mathrm{\mathbb{E}}}\varphi(x,Y).\]</span>即 <span class="math inline">\(g(x)=\mathop{\mathrm{\mathbb{E}}}\varphi(x,Y)\)</span>。这就找到了<span class="math inline">\(g\)</span> 的表达式。</p><div id="freeze" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span>是一个概率空间，<span class="math inline">\(X, Y\)</span>是两个取值在某可测空间 <span class="math inline">\((S,\mathcal{S})\)</span> 中的随机变量，子 <span class="math inline">\(\sigma\)</span> 域 <span class="math inline">\(\mathcal{G}\subseteq\mathcal{F}\)</span> 满足<span class="math inline">\(X\in\mathcal{G}\)</span> 且 <span class="math inline">\(\mathcal{G}\)</span> 与 <span class="math inline">\(Y\)</span> 独立。可测函数 <span class="math inline">\(\varphi: S\times S\to\mathbb{R}\)</span> 满足<span class="math inline">\(\varphi\)</span> 非负或者 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}|\varphi(X,Y)|&lt;\infty\)</span>。令 <span class="math inline">\(g(x)=\mathop{\mathrm{\mathbb{E}}}\varphi(x,Y)\)</span>，则 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|\mathcal{G}]=g(X).\]</span></p></div><p>在进入证明之前，我们来看个例子：</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>设 <span class="math inline">\(X, Y\)</span>是两个独立的随机变量，<span class="math inline">\(Y\)</span> 服从的是<span class="math inline">\([0, 1]\)</span> 上的均匀分布，<span class="math inline">\(X\)</span> 服从的分布我们可以不用关心。问条件期望<span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\sin(XY)|X]\)</span>是什么？</p><p>这相当于在 <a href="#freeze" title="引理 1.1">引理 1.1</a> 中取 <span class="math inline">\(\varphi(X,Y)=\sin(XY)\)</span> 和 <span class="math inline">\(\mathcal{G}=\sigma(X)\)</span>。<a href="#freeze" title="引理 1.1">引理 1.1</a> 告诉我们可以把 <span class="math inline">\(\sin(XY)\)</span> 中的 <span class="math inline">\(X\)</span> 冻结为常数 <span class="math inline">\(X=x\)</span>，把 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\sin(XY)|X]\)</span>视作关于常数 <span class="math inline">\(x\)</span> 的积分 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\sin(xY)]=\int_0^1\sin(xy)\,\mathrm{d}y = \frac{1}{x}\int_0^x\sin(z)\,\mathrm{d}z=\frac{1-\cos x}{x}.\]</span> 然后把 <span class="math inline">\(x\)</span> 解冻为 <span class="math inline">\(X\)</span> 即得 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\sin(XY)|X] =\frac{1-\cos X}{X}.\]</span></p></div><p><a href="#freeze" title="引理 1.1">引理 1.1</a> 中的可测空间 <span class="math inline">\((S,\mathcal{S})\)</span> 可以是多维空间 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>，<span class="math inline">\(X,Y\)</span> 也可以是独立的随机向量。即如果 <span class="math inline">\(\varphi(X_1,\ldots,X_n,Y_1,\ldots,Y_m)\)</span>是关于随机变量的可测函数，<span class="math inline">\(\sigma(X_1,\ldots,X_n)\subset\mathcal{G}\)</span>并且 <span class="math inline">\(\mathcal{G}\)</span> 和 <span class="math inline">\(\sigma(Y_1,\ldots,Y_m)\)</span> 独立，那么条件期望<span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|\mathcal{G}]\)</span>就是一个以 <span class="math inline">\((x_1,\ldots,x_n)\)</span>为参变元的多重积分 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(x_1,\ldots,x_n,Y_1,\ldots,Y_m)]=g(x_1,\ldots,x_n).\]</span></p><p><strong>证明</strong>：我们要证明对任何可测集 <span class="math inline">\(C\in\mathcal{G}\)</span> 有</p><p><span class="math display">\[\int_C \varphi(X, Y)\mathrm{d}\mu =\int_C g(X)\mathrm{d}\mu.\]</span> 当 <span class="math inline">\(\varphi(x,y)=\mathbb{1}_A(x)\mathbb{1}_B(y)\)</span> 时，<span class="math inline">\(g(x)=\mathbb{1}_A(x)\mathbb{P}(\{Y\inB\})\)</span>，从而 <span class="math display">\[\begin{align*}\int_C\mathbb{1}_A(X)\mathbb{1}_B(Y)\mathrm{d}\mu&amp;=\mathbb{P}(\{X\inA\}\cap C\cap\{Y\in B\})\\&amp;=\mathbb{P}(\{X\in A\}\capC)\cdot\mathbb{P}(\{Y\inB\})\\&amp;=\int_C\mathbb{1}_A(X)\mathrm{d}\mu\cdot\mathbb{P}(\{Y\inB\})\\&amp;=\int_C g(X)\mathrm{d}\mu.\end{align*}\]</span></p><p>于是结论对所有形如 <span class="math inline">\(A\times B\)</span>的集合的示性函数成立。这些函数构成一个 <span class="math inline">\(\pi-\)</span> 系。根据可测函数的单调类定理(monotone class theorem)，结论对所有非负或者可积函数都成立。<span class="math inline">\(\blacksquare\)</span></p><h2 id="分析的预备知识">分析的预备知识</h2><div id="newton-potential" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B=B(A,R)\)</span> 是 <span class="math inline">\(\mathbb{R}^3\)</span> 中以点 <span class="math inline">\(A\)</span> 为中心，半径为 <span class="math inline">\(R\)</span> 的球，<span class="math inline">\(X\)</span> 是球面上均匀分布的随机点，则 <span class="math inline">\(X\)</span> 与原点 <span class="math inline">\(O\)</span> 之间距离倒数的期望为 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}\frac{1}{|X|}=\begin{cases}1/a&amp; a&gt;R,\\ 1/R &amp; a\leq R.\end{cases}\]</span> 其中 <span class="math inline">\(a=|A|\)</span> 是 <span class="math inline">\(A\)</span> 与原点之间的距离。</p></div><p>这个引理其实是我们都熟悉的高中物理知识：假设以 <span class="math inline">\(A\)</span> 为中心，半径为 <span class="math inline">\(R\)</span> 的球壳上有总量为 1的均匀分布的电荷，则球壳表面和内部的电势处处等于 <span class="math inline">\(1/R\)</span>，球壳外部任意一点 <span class="math inline">\(P\)</span> 的电势等于 <span class="math inline">\(P\)</span> 和球心距离的倒数，即 <span class="math inline">\(1/|P-A|\)</span>（不计物理常数），此即为结论。</p><p>当然这不是一个严格的证明，实际上这个积分正是 Newton势函数的简单情形。由于这不是本文的重点，就不再展开讲了，读者可以参考<span class="citation" data-cites="Donoghue2014">(<a href="#ref-Donoghue2014" role="doc-biblioref">Donoghue 2014, chap.8</a>)</span>。</p><h1 id="建立模型">建立模型</h1><p>我们开始正式求解本文开头的问题。</p><ol type="1"><li><p>初始时刻为 0，太阳系是以原点为圆心，半径为 <span class="math inline">\(r\)</span> 的球，飞船初始位置在 <span class="math inline">\((R,0,0)\)</span> 处。</p></li><li><p>设 <span class="math inline">\(\{U_n\}_{n\geq 1}\)</span>是定义在某个概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\)</span>上的一组独立同分布的、在单位球面上均匀分布的随机向量，它们表示飞船每次空间跳跃的随机方向。并设<span class="math inline">\(\mathcal{F}_n=\sigma(U_1,\ldots,U_n)\)</span> 以及<span class="math inline">\(\mathcal{F}_0=(\Omega,\emptyset)\)</span>。</p></li><li><p>设第 <span class="math inline">\(n\)</span> 次空间跳跃的距离为<span class="math inline">\(l_n(n\geq1)\)</span>，由于 <span class="math inline">\(l_n\)</span> 是根据 <span class="math inline">\(n\)</span> 时刻之前的信息决定的，所以 <span class="math inline">\(l_n\)</span> 关于 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 可测。</p></li><li><p>设第 <span class="math inline">\(n\)</span>次空间跳跃后飞船的坐标为 <span class="math inline">\(X_n\)</span>，那么<span class="math display">\[X_n=X_{n-1} + l_n U_n.\quadn=1,2,\ldots.\]</span> 其中 <span class="math inline">\(X_0=(R,0,0)\)</span> 是飞船的初始位置。</p></li><li><p>设 <span class="math inline">\(T\)</span>是飞船首次返回太阳系的时间： <span class="math display">\[T = \inf\,\{n\mid X_n\in B(0,r)\},\]</span>则 <span class="math inline">\(T\)</span>的取值范围是 <span class="math inline">\(\mathbb{N^+}\cup\{+\infty\}\)</span>。我们要估算的是事件<span class="math inline">\(\{T&lt;+\infty\}\)</span>的概率，这正是飞船能够在有限时间内回到太阳系的概率。</p></li></ol><p>现在我们着手研究一下飞船的运动规律。</p><p>设 <span class="math inline">\(R_n\)</span> 为第 <span class="math inline">\(n\)</span> 次跳跃以后飞船与太阳系的距离，<span class="math inline">\(R_0=R\)</span>，我们想知道 <span class="math inline">\(R_n\)</span> 和 <span class="math inline">\(R_{n+1}\)</span> 之间的关系。</p><p>对 <span class="math inline">\(\mathcal{F}=\mathcal{F}_n,\,\mathcal{G}=\mathcal{F}_{n-1},\,X=(X_{n-1},l_n),\,Y=U_n,\,\varphi(X,Y)=1/|X_{n-1}+l_nY|\)</span> 应用前面的关于条件期望的 <a href="#freeze" title="引理 1.1">引理 1.1</a> 和 <a href="#newton-potential" title="引理 1.2">引理 1.2</a> 得到</p><p><span class="math display">\[\mathop{\mathrm{\mathbb{E}}}\left[\left.\frac{1}{R_n}\right|\mathcal{F}_{n-1}\right]=\mathop{\mathrm{\mathbb{E}}}\left.\frac{1}{\left|X_{n-1}+l_nU_n\right|}\right|_{X_{n-1}=A}\leq\frac{1}{|A|}=\frac{1}{R_{n-1}}.\]</span></p><p>这里由于 <span class="math inline">\(X_{n-1}\)</span> 和 <span class="math inline">\(l_n\)</span> 都是关于 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 可测的，而 <span class="math inline">\(U_n\)</span> 和 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 是独立的，所以应用 <a href="#freeze" title="引理 1.1">引理 1.1</a> 的条件是满足的。</p><p>总结一下：</p><div id="supermartingale" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\{1/R_n\}\)</span> 关于 <span class="math inline">\(\{\mathcal{F}_n\}\)</span> 构成一个上鞅（与策略无关）。特别地如果跳跃距离总是不超过当前飞船与太阳系的距离，即对任何<span class="math inline">\(n\geq1\)</span> 有 <span class="math inline">\(l_n\leq R_{n-1}\)</span>，则 <span class="math inline">\(\{1/R_n\}\)</span> 还是一个鞅。</p></div><p><strong>证明</strong>：只要再说明每个 <span class="math inline">\(1/R_n\)</span> 是可积的随机变量即可。由于 <span class="math inline">\(1/R_n\)</span> 是非负的随机变量因此 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[1/R_n|\mathcal{F}_{n-1}]\)</span>是有定义的且已经证明其小于等于 <span class="math inline">\(1/R_{n-1}\)</span>，于是 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[1/R_n]=\mathop{\mathrm{\mathbb{E}}}[\mathop{\mathrm{\mathbb{E}}}[1/R_n|\mathcal{F}_{n-1}]]\leq\mathop{\mathrm{\mathbb{E}}}[1/R_{n-1}].\]</span>对 <span class="math inline">\(n\)</span> 归纳即可。<span class="math inline">\(\blacksquare\)</span></p><p><a href="#supermartingale" title="定理 2.1">定理 2.1</a>是解决整个问题最关键的一步，有了它就海阔天空，没有它就寸步难行。由它我们立刻可以导出一个有趣的观察：由于非负上鞅一定是几乎处处收敛的，因此<a href="#supermartingale" title="定理 2.1">定理 2.1</a> 的结论蕴含<span class="math inline">\(\lim\limits_{n\to\infty}R_n(\omega)\)</span>几乎处处存在。这有两种可能：<span class="math inline">\(\lim\limits_{n\to\infty}R_n(\omega)=+\infty\)</span>或者 <span class="math inline">\(\lim\limits_{n\to\infty}R_n(\omega)=a&lt;+\infty\)</span>。所以飞船要么飞向无穷远，即迷失在宇宙的深处，要么被吸引到某个有限的位置。</p><p>现在我们可以证明：</p><div id="lessthan" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.2</span>.</span><span class="statement-spah"></span>不论飞船采取怎样的策略，返回太阳系的概率都严格小于 <span class="math inline">\(r/R\)</span>。</p></div><p>证明只用到非常基础的鞅的知识：</p><p>设 <span class="math inline">\(Z_n=1/R_n\)</span>，则 <span class="math inline">\(\{Z_n\}\)</span> 是一个非负上鞅，所以 <span class="math inline">\(Z_\infty=\lim\limits_{n\to\infty}Z_n\)</span>是几乎处处存在的。考虑由停时 <span class="math inline">\(T\)</span>截断得到的非负上鞅序列 <span class="math inline">\(\{Z_{T\wedgen}\}\)</span>，这个上鞅序列也是几乎处处收敛的，其中 <span class="math display">\[\lim_{n\to\infty}Z_{T\wedge n} =\begin{cases}\lim_{n\to\infty}Z_n&amp; T=\infty,\\ Z_T&amp;T&lt;\infty.\end{cases}\]</span> 一方面根据非负可积函数列的 Fatou 引理有<span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]\leq\varliminf_{n\to\infty}\mathop{\mathrm{\mathbb{E}}}[Z_{T\wedgen}]\leq \mathop{\mathrm{\mathbb{E}}}[Z_0]=\frac{1}{R}.\]</span>另一方面</p><p><span class="math display">\[\begin{align*}\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]&amp;=\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]+\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_n\mathbb{1}_{\{T=\infty\}}]\\&amp;\geq \mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]\geq\frac{\mathbb{P}(T&lt;\infty)}{r}.\end{align*}\]</span></p><p>其中最后一个不等号是因为 <span class="math inline">\(Z_T\geq1/r\)</span>。综合这两个不等式就得到了 <span class="math inline">\(\mathbb{P}(T&lt;\infty)\leqr/R\)</span>，即任何策略下飞船最终返回太阳系的概率不大于 <span class="math inline">\(r/R\)</span>。</p><p>要证明这个概率是严格小于 <span class="math inline">\(r/R\)</span>的，我们只要证明上面式子的最后一个不等号是严格成立的： <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]&gt;\frac{\mathbb{P}(T&lt;\infty)}{r}.\]</span></p><p>当然需要假定这里的 <span class="math inline">\(\{T&lt;\infty\}\)</span> 有正概率 （返回概率是 0的话当然小于 <span class="math inline">\(r/R\)</span>，没什么好证的）。为此只要证明在事件<span class="math inline">\(\{T&lt;\infty\}\)</span> 上几乎处处有 <span class="math inline">\(Z_T&gt;1/r\)</span>，即 <span class="math inline">\(R_T&lt;r\)</span> 即可。</p><p>我们来证明对每个 <span class="math inline">\(n\geq0\)</span>，事件<span class="math inline">\(A_n=\{R_n=0 \text{ or } R_n=r\}\)</span>都是零概率事件。</p><p>对 <span class="math inline">\(n\)</span> 归纳：<span class="math inline">\(n=0\)</span> 时 <span class="math inline">\(R_0=R&gt;r\)</span>，结论成立。设结论在小于 <span class="math inline">\(n\)</span> 时都成立，来看 <span class="math inline">\(n\)</span> 的情形。</p><p>由于 <span class="math inline">\(\mathbb{P}(A_n)=\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}]=\mathop{\mathrm{\mathbb{E}}}[\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}|\mathcal{F}_{n-1}]]\)</span>，我们只要证明<span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}|\mathcal{F}_{n-1}]\)</span>是几乎处处为 0 的随机变量即可。</p><p>在 <a href="#freeze" title="引理 1.1">引理 1.1</a> 中取 <span class="math inline">\(X=(X_{n-1},l_n),\,Y=U_n,\,\mathcal{G}=\mathcal{F}_{n-1}\)</span>，我们得到<span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}|\mathcal{F}_{n-1}]=\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\bigg|\mathcal{F}_{n-1}]=\mathop{\mathrm{\mathbb{E}}}\left[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\right].\]</span>其中上式最右边的期望是对单位球面上均匀分布的 <span class="math inline">\(U_n\)</span> 进行积分，结果是一个关于 <span class="math inline">\((X_{n-1},l_n)\)</span>的函数。显然无论如何上式右边作为一个只取 <span class="math inline">\(\{0,1\}\)</span> 两个值的函数的积分，结果必然在<span class="math inline">\([0,1]\)</span> 中。</p><ul><li>如果 <span class="math inline">\(|X_{n-1}|\in\{0,r\}\)</span>，我们已经知道结果在<span class="math inline">\([0,1]\)</span> 中。</li><li>如果 <span class="math inline">\(|X_{n-1}|\notin\{0,r\}\)</span>，这时以 <span class="math inline">\(X_{n-1}\)</span> 为中心，<span class="math inline">\(l_n\)</span> 为半径的球面上，与原点之间的距离为<span class="math inline">\(0\)</span> 或者 <span class="math inline">\(r\)</span> 的点的测度为 0，即积分项 <span class="math inline">\(\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\)</span> 对几乎处处的 <span class="math inline">\(U_n\)</span> 都是 0，当然积分值 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}\left[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\right]=0\)</span>。</li></ul><p>于是我们有 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}\left[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\right]=\begin{cases}\in[0,1], &amp; |X_{n-1}|\in\{0,r\}\\0,        &amp; |X_{n-1}|\notin\{0,r\}\end{cases}\]</span></p><p>根据归纳假设，<span class="math inline">\(|X_{n-1}|\in\{0,r\}\)</span> 的概率是 0，即 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}\left[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\right]\)</span> 是一个几乎处处为 0 的函数，从而 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}|\mathcal{F}_{n-1}]\)</span>也几乎处处为 0，即得所证。</p><h1 id="对策略的进一步分析">对策略的进一步分析</h1><p>现在我们把注意力转移到飞船不能返回太阳系这个事件上来。前面已经说过，飞船的运动只有两种可能，迷失在无穷远处或者被禁锢在一个有限的区域内，所以如果飞船不能返回太阳系，则飞船要么飞向无穷远，要么在太阳系之外的一个有限区域内打转。我们想知道，怎么判断这两种情形哪一种会发生呢？</p><p>举个例子，考虑这样一个明显不合理的策略：第 <span class="math inline">\(n\)</span> 次的跳跃距离总是设定为 <span class="math inline">\(1/2^n\)</span>，在这个策略下飞船永远飞不出一个半径为1 的空间，所以这种策略是应该避免的。</p><p>你可以注意到这个糟糕的策略的问题出在跳跃距离之和是收敛的。如果我们强迫每次跳跃的距离都大于一个固定的值<span class="math inline">\(\epsilon\)</span>（<span class="math inline">\(\epsilon\)</span>可以是任意的正数），就可以避免这种情形出现，这就是下面的定理：</p><div id="goinf" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\epsilon\)</span> 是任一正数 <span class="math display">\[E:=\{\omega:\T(\omega)=\infty,\  l_n(\omega)\geq\epsilon,\ \forall n\geq1\},\]</span>则我们有 <span class="math display">\[\lim_{n\to\infty}R_n=+\infty,\quad \text{for a.e.}\ \omega\in E.\]</span></p></div><p><strong>证明</strong>：设 <span class="math inline">\(\theta_n\)</span> 为 <span class="math inline">\(X_{n-1}\)</span> 与 <span class="math inline">\(U_n\)</span> 之间的夹角，利用关系 <span class="math inline">\(X_n=X_{n-1}+l_nU_n\)</span>以及三角形的余弦公式可得 <span class="math display">\[R_n^2=R_{n-1}^2+l_n^2+2R_{n-1}l_n\cos\theta_n.\]</span>令 <span class="math inline">\(B_n=\{\cos\theta_n\geq1/2\}\)</span>，则在事件 <span class="math inline">\(B_n\)</span>上我们有</p><p><span class="math display">\[R_n^2\geqR_{n-1}^2+l_n^2+R_{n-1}l_n\geq(R_{n-1}+l_n/2)^2.\]</span> 结合在事件<span class="math inline">\(E\)</span> 上有 <span class="math inline">\(l_n\geq\epsilon\)</span>，于是在事件 <span class="math inline">\(B_n\cap E\)</span> 上有 <span class="math display">\[R_n\geq R_{n-1}+l_n/2\geqR_{n-1}+\epsilon/2,\quad\omega\in B_n\cap E.\]</span> 如果我们能证明<span class="math inline">\(\mathbb{P}(\{B_n\\text{i.o.}\})=1\)</span>，再排除掉使得 <span class="math inline">\(R_n(\omega)\)</span>不收敛的零测集，则对几乎处处的 <span class="math inline">\(\omega\inE\)</span> 都有 <span class="math inline">\(R_n\geqR_{n-1}+\epsilon/2\)</span> 对无穷多个 <span class="math inline">\(n\)</span> 成立。对这些 <span class="math inline">\(\omega\)</span>，<span class="math inline">\(R_n\)</span> 是不可能收敛到一个有限的点的，只能是<span class="math inline">\(\lim\limits_{n\to\infty}R_n(\omega)=\infty\)</span>，这就说明飞船在<span class="math inline">\(E\)</span> 上几乎处处飞向无穷远。</p><p>为了证明 <span class="math inline">\(\mathbb{P}(\{B_n\\text{i.o.}\})=1\)</span>，我们只要证明 <span class="math inline">\(\{B_n\}\)</span> 是独立的事件列，且对每个 <span class="math inline">\(n\)</span> 有 <span class="math inline">\(\mathbb{P}(B_n)=\frac{1}{4}\)</span>，这样由Borel-Cantelli 第二引理就得到了结论。</p><p>注意到（又用到 <a href="#freeze" title="引理 1.1">引理 1.1</a>啦）</p><p><span class="math display">\[\begin{align*}\mathbb{P}[B_n| \mathcal{F}_{n-1}] &amp;= \mathbb{P}[\cos(U_n, v)\geq1/2] \bigg|_{v=X_{n-1}} \\&amp;= \mathbb{P}[U_n\in\{(x,y,z)\in\mathbb{R}^3:\ z\geq 1/2\}]\\&amp;=\frac{1}{4}.\end{align*}\]</span></p><p>于是对任何一组下标 <span class="math inline">\(n_1&lt;n_2&lt;\cdots&lt;n_k\)</span>，记 <span class="math inline">\(A=B_{n_1}\cap\cdots\cap{B_{n_{k-1}}}\)</span> 以及<span class="math inline">\(B=B_{n_k}\)</span>，并注意到由于 <span class="math inline">\(n_{k-1}\leq n_k-1\)</span> 因此 <span class="math inline">\(A\in\mathcal{F}_{n_k-1}\)</span>，所以</p><p><span class="math display">\[\begin{align*}\mathbb{P}[B_{n_1}\cap\cdots\capB_{n_k}] &amp;= \mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_A\mathbb{1}_B] =\mathop{\mathrm{\mathbb{E}}}[\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_A\mathbb{1}_B|\mathcal{F}_{n_k-1}]]\\&amp;=\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_A\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_B|\mathcal{F}_{n_k-1}]]\\&amp;=\frac{1}{4}\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_A]\\&amp;=\frac{1}{4}\mathbb{P}(B_{n_1}\cap\cdots\capB_{n_{k-1}}).\end{align*}\]</span></p><p>从而由递推可见对每个 <span class="math inline">\(n\)</span> 都有<span class="math inline">\(\mathbb{P}(B_n) =\frac{1}{4}\)</span>且它们是互相独立的。</p><h1 id="最优策略">最优策略</h1><p>现在我们已经知道飞船返回太阳系的概率总是小于 <span class="math inline">\(r/R\)</span>，也知道只要策略得当，就可以避免飞船在原地打转的糟糕情况。接下来的问题是：最好的策略到底是什么？</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.1</span>.</span><span class="statement-spah"></span>定义如下的跳跃策略：在准备第 <span class="math inline">\(n\)</span> 次跳跃时，如果飞船已经在太阳系内，则令<span class="math inline">\(l_n=0\)</span>，否则令 <span class="math inline">\(l_n=R_{n-1}-r+\epsilon\)</span>，这里 <span class="math inline">\(0&lt;\epsilon&lt;r\)</span>。在这个跳跃策略下，飞船返回太阳系的概率大于<span class="math inline">\((r-\epsilon)/R\)</span>。</p></div><p>注意在这个策略中总是有 <span class="math inline">\(l_n&lt;R_{n-1}\)</span>，因此 <span class="math inline">\(\{Z_n=1/R_n\}\)</span>实际上是一个鞅。此外由于总是有 <span class="math inline">\(R_n\geqr-\epsilon\)</span>，所以 <span class="math inline">\(Z_n\leq1/(r-\epsilon)\)</span>，即 <span class="math inline">\(\{Z_n\}\)</span> 被常数 <span class="math inline">\(1/(r-\epsilon)\)</span> 所控制。</p><p>接下来的证明不过是 <a href="#lessthan" title="定理 2.2">定理 2.2</a>证明的重复：</p><p>这次根据控制收敛定理有 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]=\lim_{n\to\infty}\mathop{\mathrm{\mathbb{E}}}[Z_{T\wedgen}]=\mathop{\mathrm{\mathbb{E}}}[Z_0]=\frac{1}{R}.\]</span> 另一方面<span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]=\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]+\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_n\mathbb{1}_{\{T=\infty\}}].\]</span>这个时候要注意到在 <span class="math inline">\(\{T=\infty\}\)</span>上总是有 <span class="math inline">\(l_n\geq\epsilon\)</span>，因此根据<a href="#goinf" title="定理 3.1">定理 3.1</a>的结论，飞船几乎必然飞向无穷远，即 <span class="math display">\[\lim_{n\to\infty}Z_n=0,\quad\omega\in\{T=\infty\}.\]</span> 所以 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]=\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]\leq\frac{1}{r-\epsilon}\mathbb{P}(T&lt;\infty).\]</span>综合两个式子就证明了 <span class="math inline">\(\mathbb{P}(T&lt;\infty)\geq(r-\epsilon)/R\)</span>。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Donoghue2014" class="csl-entry" role="listitem">Donoghue, W. F. 2014. <em>Distributions and Fourier Transforms</em>.ISSN. Elsevier Science. <a href="https://books.google.com/books?id=P30Y7daiGvQC">https://books.google.com/books?id=P30Y7daiGvQC</a>.</div><div id="ref-Durrett2019" class="csl-entry" role="listitem">Durrett, Rick. 2019. <em>Probability: Theory and Examples</em>. 5th ed.Cambridge Series in Statistical and Probabilistic Mathematics. CambridgeUniversity Press.</div><div id="ref-Williams1991" class="csl-entry" role="listitem">Williams, David. 1991. <em>Probability with Martingales</em>. CambridgeUniversity Press.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Artinian 环与 Wedderburn-Artin 定理</title>
      <link href="wedderburn-artin-theorem/"/>
      <url>wedderburn-artin-theorem/</url>
      
        <content type="html"><![CDATA[<p>Wedderburn-Artin 定理最早源于 1907 年 Wedderburn研究域上有限维结合代数的分类定理。在 Wedderburn考虑这个问题的时候，Killing 和 Cartan 等人已经完成了有限维复半单 Lie代数的分类工作，如果读者对有限维 Lie代数有所了解的话，可能已经知道任何有限维复 Lie 代数 <span class="math inline">\(L\)</span> 有一个极大可解理想 <span class="math inline">\(\mathrm{rad}(L)\)</span>，叫做 <span class="math inline">\(L\)</span> 的根 (radical)，去掉这个根的商代数<span class="math inline">\(L/\mathrm{rad}(L)\)</span>是半单代数，其上的双线性型 Killing型是非退化的，从而可以通过反复取正交补的方式将 <span class="math inline">\(L/\mathrm{rad}(L)\)</span>分解为一些单代数的直和，然后对单 Lie 代数的结构进行讨论得出其共有 9种不同的类型。Wedderburn 的思路自然受到了 Killing等人工作的启发，他采取了类似的套路：</p><p>对域 <span class="math inline">\(F\)</span> 上的有限维结合代数 <span class="math inline">\(A\)</span>：</p><ol type="1"><li>定义根理想 <span class="math inline">\(\mathrm{rad}(A)\)</span>。</li><li>转移到半单代数 <span class="math inline">\(A/\mathrm{rad}(A)\)</span>。</li><li>将 <span class="math inline">\(A/\mathrm{rad}(A)\)</span>分解为单代数的直和。</li><li>讨论单代数的结构。</li></ol><p>整个路线图如下所示：</p><p><img src="/images/wedderburn-artin/steps.svg" class="fig"></p><p>总之虽然有限维复李代数和结合代数结构相差很大，但它们的结构定理遵循了类似的套路：拿走可解/幂零的部分，剩下的部分是半单的，而半单是单的直和，于是最终归结为对单成分的结构进行讨论。</p><p>Wedderburn-Artin定理的过程比较长，不过在头脑中事先明确这条主线，理解整个证明并不是一件困难的事情。</p><p>本文将针对左 Artinian 环的情形证明 Wedderburn-Artin定理。我主要参考了 Curtis 和 Reiner 的经典 <span class="citation" data-cites="curtis-reiner">(<a href="#ref-curtis-reiner" role="doc-biblioref">Curtis and Reiner 1962</a>)</span>，Herstein的精彩小书 <span class="citation" data-cites="herstein-rings">(<a href="#ref-herstein-rings" role="doc-biblioref">Herstein1994</a>)</span>，以及林节玄的 <span class="citation" data-cites="Lam01">(<a href="#ref-Lam01" role="doc-biblioref">Lam2001</a>)</span>。C&amp;R的书是个大部头，但它总是从最基本的概念讲起，叙述清楚易懂，对新手非常友好。Herstein的书则是另一种风格，主线简单，节奏很快，短短几章就讲到了中心单代数和Galois 上同调。林节玄的书风格则更为现代一些，我没有细读，不多评价。</p><span id="more"></span><div id="------" class="statement sta___ definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注意</span>：</span></p><ol type="1"><li>Wedderburn 对 <span class="math inline">\(\mathrm{rad}(A)\)</span>的定义方法只适用于像左 Artinian 环这样有特殊限制的环。现代普遍采用Jacobson 根 <span class="math inline">\(J(A)\)</span> 来定义 <span class="math inline">\(\mathrm{rad}(A)\)</span>。Jacobson根的好处是它对任意的含 1 结合环都有定义，而且在建立了关于 Jacobson根的事实后，证明 Wedderburn-Artin 定理相对采用 Wedderburn的途径要简洁很多。</li><li>定义 <span class="math inline">\(A\)</span>的半单性有两种定义方法：<span class="math inline">\(\mathrm{rad}(A)=(0)\)</span>或者完全可约性。后者是更常见的做法。在左 Artinian环的情形，这两种方法是等价的。</li></ol></div><h1 id="记号与约定">记号与约定</h1><ul><li><p>在本文中，<span class="math inline">\(R\)</span>总表示含乘法单位元的结合环。我们称 <span class="math inline">\(R\)</span> 是<strong>左 Artinian 环</strong>，如果<span class="math inline">\(R\)</span> 的左理想满足所谓的降链条件(Descending chain condition, DCC)，即对任何左理想 <span class="math inline">\(\{I_n\}_{n=1}^\infty\)</span> 组成的无穷序列 <span class="math display">\[I_1\supseteq I_2\supseteq \cdots \supseteqI_n\supseteq\cdots\]</span> 都必然存在正整数 <span class="math inline">\(N\)</span> 使得 <span class="math inline">\(I_N=I_{N+1}=\cdots\)</span>。左 Artinian环的另一种等价刻画是，任何由 <span class="math inline">\(R\)</span>的左理想组成的非空集合必有极小元。</p></li><li><p>如果一个左 <span class="math inline">\(R-\)</span> 模 <span class="math inline">\(M\)</span> 除了 <span class="math inline">\((0)\)</span> 和自身以外没有其它非平凡的子模，就称<span class="math inline">\(M\)</span>是<strong>不可约</strong>的。如果左理想 <span class="math inline">\(I\subseteq R\)</span> 作为左 <span class="math inline">\(R-\)</span> 模是不可约的，就称 <span class="math inline">\(I\)</span>是不可约左理想。非零的不可约左理想叫作<strong>极小左理想</strong>。</p></li></ul><h1 id="定义环-r-的根-mathrmradr">定义环 <span class="math inline">\(R\)</span> 的根 <span class="math inline">\(\mathrm{rad}(R)\)</span></h1><p>前面提到，Wedderburn 的想法第一步是仿照 Lie 代数的情形定义环 <span class="math inline">\(R\)</span> 的根 <span class="math inline">\(\mathrm{rad}(R)\)</span>，它必须是一个双边理想，从而可以取商环<span class="math inline">\(R/\mathrm{rad}(R)\)</span>，<span class="math inline">\(R/\mathrm{rad}(R)\)</span> 的根是平凡的。</p><p>Wedderburun 希望将 <span class="math inline">\(\mathrm{rad}(R)\)</span> 定义为 <span class="math inline">\(R\)</span> 的极大幂零理想，即 <span class="math inline">\(R\)</span>的所有<strong>幂零左理想</strong>的和。这个定义本身的合理性是存疑的，所有幂零左理想的和是否真的是双边理想？是否仍然幂零？虽然确实如此，但是背后的原因并不直观。这一节的任务就是解决这个问题。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.1</span>.</span><span class="statement-spah"> </span>我们称 <span class="math inline">\(R\)</span> 的左理想 <span class="math inline">\(I\)</span> 是幂零的，如果存在正整数 <span class="math inline">\(n\)</span> 使得 <span class="math inline">\(I^n=0\)</span>。</p></div><p>显然 <span class="math inline">\(I\)</span>幂零自动蕴含其元素都是幂零的：对任何 <span class="math inline">\(x\inI\)</span> 有 <span class="math inline">\(x^n=0\)</span>。但是反过来则未必对：<span class="math inline">\(I\)</span> 的每个元素都幂零并不能保证 <span class="math inline">\(I\)</span> 是幂零的。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(R\)</span> 的所有幂零左理想的和记作 <span class="math inline">\(\mathrm{rad}(R)\)</span>。</p></div><p>我们要解决两个问题：</p><ol type="1"><li><p><span class="math inline">\(\mathrm{rad}(R)\)</span>还是幂零左理想的吗？不难证明有限多个幂零左理想的和仍然是幂零的，但是无穷多个幂零左理想的和还幂零吗？</p></li><li><p><span class="math inline">\(\mathrm{rad}(R)\)</span>是双边理想吗？</p></li></ol><p>这两个问题都可以用一个引理来解决，这个引理的证明颇有一点技巧性：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(e\in R\)</span> 满足 <span class="math inline">\(e\ne0\)</span> 且 <span class="math inline">\(e^2=e\)</span>，就称 <span class="math inline">\(e\)</span> 是一个幂等元。</p></div><div id="idempotent" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理2.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(R\)</span> 是左 Artinian 环。如果左理想 <span class="math inline">\(I\subseteq R\)</span>不是幂零的，则其必然包含一个幂等元。</p></div><p>我们把 <a href="#idempotent" title="引理 2.4">引理 2.4</a>的证明稍微放一放，先看看它是怎么解决上面的问题 1, 2 的。</p><p>记 <span class="math inline">\(N\)</span> 为 <span class="math inline">\(R\)</span> 的所有幂零左理想 <span class="math inline">\(\{I_{\alpha}\}\)</span> 的和，则 <span class="math inline">\(N\)</span> 也是左理想，并且其中的元素都是 <span class="math inline">\(\{I_{\alpha}\}\)</span> 中元素的有限线性组合：<span class="math display">\[x =x_{\alpha_1}+x_{\alpha_2}+\cdots+x_{\alpha_k},\quad x_{\alpha_i}\inI_{\alpha_i}.\]</span></p><ol type="1"><li>如果 <span class="math inline">\(N\)</span> 不是幂零的，那么根据 <a href="#idempotent" title="引理 2.4">引理 2.4</a> 它包含一个幂等元 <span class="math inline">\(e\)</span>，于是 <span class="math inline">\(e\)</span>可以表示为有限多个幂零元的和，从而也是幂零的，矛盾！</li><li><span class="math inline">\(NR\)</span>是一个双边理想，而且它是幂零的：<span class="math display">\[(NR)^i=N(RN)^{i-1}R\subseteqN^iR.\]</span>特别它是一个幂零左理想，于是 <span class="math inline">\(NR\subseteq N\)</span>，从而 <span class="math inline">\(N\)</span> 是双边理想。</li></ol><p><strong><a href="#idempotent" title="引理 2.4">引理 2.4</a>的证明</strong>：</p><p>我们会反复使用 DCC 降链条件，即任何由 <span class="math inline">\(R\)</span> 的左理想构成的非空集合必有最小元。</p><p>首先不妨假设 <span class="math inline">\(I\)</span>是「极小」非幂零的，即 <span class="math inline">\(I\)</span>本身不幂零，但 <span class="math inline">\(I\)</span>的任何真理想都是幂零的。否则考察所有包含在 <span class="math inline">\(I\)</span>内的、非幂零的左理想组成的集合，此集合包含 <span class="math inline">\(I\)</span> 所以非空，于是根据 DCC条件它包含一个极小元 <span class="math inline">\(I_1\)</span>，<span class="math inline">\(I_1\)</span> 不是幂零的，但是任何真包含于 <span class="math inline">\(I_1\)</span> 内的左理想都是幂零的。用 <span class="math inline">\(I_1\)</span> 代替 <span class="math inline">\(I\)</span>，故而可以假设 <span class="math inline">\(I\)</span> 是极小非幂零的。</p><p><span class="math inline">\(I^2\)</span> 包含于 <span class="math inline">\(I\)</span> 内，但它不可能是幂零的，否则 <span class="math inline">\(I\)</span> 就幂零了，所以 <span class="math inline">\(I^2=I\)</span>。我们考察所有满足如下条件的左理想<span class="math inline">\(L\)</span> 组成的集合 <span class="math inline">\(S\)</span>：</p><ol type="1"><li><span class="math inline">\(L\subseteq I\)</span>。</li><li><span class="math inline">\(IL\ne0\)</span>。</li></ol><p>显然 <span class="math inline">\(S\)</span> 包含 <span class="math inline">\(I\)</span> 从而非空，于是 <span class="math inline">\(S\)</span> 包含一个极小元 <span class="math inline">\(L\)</span>。由于 <span class="math inline">\(IL\ne0\)</span> 所以存在 <span class="math inline">\(x\in L\)</span> 使得 <span class="math inline">\(Ix\ne 0\)</span>。由于 <span class="math inline">\(Ix\)</span> 是包含在 <span class="math inline">\(L\)</span> 内的一个左理想，而且 <span class="math inline">\(I(Ix)=Ix\ne0\)</span> 所以 <span class="math inline">\(Ix\)</span> 也在 <span class="math inline">\(S\)</span> 中，由 <span class="math inline">\(L\)</span> 的极小性有 <span class="math inline">\(Ix=L\)</span>。由 <span class="math inline">\(x\inL\)</span> 可知存在 <span class="math inline">\(a\in I\)</span> 满足<span class="math inline">\(x=ax\)</span>，从而 <span class="math display">\[x= ax = a^2x = \cdots.\]</span> 所以 <span class="math inline">\(a\)</span> 不可能是幂零的，并且 <span class="math inline">\((a^2-a)x=0\)</span>。我们断言 <span class="math inline">\(a^2-a\)</span> 是幂零的。为此进一步考虑包含在<span class="math inline">\(I\)</span> 内的左理想 <span class="math display">\[N = \{ u\in I\ |\ ux = 0\}.\]</span> 于是 <span class="math inline">\(Nx=0\)</span>，但 <span class="math inline">\(Ix\ne0\)</span>，所以 <span class="math inline">\(N\)</span> 真包含于 <span class="math inline">\(I\)</span> 内，所以 <span class="math inline">\(N\)</span>是幂零的，从而其每个元素都是幂零的，特别地 <span class="math inline">\(a^2-a\in N\)</span>是幂零的。我们断言存在一个多项式 <span class="math inline">\(p\)</span>使得 <span class="math inline">\(u=p(a)\)</span> 是一个幂等元。为此假设<span class="math inline">\((a^2-a)^k=0\)</span>，展开以后可得存在多项式<span class="math inline">\(q\)</span> 使得 <span class="math inline">\(a^k=a^{k+1}q(a)\)</span>，从而 （反复将等式右边的<span class="math inline">\(a^k\)</span> 替换为 <span class="math inline">\(a^{k+1}q(a)\)</span>） <span class="math display">\[a^k=a^kaq(a)=a^{k+2}q^2(a)=a^{k+3}q^3(a)=\cdots=a^{2k}q^{k}(a).\]</span>令 <span class="math inline">\(e=a^kq^k(a)\)</span>，则 <span class="math inline">\(a^k=a^ke\)</span>, 由于 <span class="math inline">\(a\)</span> 不是幂零的所以 <span class="math inline">\(e\ne0\)</span>。在 <span class="math inline">\(a^k=a^ke\)</span> 两边同乘以 <span class="math inline">\(q^k(a)\)</span> 得到 <span class="math inline">\(a^kq^k(a)=a^{k}q^{k}(a)e\)</span>，即 <span class="math inline">\(e=e^2\)</span>，从而 <span class="math inline">\(e\)</span> 是幂等元，这就证明了结论。<span class="math inline">\(\blacksquare\)</span></p><p>整理上述讨论，我们给出半单性的定义：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.5</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(R\)</span> 是左 Artinian 环，定义其根 <span class="math inline">\(\mathrm{rad}(R)\)</span> 为 <span class="math inline">\(R\)</span> 的所有幂零左理想之和，则 <span class="math inline">\(\mathrm{rad}(R)\)</span>是双边理想，且是幂零的。如果 <span class="math inline">\(\mathrm{rad}(R)=0\)</span>，即 <span class="math inline">\(R\)</span> 不含任何非零的幂零左理想，就称 <span class="math inline">\(R\)</span> 是<strong>半单</strong>的。</p></div><p>不难验证环 <span class="math inline">\(R/\mathrm{rad}(R)\)</span>不含非零的幂零左理想，从而它符合我们对半单性的定义。下面的任务就是对半单环进行讨论。</p><p><a href="#idempotent" title="引理 2.4">引理 2.4</a>有一个简单的推论，后面会用到。我把它写在这里：</p><div id="L-proj" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.6</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(R\)</span> 是半单左 Artinian 环，<span class="math inline">\(L\)</span> 是 <span class="math inline">\(R\)</span> 的极小左理想，<span class="math inline">\(e\in L\)</span> 是幂等元，则：</p><ol type="1"><li>对任何 <span class="math inline">\(R\)</span> 的左理想 <span class="math inline">\(I\supset L\)</span> 都有 <span class="math inline">\(Ie=L\)</span>。</li><li>对任何 <span class="math inline">\(x\in L\)</span> 有 <span class="math inline">\(xe=x\)</span>。</li></ol></div><p>这里 <span class="math inline">\(e\)</span> 的存在性由 <span class="math inline">\(R\)</span> 半单以及 <a href="#idempotent" title="引理 2.4">引理 2.4</a> 保证。这个结论的含义是，对 <span class="math inline">\(x\in R\)</span>，右乘 <span class="math inline">\(x\mapsto xe\)</span> 将 <span class="math inline">\(x\)</span> 投影到 <span class="math inline">\(L\)</span> 中。特别地，这个投影保持 <span class="math inline">\(L\)</span> 中的元素不动。</p><p><strong>证明</strong>：</p><ol type="1"><li>显然 <span class="math inline">\(Ie\subset L\)</span>，并且 <span class="math inline">\(e=e\cdot e\in Ie\)</span>，所以 <span class="math inline">\(Ie\ne (0)\)</span>，于是由 <span class="math inline">\(L\)</span> 是极小左理想可得 <span class="math inline">\(Ie=L\)</span>。</li><li>取 <span class="math inline">\(I=R\)</span> 即得 <span class="math inline">\(L=Re\)</span>，即 <span class="math inline">\(L\)</span> 中的任何元素 <span class="math inline">\(x\)</span> 都形如 <span class="math inline">\(x=ae,\,a\in R\)</span>。于是 <span class="math inline">\(xe=ae^2=ae=x\)</span>。<span class="math inline">\(\blacksquare\)</span></li></ol><h1 id="将半单环分解为单环的直和">将半单环分解为单环的直和</h1><p>我们将证明半单环总是可以分解为一些单环的直和（单环的含义后面会介绍），而且这种分解还是唯一的。如果用整数分解为素数乘积来类比的话，极小左理想相当于单个素因子，单环相当于某个素因子的幂。</p><p>我们首先来证明半单环的极小左理想具有直和补性质。首先是一个引理：</p><div id="ideal-decomp" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(R\)</span> 是半单环，<span class="math inline">\(L\subset I\)</span> 都是 <span class="math inline">\(R\)</span> 的左理想并且 <span class="math inline">\(L\)</span> 还是极小左理想，则存在 <span class="math inline">\(R\)</span> 的左理想 <span class="math inline">\(J\)</span> 满足 <span class="math inline">\(I=L\oplus J\)</span>。</p></div><p><strong>证明</strong>： 根据 <a href="#L-proj" title="推论 2.6">推论2.6</a>，设幂等元 <span class="math inline">\(e\in L\)</span> 满足 <span class="math inline">\(I=Le\)</span>。考虑 <span class="math inline">\(J=I(1-e)\)</span>，这也是一个包含在 <span class="math inline">\(I\)</span> 中的左理想。显然 <span class="math display">\[I=Ie\oplus I(1-e)=L\oplus J.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div id="decompose-minimal" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.2</span>.</span><span class="statement-spah"> </span>半单环 <span class="math inline">\(R\)</span> 一定可以分解为有限个极小左理想的直和<span class="math inline">\(R=L_1\oplus\cdots\oplus L_n\)</span>。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(L_1\)</span> 是<span class="math inline">\(R\)</span> 的任一极小左理想，在 <a href="#ideal-decomp" title="引理 3.1">引理 3.1</a> 中取 <span class="math inline">\(L=L_1,I=R\)</span> 可得存在 <span class="math inline">\(R\)</span> 的左理想 <span class="math inline">\(J\)</span> 使得 <span class="math inline">\(R=L_1\oplus J\)</span>。如果 <span class="math inline">\(J\)</span> 非零，则它包含 <span class="math inline">\(R\)</span> 的某个极小左理想 <span class="math inline">\(L_2\)</span>。根据 <a href="#ideal-decomp" title="引理 3.1">引理 3.1</a> <span class="math inline">\(J\)</span>可以进一步分解为 <span class="math inline">\(J=L_2\oplusK\)</span>。其中 <span class="math inline">\(K\)</span> 也是 <span class="math inline">\(R\)</span> 的左理想。这样继续分解下去，由于左Artinian 条件这样的分解只能进行有限多次，于是 <span class="math display">\[R=L_1\oplus J =L_1\oplus L_2\oplus K = \cdots =L_1\oplus L_2\oplus\cdots\oplus L_n.\]</span> <span class="math inline">\(\blacksquare\)</span></p><p>我们接下来要把 <span class="math inline">\(R=\oplus_{i=1}^nL_i\)</span> 中所有同构于某个<span class="math inline">\(L_i\)</span>的极小左理想合起来，形成一个单环。这类似于在整数的素因子分解中把相同的素数的乘积合起来得到单一素因子的幂。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义3.3</span>.</span><span class="statement-spah"></span>如果两个极小左理想 <span class="math inline">\(L,L'\)</span>作为左 <span class="math inline">\(R-\)</span>模是同构的，就称它们是同构的，记作 <span class="math inline">\(L\congL'\)</span>。</p></div><p>我们先来说明极小左理想具有某种「正交性」：</p><div id="two-left-ideals" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.4</span>.</span><span class="statement-spah"> </span>两个极小左理想<span class="math inline">\(L\cong L'\)</span> 当且仅当 <span class="math inline">\(L'L\ne0\)</span>。特别地这个同构可以由右乘一个元素<span class="math inline">\(a\in L\)</span> 给出：<span class="math inline">\(L'=La\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(L'L\subset L\)</span>，它只能是 <span class="math inline">\((0)\)</span> 或者 <span class="math inline">\(L\)</span>，所以陈述 <span class="math inline">\(L'L\ne0\)</span> 等价于 <span class="math inline">\(L'L=L\)</span>。于是我们只要证明以下三点是等价的即可：</p><div class="statement simple plain unnumbered"><ol type="1"><li><span class="math inline">\(L\cong L'\)</span>。</li><li>存在 <span class="math inline">\(a\in L\)</span> 使得 <span class="math inline">\(L=L'a\)</span>。</li><li><span class="math inline">\(L'L = L\)</span>。</li></ol></div><p><span class="math inline">\(1\Rightarrow 2\)</span>： 设 <span class="math inline">\(\varphi: L\to L'\)</span> 是一个左 <span class="math inline">\(R-\)</span> 模同构，利用 <a href="#L-proj" title="推论 2.6">推论 2.6</a> 的结论，设 <span class="math inline">\(e\in L\)</span> 是幂等元，则对任何 <span class="math inline">\(x\in L\)</span> 都有 <span class="math inline">\(x=xe\)</span>，所以 <span class="math display">\[\varphi(x)=\varphi(xe)=x\varphi(e),\quad x\inL.\]</span> 即同构 <span class="math inline">\(\varphi\)</span> 由右乘<span class="math inline">\(a=\varphi(e)\)</span> 给出。</p><p><span class="math inline">\(2\Rightarrow 3\)</span>： 注意到 <span class="math inline">\(L'L\subset L\)</span> 和 <span class="math inline">\(L'L\supset L'a=L\)</span> 即可。</p><p><span class="math inline">\(3\Rightarrow 1\)</span>： 若 <span class="math inline">\(L'L=L\)</span>，则存在 <span class="math inline">\(a\in L\)</span> 使得 <span class="math inline">\(L'a\ne0\)</span>，而 <span class="math inline">\((0)\ne L'a\subset L\)</span>，所以 <span class="math inline">\(L'a=L\)</span>，于是 <span class="math inline">\(y\to ya\)</span> 给出了从 <span class="math inline">\(L'\)</span> 到 <span class="math inline">\(L\)</span> 的一个左 <span class="math inline">\(R-\)</span> 模同构。<span class="math inline">\(\blacksquare\)</span></p><div id="left-ideal" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论3.5</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(R=\oplus_{i=1}^n L_i\)</span> 是上面所述的将 <span class="math inline">\(R\)</span> 分解极小左理想的直和，则 <span class="math inline">\(R\)</span> 的任何极小左理想必然同构于某个 <span class="math inline">\(L_i\)</span>。</p></div><p><strong>证明</strong>：对任何极小左理想 <span class="math inline">\(L\)</span> 有 <span class="math inline">\(L=\oplus_{i=1}^nLL_i\)</span>，所以必然存在某个<span class="math inline">\(i\)</span> 使得 <span class="math inline">\(LL_i\ne0\)</span>，从而根据 <a href="#two-left-ideals" title="引理 3.4">引理 3.4</a> 有 <span class="math inline">\(L\cong L_i\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>对 <span class="math inline">\(R\)</span> 的任一极小左理想 <span class="math inline">\(L\)</span>，记 <span class="math inline">\(B_L\)</span> 为 <span class="math inline">\(R\)</span> 的所有同构于 <span class="math inline">\(L\)</span> 的极小左理想的和。我们来分析 <span class="math inline">\(B_L\)</span> 具有哪些性质。</p><div id="Bi-orth" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.6</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B_LB_{L'}\ne 0\)</span> 当且仅当 <span class="math inline">\(L\cong L'\)</span>。</p></div><p><strong>证明</strong>：由 <a href="#two-left-ideals" title="引理 3.4">引理 3.4</a> 这是显然的。<span class="math inline">\(\blacksquare\)</span></p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.7</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B_L\)</span> 是双边理想。</p></div><p><strong>证明</strong>：记 <span class="math inline">\(R =\oplus_{i=1}^nL_i\)</span> 为极小左理想的直和，于是 <span class="math inline">\(B_LR=\oplus_{i=1}^nB_LL_i\)</span>。右边每个 <span class="math inline">\(B_LL_i\)</span> 要么是 <span class="math inline">\((0)\)</span> (<span class="math inline">\(L_i\ncong L\)</span>)，要么等于 <span class="math inline">\(L_i\)</span> (<span class="math inline">\(L_i\congL\)</span>) 从而属于 <span class="math inline">\(B_L\)</span>，所以<span class="math inline">\(B_LR\subset B_L\)</span>，即 <span class="math inline">\(B_L\)</span> 是双边理想。<span class="math inline">\(\blacksquare\)</span></p><p>为简便以下记 <span class="math inline">\(B_i = B_{L_i}\)</span>。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.8</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B_L\)</span> 也有乘法单位元 （与 <span class="math inline">\(R\)</span> 的单位元未必相同）。</p></div><p><strong>证明</strong>：不妨设在 <span class="math inline">\(R =\oplus_{i=1}^nL_i\)</span> 中，<span class="math inline">\(\{L_1,\ldots,L_m\}\)</span> 是互不同构的，<span class="math inline">\(\{L_{m+1},\ldots, L_n\}\)</span> 中的任何一个都与<span class="math inline">\(\{L_1,\ldots, L_m\}\)</span>中的某一个同构，则 <span class="math inline">\(R=B_1+\cdots+B_m\)</span>。于是环 <span class="math inline">\(R\)</span> 的单位元可以表示为 <span class="math display">\[1 = e_1+\cdots + e_m,\quad e_i\in B_i.\]</span>对任何 <span class="math inline">\(x\in B_i\)</span>，利用 <span class="math inline">\(i\ne j\)</span> 时 <span class="math inline">\(B_iB_j=0\)</span> 有 <span class="math display">\[x=1\cdot x = e_1x+\cdots+e_mx = e_ix.\]</span> 同理也有 <span class="math inline">\(x=xe_i\)</span>。从而<span class="math inline">\(e_i\)</span> 是 <span class="math inline">\(B_i\)</span> 的乘法单位元。</p><p>根据 <a href="#left-ideal" title="推论 3.5">推论 3.5</a> 任何 <span class="math inline">\(B_L\)</span> 必然等于 <span class="math inline">\(\{B_1,\ldots,B_m\}\)</span>之一，所以也是有单位元的。<span class="math inline">\(\blacksquare\)</span></p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.9</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B_L\)</span> 也满足左理想的 DCC 降链条件。</p></div><p><strong>证明</strong>：只要说明 <span class="math inline">\(B_{L}\)</span> 的左理想 <span class="math inline">\(I\)</span> 也是 <span class="math inline">\(R\)</span> 的左理想即可：由于 <span class="math inline">\(e\)</span> 是 <span class="math inline">\(B_{L}\)</span> 的乘法单位元所以 <span class="math inline">\(I=eI\)</span>，于是 <span class="math inline">\(RI=ReI\subset B_{L}I\subset I\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>与这个引理的证明类似，我们可以得出 <span class="math inline">\(B_L\)</span> 的右理想 <span class="math inline">\(I\)</span> 也是 <span class="math inline">\(R\)</span> 的右理想。特别地 <span class="math inline">\(B_L\)</span> 的双边理想也是 <span class="math inline">\(R\)</span> 的双边理想。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.10</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B_L\)</span> 除了 (0)和自身外不含其它双边理想。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(D\)</span> 是<span class="math inline">\(B_L\)</span> 的非零双边理想，则 <span class="math inline">\(D\)</span> 也是 <span class="math inline">\(R\)</span> 的双边理想，从而其包含 <span class="math inline">\(R\)</span> 的某个极小左理想 <span class="math inline">\(L_1\)</span>，即<span class="math display">\[L_1\subset D \subset B_L.\]</span>由于 <span class="math inline">\(L_1B_L\supset L_1^2\ne0\)</span> 所以 <span class="math inline">\(L_1\cong L\)</span>。</p><p>由于对任意的 <span class="math inline">\(a\in R\)</span> 都有 <span class="math inline">\(L_1a\subset D\)</span>，根据 <a href="#two-left-ideals" title="引理 3.4">引理 3.4</a>，这些 <span class="math inline">\(L_1a\)</span> 跑遍所有与 <span class="math inline">\(L_1\)</span> 同构的极小左理想，从而 <span class="math inline">\(B_L\subset D\)</span>，于是 <span class="math inline">\(B_L=D\)</span>，即 <span class="math inline">\(B_L\)</span> 不含非平凡的双边理想。<span class="math inline">\(\blacksquare\)</span></p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.11</span>.</span><span class="statement-spah"> </span><span class="math inline">\(R = B_1\oplus\cdots\oplus B_m\)</span>。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(x_i\inB_i\)</span> 满足 <span class="math inline">\(x_1+\cdots+x_m=0\)</span>，两边同时乘以 <span class="math inline">\(B_i\)</span> 的单位元 <span class="math inline">\(e_i\)</span> 并利用 <a href="#Bi-orth" title="引理 3.6">引理 3.6</a> 可得 <span class="math inline">\(x_i=0\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.12</span>.</span><span class="statement-spah"> </span><span class="math inline">\(R\)</span> 的任何双边理想 <span class="math inline">\(I\)</span> 都可以表示为若干 <span class="math inline">\(B_i\)</span> 的直和。</p></div><p><strong>证明</strong>：由 <span class="math inline">\(R=\oplus_{i=1}^mB_i\)</span> 有 <span class="math inline">\(I=\oplus_{i=1}^m IB_i\)</span>。每个 <span class="math inline">\(IB_i\)</span> 都是 <span class="math inline">\(B_i\)</span> 中的双边理想，而我们已经证明了 <span class="math inline">\(B_i\)</span> 没有非平凡的双边理想，所以每个 <span class="math inline">\(IB_i\)</span> 要么等于 <span class="math inline">\(B_i\)</span>，要么等于 <span class="math inline">\((0)\)</span>，从而 <span class="math inline">\(I\)</span> 是一些 <span class="math inline">\(B_i\)</span> 的直和。<span class="math inline">\(\blacksquare\)</span></p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义3.13</span>.</span><span class="statement-spah"> </span>如果左 Artinian环 <span class="math inline">\(R\)</span> 除了 <span class="math inline">\((0)\)</span> 和自身外不含有其它的双边理想，就称<span class="math inline">\(R\)</span> 是<strong>单环</strong>。</p></div><p>显然单环的根都是 <span class="math inline">\((0)\)</span>，所以也是半单的。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.14</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(R\)</span> 是单环，则在同构意义下只有一种不可约左<span class="math inline">\(R-\)</span> 模，即 <span class="math inline">\(R\)</span> 的某个极小左理想。</p></div><p><strong>证明</strong>：显然 <span class="math inline">\(R\)</span>的所有极小左理想都是互相同构的。设 <span class="math inline">\(M\)</span> 是任一不可约左 <span class="math inline">\(R-\)</span> 模，则 <span class="math inline">\(R\)</span> 的某个极小左理想 <span class="math inline">\(L\)</span> 满足 <span class="math inline">\(LM\ne0\)</span>，从而存在 <span class="math inline">\(m\in M\)</span> 满足<span class="math inline">\(Lm\ne 0\)</span>，从而 <span class="math inline">\(Lm=M\)</span>。<span class="math inline">\(\phi\colon\ x\mapsto xm\)</span> 给出了 <span class="math inline">\(L\)</span> 到 <span class="math inline">\(M\)</span> 的 <span class="math inline">\(R-\)</span> 模同构。<span class="math inline">\(\blacksquare\)</span></p><p>至此我们已经把半单环 <span class="math inline">\(R\)</span>分解为了单环的直和： <span class="math display">\[R =B_1\oplus\cdots\oplus B_m.\]</span> 实际上这个分解还是唯一的，即若 <span class="math display">\[R = B'_1\oplus\cdots\oplus B'_l.\]</span>其中每个 <span class="math inline">\(B'_j\)</span> 是单环，并且是<span class="math inline">\(R\)</span> 的双边理想，则 <span class="math inline">\(m=l\)</span> 且适当重排以后有 <span class="math inline">\(B_i=B'_j\)</span>。（证明简单，略）</p><h1 id="单环的结构定理">单环的结构定理</h1><p>最终我们来到了单环的结构定理。在本节中，我们用 <span class="math inline">\(A\)</span> 来表示单环，以便与前面的半单环 <span class="math inline">\(R\)</span> 区分。</p><div id="w-a" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.1</span> <span class="statement-info">(Wedderburn-Artin)</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span>是单环，则存在除环 <span class="math inline">\(D\)</span> 使得 <span class="math inline">\(A\cong {\rm Mat}_n(D)\)</span>，这里 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(D\)</span> 由 <span class="math inline">\(A\)</span> 唯一确定。</p></div><p>我们先来验证 <span class="math inline">\({\rm Mat}_n(D)\)</span>是单环。记 <span class="math inline">\(e_{ij}\in {\rm Mat}_n(D)\)</span>是第 <span class="math inline">\((i,j)\)</span> 个分量为 1，其余位置都是0 的初等矩阵。</p><ol type="1"><li>恒等矩阵 <span class="math inline">\(I_n\)</span>是乘法单位元。</li><li><span class="math inline">\({\rm Mat}_n(D)\)</span>可以分解为极小左理想的直和 <span class="math display">\[{\rmMat}_n(D)={\rm Mat}_n(D)e_{11}\oplus\cdots {\rmMat}_n(D)e_{nn}.\]</span> 其中 <span class="math inline">\(\{e_{ii},\,1\leq i\leq n\}\)</span>是仅在对角线上第 <span class="math inline">\(i\)</span> 个元素为1，其余所有元素都为 0的矩阵，它们构成一组互相正交的幂等元，其和为单位矩阵。左理想 <span class="math inline">\(L_i={\rm Mat}_n(D)e_{ii}\)</span> 中的矩阵除了第<span class="math inline">\(i\)</span> 列以外，其余的列都是 0。<span class="math inline">\(L_i\)</span>是极小左理想是因为，对任何两个非零元素 <span class="math inline">\(x,y\in L_i\)</span>，我们总可以用初等行变换将<span class="math inline">\(x\)</span> 变成 <span class="math inline">\(y\)</span>，而初等行变换就是左乘一个 <span class="math inline">\({\rm Mat}_n(D)\)</span> 中的矩阵，所以任何非零元<span class="math inline">\(x\)</span> 都可以在 <span class="math inline">\({\rm Mat}_n(D)\)</span> 的左乘作用下生成整个 <span class="math inline">\(L_i\)</span>，所以 <span class="math inline">\(L_i\)</span> 确实是极小左理想。</li><li>这些极小左理想 <span class="math inline">\(L_i\,(1\leq i\leqn)\)</span> 是互相同构的。为此只要说明 <span class="math display">\[L_iL_j={\rm Mat}_n(D)e_{ii}\cdot {\rmMat}_n(D)e_{jj}\]</span> 不为 0 即可，而这个乘积包含 <span class="math inline">\(e_{ii}e_{ij}e_{jj}=e_{ij}\)</span>，当然不是0。</li></ol><p>下面回到 <a href="#w-a" title="定理 4.1">定理 4.1</a> 的证明。</p><p>大多数文献上对这一步的处理方式都是证明单环 <span class="math inline">\(A\)</span>和它的不可约模满足所谓的双重中心化子性质。我们先介绍大致的思路：</p><p>设 <span class="math inline">\(M\)</span> 是一个左 <span class="math inline">\(A-\)</span> 模，则 <span class="math inline">\(A\)</span> 在 <span class="math inline">\(M\)</span> 上的左乘给出了 <span class="math inline">\(A\to {\rm End}(M)\)</span> 的一个环同态，记 <span class="math inline">\(A\)</span> 在 <span class="math inline">\({\rmEnd}(M)\)</span> 中的同态像为 <span class="math inline">\(A_L\)</span>。由于 <span class="math inline">\(A\)</span> 是单环所以 <span class="math inline">\(A\cong A_L\)</span>。</p><p>记 <span class="math inline">\(D={\rm Hom}_A(M,M)\)</span> 为 <span class="math inline">\(M\)</span> 的 <span class="math inline">\(A-\)</span> 模自同态。<span class="math inline">\(D\)</span> 正是 <span class="math inline">\(A_L\)</span> 在 <span class="math inline">\({\rmEnd}(M)\)</span> 中的中心化子： <span class="math display">\[(am)d =a(md),\quad a\in A_L,\,m\in M,\,d\in D.\]</span> 值得注意的是，我们把<span class="math inline">\(A_L\)</span>的作用写在左边（这就是为什么用了 <span class="math inline">\(L\)</span>作为下标），<span class="math inline">\(D\)</span> 在 <span class="math inline">\(M\)</span> 上的作用写在右边：对任何 <span class="math inline">\(d\in D\)</span>，<span class="math inline">\(d\)</span> 在 <span class="math inline">\(M\)</span> 上的作用为 <span class="math inline">\(m\to md\)</span>。把 <span class="math inline">\(D\)</span>的作用写在右边有两个好处：一是可以避免后面在矩阵中使用讨厌的反环记号 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，二是这样一来 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(D\)</span> 交换就等价于说 <span class="math inline">\(M\)</span> 是一个 <span class="math inline">\((A,D)-\)</span> 双模。</p><p>进一步记 <span class="math inline">\(E={\rm Hom}_D(M,M)\)</span> 为<span class="math inline">\(D\)</span> 在 <span class="math inline">\({\rm End}(M)\)</span> 中的中心化子，<span class="math inline">\(E\)</span> 在 <span class="math inline">\(M\)</span> 上的作用写在左边。即 <span class="math inline">\(E\)</span> 由所有满足 <span class="math display">\[(fm)d = f(md),\quad f\in {\rm End}(M),\,m\inM,\,d\in D.\]</span> 的自同态 <span class="math inline">\(f\)</span>组成。显然 <span class="math inline">\(E\)</span> 是由 <span class="math inline">\(A_L\)</span> 在 <span class="math inline">\({\rmEnd}(M)\)</span> 中连续取两次中心化子得到的，且 <span class="math inline">\(A_L\subseteq E\)</span>。特别地，如果 <span class="math inline">\(A_L=E\)</span> 我们就称 <span class="math inline">\((A,M)\)</span>具有<strong>双重中心化子性质</strong>。</p><p>设 <span class="math inline">\(M\)</span> 是 <span class="math inline">\(A\)</span> 的一个极小左理想，从而 <span class="math inline">\(M\)</span> 也是不可约左 <span class="math inline">\(A-\)</span> 模。我们希望证明 <span class="math inline">\((A,M)\)</span> 具有双重中心化子性质。这时 <span class="math inline">\(D={\rm Hom}_A(M,M)\)</span> 是除环，<span class="math inline">\(M\)</span> 作为右 <span class="math inline">\(D-\)</span> 模是除环 <span class="math inline">\(D\)</span> 上的右向量空间。若 <span class="math inline">\((A,M)\)</span> 具有双重中心化子性质则 <span class="math inline">\(A\cong A_L\cong {\rm Hom}_D(M,M)\)</span>，即<span class="math inline">\(A\)</span> 同构于除环 <span class="math inline">\(D\)</span> 上的右向量空间 <span class="math inline">\(M\)</span> 上的所有 <span class="math inline">\(D-\)</span> 线性变换构成的环。特别地如果维数 <span class="math inline">\(\dim_D  M=n&lt;\infty\)</span>，则 <span class="math inline">\(A\cong {\rm Mat}_n(D)\)</span>，这就证明了Wedderburn-Artin 定理。</p><p>于是我们的思路就是先证明 <span class="math inline">\((A, M)\)</span>具有双重中心化子性质，再证明 <span class="math inline">\(\dim_DM&lt;\infty\)</span>。</p><p>注意到对左正则模 <span class="math inline">\(_AA\)</span> ，<span class="math inline">\((A, \,_AA)\)</span>是具有双重中心化子性质的。事实上很容易验证 <span class="math inline">\(A\)</span> 在自身上的左乘 <span class="math inline">\(A_L\)</span> 和右乘 <span class="math inline">\(A_R\)</span> 互为对方在 <span class="math inline">\({\rm End}(A)\)</span> 中的中心化子，所以 <span class="math inline">\((A,\, _AA)\)</span> 是具有双重中心化子性质的。</p><p>当 <span class="math inline">\(A\)</span> 是单环时，左正则模 <span class="math inline">\(_AA\)</span> 同构于 <span class="math inline">\(A\)</span> 的某个极小左理想 <span class="math inline">\(L\)</span> 的若干重直和：<span class="math inline">\(_AA\cong\oplus_{i=1}^nL\)</span>，所以我们只要证明这样的结论就好了：</p><div id="A-M" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理4.2</span>.</span><span class="statement-spah"> </span>设左 <span class="math inline">\(A-\)</span> 模 <span class="math inline">\(V,M\)</span> 满足 <span class="math inline">\(V=\oplus_{i=1}^n M\)</span>。若 <span class="math inline">\((A, V)\)</span> 具有双重中心化子性质，则 <span class="math inline">\((A, M)\)</span> 也具有双重中心化子性质。</p></div><p>注意这个引理中 <span class="math inline">\(A\)</span>可以是任意的环，不仅限于单环；<span class="math inline">\(M\)</span>也是任意的左 <span class="math inline">\(A-\)</span>模，不仅限于不可约模。</p><p><strong>证明</strong>：对任何 <span class="math inline">\(f\in E={\rmHom}_D(M, M)\)</span>，将其提升为 <span class="math inline">\(V\)</span>的一个自同态 <span class="math display">\[f^\ast: (m_1,m_2,\ldots,m_n)\to (f(m_1), f(m_2), \ldots, f(m_n)).\]</span> 我们希望证明 <span class="math inline">\(f^\ast \in {\rm Hom}_{D^\ast}(V, V)\)</span>，其中<span class="math inline">\(D^\ast={\rm Hom}_A(V,V)\)</span>，这样利用已知 <span class="math inline">\((A, V)\)</span>具有双重中心化子性质，可得 <span class="math inline">\(f^\ast\)</span>来自某个 <span class="math inline">\(a\in A\)</span> 在 <span class="math inline">\(V\)</span> 上的左乘，即对任何 <span class="math inline">\((m_1,m_2,\ldots,m_n)\)</span> 有 <span class="math display">\[ f^\ast(m_1,m_2,\ldots, m_n)=  (am_1,am_2,\ldots,am_n).\]</span> 只看第一个分量即得对任何 <span class="math inline">\(m\in M\)</span> 有 <span class="math inline">\(f(m)=am\)</span>，这就证明了结论。</p><p>为此我们只要注意到 <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> （一个简单的练习，细节见脚注） <span class="math display">\[D^\ast={\rm Hom}_A(\oplus_{i=1}^nM,\oplus_{i=1}^nM)\cong {\rm Mat}_n({\rm Hom}_A(M, M)) = {\rmMat}_n(D).\]</span> 换言之任何 <span class="math inline">\(\varphi\inD^\ast\)</span> 都形如 <span class="math inline">\(\varphi=(d_{ij})_{1\leq i,j\leq n}\)</span>，其中<span class="math inline">\(d_{ij}\in D={\rmHom}_A(M,M)\)</span>，所以验证 <span class="math inline">\(f^\ast\in{\rmHom}_{D^\ast}(V, V)\)</span> 变成了验证一串矩阵等式： <span class="math display">\[\begin{align*}(f^\ast(m_1,\ldots,m_n))\varphi&amp;=(f(m_1),\ldots,f(m_n))\varphi\\&amp;=(f(m_1),\ldots,f(m_n))\begin{pmatrix}d_{11}&amp;\cdots&amp;d_{1n}\\\vdots&amp;\ddots&amp;\vdots\\d_{n1}&amp;\cdots&amp;d_{nn}\end{pmatrix}\\&amp;=\left(\sum_{i=1}^nf(m_i)d_{i1},\ldots,\sum_{i=1}^nf(m_i)d_{in}\right)\\&amp;=\left(f(\sum_{i=1}^nm_id_{i1}),\ldots,f(\sum_{i=1}^nm_id_{in})\right)\\&amp;=f^\ast\left(\sum_{i=1}^nm_id_{i1},\ldots,\sum_{i=1}^nm_id_{in}\right)\\&amp;=f^\ast((m_1,\ldots,m_n)\varphi)\end{align*}\]</span></p><p>即 <span class="math inline">\(f^\ast \in {\rm Hom}_{D^\ast}(V,V)\)</span>，<a href="#A-M" title="引理 4.2">引理 4.2</a> 得证。<span class="math inline">\(\blacksquare\)</span></p><p>这样我们就证明了单环具有双重中心化子性质。我把结论明确写下来：</p><div id="double-centralizer" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是单环，<span class="math inline">\(M\)</span> 是不可约左 <span class="math inline">\(A-\)</span> 模。将除环 <span class="math inline">\(D={\rm Hom}_A(M,M)\)</span> 的作用写在 <span class="math inline">\(M\)</span> 右边，则 <span class="math inline">\(A\cong {\rm Hom}_D(M,M)\)</span>。特别地 <span class="math inline">\({\rm Hom}_D(M,M)\)</span> 也是单环。</p></div><p>我们还需要证明 <span class="math inline">\(\dim_DM&lt;\infty\)</span>。由于我们在 <a href="#double-centralizer" title="命题 4.3">命题 4.3</a> 中证明了 <span class="math inline">\({\rmHom}_D(M,M)\)</span> 是单环，所以 <span class="math inline">\(\dim_DM&lt;\infty\)</span> 的结论立刻可以由下面的命题得出：</p><div id="dim-D-finite" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(M\)</span> 是除环 <span class="math inline">\(D\)</span> 上的右向量空间，则 <span class="math inline">\(\dim_D M&lt;\infty\)</span> 当且仅当 <span class="math inline">\({\rm Hom}_D(M,M)\)</span> 是单环。</p></div><p><strong>证明</strong>：<span class="math inline">\(\Rightarrow\)</span>说的是除环上的矩阵环都是单环，这一点在前面已经讨论过了。只要再证明 <span class="math inline">\(\Leftarrow\)</span>。用反证法，如果 <span class="math inline">\(\dim_D M=\infty\)</span>，考虑 <span class="math inline">\({\rm Hom}_D(M,M)\)</span> 的子集 <span class="math display">\[I = \{ f\in {\rm Hom}_D(M,M) \mid \dim_D  {\rmim}(f) &lt;\infty\}.\]</span> 我们来验证 <span class="math inline">\(I\)</span> 是 <span class="math inline">\({\rmHom}_D(M,M)\)</span> 中非平凡的双边理想。</p><ol type="1"><li>由于 <span class="math inline">\(\dim_DM=\infty\)</span>，所以恒等映射不包含在 <span class="math inline">\(I\)</span> 中，所以 <span class="math inline">\(I\ne {\rm Hom}_D(M,M)\)</span>。</li><li>由于 <span class="math inline">\({\rm im}(f_1+f_2)\subset {\rmim}(f_1)+{\rm im}(f_2)\)</span>，所以 <span class="math inline">\(I\)</span> 对加法是封闭的。</li><li>设 <span class="math inline">\(f\in I,\,g\in {\rmHom}_D(M,M)\)</span>，则不难验证 <span class="math inline">\({\rmim}(fg)\)</span> 和 <span class="math inline">\({\rm im}(gf)\)</span>都是有限维的。</li><li><span class="math inline">\(I\ne(0)\)</span>。为此只要取 <span class="math inline">\(M\)</span> 的一组 <span class="math inline">\(D-\)</span> 基 <span class="math inline">\(\{e_\alpha\}\)</span>，并固定某个基元素 <span class="math inline">\(e_\beta\)</span>，规定 <span class="math display">\[f\colon\ \sum e_\alpha d_\alpha\mapsto e_\betad_\beta .\]</span> 即 <span class="math inline">\(f\)</span> 是到 <span class="math inline">\(e_\beta\)</span> 生成的一维子空间的投影。<span class="math inline">\(f\in I\)</span> 并且 <span class="math inline">\(f(e_\beta)=e_\beta\)</span> 不是零映射。</li></ol><p><span class="math inline">\(\blacksquare\)</span></p><p>最后我们来说明 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(D\)</span> 是唯一确定的，即若 <span class="math inline">\(n'\)</span> 和 <span class="math inline">\(D'\)</span> 使得 <span class="math inline">\(A\cong {\rm Mat}_n(D)\cong {\rmMat}_{n'}(D')\)</span>，则 <span class="math inline">\(n=n'\)</span> 且 <span class="math inline">\(D\cong D'\)</span>。从上面的证明中我们已经看到<span class="math inline">\(n\)</span> 是 <span class="math inline">\(A\)</span> 分解为极小左理想 <span class="math inline">\(M\)</span> 直和的重数，从而是唯一确定的。而除环<span class="math inline">\(D={\rm Hom}_A(M,M)\)</span>是其唯一不可约模的 <span class="math inline">\(A-\)</span>自同态环，所以也是唯一确定的。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-curtis-reiner" class="csl-entry" role="listitem">Curtis, C.W., and I. Reiner. 1962. <em>Representation Theory of FiniteGroups and Associative Algebras</em>. New York: Interscience Publishers,a division of John Wiley &amp; Sons.</div><div id="ref-herstein-rings" class="csl-entry" role="listitem">Herstein, I. N. 1994. <em>Noncommutative Rings</em>. Vol. 15. CarusMathematical Monographs. Mathematical Association of America,Washington, DC.</div><div id="ref-Lam01" class="csl-entry" role="listitem">Lam, T. Y. 2001. <em>A First Course in Noncommutative Rings</em>. Secondedition. Vol. 131. Graduate Texts in Mathematics. Springer-Verlag, NewYork.</div></div><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>除环上的向量空间与域上的向量空间的一个显著不同是：如果<span class="math inline">\(V\)</span> 是一个左 <span class="math inline">\(D-\)</span> 向量空间且 <span class="math inline">\(\dim _DV=n\)</span>，则其 <span class="math inline">\(D-\)</span> 自同态环 <span class="math inline">\({\rm End}_D(V)\cong {\rm Mat}_n(D^{\rmop})\)</span>，这里 <span class="math inline">\(D^{\rm op}\)</span> 是<span class="math inline">\(D\)</span> 的反环。但是如果 <span class="math inline">\(V\)</span> 是右 <span class="math inline">\(D-\)</span> 向量空间，并且把 <span class="math inline">\({\rm End}_D(V)\)</span> 在 <span class="math inline">\(V\)</span> 上的作用写在左边的话（即把 <span class="math inline">\(V\)</span> 看作是 <span class="math inline">\(({\rm End}_D(V), D)-\)</span> 双模），则 <span class="math inline">\({\rm End}_D(V)\cong {\rm Mat}_n(D)\)</span>。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>记 <span class="math inline">\(i_k\)</span> 是从 <span class="math inline">\(M\)</span> 到 <span class="math inline">\(\oplus_{i=1}^nM\)</span> 的第 <span class="math inline">\(k\)</span> 个分量的嵌入映射： <span class="math display">\[i_k: m\to(0, 0,\ldots, m,\ldots, 0).\]</span><span class="math inline">\(\pi_l\)</span> 是从 <span class="math inline">\(\oplus_{i=1}^nM\)</span> 的第 <span class="math inline">\(l\)</span> 个分量到 <span class="math inline">\(M\)</span> 的投影： <span class="math display">\[\pi_l: (m_1,\ldots,m_l,\ldots, m_n) \tom_l.\]</span> 对任何 <span class="math inline">\(\varphi\in {\rmHom}_A(\oplus_{i=1}^nM,\oplus_{i=1}^nM)\)</span>，<span class="math inline">\((m_1,\ldots,m_n)\varphi\)</span> 的第 <span class="math inline">\(j\)</span> 个分量当然就是 <span class="math inline">\((m_1,\ldots,m_n)\varphi\circ\pi_j\)</span>。进一步把左边的<span class="math inline">\((m_1,\ldots,m_n)\)</span> 拆成求和有 <span class="math display">\[(m_1,\ldots,m_n)\varphi\circ\pi_j=\left(\sum_{i=1}^nm_i\circi_i\right)\varphi\circ\pi_j=\sum_{i=1}^nm_i(i_i\circ\varphi\circ\pi_j)=\sum_{i=1}^nm_i\varphi_{ij}.\]</span>其中 <span class="math inline">\(\varphi_{ij}=i_i\circ\varphi\circ\pi_j\in{\rmHom}_A(M,M)\)</span>，注意 <span class="math inline">\(\varphi_{ij}\)</span> 是写在 <span class="math inline">\(m\)</span> 右边的，<span class="math inline">\(i_i\)</span> 先作用，其次是 <span class="math inline">\(\varphi\)</span>，最后是 <span class="math inline">\(\pi_j\)</span>。 这告诉我们 <span class="math inline">\((m_1,\ldots,m_n)\varphi\)</span> 的第 <span class="math inline">\(j\)</span> 个分量等于 <span class="math inline">\(\sum_{i=1}^nm_i\varphi_{ij}\)</span>，即下面的矩阵乘法等式成立：<span class="math display">\[(m_1,\ldots,m_n)\varphi=(m_1,\ldots,m_n)\begin{pmatrix}\varphi_{11}&amp;\cdots&amp;\varphi_{1n}\\\vdots&amp;\ddots&amp;\vdots\\\varphi_{n1}&amp;\cdots&amp;\varphi_{nn}\end{pmatrix}.\]</span>不难验证 <span class="math inline">\(\varphi\to(\varphi_{ij})\)</span>是一个从 <span class="math inline">\({\rmHom}_A(\oplus_{i=1}^nM,\oplus_{i=1}^nM)\)</span> 到 <span class="math inline">\({\rm Mat}_n(D)\)</span> 的同构。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 有限群表示与结合代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中心单代数的三个基本结论</title>
      <link href="central-simple-algebra/"/>
      <url>central-simple-algebra/</url>
      
        <content type="html"><![CDATA[<p>本文来自我在讨论班上的一个两小时左右的报告，目的是介绍中心单代数的三个基本结论：</p><ol type="1"><li>中心单代数对张量积运算是封闭的。</li><li>Noether-Skolem 定理。</li><li>双重中心化子定理。</li></ol><p>这部分内容比较经典，在很多教材上都有，但是采用的讲述方式却很不一样，找到一个完全符合自己口味的讲解不是件容易的事情。尤其是对初学者而言，有些名气很大的教材反而不见得适合。我当初念<span class="citation" data-cites="Jacobson_alg">Jacobson (<a href="#ref-Jacobson_alg" role="doc-biblioref">1980</a>)</span>就念的很抓狂。后来我查阅了不少教材后经过提炼整理得到了本文。我个人认为这是最直接清楚的证明方式。</p><span id="more"></span><h1 id="中心单代数对张量积运算是封闭的">中心单代数对张量积运算是封闭的</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的一个有限维的结合代数，有乘法单位元<span class="math inline">\(\rm 1\)</span>。如果 <span class="math inline">\(A\)</span> 除了 <span class="math inline">\((0)\)</span> 和自身以外不含有其它的双边理想，就称<span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的<strong>单代数</strong>；进一步如果<span class="math inline">\(A\)</span> 的中心 <span class="math inline">\(Z(A)=F\cdot{\rm 1}\cong F\)</span>，就称 <span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的<strong>中心单代数</strong>。</p></div><p>最基本也是最重要的中心单代数的例子就是矩阵代数 <span class="math inline">\({\rmMat}_n(F)\)</span>。在研究中心单代数的时候，一个有效的手段就是建立它和<span class="math inline">\({\rm Mat}_n(F)\)</span> 之间的同态。</p><p>中心单代数有个很好的性质，就是它们对张量积的运算是封闭的：</p><div id="A-otimes-B" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A,B\)</span> 是域 <span class="math inline">\(F\)</span> 上的两个中心单代数，则 <span class="math inline">\(A\otimes_F B\)</span> 也是中心单代数。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(\dimB=m\)</span>，取定 <span class="math inline">\(B\)</span> 的一组基 <span class="math inline">\(\{b_1,\ldots,b_m\}\)</span>，则 <span class="math inline">\(A\otimes B\)</span> 中的任何元素 <span class="math inline">\(x\)</span> 可以唯一地写成 <span class="math display">\[x= a_1\otimes b_1+a_2\otimesb_2+\cdots+a_m\otimes b_m,\quad a_i\in A.\]</span> 当然这里的 <span class="math inline">\(a_i\)</span> 某些可以是 <span class="math inline">\(0\)</span>。我们称上面这个表达式中非零项的个数为<span class="math inline">\(x\)</span> 的长度。</p><p>设 <span class="math inline">\(I\)</span> 是 <span class="math inline">\(A\otimes B\)</span> 的任一非零理想，取 <span class="math inline">\(x\ne 0\)</span> 使得 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(I\)</span> 中所有非零元素中长度最小的，不妨假设<span class="math display">\[x= a_1\otimes b_1+a_2\otimesb_2+\cdots+a_r\otimes b_r,\quad 0&lt;r\leq m.\]</span> 这里每个 <span class="math inline">\(a_i\)</span> 都不是 <span class="math inline">\(0\)</span>，特别 <span class="math inline">\(a_1\ne0\)</span>。由于 <span class="math inline">\(A\)</span> 是单代数因此 <span class="math inline">\(A=Aa_1A\)</span> （即 <span class="math inline">\(a_1\)</span> 生成的双边理想），所以存在一组 <span class="math inline">\(\{c_j, d_j\mid 1\leq j\leq p\}\)</span> 满足 <span class="math display">\[1=\sum_{j=1}^p c_ja_1d_j.\]</span> 由于 <span class="math inline">\(I\)</span> 是双边理想因此每个 <span class="math display">\[(c_j\otimes 1)x(d_j\otimes 1)=(c_ja_1d_j)\otimesb_1+\cdots+(c_ja_rd_j)\otimes b_r\]</span> 都在 <span class="math inline">\(I\)</span> 中，当然它们的和也在 <span class="math inline">\(I\)</span> 中，设这个和为 <span class="math inline">\(x'\)</span>，则 <span class="math inline">\(x'\)</span> 与 <span class="math inline">\(x\)</span> 有同样的长度但是形如 <span class="math inline">\(x'=1\otimesb_1+\cdots\)</span>，<strong>所以我们不妨一开始就假设在 <span class="math inline">\(x\)</span> 的表达式中有 <span class="math inline">\(a_1=1\)</span></strong>。</p><p>任取 <span class="math inline">\(a\in A\)</span>，则 <span class="math display">\[(a\otimes 1)x -x(a\otimes1) =(aa_2-a_2a)\otimesb_2+\cdots+(aa_r-a_ra)\otimes b_r\in I.\]</span> 然而它的长度小于 <span class="math inline">\(r\)</span> 因此必须是 <span class="math inline">\(0\)</span>，即对每个 <span class="math inline">\(i=2,\ldots,r\)</span> 有 <span class="math inline">\(aa_i=a_ia\)</span>，由 <span class="math inline">\(a\)</span> 的任意性可知每个 <span class="math inline">\(a_i\)</span> 都属于 <span class="math inline">\(A\)</span> 的中心 <span class="math inline">\(Z(A)=F\)</span>，因此这些 <span class="math inline">\(a_i\)</span> 可以拿到 <span class="math inline">\(\otimes\)</span> 的右边去： <span class="math display">\[x=1\otimes b_1+\cdots+1\otimesa_rb_r=1\otimes(b_1+a_2b_2+\cdots+a_rb_r)\in I.\]</span> 注意由于 <span class="math inline">\(b_i\)</span> 是线性无关的所以 <span class="math inline">\(b=b_1+a_2b_2+\cdots+a_rb_r\ne0\)</span>。</p><p>总之我们证明了在 <span class="math inline">\(I\)</span>中存在一个形如 <span class="math inline">\(1\otimes b\)</span>的元素。</p><p>然后我们有 <span class="math display">\[I\supset (1\otimes B)1\otimesb(1\otimes B)=1\otimes BbB=1\otimes B,\]</span> 其中最后一个等号是因为<span class="math inline">\(B\)</span> 是单代数，从而 <span class="math inline">\(B\)</span> 等于元素 <span class="math inline">\(b\)</span> 生成的双边理想 <span class="math inline">\(BbB\)</span>。从而 <span class="math display">\[I\supset (A\otimes1)(1\otimes B)=A\otimesB,\]</span> 这就证明了 <span class="math inline">\(I=A\otimesB\)</span>，即 <span class="math inline">\(A\otimes B\)</span>是单代数。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在上面的证明中，我们只用到了 <span class="math inline">\(A\)</span> 是中心单代数和 <span class="math inline">\(B\)</span> 是单代数作为条件，即只要 <span class="math inline">\(A,B\)</span>中一个是单代数，另一个是中心单代数，则 <span class="math inline">\(A\otimes B\)</span> 就是单代数。这个结论对 <span class="math inline">\(A,B\)</span> 都是单代数的情形是不成立的，比如<span class="math inline">\(\mathbb{C}\)</span> 是 <span class="math inline">\(\mathbb{R}\)</span> 上的单代数但不是中心单的，这时<span class="math inline">\(\mathbb{C}\otimes_\mathbb{R}\mathbb{C}\cong\mathbb{C}\oplus\mathbb{C}\)</span> 就不是单代数。</p></div><p>证明 <span class="math inline">\(Z(A\otimes B)=F\)</span>也可以用同样的套路，不过我们想花点精力证明一个更一般的结论：</p><div id="C-otimes-D" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A,B\)</span> 是域 <span class="math inline">\(F\)</span> 上的代数，<span class="math inline">\(C\subset A\)</span> 和 <span class="math inline">\(D\subset B\)</span> 分别是子代数，则 <span class="math inline">\(C\otimes D\)</span> 在 <span class="math inline">\(A\otimes B\)</span> 中的中心化子是 <span class="math inline">\(C_{A\otimes B}(C\otimes D)=C_A(C)\otimesC_B(D)\)</span>。也就是分别取 <span class="math inline">\(C,D\)</span>在 <span class="math inline">\(A,B\)</span>里的中心化子，然后作张量积。</p></div><p>特别地取 <span class="math inline">\(C=A,D=B\)</span> 我们有 <span class="math inline">\(Z(A\otimes B)=Z(A)\otimes Z(B)\)</span>。</p><p>当 <span class="math inline">\(A,B\)</span>都是中心单代数时，由此引理 <span class="math inline">\(Z(A\otimesB)=Z(A)\otimes Z(B)=F\otimes F\cong F(1\otimes 1)\)</span> 即得 <a href="#A-otimes-B" title="定理 1.2">定理 1.2</a> 结论。</p><p><a href="#C-otimes-D" title="引理 1.3">引理 1.3</a> 的证明：首先<span class="math inline">\(C_{A\otimes B}(C\otimes D)\supseteqC_A(C)\otimes C_B(D)\)</span>是显然的，只要再证明反向的包含关系成立即可。</p><p>任何 <span class="math inline">\(z\in C_{A\otimes B}(C\otimesD)\)</span> 可以唯一地写成 <span class="math display">\[z= a_1\otimesb_1+a_2\otimes b_2+\cdots+a_m\otimes b_m.\]</span> 由于 <span class="math inline">\(z\)</span> 和 <span class="math inline">\(C\otimesD\)</span> 交换，当然也就和 <span class="math inline">\(C\otimes1\)</span> 交换，所以对任何 <span class="math inline">\(c\in C\)</span>有 <span class="math display">\[(c\otimes1)z-z(c\otimes1)=\sum_{i=1}^m(ca_i-a_ic)\otimesb_i=0.\]</span></p><p>由于 <span class="math inline">\(b_i\)</span> 是线性无关的，因此每个<span class="math inline">\(ca_i=a_ic\)</span>，由 <span class="math inline">\(c\)</span> 的任意性有 <span class="math inline">\(a_i\in C_A(C)\)</span>。进一步设 <span class="math inline">\(\{x_1,\ldots,x_r\}\)</span> 是 <span class="math inline">\(C_A(C)\)</span> 的一组基，再将每个 <span class="math inline">\(a_i\)</span> 表示为 <span class="math inline">\(\{x_1,\ldots,x_r\}\)</span> 的线性组合，我们得到<span class="math display">\[z=a_1\otimes b_1+a_2\otimesb_2+\cdots+a_m\otimes b_m=x_1\otimes b_1'+\cdots +x_rb_r'.\]</span> 其中每个 <span class="math inline">\(b_i'\inB\)</span>。进一步 <span class="math inline">\(z\)</span> 与任何形如<span class="math inline">\(1\otimes d,d\in D\)</span> 的元素交换，得到<span class="math display">\[(1\otimes d)z-z(1\otimesd)=\sum_{i=1}^rx_i\otimes (db_i'-b_i'd)=0.\]</span> 由于 <span class="math inline">\(x_1,\ldots,x_r\)</span> 是线性无关的，所以每个<span class="math inline">\(db_i'-b_i'd=0\)</span>，由 <span class="math inline">\(d\)</span> 的任意性可得 <span class="math inline">\(b_i'\in C_B(D)\)</span>，这就证明了任何 <span class="math inline">\(z\in C_{A\otimes B}(C\otimes D)\)</span>可以表示为 <span class="math display">\[z=x_1\otimes b_1'+\cdots +x_rb_r'\]</span> 的形式，其中每个 <span class="math inline">\(x_i\inC_A(B)\)</span>，每个 <span class="math inline">\(b_i'\inC_B(D)\)</span>，从而反向的包含得证。<span class="math inline">\(\blacksquare\)</span></p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的中心单代数，<span class="math inline">\(\dim_F A=n\)</span>，则 <span class="math inline">\(A\otimes A^{\rm op}\cong{\rmMat}_n(F)\)</span>。</p></div><p>背后的道理很简单：<span class="math inline">\(A\)</span> 显然是 <span class="math inline">\((A,A)\)</span>- 双模，从而是一个左 <span class="math inline">\(A\otimes A^{\rm op}\)</span>- 模（回忆一下，<span class="math inline">\((R,S)\)</span>- 双模与左 <span class="math inline">\(R\otimes S^{\rm op}\)</span>-模是一回事），即存在代数同态 <span class="math display">\[A\otimesA^{\rm op}\to \mathrm{End}_F(A).\]</span> （<span class="math inline">\(M\)</span> 是左 <span class="math inline">\(R\)</span>- 模当且仅当存在环同态 <span class="math inline">\(R\to{\rm End}(M)\)</span>）</p><p>由 <a href="#A-otimes-B" title="定理 1.2">定理 1.2</a> 知道 <span class="math inline">\(A\otimes A^{\rm op}\)</span>是单代数从而这是一个单射，比较维数即得这是一个同构。</p><h1 id="noether-skolem-定理">Noether-Skolem 定理</h1><div id="N-S" class="statement sta_noether_skolem___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Noether-Skolem 定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span>是一个中心单代数，<span class="math inline">\(B\)</span> 是单代数，<span class="math inline">\(f,g\colon\ B\to A\)</span> 是从 <span class="math inline">\(B\)</span> 到 <span class="math inline">\(A\)</span> 的两个代数同态，则存在 <span class="math inline">\(u\in A^{\times}\)</span> 满足 <span class="math display">\[f(b) =u^{-1}g(b)u,\quad \forall b\in B.\]</span>特别的，我们得到中心单代数的自同构都是内自同构。</p></div><p>这个定理背后的想法不难，只是需要一点 Wedderburn-Artin半单代数理论的知识：对于一个单代数 <span class="math inline">\(B\)</span>，在同构意义下 <span class="math inline">\(B\)</span> 只有唯一的不可约模左 <span class="math inline">\(B\)</span>- 模 <span class="math inline">\(V\)</span>。任何左 <span class="math inline">\(B\)</span>- 模都是完全可约的，可以分解为若干 <span class="math inline">\(V\)</span> 的直和，从而两个左 <span class="math inline">\(B\)</span>- 模 <span class="math inline">\(W,W'\)</span> 是同构的当且仅当它们作为 <span class="math inline">\(F\)</span>- 向量空间的维数相同：<span class="math inline">\(W\cong W'\Leftrightarrow\dim_F W=\dim_FW'\)</span>，所以判断两个 <span class="math inline">\(B\)</span>-模是否同构是很简单的，只看维数就行。</p><p>回到 <a href="#N-S" title="Noether-Skolem 定理">Noether-Skolem定理</a> 的证明，我们先处理 <span class="math inline">\(A={\rmMat}_n(F)\)</span> 的情形：这时我们可以在 <span class="math inline">\(F^n\)</span> 上定义两种不同的 <span class="math inline">\(B\)</span>- 模结构：<span class="math inline">\(b\cdot x =f(b)x\)</span> 和 <span class="math inline">\(b\circ x=g(b)x\)</span>。我们已经介绍了在 <span class="math inline">\(B\)</span> 是单代数的情形，两个左 <span class="math inline">\(B\)</span>-模同构当且仅当它们作为向量空间的维数相等。所以 <span class="math inline">\(F^n\)</span> 作为 <span class="math inline">\((B,\cdot)\)</span> 和 <span class="math inline">\((B,\circ)\)</span> 是同构的，因此存在可逆线性变换<span class="math inline">\(T:F^n\to F^n\)</span> 使得 <span class="math display">\[b\cdot (Tx)=T(b\circ x),\]</span> 即 <span class="math inline">\(f(b)=T^{-1}g(b)T\)</span>，因此在 <span class="math inline">\(A={\rm Mat}_n(F)\)</span> 的情形定理成立。</p><p>对于一般的情形，我们当然要向矩阵代数靠拢。考虑 <span class="math inline">\(A\otimes A^{\rm op}\)</span> 的两个单子代数 <span class="math inline">\(f(B)\otimes A^{\rm op}\)</span> 和 <span class="math inline">\(g(B)\otimes A^{\rm op}\)</span>。由于 <span class="math inline">\(A\otimes A^{\rm op}\)</span> 同构于 <span class="math inline">\({\rm Mat}_n(F)\)</span> 因此上面的情形可用，即存在<span class="math inline">\(T \in (A\otimes A^{\rm op})^\times\)</span>满足对任何 <span class="math inline">\(b\otimes a^{\rm op}\)</span> 有<span class="math display">\[f(b)\otimes a^{\rm op}=T^{-1}(g(b)\otimesa^{\rm op})T. \tag{$\ast$}\label{ast}\]</span> 取 <span class="math inline">\(b=1\)</span> 我们有 <span class="math display">\[1\otimes a^{\rm op}=T^{-1}(1\otimes a^{\rmop})T.\]</span> 即 <span class="math inline">\(T\)</span> 与 <span class="math inline">\(1\otimes A^{\rm op}\)</span> 交换。于是根据 <a href="#C-otimes-D" title="引理 1.3">引理 1.3</a>，<span class="math inline">\(T\in A\otimes1\)</span>，从而存在 <span class="math inline">\(u\in A\)</span> 使得 <span class="math inline">\(T=u\otimes1\)</span>，<span class="math inline">\(T\in (A\otimes A^{\rm op})^\times\)</span> 说明<span class="math inline">\(u\in A^{\times}\)</span>，代入到 <span class="math inline">\(\ref{ast}\)</span> 中去即得 <span class="math inline">\(f(b)=u^{-1}g(b)u\)</span>。<span class="math inline">\(\blacksquare\)</span></p><h1 id="双重中心化子定理">双重中心化子定理</h1><div id="------------------------" class="statement sta_________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">双重中心化子定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span>是 <span class="math inline">\(F\)</span> 上的中心单代数，<span class="math inline">\(B\)</span> 是 <span class="math inline">\(A\)</span> 的单子代数，<span class="math inline">\(C\)</span> 是 <span class="math inline">\(B\)</span> 在 <span class="math inline">\(A\)</span> 中的中心化子： <span class="math display">\[C=C_A(B)=\{ c\in A:\ cb=bc,\ \forall b\inB\}.\]</span> 则以下结论成立：</p><ol type="1"><li><span class="math inline">\(C\)</span> 也是 <span class="math inline">\(A\)</span> 的单子代数。</li><li><span class="math inline">\(\dim_F A=(\dim_F B)(\dim_FC)\)</span>。</li><li><span class="math inline">\(C\)</span> 的中心化子是 <span class="math inline">\(B\)</span>。</li></ol></div><p><strong>证明</strong>：参考下图 （<span class="math inline">\(i\)</span> 是嵌入映射）：</p><p><span class="math display">\[\require{amsCd}\begin{CD}B\otimes1 @&gt;{i}&gt;&gt; A\otimes\mathrm{End}_F(B) @&lt;{i}&lt;&lt;1\otimes l(B)\\@V{\rm centralizer}VV @. @VV{\rm centralizer}V \\C\otimes\mathrm{End}_F(B) @&gt;{i}&gt;&gt; A\otimes\mathrm{End}_F(B)@&lt;{i}&lt;&lt; A\otimes r(B)\end{CD}\]</span></p><p>考虑中心单代数 <span class="math inline">\(A\otimes\mathrm{End}_F(B)\)</span>，它有两个子代数<span class="math inline">\(B\otimes 1\)</span> 和 <span class="math inline">\(1\otimes l(B)\)</span>，这里 <span class="math inline">\(l(B)\)</span> 是 <span class="math inline">\(B\)</span> 在自身上的左乘。它们都同构于单子代数<span class="math inline">\(B\)</span>，因此 Noether-Skolem定理断言它俩是共轭的，于是它俩在 <span class="math inline">\(A\otimes\mathrm{End}_F(B)\)</span>中的中心化子也是共轭的。利用 <a href="#C-otimes-D" title="引理 1.3">引理1.3</a> 的结论，对它俩在 <span class="math inline">\(A\otimes\mathrm{End}_F(B)\)</span>中分别求中心化子，得到 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span> 和 <span class="math inline">\(A\otimes r(B)\)</span> 是共轭的。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span><span class="math inline">\(l(B)\)</span> 在 <span class="math inline">\(\mathrm{End}_F(B)\)</span> 中的中心化子是 <span class="math inline">\(r(B)\)</span>，即 <span class="math inline">\(B\)</span> 在自身上的右乘。<span class="math inline">\(r(B)\)</span> 同构于 <span class="math inline">\(B\)</span> 的反环 <span class="math inline">\(B^{\rm op}\)</span>。</p></div><p>由 <a href="#A-otimes-B" title="定理 1.2">定理 1.2</a> <span class="math inline">\(A\otimes r(B)\)</span> 是单代数，于是 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span>也是单代数，从而 <span class="math inline">\(C\)</span> 必须是单代数（否则若 <span class="math inline">\(C\)</span> 有非平凡理想 <span class="math inline">\(I\)</span> 则 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span> 有理想 <span class="math inline">\(I\otimes\mathrm{End}_F(B)\)</span>），这证明了1。</p><p>由于 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span>和 <span class="math inline">\(A\otimes r(B)\)</span>共轭，所以它们的维数相等，即 <span class="math display">\[(\dim_F C)(\dim_F B)^2=(\dim_F A)(\dim_F B),\]</span> 从而可得 <span class="math display">\[(\dim_F C)(\dim_F B)=\dim_F A.\]</span> 这证明了2。</p><p>最后设 <span class="math inline">\(C\)</span> 的中心化子为 <span class="math inline">\(C_A(C)\)</span>，对单子代数 <span class="math inline">\(C\)</span> 应用结论 2， <span class="math display">\[\dim_F C =\frac{\dim_F A}{\dim_FC_A(C)}=\frac{\dim_F A}{\dim_F B}.\]</span> 即 <span class="math inline">\(\dim_F C_A(C)=\dim_F B\)</span>。然而 <span class="math inline">\(B\subsetC_A(C)\)</span>，二者维数相同因此必然相等，这就证明了 3。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Jacobson_alg" class="csl-entry" role="listitem">Jacobson, Nathan. 1980. <em>Basic Algebra. <span>II</span></em>. SanFrancisco, Calif.: W. H. Freeman; Co.</div></div>]]></content>
      
      
      <categories>
          
          <category> 有限群表示与结合代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实化与复化</title>
      <link href="real-complex/"/>
      <url>real-complex/</url>
      
        <content type="html"><![CDATA[<h1 id="实化">实化</h1><p>设 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span> 上的 <span class="math inline">\(n\)</span> 维向量空间，我们可以「忘掉」 <span class="math inline">\(V\)</span> 的复向量空间结构，把 <span class="math inline">\(V\)</span> 看作实向量空间，记作 <span class="math inline">\(V_{\mathbb{R}}\)</span> 以区别于 <span class="math inline">\(V\)</span>。即 <span class="math inline">\(V_\mathbb{R}\)</span> 与 <span class="math inline">\(V\)</span>作为加法群是一样的，但是数和向量的乘法限制在 <span class="math inline">\(\mathbb{R}\)</span> 上。<span class="math inline">\(V_{\mathbb{R}}\)</span> 是 <span class="math inline">\(2n\)</span> 维的。如果 <span class="math inline">\(\{e_i\}_{i=1}^n\)</span> 是 <span class="math inline">\(V\)</span> 的一组 <span class="math inline">\(\mathbb{C}\)</span>- 基，则 <span class="math inline">\(\{e_i,ie_i\}_{i=1}^n\)</span> 是 <span class="math inline">\(V_\mathbb{R}\)</span> 的一组 <span class="math inline">\(\mathbb{R}\)</span>- 基。<span class="math inline">\(V_{\mathbb{R}}\)</span> 叫做 <span class="math inline">\(V\)</span> 的<strong>实化</strong>。</p><p>但是 <span class="math inline">\(V_{\mathbb{R}}\)</span> 比一般的<span class="math inline">\(2n\)</span>维实向量空间还要多出一个结构，这个结构来自 <span class="math inline">\(V\)</span> 上虚数 <span class="math inline">\(i\)</span> 的乘法，它诱导了 <span class="math inline">\(V_\mathbb{R}\)</span> 上的 <span class="math inline">\(\mathbb{R}\)</span>- 线性变换 <span class="math inline">\(J\colon\ v\mapsto iv\)</span>。<span class="math inline">\(J\)</span> 满足 <span class="math inline">\(J^2=-1\)</span>。<span class="math inline">\(J\)</span> 叫做 <span class="math inline">\(V_{\mathbb{R}}\)</span>上的<strong>复结构</strong>。</p><p>反过来，给定一个偶数维的实向量空间 <span class="math inline">\(W\)</span> 以及 <span class="math inline">\(W\)</span> 上的一个复结构 <span class="math inline">\(J\)</span>，<span class="math inline">\(W\)</span>上可以自然地定义复向量空间结构：因为 <span class="math inline">\(J\)</span> 本质就是虚数 <span class="math inline">\(i\)</span> 的乘法，我们只要规定 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(W\)</span> 中向量的乘法为 <span class="math inline">\(iw=J ( w )\)</span>，然后扩展到 <span class="math inline">\(\mathbb{C}\)</span> 上即可： <span class="math display">\[( a+ib ) w = aw+bJ ( w ) ,\quada,b\in\mathbb{R},w\in W.\]</span> 我们用 <span class="math inline">\((W,J )\)</span> 表示这样得到的复向量空间。</p><p>总之任何任何复向量空间 <span class="math inline">\(V\)</span>可以等同于一个 <span class="math inline">\(2n\)</span> 维实向量空间<span class="math inline">\(V_{\mathbb{R}}\)</span> 加上一个复结构 <span class="math inline">\(J\)</span>。</p><h1 id="反线性映射">反线性映射</h1><p>设 <span class="math inline">\(V\)</span> 是复向量空间，记 <span class="math inline">\(\overline{V}\)</span> 是如下的向量空间：<span class="math inline">\(\overline{V}\)</span> 作为加法群和 <span class="math inline">\(V\)</span> 完全相同，但是复数与向量的乘法 <span class="math inline">\(\bullet\)</span> 定义为 <span class="math inline">\(c\bullet z=\overline{c}z\)</span>，其中右边的<span class="math inline">\(\overline{c}z\)</span> 是 <span class="math inline">\(V\)</span> 中的原始数乘。我们称 <span class="math inline">\(\overline{V}\)</span> 是 <span class="math inline">\(V\)</span> 的共轭空间。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(V,U\)</span>是复向量空间。如果映射 <span class="math inline">\(f\colon\ V\toU\)</span> 满足下面两个条件，就称 <span class="math inline">\(f\)</span>是 <a href="https://en.wikipedia.org/wiki/Antilinear_map">反线性</a>映射：</p><ol type="1"><li><span class="math inline">\(f\)</span> 是从 <span class="math inline">\(V\)</span> 到 <span class="math inline">\(U\)</span> 的加法群同态：<span class="math inline">\(f(v_1+v_2)=f(v_1)+f(v_2)\)</span> 对任何 <span class="math inline">\(v_1,v_2\in V\)</span> 成立。</li><li><span class="math inline">\(f(cv)=\overline{c}v\)</span> 对任何<span class="math inline">\(c\in\mathbb{C}\)</span> 和 <span class="math inline">\(v\in V\)</span> 成立。</li></ol></div><p>反线性映射是 <span class="math inline">\(\mathbb{R}\)</span>-线性的，但不是 <span class="math inline">\(\mathbb{C}\)</span>-线性的。</p><p><span class="math inline">\(V\to U\)</span> 的反线性映射和 <span class="math inline">\(V\to\overline{U}\)</span> 的 <span class="math inline">\(\mathbb{C}\)</span>- 线性映射是一回事。</p><h1 id="复化">复化</h1><p>与实化相对应的操作是<strong>复化</strong>，即给定一个 <span class="math inline">\(n\)</span> 维实向量空间 <span class="math inline">\(W\)</span>，把域和向量的乘法扩展到 <span class="math inline">\(\mathbb{C}\)</span> 上，使 <span class="math inline">\(W\)</span> 成为一个复向量空间。我们记作 <span class="math inline">\(W^\mathbb{C}\)</span> 以区别于 <span class="math inline">\(W\)</span>。</p><p>构造 <span class="math inline">\(W^\mathbb{C}\)</span>的标准方法是使用张量积，令 <span class="math inline">\(W^\mathbb{C}=\mathbb{C}\otimes_\mathbb{R}W\)</span>，则<span class="math inline">\(W^\mathbb{C}\)</span> 是 <span class="math inline">\(n\)</span> 维复向量空间，复数与向量的乘法定义为<span class="math display">\[c ( z\otimes w ) = cz\otimes w.\]</span><span class="math inline">\(W\)</span> 可以通过 <span class="math inline">\(w\to 1\otimes w\)</span> 等同于 <span class="math inline">\(W^\mathbb{C}\)</span> 的 <span class="math inline">\(\mathbb{R}\)</span>- 子空间 <span class="math inline">\(1\otimes W\)</span>。在这个等同下，<span class="math inline">\(W^\mathbb{C}\)</span> 中的向量都是 <span class="math inline">\(W\)</span> 中向量的 <span class="math inline">\(\mathbb{C}\)</span>- 线性组合： <span class="math display">\[\sum c_i\otimes w_i = \sum c_i(1\otimes w_i)\leftrightarrow \sum c_iw_i.\]</span> 这一点与我们关于「 将 <span class="math inline">\(W\)</span> 的数乘扩张到 <span class="math inline">\(\mathbb{C}\)</span> 」的直觉完全一致。于是 <span class="math inline">\(W\)</span> 的任何一组 <span class="math inline">\(\mathbb{R}\)</span>- 基同时也是 <span class="math inline">\(W^\mathbb{C}\)</span> 的一组 <span class="math inline">\(\mathbb{C}\)</span>- 基。特别地，<span class="math inline">\(W\)</span> 作为实向量空间的维数与 <span class="math inline">\(W^\mathbb{C}\)</span>作为复向量空间的维数相等。</p><p><span class="math inline">\(W^\mathbb{C}\)</span>可以分解为两个实子空间的直和 <span class="math display">\[W^\mathbb{C}=1\otimes W \oplus i\otimes W=1\otimes W \oplus i(1\otimes W)  .\]</span> 由于 <span class="math inline">\(W\)</span> 可以等同于 <span class="math inline">\(1\otimes W\)</span>，上式可以简写成 <span class="math inline">\(W^\mathbb{C}=W\oplus iW\)</span>。</p><p><span class="math inline">\(W^\mathbb{C}\)</span> 与一般的 <span class="math inline">\(n\)</span>维复向量空间相比也多出一个结构，叫做共轭。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>如果 <span class="math inline">\(\tau\colon\ V\to V\)</span>是反线性映射并且 <span class="math inline">\(\tau^2=1\)</span>，就称<span class="math inline">\(\tau\)</span>是一个<strong>共轭</strong>。</p></div><p>复数的共轭诱导了 <span class="math inline">\(\mathbb{C}\otimes_\mathbb{R}W\)</span> 上的共轭：<span class="math display">\[\tau ( c\otimes w ) =\overline{c}\otimesw,\quad c\in\mathbb{C}, w\in W.\]</span> <span class="math inline">\(\tau\)</span> 保持实子空间 <span class="math inline">\(1\otimes W\cong W\)</span> 不变。<span class="math inline">\(W\)</span> 可以理解为 <span class="math inline">\(V\)</span> 在共轭 <span class="math inline">\(\tau\)</span> 下的实部。</p><p>反过来，给定复向量空间 <span class="math inline">\(V\)</span>以及共轭 <span class="math inline">\(\tau\)</span>，我们可以还原出使得<span class="math inline">\(V=W^\mathbb{C}\)</span> 成立的实向量空间<span class="math inline">\(W\)</span> 来。<span class="math inline">\(W\)</span> 正是 <span class="math inline">\(\tau\)</span> 的不动点子空间 <span class="math inline">\(W=\{v\in V\mid \tau ( v ) =v\}\)</span>，即 <span class="math inline">\(\tau\)</span> 的 +1 特征子空间。相应地 <span class="math inline">\(iW\)</span> 是 <span class="math inline">\(\tau\)</span> 的 -1 特征子空间并且 <span class="math inline">\(V=W\oplus iW\)</span>。根据下面的命题，<span class="math inline">\(W\)</span> 的复化就是 <span class="math inline">\(V\)</span>。</p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(V\)</span>是有限维复向量空间，<span class="math inline">\(W\)</span> 是 <span class="math inline">\(V\)</span> 的 <span class="math inline">\(\mathbb{R}\)</span>- 子空间。若有 <span class="math inline">\(V=W\oplus iW\)</span> 成立，则 <span class="math inline">\(V\cong\mathbb{C}\otimes_\mathbb{R}W\)</span>。</p></div><p><strong>证明</strong>：考察如下定义的映射 <span class="math display">\[\begin{aligned}f\colon\  \mathbb{C}\otimes_\mathbb{R}W &amp; \to V\\c\otimes w &amp;\mapsto cw.\end{aligned}\]</span> 显然 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span>- 线性的。我们来验证 <span class="math inline">\(f\)</span> 是双射。</p><p>由于 <span class="math inline">\(V=W\oplus iW\)</span> 所以任何 <span class="math inline">\(v\in V\)</span> 可以写成 <span class="math inline">\(v=w_1+iw_2,\,w_1,w_2\in W\)</span>的形式。不难验证 <span class="math inline">\(f ( 1\otimes w_1 + i\otimesw_2 ) = w_1+iw_2\)</span> 所以 <span class="math inline">\(f\)</span>是满射。并且 <span class="math inline">\(f ( 1\otimes w_1 + i\otimes w_2) =0\)</span> 当且仅当 <span class="math inline">\(w_1+iw_2=0\)</span>，即 <span class="math inline">\(w_1=-iw_2\in W\cap iW= ( 0 )\)</span>，从而 <span class="math inline">\(w_1=w_2=0\)</span>，这说明 <span class="math inline">\(f\)</span> 也是单射。于是 <span class="math inline">\(f\)</span> 是同构。 <span class="math inline">\(\blacksquare\)</span></p><h1 id="先实化后复化">先实化后复化</h1><p>有了上面的准备，我们来分析将一个 <span class="math inline">\(n\)</span> 维复向量空间 <span class="math inline">\(V\)</span>，先实化再复化得到的 <span class="math display">\[(V_\mathbb{R})^\mathbb{C}=\mathbb{C}\otimes_\mathbb{R}V_\mathbb{R}\]</span>的结构。我其实可以直接写出结论来：</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.1</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(V\)</span> 是复向量空间，则我们有复向量空间的同构<span class="math display">\[\begin{aligned}(V_\mathbb{R})^\mathbb{C}&amp; \to V\oplus \overline{V}\\c\otimes v &amp;\mapsto (cv, \overline{c}v).\end{aligned}\]</span></p></div><p><strong>证明 1</strong>：不难验证所给的映射是 <span class="math inline">\(\mathbb{C}\)</span>- 线性的，并且把 <span class="math inline">\(1\otimes x + i\otimes y\)</span> 映射为 <span class="math inline">\((x+iy,x-iy)\)</span>。我们可以从 <span class="math inline">\((x+iy,x-iy)\)</span> 唯一地反解出 <span class="math inline">\(x,y\)</span> 来，所以这是一个线性同构。<span class="math inline">\(\blacksquare\)</span></p><p>上面的证明虽然简明了然，但是似乎没有揭示这个同构是怎么想出来的。特别是<span class="math inline">\(\overline{V}\)</span>的出现显得有些突兀。我们换一种方法来分析：找到合适的线性变换并分析它在<span class="math inline">\((V_\mathbb{R})^\mathbb{C}\)</span>上的作用。</p><p><strong>证明 2</strong>：记 <span class="math inline">\(J\)</span> 是<span class="math inline">\(V_\mathbb{R}\)</span> 的复结构，则 <span class="math inline">\(J^\mathbb{C}=1\otimes J\)</span> 是 <span class="math inline">\(\mathbb{C}\otimes_\mathbb{R}V_\mathbb{R}\)</span>上的 <span class="math inline">\(\mathbb{C}\)</span>- 线性变换并且 <span class="math inline">\(( J^\mathbb{C})^2 = -1\)</span>。<span class="math inline">\(( V_\mathbb{R})^\mathbb{C}\)</span> 可以分解为<span class="math inline">\(J^\mathbb{C}\)</span> 的 <span class="math inline">\(\pm i\)</span> 特征子空间的直和： <span class="math display">\[( V_\mathbb{R})^\mathbb{C}= V_+\oplusV_-.\]</span> 具体写出来，就是 <span class="math display">\[\begin{aligned}V_+ &amp;= \frac{1\otimes V_\mathbb{R}- i\otimes J(V_\mathbb{R})}{2}, \\V_- &amp;= \frac{1\otimes V_\mathbb{R}+ i\otimes J(V_\mathbb{R})}{2}.\end{aligned}\]</span></p><p>容易验证 <span class="math inline">\(\tau\)</span> 交换 <span class="math inline">\(V_+\)</span> 和 <span class="math inline">\(V_-\)</span>，但 <span class="math inline">\(\tau\)</span> 是反线性的，所以 <span class="math inline">\(V_+\cong\overline{V_-}\)</span>，即二者互为共轭空间。</p><p>进一步我们断言有复向量空间的同构 <span class="math inline">\(V_+\cong V\)</span>。考虑映射 <span class="math display">\[\begin{aligned}f\colon \ V_+  &amp; \to (V_\mathbb{R}, J)\\c\otimes v &amp;\mapsto cv.\end{aligned}\]</span> 这里右边的乘法 <span class="math inline">\(cv\)</span>理解为对 <span class="math inline">\(c=a+ib\)</span> 有 <span class="math inline">\(cv=av+bJ(v)\)</span>。</p><p><span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span>- 线性的，确实把 <span class="math inline">\(V_+\)</span> 映射到 <span class="math inline">\(V_\mathbb{R}\)</span>： <span class="math display">\[f\left(\frac{1\otimes v- i\otimes J(v)}{2}\right)= \frac{v-J^2(v)}{2}=v.\]</span> <span class="math inline">\(f\)</span>有逆映射 <span class="math display">\[\begin{aligned}f^{-1}\colon \ V_\mathbb{R}&amp; \to V_+\\v &amp;\mapsto \frac{1\otimes v- i\otimes J(v)}{2}.\end{aligned}\]</span> 所以 <span class="math inline">\(V_+\cong(V_\mathbb{R},J)\cong V\)</span>。至此我们就证明了 <span class="math display">\[(V_\mathbb{R})^\mathbb{C}\cong V\oplus\overline{V}.\]</span></p><p><span class="math inline">\(\blacksquare\)</span></p><p>这个同构也可以用下面的交换图来表示：</p><p><span class="math display">\[\require{amsCd}\begin{CD}\mathbb{C}\otimes_\mathbb{R}V_\mathbb{R}@&gt;{c\otimes v\,\to\,(cv,\,\overline{c}v)}&gt;&gt; (V,\overline{V})\\@V{\tau}VV  @VV{(u,\,v)\leftrightarrow (v,\,u)}V \\\mathbb{C}\otimes_\mathbb{R}V_\mathbb{R}@&gt;{c\otimes v\,\to\,(cv,\,\overline{c}v)}&gt;&gt; (V,\overline{V})\end{CD}\]</span> 其中 <span class="math inline">\((u,v)\leftrightarrow(v,u)\)</span> 是 <span class="math inline">\(\tau\)</span> 在 <span class="math inline">\(V\oplus\overline{V}\)</span>上诱导的共轭结构，它交换两个直和分量。</p><h1 id="线性变换的复化">线性变换的复化</h1><p>设 <span class="math inline">\(W\)</span> 是实向量空间，<span class="math inline">\(W^\mathbb{C}=\mathbb{C}\otimes_\mathbb{R}W\)</span>是复化，则任何 <span class="math inline">\(f\in\mathrm{Hom}_\mathbb{R}(W,W)\)</span>可以自然地扩展为 <span class="math display">\[f^\mathbb{C}=1\otimesf\in\mathrm{Hom}_\mathbb{C}(W^\mathbb{C},W^\mathbb{C}).\]</span> <span class="math inline">\(f^\mathbb{C}\)</span> 与 <span class="math inline">\(f\)</span> 有相同的矩阵。注意 <span class="math inline">\(f^\mathbb{C}\)</span> 与共轭 <span class="math inline">\(\tau\)</span>交换，因为它们作用在张量积的不同分量上。</p><p>反过来，我们想知道何时 <span class="math inline">\(g\in\mathrm{Hom}_\mathbb{C}(W^\mathbb{C},W^\mathbb{C})\)</span>是某个 <span class="math inline">\(f\in\mathrm{Hom}_\mathbb{R}(W,W)\)</span>的复化：<span class="math inline">\(g=f^\mathbb{C}\)</span>。一个必要条件当然是 <span class="math inline">\(g\)</span> 与共轭 <span class="math inline">\(\tau\)</span>交换。这个条件也是充分的。这是因为，我们有自然同构 <span class="math display">\[\mathrm{Hom}_\mathbb{C}(W^\mathbb{C},W^\mathbb{C})\cong\mathbb{C}\otimes\mathrm{Hom}_\mathbb{R}(W,W).\]</span> 所以 <span class="math inline">\(g\)</span> 可以写成如下的形式： <span class="math display">\[g=1\otimes f_1+i\otimes f_2,\quadf_1,f_2\in\mathrm{Hom}_\mathbb{R}(W,W).\]</span> <span class="math inline">\(g\)</span> 与 <span class="math inline">\(\tau\)</span> 交换说明 <span class="math inline">\(f_2\)</span> 作用在 <span class="math inline">\(W\)</span> 上是零变换，从而 <span class="math inline">\(g=1\otimes f_1\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hurwitz 平方和定理</title>
      <link href="hurwitz-square-sum-theorem/"/>
      <url>hurwitz-square-sum-theorem/</url>
      
        <content type="html"><![CDATA[<p>Hurwitz平方和定理是有限群表示论的一个精彩应用，本文是若干年前读书时的笔记。</p><span id="more"></span><h1 id="hurwitz-平方和定理">Hurwitz 平方和定理</h1><p>我们都熟悉复数的乘法：如果 <span class="math inline">\(z_1=x_1+y_1i,\,z_2=x_2+y_2i\)</span>是两个复数，则 <span class="math display">\[|z_1z_2|=|z_1|\cdot|z_2|.\]</span> 也就是 <span class="math display">\[(x_1^2+y_1^2)(x_2^2+y_2^2)=(x_1x_2-y_1y_2)^2+(x_1y_2+x_2y_1)^2.\]</span>1748 年 Euler 发现了如下的 4 平方和等式： <span class="math display">\[(x_1^2+x_2^2+x_3^2+x_4^2)(y_1^2+y_2^2+y_3^2+y_4^2)=z_1^2+z_2^2+z_3^2+z_4^2.\]</span>其中 <span class="math display">\[\begin{align*}&amp;z_1=x_1y_1-x_2y_2-x_3y_3-x_4y_4,\\&amp;z_2=x_1y_2+x_2y_1+x_3y_4-x_4y_3,\\&amp;z_3=x_1y_3+x_3y_1-x_2y_4+x_4y_2,\\&amp;z_4=x_1y_4+x_4y_1+x_2y_3-x_3y_2.\end{align*}\]</span>4 平方和等式说的是在 Hamilton 四元数体中范数仍然是乘性的。1848 年 Cayley发现了八元数 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，从而导出了类似的 8平方和等式，当然具体写出来会很复杂，这里就按下不表了。</p><p>一般地，如果能在 <span class="math inline">\(n\)</span> 维 Euclidean空间 <span class="math inline">\(\mathbb{R}^n\)</span>上定义向量之间的乘法： <span class="math display">\[\mathbb{R}^n\times\mathbb{R}^n\rightarrow\mathbb{R}^n:(v,w)\rightarrowv\times w\]</span> 使得 <span class="math inline">\(v\times w\)</span>对 <span class="math inline">\(v,w\)</span>都是线性的，而且乘积的范数等于范数的乘积：<span class="math inline">\(|v\times w|=|v|\cdot |w|\)</span>，这里 <span class="math inline">\(|\cdot|\)</span> 是通常的 Euclidean范数，则我们就得到了一个 <span class="math inline">\(n\)</span>平方和等式。</p><p>在接下来的 50 年里，人们一直致力于寻找可能的 16平方和等式，但是都失败了，于是开始怀疑是否没有这样的等式成立。终于在1898 年 Hurwitz 证明了这样的结论：</p><div id="hurwitz----------------" class="unnumbered statement sta_hurwitz______ plain"><p><span class="statement-heading"><span class="statement-label">Hurwitz平方和定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(x=(x_1,\ldots,x_n)\)</span>, <span class="math inline">\(y=(y_1,\dots,y_n)\)</span> 为 <span class="math inline">\(\mathbb{R}^n\)</span> 中的向量。如果存在关于 <span class="math inline">\(x,y\)</span> 的双线性函数 <span class="math inline">\(z_1(x,y),\ldots,z_n(x,y)\)</span> 使得等式 <span class="math display">\[(x_1^2+\cdots+x_n^2)(y_1^2+\cdots+y_n^2)=z_1^2+\cdots+z_n^2\]</span>恒成立，那么 <span class="math inline">\(n=1,2,4,8\)</span>。</p></div><p>正如前面说过的，Huiwitz 平方和定理意味着在实数域 <span class="math inline">\(\mathbb{R}\)</span>，复数域 <span class="math inline">\(\mathbb{C}\)</span>，四元数 <span class="math inline">\(\mathbb{H}\)</span> 和八元数 <span class="math inline">\(\mathbb{O}\)</span> 中，元素的 Euclidean范数和向量的乘法是相容的，而在其它维数的 <span class="math inline">\(\mathbb{R}^n\)</span> 上是不可能定义与 Euclidean范数相容的向量乘法的。</p><p>Hurwitz本人的证明是纯线性代数的，线性代数的证明较为初等，不过步骤略长。1943 年Eckmann用有限群表示论的方法给了一个漂亮的证明，本文就来介绍这个证明。</p><h1 id="将问题转化为矩阵方程">将问题转化为矩阵方程</h1><p>设 <span class="math inline">\(z=(z_1,\ldots,z_n)\)</span>，则每个<span class="math inline">\(z_i\)</span> 关于 <span class="math inline">\(y\)</span> 都是线性的，因此存在 <span class="math inline">\(n\)</span> 阶矩阵 <span class="math inline">\(A\)</span> 满足 <span class="math inline">\(z=yA\)</span>，当然矩阵 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(x\)</span> 有关。于是 Hurwitz 定理中的等式变成<span class="math display">\[(x_1^2+x_2^2+\cdots+x_n^2)yy'=yAA'y'.\]</span>由于 <span class="math inline">\(y\)</span> 是不定元，因此 <span class="math display">\[AA'=(x_1^2+\cdots+x_n^2)I_n.\]</span>进一步，由于 <span class="math inline">\(A\)</span> 关于 <span class="math inline">\(x\)</span> 也是线性的，因此设 <span class="math inline">\(A=A_1x_1+\cdots+A_nx_n\)</span>，则 <span class="math display">\[AA'=\sum_{i=1}^nA_iA_i'x_i^2+\sum_{1\leqi&lt;j\leq n}(A_iA_j'+A_jA_i')x_ix_j.\]</span>从而我们得到一组矩阵方程 <span class="math display">\[A_iA_i'=I_n,\quadA_iA_j'+A_jA_i'=0\text{ for } i\ne j.\]</span> 进一步可以把<span class="math inline">\(A_n\)</span> 归一化为单位矩阵：令 <span class="math inline">\(Q_i=A_iA_n^{-1}\)</span>，于是 <span class="math inline">\(Q_1,\ldots,Q_{n-1}\)</span> 满足 <span class="math display">\[Q_i'=-Q_i,\quad Q_i^2=-I_n,\quadQ_iQ_j=-Q_jQ_i\text{ for } i\ne j.\]</span> 显然 <span class="math inline">\(n\)</span> 必须是偶数 （奇数阶反对称矩阵行列式都是0），而 <span class="math inline">\(n=2\)</span>的时候结论是成立的（复数域），所以下面我们都假定 <span class="math inline">\(n&gt;2\)</span>，于是 <span class="math inline">\(n\)</span> 的可能值为 <span class="math inline">\(4,6,8,\ldots\)</span>。</p><h1 id="用群表示论的工具得出矛盾">用群表示论的工具得出矛盾</h1><p>考虑这样一个抽象群 <span class="math inline">\(G\)</span>，它由元素<span class="math inline">\(a,g_1,\ldots,g_{n-1}\)</span>生成，且满足关系 <span class="math display">\[ a^2=1,\quad g_i^2=a,\quadg_ig_j=ag_jg_i\ \text{when}\ i\ne j.\]</span> 这里 <span class="math inline">\(a\)</span> 对应的是上面矩阵中的 <span class="math inline">\(-I_n\)</span>，<span class="math inline">\(g_i\)</span> 对应的上面矩阵中的 <span class="math inline">\(Q_i\)</span>。这个群的结构很好分析：</p><ul><li><span class="math inline">\(|G|=2^n\)</span>，每个元素形如 <span class="math inline">\(a^{e_0}g_1^{e_1}\cdotsg_{n-1}^{e_{n-1}}\)</span>，其中 <span class="math inline">\(e_i\in\{0,1\}\)</span>。</li><li><span class="math inline">\(G\)</span> 的中心 <span class="math inline">\(Z(G)=\{1,a,g_1g_2\cdots g_{n-1},ag_1g_2\cdotsg_{n-1}\}\)</span>。</li><li><span class="math inline">\(G\)</span> 的换位子群 <span class="math inline">\([G,G]=\{1,a\}\)</span>，从而 <span class="math inline">\(G\)</span> 有 <span class="math inline">\(|G/[G,G]|=2^{n-1}\)</span> 个线性表示。</li><li><span class="math inline">\(G\)</span>的任何非平凡共轭类都只有两个元素 <span class="math inline">\(\{g,ag\}\)</span>，从而 <span class="math inline">\(G\)</span> 有 <span class="math inline">\(2^{n-1}+2\)</span>个共轭类，从而其不可约复表示的个数也是 <span class="math inline">\(2^{n-1}+2\)</span>。</li></ul><p>于是我们知道 <span class="math inline">\(G\)</span> 有 <span class="math inline">\(2^{n-1}\)</span> 个一次表示，还有 2 个次数大于 1的表示，设它俩的次数分别是 <span class="math inline">\(f_1,f_2\)</span>，根据不可约表示次数的平方和等于<span class="math inline">\(G\)</span> 的阶，得到方程 <span class="math display">\[f_1^2+f_2^2 + 2^{n-1}=|G|=2^n.\]</span> 即 <span class="math inline">\(f_1^2+f_2^2=2^{n-1}\)</span>。再利用不可约表示的次数整除<span class="math inline">\(G\)</span> 的阶，知道 <span class="math inline">\(f_1\)</span> 和 <span class="math inline">\(f_2\)</span> 都是 2 的幂，这只有一种可能，就是<span class="math display">\[ f_1=f_2=2^{\frac{n}{2}-1}.\]</span></p><p>现在 Hurwitz 矩阵方程给出了 <span class="math inline">\(G\)</span>的一个 <span class="math inline">\(n\)</span>维表示，这个表示可以分解为若干不可约表示的直和，我们断言其中不含有一次表示，从而只能是若干个<span class="math inline">\(2^{\frac{n}{2}-1}\)</span>次表示的直和：这是因为元素 <span class="math inline">\(a\)</span>在这个表示下是 <span class="math inline">\(n\)</span> 阶矩阵 <span class="math inline">\(-I_n\)</span>，从而其在任何不变子空间上的作用都是乘以-1。但是任何一次表示都把 <span class="math inline">\(a\in [G,G]\)</span>映射为 1，矛盾！</p><p>于是 <span class="math inline">\(2^{\frac{n}{2}-1}\big|n\)</span>，设 <span class="math inline">\(n=2^r\cdot s\)</span>，其中<span class="math inline">\(s\)</span> 为奇数，则 <span class="math inline">\(\frac{n}{2}-1\leq r\)</span>，从而 <span class="math display">\[ 2^r\leq n\leq 2r+2.\]</span> 注意 <span class="math inline">\(n\)</span> 是偶数，所以只能是 <span class="math inline">\(n=4,6,8\)</span>，这就完成了 Hurwitz定理的证明。</p><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://en.wikipedia.org/wiki/Octonion#History">https://en.wikipedia.org/wiki/Octonion#History</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 有限群表示与结合代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jordan 标准形</title>
      <link href="jordan-canonical-form/"/>
      <url>jordan-canonical-form/</url>
      
        <content type="html"><![CDATA[<p>Jordan标准形定理是线性代数中的基本定理，专门为它写一篇长文好像有点多余：这方面的教材讲义实在是太多了！一个陈旧的定理还能写出什么新意来呢？</p><p>理由有两个。第一个原因是我曾经在做助教给学生讲这个定理的时候，突然发现不知道该怎么启发他们为好。虽然我知道Jordan标准形定理的很多种证法，照念几个不在话下，但是感觉有点疙疙瘩瘩的：怎么才能说清定理背后的想法，让学生觉得定理的成立是顺理成章的呢？于是我知道我对这个定理的理解还有模糊的地方。</p><p>第二个原因是 Jordan块有一个重要的代数性质是通常教材中不讲的，而这个性质是代数学中一类重要而常见的性质的雏形，这就是不可分解性。与之对应的是可对角化的线性变换的完全可约性。从一开始就让学生接触这些现象是有好处的。</p><span id="more"></span><h1 id="什么是-jordan-标准形">什么是 Jordan 标准形</h1><p>我们从中学就知道整数环和多项式环有唯一因子分解定理：每个整数可以唯一地分解为素数的乘积，每个域上的多项式可以唯一地分解为不可约多项式的乘积。数学里面有很多这样的唯一分解定理，现在我们想知道：有没有所谓的“线性变换的唯一分解定理”呢？可以猜测如果有这样的定理存在，那么大概可以表述为如下的样子：</p><div id="unique-1" class="statement sta____________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">线性变换的唯一分解定理</span>.</span><span class="statement-spah"> </span>（粗糙的版本）：设 <span class="math inline">\(V\)</span> 是域 <span class="math inline">\(F\)</span> 上的有限维向量空间，<span class="math inline">\(T\)</span> 是 <span class="math inline">\(V\)</span> 上的线性变换，则 <span class="math inline">\(T\)</span>可以唯一地分解为若干个「简单的」线性变换，而这些「简单的」线性变换本身不能再分解。</p></div><p>这个表述很不清楚，整数和多项式的分解就是表示为素因子的乘积，那什么是线性变换的分解呢？什么又是不可分解的线性变换呢？正确的概念是直和：</p><div class="statement simple plain unnumbered"><p>设 <span class="math inline">\(T\)</span> 是向量空间 <span class="math inline">\(V\)</span> 上的线性变换，如果 <span class="math inline">\(V\)</span> 可以分解为一些非平凡的子空间的直和<span class="math inline">\(V=V_1\oplus\cdots\oplusV_k\)</span>，使得每一个 <span class="math inline">\(V_i\)</span> 都是<span class="math inline">\(T\)</span>- 不变的子空间，则称 <span class="math inline">\(T\)</span> 是可以分解的； 如果 <span class="math inline">\(V\)</span> 不存在这样的分解，则称 <span class="math inline">\(T\)</span> 是不可分解的线性变换。</p></div><p>这样我们就可以比较准确的表述线性变换的唯一分解定理了：</p><div id="unique-2" class="statement sta____________-1 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">线性变换的唯一分解定理</span>.</span><span class="statement-spah"> </span>（修正的版本）：设 <span class="math inline">\(V\)</span> 是域 <span class="math inline">\(F\)</span> 上的有限维向量空间，<span class="math inline">\(T\)</span> 是 <span class="math inline">\(V\)</span> 上的线性变换，则 <span class="math inline">\(V\)</span> 可以分解为若干个 <span class="math inline">\(T\)</span>- 不变子空间的直和 <span class="math inline">\(V=V_1\oplus\cdots\oplus V_k\)</span>，<span class="math inline">\(T\)</span> 限制在每个 <span class="math inline">\(V_i\)</span>上是不可分解的线性变换。这个分解还是唯一的，即如果 <span class="math inline">\(V=W_1\oplus\cdots\oplus W_l\)</span>是另一种分解，则 <span class="math inline">\(k=l\)</span>且适当重排以后，对每个 <span class="math inline">\(i\)</span>，<span class="math inline">\(T\)</span> 在 <span class="math inline">\(V_i\)</span> 上的限制与 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(W_i\)</span> 上的限制是相似的。</p></div><p>这里有一个重要的问题需要说明：在一般的域上研究不可分解的线性变换是一个棘手的多的问题，这个问题的解决要用到Frobenius 有理标准形，而在复数域上问题就简单很多，这就是 Jordan标准形做的事情。在本文中我们都在复数域上讨论。</p><p>那么什么样的线性变换算是不可分解的线性变换呢？</p><p>最简单也是最重要的例子就是移位算子：假设 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(V\)</span> 的一组基 <span class="math inline">\(\{v_1,\cdots,v_n\}\)</span>的作用是一个向右的移位： <span class="math display">\[T:\quadv_n\rightarrow v_{n-1}\rightarrow\cdots\rightarrowv_1\rightarrow0.\]</span> 则称 <span class="math inline">\(T\)</span>是一个移位算子。<span class="math inline">\(T\)</span>在这组基下的矩阵为 <span class="math inline">\(J_0\)</span>: <span class="math display">\[(v_1, v_2, \ldots, v_n)J_0 = (0, v_1, \ldots,v_{n-1}),\quad J_0=\begin{pmatrix}0&amp;1&amp;&amp;\\ &amp;\ddots&amp;\ddots &amp;\\ &amp;&amp;0&amp;1\\&amp;&amp;&amp;0\end{pmatrix}.\]</span></p><p><span class="math inline">\(J_0\)</span> 叫做特征值为 0 的 Jordan块。注意 <span class="math inline">\(T\)</span> 是一个幂零算子：<span class="math inline">\(T^n=0\)</span>，它仅有唯一的特征值 0。</p><p>为什么 <span class="math inline">\(T\)</span> 是不可分解的？假设<span class="math inline">\(V=U\oplus W\)</span> 是两个非平凡 <span class="math inline">\(T\)</span>- 不变子空间的直和，则 <span class="math inline">\(T\)</span> 作为 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(W\)</span> 上的幂零线性变换必然各有一个特征值为 0的特征向量，因此齐次线性方程组 <span class="math inline">\(TX=0\)</span>的解空间至少包含两个线性无关的向量。但是 <span class="math inline">\(T\)</span> 的秩是 <span class="math inline">\(n-1\)</span>，所以 <span class="math inline">\(TX=0\)</span> 的解空间是 1维的，这就导致了矛盾。</p><p>用同样的方法可以说明给移位算子 <span class="math inline">\(T\)</span>加上一个数乘变换以后得到的仍然是不可分解的线性变换：设 <span class="math inline">\(\lambda\in\mathbb{C}\)</span>，<span class="math inline">\(S=T+\lambda I\)</span>，则 <span class="math inline">\(S\)</span> 也是不可分解线性变换，其对应的矩阵<span class="math display">\[J_\lambda=\begin{pmatrix}\lambda&amp;1&amp;&amp;\\&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\lambda&amp;1\\&amp;&amp;&amp;\lambda\end{pmatrix}\]</span>叫做特征值为 <span class="math inline">\(\lambda\)</span> 的 Jordan块。</p><p>现在我们已经找到了一族不可分解的线性变换，那么它们是否就构成了全部的线性变换呢？答案是肯定的，这就是Jordan 标准形定理：</p><div id="jordan-canonical" class="unnumbered statement sta_jordan______ plain"><p><span class="statement-heading"><span class="statement-label">Jordan标准形定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span> 上有限维向量空间 <span class="math inline">\(V\)</span> 上的线性变换，则存在 <span class="math inline">\(V\)</span> 的一组基使得 <span class="math inline">\(T\)</span> 在这组基下的矩阵为 Jordan 块的直和：<span class="math display">\[T=J_{\lambda_1}\oplus\cdots\oplusJ_{\lambda_r}.\]</span> 这种分解是唯一的，意思是如果存在 <span class="math inline">\(V\)</span> 的另一组基使得 <span class="math inline">\(T\)</span> 的矩阵也是 Jordan 块的直和 <span class="math display">\[T=J_{\mu_1}\oplus\cdots\oplus J_{\mu_s},\]</span>则 <span class="math inline">\(r=s\)</span> 且适当重排后有 <span class="math inline">\(J_{\lambda_i}=J_{\mu_i}\)</span>。</p></div><h1 id="jordan-标准形定理的证明">Jordan 标准形定理的证明</h1><p>定理的结论包含存在性和唯一性两部分，我们先来处理存在性的证明。</p><h2 id="分解存在性-1转化为幂零的情形">分解存在性1：转化为幂零的情形</h2><p>首先我们需要另一个重要的定理：准素分解定理。准素分解定理是一个初步的分解，它把<span class="math inline">\(V\)</span> 分解为若干 <span class="math inline">\(T\)</span>- 不变子空间 <span class="math inline">\(V_i\)</span> 的直和，使得 <span class="math inline">\(T\)</span> 在每个 <span class="math inline">\(V_i\)</span> 上的作用是一个数乘变换 <span class="math inline">\(\lambda_iI\)</span> 加上一个幂零线性变换 <span class="math inline">\(N\)</span>。借助准素分解定理，我们把 Jordan标准形的存在性转化为论证任何幂零线性变换可以分解为一些零特征值的 Jordan块的直和。</p><div id="primary-decomposition" class="unnumbered statement sta_______ plain"><p><span class="statement-heading"><span class="statement-label">准素分解定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(T\)</span>的特征多项式为 <span class="math inline">\(f(x)\)</span>，且 <span class="math inline">\(f(x)\)</span> 在复数域上分解为一次因式的乘积 <span class="math display">\[f(x)=(x-\lambda_1)^{n_1}\cdots(x-\lambda_k)^{n_k},\]</span>这里的 <span class="math inline">\(\lambda_i\)</span> 互不相同。令 <span class="math inline">\(V_i=\mathrm{Ker}(T-\lambda_i I)^{n_i}\)</span>，则每个 <span class="math inline">\(V_i\)</span> 都是 <span class="math inline">\(T\)</span>- 不变子空间而且 <span class="math display">\[V=V_1\oplus\cdots\oplus V_m.\]</span></p></div><p><strong>证明</strong>：我们从一个简单的引理出发：</p><div id="coprime" class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(T\)</span> 是域 <span class="math inline">\(F\)</span> 上有限维向量空间 <span class="math inline">\(V\)</span> 上的线性变换，<span class="math inline">\(p(x),q(x)\in F[x]\)</span>是两个互素的多项式，且有 <span class="math inline">\(p(T)\cdotq(T)=0\)</span>。则 <span class="math inline">\(V=\mathrm{Ker}p(T)\oplus\mathrm{Ker}q(T)\)</span>。</p></div><p>引理的证明：由于 <span class="math inline">\(p(x),q(x)\)</span>是互素的多项式，所以存在多项式 <span class="math inline">\(s(x),t(x)\)</span> 满足 <span class="math display">\[s(x)p(x)+t(x)q(x)=1.\]</span> 即 <span class="math display">\[s(T)p(T)+t(T)q(T)=I.\]</span> 于是对任何 <span class="math inline">\(v\in V\)</span> 有 <span class="math display">\[v= \underbrace{s(T)p(T)v}_{\in\mathrm{Ker}q(T)} +\underbrace{t(T)q(T)v}_{\in\mathrm{Ker}p(T)}.\]</span> 这说明 <span class="math inline">\(V = \mathrm{Ker}p(T) +\mathrm{Ker}q(T)\)</span>。要验证这是直和，不妨设 <span class="math inline">\(v\in\mathrm{Ker}p(T)\cap\mathrm{Ker}q(T)\)</span>，则<span class="math inline">\(p(T)v=q(T)v=0\)</span>，于是 <span class="math display">\[v =s(T)p(T)v+t(T)q(T)v = 0.\]</span></p><p>把引理的结论反复应用在 <span class="math inline">\(f(x)\)</span>上即可得出准素分解定理。<span class="math inline">\(\blacksquare\)</span></p><h2 id="分解存在性-2证明幂零的情形">分解存在性 2：证明幂零的情形</h2><p>借助 <a href="#primary-decomposition" title="准素分解定理">准素分解定理</a>，我们把分解存在性转化为论证若<span class="math inline">\(N\)</span> 是某个向量空间 <span class="math inline">\(V\)</span> 上的幂零线性变换，则存在 <span class="math inline">\(V\)</span> 的一组基，使得 <span class="math inline">\(N\)</span> 在这组基下的矩阵是若干零特征值 Jordan块 <span class="math inline">\(J_0\)</span> 的和。注意一个 Jordan块对应的是一个链 <span class="math display">\[v\rightarrow Nv\rightarrow\cdots \rightarrow N^kv\rightarrow 0.\]</span>我们要证明存在若干条这样的互不相交的链，这些链所包含的全部非零向量构成<span class="math inline">\(V\)</span> 的一组基。</p><p>这一步的证明方法很多，但是相差不是很大，具体喜欢那种要看个人主观，这里介绍的是最简单也是最容易被初学者接受的一种。</p><p>对 <span class="math inline">\(V\)</span> 的维数 <span class="math inline">\(\dim V\)</span> 归纳，<span class="math inline">\(\dim V=1\)</span> 时显然结论成立。</p><p>现假设结论对所有维数小于 <span class="math inline">\(\dim V\)</span>的向量空间成立，考虑 <span class="math inline">\(V\)</span> 的像空间<span class="math inline">\(\mathrm{Im}(V)\)</span>。这是一个 <span class="math inline">\(N\)</span>- 不变子空间，且由于 <span class="math inline">\(N\)</span> 是幂零线性变换所以 <span class="math inline">\(\dim \mathrm{Im}(V)&lt;\dim V\)</span>，所以可以对<span class="math inline">\(\mathrm{Im}(V)\)</span> 使用归纳假设：存在<span class="math inline">\(\mathrm{Im}(V)\)</span>的一组基如下，它们构成 <span class="math inline">\(q\)</span>条不相交的链 <span class="math inline">\(\mathcal{O}_1,\cdots,\mathcal{O}_q\)</span>：</p><p><span class="math display">\[\begin{array}{l}&amp;v_{1,1}\rightarrowv_{1,2}\rightarrow\cdots\rightarrow v_{1,n_1}\rightarrow0.\\&amp;v_{2,1}\rightarrow v_{2,2}\rightarrow\cdots\rightarrowv_{2,n_2}\rightarrow 0.\\&amp;\cdots\\&amp; v_{q,1}\rightarrowv_{q,2}\rightarrow\cdots\rightarrow v_{q,n_q}\rightarrow0.\end{array}\]</span></p><p>由于 <span class="math inline">\(v_{i,1}\in \mathrm{Im}(V)\)</span>因此可以设 <span class="math inline">\(v_{i,1}=Nw_i\)</span>，从而我们得到一组更长的链（就是在前面加上一项）</p><p><span class="math display">\[\begin{array}{l}&amp;w_1\rightarrowv_{1,1}\rightarrow v_{1,2}\rightarrow\cdots\rightarrowv_{1,n_1}\rightarrow 0.\\&amp;w_2\rightarrow v_{2,1}\rightarrowv_{2,2}\rightarrow\cdots\rightarrow v_{2,n_2}\rightarrow0.\\&amp;\cdots\cdots\cdots\\&amp;w_q\rightarrow v_{q,1}\rightarrowv_{q,2}\rightarrow\cdots\rightarrow v_{q,n_q}\rightarrow0.\end{array}\]</span></p><p>那么这些新链包含的向量是否构成 <span class="math inline">\(V\)</span>的一组基？答案是我们还要补上一些在 <span class="math inline">\(V\)</span> 中长度是 1，但是在 <span class="math inline">\(\mathrm{Im}(V)\)</span> 中“消失”了的链：注意 <span class="math inline">\(\{v_{1,n_1},\cdots,v_{q,n_q}\}\)</span> 是 <span class="math inline">\(\mathrm{Ker}N\)</span> 中的线性无关元，但是 <span class="math inline">\(\mathrm{Ker}N\)</span>还可能有其它的基向量。将它们扩充为 <span class="math inline">\(\mathrm{Ker}N\)</span> 的一组基</p><p><span class="math display">\[\{ v_{1,n_1},\cdots,v_{q,n_1}\}\cup \{w_{q+1},\cdots,w_{K}\},\quad K=\dim\mathrm{Ker}N.\]</span></p><p>从而我们最终得到下面的链图：</p><p><span class="math display">\[\begin{array}{r}\mathbf{w_1}\rightarrowv_{1,1}\rightarrow v_{1,2}\rightarrow\cdots\rightarrowv_{1,n_1}\rightarrow 0.&amp;\\\mathbf{w_2}\rightarrow v_{2,1}\rightarrowv_{2,2}\rightarrow\cdots\rightarrow v_{2,n_2}\rightarrow0.&amp;\\\cdots\cdots\cdots&amp;\\\mathbf{w_q}\rightarrowv_{q,1}\rightarrow v_{q,2}\rightarrow\cdots\rightarrowv_{q,n_q}\rightarrow 0.&amp;\\\mathbf{w_{q+1}}\rightarrow0.&amp;\\\cdots\cdots&amp;\\\mathbf{w_K}\rightarrow0.\end{array}\]</span></p><p>你可以看到 <span class="math inline">\(w_{q+1},\ldots,w_K\)</span>正是那些在 <span class="math inline">\(V\)</span> 中长度为 1，但是在<span class="math inline">\(\mathrm{Im}(V)\)</span>中「消失」了的链。</p><p>最后只剩下验证这些向量确实构成 <span class="math inline">\(V\)</span>的一组基。显然这些向量一共有 <span class="math display">\[\dim\mathrm{Im}(V)+\dim\mathrm{Ker}N=\dim V\]</span>个，所以只要再说明它们是线性无关的。</p><p>假设有线性关系</p><p><span class="math display">\[\cdots+(c_0w_i+c_1v_{i,1}+\cdots+c_{n_i}v_{i,n_i})+\cdots+\sum_{j=q+1}^Kd_jw_j=0,\]</span></p><p>我们要说明出现在上式中的所有系数 <span class="math inline">\(c_i,d_j\)</span> 都是 0。左边用 <span class="math inline">\(N\)</span> 作用得到</p><p><span class="math display">\[\cdots+(c_0v_{i,1}+c_1v_{i,2}+\cdots+c_{n_i-1}v_{i,n_i})+\cdots=0.\]</span></p><p>这是一个关于 <span class="math inline">\(\mathrm{Im}(V)\)</span>的一组基的一个线性关系，于是 <span class="math inline">\(c_0=\cdots=c_{n_i-1}=0\)</span>，从而剩下的线性关系为</p><p><span class="math display">\[\cdots+c_{n_i}v_{i,n_i}+\cdots+\sum_{j=q+1}^Kd_jw_j=0.\]</span></p><p>而这是一个关于 <span class="math inline">\(\mathrm{Ker}N\)</span>的一组基的一个线性关系，于是 <span class="math inline">\(c_{n_i}=d_{q+1}=\cdots=d_K=0\)</span>，从而所有的系数都是0，这就完成了 Jordan 标准形存在性的证明。</p><h2 id="分解唯一性的证明">分解唯一性的证明</h2><p>要证明分解的唯一性，我们只要证明对任一特征值 <span class="math inline">\(\lambda_i\)</span>，<span class="math inline">\(T\)</span> 限制在 <span class="math inline">\(U=\mathrm{Ker}(T-\lambda_i)^{n_i}\)</span>上分解为 Jordan 块的方式是唯一的。我们可以不妨假设 <span class="math inline">\(\lambda_i=0\)</span>。记 <span class="math inline">\(N=T\mid_U\)</span>，则 <span class="math inline">\(N\)</span> 是 <span class="math inline">\(U\)</span> 上的幂零线性变换。根据存在性的证明，在<span class="math inline">\(U\)</span> 上我们有如下的链图： <span class="math display">\[\begin{array}{r}v_{1,1}\rightarrowv_{1,2}\rightarrow\cdots\rightarrow v_{1,n_1}\rightarrow0.&amp;\\v_{2,1}\rightarrow v_{2,2}\rightarrow\cdots\rightarrowv_{2,n_2}\rightarrow 0.&amp;\\\cdots\cdots&amp;\\ v_{q,1}\rightarrowv_{q,2}\rightarrow\cdots\rightarrow v_{q,n_q}\rightarrow0.\end{array}\]</span> 这里每个链代表一个 Jordan 块，按照 <span class="math inline">\(n_1\geq\cdots\geq n_q\)</span>的顺序排列。我们要证明链图中行数 <span class="math inline">\(q\)</span>和行的长度 <span class="math inline">\((n_1,\ldots,n_q)\)</span>都是唯一确定的，不依赖于基的选择。</p><p>我用一个具体的例子来说明：</p><p><span class="math display">\[\begin{array}{r}\bullet\rightarrow {\color{blue}{\bullet}}\rightarrow{\color{green}{\bullet}}\rightarrow{\color{red}{\bullet}}\rightarrow 0.\\{\color{blue}{\bullet}}\rightarrow{\color{green}{\bullet}}\rightarrow{\color{red}{\bullet}}\rightarrow0.&amp;\\{\color{green}{\bullet}}\rightarrow{\color{red}{\bullet}}\rightarrow0.&amp;\\{\color{red}{\bullet}}\rightarrow 0.\\{\color{red}{\bullet}}\rightarrow 0.\end{array}\]</span></p><p>注意到在链图中，从右边数起，从第 <span class="math inline">\(1\)</span> 到第 <span class="math inline">\(i\)</span> 列，都会被 <span class="math inline">\(N^i\)</span> 变成零向量。这些向量构成了 <span class="math inline">\(\mathrm{Ker}N^i\)</span>的一组基。例如在上面例子中，<span class="math inline">\(\{{\color{red}{\bullet}} \}\)</span> 的列构成了 <span class="math inline">\(\mathrm{Ker}N\)</span> 的一组基，<span class="math inline">\(\{ {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}\)</span> 的列构成了 <span class="math inline">\(\mathrm{Ker}N^2\)</span> 的一组基，等等。</p><p>于是我们有子空间的升链： <span class="math display">\[(0)\subset\underbrace{\mathrm{Ker}N}_{\{ {\color{red}{\bullet}} \}}\subset\underbrace{\mathrm{Ker}N^2}_{\{ {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}} \subset \underbrace{\mathrm{Ker}N^3}_{\{{\color{blue}{\bullet}}\mid {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}} \subset \underbrace{\mathrm{Ker}N^4}_{\{\bullet\mid {\color{blue}{\bullet}}\mid {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}}=U.\]</span> 不难看到右边的第 <span class="math inline">\(i\)</span> 列正好构成商空间 <span class="math inline">\(\mathrm{Ker}N^{i}/\mathrm{Ker}N^{i-1}\)</span>的一组基。 <span class="math display">\[\begin{aligned}\mathrm{Ker}N: \quad &amp;  \{ {\color{red}{\bullet}} \}\\\mathrm{Ker}N^2/\mathrm{Ker}N: \quad &amp; \{ {\color{green}{\bullet}}\}\\\mathrm{Ker}N^3/\mathrm{Ker}N^2: \quad &amp; \{ {\color{blue}{\bullet}}\}\\\mathrm{Ker}N^4/\mathrm{Ker}N^3=U/\mathrm{Ker}N^3: \quad &amp; \{\bullet \}\\\end{aligned}\]</span> 所以右边第 <span class="math inline">\(i\)</span> 列的长度等于<span class="math inline">\(\dim\mathrm{Ker}N^i -\dim\mathrm{Ker}N^{i-1}\)</span>。</p><p>另一方面右边第 <span class="math inline">\(i\)</span>列的长度还等于「长度 <span class="math inline">\(\geq i\)</span>的链的个数」。所以长度恰好等于 <span class="math inline">\(k\)</span>的链，即大小恰好为 <span class="math inline">\(k\)</span> 的 Jordan块的个数，等于 <span class="math display">\[\begin{aligned}&amp;(\dim\mathrm{Ker}N^k -\dim\mathrm{Ker}N^{k-1})-(\dim\mathrm{Ker}N^{k+1} -\dim\mathrm{Ker}N^k)\\&amp;=2\dim\mathrm{Ker}N^k -\dim\mathrm{Ker}N^{k-1}-\dim\mathrm{Ker}N^{k+1}.\end{aligned}\]</span>这是一个由 <span class="math inline">\(N\)</span>完全确定的值。这就证明了分解的唯一性。</p><h1 id="进一步的思考">进一步的思考</h1><p>一个很有意思的问题是，给定</p><p><span class="math display">\[J_\lambda=\begin{pmatrix}\lambda&amp;1&amp;&amp;\\&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\lambda&amp;1\\&amp;&amp;&amp;\lambda\end{pmatrix}_{n\timesn}\]</span></p><p>为一个特征值 <span class="math inline">\(\lambda\)</span> 的 Jordan块，计算其 <span class="math inline">\(k\)</span> 次幂 <span class="math inline">\(J_\lambda^k\)</span> 的 Jordan 标准形。</p><p>当 <span class="math inline">\(\lambda\ne0\)</span> 时，</p><p><span class="math display">\[J_\lambda^k = \begin{pmatrix}\lambda^k&amp;k\lambda^{k-1}&amp;\ddots&amp;\\&amp;\lambda^k&amp;\ddots&amp;\ddots\\&amp;&amp;\ddots&amp;k\lambda^{k-1}\\&amp;&amp;&amp;\lambda^k\end{pmatrix}.\]</span></p><p>你知道怎样计算 <span class="math inline">\(J_\lambda^k\)</span>吗？记住这个技巧：把多项式 <span class="math inline">\(x^k\)</span> 在<span class="math inline">\(\lambda\)</span> 处 Taloy 展开：</p><p><span class="math display">\[x^k=(x-\lambda)^k+a_{k-1}(x-\lambda)^{k-1}+a_1(x-\lambda)+a_0,\]</span></p><p>然后代入即可。</p><p>和 Jordan 块不可分解性的证明完全一样，我们发现 <span class="math inline">\(J_\lambda^k-\lambda^k I\)</span> 的秩是 <span class="math inline">\(n-1\)</span>，因此方程组 <span class="math inline">\(J_\lambda^kX=\lambda^k X\)</span> 的解空间是 1维的，从而 <span class="math inline">\(J_\lambda^k\)</span>是不可分解的，因此其 Jordan 标准形只有一块，就是</p><p><span class="math display">\[\begin{pmatrix}\lambda^k&amp;1&amp;&amp;\\&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\lambda^k&amp;1\\&amp;&amp;&amp;\lambda^k\end{pmatrix}_{n\timesn}.\]</span></p><p>最有意思的情形发生在 <span class="math inline">\(\lambda=0\)</span>时，这个时候 Jordan 会均匀的碎裂为一些小的 Jordan 块的和。</p><p>这时 <span class="math inline">\(J_0\)</span> 是一个移位算子：</p><p><span class="math display">\[J_0:\quad v_n\rightarrowv_{n-1}\rightarrow \cdots \rightarrow v_1\rightarrow 0.\]</span></p><p>整个链只有一条。但是 <span class="math inline">\(J_0^k\)</span> 则是<span class="math inline">\(k\)</span> 步 <span class="math inline">\(k\)</span> 步地「跳」：</p><p><span class="math display">\[J_0^k:\quad \left\{\begin{array}{l}v_n\rightarrow v_{n-k}\rightarrow \cdots\rightarrow0,\\v_{n-1}\rightarrow v_{n-1-k}\rightarrow \cdots\rightarrow0,\\\cdots\\v_{n-k+1}\rightarrow v_{n-2k+1}\rightarrow \cdots\rightarrow 0.\end{array}\right.\]</span></p><p>所以 <span class="math inline">\(J_0^k\)</span> 有 <span class="math inline">\(k\)</span> 条链，每个链都是一个 Jordan 块，即<span class="math inline">\(J_0^k\)</span> 的标准形中有 <span class="math inline">\(k\)</span> 个 Jordan 块。设 <span class="math inline">\(n=qk+r\)</span>，这里 <span class="math inline">\(0\leq r&lt; k\)</span>，则这 <span class="math inline">\(k\)</span> 个 Jordan 块中有 <span class="math inline">\(r\)</span> 个是 <span class="math inline">\(q+1\)</span> 阶的，<span class="math inline">\(k-r\)</span> 个是 <span class="math inline">\(q\)</span> 阶的。</p><p>举个例子就明白了，一个 8 阶的 0 特征值 Jordan 块 <span class="math inline">\(J_0\)</span>，<span class="math inline">\(J_0^3\)</span> 的 Jordan标准形是什么样子的？这个时候 <span class="math inline">\(J_0^3\)</span>有 3 个链 <span class="math inline">\(\{v_8,v_5,v_2\}\)</span>, <span class="math inline">\(\{v_7,v_4,v_1 \}\)</span>, <span class="math inline">\(\{v_6,v_3\}\)</span>，所以 <span class="math inline">\(J_0^3\)</span> 的 Jordan 标准形有 2 个 3 阶的Jordan 块和 1 个 2 阶的 Jordan 块。</p><p>总结一下：零特征值的 Jordan块的高次幂一定会分裂，而且是尽可能均匀的分裂；非零特征值的 Jordan块的任意次幂都不会分裂。</p><p>一个不可约的代数结构，在某种限制或者扩张的意义下却能均匀的「碎裂」，这是代数学中一个常见而重要的现象。比如设<span class="math inline">\(f\)</span> 是一个有理数域 <span class="math inline">\(\mathbb{Q}\)</span> 上的不可约多项式，<span class="math inline">\(F\)</span> 是 <span class="math inline">\(\mathbb{Q}\)</span> 的一个正规扩域，则如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(F\)</span> 上是可约的，那么 <span class="math inline">\(f\)</span>必然分解成一些次数相同的多项式的乘积：</p><p><span class="math display">\[f=f_1f_2\cdots f_r,\quad \degf_1=\cdots=\deg f_r.\]</span></p><p>类似的现象还有代数数论中素理想的分解，群表示论中不可约表示（在诱导和限制下） 的分解，代数几何中不可约代数簇的分解等等。</p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>矩阵空间的子空间</title>
      <link href="space-of-matrices/"/>
      <url>space-of-matrices/</url>
      
        <content type="html"><![CDATA[<p>在数学里面经常可以提出这样一些问题：它们叙述起来很简单，答案看起来也很显然，但是要仔细证明却非常困难。即使是线性代数这样的「入门课」中也不缺少这样的问题：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>设域 <span class="math inline">\(\mathbb{F}\)</span> 上的所有 <span class="math inline">\(n\)</span> 阶矩阵构成的向量空间为 <span class="math inline">\({\rm Mat}_n(\mathbb{F})\)</span>，<span class="math inline">\(M\)</span> 是 <span class="math inline">\({\rmMat}_n(\mathbb{F})\)</span> 的一个子空间。</p><ol type="1"><li>如果 <span class="math inline">\(M\)</span>中所有矩阵关于矩阵乘法两两可以交换，那么 <span class="math inline">\(M\)</span> 的维数最大是多少？</li><li>如果 <span class="math inline">\(M\)</span> 中所有矩阵的秩都不超过<span class="math inline">\(r\)</span>，这里 <span class="math inline">\(0&lt;r&lt;n\)</span>，那么 <span class="math inline">\(M\)</span> 的维数最大是多少？</li><li>如果 <span class="math inline">\(M\)</span>中所有矩阵都是幂零的，那么 <span class="math inline">\(M\)</span>的维数最大是多少？</li><li>如果 <span class="math inline">\(M\)</span>中所有非零矩阵都是可逆矩阵，那么 <span class="math inline">\(M\)</span>的维数最大是多少？</li></ol></div><span id="more"></span><p>我是在几年前一个偶然的时刻自己想到了这几个问题，那个时候我已经本科毕业了，不是初学线性代数的新手了，但是苦思冥想了很久，结果一个也没做出来。我当时很惊讶，这么有趣而不平凡的问题居然在我身边潜伏了那么久而没有注意到。长久以来我们一直都是把各种习题集做的滚瓜烂熟，然后考试拿个高分就自以为学的很好了，很少自己去发现问题。我可以肯定的讲这几个问题在任何本科线性代数的教材中都没有提到，但是教材上不讲并不是我们无视它们的理由。于是我开始查阅资料，发现这四个问题的确是有难度的问题，要完全弄懂并不容易，但是这种探索本身就是一种令人难忘而愉悦的经历。</p><p>接下来将依次介绍前三个问题的解答，它们综合使用了各种各样的线性代数的技巧，这些技巧如果一步步拆开来，其实也很普通。总之这三个问题是对读者基本功的一次很好的检验。至于第四个问题嘛… 不会做很正常，会做才不正常。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>问题的提法中对域 <span class="math inline">\(\mathbb{F}\)</span>没有什么限制，实际上前三个问题的答案确实与域无关，只有第四个问题是例外。但是如果要让证明对任何域<span class="math inline">\(\mathbb{F}\)</span>都适用那就要花不少心思，旁生不少枝节。为了让文章读起来不那么晦涩，我适当放宽了域的条件，这样证明简明很多。</p></div><h1 id="交换子空间的最大维数">交换子空间的最大维数</h1><p>如果 <span class="math inline">\(M\)</span>中的矩阵两两可以交换，我们来猜猜 <span class="math inline">\(M\)</span>的维数最大可能多少。首先很容易想到所有的对角矩阵是两两交换的，而所有对角矩阵构成的子空间维数是<span class="math inline">\(n\)</span>，所以答案不会小于 <span class="math inline">\(n\)</span>。</p><p>但是实际上还可以更大，下面的构造是最优的：（<span class="math inline">\(N\)</span> 是任意子矩阵）</p><p><span class="math display">\[\begin{pmatrix}\lambdaI_m&amp;N\\0&amp;\lambda I_m\end{pmatrix}\ (n=2m),\quad\begin{pmatrix}\lambda I_m&amp;N\\0&amp;\lambda I_{m+1}\end{pmatrix}\(n=2m+1).\]</span></p><p>这个结论于 1905 年被 Schur 所证明：</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(M\)</span> 的维数最大为 <span class="math inline">\(\left[\frac{n^2}{4}\right]+1\)</span>，其中 <span class="math inline">\([\cdot]\)</span> 为高斯取整函数。</p></div><p>证明：首先假设 <span class="math inline">\(\mathbb{F}\)</span>是代数闭域。对 <span class="math inline">\(n\)</span> 归纳，<span class="math inline">\(n=1\)</span> 时结论显然成立，设小于 <span class="math inline">\(n\)</span> 的时候结论成立，来看 <span class="math inline">\(n\)</span> 的情形。</p><p>由于 <span class="math inline">\(\mathbb{F}\)</span> 是代数闭域且<span class="math inline">\(M\)</span>中的矩阵两两可以交换，因此存在可逆矩阵 <span class="math inline">\(P\in{\rm Mat}_n(\mathbb{F})\)</span> 使得 <span class="math inline">\(P^{-1}MP\)</span> 中的矩阵都是上三角的，而 <span class="math inline">\(M\)</span> 和 <span class="math inline">\(P^{-1}MP\)</span>是同构的空间，因此我们不妨一开始就假定 <span class="math inline">\(M\)</span> 中的矩阵都是上三角矩阵。</p><p>对任何 <span class="math inline">\(A\in M\)</span>，记 <span class="math inline">\(f(A)\)</span> 为 <span class="math inline">\(A\)</span> 左上角的 <span class="math inline">\(n-1\)</span> 阶子矩阵，<span class="math inline">\(g(A)\)</span> 为 <span class="math inline">\(A\)</span> 右下角的 <span class="math inline">\(n-1\)</span> 阶子矩阵，则 <span class="math inline">\(f\)</span> 和 <span class="math inline">\(g\)</span> 都是从 <span class="math inline">\({\rmMat}_n(\mathbb{F})\)</span> 到 <span class="math inline">\({\rmMat}_{n-1}(\mathbb{F})\)</span> 的线性映射。<span class="math inline">\(f(M)=\{f(A)\ |\ A\in M\}\)</span> 和 <span class="math inline">\(g(M)=\{g(A)\ |\ A\in M\}\)</span> 都是 <span class="math inline">\({\rm Mat}_{n-1}(\mathbb{F})\)</span>的乘法交换子空间，因此由归纳假设 <span class="math display">\[\dimf(M)\leq\left[\frac{(n-1)^2}{4}\right]+1,\quad \dimg(M)\leq\left[\frac{(n-1)^2}{4}\right]+1.\]</span></p><p>不难看出 <span class="math inline">\(\ker f\)</span> 中的元素形如<span class="math inline">\(\begin{pmatrix}\mathbf{0}_{n\times(n-1)}&amp;\alpha\end{pmatrix}\)</span>，<span class="math inline">\(\ker g\)</span> 中的元素形如 <span class="math inline">\(\begin{pmatrix}\beta'\\\mathbf{0}_{(n-1)\timesn}\end{pmatrix}\)</span>。这里 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> 都是 <span class="math inline">\(n\times1\)</span> 向量，两者交换说明 <span class="math inline">\(\beta'\alpha=0\)</span>。设 <span class="math inline">\((\beta_1',\ldots,\beta_s')\)</span> 取自<span class="math inline">\(\ker g\)</span>的一组基并且排成行矩阵的形式，即设 <span class="math display">\[L=\left(\begin{array}{c}\beta_1'\\\beta_2' \\\vdots\\\beta_s' \\\end{array}\right),\]</span>则<span class="math inline">\(\ker f\)</span> 中的元素都是齐次方程组 <span class="math inline">\(LX=0\)</span> 的解，因此 <span class="math inline">\(\dim\ker f+\dim\ker g\leq n\)</span>，从而 <span class="math display">\[\begin{align*} \dim M&amp;=\dim \ker f+\dimf(M)=\dim\ker g+\dim g(M)\\&amp;\leq\frac{\dim\ker f+\dim\kerg}{2}+\left[\frac{(n-1)^2}{4}\right]+1\\&amp;\leq\frac{n}{2}+\left[\frac{(n-1)^2}{4}\right]+1.\end{align*}\]</span>这时需要分情况讨论：不论 <span class="math inline">\(n=2k\)</span>是偶数还是 <span class="math inline">\(n=2k+1\)</span> 是奇数，我们总有<span class="math display">\[\frac{n}{2}+\left[\frac{(n-1)^2}{4}\right]+1 &lt;k^2 + 2,\]</span> 因此 <span class="math inline">\(\dim M\leq k^2+1\leq\left[\frac{n^2}{4}\right]+1\)</span>。</p><p>在 <span class="math inline">\(\mathbb{F}\)</span>不是代数闭域的情形，显然答案不会超过 <span class="math inline">\(\left[\frac{n^2}{4}\right]+1\)</span>，但是我们开头的构造的例子是在<span class="math inline">\(\mathbb{F}\)</span>内的，它取到了这个最大值，因此结论依然成立。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>有更简单的方式可以得出 <span class="math inline">\(\dim\ker f +\dim\ker g\leq n\)</span>。利用内积 <span class="math inline">\((\alpha,\beta) = \beta'\alpha\)</span> 是非退化的双线性型，以及 <span class="math inline">\(\ker f\)</span> 和 <span class="math inline">\(\ker g\)</span> 在这个双线性型下互相正交即可。</p></div><h1 id="m-中矩阵秩都不超过-r-时-m-的最大维数"><span class="math inline">\(M\)</span> 中矩阵秩都不超过 <span class="math inline">\(r\)</span> 时 <span class="math inline">\(M\)</span> 的最大维数</h1><p>第二个问题的答案比较好猜，就是 <span class="math inline">\(rn\)</span>，取所有后 <span class="math inline">\(n-r\)</span> 行元素均为 0的矩阵构成的向量空间即可，但是不太好证明。</p><p>证明的困难之处在于这个域 <span class="math inline">\(\mathbb{F}\)</span> 是任意的，如果 <span class="math inline">\(\mathbb{F}\)</span> 是实数域或者复数域这样有“内积” 的性质比较好的域，那么证明就简单很多。我们接下来就假定 <span class="math inline">\(\mathbb{F}\)</span>是实数域，对于一般的情形我把它留给</p><blockquote><p>H.landers 1962, On spaces of linear transformation of boundedrank.</p></blockquote><p>首先可以不妨假设 <span class="math inline">\(M\)</span>中存在一个形如 <span class="math display">\[A=\begin{pmatrix}I_r&amp;0\\0&amp;0\end{pmatrix}\]</span>的矩阵 （想一想，为什么？），于是我们有下面的结论：</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理2.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(M\)</span> 中的矩阵都形如 <span class="math display">\[\begin{pmatrix}B_{11}&amp;B_{12}\\B_{21}&amp;0\end{pmatrix}.\]</span>这里 <span class="math inline">\(B_{11}\)</span> 是 <span class="math inline">\(r\times r\)</span> 矩阵，且 <span class="math inline">\(B_{21}B_{12}=0\)</span>.</p></div><p>引理的证明：对任意的 <span class="math inline">\(B\in M\)</span>，设<span class="math display">\[B=\begin{pmatrix}B_{11}&amp;B_{12}\\B_{21}&amp;B_{22}\end{pmatrix},\]</span>那么对任何实数 <span class="math inline">\(t\)</span>，<span class="math inline">\(tA+B\)</span> 仍然是 <span class="math inline">\(M\)</span> 中的矩阵，其秩不超过 <span class="math inline">\(r\)</span>，所以其任何 <span class="math inline">\(r+1\)</span> 阶子式必为 <span class="math inline">\(0\)</span>， 即 <span class="math display">\[\Delta(t)=\begin{vmatrix}tI_r+B_{11}&amp;\beta_j\\\alpha_i&amp;b_{ij}\end{vmatrix}=0.\]</span>这里 <span class="math inline">\(b_{ij}\)</span> 表示<span class="math inline">\(B_{22}\)</span> 的第 <span class="math inline">\((i,j)\)</span> 个元素，<span class="math inline">\(\alpha_i\)</span> 表示 <span class="math inline">\(B_{21}\)</span> 的第 <span class="math inline">\(i\)</span> 行， <span class="math inline">\(\beta_j\)</span> 表示 <span class="math inline">\(B_{12}\)</span> 的第 <span class="math inline">\(j\)</span> 列。</p><p><span class="math inline">\(\Delta(t)\)</span> 是关于 <span class="math inline">\(t\)</span> 的多项式，由于它必须恒等于 <span class="math inline">\(0\)</span>，所以首项 <span class="math inline">\(t^r\)</span> 的系数 <span class="math inline">\(b_{ij}=0\)</span>，从而由 <span class="math inline">\((i, j)\)</span> 的任意性有 <span class="math inline">\(B_{22}=0\)</span>。下面来求它的 <span class="math inline">\(t^{r-1}\)</span> 次项系数。</p><p>由于讨论是在实数域上，从而存在无穷多个 <span class="math inline">\(t\)</span> 使得矩阵 <span class="math inline">\(tI_r+B_{11}\)</span> 可逆，对这些 <span class="math inline">\(t\)</span> 利用行列式的 <a href="https://en.wikipedia.org/wiki/Schur_complement">Schur补公式</a>，我们有 <span class="math display">\[\begin{align*}\Delta(t)&amp;=|tI_r+B_{11}|\cdot(0-\alpha_i(tI_r+B_{11})^{-1}\beta_j)\\&amp;=-\alpha_i(tI_r+B_{11})^\ast\beta_j.\end{align*}\]</span>这里 <span class="math inline">\((tI_r+B_{11})^\ast\)</span> 表示矩阵<span class="math inline">\(tI_t+B_{11}\)</span> 的伴随矩阵。</p><p>由于 <span class="math inline">\(\Delta(t)=-\alpha_i(tI_r+B_{11})^\ast\beta_j\)</span>两边都是关于 <span class="math inline">\(t\)</span>的多项式而且对无穷多个 <span class="math inline">\(t\)</span>成立此等式成立，因此必然是恒等式。注意在伴随矩阵 <span class="math inline">\((tI_r+B_{11})^\ast\)</span> 的各个元素中，<span class="math inline">\(t^{r-1}\)</span> 项只出现在对角线上，且系数都是<span class="math inline">\(1\)</span>，因此 <span class="math inline">\(\Delta(t)\)</span> 的 <span class="math inline">\(r-1\)</span> 次项系数为 <span class="math inline">\(-\alpha_i\beta_j=0\)</span>，因此 <span class="math inline">\(B_{21}B_{12}=0\)</span>，引理成立。</p><p>现在考虑 <span class="math inline">\({\rm Mat}_n(\mathbb{R})\)</span>的子空间 <span class="math display">\[J=\left\{\begin{pmatrix}0&amp;P\\P'&amp;Q\end{pmatrix}\midP\in {\rm Mat}_{r\times(n-r)}(\mathbb{R}),\, Q\in {\rmMat}_{n-r}(\mathbb{R})\right\}.\]</span></p><p>于是 <span class="math inline">\(M\cap J=(0)\)</span>，因此 <span class="math inline">\(M+J\)</span> 是直和，从而 <span class="math inline">\(\dim M+\dim J\leq n^2\)</span>，再由 <span class="math inline">\(\dim J=n(n-r)\)</span> 即得 <span class="math inline">\(\dim M\leq rn\)</span>。</p><p>注意这里利用了实数域内积的正定性： 实矩阵 <span class="math inline">\(P'P=0\)</span> 当且仅当 <span class="math inline">\(P=0\)</span>，对复数域的情形可以用厄米特内积代替。对一般的域<span class="math inline">\(\mathbb{F}\)</span> 是没有内积的概念的，但是我们有迹函数 <span class="math display">\[{\rmMat}_n(\mathbb{F})\times {\rm Mat}_n(\mathbb{F})\rightarrow\mathbb{F}:\quad (A,B)\rightarrow\mathrm{tr}(AB).\]</span>这个非退化的双线性型可以代替内积，只是论证略麻烦。</p><h1 id="m-中矩阵都是幂零矩阵"><span class="math inline">\(M\)</span>中矩阵都是幂零矩阵</h1><p>这种情形答案也是很好猜的：所有严格上三角矩阵组成的子空间，其维数是<span class="math inline">\(n(n-1)/2\)</span>。</p><p>我们在 <span class="math inline">\({\rmchar}\,\mathbb{F}\ne2\)</span> 的条件下讨论。（当然特征是 2结论是一样的，不过证明要绕点弯路）</p><p>首先是一个小小的引理：</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.1</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(A,B,A+B\)</span> 都是幂零矩阵，则 <span class="math inline">\(\mathrm{tr}(AB)=0\)</span>。</p></div><p>引理证明很简单，这里省略。</p><p>其次我们需要迹函数的一些性质：<span class="math inline">\((A,B)\rightarrow\mathrm{tr}(AB)\)</span> 是一个<span class="math inline">\({\rm Mat}_n(\mathbb{F})\)</span>上的非退化的双线性函数，这里非退化的意思是如果某个 <span class="math inline">\(A\in{\rm Mat}_n(\mathbb{F})\)</span> 使得对任何<span class="math inline">\(B\in{\rm Mat}_n(\mathbb{F})\)</span> 有<span class="math inline">\(\mathrm{tr}(AB)=0\)</span> 成立的话，则<span class="math inline">\(A=0\)</span>。</p><p>设 <span class="math inline">\(V\)</span> 是 <span class="math inline">\({\rm Mat}_n(\mathbb{F})\)</span> 的子空间，定义<span class="math inline">\(V\)</span> 在迹函数下的正交补空间 <span class="math inline">\(V^{\bot}\)</span> 为</p><p><span class="math display">\[V^{\bot}=\{ B\in{\rm Mat}_n(\mathbb{F})\\left|\ \mathrm{tr}(AB)=0,\ \forall A\in V\right.\}.\]</span></p><p>虽然未必有 <span class="math inline">\(V\capV^{\bot}=(0)\)</span>，但是总是有 <span class="math display">\[\dimV+\dim V^{\bot}=\dim{\rm Mat}_n(\mathbb{F})=n^2.\]</span>（这是非退化双线性型的基本结论）</p><p>设 <span class="math inline">\(M_1\)</span> 是 <span class="math inline">\(M\)</span>中所有严格上三角矩阵组成的集合，很容易验证 <span class="math inline">\(M_1\)</span> 是一个子空间；任取子空间 <span class="math inline">\(N\subset M\)</span> 使得 <span class="math inline">\(M=M_1\oplus N\)</span>，则 <span class="math inline">\(N\)</span> 中的非零矩阵都不是上三角矩阵，否则若<span class="math inline">\(A\in N\)</span> 是上三角矩阵，而 <span class="math inline">\(A\)</span>又是幂零矩阵，那么就必须是严格上三角矩阵，从而 <span class="math inline">\(A\in M_1\)</span>，这与 <span class="math inline">\(M_1\)</span> 和 <span class="math inline">\(N\)</span> 是直和矛盾。</p><p>我们来考虑 <span class="math inline">\(M_1\)</span> 在 <span class="math inline">\(\mathrm{tr}(,)\)</span> 下的正交补。</p><p>设 <span class="math inline">\(U\)</span>是所有上三角矩阵组成的集合，由于上三角矩阵和严格上三角矩阵的乘积是严格上三角矩阵，严格上三角矩阵的迹为0，因此 <span class="math inline">\(U\subset M_1^{\bot}\)</span>。</p><p>把引理用在 <span class="math inline">\(A\in M_1\)</span> 和 <span class="math inline">\(B\in N\)</span> 上我们得到 <span class="math inline">\(N\subset M_1^{\bot}\)</span>。然而我们已经说明了<span class="math inline">\(U+N\)</span> 是直和，因此 <span class="math inline">\(U\oplus N\subset M_1^{\bot}\)</span>，从而 <span class="math display">\[\dim U+\dim N\leq n^2-\dim M_1.\]</span> 注意<span class="math inline">\(\dim U=\frac{n(n+1)}{2}\)</span>，这就推出<span class="math display">\[\dim M=\dim N+\dim M_1\leq\frac{n(n-1)}{2}.\]</span> 实际上可以证明如果 <span class="math inline">\(\dim M=\frac{n(n-1)}{2}\)</span>，则存在可逆矩阵<span class="math inline">\(P\)</span> 使得 <span class="math inline">\(P^{-1}MP\)</span>都是严格上三角矩阵，不过这需要更复杂的分析，本文就不再写了。</p><h1 id="m-中的非零矩阵都是可逆矩阵"><span class="math inline">\(M\)</span> 中的非零矩阵都是可逆矩阵</h1><p>最后这个问题是最重要的一个，也是最难回答的一个，如果你自己做不出来也不用灰心，这是Adams 在 1962 年的论文 <a href="http://www.ams.org/journals/bull/1962-68-01/S0002-9904-1962-10693-4/S0002-9904-1962-10693-4.pdf">Vectorfields on spheres</a> 中证明的经典结论，这篇论文也是代数 K-理论的开山之作。</p><p>首先这个问题的答案依赖于域 <span class="math inline">\(\mathbb{F}\)</span>。在复数域上，如果 <span class="math inline">\(M\)</span> 的维数大于1，从中任取两个线性无关的矩阵 <span class="math inline">\(A,B\)</span>，则对任何复数 <span class="math inline">\(t\)</span>，<span class="math inline">\(A+tB\)</span>是非零矩阵因而可逆，这显然不可能，因此 <span class="math inline">\(M\)</span> 的维数只能是 1 （比如取所有形如 <span class="math inline">\(\lambda I_n\)</span> 的矩阵）。</p><p>在实数域上，答案是非常难以猜到的，叫做 Radon-Hurwitz 数：设 <span class="math inline">\(n=2^ab\)</span>，<span class="math inline">\(b\)</span> 是奇数，<span class="math inline">\(a=c+4d\)</span>，<span class="math inline">\(0\leqc&lt;4\)</span>，定义 <span class="math inline">\(\rho(n)=2^c+8d\)</span>，则 <span class="math inline">\(M\)</span> 的维数最大是 <span class="math inline">\(\rho(n)\)</span>。</p><p>证明这个结论分两步，首先用代数 K- 理论的知识证明 <span class="math inline">\(M\)</span> 的维数不会超过 <span class="math inline">\(\rho(n)\)</span>，然后用 Clifford代数的表示构造一个维数为 <span class="math inline">\(\rho(n)\)</span>的子空间。整个过程要用到非常多的数学知识以至于要完整写下来需要一本书的篇幅，这是本文力所不及的。</p><h1 id="结语">结语</h1><p>其实类似的问题还可以提出更多，比如 <span class="math inline">\(M\)</span> 中的非零矩阵的秩都不小于 <span class="math inline">\(r\)</span>，这里 <span class="math inline">\(0&lt;r&lt;n\)</span> 是个给定的正整数，那么 <span class="math inline">\(M\)</span> 的维数最大是多少？（答案仍然和Radon-Hurwitz数有关）你可以试着自己提出一些这样的问题，然后尝试给出它们的解答，遇到困难再去查阅资料，相信一定会有收获的。</p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>国际象棋棋盘的多米诺骨牌密铺</title>
      <link href="Pfaffian-and-chessboard-tiling/"/>
      <url>Pfaffian-and-chessboard-tiling/</url>
      
        <content type="html"><![CDATA[<p>下面的问题与统计物理中的 Dimer 格点模型有关：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>用 <span class="math inline">\(1\times2\)</span> 的多米诺骨牌密铺一张 <span class="math inline">\(8\times8\)</span>的国际象棋棋盘，有多少种不同的方法？</p></div><p>下图是其中一种：</p><p><img src="/images/pfaff/chessboard.svg" class="fig"></p><p>答案是 12988816，非常大的一个数字，显然不可能是逐个枚举数出来的。1961年德国物理学家 Kasteleyn借助线性代数的工具首先解决了这个问题，本文就来介绍他的方法。</p><span id="more"></span><h1 id="反对称矩阵的-pfaffian">反对称矩阵的 Pfaffian</h1><p>我们从一个线性代数的结论说起，先来看一个 4 阶反对称矩阵的行列式：</p><p><span class="math display">\[\det\begin{pmatrix}0&amp;a_{12}&amp;a_{13}&amp;a_{14}\\-a_{12}&amp;0&amp;a_{23}&amp;a_{24}\\-a_{13}&amp;-a_{23}&amp;0&amp;a_{34}\\-a_{14}&amp;-a_{24}&amp;-a_{34}&amp;0\end{pmatrix}=(a_{12}a_{34}-a_{13}a_{24}+a_{14}a_{23})^2.\]</span>你发现了什么？这个反对称矩阵的行列式是一个多项式的平方，而且观察右边每个单项式的下标你发现，它们分别是<span class="math inline">\(\{(12),(34)\}\)</span>，<span class="math inline">\(\{(14),(23)\}\)</span>，<span class="math inline">\(\{(13),(24)\}\)</span>，恰好跑遍集合 <span class="math inline">\(\{1,2,3,4\}\)</span> 的所有匹配！</p><p>这个结论不是偶然的，实际上对任何 <span class="math inline">\(2n\)</span> 阶反对称矩阵 <span class="math inline">\(A\)</span>，<span class="math inline">\(A\)</span>的行列式都可以表示为一个多项式的平方，这个多项式叫做 Pfaffian多项式，记作 <span class="math inline">\(\mathrm{pf}(A)\)</span>。<span class="math inline">\(\mathrm{pf}(A)\)</span> 中的单项式与集合 <span class="math inline">\([2n]=\{1,2,\ldots,2n\}\)</span>的匹配一一对应。</p><p>那么奇数阶反对称矩阵呢？它们的行列式都是 0，所以不考虑它们。</p><p>我们来给出 <span class="math inline">\(\mathrm{pf}(A)\)</span>的定义：考虑一种把 <span class="math inline">\([2n]\)</span>两两配对（从而分成 <span class="math inline">\(n\)</span> 对）的方式：<span class="math display">\[\pi =(i_1,j_1)(i_2,j_2)\cdots(i_n,j_n).\]</span> <span class="math inline">\(\pi\)</span> 叫做集合 <span class="math inline">\([2n]\)</span>的一个匹配，它可以用一个置换来表示，仍然记作 <span class="math inline">\(\pi\)</span>： <span class="math display">\[\pi=\begin{pmatrix}1&amp;2&amp;3&amp;4&amp;\cdots&amp;2n-1&amp;2n\\i_1&amp;j_1&amp;i_2&amp;j_2&amp;\cdots&amp;i_n&amp;j_n\end{pmatrix}.\]</span>定义 <span class="math inline">\(\pi\)</span> 的权为 <span class="math display">\[\mathrm{wt}(\pi)=\text{sgn}(\pi)\cdota_\pi.\]</span> 其中 <span class="math inline">\(\text{sgn}(\pi)\)</span> 就是置换 <span class="math inline">\(\pi\)</span> 的符号，偶置换时为 <span class="math inline">\(+1\)</span>，奇置换时为 <span class="math inline">\(-1\)</span>， <span class="math display">\[a_\pi=a_{i_1j_1}a_{i_2j_2}\cdotsa_{i_nj_n}.\]</span> 于是 <span class="math inline">\(\mathrm{wt}(\pi)\)</span> 是一个次数为 <span class="math inline">\(n\)</span> 的单项式。</p><p><span class="math inline">\(\mathrm{wt}(\pi)\)</span>的定义是合理无歧义的吗？注意一个匹配 <span class="math inline">\(\pi\)</span>可以有多种不同的置换表示：你可以按任意的顺序排列这些 <span class="math inline">\((i_k,j_k)\)</span> 对，比如 <span class="math display">\[\pi=\begin{pmatrix}1&amp;2&amp;3&amp;4&amp;\cdots&amp;2n-1&amp;2n\\i_2&amp;j_2&amp;i_3&amp;j_3&amp;\cdots&amp;i_1&amp;j_1\end{pmatrix}.\]</span>或是交换某一对中 <span class="math inline">\(i_k\)</span> 和 <span class="math inline">\(j_k\)</span> 的位置： <span class="math display">\[\pi=\begin{pmatrix}1&amp;2&amp;\cdots&amp;2k-1&amp;2k&amp;\cdots&amp;2n-1&amp;2n\\i_1&amp;j_1&amp;\cdots&amp;j_k&amp;i_k&amp;\cdots&amp;i_n&amp;j_n\end{pmatrix}.\]</span>不难验证，虽然不同的置换表示给出的 <span class="math inline">\(\text{sgn}(\pi)\)</span> 和 <span class="math inline">\(a_\pi\)</span> 的值可能不同，但是二者的乘积 <span class="math inline">\(\mathrm{wt}(\pi)\)</span>的值总是一样的。比如把某个 <span class="math inline">\((i_k,j_k)\)</span> 改写成 <span class="math inline">\((j_k,i_k)\)</span>，那么 <span class="math inline">\(\text{sgn}(\pi)\)</span> 和 <span class="math inline">\(a_\pi\)</span> 都同时变号，乘积保持不变。总之<span class="math inline">\(\mathrm{wt}(\pi)\)</span> 的定义只与匹配<span class="math inline">\(\pi\)</span>有关，并不依赖于具体置换的选择。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(\mathcal{M}_{2n}\)</span> 为 <span class="math inline">\([2n]\)</span> 的所有匹配组成的集合，矩阵 <span class="math inline">\(A\)</span> 的 Pfaffian 多项式 <span class="math inline">\(\text{pf}(A)\)</span> 定义为 <span class="math display">\[\text{pf}(A) =\sum_{\pi\in\mathcal{M}_{2n}}\mathrm{wt}(\pi).\]</span></p></div><p>现在我们可以叙述本节的主要结论了：</p><div id="pfaff" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(2n\)</span> 阶反对称矩阵，则 <span class="math inline">\(\det A=[\text{pf}(A)]^2\)</span>。</p></div><p><strong>证明</strong>：根据行列式的定义， <span class="math display">\[\det A=\sum_{\sigma\inS_{2n}}\text{sgn}(\sigma)a_{\sigma}=\sum_{\sigma\inS_{2n}}\text{sgn}(\sigma) a_{1\sigma(1)}a_{2\sigma(2)}\cdots.\]</span></p><p>回忆任何置换 <span class="math inline">\(\sigma\)</span>都可以表示为若干不相交的轮换的乘积： <span class="math display">\[\sigma= (i_1i_2\cdots i_k)(j_1j_2\cdots j_l)\cdots.\]</span> 其中 <span class="math inline">\(k,l,\ldots\)</span> 是各个轮换的长度。设 <span class="math inline">\(\mathcal{E}_{2n}\)</span>为轮换长度都是偶数的那些置换组成的集合，我们要证明在上述行列式的求和中，<span class="math inline">\(\sigma\)</span> 只跑遍 <span class="math inline">\(\mathcal{E}_{2n}\)</span>，不属于 <span class="math inline">\(\mathcal{E}_{2n}\)</span>的那些置换整体对行列式的贡献为 0。</p><p>分两种情况：</p><ol type="1"><li>如果 <span class="math inline">\(\sigma\)</span>包含一个不动点：<span class="math inline">\(\sigma(i)=i\)</span>，则由于<span class="math inline">\(a_{i\sigma(i)}=0\)</span> 从而 <span class="math inline">\(\sigma\)</span> 对行列式的贡献为 0。</li><li>如果 <span class="math inline">\(\sigma\)</span>没有不动点，但是包含长度为奇数的轮换，选择其中含有最小元素的那个，设为<span class="math inline">\(C=(i_1i_2\cdots i_k)\)</span>，这里 <span class="math inline">\(k\)</span> 为奇数且大于等于 3。定义置换 <span class="math inline">\(\sigma'\)</span> 如下：<span class="math inline">\(\sigma'\)</span> 的其它轮换与 <span class="math inline">\(\sigma\)</span> 完全相同，只是把 <span class="math inline">\(C\)</span> 整个倒过来变成 <span class="math inline">\((i_k\cdots i_2i_1)\)</span>。显然 <span class="math inline">\(\sigma'\)</span> 对应的和项与 <span class="math inline">\(\sigma\)</span> 抵消，而且如果对 <span class="math inline">\(\sigma'\)</span> 执行此操作又会回到 <span class="math inline">\(\sigma\)</span>。于是所有没有不动点，而且包含长度是奇数的轮换的置换可以两两配对抵消。</li></ol><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span><span class="math inline">\(\sigma=(1\,3)(2\,4\,6)(5\,7\,8)(9\,10)\)</span> 有2 个长度为奇数的轮换 <span class="math inline">\((246)\)</span> 和 <span class="math inline">\((578)\)</span>，这两个轮换中最小的元素是 <span class="math inline">\(2\)</span>，它出现在 <span class="math inline">\((2\,4\,6)\)</span> 中，所以 <span class="math inline">\(\sigma'=(1\,3)(6\,4\,2)(5\,7\,8)(9\,10)\)</span>。</p></div><p>这就证明了在行列式的求和中，我们只需要考虑那些轮换分解长度都是偶数的置换。</p><p>于是为了证明 <span class="math inline">\(\det A=[{\rmpf}(A)]^2\)</span>，只要证明 <span class="math display">\[\sum_{\pi\in\mathcal{M}_{2n}}\sum_{\pi'\in\mathcal{M}_{2n}}{\rmwt}(\pi){\rm wt}(\pi')=\sum_{\sigma\in\mathcal{E}_{2n}}{\rmsgn}(\sigma) a_\sigma.\]</span></p><p>为此我们来建立一个双射 <span class="math display">\[\mathcal{M}_{2n}\times\mathcal{M}_{2n}\rightarrow \mathcal{E}_{2n}:\quad(\pi,\pi')\rightarrow \sigma.\]</span>而且这个双射还保持权的相等，即 <span class="math display">\[\mathrm{wt}(\pi)\cdot\mathrm{wt}(\pi')=\text{sgn}(\sigma)a_{\sigma}.\]</span>这样就证明了定理。</p><p>对任何两个匹配 <span class="math inline">\((\pi,\pi')\in\mathcal{M}_{2n}\times\mathcal{M}_{2n}\)</span>，我们把它俩画在同一张图上，图的顶点集合就是<span class="math inline">\([2n]\)</span>，两个顶点 <span class="math inline">\(i,j\)</span> 如果在 <span class="math inline">\(\pi\)</span>中配成一对就在它们之间连一条红色边，或者如果 <span class="math inline">\(i,j\)</span> 在 <span class="math inline">\(\pi'\)</span>中配成一对就在它们之间连一条蓝色边。这样我们得到的是一个每个顶点恰好有一条红边和一条蓝边的图，即每个顶点度数都是2 的正则图。这个图一定可以表示为若干条不相交的回路的并 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，在一个回路中，红边和蓝边是交错出现的，因此每个回路的长度都是偶数。</p><p>设 <span class="math inline">\(C\)</span> 是这样的一条回路，<span class="math inline">\(i_1\)</span> 是 <span class="math inline">\(C\)</span> 中最小的元素，从 <span class="math inline">\(i_1\)</span> 出发，沿着红色的边，即 <span class="math inline">\(\pi\)</span> 的方向绕 <span class="math inline">\(C\)</span> 一圈： <span class="math display">\[i_1\,{\color{red}{\xrightarrow{\pi}}}\,i_2\,{\color{blue}{\xrightarrow{\pi'}}}\,i_3\,{\color{red}{\xrightarrow{\pi}}}\,\cdots\,{\color{blue}{\xrightarrow{\pi'}}}\,i_1.\]</span>这样得到了一个轮换 <span class="math inline">\((i_1i_2\cdotsi_k)\)</span>。对每个回路都这样做，我们就得到了一组轮换，与 <span class="math inline">\((\pi,\pi')\)</span> 对应的置换 <span class="math inline">\(\sigma\)</span>就定义为所有这些轮换的乘积。由于这些回路互不相交，这些轮换两两交换，所以我们不必关心它们相乘的顺序，任何顺序都给出同样的<span class="math inline">\(\sigma\)</span>。</p><p>逆映射也很显然，对任何 <span class="math inline">\(\sigma\in\mathcal{E}_{2n}\)</span>，在 <span class="math inline">\(\sigma\)</span> 的每个轮换 <span class="math inline">\(C\)</span> 中，找到最小的 <span class="math inline">\(i_1\in C\)</span>，设 <span class="math inline">\(C=(i_1i_2\cdots i_k)\)</span>，那么依次规定 <span class="math display">\[i_1\,{\color{red}{\xrightarrow{\pi}}}\,i_2\,{\color{blue}{\xrightarrow{\pi'}}}\,i_3\,{\color{red}{\xrightarrow{\pi}}}\,\cdots\,{\color{blue}{\xrightarrow{\pi'}}}\,i_1.\]</span>即可。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>下面是将 <span class="math inline">\(2n=12\)</span>，<span class="math inline">\(\sigma=(1\,3\,4\,5\,7\,10)(2\,6\,9\,8)(11\,12)\)</span>对应到两个匹配 <span class="math inline">\(\pi,\pi'\)</span>的示意图：</p><p><img src="/images/pfaff/matching.svg" class="fig" width="500"></p></div><p>最后我们来验证这个对应保持权的相等：设 <span class="math inline">\(\sigma\)</span> 的轮换分解式为 <span class="math display">\[\sigma=(i_1i_2\cdots i_{2k-1}i_{2k})(j_1j_2\cdotsj_{2l-1}j_{2l})\cdots.\]</span> 其中 <span class="math inline">\(i_1,j_1,\ldots\)</span>是每个轮换中最小的元素。于是 <span class="math display">\[\pi=\begin{pmatrix}1&amp;2&amp;\cdots&amp;2k-1&amp;2k&amp;2k+1&amp;2k+2&amp;\cdots\\i_1&amp;i_2&amp;\cdots&amp;i_{2k-1}&amp;i_{2k}&amp;j_1&amp;j_2&amp;\cdots\end{pmatrix}.\]</span><span class="math display">\[\pi'=\begin{pmatrix}1&amp;2&amp;\cdots&amp;2k-1&amp;2k&amp;2k+1&amp;2k+2&amp;\cdots\\i_2&amp;i_3&amp;\cdots&amp;i_{2k}&amp;i_1&amp;j_2&amp;j_3&amp;\cdots\end{pmatrix}.\]</span></p><p>容易验证 <span class="math inline">\(a_\pia_{\pi'}=a_\sigma\)</span> 以及 <span class="math inline">\(\pi'=\sigma\cdot\pi\)</span>，从而 <a href="#pfaff" title="定理 1.1">定理 1.1</a> 得证。</p><h1 id="平面图的-pfaffian-定向">平面图的 Pfaffian 定向</h1><p>Pfaffian 多项式的结论启发我们可以用它来计算一个图 <span class="math inline">\(G\)</span> 的所有匹配的个数。</p><p>设 <span class="math inline">\(G\)</span> 有 <span class="math inline">\(2n\)</span> 个顶点。首先给 <span class="math inline">\(G\)</span> 的边任意定向，得到一个简单有向图 <span class="math inline">\(\overrightarrow{G}\)</span>。写出 <span class="math inline">\(\overrightarrow{G}\)</span> 的邻接矩阵 <span class="math inline">\(A=(a_{ij})\)</span>：</p><p><span class="math display">\[a_{ij}=\begin{cases}1&amp; i\rightarrowj,\\-1&amp; j\rightarrow i,\\ 0&amp;\text{else}.\end{cases}\]</span></p><p>则 <span class="math inline">\(A\)</span> 是一个反对称矩阵且</p><p><span class="math display">\[\detA=\left(\sum_{\pi\in\mathcal{M}_{2n}}\mathrm{wt}(\pi)\right)^2=\left(\sum_{\pi\in\mathcal{M}_{2n}}\text{sgn}(\pi)a_{i_1j_1}a_{i_2j_2}\cdotsa_{i_nj_n}\right)^2.\]</span></p><p>这里 <span class="math inline">\(\pi=(i_1,j_1)(i_2,j_2)\cdots(i_n,j_n)\)</span>跑遍集合 <span class="math inline">\([2n]\)</span> 的所有匹配。由于每个<span class="math inline">\(a_{ij}\)</span> 的取值是 <span class="math inline">\(\pm1\)</span> 或者 <span class="math inline">\(0\)</span>，所以 <span class="math inline">\(\mathrm{wt}(\pi)\)</span> 的值也是 <span class="math inline">\(\pm1\)</span> 或者 <span class="math inline">\(0\)</span>，并且 <span class="math inline">\(\mathrm{wt}(\pi)\ne0\)</span> 当且仅当对每个 <span class="math inline">\(1\leq k\leq n\)</span>，<span class="math inline">\(i_k\)</span> 和 <span class="math inline">\(j_k\)</span> 在 <span class="math inline">\(G\)</span> 中是相邻的，即 <span class="math inline">\(\pi\)</span> 给出 <span class="math inline">\(G\)</span> 的一个匹配。于是 <span class="math inline">\(G\)</span> 的所有匹配与 <span class="math inline">\(\mathrm{pf}(A)\)</span>中的非零项一一对应。不幸的是，这些非零项有 +1 有-1，把它们直接加起来得到的可不是 <span class="math inline">\(G\)</span>的所有匹配的个数。但是我们可以这样想： 能否通过适当的定向 <span class="math inline">\(G\)</span>，即适当给 <span class="math inline">\(a_{ij}\)</span> 赋以 +1 或者 -1，使得每一个非零的<span class="math inline">\(\mathrm{wt}(\pi)\)</span> 都同为 +1 或者同为-1？如果可以，那么<span class="math inline">\(\sqrt{|\det A|}\)</span>就是要求的匹配的个数。</p><p>回忆在证明 <a href="#pfaff" title="定理 1.1">定理 1.1</a>时，我们有结论 <span class="math display">\[\mathrm{wt}(\pi)\cdot\mathrm{wt}(\pi')=\text{sgn}(\sigma)a_{\sigma}.\]</span>要使得所有非零的 <span class="math inline">\(\mathrm{wt}(\pi)\)</span>都同为 +1 或者同为 -1，只要让每个非零的 <span class="math inline">\(\text{sgn}(\sigma)a_{\sigma}\)</span> 都等于 1即可。设 <span class="math inline">\(\sigma\)</span> 是一个使得 <span class="math inline">\(a_\sigma\ne0\)</span> 的置换且 <span class="math inline">\(\sigma\)</span> 的轮换分解为 <span class="math inline">\(\sigma=C_1\cdots C_l\)</span>，则 <span class="math inline">\(\text{sgn}(\sigma)=(-1)^l\)</span>，<span class="math inline">\(a_\sigma=a_{C_1}\cdots a_{C_l}\)</span>。这里记号<span class="math inline">\(a_{C_i}\)</span> 的含义是，如果 <span class="math inline">\(C_i=(i_1i_2\cdots i_k)\)</span>，则 <span class="math inline">\(a_{C_i}=a_{i_1i_2}\cdotsa_{i_ki_1}\)</span>。如果我们能够使得每个 <span class="math inline">\(a_{C_i}=-1\)</span>，那么就有 <span class="math display">\[\text{sgn}(\sigma)\cdot a_\sigma = (-1)^l\cdot(-1)^l=1.\]</span> 怎么才能让 <span class="math inline">\(a_{C_i}\)</span> 都等于 -1 呢？注意 <span class="math inline">\(a_{C_i}\)</span> 不等于 0 说明 <span class="math inline">\(i_1\to i_2\to\cdots\to i_k\to i_1\)</span> 是<span class="math inline">\(\overrightarrow{G}\)</span>中的一个回路。又注意 <span class="math inline">\(\sigma\)</span>的每个轮换的长度都是偶数，所以 <span class="math inline">\(k\)</span>是偶数，即回路的长度是偶数。要使得 <span class="math inline">\(a_{C_i}\)</span> 等于 -1，我们需要 <span class="math inline">\(\{a_{i_1i_2},\ldots,a_{i_ki_1}\}\)</span> 中 -1出现的次数是奇数。换句话说，当在 <span class="math inline">\(\overrightarrow{G}\)</span> 中沿着回路 <span class="math display">\[i_1\rightarrow i_2\rightarrow \cdots \rightarrowi_k\rightarrow i_1\]</span> 绕 <span class="math inline">\(C_i\)</span>一圈时，有奇数条边在 <span class="math inline">\(\overrightarrow{G}\)</span>中的定向与行走方向一致，当然也就有奇数条边的定向与行走方向相反。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(G\)</span> 是有限图。如果 <span class="math inline">\(G\)</span> 的一个回路 <span class="math inline">\(C\)</span> 的长度是偶数，且删除 <span class="math inline">\(C\)</span> 后剩下的部分仍然存在匹配，就称 <span class="math inline">\(C\)</span> 是一个好的回路。如果 <span class="math inline">\(G\)</span> 的一个定向 <span class="math inline">\(\overrightarrow{G}\)</span> 使得 <span class="math inline">\(G\)</span>的所有好的回路都是奇定向的，即沿着回路的任一方向行走都有奇数条边的定向与行走方向一致，就称<span class="math inline">\(\overrightarrow{G}\)</span> 是一个 Pfaffian定向。</p></div><p>对一般的图，找到其 Pfaffian定向是困难的事，但是对平面图却很简单。这就是下面的定理：</p><div id="Kasteleyn" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span> <span class="statement-info">(Kasteleyn)</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(G\)</span>是一个简单平面图，则可以给 <span class="math inline">\(G\)</span>的边适当定向，使得当逆时针沿着 <span class="math inline">\(G\)</span>的每个面行走时（外部的无穷区域不算），都有奇数条边与行走方向一致，这种定向就是<span class="math inline">\(G\)</span> 的 Pfaffian 定向。</p></div><p><strong>证明</strong>：我们首先说明存在这样的定向，使得 <span class="math inline">\(G\)</span>的每个面都是奇定向的。对面的个数归纳：<span class="math inline">\(f=0\)</span>，则 <span class="math inline">\(G\)</span> 是一个树，任何定向都是 Pfaffian定向。设结论对有 <span class="math inline">\(f-1\)</span>个面的简单有向图成立，对有 <span class="math inline">\(f&gt;1\)</span>个面的图 <span class="math inline">\(G\)</span>，找到一条内部面与外部区域相邻的边 <span class="math inline">\(e\)</span>，删去 <span class="math inline">\(e\)</span> 得到的是一个有 <span class="math inline">\(f-1\)</span>个面的有向图，由归纳假设，可以让每个面都是奇定向，然后把 <span class="math inline">\(e\)</span> 补回去，并适当在 <span class="math inline">\(e\)</span>的两种可能的定向中选择一个使得最后这个面也是奇定向的即可。</p><p>其次我们要说明这样的定向是 Pfaffian 定向，即对 <span class="math inline">\(G\)</span> 中任意好的回路 <span class="math inline">\(C\)</span>，当绕着 <span class="math inline">\(C\)</span>的内部逆时针行走一圈时，有奇数条边的定向与行走方向一致。</p><p>设 <span class="math inline">\(C\)</span> 长度为 <span class="math inline">\(l\)</span>，<span class="math inline">\(C\)</span>内部有 <span class="math inline">\(p\)</span> 个顶点，<span class="math inline">\(q\)</span> 条边，<span class="math inline">\(r\)</span> 个面，<span class="math inline">\(C\)</span> 上逆时针定向的边的个数为 <span class="math inline">\(c\)</span>，内部的第 <span class="math inline">\(i\)</span> 个面 (<span class="math inline">\(1\leqi\leq r\)</span>) 上逆时针定向的边的个数为 <span class="math inline">\(c_i\)</span>。</p><p>绕着所有面都逆时针走一圈，遇到的与行走方向定向相同的边的个数是 <span class="math inline">\(\sum\limits_{i=1}^rc_i=c+q\)</span>，这是因为<span class="math inline">\(C\)</span> 内部的 <span class="math inline">\(q\)</span>条边都被走了两次，一次逆时针，一次顺时针，因此都被计算了一次；而 <span class="math inline">\(C\)</span> 上的边只有逆时针定向的那些边（一共有<span class="math inline">\(c\)</span> 条）被计算了一次。</p><p>由于每个 <span class="math inline">\(c_i\)</span> 都是奇数，因此<span class="math display">\[r\equiv c+q\ (\text{mod}\ 2).\]</span></p><p>另一方面对 <span class="math inline">\(C\)</span> 包含的区域用 Euler定理，得到 <span class="math display">\[(p+l)-(q+l)+r=1.\]</span> 从而<span class="math inline">\(p\)</span> 与 <span class="math inline">\(c\)</span> 奇偶性相反，但是 <span class="math inline">\(p\)</span> 是偶数，这是因为删去 <span class="math inline">\(C\)</span> 以后仍然存在匹配说明 <span class="math inline">\(C\)</span> 的内部和外部各有偶数个顶点，因此 <span class="math inline">\(c\)</span> 是奇数，这就证明了定理。</p><h1 id="棋盘的多米诺骨牌密铺的计数">棋盘的多米诺骨牌密铺的计数</h1><p>回到文章开始的问题。</p><p>设棋盘的大小为 <span class="math inline">\(m\times n\)</span>，<span class="math inline">\(m\)</span> 是行数。这里 <span class="math inline">\(m,n\)</span>必须至少有一个是偶数，我们这里假定列数 <span class="math inline">\(n\)</span> 是偶数。</p><p>把棋盘的每个方格看作图 <span class="math inline">\(G\)</span>的顶点，两个方格对应的顶点 <span class="math inline">\(u,v\)</span> 在<span class="math inline">\(G\)</span>中相邻当且仅当它们有公共的边，这样就得到一个有 <span class="math inline">\(mn\)</span> 个顶点的平面图。棋盘的多米诺密铺与<span class="math inline">\(G\)</span>的完美匹配是一一对应的：密铺中的每个骨牌恰好盖住两个相邻的方格，这两个方格匹配在了一起。</p><p>为了求出 <span class="math inline">\(G\)</span>的完美匹配个数，只要标记出 <span class="math inline">\(G\)</span> 的一个Pfaffian 定向，写出对应的邻接矩阵，然后求出行列式，再开平方即可。</p><p>Pfaffian 定向是很容易找的，如下图所示：</p><figure><img src="/images/pfaff/pfaff.svg" width="300" alt="m\times n 网格图的 Pfaffian 定向"><figcaption aria-hidden="true"><span class="math inline">\(m\timesn\)</span> 网格图的 Pfaffian 定向</figcaption></figure><p>下一步是写出这个定向图的邻接矩阵。我们按照从第一行开始，每一行从左到右的顺序给顶点排序。设<span class="math display">\[B_n=\begin{pmatrix}0&amp;1&amp;0&amp;&amp;\\-1&amp;0&amp;1&amp;&amp;\\&amp;-1&amp;0&amp;1&amp;\\&amp;&amp;&amp;\ddots&amp;1\\&amp;&amp;&amp;-1&amp;0\end{pmatrix}_{n\timesn}.\]</span> 则邻接矩阵为 <span class="math display">\[L(m,n)=\begin{pmatrix}B_n&amp;I_n&amp;&amp;&amp;\\-I_n&amp;-B_n&amp;I_n&amp;&amp;\\&amp;-I_n&amp;B_n&amp;&amp;\\&amp;&amp;&amp;\ddots&amp;I_n\\&amp;&amp;&amp;-I_n&amp;(-1)^{m-1}B_n\end{pmatrix}_{m\timesm}.\]</span></p><p>我把求邻接矩阵的详细过程放在后面的附录中。下面先来求 <span class="math inline">\(L(m,n)\)</span> 的行列式。</p><p>适当给 <span class="math inline">\(L(m,n)\)</span>的行列变号，可以得到 <span class="math display">\[\det L(m,n)=\det(B_n\otimes I_m-I_n\otimes C_m).\]</span> 其中 <span class="math display">\[C_m=\begin{pmatrix}0&amp;1&amp;0&amp;&amp;\\1&amp;0&amp;1&amp;&amp;\\&amp;1&amp;0&amp;1&amp;\\&amp;&amp;&amp;\ddots&amp;1\\&amp;&amp;&amp;1&amp;0\end{pmatrix}_{m\timesm}.\]</span> 这个变号步骤并不显然，我们需要选择 <span class="math inline">\(L(m,n)\)</span> 的一些行列变号，使得对角线上的每个<span class="math inline">\(-B_n\)</span> 所在的行列恰好有一次变号，每个<span class="math inline">\(B_n\)</span>所在的行列要变号两次，要么不变。具体规则是这样的：由于 <span class="math inline">\(-B_n\)</span> 出现在 <span class="math inline">\(L(m,n)\)</span> 对角线上的 <span class="math inline">\(2,4,6,\ldots,\)</span> 位置上，我们选择：</p><ol type="1"><li>将所有形如 <span class="math inline">\(4k+2\)</span>的<strong>列</strong>变号；</li><li>将所有形如 <span class="math inline">\(4k\)</span>的<strong>行</strong>变号；</li><li>将所有形如 <span class="math inline">\(4k+3\)</span>的<strong>行和列</strong>同时变号；</li></ol><p>这样显然可以把对角线上都变成 <span class="math inline">\(B_n\)</span>。对每个位于次对角线上 <span class="math inline">\((i-1, i)\)</span> 位置的 <span class="math inline">\(I_n\)</span>，</p><ul><li>如果 <span class="math inline">\(i=4k+2\)</span>，则 <span class="math inline">\((i-1,i)=(4k+1, 4k+2)\)</span>，根据 1它改变了一次符号；</li><li>如果 <span class="math inline">\(i=4k\)</span>，则 <span class="math inline">\((i-1,i)=(4k-1, 4k)\)</span>，根据 2, 3它改变了三次符号；</li><li>如果 <span class="math inline">\(i=4k+1\)</span>，则 <span class="math inline">\((i-1,i)=(4k, 4k+1)\)</span>，根据 2它改变了一次符号；</li><li>如果 <span class="math inline">\(i=4k+3\)</span>，则 <span class="math inline">\((i-1,i)=(4k+2, 4k+3)\)</span>，根据 1, 3它改变了三次符号。</li></ul><p>总之 <span class="math inline">\(I_n\)</span> 都会变成 <span class="math inline">\(-I_n\)</span>。类似地所有 <span class="math inline">\(-I_n\)</span> 均保持不变。</p><p>剩下的就是线性代数中求特征值的部分，需要一些关于矩阵张量积的知识，这里就不展开写了，大致逻辑是这样的：设<span class="math inline">\(B_n\)</span> 的特征值为 <span class="math inline">\(\lambda_1,\ldots,\lambda_n\)</span>，<span class="math inline">\(C_m\)</span> 的特征值为 <span class="math inline">\(\mu_1,\ldots,\mu_m\)</span>，则 <span class="math inline">\(B_n\otimes I_m- I_n\otimes C_m\)</span> 的 <span class="math inline">\(mn\)</span> 个特征值为 <span class="math inline">\(\{\lambda_i-\mu_j, 1\leq i\leq n, 1\leq j\leqm\}\)</span>，所以 <span class="math display">\[\det(B_n\otimes I_m-I_n\otimes C_m) = \prod_{i=1}^n\prod_{j=1}^m(\lambda_i-\mu_j).\]</span><span class="math inline">\(B_n\)</span> 和 <span class="math inline">\(C_m\)</span>的特征值的计算应该是线性代数课程中行列式部分的常见的习题，我把具体的计算步骤放在附录中，最终结果是<span class="math display">\[\sqrt{|\det L(m,n)|}=\prod_{k=1}^m\prod_{l=1}^n(4\cos^2\frac{k\pi}{m+1}+4\cos^2\frac{l\pi}{n+1})^{\frac{1}{4}}.\]</span>此即为要求的完美匹配的个数。</p><h1 id="未尽的讨论">未尽的讨论</h1><p>我们已经得到了一个关于 <span class="math inline">\(m\times n\)</span>棋盘的多米诺骨牌密铺的漂亮的表达式，事情可以结束了吗？其实还没有，这个表达式虽然很漂亮，但是我们没法用它来具体计算匹配个数的值（一堆三角函数的乘积怎么算？）。那应该怎么办呢？我把后面的故事留给<span class="citation" data-cites="aigner07">(<a href="#ref-aigner07" role="doc-biblioref">Aigner 2007, sec. 10.1</a>)</span>。</p><h1 id="附录">附录</h1><h2 id="求邻接矩阵-lmn-的具体步骤">求邻接矩阵 <span class="math inline">\(L(m,n)\)</span> 的具体步骤</h2><p>将 <span class="math inline">\(L(m,n)\)</span> 简写为 <span class="math inline">\(L=L(m,n)\)</span>。把网格图 <span class="math inline">\(G\)</span> 的顶点标记如下：</p><p><span class="math display">\[\begin{matrix}(1,1)&amp;(1,2)&amp;\cdots&amp;(1,n)\\(2,1)&amp;(2,2)&amp;\cdots&amp;(2,n)\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\(m,1)&amp;(m,2)&amp;\cdots&amp;(m, n)\end{matrix}\]</span></p><p>对这些顶点排序，首先是第一行从左到右，然后是第二行从左到右，等等：<span class="math display">\[(1,1)&lt;(1,2)&lt;\cdots&lt;(1,n)&lt;(2,1)&lt;\cdots&lt;(2,n)&lt;\cdots&lt;(m,1)&lt;\cdots&lt;(m,n).\]</span></p><p><span class="math inline">\(L\)</span> 是 <span class="math inline">\(mn\times mn\)</span> 阶矩阵，它的行和列分别由<span class="math inline">\((i,j)_{\begin{smallmatrix}1\leq i\leqm\\1\leq j\leq n\end{smallmatrix}}\)</span> 和 <span class="math inline">\((i',j')_{\begin{smallmatrix}1\leqi'\leq m\\1\leq j'\leq n\end{smallmatrix}}\)</span> 标记。<span class="math inline">\(L\)</span> 可以划分成 <span class="math inline">\(m\times m\)</span> 个子块，每个子块是 <span class="math inline">\(n\times n\)</span> 阶的，其中位于 <span class="math inline">\((i,i')\)</span> 处的子块对应的矩阵是 <span class="math inline">\((L_{(i,j)(i',j')})_{1\leq j,j'\leqn}\)</span>： <span class="math display">\[\begin{array}{c|c|c}&amp;(i',1), \cdots,(i',j'),\cdots, (i',n)&amp;\\ &amp;\hline&amp;\qquad\\(i,1)&amp;&amp;\\\vdots&amp;&amp;\\(i,j)&amp;\ast&amp;\\\vdots&amp;&amp;\\(i,n)&amp;&amp;\\&amp;\hline&amp;\qquad\\ &amp;&amp;\end{array}\]</span></p><p>注意到 <span class="math inline">\((i,j)\)</span> 和 <span class="math inline">\((i',j')\)</span>之间有边相连当且仅当：</p><ol type="1"><li><span class="math inline">\(i=i'\)</span> 且 <span class="math inline">\(j'=j\pm1\)</span>；</li><li><span class="math inline">\(i'=i\pm1\)</span> 且 <span class="math inline">\(j=j'\)</span>。</li></ol><p>这说明 <span class="math inline">\(L\)</span>在除去对角线以及两侧的次对角线以外的位置都是 0。</p><p>在情形 1 中，由于水平的边（红色和绿色）是交替改变方向的，所以 <span class="math display">\[L_{(i,j)(i,j+1)} = (-1)^{i-1} \text{ for } 1\leqi\leq m \text{ and } 1\leq j\leq n-1.\]</span> 这说明 <span class="math inline">\(L\)</span> 对角线上的第 <span class="math inline">\(i\)</span> 个子块是 <span class="math inline">\((-1)^{i-1}B_n\)</span>，其中 <span class="math display">\[B_n=\begin{pmatrix}0&amp;1&amp;0&amp;&amp;\\-1&amp;0&amp;1&amp;&amp;\\&amp;-1&amp;0&amp;1&amp;\\&amp;&amp;&amp;\ddots&amp;1\\&amp;&amp;&amp;-1&amp;0\end{pmatrix}_{n\timesn}.\]</span> 即 <span class="math inline">\(L\)</span> 形如 <span class="math display">\[\begin{pmatrix}B_n &amp;\ast&amp;&amp;&amp;\\\ast&amp; -B_n &amp;\ast&amp;&amp;\\&amp;\ast&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\ddots&amp;\ddots&amp; \ast\\&amp;&amp;&amp;\ast&amp;(-1)^{m-1}B_n\end{pmatrix}.\]</span> 在情形 2中，由于竖直的边（蓝色）是恒定向下的，所以 <span class="math display">\[L_{(i,j),(i+1,j)}  = 1  \text{ for } 1\leq i\leqm-1 \text{ and } 1\leq j\leq n.\]</span> 这说明 <span class="math inline">\(L\)</span> 右上方次对角线上的 <span class="math inline">\((i,i+1)\)</span> 位置的子块都是 <span class="math inline">\(I_n\)</span>。再结合 <span class="math inline">\(L\)</span> 是反对称的，下方次对角线上都是 <span class="math inline">\(-I_n\)</span>，所以 <span class="math inline">\(L\)</span> 形如 <span class="math display">\[\begin{pmatrix}B_n &amp;I_n&amp;&amp;&amp;\\-I_n&amp; -B_n &amp;I_n&amp;&amp;\\&amp;-I_n&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\ddots&amp;\ddots&amp; I_n\\&amp;&amp;&amp;-I_n&amp;(-1)^{m-1}B_n\end{pmatrix}.\]</span></p><p>此即为 <span class="math inline">\(G\)</span> 的邻接矩阵。</p><h2 id="求-b_n-和-c_m-的特征值">求 <span class="math inline">\(B_n\)</span> 和 <span class="math inline">\(C_m\)</span> 的特征值</h2><p>我们以 <span class="math display">\[C_m=\begin{pmatrix}0&amp;1&amp;0&amp;&amp;\\1&amp;0&amp;1&amp;&amp;\\&amp;1&amp;0&amp;1&amp;\\&amp;&amp;&amp;\ddots&amp;1\\&amp;&amp;&amp;1&amp;0\end{pmatrix}.\]</span>为例来说明怎样求它的特征值，<span class="math inline">\(B_n\)</span>的求解是类似的。</p><p>我们需要求出其特征多项式</p><p><span class="math display">\[f_m(\lambda) =\det\begin{pmatrix}\lambda&amp;-1&amp;0&amp;&amp;\\-1&amp;\lambda&amp;-1&amp;&amp;\\&amp;-1&amp;\lambda&amp;-1&amp;\\&amp;&amp;&amp;\ddots&amp;-1\\&amp;&amp;&amp;-1&amp;\lambda\end{pmatrix}.\]</span></p><p>按第一行展开可得递推关系</p><p><span class="math display">\[f_m = \lambda f_{m-1} -f_{m-2},\]</span></p><p>结合初始条件 <span class="math inline">\(f_0=1, f_1=\lambda\)</span>（初始条件可以从 <span class="math inline">\(m=2\)</span>的情形展开确定） 可得</p><p><span class="math display">\[f_m(\lambda) =\frac{1}{\sqrt{\lambda^2-4}}\left[\left(\frac{\lambda+\sqrt{\lambda^2-4}}{2}\right)^{m+1}-\left(\frac{\lambda-\sqrt{\lambda^2-4}}{2}\right)^{m+1}\right].\]</span></p><p>由此不难确定 <span class="math inline">\(C_m\)</span> 的 <span class="math inline">\(m\)</span> 个特征值为 <span class="math inline">\(2\cos\dfrac{k\pi}{m+1},k=1,\ldots,m.\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-aigner07" class="csl-entry" role="listitem">Aigner, M. 2007. <em>A Course in Enumeration</em>. Graduate Texts inMathematics. Springer Berlin Heidelberg.</div></div><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>提示：从任一顶点 <span class="math inline">\(x\)</span>出发沿着红边到达顶点 <span class="math inline">\(y\)</span>，再从 <span class="math inline">\(y\)</span> 出发沿着蓝边到达顶点 <span class="math inline">\(z\)</span>，再从 <span class="math inline">\(z\)</span> 出发沿着红边到达顶点 <span class="math inline">\(w\)</span>，这样一直继续下去肯定会回到某个访问过的点，从而形成一个回路。拿掉这个回路以后剩下的图每个顶点的度数仍然是偶数，所以可以继续重复这个过程。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 计数组合学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>平面分拆的 Macmahon 公式</title>
      <link href="macmahon-formula-plane-partitions/"/>
      <url>macmahon-formula-plane-partitions/</url>
      
        <content type="html"><![CDATA[<div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>一个边长为 <span class="math inline">\(a\times b\times c\)</span> 的平行六边形（<span class="math inline">\(a,b,c\)</span> 都是正整数），每个内角都是 120度。用边长为 1 的菱形密铺，有多少种不同的方法？</p><figure><img src="/images/macmahon/hexagon.svg" width="400" alt="a\times b\times c 的六边形"><figcaption aria-hidden="true"><span class="math inline">\(a\timesb\times c\)</span> 的六边形</figcaption></figure></div><p>下图是一种密铺的示例：</p><figure><img src="/images/macmahon/planepartition.svg" width="400" alt="一个密铺的例子，顶部的数字表示高度，解释见下文"><figcaption aria-hidden="true">一个密铺的例子，顶部的数字表示高度，解释见下文</figcaption></figure><span id="more"></span><p>我们观察这张图，想象在空间中鸟瞰它，发现它很像是在墙角“堆箱子”。不仅如此，箱子的堆放方式还满足规律：从墙角开始，沿着两侧墙壁的方向，箱子的高度是递减的。我们把地面上第<span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 列位置箱子的高度 <span class="math inline">\(a_{ij}\)</span> 填写在一个 <span class="math inline">\(a\)</span> 行 <span class="math inline">\(b\)</span> 列的矩阵 <span class="math inline">\(A\)</span> 中（习惯上空白位置的 0 不写出来）：</p><table><tbody><tr><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p><span class="math inline">\(A\)</span> 有如下特点：</p><blockquote><ul><li><span class="math inline">\(A\)</span>的每一行从左到右，每一列从上到下都是递减的。</li><li><span class="math inline">\(a_{ij}\)</span> 都是介于 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(c\)</span>之间的整数（箱子的高度不能超过天花板的高度 <span class="math inline">\(c\)</span>）。</li></ul></blockquote><p>我们把矩阵 <span class="math inline">\(A\)</span> 叫做一个参数为<span class="math inline">\((a,b,c)\)</span>的受限制的<strong>平面分拆</strong>。</p><p>每个受限制的平面分拆都对应一种堆箱子的方式，从而对应六边形的一个菱形密铺。这个对应是一一的。较真的读者可能会说：“且慢，你这只是从视觉直观上看出来菱形密铺和堆箱子是一一对应的，这不够严格吧？”没错，严格的证明是可以有的，但是这里我们的目的是欣赏一处数学奇趣，不必搞得那么学究。</p><p>总之，我们把开头的密铺问题转化为平面分拆的计数问题：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>满足如下两个条件的 <span class="math inline">\(a\)</span> 行 <span class="math inline">\(b\)</span> 列矩阵有多少个？</p><ol type="1"><li>元素都是 <span class="math inline">\([0,c]\)</span>之间的非负整数；</li><li>每一行从左到右，每一列从上到下都是递减的。</li></ol></div><p>设答案为 <span class="math inline">\(M(a,b,c)\)</span>，则我们有一个非常令人吃惊的表达式：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>（<strong>Macmahon 公式</strong>）</p><p><span class="math display">\[M(a,b,c)=\prod_{i=1}^a\prod_{j=1}^b\prod_{k=1}^c\frac{i+j+k-1}{i+j+k-2}.\]</span></p></div><p>虽然问题看起来很初等，但是答案的复杂暗示我们它并不像看起来那么容易。接下来你会看到，用一个巧妙的方法可以把问题转化为求一个行列式的值。</p><h1 id="不相交的路径组">不相交的路径组</h1><p>我们知道在平面上从原点 <span class="math inline">\((0,0)\)</span>出发，每次向右或者向上移动一个单位的距离，到达点 <span class="math inline">\((b,a)\)</span> 的路径个数是组合数 <span class="math inline">\(\binom{a+b}{b}\)</span>，这样的一条路径叫做 Gauss路径。</p><p>每个平面分拆的矩阵 <span class="math inline">\(A\)</span> 都对应<span class="math inline">\(c\)</span> 条这样的路径，其中第 <span class="math inline">\(k\)</span> 条路径是高度为 <span class="math inline">\(k\,(1\leq k\leq c)\)</span>的那一层的「等高线」：</p><figure><img src="/images/macmahon/paths-on-cubes.svg" width="400" alt="等高线示意图"><figcaption aria-hidden="true">等高线示意图</figcaption></figure><p>我们把这些路径投影到 2D，和矩阵 <span class="math inline">\(A\)</span> 画在一起。从最下方的路径开始，第 <span class="math inline">\(i\)</span> 条路径对应的是矩阵中 <span class="math inline">\(\geq i\)</span> 的那些方格构成的区域的边界：</p><figure><img src="/images/macmahon/gauss_path.svg" width="500" alt="等高线投影到 xy 平面上的效果图"><figcaption aria-hidden="true">等高线投影到 <span class="math inline">\(xy\)</span> 平面上的效果图</figcaption></figure><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在上图中，我稍微移动了各个路径的位置，使得它们容易在视觉中区分，所以导致看起来它们的起点和终点是不同的。实际上它们都是从<span class="math inline">\((0,0)\)</span> 到 <span class="math inline">\((b,a)\)</span> 的 Gauss 路径。</p></div><p>注意 <span class="math inline">\(A\)</span>的行和列满足递降关系，这个递降关系反映在这 <span class="math inline">\(c\)</span>条路径上就是，对任何两条路径，它们可以有接触点或者重合的边，但彼此不能穿过对方。</p><p>接下来是关键的一步：如果把这 <span class="math inline">\(c\)</span>条路径沿着 <span class="math inline">\((-1,1)\)</span> 方向，分别平移<span class="math inline">\(0,1,\ldots,c-1\)</span> 个单位，则平移后的<span class="math inline">\(c\)</span>条路径两两之间将没有任何公共点。我们称之为一个不相交的路径组。如下图所示：</p><p><img src="/images/macmahon/nonintersecting_paths.gif" class="fig" width="550"></p><p>这里 <span class="math inline">\(A_i=(1-i,i-1)\)</span>，<span class="math inline">\(B_j=(b+1-j,a-1+j)\)</span>，<span class="math inline">\(\{p_i:A_i\rightarrow B_i,1\leq i\leq c\}\)</span>是一个不相交的路径组。反过来对每一个这样的不相交的路径组，我们也很容易还原出对应的平面分拆来。</p><p>于是我们的问题又进一步转化为</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>设 <span class="math display">\[\{A_i=(1-i,i-1) ,\, 1\leq i\leq c\}\]</span> 和<span class="math display">\[\{B_j=(b+1-j,a-1+j),\, 1\leq j\leqc\}\]</span> 是平面上两组顶点集，求出所有不相交的路径组 <span class="math inline">\(\mathcal{P}=\{p_i,1\leq i\leq c\}\)</span>的数目，其中 <span class="math inline">\(p_i\)</span> 是从 <span class="math inline">\(A_i\)</span> 出发到 <span class="math inline">\(B_i\)</span> 的 Gauss 路径。</p></div><h1 id="gessel-viennot-的巧妙方法">Gessel-Viennot 的巧妙方法</h1><p>考虑这样一个 <span class="math inline">\(c\times c\)</span> 的矩阵<span class="math inline">\(M\)</span>，其元素 <span class="math inline">\(m_{ij}\)</span> 是从点 <span class="math inline">\(A_i\)</span> 出发到达点 <span class="math inline">\(B_j\)</span> 的所有 Gauss 路径的数目。由于点 <span class="math inline">\(A_i\)</span> 坐标为 <span class="math inline">\((1-i,i-1)\)</span>，点 <span class="math inline">\(B_j\)</span> 坐标为 <span class="math inline">\((b+1-j,a-1+j)\)</span>，所以 <span class="math display">\[m_{ij}=\binom{a+b}{b+i-j}.\]</span> 这里如果<span class="math inline">\(b+i-j&lt;0\)</span> 则规定 <span class="math inline">\(m_{ij}=0\)</span>。Gessel-Viennot引理非常意外地告诉我们：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>（<strong>Gessel-Viennot 引理</strong>）</p><p>记 <span class="math inline">\(\mathcal{A}=\{A_i,1\leq i\leqc\}\)</span> 和 <span class="math inline">\(\mathcal{B}=\{B_j,1\leqj\leq c\}\)</span> 是如上所述的两个顶点集合，对 <span class="math inline">\(c\)</span> 元组上的任一置换 <span class="math inline">\(\sigma\)</span>，记 <span class="math inline">\(\mathcal{P}_\sigma=\{p_i:A_i\toB_{\sigma(i)}\}\)</span> 为一个路径组。则所有不相交路径组的个数为 <span class="math display">\[\det M=\det_{1\leq i,j\leqc}\left(\left(\begin{array}{c}a+b\\b+i-j\end{array}\right)\right).\]</span></p></div><p>Gessel-Viennot引理对更一般的带权的图也成立，它在许多组合问题中都有精彩的应用。关于这方面可以参看<span class="citation" data-cites="thebook">(<a href="#ref-thebook" role="doc-biblioref">Aigner and Ziegler 2018</a>)</span>。</p><p><strong>证明</strong>：把 <span class="math inline">\(\det M\)</span>按照行列式的定义展开：</p><p><span class="math display">\[\begin{aligned}\detM&amp;=\sum_{\sigma}\text{sgn}(\sigma)m_{1\sigma(1)}\cdotsm_{c\sigma(c)}\\&amp;=\sum_{\sigma}\text{sgn}(\sigma)\left(\sum_{p_1:A_1\toB_{\sigma(1)}}1\right)\cdots\left(\sum_{p_c:A_c\toB_{\sigma(c)}}1\right).\end{aligned}\]</span></p><p>其中 <span class="math inline">\(\sigma\)</span> 跑遍对称群 <span class="math inline">\(S_c\)</span> 的所有置换。取出其中的一项</p><p><span class="math display">\[\left(\sum_{p_1:A_1\toB_{\sigma(1)}}1\right)\cdots\left(\sum_{p_c:A_c\toB_{\sigma(c)}}1\right),\]</span></p><p>把它展开得到很多个 1，每个 1 对应一个路径组 <span class="math inline">\(\mathcal{P}_\sigma=\{p_i:A_i\rightarrowB_{\sigma(i)},1\leq i\leq c\}\)</span>，因此</p><p><span class="math display">\[\detM=\sum_{\sigma,\mathcal{P}_\sigma}\text{sgn}(\sigma).\tag{$\ast$}\label{eq:det}\]</span></p><p>这个求和是对每个置换 <span class="math inline">\(\sigma\)</span>，跑遍所有可能的路径组 <span class="math inline">\(P_\sigma\)</span>。</p><p>我们来证明在上面的求和中，相交的路径组对应的项可以两两抵消，剩下的只有不相交的路径组。</p><p>设 <span class="math inline">\(\mathcal{P}\)</span>是一个相交的路径组，我们构造与之抵消的路径组 <span class="math inline">\(\mathcal{P}'\)</span> 如下：</p><ol type="1"><li>在 <span class="math inline">\(\mathcal{P}\)</span>的所有交点中，首先选择横坐标最大的那个，如果这样的交点有多个，就选择纵坐标最大的那个，将其记作<span class="math inline">\(C\)</span>。</li><li>在经过 <span class="math inline">\(C\)</span>的所有路径中，首先选择最大的 <span class="math inline">\(i\)</span> 使得<span class="math inline">\(p_i:A_i\rightarrow B_{\sigma(i)}\)</span>经过 <span class="math inline">\(C\)</span>，再选择最大的 <span class="math inline">\(j\ne i\)</span> 使得 <span class="math inline">\(p_j\)</span> 也经过 <span class="math inline">\(C\)</span>。</li><li>交换 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(p_j\)</span> 在 <span class="math inline">\(C\)</span>点之后的部分，保持路径组其它部分不动。记得到的新路径组为 <span class="math inline">\(\mathcal{P}'\)</span>。</li></ol><p>直观上，你可以想象两个人分别从 <span class="math inline">\(A_i\)</span> 和 <span class="math inline">\(A_j\)</span> 出发沿着路径 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(p_j\)</span> 前往目的地 <span class="math inline">\(B_{\sigma(i)}\)</span> 和 <span class="math inline">\(B_{\sigma(j)}\)</span>。当他们到达 <span class="math inline">\(C\)</span>时改变路线，沿着对方剩下的路径前往对方的目的地。</p><p><img src="/images/macmahon/gessel_viennot.svg" class="fig" width="550"></p><p>于是 <span class="math inline">\(\mathcal{P}'\)</span> 对应的置换<span class="math inline">\(\sigma'\)</span> 与 <span class="math inline">\(\mathcal{P}\)</span> 对应的置换 <span class="math inline">\(\sigma\)</span> 只差一个对换 <span class="math inline">\((ij)\)</span>，因此 <span class="math inline">\(\text{sgn}(\sigma')=-\text{sgn}(\sigma)\)</span>。更重要的是，如果对<span class="math inline">\(\mathcal{P}'\)</span>也进行上述操作的话，又会回到 <span class="math inline">\(\mathcal{P}\)</span>，因此相交的路径组确实可以两两配对抵消。</p><p>于是我们可以把 <span class="math inline">\((\ref{eq:det})\)</span>改写为 <span class="math display">\[\detM=\sum_{\sigma,\mathcal{P}_\sigma \text{non-intersecting}}\text{sgn}(\sigma).\]</span></p><p>但是注意，不相交的路径组只有在 <span class="math inline">\(\sigma=1\)</span> 时才可能发生，即每个 <span class="math inline">\(A_i\)</span> 的目的地必须是 <span class="math inline">\(B_i\)</span>。所以我们进一步得到 <span class="math display">\[\det M=\sum_{\sigma=1\text{ and } \mathcal{P}_\sigma \text{non-intersecting}}1.\]</span> 这正是所有不相交路径组的个数。<span class="math inline">\(\blacksquare\)</span></p><h1 id="dodgsons-condensation-method">Dodgson’s condensation method</h1><p>为了求出行列式的值，我们介绍一个古老的方法：Dodgson’scondensation。这是一个递归求解行列式的方法：设 <span class="math inline">\(A\)</span> 是一个 <span class="math inline">\(n\times n\)</span> 矩阵，用 <span class="math inline">\(A_i^j\)</span> 表示删去 <span class="math inline">\(A\)</span> 的第 <span class="math inline">\(i\)</span> 行和第 <span class="math inline">\(j\)</span> 列后剩下的 <span class="math inline">\(n-1\)</span> 阶矩阵，用 <span class="math inline">\(A_{1,n}^{1,n}\)</span> 表示删去 <span class="math inline">\(A\)</span> 的第 1 行第 1 列和第 <span class="math inline">\(n\)</span> 行第 <span class="math inline">\(n\)</span> 列后剩下的 <span class="math inline">\(n-2\)</span> 阶矩阵，则我们有恒等式</p><p><span class="math display">\[\det A\cdot \det A_{1,n}^{1,n}=\detA_1^1\det A_n^n-\det A_1^n\det A_n^1.\]</span></p><p>用一个形象的图片描述：</p><p><img src="/../images/macmahon/dodgson.svg" class="fig" width="450"></p><p>这个结论的证明不难，可以见 <a href="http://en.wikipedia.org/wiki/Dodgson_condensation">维基百科</a>，这里就不再写了。</p><p>我们对 <span class="math inline">\(c\)</span> 归纳来证明</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>（<strong>Macmahon 公式</strong>）</p><p><span class="math display">\[\det_{1\leq i,j\leqc}\left(\left(\begin{array}{c}a+b\\b+i-j\end{array}\right)\right)=\prod_{i=1}^a\prod_{j=1}^b\prod_{k=1}^c\frac{i+j+k-1}{i+j+k-2}.\]</span></p></div><p>首先你需要对 <span class="math inline">\(c=1\)</span> 和 <span class="math inline">\(c=2\)</span> 的情形手算验证（略繁琐，不过只是一个2 阶矩阵），设 <span class="math inline">\(M_c(a, b)\)</span>为所求的行列式，注意到</p><p><span class="math display">\[\begin{cases}(M_c(a,b))_1^1=M_{c-1}(a,b),\\(M_c(a,b))_n^n=M_{c-1}(a,b),\\(M_c(a,b))_1^n=M_{c-1}(a-1,b+1),\\(M_c(a,b))_n^1=M_{c-1}(a+1,b-1),\\(M_c(a,b))^{1,n}_{1,n}=M_{c-2}(a,b).\end{cases}\]</span></p><p>然后应用归纳假设即可。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>问题的 <span class="math inline">\(q-\)</span> 计数版本也可以用Gessel-Viennot 引理来做，只是行列式的求值略复杂。其实也可以用 <a href="https://arxiv.org/abs/math/9902004">Krattenthaler 公式</a>来计算，不过那个方法不是我们要讲的。</p></div><h1 id="番外话">番外话</h1><p>说点八卦的东西。Dodgson 是 19世纪的英国数学家，细心点的读者可能注意到这位老兄的名字实在让人不敢恭维：Dodgson，dog..son？大概他也知道自己的名字难登大雅之堂，所以他给自己取了一个很好听的笔名：LewisCarroll（路易斯·卡罗尔）。</p><p>你对这个名字没有反应么？那好，我们继续说说他的轶事。这位老兄虽然名字略俗，受过的教育可不含糊，是牛津大学的数学教授，也算上层社会体面人物，但是按照今天的话说，是个不折不扣的怪蜀黍，对萝莉有着特别的喜爱，尤其喜爱给她们拍裸照，所以后人基本认定他是一个恋童癖大叔。他曾经专门为邻居家的女儿写了一部童话来哄她开心，这就是大名鼎鼎的《爱丽斯漫游奇境记》。虽然创作动机不纯，但是这部童话非常精彩，以至于当时的英国女王都变成了他的粉丝。女王命令手下的大臣把Dodgson的全部著作都搜集呈上来，于是大臣献上了一本厚厚的《符号逻辑》，当然结果你猜得到的…</p><p>时光一转到了 20 世纪 80 年代，三位数学家 William Mills，David Robbins和 Howard Rumsey 在研究计算行列式的快速数值算法时，受 Dodgson算法的启发，发现了交错符号矩阵猜想。这是计数组合学里面最精彩的猜想之一。我向你推荐Bressoud 的书 <span class="citation" data-cites="Bressoud1999">(<a href="#ref-Bressoud1999" role="doc-biblioref">Bressoud1999</a>)</span>，我保证里面的故事和《爱丽丝漫游奇境记》一样奇妙 …</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-thebook" class="csl-entry" role="listitem">Aigner, Martin, and Gnter M. Ziegler. 2018. <em>Proofs from THEBOOK</em>. 6th ed. Springer Publishing Company, Incorporated.</div><div id="ref-Bressoud1999" class="csl-entry" role="listitem">Bressoud, David M. 1999. <em>Proofs and Confirmations: The Story of theAlternating-Sign Matrix Conjecture</em>. Spectrum. Cambridge UniversityPress.</div></div>]]></content>
      
      
      <categories>
          
          <category> 计数组合学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Aztec 钻石图的完美匹配与多米诺洗牌算法</title>
      <link href="domino-shuffling/"/>
      <url>domino-shuffling/</url>
      
        <content type="html"><![CDATA[<p><strong>2021/03/15 更新</strong>：刚得知 Youtube 上的博主 mathologer制作了一期非常精彩的节目，介绍 Aztec钻石图与多米诺洗牌算法，非常值得一看！</p><iframe width="640" height="360" src="https://www.youtube.com/embed/Yy7Q8IWNfHM" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><hr><p><strong>2021/01/01 更新</strong>：2021 年的第一天，有人在 Shadertoy上放了一个精彩的动画，演示多米诺洗牌算法的步骤：</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/Wldyzj?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><hr><p>Aigner 和 Ziegler 所著的 <a href="https://en.wikipedia.org/wiki/Proofs_from_THE_BOOK">Proofs fromthe book</a> （中文译版《数学天书中的证明》）是一本非常精彩的数学读物，其中包含了 40余个著名的数学问题和它们的巧妙解答。这些问题并不深奥，但也绝非没有受过严格数学训练的人所能欣赏，其中往往包含了相当的洞察力和聪明才智，读起来让人神清气爽，大叹数学之妙。</p><p>然而读完这本书的人恐怕都会有意犹未尽的感觉：这就没啦？我还没看够呢！</p><p>有一个问题我想是非常适合放在这本书里的，我也非常期待能在未来的版本中看到它，这就是Aztec 钻石图的多米诺铺砌的计数问题。这个问题完美符合该书选题的标准：</p><ol type="1"><li>表述初等，不需要太多的背景知识就能能理解。</li><li>内涵丰富。Aztec钻石图是当前代数组合学中一个热点问题，它与交错符号矩阵、表示论、概率论、统计力学都有着深刻而奇妙的联系，有许多悬而未决的问题有待解决。</li><li>有多种令人拍案叫绝的解答，每个解答都不平凡，要么需要深刻的数学知识，要么需要开很大的脑洞。</li></ol><p>我来介绍一下这个问题：</p><span id="more"></span><p>依次把 <span class="math inline">\(2,4,\ldots,2n\)</span>个单位正方形对称地摞在一起，放在 <span class="math inline">\(x\)</span>轴上方，然后关于 <span class="math inline">\(x\)</span>轴对称地反射过去，得到的图形叫做 <span class="math inline">\(n\)</span>阶的 Aztec 钻石图，记作 <span class="math inline">\(\mathrm{AZ}(n)\)</span>。下图显示的是 <span class="math inline">\(\mathrm{AZ}(10)\)</span>：</p><figure><img src="/images/aztec/azgraph.svg" width="350" alt="\mathrm{AZ}(10)"><figcaption aria-hidden="true"><span class="math inline">\(\mathrm{AZ}(10)\)</span></figcaption></figure><p>用 1x2 的多米诺骨牌不重叠不遗漏地盖住这些方格，可以得到 Aztec钻石图的一个多米诺骨牌铺砌。下图显示的是 <span class="math inline">\(\mathrm{AZ}(10)\)</span> 的一种可能的铺砌：</p><figure><img src="/images/aztec/az10.svg" width="350" alt="\mathrm{AZ}(10) 的一种铺砌"><figcaption aria-hidden="true"><span class="math inline">\(\mathrm{AZ}(10)\)</span> 的一种铺砌</figcaption></figure><p>可以看到图中出现了四种不同颜色的骨牌，为什么这样染色后面会解释。</p><p>我们的问题是：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span><span class="math inline">\(\mathrm{AZ}(n)\)</span>总共有多少种不同的多米诺骨牌铺砌？</p></div><p>这里不考虑铺砌的对称性，比如全部用水平的骨牌铺砌和全部用竖直的骨牌铺砌是两种不同的铺砌。</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>如何在 <span class="math inline">\(\mathrm{AZ}(n)\)</span>的所有铺砌中等概率地随机任选一种？</p></div><p>第一个问题的答案是 <span class="math inline">\(2^{n(n+1)/2}\)</span>，这个表达式很简洁，这暗示这个问题也应该有一个简洁的解答（确实如此）。</p><p>第二个问题的答案叫做多米诺洗牌算法，正是本文要介绍的。</p><p>Aztec 钻石图多米诺铺砌的计数问题最早由 Elkies、Kuperberg、Propp 和Larson 在论文 <span class="citation" data-cites="dominoshuffling">(<a href="#ref-dominoshuffling" role="doc-biblioref">Elkies et al.1991</a>)</span> 中进行了深入的研究，在这篇文章中他们一共给出了 4种不同的解答。时至今日人们发现的解法已经超过一打，不幸的是没有一种可以算是「简单的」，但其中最精彩的仍然要数Elkies 等人论文中的第四个解法：洗牌算法。后来 Propp 在另一篇文章 <span class="citation" data-cites="spidermove">(<a href="#ref-spidermove" role="doc-biblioref">Propp 2001</a>)</span>中用图变换的方式重新表述了这个算法，并同时解决了在给定边的权重情况下对铺砌随机取样的问题。本文就来介绍Propp 的方法。</p><h1 id="洗牌算法">洗牌算法</h1><p>理解洗牌算法的第一个关键是理解骨牌的定向。</p><p>把 <span class="math inline">\(\mathbb{Z}^2\)</span>看做一张无穷大的国际象棋棋盘，每个方格染成黑白两色之一，相邻方格的颜色是不同的，于是每个骨牌都恰好覆盖一个黑方格和一个白方格。</p><p>乍看起来，骨牌只有水平或者竖直两种不同的类型，其实不然，骨牌有<code>N</code>、<code>S</code>、<code>W</code>、<code>E</code>（北南西东）四种不同的类型，认识到这一点非常重要。下面介绍怎样定义和区分骨牌的类型。</p><p>如果棋盘上一个 <span class="math inline">\(2\times2\)</span>的正方形区域的左上角的方格是黑色的，我们就称这是一个<strong>黑方块</strong>，如下图所示：</p><figure><img src="/images/aztec/block.svg" width="100" alt="黑方块"><figcaption aria-hidden="true">黑方块</figcaption></figure><p>类似地可以定义<strong>白方块</strong>为左上角方格为白色的 2x2正方形区域。</p><p>对一张骨牌 <span class="math inline">\(d\)</span>，它必然落在唯一的一个黑方块 <span class="math inline">\(B\)</span> 中。规定 <span class="math inline">\(d\)</span> 的移动规则为：把 <span class="math inline">\(d\)</span> 移动到它在 <span class="math inline">\(B\)</span> 中对面的位置上，根据 <span class="math inline">\(d\)</span> 的移动方向规定其定向分别为<code>N</code>、<code>S</code>、<code>W</code>、<code>E</code>。如下图所示：</p><figure><img src="/images/aztec/orientation.svg" width="400" alt="不同定向的骨牌的移动规则"><figcaption aria-hidden="true">不同定向的骨牌的移动规则</figcaption></figure><p>注意到在移动以后，定向为 <code>N/S</code> 的骨牌变成了定向为<code>S</code> 的骨牌，定向为 <code>S</code> 的骨牌变成了定向为<code>N</code> 的骨牌，对 <code>E</code>, <code>W</code>类型的骨牌亦然。</p><p>设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(\mathrm{AZ}(n)\)</span>的一个多米诺铺砌，如果一个黑方块 <span class="math inline">\(B\)</span>恰好包含 <span class="math inline">\(T\)</span>中一对平行放置的骨牌，就称 <span class="math inline">\(B\)</span> 是<span class="math inline">\(T\)</span>的一个<strong>坏方块</strong>。在一个坏方块中，两个骨牌的定向是互相朝着对方的。</p><p>把 <span class="math inline">\(\mathrm{AZ}(n)\)</span>放在棋盘上，使得其最上方一行的最左边的方格是白色，规定 <span class="math inline">\(\mathrm{AZ}(n)\)</span> 的对称中心为原点。设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(\mathrm{AZ}(n)\)</span>的任一铺砌，如下图所示。图中根据骨牌的定向<code>N</code>、<code>S</code>、<code>W</code>、<code>E</code>将其染成了红、黄、绿、蓝四种颜色。我还画出了一个大小为 <span class="math inline">\(\mathrm{AZ}(n+1)\)</span> 的背景区域。</p><figure><img src="/images/aztec/step0.svg" width="350" alt="\mathrm{AZ}(10) 的一个铺砌 T"><figcaption aria-hidden="true"><span class="math inline">\(\mathrm{AZ}(10)\)</span> 的一个铺砌 <span class="math inline">\(T\)</span></figcaption></figure><ol type="1"><li><p>移走所有坏方块中的骨牌，这一操作叫做「删除」(deletion)。上图中的铺砌在删除后的结果如下图所示：</p><figure><img src="/images/aztec/step1.svg" width="350" alt="从 T 中移走坏方块中的骨牌"><figcaption aria-hidden="true">从 <span class="math inline">\(T\)</span>中移走坏方块中的骨牌</figcaption></figure></li><li><p>将剩下的骨牌按照其定向各自移动一步，这一操作叫做「移动」(sliding)：</p><figure><img src="/images/aztec/step2.svg" width="350" alt="移动剩下的骨牌"><figcaption aria-hidden="true">移动剩下的骨牌</figcaption></figure><p>可以看到，这些剩下的骨牌分布在更大一些的 <span class="math inline">\(\mathrm{AZ}(n+1)\)</span>的区域内，而且不会出现骨牌重叠的情况。</p></li><li><p>可以证明在移动结束后 <span class="math inline">\(\mathrm{AZ}(n+1)\)</span>中的空白部分可以唯一地表示为若干不相交的黑方块的并，对每个这样的黑方块，任意用一对水平的或者是竖直的骨牌将其填充，就得到了<span class="math inline">\(\mathrm{AZ}(n+1)\)</span>的一个铺砌。这一操作叫做「生成 」(creation)。上图中的空白区域可以表示为14 个不相交的黑方块的并，因此一共有 <span class="math inline">\(2^{14}\)</span>种不同的生成方式，其中一种如下：</p><figure><img src="/images/aztec/step3.svg" width="350" alt="将每个黑方块用一对水平或竖直的骨牌填充，结果是一个 \mathrm{AZ}(n+1) 的铺砌"><figcaption aria-hidden="true">将每个黑方块用一对水平或竖直的骨牌填充，结果是一个<span class="math inline">\(\mathrm{AZ}(n+1)\)</span>的铺砌</figcaption></figure></li></ol><p>于是从 <span class="math inline">\(\mathrm{AZ}(n)\)</span>的任一铺砌出发，经过删除、移动、生成三次操作后，可以得到 <span class="math inline">\(\mathrm{AZ}(n+1)\)</span>的一个铺砌。这个步骤就叫做洗牌。</p><div id="------" class="statement sta___ definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注意</span>：</span><span class="statement-spah"> </span>算法开始时要求 <span class="math inline">\(\mathrm{AZ}(n)\)</span>最左上边的方格是白色，但是经过一次洗牌操作后，得到的 <span class="math inline">\(\mathrm{AZ}(n+1)\)</span>的铺砌最左上边的方格是黑色。如果我们想从这个 <span class="math inline">\(\mathrm{AZ}(n+1)\)</span> 的铺砌继续洗牌得到 <span class="math inline">\(\mathrm{AZ}(n+2)\)</span>的铺砌的话，就要翻转棋盘的染色。否则我们又会回到一个 <span class="math inline">\(\mathrm{AZ}(n)\)</span> 的铺砌。</p></div><p>用 GIF 动图演示这个过程：</p><p><img src="/images/aztec/dominoshuffling.gif" class="fig"></p><p>上图演示的是从 1 阶 Aztec 钻石图的一个随机铺砌出发，反复地执行删除-&gt; 移动 -&gt; 生成 -&gt; 删除 -&gt; 移动 -&gt; … 的步骤，最终生成 30阶 Aztec 钻石图的随机铺砌。其中每次生成之后都翻转棋盘的染色。</p><p><strong>算法中最难的部分是证明在第二步移动结束后，<span class="math inline">\(\mathrm{AZ}(n+1)\)</span>区域中的空白部分可以表示为不相交的黑方块的并</strong>。Elkies等人的原证明很简单，但是给人的感觉不够优雅和本质。我们先承认这个结论是对的，然后可以给出计数问题的一个快速解答：假设一个<span class="math inline">\(\mathrm{AZ}(n)\)</span> 的铺砌 <span class="math inline">\(T\)</span> 包含 <span class="math inline">\(k\)</span> 个坏方块，则 <span class="math inline">\(\mathrm{AZ}(n)\)</span> 有 <span class="math inline">\(2^k\)</span>个不同的铺砌，它们包含的坏方块恰好就是这 <span class="math inline">\(k\)</span> 个。在删除和移动操作以后这 <span class="math inline">\(2^k\)</span> 个铺砌给出相同的结果。<span class="math inline">\(\mathrm{AZ}(n+1)\)</span> 的空白部分由 <span class="math inline">\(k+n+1\)</span> 个黑方块组成，这里多出来的 <span class="math inline">\(n+1\)</span> 是因为 <span class="math inline">\(\mathrm{AZ}(n+1)\)</span> 比 <span class="math inline">\(\mathrm{AZ}(n)\)</span> 多了 <span class="math inline">\(4(n+1)\)</span> 个方格，所以要多 <span class="math inline">\(n+1\)</span> 个方块。所以有 <span class="math inline">\(2^{k+n+1}\)</span> 种不同的生成方式得到 <span class="math inline">\(\mathrm{AZ}(n+1)\)</span> 的铺砌，数目正好是原来的<span class="math inline">\(2^{n+1}\)</span> 倍。这就是递推关系。</p><p>这个算法用 Propp 论文中介绍的图变换的角度更容易看清楚。</p><h1 id="蜘蛛移动">蜘蛛移动</h1><p>多米诺铺砌实质上是图的完美匹配：考虑图 <span class="math inline">\(G_n\)</span>，<span class="math inline">\(G_n\)</span> 的顶点与 <span class="math inline">\(\mathrm{AZ}(n)\)</span>中的方格一一对应，两个顶点相邻当且仅当它们对应的方格在 <span class="math inline">\(\mathrm{AZ}(n)\)</span> 中有公共的边，于是 <span class="math inline">\(\mathrm{AZ}(n)\)</span> 的多米诺铺砌与 <span class="math inline">\(G_n\)</span> 的完美匹配 (perfect matching)一一对应。</p><figure><img src="/images/aztec/matching.svg" width="350" alt="将 \mathrm{AZ}(n) 视作一个二分图 G_n"><figcaption aria-hidden="true">将 <span class="math inline">\(\mathrm{AZ}(n)\)</span> 视作一个二分图 <span class="math inline">\(G_n\)</span></figcaption></figure><p>现在问题转化为求 <span class="math inline">\(G_n\)</span>的完美匹配的个数，基本的想法是权函数。</p><p>设 <span class="math inline">\(G\)</span> 是一个简单平面图，<span class="math inline">\(G\)</span> 的每条边 <span class="math inline">\(e\)</span> 有一个权值 <span class="math inline">\(w(e)\)</span>，<span class="math inline">\(w(e)\)</span> 是一个变量，比如 <span class="math inline">\(x,y,z,w\)</span>。对 <span class="math inline">\(G\)</span> 的一个完美匹配 <span class="math inline">\(\pi\)</span>，定义 <span class="math inline">\(\pi\)</span> 的权值 <span class="math inline">\(w(\pi)\)</span> 为 <span class="math inline">\(\pi\)</span> 中所有边的权值的乘积：</p><p><span class="math display">\[w(\pi)=\prod_{e\in\pi}w(e).\]</span></p><p>并定义 <span class="math inline">\(G\)</span> 的权函数 <span class="math inline">\(w(G)\)</span> 为 <span class="math inline">\(G\)</span> 的所有完美匹配的权值的和： <span class="math display">\[w(G)=\sum_{\pi}w(\pi).\]</span></p><p>如果 <span class="math inline">\(G\)</span> 的每条边的权值都是1，那么 <span class="math inline">\(w(G)\)</span> 就是 <span class="math inline">\(G\)</span>的完美匹配的个数。但是一般情况下边的权值是未定元，所以 <span class="math inline">\(w(G)\)</span>是一个包含未定元的多元函数。但是只要求出了 <span class="math inline">\(w(G)\)</span> 的表达式，把其中所有变元都赋值为1，就得到了 <span class="math inline">\(G\)</span>的完美匹配的个数。</p><p>能求出权函数来当然是一件好事，因为权函数里面包含了图的非常多的信息，可以帮助我们计算出许多其它感兴趣的量来。比如说指定一条边<span class="math inline">\(e\)</span>，问 <span class="math inline">\(G\)</span> 有多少个匹配不包含 <span class="math inline">\(e\)</span>？为此只要把边 <span class="math inline">\(e\)</span> 的权值设置为 0，其它的边权值保持为1，代入权函数中即可。</p><p>看起来求出图的权函数是一个比直接计算其完美匹配的个数更复杂的问题，那为什么我们要舍近求远呢？权函数方法的奥秘在哪里呢？</p><p>这就是关键所在：对于一个复杂的图，我们想通过一些「手术」或者「变换」把它变成简单一些的图，比如删去一些顶点和边，或者把其中的一部分用一个新图去替换。这些变换通常会改变图的完美匹配的个数，但是权函数却在变换前后保持某种递推关系从而可以求解出来。这种操作我们其实都见到过，高中物理中电网络的各种等效电路替换（如<span class="math inline">\(Y-\Delta\)</span> 变换）就是图变换。</p><p>Propp 使用的图变换基于下面的蜘蛛引理：</p><div id="spider-move" class="unnumbered statement sta_____ plain"><p><span class="statement-heading"><span class="statement-label">蜘蛛移动</span>.</span><span class="statement-spah"> </span>假设图 <span class="math inline">\(G\)</span>的某个局部是一个正方形，如下图左边所示：</p><figure><img src="/images/aztec/spidermove.svg" width="500" alt="蜘蛛移动"><figcaption aria-hidden="true">蜘蛛移动</figcaption></figure><p>这里正方形的四个顶点记作 <span class="math inline">\(ABCD\)</span>，四条边权值分别为 <span class="math inline">\(x,y,z,w\)</span>。虚线表示它们可能与 <span class="math inline">\(G\)</span> 的其它部分相连。</p><p>现在我们保持 <span class="math inline">\(G\)</span>其它的部分不动，将正方形 <span class="math inline">\(ABCD\)</span>替换为一个新的局部图，如上图右边所示。新局部的正方形部分四条边的权值分别是<span class="math inline">\(z/\Delta,w/\Delta,x/\Delta,y/\Delta\)</span>，其中<span class="math inline">\(\Delta =xz+yw\)</span>。多出来的四条边的权值都是 1。记替换后则得到的新图为 <span class="math inline">\(G'\)</span>，则 <span class="math inline">\(G'\)</span> 与原图 <span class="math inline">\(G\)</span> 的权函数的关系为 <span class="math display">\[w(G)=w(G')\cdot\Delta.\]</span></p></div><p><strong>证明</strong>：对 <span class="math inline">\(G\)</span>的任一匹配 <span class="math inline">\(\pi\)</span>，我们考察 <span class="math inline">\(\pi\)</span> 在正方形 <span class="math inline">\(ABCD\)</span> 处的匹配情况。根据 <span class="math inline">\(ABCD\)</span> 中包含的 <span class="math inline">\(\pi\)</span> 中边的个数，有三种可能：</p><ol type="1"><li><span class="math inline">\(ABCD\)</span> 正好匹配成两对，即它们包含<span class="math inline">\(\pi\)</span> 的两条边；</li><li><span class="math inline">\(ABCD\)</span>中有两个匹配在一起，另外两个与外部匹配，即它们包含 <span class="math inline">\(\pi\)</span> 的一条边。</li><li><span class="math inline">\(ABCD\)</span> 互不匹配，即它们不含 <span class="math inline">\(\pi\)</span> 的边。</li></ol><p>设 <span class="math inline">\(Q\)</span> 是 <span class="math inline">\(\pi\)</span> 在除去正方形 <span class="math inline">\(ABCD\)</span>后剩下部分的权。依次讨论这三种可能：</p><ol type="1"><li><p>若 <span class="math inline">\(\pi\)</span>属于第一类情形，则有两种可能：<span class="math inline">\(\{A,B\},\{C,D\}\)</span> 或者 <span class="math inline">\(\{A,D\},\{B,C\}\)</span>。这两种可能对应于 <span class="math inline">\(G'\)</span> 的一个匹配 <span class="math inline">\(\pi^\ast\)</span>，如下图所示：</p><figure><img src="/images/aztec/case1.svg" width="500" alt="情形 1"><figcaption aria-hidden="true">情形 1</figcaption></figure><p><span class="math inline">\(\pi\)</span> 的两种可能性的权分别是 <span class="math inline">\(xzQ\)</span> 和 <span class="math inline">\(ywQ\)</span>，和是 <span class="math inline">\(\Delta Q\)</span>；<span class="math inline">\(\pi^\ast\)</span> 的权是 <span class="math inline">\(Q\)</span>，变换后的权值是变换前的 <span class="math inline">\(1/\Delta\)</span>。</p></li><li><p>若 <span class="math inline">\(\pi\)</span>属于第二类情形，则不妨设顶点 <span class="math inline">\(\{A,B\}\)</span> 匹配（另外三种可能的情形是 <span class="math inline">\(\{B,C\}\)</span>，<span class="math inline">\(\{C,D\}\)</span>，<span class="math inline">\(\{A,D\}\)</span>，分析是类似的），则 <span class="math inline">\(\pi\)</span> 可以唯一地对应到 <span class="math inline">\(G'\)</span> 的一个匹配 <span class="math inline">\(\pi^\ast\)</span>，如下图所示：</p><figure><img src="/images/aztec/case2.svg" width="500" alt="情形 2"><figcaption aria-hidden="true">情形 2</figcaption></figure><p><span class="math inline">\(\pi\)</span> 的权是 <span class="math inline">\(xQ\)</span>，<span class="math inline">\(\pi^\ast\)</span> 的权是 <span class="math inline">\(xQ/\Delta\)</span>，变换后的权值仍然是变换前的<span class="math inline">\(1/\Delta\)</span>。</p></li><li><p>若 <span class="math inline">\(\pi\)</span> 属于第三类情形，则<span class="math inline">\(\pi\)</span> 可以映射为 <span class="math inline">\(G'\)</span> 中的两个匹配 <span class="math inline">\(\pi^\ast_1,\pi^\ast_2\)</span>：</p><figure><img src="/images/aztec/case3.svg" width="500" alt="情形 3"><figcaption aria-hidden="true">情形 3</figcaption></figure><p><span class="math inline">\(\pi\)</span> 的权是 <span class="math inline">\(Q\)</span>，<span class="math inline">\(\pi^\ast_1,\pi^\ast_2\)</span> 的权分别是 <span class="math inline">\(xzQ/\Delta^2\)</span> 和 <span class="math inline">\(ywQ/\Delta^2\)</span>，它们的和是 <span class="math inline">\(Q/\Delta\)</span>，仍然是变换前的 <span class="math inline">\(1/\Delta\)</span>。</p></li></ol><p>于是 <span class="math inline">\(G\)</span>的匹配可以划分为不相交的三个子集 <span class="math inline">\(X_1,X_2,X_3\)</span>，它们分别对应上面列出的三种情形。相应地<span class="math inline">\(G'\)</span>的匹配也可以分为三个不相交的子集 <span class="math inline">\(Y_1,Y_2,Y_3\)</span>。<span class="math inline">\(X_1\)</span> 中每两个对应 <span class="math inline">\(Y_1\)</span> 中的一个，<span class="math inline">\(X_2\)</span> 和 <span class="math inline">\(Y_2\)</span> 一一对应，<span class="math inline">\(X_3\)</span> 中每一个对应 <span class="math inline">\(Y_3\)</span> 中的两个。在这个对应下 <span class="math inline">\(Y_i\)</span> 中所有匹配的权之和 <span class="math inline">\(w(Y_i)=w(X_i)/\Delta\)</span>，从而 <span class="math inline">\(w(G')=\sum_{i=1}^3w(Y_i)=w(G)/\Delta\)</span>。</p><p>下面这个引理在下节会用到，它的证明非常简单，所以我省略它的证明。</p><div id="contraction" class="unnumbered statement sta_____-1 plain"><p><span class="statement-heading"><span class="statement-label">顶点收缩</span>.</span><span class="statement-spah"></span>如果某个顶点只有两个邻居，并且它和这两个邻居之间的边的权值都是1，则我们可以将这个顶点以及它的两个邻居收缩为一个顶点。这样得到的新图与原图有同样的权函数。如下图所示：</p><figure><img src="/images/aztec/contraction.svg" width="400" alt="顶点收缩"><figcaption aria-hidden="true">顶点收缩</figcaption></figure></div><h1 id="用图变换求解计数问题">用图变换求解计数问题</h1><p>我们用蜘蛛移动的技巧来计算 <span class="math inline">\(G_n\)</span>的权函数 <span class="math inline">\(w(G_n)\)</span>满足的递推关系。</p><p>把 <span class="math inline">\(\mathbb{Z}^2\)</span>的顶点间隔染成黑白两色。如果一个 <span class="math inline">\(2\times2\)</span>的方块的左上角的顶点是黑色，就称它是一个「<strong>胞腔</strong>」。胞腔就是前面洗牌算法中的「黑方块」。对每个胞腔的四条边，从右侧开始顺时针依次标记其权重为<span class="math inline">\(x,y,z,w\)</span>。</p><p>我们从 <span class="math inline">\(G_{n-1}\)</span> 开始。下图是<span class="math inline">\(G_2\,(n=3)\)</span> 的例子：</p><figure><img src="/images/aztec/G1.svg" width="250" alt="G_2"><figcaption aria-hidden="true"><span class="math inline">\(G_2\)</span></figcaption></figure><p>然后我们给 <span class="math inline">\(G_{n-1}\)</span>外侧装饰上一些边，把它变成一个更大的图 <span class="math inline">\(G_n^{(1)}\)</span>。<span class="math inline">\(G_n^{(1)}\)</span> 包含 <span class="math inline">\(G_n\)</span> 作为子图，但是又比 <span class="math inline">\(G_n\)</span>多出一些蓝色的边。这些蓝色的边权值都是 1。<span class="math inline">\(G_n^{(1)}\)</span>的匹配在这些装饰的边处是限制死的，必须包含蓝色的边，所以 <span class="math inline">\(G_n^{(1)}\)</span> 和 <span class="math inline">\(G_{n-1}\)</span> 的权函数完全相同：</p><figure><img src="/images/aztec/G2.svg" width="350" alt="G_n^{(1)} 是 G_2 的扩展，二者的权函数相同"><figcaption aria-hidden="true"><span class="math inline">\(G_n^{(1)}\)</span> 是 <span class="math inline">\(G_2\)</span> 的扩展，二者的权函数相同</figcaption></figure><p>对 <span class="math inline">\(G_n^{(1)}\)</span>在各个胞腔处分别使用 <a href="#spider-move" title="蜘蛛移动">蜘蛛移动</a>，得到图 <span class="math inline">\(G_n^{(2)}\)</span>：</p><figure><img src="/images/aztec/G3.svg" width="350" alt="对 G_n^{(1)} 使用蜘蛛移动后得到 G_n^{(2)}"><figcaption aria-hidden="true">对 <span class="math inline">\(G_n^{(1)}\)</span> 使用蜘蛛移动后得到 <span class="math inline">\(G_n^{(2)}\)</span></figcaption></figure><p>由于我们总共对 <span class="math inline">\(n^2\)</span>个胞腔使用了蜘蛛移动，因此 <span class="math inline">\(G_n^{(2)}\)</span> 的权函数是 <span class="math display">\[w(G_n^{(2)})=\frac{w(G_n^{(1)})}{\Delta^{n^2}} =\frac{w(G_{n-1})}{\Delta^{n^2}}.\]</span></p><p>对 <span class="math inline">\(G_n^{(2)}\)</span> 使用 <a href="#contraction" title="顶点收缩">顶点收缩</a>，我们得到了 <span class="math inline">\(G_n^{(3)}\)</span>：</p><figure><img src="/images/aztec/G4.svg" width="350" alt="对 G_n^{(2)} 使用顶点收缩得到 G_n^{(3)}"><figcaption aria-hidden="true">对 <span class="math inline">\(G_n^{(2)}\)</span> 使用顶点收缩得到 <span class="math inline">\(G_n^{(3)}\)</span></figcaption></figure><p>顶点收缩不改变权函数，所以 <span class="math display">\[w(G_n^{(3)})= w(G_n^{(2)}) = \frac{w(G_{n-1})}{\Delta^{n^2}}.\]</span></p><p><span class="math inline">\(G_n^{(3)}\)</span> 作为图和 <span class="math inline">\(G_n\)</span>是一样的，但是每个胞腔四条边的权值变成了 <span class="math inline">\(x/\Delta,y/\Delta,z/\Delta,w/\Delta\)</span>，因此其权函数为<span class="math inline">\(w(G_n)/\Delta^{n(n+1)}\)</span>（因为 <span class="math inline">\(G_n\)</span> 的每个匹配都包含 <span class="math inline">\(n(n+1)\)</span> 条边，是 <span class="math inline">\(G_n\)</span>的顶点个数的一半）。从而我们用两种方法得到了 <span class="math inline">\(G_n^{(3)}\)</span> 的权函数，即 <span class="math display">\[\frac{w(G_{n-1})}{\Delta^{n^2}}=\frac{w(G_n)}{\Delta^{n(n+1)}}.\]</span>也就是 <span class="math inline">\(w(G_n)=\Delta^nw(G_{n-1})\)</span>。这就是 <span class="math inline">\(\{w(G_n)\}\)</span> 满足的递推关系。</p><p>由初始条件 <span class="math inline">\(w(G_1)=\Delta\)</span> 可得<span class="math inline">\(w(G_n)=\Delta^{n(n+1)/2}\)</span>。特别令<span class="math inline">\(w=x=y=z=1\)</span> 我们就得到 <span class="math inline">\(\mathrm{AZ}(n)\)</span> 的多米诺铺砌的个数为 <span class="math inline">\(2^{n(n+1)/2}\)</span>。</p><h1 id="从图变换的角度看洗牌算法">从图变换的角度看洗牌算法</h1><p>最后我们从图变换的角度解释为什么洗牌算法是正确的。你会看到，洗牌算法的三个操作步骤恰好对应<a href="#spider-move" title="蜘蛛移动">蜘蛛移动</a> 中的三种情形。</p><p>在下图中，胞腔是深色，匹配的边是红色。三个胞腔 I, II, III 分别对应 <a href="#spider-move" title="蜘蛛移动">蜘蛛移动</a> 的三种情形：I包含匹配的两条边；II 包含匹配的一条边；III 不含匹配的边。</p><figure><img src="/images/aztec/trans1.svg" width="350" alt="注意看，I, II, III 三个胞腔将分别对应蜘蛛移动中的三种情形，即洗牌算法的三个步骤。"><figcaption aria-hidden="true">注意看，I, II, III三个胞腔将分别对应蜘蛛移动中的三种情形，即洗牌算法的三个步骤。</figcaption></figure><p>蜘蛛移动以后的结果如下。注意初始 <span class="math inline">\(\mathbb{Z}^2\)</span> 中的边不属于新图。</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr><td style="text-align: center;">只有红色边和虚线边属于新图</td><td style="text-align: center;">拿走 <span class="math inline">\(\mathbb{Z}^2\)</span> 的边后的效果</td></tr><tr><td style="text-align: center;"><img src="/images/aztec/trans2.svg" width="350"></td><td style="text-align: center;"><img src="/images/aztec/trans3.svg" width="350"></td></tr></tbody></table><p>收缩后我们得到了 <span class="math inline">\(\mathbb{Z}^2\)</span>的一个新匹配。如下图所示：</p><figure><img src="/images/aztec/trans4.svg" width="350" alt="收缩后的效果，注意 I, II, II 三个胞腔中匹配的变化"><figcaption aria-hidden="true">收缩后的效果，注意 I, II, II三个胞腔中匹配的变化</figcaption></figure><p>与原匹配相比，I 中的边「删除」了，II 中的边「移动」到了对面，III中「生成」了两条新边，正好与洗牌算法一致。同时胞腔的染色发生了翻转，即白方块和黑方块互换了颜色。</p><h1 id="结语">结语</h1><p>Aztec钻石图背后有许多有趣而深刻的数学，即便是计数这样看似初等的问题也有许多奥妙在里面，比如还有基于graph condensation 的证明、转化为不相交路径组计数的证明、利用 <span class="math inline">\({\rm GL}_n(\mathbb{C})\)</span>的表示等精彩的证明，它们背后的思想已经广泛应用在计数组合学的许多问题中。借用丘吉尔的一句话作为结尾：“Nowthis is not the end. It is not even the beginning of the end. But it is,perhaps, the end of the beginning”。</p><p>顺便一提，演示多米诺算法的 GIF 动图是我学习 Python的第一个正式程序，从开始看语法到写出最初的粗糙版本花了一周左右的时间。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-dominoshuffling" class="csl-entry" role="listitem">Elkies, Noam, Greg Kuperberg, Michael Larsen, and James Propp. 1991.<span>“Alternating Sign Matrices and Domino Tilings.”</span> <em>J.Algebraic Combin. 1 (1992), No. 2, 111–132; J. Algebraic Combin. 1(1992), No. 3, 219-234</em>, June. <a href="https://arxiv.org/abs/math/9201305v1">https://arxiv.org/abs/math/9201305v1</a>.</div><div id="ref-spidermove" class="csl-entry" role="listitem">Propp, James. 2001. <span>“Generalized Domino-Shuffling.”</span><em>Theoret. Comput. Sci. 303, No. 2-3, 267–301, Tilings of the Plane(2003).</em>, November. <a href="https://arxiv.org/abs/math/0111034v2">https://arxiv.org/abs/math/0111034v2</a>.</div></div>]]></content>
      
      
      <categories>
          
          <category> 计数组合学 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="about/index.html"/>
      <url>about/index.html</url>
      
        <content type="html"><![CDATA[<p>欢迎来到 <strong>赵亮</strong>的个人网站。这里记录了我的一些关于数学和编程方面的文章，它们大致可以分为三类：</p><ol type="1"><li>从通俗有趣的问题出发介绍它们背后的数学。</li><li>我写过的（自以为）有趣的开源项目。</li><li>一些念书时的笔记（非常枯燥）。</li></ol><p>由于个人水平不足，文中难免出现错误，还请读者不吝指正。</p><p>个人方面，以下信息也许对你了解我有帮助：</p><ol type="1"><li>80 后，已婚，有娃一只。</li><li>工作之余带娃、念数学、写代码。</li><li>喜欢听罗大佑/邓丽君/Beyond，最喜欢的电影有《肖申克的救赎》，《真实的谎言》，《谍影重重》。</li><li>郑渊洁和刘慈欣爱好者。</li></ol><p>博客使用 <a href="https://hexo.io/">hexo</a> 搭建，主题为 <a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism">raytaylorism</a>，我在其基础上做了一些修改，特此鸣谢作者。</p><p>文章是在 markdown 中书写的，用 <a href="https://pandoc.org/">Pandoc</a> 渲染，<a href="https://github.com/dialoa/statement">statement</a>生成自动编号的定理环境。</p><p>转载文章和图片注明出处即可。所有代码均采用 <a href="https://opensource.org/licenses/MIT">MIT LICENSE</a>。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter 群语言正则的证明</title>
      <link href="coxeter-automatic/index.html"/>
      <url>coxeter-automatic/index.html</url>
      
        <content type="html"><![CDATA[<div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.1</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha,\beta\in\Phi\)</span> 满足 <span class="math inline">\(|(\alpha,\beta)|&lt;1\)</span>，则必然有 <span class="math inline">\((\alpha,\beta)=\cos(p\pi/q)\)</span>，其中 <span class="math inline">\(p,q\)</span> 是互素的正整数，而且反射 <span class="math inline">\(r_\alpha,r_\beta\)</span> 生成的子群是有限群。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(|(\alpha,\beta)|&lt;1\)</span>，则内积 <span class="math inline">\((\,,)\)</span> 限制在 <span class="math inline">\(\alpha,\beta\)</span> 张成的二维子空间 <span class="math inline">\(U=\mathop{\mathrm{span}}{\{\alpha,\beta\}}\)</span>上是正定的。</p><p>我们可以不妨假定 <span class="math inline">\(\alpha\)</span>是正根，以及 <span class="math inline">\(\beta=\alpha_s\)</span>是单根。设 <span class="math display">\[\alpha = c_s\alpha_s +\sum_{t\ne s }c_t\alpha_t.\]</span> 由于 <span class="math inline">\(\alpha\)</span> 不可能是 <span class="math inline">\(\alpha_s\)</span> 的正倍数，所以 <span class="math inline">\(\gamma=\alpha - c_s\alpha_s\ne0\)</span>。</p><p>注意到如果 <span class="math inline">\(a,b\in\mathbb{R}\)</span> 使得<span class="math inline">\(a\gamma+b\alpha_s\in\Phi\)</span>，则 <span class="math inline">\(a,b\)</span> 必须同时非负，或者同时非正。如果<span class="math inline">\(\alpha,\beta\)</span> 所夹的角度是 <span class="math inline">\(\pi\)</span> 的无理数倍，那么 <span class="math inline">\((r_\alpha s)\)</span> 是 <span class="math inline">\(U\)</span> 上角度为 <span class="math inline">\(\pi\)</span> 的无理数倍的旋转，它的各次幂 <span class="math inline">\(\{(r_\alpha s)^n,n=0,1,\ldots,\}\)</span> 会将<span class="math inline">\(\alpha\)</span> 映射为 <span class="math inline">\(U\)</span>中单位圆周上稠密的集合，特别地必然有某个 <span class="math inline">\(k\)</span> 使得 <span class="math inline">\((r_\alpha s)^k\alpha\)</span> 位于区域 <span class="math inline">\(\{a\gamma+b\alpha_s\mid a &gt; 0,b&lt;0\}\)</span> 中，这与此区域不包含任何根矛盾。所以 <span class="math inline">\(\alpha,\beta\)</span> 所夹的角度必须是 <span class="math inline">\(\pi\)</span> 的有理数倍，形如 <span class="math inline">\(p\pi/q\)</span>，从而 <span class="math inline">\(r_\alpha,r_\beta\)</span> 生成的子群 <span class="math inline">\(D\)</span> 在 <span class="math inline">\(U\)</span> 上的作用是一个二面体群。另一方面 <span class="math inline">\((\,,)\)</span> 限制在 <span class="math inline">\(U\)</span> 上是正定的，所以 <span class="math inline">\(V=U\oplus U^\bot\)</span>。而 <span class="math inline">\(D\)</span> 作用在 <span class="math inline">\(U^\bot\)</span> 上是平凡的，所以 <span class="math inline">\(D\)</span> 在全空间上的作用也是二面体群。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义0.2</span>.</span><span class="statement-spah"> </span>对任何正根 <span class="math inline">\(\alpha\in\Phi^+\)</span>，定义其深度为 <span class="math display">\[\mathrm{dp}(\alpha)=\min\{\,l(w) \midw\alpha\in\Phi^-\,\}.\]</span> 对两个正根 <span class="math inline">\(\alpha,\beta\)</span>，定义 <span class="math inline">\(\alpha\preceq\beta\)</span> 当且仅当存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(\beta=w\alpha\)</span> 并且 <span class="math display">\[\mathrm{dp}(\beta)=\mathrm{dp}(\alpha)+l(w).\]</span>如果 <span class="math inline">\(\alpha\preceq\beta\)</span> 且 <span class="math inline">\(\alpha\ne\beta\)</span> 我们记为 <span class="math inline">\(\alpha\prec\beta\)</span>。</p></div><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\preceq\)</span> 是 <span class="math inline">\(\Phi^+\)</span> 上的偏序。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span> 使得 <span class="math inline">\(\alpha\prec\beta\)</span>，则必然有 <span class="math inline">\(\mathrm{dp}(\beta)&gt;\mathrm{dp}(\alpha)\)</span>，即<span class="math inline">\(\preceq\)</span> 是反对称的。我们只要再证明<span class="math inline">\(\preceq\)</span> 是传递的。</p><p>设 <span class="math inline">\(\alpha,\beta,\gamma\in\Phi^+\)</span>满足 <span class="math inline">\(\alpha\preceq\beta\)</span> 和 <span class="math inline">\(\beta\preceq\gamma\)</span>，我们来证明 <span class="math inline">\(\alpha\preceq\gamma\)</span>。为此我们设 <span class="math display">\[\begin{aligned}\beta &amp;= u\alpha, &amp;\mathrm{dp}(\beta) - \mathrm{dp}(\alpha) =l(u).\\\gamma &amp;= v\beta, &amp;\mathrm{dp}(\gamma) - \mathrm{dp}(\beta) =l(v).\\\end{aligned}\]</span> 显然 <span class="math inline">\(\gamma=vu\alpha\)</span> 且<span class="math inline">\(\mathrm{dp}(\gamma)-\mathrm{dp}(\alpha)=l(u)+l(v)\)</span>。只要再证明 <span class="math inline">\(l(uv)=l(u)+l(v)\)</span> 即可。</p><p>设 <span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(w\alpha\in\Phi^-\)</span> 且 <span class="math inline">\(l(w)=\mathrm{dp}(\alpha)\)</span>。于是 <span class="math display">\[\gamma=vu\alpha\Rightarrowu^{-1}v^{-1}\gamma=\alpha \Rightarrowwu^{-1}v^{-1}\gamma\in\Phi^-.\]</span> 从而 <span class="math inline">\(l(wu^{-1}v^{-1})\geq\mathrm{dp}(\gamma)\)</span>。</p><p>另一方面 <span class="math display">\[l(wu^{-1}v^{-1})\leql(w)+(l(u)+l(v))=\mathrm{dp}(\alpha)+(\mathrm{dp}(\gamma)-\mathrm{dp}(\alpha))=\mathrm{dp}(\gamma).\]</span>所以 <span class="math inline">\(l(wu^{-1}v^{-1})=\mathrm{dp}(\gamma)\)</span>，特别地上式中所有的不等号都是等号，于是<span class="math inline">\(l(wu^{-1}v^{-1})=l(w)+l(u)+l(v)\)</span>，从而必然有 <span class="math inline">\(l(uv)=l(u)+l(v)\)</span>。<span class="math inline">\(\blacksquare\)</span>。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha_s\)</span> 是单根，<span class="math inline">\(\alpha\ne\alpha_s\)</span> 是正根，则 <span class="math display">\[\mathrm{dp}(s\alpha)=\begin{cases}\mathrm{dp}(\alpha)-1&amp; \text{if } (\alpha,\alpha_s)&gt;0,\\\mathrm{dp}(\alpha) &amp;\text{if } (\alpha,\alpha_s)=0.\\\mathrm{dp}(\alpha)+1 &amp; \text{if }(\alpha,\alpha_s)&lt;0.\end{cases}\]</span></p></div><p>第二条是显然的，而第三条可以由第一条得出：只要对 <span class="math inline">\(s\alpha\)</span>应用第一条的结论即可。所以我们只需要证明第一条。</p><p>首先取 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(l(w)=\mathrm{dp}(\alpha)\)</span> 且 <span class="math inline">\(w\alpha\in\Phi^-\)</span>。</p><ol type="1"><li><p>如果 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>，则<span class="math inline">\(l(ws)&lt;l(w)\)</span>，并且 <span class="math inline">\(ws\)</span> 满足 <span class="math inline">\((ws)(s\alpha)&lt;0\)</span>，所以 <span class="math inline">\(\mathrm{dp}(s\alpha)\leql(ws)=l(w)-1\)</span>，从而 <span class="math inline">\(\mathrm{dp}(s\alpha)=l(w)-1\)</span>。</p></li><li><p>如果 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>，则<span class="math inline">\(w(s\alpha)\)</span> 是负根，并且 <span class="math display">\[\begin{align*}w(s\alpha)&amp;=w(\alpha - 2(\alpha,\alpha_s)\alpha_s)\\&amp;=w\alpha-cw\alpha_s (c&gt;0)\end{align*}\]</span> 由于 <span class="math inline">\(\alpha\ne\alpha_s\)</span>是不同的正根，所以它们不共线，从而 <span class="math inline">\(w\alpha\)</span> 和 <span class="math inline">\(w\alpha_s\)</span>也不共线，于是上式是两个不共线的负根的和，所以任何单反射不能将 <span class="math inline">\(w(s\alpha)\)</span> 变成正根。取 <span class="math inline">\(t\in S\)</span> 使得 <span class="math inline">\(l(tw)&lt;l(w)\)</span>，则 <span class="math inline">\((tw)(s\alpha)\)</span> 仍然是负根，所以 <span class="math inline">\(\mathrm{dp}(s\alpha)\leql(tw)=l(w)-1\)</span>，结论仍然得证。</p></li></ol><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.5</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha\preceq\beta\)</span>，则存在序列 <span class="math display">\[\alpha=\alpha_0\preceq\alpha_1\preceq\cdots\preceq\alpha_k=\beta\]</span>使得对每个 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(\mathrm{dp}(\alpha_{i+1})=\mathrm{dp}(\alpha_i)+1\)</span>。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(w=s_k\cdotss_1\)</span> 满足 <span class="math inline">\(\beta=w\alpha\)</span> 且<span class="math inline">\(l(w)=\mathrm{dp}(\beta)-\mathrm{dp}(\alpha)\)</span>，考虑<span class="math inline">\(\alpha_i=s_i\cdots s_1\alpha\)</span>，其中<span class="math inline">\(\alpha_0=\alpha\)</span>，<span class="math inline">\(\alpha_k=\beta\)</span>。从 <span class="math inline">\(\alpha_0\)</span> 到 <span class="math inline">\(\alpha_k\)</span> 经过了 <span class="math inline">\(k=l(w)\)</span> 次单反射，depth 增加了 <span class="math inline">\(l(w)\)</span>，但上面的引理告诉我们每次单反射depth 至多增加 1，所以只能是每一项的 depth 都比前一项增加了1，即得结论。</p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.6</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\alpha\preceq\beta\)</span>，且 <span class="math inline">\(\alpha=\sum c_s\alpha_s,\, \beta=\sumd_s\alpha_s\)</span>，则对每个 <span class="math inline">\(s\)</span> 有<span class="math inline">\(c_s\leq d_s\)</span>。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(\beta=s\alpha\)</span> 则 <span class="math inline">\(\alpha,\beta\)</span> 只有在 <span class="math inline">\(\alpha_s\)</span> 项的系数不同。又 <span class="math inline">\((\alpha,\alpha_s)&lt;0\)</span> 所以 <span class="math inline">\(d_s&gt;c_s\)</span> 得证。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义0.7</span>.</span><span class="statement-spah"> </span>对 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span>，如果对任何 <span class="math inline">\(w\in W\)</span> 都有 <span class="math inline">\(w\alpha\in\Phi^-\Rightarroww\beta\in\Phi^-\)</span>，我们就称 <span class="math inline">\(\alpha\)</span> 支配 <span class="math inline">\(\beta\)</span>，记作 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>。</p></div><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.8</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span> 且 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>，则：</p><ol type="1"><li><span class="math inline">\((\alpha,\beta)&gt;0\)</span>。</li><li>若 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\beta\)</span> 是正根，则 <span class="math inline">\(w\alpha\,\mathrm{dom}\,w\beta\)</span>。</li><li>若 <span class="math inline">\(\alpha\prec\alpha'\)</span> 则<span class="math inline">\(\alpha'\)</span>不是极小根。换句话说，若一个根是极小根，则在偏序 <span class="math inline">\(\preceq\)</span> 下小于它的根也都是极小根。</li><li><span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>，等号当且仅当<span class="math inline">\(\alpha=\beta\)</span> 时成立。</li></ol></div><p><strong>证明</strong>：</p><ol type="1"><li><p><span class="math inline">\(r_\alpha\)</span> 满足 <span class="math inline">\(r_\alpha\alpha=-\alpha\in\Phi^-\)</span>，所以<span class="math inline">\(r_\alpha\beta=\beta-2(\alpha,\beta)\alpha&lt;0\)</span>，这必须<span class="math inline">\((\alpha,\beta)&gt;0\)</span> 才行。</p></li><li><p>显然。</p></li><li><p>只要对 <span class="math inline">\(\mathrm{dp}(\alpha')=\mathrm{dp}(\alpha)+1\)</span>进行证明即可。这时存在单反射 <span class="math inline">\(s\)</span> 使得<span class="math inline">\(\alpha'=s\alpha\)</span>，并且 <span class="math inline">\((\alpha_s,\alpha)&lt;0\)</span>。根据 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span> 和 <span class="math inline">\((\alpha,\beta)&gt;0\)</span> 说明 <span class="math inline">\(\beta\ne\alpha_s\)</span>，从而 <span class="math inline">\(s\beta\)</span> 是正根，从而 <span class="math inline">\(\alpha'=s\alpha\,\mathrm{dom}\,s\beta\)</span>不是极小根。</p></li><li><p><span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>显然意味着 <span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>。设<span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\alpha=-\alpha_s\)</span> 是某个负的单根，则<span class="math inline">\(w\beta\in\Phi^-\)</span>。注意这时 <span class="math inline">\(w^{-1}\alpha_s=-\alpha&lt;0\)</span>，所以 <span class="math inline">\(l(sw)&lt;l(w)\)</span>。</p><ul><li><p>若 <span class="math inline">\(sw\beta\in\Phi^+\)</span>，则由<span class="math inline">\(w\beta&lt;0\)</span> 可知 <span class="math inline">\(w\beta=-\alpha_s\)</span>，再结合 <span class="math inline">\(w\alpha=-\alpha_s\)</span> 可得 <span class="math inline">\(\alpha=\beta\)</span>。</p></li><li><p>若 <span class="math inline">\(sw\beta\in\Phi^-\)</span>，则<span class="math inline">\(\mathrm{dp}(\beta)\leql(sw)&lt;\mathrm{dp}(\alpha)\)</span>。</p></li></ul></li></ol><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论0.9</span>.</span><span class="statement-spah"> </span>在有限 Coxeter群中，所有根都是极小根。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(w_0\)</span>是最长元，则 <span class="math inline">\(\alpha\to -w_0(\alpha)\)</span>置换 <span class="math inline">\(\Phi^+\)</span>。我们来验证这个置换保持每个正根的深度不变：若<span class="math inline">\(w\alpha&lt;0\)</span>，则 <span class="math inline">\(w_0w\alpha&gt;0\)</span>，从而 <span class="math inline">\((w_0ww_0)-w_0\alpha&lt;0\)</span>，这说明 <span class="math inline">\(\mathrm{dp}(-w_0\alpha)\geql(w_0ww_0)=l(w)\)</span>。对 <span class="math inline">\(-w_0\alpha\)</span> 应用此结论可得 <span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(-w_0\alpha)\)</span>。从而二者相等。</p><p>另一方面我们来验证它翻转 <span class="math inline">\(\,\mathrm{dom}\,\)</span> 这个偏序：若 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>，则 <span class="math display">\[\begin{align*}w\alpha&lt;0&amp;\Rightarrow w\beta&lt;0\\&amp;\Downarrow\\w\beta &gt; 0&amp;\Rightarrow w\alpha&gt;0\\&amp;\Downarrow\\ww_0\beta &gt; 0&amp;\Rightarrow ww_0\alpha&gt;0\\&amp;\Downarrow\\w(-w_0\beta) &lt; 0&amp;\Rightarrow w(-w_0\alpha)&lt;0\\\end{align*}\]</span> 即确实有 <span class="math inline">\(-w_0\beta\,\mathrm{dom}\,-w_0\alpha\)</span>。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.10</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span> 的充要条件是<span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>且 <span class="math inline">\((\alpha,\beta)\geq1\)</span>。</p></div><p><strong>证明</strong>：我们只考虑 <span class="math inline">\(\alpha\ne\beta\)</span> 的情形即可。</p><p><span class="math inline">\(\Rightarrow\)</span>：只要再证明 <span class="math inline">\((\alpha,\beta)\geq1\)</span>。用反证法，若不然，则<span class="math inline">\(0&lt;(\alpha,\beta)&lt;1\)</span>，从而<span class="math inline">\(r_\alpha,r_\beta\)</span>生成一个有限二面体群 <span class="math inline">\(D\)</span>。由于在有限群中没有支配关系，所以存在<span class="math inline">\(w\in D\)</span> 使得 <span class="math inline">\(w\alpha\in\Phi^-,\,w\beta\in\Phi^+\)</span>。这与<span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>矛盾。</p><p><span class="math inline">\(\Leftarrow\)</span>：我们先考虑 <span class="math inline">\(\beta=\alpha_s\)</span> 是一个单根的情形。由于<span class="math inline">\(\alpha\ne\beta\)</span> 所以 <span class="math inline">\(s\alpha\)</span> 仍然是正根。我们发现 <span class="math display">\[(\alpha,s\alpha)=(\alpha,\alpha-2(\alpha,\alpha_s)\alpha_s)=1-2(\alpha,\alpha_s)^2\leq-1.\]</span> 所以有无穷多个形如 <span class="math inline">\(a\alpha+b\alpha_s\)</span> 的正根，其中 <span class="math inline">\(a,b&gt;0\)</span>。</p><p>用反证法，如果 <span class="math inline">\(\alpha\)</span> 不支配<span class="math inline">\(\beta=\alpha_s\)</span>，则存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\alpha\in\Phi^-\)</span> 但 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>。由于 <span class="math display">\[w(s\alpha)=w\alpha -2(\alpha,\alpha_s)w\alpha_s\]</span> 是负根 <span class="math inline">\(w\alpha\)</span> 减去正根 <span class="math inline">\(w\alpha_s\)</span>的一个正倍数，必然仍然是负根。于是 <span class="math inline">\(\{\alpha,s\alpha\}\subsetN(w)\)</span>，从而所有形如 <span class="math inline">\(\{a\alpha+bs\alpha\mid a,b&gt;0\}\)</span>的根都在 <span class="math inline">\(N(w)\)</span> 中，这与 <span class="math inline">\(|N(w)|=l(w)&lt;\infty\)</span> 矛盾。</p><p>对 <span class="math inline">\(\beta\)</span> 是一般正根的情形，取<span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w\beta\in\Delta\)</span>，<span class="math inline">\(l(w)=\mathrm{dp}(\beta)-1\)</span>。由于 <span class="math inline">\(\mathrm{dp}(\alpha)\geq\mathrm{dp}(\beta)\)</span>所以 <span class="math inline">\(w\alpha\)</span> 仍然是正根，当然就有<span class="math inline">\(\mathrm{dp}(w\alpha)\geq\mathrm{dp}(w\beta)=1\)</span>和 <span class="math inline">\((w\alpha,w\beta)=(\alpha,\beta)\geq1\)</span>。根据上面的证明，<span class="math inline">\(w\alpha\,\mathrm{dom}\,w\beta\)</span>，所以 <span class="math inline">\(\alpha\,\mathrm{dom}\,\beta\)</span>。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.11</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\lambda,\mu\)</span> 是正根，且 <span class="math inline">\(s_\lambda,s_\mu\)</span>生成一个无限群，则下面三种情况必居其一：</p><ol type="1"><li><span class="math inline">\(\lambda\,\mathrm{dom}\,\mu\)</span>.</li><li><span class="math inline">\(\mu\,\mathrm{dom}\,\lambda\)</span>.</li><li><span class="math inline">\(s_\mu\lambda\,\mathrm{dom}\,\mu\)</span>且 <span class="math inline">\(s_\lambda\mu\,\mathrm{dom}\,\lambda\)</span>.</li></ol></div><p><strong>证明</strong>：<span class="math inline">\(s_\lambda,s_\mu\)</span> 生成一个无限群说明 <span class="math inline">\(|(\lambda,\mu)|\geq1\)</span>。如果 <span class="math inline">\((\lambda,\mu)\geq1\)</span> 那么 <span class="math inline">\(\lambda,\mu\)</span> 中 depth更大的那一个支配另一个。</p><p>如果 <span class="math inline">\((\lambda,\mu)\leq-1\)</span>我们来证明 <span class="math inline">\(s_\mu\lambda\,\mathrm{dom}\,\mu\)</span>，<span class="math inline">\(s_\lambda\mu\,\mathrm{dom}\,\lambda\)</span>的论证是一样的。注意到这时 <span class="math inline">\((s_\mu\lambda,\mu)=-(\lambda,\mu)\geq1\)</span>，所以只要再证明 <span class="math inline">\(\mathrm{dp}(s_\mu\lambda)\geq\mathrm{dp}(\mu)\)</span> 即可。</p><p>设 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(w(s_\mu\lambda)&lt;0\)</span> 且 <span class="math inline">\(l(w)=\mathrm{dp}(s_\mu\lambda)\)</span>，我们来证明必有一个长度<span class="math inline">\(l(w')\leq l(w)\)</span> 的元素 <span class="math inline">\(w'\)</span> 使得 <span class="math inline">\(w'\mu&lt;0\)</span>，从而 <span class="math inline">\(\mathrm{dp}(s_\mu\lambda)\geq\mathrm{dp}(\mu)\)</span>。</p><p>首先若 <span class="math inline">\(w\mu&lt;0\)</span> 则可以取 <span class="math inline">\(w'=w\)</span>。否则若 <span class="math inline">\(w\mu&gt;0\)</span>，我们来计算 <span class="math display">\[w(s_\mu\lambda)=w\lambda-2(\mu,\lambda)w\mu.\]</span>我们知道这是一个负根，而且它是 <span class="math inline">\(w\lambda\)</span> 加上正根 <span class="math inline">\(w\mu\)</span> 的正倍数，所以必须 <span class="math inline">\(w\lambda&lt;0\)</span>，从而 <span class="math inline">\(l(ws_\lambda)&lt;l(w)\)</span>。</p><p>进一步我们计算 <span class="math display">\[(ws_\lambda)\mu=w\mu-2(\mu,\lambda)w\lambda.\]</span>我们来证明 <span class="math inline">\((ws_\lambda)\mu\)</span>是一个负根，从而 <span class="math inline">\(\mathrm{dp}(\mu)\leql(ws_\lambda)&lt;l(w)=\mathrm{dp}(s_\mu\lambda)\)</span>。</p><p>若不然，记 <span class="math inline">\(c=-2(\mu,\lambda)\geq2\)</span>，若 <span class="math inline">\((ws_\lambda)\mu=w\mu+cw\lambda&gt;0\)</span>，乘以<span class="math inline">\(c\)</span> 得到 <span class="math inline">\(cw\mu+c^2w\lambda\)</span>是正根的非负线性组合（未必还是根），根据上面 <span class="math inline">\(w\lambda+cw\mu&lt;0\)</span>，减去后者得到 <span class="math inline">\((c^2-1)w\lambda\)</span> 是正根的非负线性组合，但<span class="math inline">\(c^2-1\geq 3\)</span>，这与 <span class="math inline">\(w\lambda&lt;0\)</span> 矛盾。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.12</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi^+\)</span> 满足 <span class="math inline">\(\beta\preceq\alpha\)</span>，并且 <span class="math inline">\(\alpha\)</span> 是极小根。进一步设 <span class="math inline">\(\alpha_s\in\Delta\)</span> 满足 <span class="math inline">\((\beta,\alpha_s)\leq-1\)</span>，则 <span class="math inline">\(\alpha\)</span> 和 <span class="math inline">\(\beta\)</span> 的 <span class="math inline">\(\alpha_s\)</span> 项的系数相等。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(\beta\preceq\gamma\preceq\alpha\)</span> 使得<span class="math inline">\(\gamma\)</span> 是偏序 <span class="math inline">\(\preceq\)</span> 下最大的与 <span class="math inline">\(\beta\)</span> 有相同的 <span class="math inline">\(\alpha_s\)</span> 项系数。如果 <span class="math inline">\(\gamma\ne\alpha\)</span>，则存在 <span class="math inline">\(t\)</span> 使得 <span class="math inline">\(\gamma\prec t\gamma\preceq\alpha\)</span>。由<span class="math inline">\(\gamma\)</span> 的极大性可得 <span class="math inline">\(s=t\)</span>。</p><p>但是 <span class="math inline">\(\gamma-\beta=\sum_{t\nes}c_t\alpha_t\)</span>，且每个 <span class="math inline">\(c_t\geq0\)</span>。因此 <span class="math display">\[(s\gamma,\alpha_s)=(\gamma,-\alpha_s)=-(\beta,\alpha_s)-\sum_{t\ner}c_t(\alpha_t,\alpha_s)\geq1.\]</span> 于是 <span class="math inline">\(s\gamma\,\mathrm{dom}\,\alpha_s\)</span>不是极小根，从而 <span class="math inline">\(\alpha\succeqs\gamma\)</span> 也不是极小根。矛盾！所以 <span class="math inline">\(\gamma=\alpha\)</span>，从而命题得证。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题0.13</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha,\beta\in\Phi\)</span> 满足 <span class="math inline">\(|(\alpha,\beta)|\leq 1\)</span>，则这样的 <span class="math inline">\((\alpha,\beta)\)</span> 只有有限多个值。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(|(\alpha,\beta)|&lt;1\)</span> 则 <span class="math inline">\(r_\alpha,r_\beta\)</span> 生成的子群 <span class="math inline">\(D\)</span> 是有限的，所以存在 <span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(wDw^{-1}\)</span> 属于某个有限的标准椭圆子群 <span class="math inline">\(W_J\)</span>，特别地，<span class="math inline">\(r_\alpha r_\beta\)</span> 的阶 <span class="math inline">\(m\)</span> 应该整除 <span class="math inline">\(W_J\)</span> 的阶，从而 <span class="math inline">\((\alpha,\beta)\)</span> 形如 <span class="math inline">\(\cos(a\pi/m)\)</span>，其中 <span class="math inline">\(0\leq a\leq 2m\)</span> 而且 <span class="math inline">\(m\)</span>是某个有限标准椭圆子群的阶的因子。由于这样的子群是有限的，所以这样的<span class="math inline">\(\cos\)</span> 值也是有限的。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理0.14</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\alpha=\sum a_s\alpha_s\)</span> 和 <span class="math inline">\(\beta=\sum b_s\alpha_s\)</span> 都是正根。进一步设<span class="math inline">\(S=I\cup J\)</span> 使得</p><ol type="1"><li>对任何 <span class="math inline">\(t\in I\)</span> 有 <span class="math inline">\((\alpha,\alpha_t)=(\beta,\beta_t)\)</span>。</li><li><span class="math inline">\(c_t=b_t\)</span> 对任何 <span class="math inline">\(t\in J\)</span> 成立。</li></ol><p>则 <span class="math inline">\((\alpha,\beta)=1\)</span>。</p></div><p>注意这里 <span class="math inline">\(I\)</span> 或者 <span class="math inline">\(J\)</span> 允许有一个是空集。</p><p><strong>证明</strong>：我们有 <span class="math inline">\(\alpha-\beta=\sum_{s\inI}(a_s-b_s)\alpha_s\)</span>，所以 <span class="math display">\[(\alpha,\alpha-\beta)=\sum_{s\inI}(a_s-b_s)(\alpha,\alpha_s)=\sum_{s\inI}(a_s-b_s)(\beta,\alpha_s)=(\beta,\alpha-\beta).\]</span> 即 <span class="math inline">\((\alpha,\beta)=1\)</span>。</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理0.15</span>.</span><span class="statement-spah"></span>极小根集合是有限的。</p></div><p><strong>证明</strong>：我们来证明极小根的深度是有上界的。设 <span class="math inline">\(\beta\)</span> 是一个深度为 <span class="math inline">\(d\)</span> 的极小根，<span class="math inline">\(\beta_1\prec\cdots\prec\beta_d=\beta\)</span>是一个序列满足 <span class="math inline">\(\mathrm{dp}(\beta_i)=i\)</span>，则每个 <span class="math inline">\(\beta_i\)</span> 都是极小根。</p><p>记 <span class="math inline">\(J_i=\{\gamma\in\Delta \mid (\gamma,\beta_i)\geq-1\}\)</span>。我们来证明 <span class="math inline">\(\{J_i,1\leq i\leq d\}\)</span>是递降的，并且最终会降为空集。</p><p>对 <span class="math inline">\(1\leq i\leq d\)</span>，若 <span class="math inline">\(\gamma\notin J_i\)</span>，则 <span class="math inline">\(\gamma\)</span> 在所有 <span class="math inline">\(\beta_j(j\geq i)\)</span> 中的系数都相同。</p><p>设 <span class="math inline">\(\beta_i=\sum c_s\alpha_s,\,\beta_j=\sum d_s\alpha_s\)</span>，则 <span class="math inline">\(0\leqc_s\leq d_s\)</span> 且 <span class="math inline">\(c_\gamma=d_\gamma\)</span>。注意到 <span class="math inline">\((\beta_j,\gamma)=\sum_{s\in\Delta}d_s(\alpha_s,\gamma)\leq \sum_{s\in\Delta}c_s(\alpha_s, \gamma)=(\beta_i,\gamma)&lt;-1\)</span>。所以 <span class="math inline">\(\gamma\not\inJ_j\)</span>。即 <span class="math inline">\(\{J_i\}\)</span>确实是递降的。</p><p>设 <span class="math inline">\(J_i=\cdots=J_i=J\)</span> 对某个 <span class="math inline">\(i&lt;j\)</span> 成立。对任何 <span class="math inline">\(\gamma\in J\)</span> 和 <span class="math inline">\(i\leq k\leq j\)</span>，由于 <span class="math inline">\(\beta_k\)</span> 不能支配 <span class="math inline">\(\gamma\)</span>，所以 <span class="math inline">\(-1\leq (\beta,\gamma)\leq 1\)</span>，等于 1当且仅当 <span class="math inline">\(\beta=\gamma\)</span>。于是 <span class="math inline">\((\beta_k,\gamma)\in\mathcal{C}(S)\)</span>。于是如果<span class="math inline">\(j-i&gt;|\mathcal{C}(S)|^{|S|}\)</span>那么必然存在 <span class="math inline">\(i\leq m &lt; n\leq j\)</span>使得 <span class="math inline">\((\beta_m, J)=(\beta_n,J)\)</span>。（鸽笼原理，<span class="math inline">\(\beta\)</span>和一个单根的内积有 <span class="math inline">\(|c|\)</span>种不同的可能值，和所有单根的内积共有 <span class="math inline">\(c^{|S|}\)</span> 种不同的可能值）。</p><p>但是如果 <span class="math inline">\(\gamma\not\in J\)</span>，则<span class="math inline">\(\gamma\)</span> 在 <span class="math inline">\(\beta_m,\beta_n\)</span>中的系数相同，所以根据前面的引理 <span class="math inline">\((\beta_m,\beta_n)=1\)</span>，但这导致 <span class="math inline">\(\beta_n \,\mathrm{dom}\,\beta_m\)</span>，所以如果<span class="math inline">\(j-i&gt;c^{|S|}\)</span> 时 <span class="math inline">\(J_j\)</span> 必须比 <span class="math inline">\(J_i\)</span> 严格地小，所以整个链的长度有限，即<span class="math inline">\(d\)</span> 有限。</p><blockquote><p><strong>引理</strong>：设 <span class="math inline">\(\gamma\)</span>不是极小根，<span class="math inline">\(u,v\in W\)</span> 使得 <span class="math inline">\(u\gamma, v^{-1}\gamma\)</span> 都是单根，则 <span class="math inline">\(l(uv)\ne l(u)+l(v)\)</span>。</p></blockquote><p>证明：设 <span class="math inline">\(u\gamma=\alpha_s,v^{-1}\gamma=\alpha_t\)</span>，则<span class="math inline">\(\gamma\in N(su)\capN(tv^{-1})\)</span>。又设 <span class="math inline">\(\gamma\,\mathrm{dom}\,\beta\)</span>，则 <span class="math inline">\(\beta\in N(su)\cap N(tv^{-1})\)</span>。但是 <span class="math inline">\(u\beta\ne u\gamma=\alpha_s\)</span>，所以 <span class="math inline">\(su\beta\in\Phi^-\)</span> 说明 <span class="math inline">\(u\beta\in\Phi^-\)</span>。同理 <span class="math inline">\(v^{-1}\beta\in\Phi^-\)</span>，所以 <span class="math inline">\(N(u)\cap N(v^{-1})\)</span>非空，所以引理得证。</p><hr><p>设 <span class="math inline">\(\Sigma\)</span>是所有极小根组成的集合，则 <span class="math inline">\(|\Sigma|&lt;\infty\)</span> 是有限集。</p><p>定义状态机如下：</p><p>一个状态 <span class="math inline">\(S_i\subset\Sigma\)</span>是极小根的子集。转移 <span class="math inline">\(S_i\xrightarrow{s}S_{i+1}\)</span> 为：</p><ol type="1"><li>如果 <span class="math inline">\(s\in S_i\)</span> 则 <span class="math inline">\(S_i\xrightarrow{s}\mathrm{NO}\)</span>。</li><li>如果 <span class="math inline">\(s\notin S_i\)</span> 则 <span class="math inline">\(S_i\xrightarrow{s} (sS_i\cup \{\alpha_s\}\cup\{s\alpha_t,t&lt;s\})\cap\Sigma\)</span>。</li></ol><p>我们来证明这个状态机识别语言 <span class="math inline">\(\mathcal{L}\)</span>。</p><p>为方便我们记 <span class="math inline">\(\mathcal{R}_i=\{\alpha_s\in\Delta,s&lt;i\}\)</span> 是那些字典序下小于 <span class="math inline">\(\alpha_i\)</span> 的单根组成的集合。</p><p>假设 <span class="math inline">\(s_1\cdots s_l\in\mathcal{L}\)</span>，但是 <span class="math inline">\(s_1\cdotss_{l+1}\notin \mathcal{L}\)</span> 当且仅当 <span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。其中 <span class="math inline">\(S_i\subset\Sigma\)</span> 是状态机读入 <span class="math inline">\(s_i\)</span> 以后的状态。</p><p>我们来证明对任何 <span class="math inline">\(k\leq l\)</span> 有<span class="math display">\[S_k\subset\{(s_k\cdots s_{i+1})\alpha_i\mid1\leq i\leq l\}\cup\cup_{i=1}^{k}(s_k\cdotss_i)\cdot\mathcal{R}_i.\]</span> 首先 <span class="math inline">\(k=1\)</span> 时 <span class="math inline">\(S_1=\{\alpha_1\}\)</span>，</p><p>由于下一步读入 <span class="math inline">\(s_{l+1}\)</span>的时候是拒绝态，所以 <span class="math inline">\(\alpha_{l+1}\)</span>也属于上面的集合。</p><ul><li><p>如果 <span class="math inline">\(\alpha_{l+1}\in \{(s_l\cdotss_{i+1})\alpha_i\mid 1\leq i\leq l\}\)</span>，则 <span class="math inline">\(s_1\cdots s_ls_{l+1}\)</span> 不是既约的，所以不在<span class="math inline">\(\mathcal{L}\)</span> 中。</p></li><li><p>如果 <span class="math inline">\(\alpha_{l+1}\notin \{(s_l\cdotss_{i+1})\alpha_i\mid 1\leq i\leq l\}\)</span>，则 <span class="math inline">\(s_1\cdots s_ls_{l+1}\)</span> 是既约的，但是 <span class="math inline">\(\alpha_{l+1}\)</span> 形如 <span class="math inline">\(s_l\cdots s_{i}\alpha_r(r&lt;i)\)</span>，所以<span class="math inline">\(s_1\cdotss_{l+1}\notin\mathcal{L}\)</span>。</p></li></ul><p>反之，我们要证明如果 <span class="math inline">\(\mathcal{L}\)</span>拒绝一个字 <span class="math inline">\(w=s_1\cdots s_n\)</span>，设<span class="math inline">\(l\)</span> 是使得 <span class="math inline">\(\mathcal{L}\)</span> 接受 <span class="math inline">\(w\)</span> 的最大位置，则必有 <span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。用反证法，设 <span class="math inline">\(\alpha_{l+1}\notin S_l\)</span>。</p><ul><li><p>如果 <span class="math inline">\(s_1\cdots s_{l+1}\)</span>不是既约的，则存在 <span class="math inline">\(1\leq i\leq l\)</span>使得 <span class="math inline">\(\alpha_{l+1}=s_l\cdotss_{i+1}\alpha_i\)</span>。于是 <span class="math inline">\(l\)</span>在集合 <span class="math inline">\(\{i\leq k\leq l \mid (s_k\cdotss_{i+1})\alpha_i\notin S_k\}\)</span> 中。设 <span class="math inline">\(j\)</span> 是此集合的最小元素，<span class="math inline">\(\beta=s_j\cdots s_{i+1}\alpha_i\)</span>。由于<span class="math inline">\(\alpha_i\in S_i\)</span>，所以 <span class="math inline">\(j&gt;i\)</span>。于是 <span class="math inline">\(s_{j-1}\cdots s_{i+1}\alpha_i\inS_{j-1}\)</span>，<span class="math inline">\(\beta\ins_jS_{j-1}\)</span>。由于 <span class="math inline">\(s_j\cdotS_{j-1}\cap\Sigma\subset S_j\)</span> 这说明 <span class="math inline">\(\beta\)</span> 不是极小根。注意到 <span class="math inline">\((s_{i+1}\cdots s_j)\beta=\alpha_i\)</span> 和<span class="math inline">\((s_{j+1}\cdotss_l)^{-1}\beta=\alpha_{l+1}\)</span>，根据上面的引理 <span class="math inline">\(l(s_{r+1}\cdots s_l)\ne l-i\)</span>，这与 <span class="math inline">\(s_1\cdots s_l\in\mathcal{L}\)</span> 矛盾，所以<span class="math inline">\(\alpha_{l+1}\in S_l\)</span>。</p></li><li><p>如果 <span class="math inline">\(s_1\cdots s_{l+1}\)</span>既约但不属于 <span class="math inline">\(\mathcal{L}\)</span>，则 <span class="math inline">\(\alpha_{l+1}=(s_l\cdotss_{i+1})\alpha_s(s&lt;i)\)</span>。设 <span class="math inline">\(i\leqj\leq l\)</span> 使得 <span class="math inline">\(\beta=(s_js_{j-1}\cdots s_i)\alpha_s\notinS_j\)</span>。如果 <span class="math inline">\(j\ne i\)</span>，则由于<span class="math inline">\(\{s_i\alpha_r\mid r&lt;i\}\cap\Sigma\subsetS_i\)</span> 这说明 <span class="math inline">\(\beta\)</span>不是极小根。若 <span class="math inline">\(j&gt;i\)</span> 同样可得<span class="math inline">\(\beta\)</span>不是极小根。于是根据上面同样的论证得出矛盾。</p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Reaction-Diffusion simulation with pyglet and glsl</title>
      <link href="grayscott/index.html"/>
      <url>grayscott/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/grayscott">Thisproject</a> is motivated by <a href="http://pmneila.github.io/jsexp/grayscott/">pmneila’s javascriptproject</a>. The core part of the code are the two GLSL shaders<code>reaction.frag</code> and <code>render.frag</code>. The pythonscripts are merely for setting the UI and compiling the GLSL code.</p><blockquote><p>Requirements: <code>pyglet</code> for the UI and OpenGL environmentand <code>ffmpeg</code> for saving the animation to video files.</p></blockquote><h1 id="examples">Examples</h1><ol type="1"><li><p>Unstable</p><p><video src="/images/grayscott/unstable.mp4" controls=""></video></p></li><li><p>Coral</p><p><video src="/images/grayscott/coral.mp4" controls=""></video></p></li><li><p>Baceria</p><p><video src="/images/grayscott/bacteria.mp4" controls=""></video></p></li></ol><h1 id="usage">Usage</h1><p>You may simply run <code>python main.py</code> and then use keyboardand mouse to play with the simulation (for keyboard and mouse controlplease see the printed doc).</p><p>You may also initialize the window by passing more options:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python main.py -size 800x600 -fps 400 -conf 1 -scale 2<br></code></pre></td></tr></tbody></table></figure><p>Here <code>-size</code> is the size of the window, <code>-fps</code>is the frames per second of the animation, if not specified then maxpossible value will be used, <code>-conf</code> is the line number ofthe pattern that the program will load from the file<code>config.txt</code> (which contains a few precomputed patterns),<code>-scale</code> is the “resolution” factor of the texture.</p><p>You may also use an image file to control the growth of the patternby adding the <code>-mask</code> option:</p><video src="/images/grayscott/mask.mp4" controls=""><h1 id="how-to-save-the-animation-to-a-video-file">How to save theanimation to a video file</h1><p>Make sure <code>ffmpeg</code> is installed on your computer and canbe found on system path, windows users need to manually add the path toyour ffmpeg.exe to environment variables, then press <code>ctrl+v</code>to start saving the video and press <code>ctrl+v</code> again to stopthe saving.</p><p>You can use the option <code>-videorate</code> to control the fps ofthe video (not the animation!) and the option <code>-samplerate</code>to control how often a frame is sampled from the animation. If theframes are sampled too frequently the size of the video file will growvery large.</p><h1 id="about-the-code">About the code</h1><p><code>pyglet</code> is only a thin wrapper of OpenGL so one has towrite his own classes to manage things like <code>vao</code>,<code>vbo</code>, <code>framebuffer</code>, etc. There are some moduleslike <code>vispy</code> and <code>gletools</code> that does similar job,but that lays the burden of learning one more package.</p><p>I wrote two scripts <code>shader.py</code> and<code>framebuffer.py</code> for compiling the shader programs andrendering to texture. They are not meant to be serious tools, just keptsimple and suffice for our work.</p><p>The GLSL code borrows heavily from pmneila’s work, the most geniuspart in his code is the use of a <code>brush</code> variable(<code>u_mouse</code> in our program) as the interface between theshader and the UI.</p></video>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Make awesome gif animation in a few seconds with pure Python!</title>
      <link href="gifmaze/index.html"/>
      <url>gifmaze/index.html</url>
      
        <content type="html"><![CDATA[<p>This program can help you make gif animations of various algorithmsrunning on the 2d square grid.</p><blockquote><p><strong>Requirements</strong>: <code>tqdm</code> for showing processbar and <code>pillow</code> for reading images.</p></blockquote><h1 id="examples">Examples</h1><ul><li><p>Wilson’s uniform spanning tree algorithm (my favourite, 2349frames, 333KB, generated in 3 seconds):</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/wilson-bfs.gif"></p></li><li><p>Prim’s algorithm:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/prim.gif"></p></li><li><p>Kruskal’s algorithm:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/kruskal.gif"></p></li><li><p>Langton’s ant:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/langton-ant.gif"></p></li><li><p>Hilbert curve：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/hilbert.gif"></p></li><li><p>Conway’s game of life (gosper glider gun):</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/gosperglidergun.gif"></p></li></ul><h1 id="whats-special-about-this-program">What’s special about thisprogram</h1><p>The code is implemented in pure Python, no third-party modules norsoftwares are required, just built-in modules like <code>struct</code>,<code>random</code>, <code>colorsys</code> and some built-in functions,and without any “color” or “draw” function calls. In later versions Iadded some features like showing process bars (requires<code>tqdm</code>) and enabling the user to embed the animtion into abackground image (requires <code>pillow</code>). The program runs muchfaster than expected, it can generate highly optimized gif output inonly a few seconds. One drawback is that it’s not quite user-friendly:the user must have some basic knowledge of the GIF89a specification toknow how to set parameters correctly in the animation.</p><h1 id="how-did-this-program-come-out">How did this program comeout</h1><p>This program is motivated by Mike Bostock’s wonderful <a href="https://bl.ocks.org/mbostock/11357811">Javascript animation</a>. Afew years ago when I saw Mike’s page I immediately had the idea ofwriting a Python version to produce gif animations of Wilson’salgorithm. A first thought on this was to save the animation into framesand then pack them back into a whole gif. But the animation usuallycontains thousands of frames so this is definitely a horrible task andis far from being efficient. Luckily five years later I learnt theGIF89a specification by chance and suddenly realized the new approach ofencoding the animation into a byte stream. So basically I implemented asmall gif encoder first, then run the algorithm on a 2d grid (use a 2darray to represent it) and encode it into frames along the way.</p><h1 id="what-is-wilsons-algorithm">What is Wilson’s algorithm</h1><p>Consider the following problem:</p><blockquote><p><strong>Problem</strong>: Let <span class="math inline">\(G\)</span>be a finite, connected and undirected graph. How can one choose a randomspanning tree among all spanning trees of <span class="math inline">\(G\)</span> from uniform probability? (we shallcall such a tree an uniform spanning tree, or simply an<strong>UST</strong>.)</p></blockquote><p>The following image shows an UST of a 48x36 grid, the circled dot isthe root vertex:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/ust.png"></p><p>You might say “that’s easy, just write a program that lists allspanning trees and then use a random integer to choose one”. But let’sconsider the complete graph <span class="math inline">\(K_n\)</span> forexample: <span class="math inline">\(K_n\)</span> has <span class="math inline">\(n^{n/2}\)</span> many different spanning trees by<a href="https://en.wikipedia.org/wiki/Cayley%27s_formula">Cayley’sformula</a>, for <span class="math inline">\(n=100\)</span> this numberis <span class="math inline">\(100^{98}\)</span>, far more larger thanthe number of particles in the universe! (which is estimated about <span class="math inline">\(10^{90}\)</span>)</p><p>Currently the most efficient algorithm known is the one proposed inWilson’s paper</p><blockquote><p>“generating random spanning trees more quickly than the covertime”.</p></blockquote><p>It’s a random algorithm, that is, some times you may be very lucky toget an UST soon, or you may wait forever. But one can prove that thisalgorithm will terminate in finite steps with probability one (note thisdoes not exclude the possibility of running forever, think about this),and it performs really well in most cases.</p><p>The key to understand Wilson’s algorithm is the so called <a href="https://en.wikipedia.org/wiki/Loop-erased_random_walk">loop erasedrandom walk</a>, that is, once the random walk visits a vertex thatalready existed in its path, it immediately erases the loop betweenthese two visits and continues the walk from this vertex. Just watch theJavascript animation if you don’t understand this, it’s obvious to seewhat “loop erased random walk” means from it. (click on the canvas torestart the animation)</p><script type="text/javascript" src="/images/code/wilson.js"></script><div data-align="center"><canvas id="wilson" width="600" height="600"></canvas></div><p>The algorithm runs as follows:</p><blockquote><p><strong>Wilson’s algorithm</strong>:</p><ol type="1"><li>Choose any vertex <span class="math inline">\(v\)</span> as the rootand maintain a tree <span class="math inline">\(T\)</span>, initially<span class="math inline">\(T=\{v\}\)</span>.</li><li>For any vertex <span class="math inline">\(z\)</span> that is not in<span class="math inline">\(T\)</span>, start a loop erased random walkfrom <span class="math inline">\(z\)</span> until the walk hits <span class="math inline">\(T\)</span>, then add the resulting path of thewalk to <span class="math inline">\(T\)</span>.</li><li>Repeat step 2 until all vertices of the graph are in <span class="math inline">\(T\)</span>.</li></ol></blockquote><p>The proof of the correctness of this algorithm is a bit tricky andwill not be discussed here, you may refer to Wilson’s original paper orthe book by Russell Lyons and Yuval Peres:</p><blockquote><p>“Probability on Trees and Networks”.</p></blockquote><h1 id="implementation">Implementation</h1><p>As mentioned before, the animation of Wilson’s algorithm (and alsoLangton’s ant animation) usually contains thousands of frames in it, soit’s quite surprising that this program takes only a few seconds toproduce a highly optimized image. The key points are:</p><ul><li><p>Only encode a minimum region at a time. We can maintain arectangular region to store which cells are changed between successiveframes, this enables us to encode only a small portion of the windowinstead of the whole into a frame.</p></li><li><p>Use variable mimimum code length for the LZW compression. Whenencoding a frame into bytearrays LZW compression allows the minimum codelength <span class="math inline">\(k\)</span> can be as small as thecolor depth of this frame (and must satisfy <span class="math inline">\(2\leq k\leq12\)</span>), this is another benifitsince most frames only contain very few colors.</p></li><li><p>Write the frames to a temporary <code>BytesIO</code> file inmemory and flush it to disk in the end.</p></li></ul><p>The code is divided into three layers: at the top layer is the<code>Maze</code> class on which we run various algoirthms. This layerknows nothing about the gif image. At the bottom layer is the<code>GIFSurface</code> class which holds the raw information like imagesize, global color table, number of loops, background color index, etc.It knows nothing about the <code>Maze</code>. At the middle layer is the<code>Animation</code> class which controls how the <code>Maze</code> isencoded and writes to the <code>GIFSurface</code>.</p><h1 id="a-short-introduction-to-the-gif89a-specification">A shortintroduction to the GIF89a specification</h1><p>In this section I’ll give a not-so-detailed introduction to theGIF89a specification. It’s not meant to be comprehensive norself-contained, you should always refer to <a href="http://giflib.sourceforge.net/whatsinagif/index.html">What’s in aGIF</a> when you have difficulties understanding my words here.</p><p>Roughly a GIF image consists of:</p><blockquote><p><strong>Structure of a GIF File</strong></p><ol type="1"><li>Always begins with 6 bytes <code>GIF89a</code>.</li><li>Then follows the <strong>logical screen descriptor</strong> whichspecifies the width and height of the image and the size of the<strong>global color table</strong>.</li><li>Then follows the global color table.</li><li>Then follows the <strong>loop control block</strong> which specifiesthe number of loops of the image.</li><li>Then comes the actual data of the frames. The data of each frame canbe further divided into 3 parts:<ol type="1"><li>the <strong>graphics control block</strong> which specifies thedelay and transparent color of this frame.</li><li>the <strong>image descriptor</strong> which specifies the relativeposition of this frame in the window and the size of the local colortable.</li><li>the local color table of this frame (if there is a local color tablefor this frame).</li><li>the LZW compressed pixel data of this frame.</li></ol></li><li>Finally the image file ends with a byte <code>0x3B</code>.</li></ol></blockquote><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>The above description does not apply to all GIF images, there canbe some variations. For example:</p><ol type="1"><li><p>The image may not contain a global color table (so you have tospecify a local color table for each frame).</p></li><li><p>For a static image the loop control block is not required; for astacit frame the graphcs control block is not required.</p></li><li><p>The file may end without the byte <code>0x3B</code>, mostdecoders can still decode the image correctly.</p></li></ol></div><p>Now we explain each part in more details.</p><h2 id="the-header-gif89a">The header GIF89a</h2><p>In python you can write it as</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">'6s'</span>, <span class="hljs-string">b'GIF89a'</span>)<br></code></pre></td></tr></tbody></table></figure><p>Why <code>b'GIF89a'</code> not simply <code>'GIF89a'</code>? This isfor compatibility with Python2 and 3 since the default encoding inPython3 is unicode whereas in python2 it’s ascii.</p><h2 id="the-logical-screen-descriptor">The logical screendescriptor</h2><p>Example:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">'&lt;2H3B'</span>, width, height, <span class="hljs-number">0b10010001</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><p>Here you shoud note the format string <code>&lt;</code> (littleendian).</p><p>The byte <code>0b10010001</code> is called a packed field. Let’s readit from left to right:</p><ol type="1"><li>The first bit 1 means we have a global color table (0 forabsent).</li><li>The next 3 bits specify the “color depth”. You don’t need care aboutwhat they mean since modern decoders like firefox and chrome do not usethem.</li><li>The fifth bit is the “sort flag” and is not used today, always setto 0.</li><li>The ending 3 bits represent an integer <span class="math inline">\(x\)</span> in range 0-7, <span class="math inline">\(x\)</span> specifies the size of the global colortable (<span class="math inline">\(=2^{x+1})\)</span>.</li></ol><p>The last two bytes are of little importance and we don’t discuss themhere.</p><h2 id="global-color-table">Global color table</h2><p><strong>Example</strong>: if we want to use 4 colors red, green,blue, yellow, then the global color table can be written as</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">bytearray</span>([<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>])<br></code></pre></td></tr></tbody></table></figure><p>It’s important that the number of colors in this array must be apower of 2 and match the size of the global color table specified in thepacked byte in the logical screen descriptor, otherwise the decoder willnot be able to parse the image correctly.</p><h2 id="graphics-control-block">Graphics control block</h2><p><strong>Example</strong>:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">"&lt;4BH2B"</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0xF9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0b00000101</span>, delay, trans_index, <span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><p>The 3 beginning bytes <code>0x21, 0xF9, 4</code> are fixed and areused to inform the decoder “Hey, I’m a graphics control block, see thenext 4 bytes!”</p><p>The next byte <code>0b00000101</code> is also a packed field, let’sread it from left to right:</p><ol type="1"><li>The first 3 bits are useless and are always 0.</li><li>The next 3 bits are called “desposal method”, they represent aninteger <span class="math inline">\(x\)</span> in range 0-7 and <span class="math inline">\(x\)</span> specifies how we should dispose thisframe after it’s displayed.<ol type="1"><li><p><span class="math inline">\(x=0\)</span> means it’s undefined,decoders will use default 1 instead in this case.</p></li><li><p><span class="math inline">\(x=1\)</span> is the default, it meansleave this frame here. So if the next frame is not overlapped with thisframe then both these two frames will be displayed. Otherwise theoverlapped area in this frame will be covered by the next one. See theexample below:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/disposal1.gif"></p></li><li><p><span class="math inline">\(x=2\)</span> means remove this frameand restore the image to background image/color, see the followingexample:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/disposal2.gif"></p><p>You can see each frame is remove immediately after it’s displayed,and its region is filled with transparent background (so you are reallyseeing the browser’s background color through the image).</p></li><li><p><span class="math inline">\(x=3\)</span> also means remove thisframe, but restore the image to the previous frame.<img style="margin:0px auto;display:block" src="/images/gifmaze/disposal3.gif"></p></li><li><p>4-7 are unused.</p></li></ol></li></ol><p>The next 2 bytes <code>delay</code> specifies the delay of the framein centiseconds, so <code>delay=3</code> means “keep staying here for0.03 second”.</p><p>The last byte <code>trans_index</code> specifies the transparentcolor in this frame, the pixels in this frame using this color aretransparent: you can see the previous frame through them (of course onlywhen the previous frame is still there (reserved), otherwise you areseeing the previous previous frame, …, etc).</p><h2 id="image-descriptor-block">Image descriptor block</h2><p>Example:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">'&lt;B4HB'</span>, <span class="hljs-number">0x2C</span>, left, top, width, height, <span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><p>Quite straight-forward to understand. Note the last byte is 0 sincewe do not need local color tables here.</p><h2 id="the-lzw-compression-algorithm">The LZW compressionalgorithm</h2><p>Finally we are left with the most difficult part: the LZW algorithm.It’s too long to include an introduction to the algorithm here, soplease refer to <a href="http://www.matthewflickinger.com/lab/whatsinagif/lzw_image_data.asp">thesecond article in What’s in a gif</a> for a complete treatment. But it’squite simple to implement it in Python, see the file <a href="https://github.com/neozhaoliang/pywonderland/blob/master/src/gifmaze/gifmaze/encoder.py">encoder.py</a>for an example.</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Humphreys《反射群与 Coxeter 群》笔记</title>
      <link href="humphreys/index.html"/>
      <url>humphreys/index.html</url>
      
        <content type="html"><![CDATA[<p>本文是我学习 <span class="citation" data-cites="Humphreys90">Humphreys (<a href="#ref-Humphreys90" role="doc-biblioref">1990</a>)</span> 时的一些笔记。</p><span id="more"></span><h1 id="generation-by-simple-reflections">1.5 Generation by simplereflections</h1><p>这一节证明了整个反射群 <span class="math inline">\(W\)</span>可以由单反射 <span class="math inline">\(\{s_\alpha\mid\alpha\in\Delta\}\)</span>生成。</p><div id="thm-1.5" class="statement sta____1_5 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">定理1.5</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 可以由 <span class="math inline">\(\{s_\alpha\mid\alpha\in\Delta\}\)</span>生成。</p></div><p><strong>证明概要</strong>：设 <span class="math inline">\(W'\)</span> 是 <span class="math inline">\(\{s_\alpha\mid\alpha\in\Delta\}\)</span>生成的群。目标是证明 <span class="math inline">\(W'=W\)</span>。我们来一步步推理：</p><ol type="1"><li>由于 <span class="math inline">\(W\)</span>是由关于整个根系的镜面反射 <span class="math inline">\(\{s_\beta\mid\beta\in\Phi\}\)</span> 生成的，所以只要证明任何 <span class="math inline">\(s_\beta\in W'\)</span> 即可。</li><li>要证明 1，只要证明任何 <span class="math inline">\(\beta\in\Phi\)</span> 可以写成 <span class="math inline">\(\beta=w'\alpha\)</span> 的形式，其中 <span class="math inline">\(w'\in W',\,\alpha\in\Pi\)</span>。这样<span class="math inline">\(s_\beta=w's_\alpha w'^{-1}\inW'\)</span>。</li><li>要证明 2，只需要分析 <span class="math inline">\(\beta\)</span>是正根且不是单根的情形，因为 <span class="math inline">\(-\beta =w's_\alpha\alpha\)</span>。</li><li>如果 <span class="math inline">\(\beta&gt;0\)</span> 但不是单根，设<span class="math inline">\(\beta=\sum c_s\alpha_s\)</span>，那么 <span class="math inline">\(0&lt;(\beta,\beta)=\sum c_s(\beta,\alpha_s)\)</span>，这说明一定存在单根 <span class="math inline">\(\alpha_s\)</span> 满足 <span class="math inline">\((\beta,\alpha_s)&gt;0\)</span>。考察 <span class="math inline">\(\gamma=s\beta\)</span>。</li><li><span class="math inline">\(\gamma\)</span> 仍然是正根，并且 <span class="math inline">\(\mathrm{ht}(\gamma) &lt;\mathrm{ht}(\beta)\)</span>。如果 <span class="math inline">\(\gamma\)</span> 不是单根，那就一直重复此步骤直到<span class="math inline">\(\gamma\)</span>变成单根为止。这个操作一定会在有限次后终止，否则我们会得到一个无穷的、高度严格降低、从而互不相同的正根序列，这与根系是有限集矛盾。</li><li>设 <span class="math inline">\(\gamma=s_1\cdotss_r\beta\in\Delta\)</span> 是最终得到的单根，则 <span class="math inline">\(\beta\in W'\Delta\)</span>，结论成立。<span class="math inline">\(\blacksquare\)</span></li></ol><h1 id="the-length-function">1.6 The length function</h1><p>这一节证明了函数 <span class="math inline">\(n(w)\)</span>满足的递推关系。</p><p>设 <span class="math inline">\(\mathrm{Neg}(w)\)</span> 是那些被<span class="math inline">\(w\)</span> 变成负根的正根的集合： <span class="math display">\[\mathrm{Neg}(w)=\{\lambda&gt;0,\lambda\in\Phi\midw\lambda&lt;0\}.\]</span> 并记 <span class="math inline">\(n(w)=|\mathrm{Neg}(w)|\)</span>。</p><div id="lem-1.6" class="statement sta____1_6 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">引理1.6</span>.</span><span class="statement-spah"> </span> 函数 <span class="math inline">\(n(w)\)</span> 满足如下的递推关系： <span class="math display">\[n(ws_\alpha)=\begin{cases}n(w)+1 &amp; w\alpha&gt;0,\\n(w)-1 &amp; w\alpha&lt;0.\end{cases}\]</span></p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在后面 5.4 节中，针对一般的 Coxeter 群证明了长度函数 <span class="math inline">\(l(w)\)</span> 也满足同样的递推关系，从而 <span class="math inline">\(l(w)=n(w)\)</span>。但是那里的证明要复杂一些。</p></div><p><strong>证明</strong>：首先注意到任何单根 <span class="math inline">\(\alpha\in\Delta\)</span> 必然恰好属于 <span class="math inline">\(\mathrm{Neg}(w)\)</span> 或者 <span class="math inline">\(\mathrm{Neg}(ws_\alpha)\)</span> 之一，这取决于<span class="math inline">\(w\alpha\)</span> 是正根还是负根：</p><ul><li><span class="math inline">\(w\alpha&lt;0\Rightarrow\alpha\in\mathrm{Neg}(w)\)</span>。</li><li><span class="math inline">\(w\alpha&gt;0\Rightarrowws_\alpha\alpha&lt;0\Rightarrow \alpha\in\mathrm{Neg}(ws_\alpha)\)</span>。</li></ul><p>另一方面对任何正根 <span class="math inline">\(\gamma\ne\alpha\)</span>，<span class="math inline">\(s_\alpha\gamma\)</span> 仍然是正根。从恒等式 <span class="math display">\[(ws_\alpha)\gamma &lt; 0\Longleftrightarroww(s_\alpha\gamma)&lt;0\]</span> 可见 <span class="math inline">\(\gamma\in\mathrm{Neg}(ws_\alpha)\)</span> 当且仅当<span class="math inline">\(\gamma\in\mathrm{Neg}(w)\)</span>，所 <span class="math inline">\(\gamma\leftrightarrow s_\alpha\gamma\)</span>给出了 <span class="math inline">\(\mathrm{Neg}(ws_\alpha)\)</span> 和<span class="math inline">\(\mathrm{Neg}(w)\)</span> 中除 <span class="math inline">\(\alpha\)</span> 之外的正根的一一对应，所以</p><p><span class="math display">\[n(ws_\alpha)=\begin{cases}n(w)+1 &amp; \alpha\in\mathrm{Neg}(ws_\alpha),\\n(w)-1 &amp; \alpha\in \mathrm{Neg}(w).\end{cases}\]</span></p><p><span class="math inline">\(\blacksquare\)</span></p><h1 id="deletion-and-exchange-conditions">1.7 Deletion and ExchangeConditions</h1><p>这一节证明了有限反射群必然满足 deletion 和 exchange条件。开头的定理乍看起来非常不直观，包含了一大堆下标。我来解释下背后的几何直观。</p><p>设 <span class="math inline">\(w=s_1\cdots s_r\)</span> 是 <span class="math inline">\(W\)</span> 的任一元素。从基本区域 <span class="math inline">\(C\)</span> 出发，我们有一个gallery，即一列两两相邻的房间</p><p><span class="math display">\[C,\, s_1C,\, s_1s_2C,\, \ldots,\,s_1\cdots s_rC.\]</span></p><p>可以这样理解：记 <span class="math inline">\(w_i=s_1\cdotss_i\)</span>，则 <span class="math inline">\(w_{i-1}\)</span>将相邻的两个房间 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(s_iC\)</span> 映射为另外两个相邻的房间 <span class="math inline">\(w_{i-1}C\)</span> 和 <span class="math inline">\(w_iC\)</span>。</p><p>不仅如此，由于 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(s_iC\)</span> 之间的墙壁是超平面 <span class="math inline">\(H_i = H_{s_i}\)</span>，它在 <span class="math inline">\(w_{i-1}\)</span> 作用下被映射为超平面 <span class="math inline">\(w_{i-1}H_i\)</span>，所以 <span class="math inline">\(w_{i-1}C\)</span> 和 <span class="math inline">\(w_iC\)</span> 之间的墙壁是 <span class="math inline">\(w_{i-1} H_i\)</span>。即</p><p><span class="math display">\[C\stackrel{H_1}{\bigl\lvert} s_1C\stackrel{s_1H_2}{\bigl\lvert}s_1s_2C\stackrel{\quad}{\bigl\lvert}\cdots\stackrel{w_{r-1}H_r}{\bigl\lvert}w_{r}C.\]</span></p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>表达式 <span class="math inline">\(w=s_1s_2\cdots s_r\)</span>是既约的，当且仅当上述镜面集合 <span class="math display">\[\{H_1,s_1H_2,\ldots,s_1\cdotss_{r-1}H_r\}\]</span> 互不相同。</p></div><p>这个引理的含义是，任何既约单词对应的 gallery不能两次跨越同一个超平面。</p><p>这个引理的证明见 4.5 小节 simpletransitivity。那里仿射的情形和这里的证明是一样的。</p><p>我们来问问自己，如果一个镜子在上面的集合中出现两次会发生什么？设<span class="math inline">\(1\leq i&lt;j\leq r\)</span> 使得 <span class="math display">\[s_1\cdots s_{i-1}H_i = s_1\cdotss_{j-1}H_j.\]</span> 两边消去 <span class="math inline">\(s_1\cdotss_{i-1}\)</span> 得到 <span class="math display">\[H_i = s_i\cdotss_{j-1}H_j.\]</span> 即 <span class="math display">\[s_i = (s_i\cdotss_{j-1})s_j(s_{j-1}\cdots s_i)=(s_i\cdots s_{j})(s_{j-1}\cdotss_i).\]</span> 把右边的 <span class="math inline">\(s_{j-1}\cdotss_i\)</span> 挪到左边来得到 <span class="math display">\[s_{i+1}\cdotss_{j-1} = s_i\cdots s_j.\]</span> 这意味着 <span class="math inline">\(s_i\cdots s_j\)</span> 这一段可以用更短的 <span class="math inline">\(s_{i+1}\cdots s_{j-1}\)</span>来代替，这就是书中定理 1.7 中的 (c)。</p><h1 id="generators-and-relations">1.9 Generators and relations</h1><p>这是比较难读的一节。这一节证明了满足 deletion 条件的有限反射群一定是Coxeter 群。</p><div id="thm-1.9" class="unnumbered statement sta____1_9 plain"><p><span class="statement-heading"><span class="statement-label">定理1.9</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\Delta\)</span> 是某 Euclidean 的一组基，<span class="math inline">\(S=\{s_\alpha\mid \alpha\in\Delta\}\)</span>是一组单反射，<span class="math inline">\(W\)</span> 是 <span class="math inline">\(S\)</span> 生成的群，并且 <span class="math inline">\(W\)</span> 满足 deletion 条件。则 <span class="math inline">\(W\)</span> 具有表现 <span class="math display">\[(s_\alpha s_\beta)^{m_{\alpha,\beta}}=1.\]</span>其中 <span class="math inline">\(m_{\alpha,\beta}\geq1\in\mathbb{Z}\)</span>。</p></div><p>注意 <span class="math inline">\(m_{\alpha,\alpha}=1\)</span>。</p><p><strong>证明</strong>：我们要说明生成元之间的任何关系 <span class="math display">\[s_1s_2\cdots s_r=1\]</span> 都可以通过形如 <span class="math inline">\((s_\alpha s_\beta)^{m_{\alpha,\beta}}=1\)</span>这样的关系推导出来。</p><p>若不然，设 <span class="math display">\[s_1s_2\cdots s_r=1,\quadr=2q\]</span> 是一个长度最短的反例。这里 <span class="math inline">\(r\)</span> 必须是偶数，因为每个 <span class="math inline">\(\det s_i=-1\)</span>。</p><p>我们将证明有 <span class="math inline">\(s_1=s_3=\cdots\)</span> 以及<span class="math inline">\(s_2=s_4=\cdots\)</span>成立，从而上述关系可以写成 <span class="math inline">\((s_1s_2)^q=1\)</span>，得出矛盾。</p><ul><li><p>我们只要证明 <span class="math inline">\(s_1=s_3\)</span>即可。然后将结论用在 <span class="math inline">\(s_2s_3\cdotss_rs_1=1\)</span> 上得到 <span class="math inline">\(s_2=s_4\)</span>；再进一步用在 <span class="math inline">\(s_3s_4\cdots s_rs_2s_1=1\)</span> 上得到 <span class="math inline">\(s_3=s_5\)</span>，等等。</p></li><li><p>为此我们只要证明如下两个等式：</p><p>(I). <span class="math inline">\(s_1s_2\cdots s_q=s_2s_3\cdotss_{q+1}\)</span>.</p><p>(II). <span class="math inline">\(s_3s_2\cdots s_q=s_2s_3\cdotss_{q+1}\)</span>.</p><p>这两个式子几乎是一样的，第一个最左边是 <span class="math inline">\(s_1\)</span>，第二个最左边是 <span class="math inline">\(s_3\)</span>，所以如果它们都成立的话就有 <span class="math inline">\(s_1=s_3\)</span>。</p></li><li><p>为了证明 I，我们把 <span class="math inline">\(s_1\cdotss_r=1\)</span> 改写为 <span class="math display">\[s_1\cdots s_{q+1} =s_r\cdots s_{q+2}.\]</span> 左边是 <span class="math inline">\(q+1\)</span> 项的乘积，右边是 <span class="math inline">\(q-1\)</span> 项的乘积，所以 <span class="math inline">\(l(s_1\cdots s_{q+1})\leq q-1\)</span>。根据deletion 条件，存在 <span class="math inline">\(1\leq i&lt;j\leqq+1\)</span> 使得有 <span class="math display">\[s_i\cdots s_j =s_{i+1}\cdots s_{j-1}. \tag{$\ast$}\]</span> 我们来论证 <span class="math inline">\(i=1,j=q+1\)</span>，也就是 I 成立。若不然，<span class="math inline">\((\ast)\)</span> 式至多包含 <span class="math inline">\(2q-2=r-2\)</span> 项，从而由假设可以由 Coxeter关系 <span class="math inline">\(\{(s_\alphas_\beta)^{m_{\alpha,\beta}}=1\mid \alpha,\beta\in\Delta\}\)</span>推导出来。然而 <span class="math inline">\((\ast)\)</span> 式等价于<span class="math display">\[s_1\cdots s_r =s_1\cdots\hat{s_i}\cdots\hat{s_j}\cdots s_r.\]</span> 此外我们已知 <span class="math inline">\(s_1\cdots s_r=1\)</span>，所以 <span class="math display">\[s_1\cdots\hat{s_i}\cdots\hat{s_j}\cdotss_r=1.\]</span> 根据 <span class="math inline">\(r\)</span>的选取，<span class="math inline">\(s_1\cdots\hat{s_i}\cdots\hat{s_j}\cdotss_r=1\)</span> 可以由 Coxeter 关系推导得到，从而 <span class="math inline">\(s_1\cdots s_r=1\)</span>也可以，这导致了矛盾，于是 I 得证。</p></li><li><p>为了证明 II，将 <span class="math inline">\(s_1\cdots s_r=1\)</span> 改写为 <span class="math inline">\(s_2\cdotss_rs_1=1\)</span>，仿照 I 的证明，我们可以得到 <span class="math display">\[s_2\cdots s_{q+1} = s_3(s_4\cdotss_{q+2}).\]</span> 把 <span class="math inline">\(s_3\)</span>挪到左边的前面，把 <span class="math inline">\(s_4\cdotss_{q+2}\)</span> 挪到左边的后面，得到 <span class="math display">\[s_3s_2\cdots s_{q+1}s_{q+2}\cdots s_4 =1.\]</span> 仍然和 I 的证明同理，我们可以得到 <span class="math display">\[s_3s_2\cdots s_q = s_2\cdots s_{q+1}.\]</span>这就是 II 中的等式。</p></li></ul><p><span class="math inline">\(\blacksquare\)</span></p><h1 id="subgraphs">2.6 Subgraphs</h1><p>在本节中，<span class="math inline">\(\Gamma\)</span> 是一个不可约Coxeter 图，内积 <span class="math inline">\((\alpha_s,\alpha_t)=-\cos\frac{\pi}{m_{s,t}}\)</span>是半正定的，但不是正定的。</p><p>记 <span class="math inline">\(N=\{v\in V\mid (v,v)=0\}\)</span> 以及<span class="math display">\[\mathrm{rad}(V)=\{v\in V\mid (v, u)=0\text{ for all } u \in V\}.\]</span> 显然 <span class="math inline">\(\mathrm{rad}(V)\)</span> 总是 <span class="math inline">\(V\)</span> 的子空间并且 <span class="math inline">\(\mathrm{rad}(V)\subset N\)</span>，但是一般来说<span class="math inline">\(N\)</span> 并不是 <span class="math inline">\(V\)</span> 的子空间。</p><p>但是在内积半正定时，我们有如下的结论：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>若内积半正定，则 <span class="math inline">\(N=\mathrm{rad}(V)\)</span>。</p></div><p>证明：只要证明 <span class="math inline">\(N\subset\mathrm{rad}(V)\)</span> 即可，即若 <span class="math inline">\(u\in V\)</span> 满足 <span class="math inline">\((u,u)=0\)</span>，则对任何 <span class="math inline">\(v\in V\)</span> 都有 <span class="math inline">\((u,v)=0\)</span>。若不然，设 <span class="math inline">\(v\)</span> 满足 <span class="math inline">\((u,v)\ne0\)</span>，我们给 <span class="math inline">\(v\)</span> 乘以适当实数使得 <span class="math inline">\((u,v)=1\)</span>。设 <span class="math inline">\(k\)</span> 是实数，考虑向量 <span class="math inline">\(z=ku +v\)</span>： <span class="math display">\[(z,z)=(ku+v,ku+v) = (v,v) + 2k.\]</span>所以只要选择 <span class="math inline">\(k\)</span> 满足 <span class="math inline">\(2k &lt; -(v,v)\)</span> 就有 <span class="math inline">\((z,z)&lt;0\)</span>，这与内积的半正定性矛盾。<span class="math inline">\(\blacksquare\)</span></p><p>这一节的主要结论是：</p><div id="-------2-6" class="unnumbered statement sta____2_6 plain"><p><span class="statement-heading"><span class="statement-label">命题2.6</span>.</span></p><ol type="1"><li><span class="math inline">\(\mathrm{rad}(V)\)</span>是一维的，由一个向量 <span class="math inline">\(\delta=\sum_{s\inS}c_s\alpha_s\)</span> 生成，并且每个系数 <span class="math inline">\(c_s\)</span> 都大于 0。</li><li><span class="math inline">\(\Gamma\)</span>删去任意多个顶点后得到的子图是正定的。</li></ol></div><p>这里给出一个不同于 Humphreys 书上的证明。</p><p>1 的证明：</p><p>设 <span class="math inline">\(u=\sum_{s\inS}c_s\alpha_s\in\mathrm{rad}(V)\)</span> 是一个非零向量，记 <span class="math display">\[I_+=\{s\in S\mid c_s&gt;0\},\quad I_-=\{s\inS\mid c_s&lt;0\},\quad I_0=\{s\in S\mid c_s=0\}.\]</span> <span class="math display">\[u_+=\sum_{s\in I_+}c_s\alpha_s,\quadu_-=\sum_{s\in I_-}c_s\alpha_s.\]</span> 则 <span class="math inline">\(u=u_++u_-\)</span>，并且 <span class="math display">\[(u_+,u_-)=\sum_{c\in I_+}\sum_{t\inI_-}\underbrace{c_sc_t}_{&lt;0}\,\underbrace{\alpha_s\alpha_t}_{\leq0}\geq0.\]</span></p><p>由于 <span class="math inline">\(u\in\mathrm{rad}(V)\)</span> 所以<span class="math inline">\((u,u)=0\)</span>，即 <span class="math display">\[(u,u)=(u_+,u_+)+(u_-,u_-)+2(u_+,u_-)=0.\]</span>根据半正定性和上面的分析，上式的三项都是非负的，所以只能是 <span class="math display">\[(u_+,u_+)=(u_-,u_-)=(u_+,u_-)=0.\]</span></p><p>此外 <span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 中至少有一个非空，不妨设 <span class="math inline">\(I_+\ne\emptyset\)</span>，我们来证明 <span class="math inline">\(I_-\)</span> 和 <span class="math inline">\(I_0\)</span> 必须都是空集。</p><p>若不然，<span class="math inline">\(I_-\cup I_0\)</span> 非空，任取<span class="math inline">\(t\in I_-\cup I_0\)</span>，设 <span class="math inline">\(\delta\)</span> 是正数，考虑向量 <span class="math inline">\(z=u_+ +\delta\alpha_t\)</span>。我们有</p><p><span class="math display">\[(z,z)=\delta^2+2\delta(u_+,\alpha_t)=\delta^2+2\delta\sum_{s\inI_+}\underbrace{c_s}_{&gt;0}\underbrace{(\alpha_s,\alpha_t)}_{\leq0}.\]</span>注意到每一项 <span class="math inline">\(c_s(\alpha_s,\alpha_t)\leq0\)</span>，所以 <span class="math inline">\(\sum_{s\inI_+}c_s(\alpha_s,\alpha_t)\leq0\)</span>，并且如果存在 <span class="math inline">\(s\in I_+\)</span> 使得 <span class="math inline">\(s\)</span> 与 <span class="math inline">\(t\)</span> 之间有边相连的话则 <span class="math inline">\(\sum_{s\in I_+}c_s(\alpha_s,\alpha_t)\)</span>严格小于 0。这时取 <span class="math inline">\(\delta\)</span>足够小可以使得 <span class="math inline">\((z,z)&lt;0\)</span>，这与内积<span class="math inline">\((,)\)</span>是半正定的矛盾。所以必须是对每个 <span class="math inline">\(s\inI_+\)</span> 有 <span class="math inline">\((\alpha_s,\alpha_t)=0\)</span>。由 <span class="math inline">\(t\)</span> 的任意性可得 <span class="math inline">\(I_-\cup I_0\)</span> 与 <span class="math inline">\(I_+\)</span> 互不连通，但这又与 <span class="math inline">\(\Gamma\)</span> 不可约矛盾。</p><p>总之我们证明了 <span class="math inline">\(\mathrm{rad}(V)\)</span>中非零向量的系数必须同时为正或者同时为负。</p><p>如果 <span class="math inline">\(\mathrm{rad}(V)\)</span>包含两个线性无关的向量 <span class="math inline">\(u,v\)</span>，根据上面的证明，我们可以不妨设 <span class="math inline">\(u,v\)</span>的各项系数都是正数。适当缩放以后我们可以让 <span class="math inline">\(u,v\)</span> 的 <span class="math inline">\(\alpha_1\)</span> 项系数都是 1。于是 <span class="math inline">\(u-v\)</span> 也在 <span class="math inline">\(\mathrm{rad}(V)\)</span> 中，并且其 <span class="math inline">\(\alpha_1\)</span> 项系数是 0，这就导致了矛盾。</p><p>2 的证明：</p><p>我们只要证明若 <span class="math inline">\(I\subsetneqq\Gamma\)</span> 是真子集，则对任何非零向量 <span class="math inline">\(u=\sum_{s\in I}c_s\alpha_s\)</span> 都有 <span class="math inline">\((u,u)&gt;0\)</span>。若不然，<span class="math inline">\(u=\sum_{s\in I}c_s\alpha_s+\sum_{t\notinI}0\cdot\alpha_t\)</span> 并且 <span class="math inline">\((u,u)=0\)</span>，这与 <span class="math inline">\(u\)</span> 的系数必须全部非零矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 id="uniqueness-of-the-degrees">3.7 Uniqueness of the degrees</h1><p>这一节介绍了不变多项式环 <span class="math inline">\(S^G\)</span>的任何一组齐次生成元的次数 <span class="math inline">\(d_1,d_2,\ldots,d_n\)</span>是唯一确定的。证明不难，但是采用的方法很典型，以后会反复用到。</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(f_1,\ldots,f_n\inK[x_1,\ldots,x_n]\)</span> 是一组齐次、代数无关的多项式；其次数分别为<span class="math inline">\(d_1,\ldots,d_n\)</span>；<span class="math inline">\(g_1,\ldots,g_n\)</span>是另一组齐次、代数无关的多项式，次数分别为 <span class="math inline">\(e_1,\ldots,e_n\)</span>，并且每个 <span class="math inline">\(g_i\)</span> 可以写成 <span class="math inline">\(f_1,\ldots,f_n\)</span> 的多项式，则适当重排以后有<span class="math inline">\(e_i\geq d_i\)</span>。</p></div><p>证明：利用链式法则对导可得 <span class="math display">\[\frac{\partial g_i}{\partial x_k} = \sum_{j=1}^n\frac{\partial g_i}{\partial f_j}\frac{\partial f_j}{\partialx_k}.\]</span></p><p>由于 <span class="math inline">\(g_1,\ldots,g_n\)</span>代数无关，根据 Jacobian 判定左边的矩阵 <span class="math inline">\(\left(\frac{\partial g_i}{\partialx_k}\right)\)</span> 可逆，从而右边的矩阵 <span class="math inline">\(\left(\frac{\partial g_i}{\partialf_j}\right)\)</span> 也可逆，其行列式非零，于是存在置换 <span class="math inline">\(\pi\)</span> 使得 <span class="math display">\[\prod_{i=1}^n\frac{\partial g_i}{\partialf_{\pi(i)}}\ne0.\]</span> 适当重排 <span class="math inline">\(g_1,\ldots,g_n\)</span> 以后可以不妨设 <span class="math inline">\(\pi\)</span> 是恒等置换，即 <span class="math display">\[\prod_{i=1}^n\frac{\partial g_i}{\partialf_{i}}\ne0.\]</span> 这说明每个 <span class="math inline">\(\frac{\partial g_i}{\partialf_i}\ne0\)</span>，即当把 <span class="math inline">\(g_i\)</span> 写成<span class="math inline">\(f_1,\ldots, f_n\)</span> 的多项式时，<span class="math inline">\(f_i\)</span> 一定出现在其中。于是至少存在一个形如<span class="math display">\[f_1^{k_1}\cdots f_n^{k_n},\quad k_i\geq1\]</span> 的单项式，它出现在 <span class="math inline">\(g_i\)</span>的表达式中，并且不会被抵消掉。从而 <span class="math inline">\(e_i=\sumk_id_i\geq d_i\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="unique-degrees" class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span><span class="math inline">\(S^G\)</span>的任何一组齐次、代数无关生成元的次数是唯一却定的。</p></div><h1 id="coxeter-elements">3.16 Coxeter elements</h1><p>我们来证明任何两个 Coxeter 元都是共轭的。我们只要取一个特殊的 Coxeter元，并证明其它 Coxeter 元都和这个特殊元共轭即可。</p><p>首先，取 Coxeter 图 <span class="math inline">\(\Gamma\)</span>的一个叶节点，将其记作 <span class="math inline">\(s_n\)</span>。从<span class="math inline">\(\Gamma\)</span> 中移走 <span class="math inline">\(s_n\)</span> 以后，剩下的部分 <span class="math inline">\(\Gamma_1=\Gamma-\{s_n\}\)</span>仍然是一个树，于是我们又可以取其叶节点，记作 <span class="math inline">\(s_{n-1}\)</span>。<span class="math inline">\(\Gamma_1-\{s_{n-1}\}\)</span>仍然是树，又可以取其一个叶节点 <span class="math inline">\(s_{n-2}\)</span>，以此类推。即我们将生成元排列为<span class="math inline">\(s_1,\ldots,s_n\)</span>，使得对每个 <span class="math inline">\(1\leq i\leq n\)</span>，<span class="math inline">\(s_1,\ldots,s_i\)</span> 构成 <span class="math inline">\(\Gamma\)</span> 的一个子树，并且 <span class="math inline">\(s_i\)</span> 是这个树的叶节点。</p><p>首先我们注意到任何 Coxeter 元都可以通过循环移位共轭于某个以 <span class="math inline">\(s_n\)</span> 结尾的 Coxeter 元 <span class="math inline">\(s_{i_1}\cdotss_{i_{n-1}}s_n\)</span>，我们来证明这样的元素都共轭于 <span class="math inline">\(s_1s_2\cdots s_n\)</span>。</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>任何形如 <span class="math inline">\(s_{i_1}\cdotss_{i_{n-2}}{\color{blue}s_{i_{n-1}}}s_n\)</span> 的 Coxeter 元共轭于<span class="math display">\[{\color{blue}s_{i_{n-1}}}s_{i_1}\cdotss_{i_{n-2}}s_n.\]</span></p></div><p><strong>证明</strong>：如果 <span class="math inline">\(s_{i_{n-1}}\)</span> 与 <span class="math inline">\(s_n\)</span> 交换，那么 <span class="math display">\[s_{i_1}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}s_n\to s_{i_1}\cdotss_{i_{n-2}}s_n\textcolor{blue}{s_{i_{n-1}}}\to\textcolor{blue}{s_{i_{n-1}}}s_{i_1}\cdots s_{i_{n-2}}s_n.\]</span>结论成立。否则 <span class="math inline">\(s_n\)</span> 唯一的边是与<span class="math inline">\(s_{i_{n-1}}\)</span> 连接，从而 <span class="math inline">\(s_n\)</span> 与 <span class="math inline">\(\{s_{i_1},\ldots,s_{i_{n-2}}\}\)</span>都交换，所以 <span class="math display">\[\begin{aligned}s_{i_1}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}\textcolor{red}{s_n}&amp;\to\textcolor{red}{s_n}s_{i_1}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}\to s_{i_1}\textcolor{red}{s_n}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}\\&amp;\to s_{i_1}\cdotss_{i_{n-2}}\textcolor{red}{s_n}\textcolor{blue}{s_{i_{n-1}}}\\&amp;\to\textcolor{blue}{s_{i_{n-1}}}s_{i_1}\cdotss_{i_{n-2}}\textcolor{red}{s_n}.\end{aligned}\]</span> 结论同样成立。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(k\geq1\)</span>，任何形如 <span class="math inline">\(s_{i_1}\cdots\textcolor{blue}{s_{i_{n-k}}}s_{n-k+1}\cdots s_n\)</span> 的 Coxeter 元都共轭于 <span class="math display">\[\textcolor{blue}{s_{i_{n-k}}} s_{i_1}\cdotss_{i_{n-k-1}}s_{n-k+1}\cdots s_n.\]</span></p></div><p><strong>证明</strong>：<span class="math inline">\(k=1\)</span>的情形在前一个的引理中已经证明了。对 <span class="math inline">\(k\geq2\)</span> 用归纳法，假设结论对小于 <span class="math inline">\(k\)</span> 的情形成立。</p><p>如果 <span class="math inline">\(s_{i_{n-k}}\)</span> 和 <span class="math inline">\(s_{n-k+1}\)</span> 交换，那么 <span class="math display">\[s_{i_1}\cdots \textcolor{blue}{s_{i_{n-k}}}s_{n-k+1}\cdots s_n\to s_{i_1}\cdotss_{n-k+1}\textcolor{blue}{s_{i_{n-k}}}\cdots s_n.\]</span></p><p>然而对 <span class="math inline">\(k-1\)</span>的情形应用归纳假设，上面右边共轭于 <span class="math display">\[\textcolor{blue}{s_{i_{n-k}}} s_{i_1}\cdotss_{n-k+1}\cdots s_n.\]</span> 于是结论成立。</p><p>如果 <span class="math inline">\(s_{i_{n-k}}\)</span> 和 <span class="math inline">\(s_{n-k+1}\)</span> 不交换，那么 <span class="math inline">\(s_{n-k+1}\)</span> 和所有 <span class="math inline">\(s_{i_1}\sim s_{i_{n-k-1}}\)</span>都交换，于是直接用归纳假设有 <span class="math display">\[s_{i_1}\cdots\textcolor{blue}{s_{i_{n-k}}}\textcolor{red}{s_{n-k+1}}\cdotss_n\to\textcolor{red}{s_{n-k+1}}s_{i_1}\cdots\textcolor{blue}{s_{i_{n-k}}}\cdotss_n\tos_{i_1}\cdots\textcolor{red}{s_{n-k+1}}\textcolor{blue}{s_{i_{n-k}}}\cdotss_n.\]</span> 再一次应用归纳假设，上面右边共轭于 <span class="math display">\[\textcolor{blue}{s_{i_{n-k}}}s_{i_1}\cdots\textcolor{red}{s_{n-k+1}}\cdotss_n.\]</span> 结论同样成立。<span class="math inline">\(\blacksquare\)</span></p><p>这样一来，下面的结论就是显然的了：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>任何 Coxeter 元都共轭于 <span class="math inline">\(s_1\cdotss_n\)</span>。</p></div><h1 id="acting-on-a-plane">3.17 Acting on a plane</h1><p>设 <span class="math inline">\(A=(a_{ij})_{1\leq i,j\leqn}=((\alpha_i,\alpha_j))\)</span> 是 Cartan 矩阵，<span class="math inline">\(\{\omega_i\}_{i=1}^n\)</span> 是关于 <span class="math inline">\(\Delta=\{\alpha_i\}_{i=1}^n\)</span>的对偶基。<span class="math inline">\(A\)</span> 正是 <span class="math inline">\(V\)</span> 上线性变换 <span class="math inline">\(\bf A\)</span> 在基 <span class="math inline">\(\{\omega_i\}\)</span> 下的矩阵： <span class="math display">\[a_{ij}=(\alpha_i,\alpha_j)=({\bfA}\omega_i,\alpha_j).\]</span> 我们知道矩阵 <span class="math inline">\(A\)</span> 有一个特征值 <span class="math inline">\(c\)</span>，它对应的特征向量 <span class="math inline">\((c_1,\ldots, c_n)\)</span> 的分量 <span class="math inline">\(c_i\)</span> 都是大于 0 的，于是 <span class="math inline">\(\sum_{i=1}^nc_i\omega_i\)</span> 是变换 <span class="math inline">\({\bf A}\)</span> 的特征向量： <span class="math display">\[{\bf A}\sum_{i=1}^nc_i\omega_i =\sum_{i=1}^ncc_i\omega_i.\]</span> 另一方面 <span class="math inline">\({\bfA}\sum_{i=1}^nc_i\omega_i=\sum_{i=1}^nc_i\alpha_i\)</span>，所以 <span class="math display">\[\sum_{i=1}^nc_i\alpha_i =\sum_{i=1}^ncc_i\omega_i.\]</span> 两边用某个 <span class="math inline">\(\alpha_j,\,(j\in J)\)</span> 作内积，并注意到<span class="math inline">\(\alpha_j\)</span> 与 <span class="math inline">\(J\)</span> 中除自己之外其它 <span class="math inline">\(J\)</span> 中的 <span class="math inline">\(\alpha_i\)</span> 正交，得到 <span class="math display">\[cc_j=\sum_{i=1}^nc_i(\alpha_i,\alpha_j)=c_j +\sum_{i\in I}c_ia_{ij}.\]</span> 即 <span class="math display">\[(c-1)c_j = \sum_{i\in I}c_ia_{ij}.\]</span>两边乘以 <span class="math inline">\(\omega_j\)</span> 并对 <span class="math inline">\(j\in J\)</span> 求和，然后交换和号得到 <span class="math display">\[\begin{aligned}(c-1)\sum_{j\in J}c_j\omega_j &amp;= \sum_{j\in J}\left(\sum_{i\inI}c_ia_{ij}\right)\omega_j\\&amp;=\sum_{i\in I}c_i\left(\sum_{j\in J}a_{ij}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\sum_{j=1}^n a_{ij}\omega_j- \sum_{j\inI}a_{ij}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\alpha_i- \sum_{j\inI}a_{ij}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\alpha_i- \omega_i-\sum_{j\in I,\,j\nei}\underbrace{a_{ij}}_{=0}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\alpha_i- \omega_i\right)\\&amp;=\sum_{i\in I}c_i\alpha_i- \mu.\\\end{aligned}\]</span> 即 <span class="math inline">\((c-1)\nu + \mu =\sum_{i\in I}c_i\alpha_i\)</span>。注意到 <span class="math inline">\(\sum_{i\in I}c_i\alpha_i\)</span> 被 <span class="math inline">\(x=\prod_{i\in I}s_i\)</span> 映射为它的负 <span class="math inline">\(-\sum_{i\in I}c_i\alpha_i\)</span>。此外 <span class="math inline">\(x\)</span> 保持 <span class="math inline">\(\nu\)</span> 不动，所以 <span class="math inline">\(x\)</span> 保持 <span class="math inline">\(\mu,\nu\)</span> 生成的二维子空间 <span class="math inline">\(P\)</span> 不变。<span class="math inline">\(x\)</span> 作为 <span class="math inline">\(P\)</span> 上的正交变换保持直线 <span class="math inline">\(\nu\)</span> 上的点不动，所以 <span class="math inline">\(x\)</span> 限制在 <span class="math inline">\(P\)</span> 上是一个反射。同理 <span class="math inline">\(y\)</span> 也是如此。所以 <span class="math inline">\(w^t=xy\)</span> 在 <span class="math inline">\(P\)</span> 上的作用是一个旋转。设这个旋转角度是<span class="math inline">\(2\pi/h\)</span>，则 <span class="math inline">\(w^t\)</span> 在 <span class="math inline">\(P\)</span> 上的阶是 <span class="math inline">\(h\)</span>。</p><p>又因为 <span class="math inline">\(\mu+\nu\)</span> 严格属于 <span class="math inline">\(C\cap P\)</span>，所以它在 <span class="math inline">\(w^t\)</span> 作用下一定在 <span class="math inline">\(V\)</span> 中有 <span class="math inline">\(k\)</span> 个不同的像，即 <span class="math inline">\(P\)</span> 上的阶等于它在 <span class="math inline">\(V\)</span> 上的阶。</p><h1 id="the-coxeter-number">3.18 The Coxeter number</h1><p>这一节证明了如下结论：对一个有限 Coxeter 群，正根的个数 <span class="math inline">\(N=|\Phi^+|\)</span>，Coxeter 数 <span class="math inline">\(h\)</span>，单根的个数 <span class="math inline">\(n=|\Delta|\)</span> 满足 <span class="math display">\[N = \frac{nh}{2}.\]</span></p><p>回忆 <span class="math inline">\(y=s_1\cdots s_r,z=s_{r+1}\cdotss_n\)</span> 在 <span class="math inline">\(P\)</span>上的作用都是反射，它们在 <span class="math inline">\(P\)</span>上生成的群是二面体群 <span class="math inline">\(I_2(h)\)</span>，这个群包含 <span class="math inline">\(h\)</span> 个反射和 <span class="math inline">\(h\)</span> 个旋转。记 <span class="math inline">\(I_2(h)\)</span> 中的 <span class="math inline">\(h\)</span> 个反射对应的超平面在 <span class="math inline">\(P\)</span> 上的截线分别是 <span class="math inline">\(L_1,\ldots,L_h\)</span>，这些 <span class="math inline">\(L_i\)</span> 是 <span class="math inline">\(I_2(h)\)</span> 作用在直线 <span class="math inline">\(L=\mathbb{R}\lambda\)</span> 和 <span class="math inline">\(M=\mathbb{R}\mu\)</span> 上得到的。设 <span class="math inline">\(\beta\in\Phi\)</span>，我们来分析 <span class="math inline">\(\beta\)</span> 对应的超平面 <span class="math inline">\(H_\beta\)</span> 在 <span class="math inline">\(P\)</span> 上的截线是什么。</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>对任何 <span class="math inline">\(\beta\in\Phi\)</span>，<span class="math inline">\(H_\beta\cap P\in \{L_1,\ldots,L_h\}\)</span>。</p></div><p>证明：首先注意到 <span class="math inline">\(P\)</span> 不可能包含在<span class="math inline">\(H_\beta\)</span> 中。因为 <span class="math inline">\(P\)</span> 和基本区域 <span class="math display">\[C=\{v\in V\mid (\alpha, v)&gt;0 \text { for all}\alpha\in\Delta\}\]</span> 的交是 <span class="math display">\[P\capC=\{a\lambda + b\mu\mid a&gt;0,b&gt;0\}.\]</span> 它当然是非空的，而<span class="math inline">\(H_\beta\)</span> 不可能包含 <span class="math inline">\(C\)</span> 中的点，所以 <span class="math inline">\(H_\beta\cap P\)</span> 是 <span class="math inline">\(P\)</span> 的一条截线。</p><p>其次如果这条截线不是上述 <span class="math inline">\(\{L_i\}\)</span>任何之一，那么我们可以用 <span class="math inline">\(y,z\)</span>的某个组合将其变换到 <span class="math inline">\(P\cap C\)</span>中，这相当于用某个 <span class="math inline">\(w\in I_2(h)\)</span> 使得<span class="math inline">\(\gamma=w\beta\)</span> 的超平面 <span class="math inline">\(H_\gamma\)</span> 与 <span class="math inline">\(P\)</span> 的交线穿过 <span class="math inline">\(P\cap C\)</span>，这与任何根的镜面与 <span class="math inline">\(C\)</span> 之交为空集矛盾。<span class="math inline">\(\blacksquare\)</span></p><p>我们只要讨论哪些 <span class="math inline">\(H_\beta\)</span> 满足<span class="math inline">\(H_\beta\cap P =L\)</span> 或者 <span class="math inline">\(H_\beta\cap P =M\)</span> 即可。其它的 <span class="math inline">\(L_i\)</span> 由于形如 <span class="math inline">\(L_i=wL\)</span> 或者 <span class="math inline">\(L_i=wM\)</span>，这里 <span class="math inline">\(w\in I_2(h)\)</span>，所以对应的是 <span class="math inline">\(wH_\beta\)</span>。</p><p>如果 <span class="math inline">\(H_\beta\cap P = L\)</span>，则反射<span class="math inline">\(s_\beta\)</span> 保持 <span class="math inline">\(L\)</span> 不动。这时 <span class="math inline">\((\beta,\lambda=0)\)</span>。设 <span class="math inline">\(\beta=\sum\limits_{i=1}^n a_i\alpha_i (a_i\geq0)\)</span>，由于 <span class="math inline">\(\lambda=\sum_{i\inI}c_i\omega_i\)</span>，所以 <span class="math display">\[(\beta,\lambda) = \sum_{i\in I} a_ic_i=0.\]</span> 由于 <span class="math inline">\(c_i(1\leq i\leq n)\)</span>都是正的，所以必须对每个 <span class="math inline">\(i\in I\)</span> 有<span class="math inline">\(a_i=0\)</span>，即 <span class="math inline">\(\beta\)</span> 是 <span class="math inline">\(\{\alpha_j,j\in J\}\)</span> 的线性组合，从而<span class="math inline">\(\beta\)</span> 属于标准椭圆子群 <span class="math inline">\(J\)</span> 的根系 <span class="math inline">\(\Phi_J\)</span>。但是 <span class="math inline">\(J\)</span> 中的生成元两两交换，<span class="math inline">\(\Phi_J\)</span> 中的正根只有 <span class="math inline">\(\{\alpha_j,j\in J\}\)</span>，所以满足 <span class="math inline">\(H_\beta\cap P=L\)</span> 的正根 <span class="math inline">\(\beta\)</span> 有 <span class="math inline">\(|J|=n-r\)</span> 个。</p><p>同样的分析可得满足 <span class="math inline">\(H_\beta\capP=M\)</span> 的正根 <span class="math inline">\(\beta\)</span> 有 <span class="math inline">\(|I|=r\)</span> 个。</p><p>当 <span class="math inline">\(h\)</span> 是偶数时，<span class="math inline">\(I_2(h)\)</span> 在 <span class="math inline">\(\{L_1,\ldots,L_h\}\)</span>上的作用分成两个长度同为 <span class="math inline">\(h/2\)</span>的轨道，分别由 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span> 生成，<span class="math inline">\(L\)</span> 所在的轨道每个超平面来自 <span class="math inline">\(n-r\)</span> 个正根，<span class="math inline">\(M\)</span> 所在的轨道每个超平面来自 <span class="math inline">\(r\)</span> 个正根，所以一共是 <span class="math inline">\(h(n-r)/2 + hr/2 = nh/2=N\)</span> 个正根。</p><p>当 <span class="math inline">\(h\)</span> 是奇数时，<span class="math inline">\(I_2(h)\)</span> 传递地作用在 <span class="math inline">\(\{L_1,\ldots,L_h\}\)</span> 上，所以 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span> 来自同样数目的正根，即 <span class="math inline">\(r=n-r\)</span>，所以 <span class="math inline">\(r=n/2\)</span>。同样地 <span class="math inline">\(N=nh/2\)</span>。</p><p>这里需要对 <span class="math inline">\(h\)</span>的奇偶性分别讨论是因为在二面体群中，奇数时两个生成元是共轭的，偶数时则不共轭。</p><h1 id="eigenvalues-of-coxeter-elements">3.19 Eigenvalues of Coxeterelements</h1><p>设 <span class="math inline">\(u,v\)</span> 是 Coxeter 平面 <span class="math inline">\(P\)</span> 的一组正交基，则 <span class="math inline">\(z=u+iv\)</span> 是 <span class="math inline">\(w\)</span> 在 <span class="math inline">\(V_{\mathbb{C}}\)</span> 上的特征向量，特征值为<span class="math inline">\(e^{2\pi i/h}\)</span>。对任何 <span class="math inline">\(\beta\in\Phi^+\)</span>，<span class="math inline">\((\beta,z)=(\beta,u) + (\beta,v)i\ne0\)</span>，否则会导致 <span class="math inline">\(P\inH_\beta\)</span>，与 <span class="math inline">\(P\cap C\)</span>非空矛盾。</p><p>设 <span class="math inline">\(\{v_i\}\)</span> 是 <span class="math inline">\(V\)</span> 的一组基，<span class="math inline">\(\{x_i\}\in V^\ast\)</span> 是对偶基：<span class="math inline">\(x_i(v_j)=\delta_{ij}\)</span>。<span class="math inline">\(x_1,\cdots,x_n\)</span>是坐标函数，它们是代数无关的：<span class="math inline">\(\mathbb{C}[x_1,\cdots,x_n]\)</span>是一个多项式环。我们把 <span class="math inline">\(\mathbb{C}[x_1,\cdots,x_n]\)</span> 称作 <span class="math inline">\(V\)</span> 上的坐标环，简记作 <span class="math inline">\(\mathbb{C}[V]\)</span>。设 <span class="math inline">\(G\subset GL(V)\)</span>是一个有限的可逆线性变换群，则 <span class="math inline">\(G\)</span>也作用在 <span class="math inline">\(\mathbb{C}[V]\)</span>上：对任何多项式 <span class="math inline">\(f\in\mathbb{C}[V]\)</span>，定义 <span class="math inline">\(g\)</span> 在<span class="math inline">\(f\)</span> 上作用的结果 <span class="math inline">\(g\cdot f\)</span> 为</p><p><span class="math display">\[g\cdot f(v)=f(g^{-1}v).\]</span> 对<span class="math inline">\(f=\sum a_{i_1\cdots i_n}x_1^{i_1}\cdotsx_n^{i_n}\in\mathbb{C}[V]\)</span>，<span class="math inline">\(f\)</span> 在 <span class="math inline">\(v=\sum_{i}c_iv_i\)</span> 处的值为 <span class="math display">\[f(v)=\sum a_{i_1\cdots i_n}x_1(v)^{i_1}\cdotsx_n(v)^{i_n} = \sum a_{i_1\cdots i_n}c_1^{i_1}\cdots c_n^{i_n}.\]</span>于是如果不含常数项的多项式 <span class="math inline">\(f\in\mathbb{C}[V]\)</span> 满足 <span class="math inline">\(f(v_1)\ne 0\)</span>，则若 <span class="math inline">\(f=\sum a_{i_1\cdots i_n}x_1^{i_1}\cdotsx_n^{i_n}\)</span>，我们有 <span class="math display">\[0\ne f(v_1)=\suma_{i_1\cdots i_n}x_1^{i_1}\cdotsx_n^{i_n}\mid_{x_1=1,x_2=\cdots=x_n=0}.\]</span> 即 <span class="math inline">\(f\)</span> 的单项式里面必有一项只含有 <span class="math inline">\(x_1\)</span>。</p><p>进一步，如果 <span class="math inline">\(\frac{\partial f}{\partialx_i}\)</span> 满足 <span class="math inline">\(\frac{\partialf}{\partial x_i}(v_1)\ne0\)</span>，那就说明 <span class="math inline">\(f\)</span> 的单项式里面必有一项形如 <span class="math inline">\(ax_1^{m}x_i\)</span>，即 <span class="math inline">\(f\)</span> 形如 <span class="math inline">\(f=ax_1^mx_i + \cdots\)</span>。</p><p>设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(V\)</span> 上可对角化的线性变换，<span class="math inline">\(Tv_i=\lambda_i v_i\)</span>，则 <span class="math inline">\(Tx_i=\lambda_i^{-1}x_i\)</span>。并且设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(T\)</span>- 不变的多项式，则 <span class="math display">\[f=T\cdot f =a\lambda_1^{-m}x_1^m\lambda_i^{-1}x_i + \cdots.\]</span> 比较即得 <span class="math display">\[ax_1^mx_i =a\lambda_1^{-m}x_1^m\lambda_i^{-1}x_i.\]</span> 即 <span class="math inline">\(1 = \lambda_1^{-m}\lambda_i^{-1}\)</span>，从而<span class="math inline">\(\lambda_i = \lambda_1^{-m}\)</span>。</p><p>对 Coxeter 元 <span class="math inline">\(w\)</span>，它的特征值是<span class="math inline">\(\{\zeta^{m_i},\,1\leq i\leqn\}\)</span>，并且 <span class="math inline">\(m_1=1,m_{n-1}=h-1\)</span>。<span class="math inline">\(m_1=1\)</span> 对应的是 <span class="math inline">\(w\)</span> 的重数为 1 的特征值 <span class="math inline">\(\zeta\)</span>。</p><p>以 <span class="math inline">\(w\)</span> 的特征向量为基，由于 <span class="math inline">\(\zeta\)</span> 对应的特征向量 <span class="math inline">\(v_1\)</span> 在 <span class="math inline">\(C\)</span> 内，它不在任何根平面 <span class="math inline">\(H_\alpha\)</span> 上，所以 Jacobian <span class="math inline">\(J=\det\left(\frac{\partial f_i}{\partialx_j}\right)\)</span> 在 <span class="math inline">\(v_1\)</span> 处不为0，于是某个 <span class="math inline">\(\prod_{i=1}^n \frac{\partialf_i}{\partial x_{\pi(j)}}\)</span> 在 <span class="math inline">\(v_1\)</span> 处不为 0，适当重排 <span class="math inline">\(f_i\)</span> 以后可以不妨设每个 <span class="math inline">\(\frac{\partial f_i}{\partialx_i}(v_1)\ne0\)</span>。根据上面的讨论，<span class="math inline">\(f_i\)</span> 形如 <span class="math display">\[f_i=ax_1^{d_i-1}x_i+\cdots.\]</span> 并且 <span class="math inline">\(\lambda_i=\zeta^{m_i}=\zeta^{1-d_i}\)</span>。从而 <span class="math inline">\(h-m_i\equiv d_i-1\pmodh\)</span>。我们知道对每个 <span class="math inline">\(i\)</span> 有<span class="math inline">\(0&lt;h-m_i&lt;h\)</span>，所以对每个 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(d_i-1\geq h-m_i\)</span>。另一方面，集合 <span class="math inline">\(\{h-m_i\}\)</span> 不过是集合 <span class="math inline">\(\{m_i\}\)</span> 的一个置换，所以 <span class="math display">\[\sum (h-m_i) = \sum m_i = \sum(d_i-1).\]</span>这只能是对每个 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(h-m_i=d_i-1\)</span>，即集合相等 <span class="math inline">\(\{d_i-1\}=\{m_i\}\)</span>。</p><h1 id="counting-hyperplanes">4.4 Counting hyperplanes</h1><p>回忆 <span class="math inline">\(\mathcal{H}\)</span> 是所有超平面<span class="math inline">\(\{H_{\alpha,k}\mid\alpha\in\Phi,k\in\mathbb{Z}\}\)</span> 组成的集合。其中 <span class="math display">\[H_{\alpha,k}=\{v\in V\mid(\alpha,v)=k\}.\]</span></p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span><span class="math inline">\(H_s\)</span> 是 <span class="math inline">\(\mathcal{H}\)</span> 中唯一分隔 <span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 的超平面，即 <span class="math inline">\(\mathcal{L}(s)=\{H_s\}\)</span>。</p></div><p>证明：我们先说明对任何正根 <span class="math inline">\(\beta\ne\alpha_s\)</span>，以及任何 <span class="math inline">\(k\in\mathbb{Z}\)</span>，<span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 都在超平面 <span class="math inline">\(H_{\beta,k}\)</span> 的同一侧。</p><p>首先根据 <span class="math inline">\(A_o\)</span>的刻画，它满足对任何正根 <span class="math inline">\(\gamma\)</span>都有 <span class="math inline">\(0&lt;(A_o,\gamma)&lt;1\)</span>，特别地<span class="math inline">\(0&lt;(A_o,\beta)&lt;1\)</span>。由于 <span class="math inline">\(\beta\ne\alpha_s\)</span> 所以 <span class="math inline">\(s\beta\)</span> 仍然是正根，因此 <span class="math display">\[0&lt;(A_o,s\beta)&lt;1\Longrightarrow0&lt;(sA_o,\beta)&lt;1.\]</span> 这说明 <span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 在 <span class="math inline">\(H_\beta\)</span> 和 <span class="math inline">\(H_{\beta,1}\)</span>围成的带状区域中间。所以对任何 <span class="math inline">\(k\)</span>它们都在 <span class="math inline">\(H_{\beta,k}\)</span> 的同一侧。</p><p>另一方面不难看出 <span class="math inline">\(-1 &lt;(sA_o,\alpha_s)&lt;0\)</span>，也就是说 <span class="math inline">\(sA_o\)</span> 和 <span class="math inline">\(A_o\)</span> 位于 <span class="math inline">\(H_{\alpha_s,0}\)</span> 的两侧，但是对任何 <span class="math inline">\(k\ne0\)</span>，它们位于 <span class="math inline">\(H_{\alpha_s,k}\)</span> 的同侧。</p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>固定 <span class="math inline">\(s\in S_a\)</span>。对任何 <span class="math inline">\(w\in\widehat{W_a}\)</span>，有如下结论成立：</p><ul><li><span class="math inline">\(H_s\)</span> 恰好属于 <span class="math inline">\(\mathcal{L}(w)\)</span> 和 <span class="math inline">\(\mathcal{L}(sw)\)</span> 之一。</li><li><span class="math inline">\(s(\mathcal{L}(w)\setminus\{H_s\}) =\mathcal{L}(sw)\setminus\{H_s\}\)</span>。</li></ul></div><p>证明：第一点是显然的，因为 <span class="math inline">\(wA_o\)</span>和 <span class="math inline">\(swA_o\)</span> 位于 <span class="math inline">\(H_s\)</span> 的两侧，它俩有且恰有一个和 <span class="math inline">\(A_o\)</span> 位于 <span class="math inline">\(H_s\)</span> 的同一侧。</p><p>对于第二点，我们要证明的是 <span class="math inline">\(H\leftrightarrow sH\)</span> 给出了 <span class="math inline">\(\mathcal{L}(w)\)</span> 和 <span class="math inline">\(\mathcal{L}(sw)\)</span> 中除 <span class="math inline">\(H_s\)</span> 之外的超平面的一一对应。然而若 <span class="math inline">\(H\ne H_s\)</span>，根据上面的引理，<span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 位于 <span class="math inline">\(H\)</span> 的同一侧，所以</p><p><span class="math display">\[H\in\mathcal{L}(w)\Longleftrightarrow\begin{matrix}A_o\\ sA_o\end{matrix}\stackrel{H=0}{\biggl\lvert} wA_o\Longleftrightarrow \begin{matrix}sA_o\\A_o\end{matrix}\stackrel{sH=0}{\biggl\lvert} swA_o.\]</span> 可见 <span class="math inline">\(sH\in \mathcal{L}(sw)\)</span> 并且显然 <span class="math inline">\(sH\ne H_s\)</span>。此即为所证。</p><h1 id="a-formula-for-the-order-of-w">4.9 A formula for the order of<span class="math inline">\(W\)</span></h1><p>从前面的学习中我们知道，一个仿射 Weyl 群 <span class="math inline">\(W_a\)</span> 总是可以写成一个有限 Weyl 群 <span class="math inline">\(W\)</span> 和一个格点群 <span class="math inline">\(L\)</span> 的半直积：<span class="math inline">\(W_a=W\ltimes L\)</span>。这里的 <span class="math inline">\(L\)</span> 实际上是 <span class="math inline">\(W\)</span> 的余根格点：<span class="math inline">\(L=L(\Phi^\vee)\)</span>。这一节介绍了怎样计算<span class="math inline">\(W\)</span> 的阶 <span class="math inline">\(|W|\)</span>。</p><p>我们以 <span class="math inline">\(\widetilde{B}_2\)</span>为例来说明。<span class="math inline">\(\Delta\)</span> 包含两个单根<span class="math inline">\(\alpha_1=e_1-e_2,\,\alpha_2=e_2\)</span>。最高根<span class="math inline">\(\widetilde{\alpha}=\alpha_1+2\alpha_2\)</span>，于是<span class="math inline">\(c_1=1,c_2=2\)</span>。</p><p><img style="margin:0px auto;display:block" width="500" src="/images/humphreys/b2.svg"></p><ul><li>图中<strong>黄色</strong>区域是由所有的房间 <span class="math inline">\(\{wA_o\mid w\in W\}\)</span> 组成。即 <span class="math inline">\(\Pi=\bigcup_{w\inW}wA_o\)</span>。另一个等价的描述是 <span class="math display">\[ \Pi =\{x\in V\mid -1 &lt; (x,\alpha) &lt; 1 \text{ for all }\alpha\in\Phi^+\}.\]</span> 所以 <span class="math inline">\(\mathrm{Vol}(\Pi)=|W|\cdot\mathrm{Vol}(A_o)\)</span>。<span class="math inline">\(\Pi\)</span> 是余根格点 <span class="math inline">\(L(\Phi^\vee)\)</span>的基本区域，因为书中已经证明了 <span class="math inline">\(W_a=W\ltimesL\)</span>，并且 <span class="math inline">\(A_o\)</span> 是 <span class="math inline">\(W_a\)</span> 作用下的基本区域，所以 <span class="math inline">\(\Pi\)</span> 在 <span class="math inline">\(L\)</span>的作用下互不相交，并且密铺了整个平面。</li><li>图中<strong>绿色</strong>区域是余权格点 <span class="math inline">\(\hat{L}(\Phi^\vee)\)</span> 的基本区域 <span class="math inline">\(\hat{\Pi}\)</span>，它是一个平行多面体，由基本余权<span class="math inline">\(\{\omega_1,\ldots,\omega_n\}\)</span>张成，并且 <span class="math inline">\(\dfrac{\mathrm{Vol}(\Pi)}{\mathrm{Vol}(\hat{\Pi}) } = f\)</span>。</li><li>基本区域 <span class="math inline">\(A_o\)</span> 是由 <span class="math inline">\(\left\{0,\dfrac{\omega_1}{c_1},\ldots,\dfrac{\omega_n}{c_n}\right\}\)</span>生成的单纯形，它和 <span class="math inline">\(\{\omega_1,\ldots,\omega_n\}\)</span>生成的平行多面体 <span class="math inline">\(\hat{\Pi}\)</span>的体积关系为 <span class="math display">\[\mathrm{Vol}(\hat{\Pi}) =n!c_1\cdots c_n\cdot\mathrm{Vol}(A_o).\]</span></li><li>综上可得 <span class="math display">\[\dfrac{\mathrm{Vol}(\Pi)}{\mathrm{Vol}(\hat{\Pi}) } =\frac{|W|\mathrm{Vol}(A_o)}{n!c_1\cdotsc_n\cdot\mathrm{Vol}(A_o)}=f.\]</span> 即 <span class="math inline">\(|W| = n!c_1\cdots c_n f\)</span>。</li></ul><h1 id="bruhat-ordering">5.9 Bruhat ordering</h1><p>这一节介绍了 Bruhat 序，以及重要的 lifting property。Humphreys书中是先介绍的 liftingproperty，然后在下一小节证明子表达式定理。实际上，如果我们采用 Bjornerand Brenti 教材的处理方式，先证明子表达式定理的话，那么 lifting property更好证。</p><div id="lifting" class="unnumbered statement sta_lifting_property plain"><p><span class="statement-heading"><span class="statement-label">Liftingproperty</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(u&lt; w\)</span>，<span class="math inline">\(s\inS\)</span> 满足 <span class="math inline">\(sw&lt;w\)</span> 和 <span class="math inline">\(su&gt;u\)</span>，则 <span class="math inline">\(u\leq sw\)</span> 并且 <span class="math inline">\(su\leq w\)</span>。</p></div><p>证明：用 <span class="math inline">\(\alpha\prec\beta\)</span> 表示word <span class="math inline">\(\alpha\)</span> 是 word <span class="math inline">\(\beta\)</span> 的子表达式。设 <span class="math inline">\(sw=s_1\cdots s_q\)</span> 是 <span class="math inline">\(sw\)</span> 的一个既约表示。由于 <span class="math inline">\(sw&lt;w\)</span>，所以 <span class="math inline">\(w=ss_1\cdots s_q\)</span> 也是既约表示。又因为已知<span class="math inline">\(u&lt;w\)</span>，所以根据子表达式定理，存在<span class="math inline">\(u=s_{i_1}\cdots s_{i_k}\)</span>的某个既约表示满足 <span class="math display">\[s_{i_1}\cdotss_{i_k}\prec ss_1\cdots s_q.\]</span> 又已知 <span class="math inline">\(su&gt;u\)</span>，所以 <span class="math inline">\(s\ne s_{i_1}\)</span>，从而 <span class="math display">\[u=s_{i_1}\cdots s_{i_k}\prec s_1\cdotss_q=sw.\]</span> 这意味着 <span class="math display">\[su=ss_{i_1}\cdotss_{i_k}\prec ss_1\cdots s_q=w,\]</span> 从而 <span class="math inline">\(u\leq sw\)</span> 且 <span class="math inline">\(su\leq w\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(u\ne w\)</span>，则存在 <span class="math inline">\(x\)</span> 满足 <span class="math inline">\(u&lt;x\)</span> 且 <span class="math inline">\(w&lt;x\)</span>。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(l(u)+l(w)\)</span> 归纳。<span class="math inline">\(l(u)+l(w)=0\)</span>时结论是显然的。假设结论对小于 <span class="math inline">\(l(u)+l(w)\)</span> 的情形已经成立。取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(su&lt;u\)</span>，则根据归纳假设，存在 <span class="math inline">\(y\)</span> 使得 <span class="math inline">\(su&lt;y\)</span> 且 <span class="math inline">\(w&lt;y\)</span>。</p><ol type="1"><li>如果 <span class="math inline">\(sy&lt;y\)</span>，那么由提升引理，<span class="math inline">\(u&lt;y\)</span>，从而 <span class="math inline">\(y\)</span> 就是所求的 <span class="math inline">\(x\)</span>。</li><li>如果 <span class="math inline">\(sy&gt;y\)</span>，那么 <span class="math inline">\(sy\)</span> 就是所求的 <span class="math inline">\(x\)</span>。</li></ol><p><span class="math inline">\(\blacksquare\)</span></p><p>这个推论的一个直接结论是，任何有限 Coxeter 群中必有 Bruhat序下唯一的极大元 <span class="math inline">\(w_0\)</span>。<span class="math inline">\(w_0\)</span> 必然满足 <span class="math inline">\(w_0^2=1\)</span>，因为如果 <span class="math inline">\(w_0\ne w_0^{-1}\)</span>的话，它们就会还有一个更大的覆盖元。</p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>如果 <span class="math inline">\(w\in W\)</span> 满足对任何 <span class="math inline">\(s\in S\)</span> 都有 <span class="math inline">\(sw&lt;w\)</span>，则 <span class="math inline">\(W\)</span> 必然是有限群，并且 <span class="math inline">\(w=w_0\)</span> 是极大元。</p></div><p><strong>证明</strong>：我们对 <span class="math inline">\(l(x)\)</span> 归纳证明对任何 <span class="math inline">\(x\in W\)</span> 有 <span class="math inline">\(x\leq w\)</span>。设结论对长度小于 <span class="math inline">\(l(x)\)</span> 的元素都成立，取 <span class="math inline">\(s\)</span> 使得 <span class="math inline">\(l(sx)&lt;l(x)\)</span>，根据归纳假设 <span class="math inline">\(sx\leq w\)</span>。但是 <span class="math inline">\(sx\)</span> 不可能等于 <span class="math inline">\(w\)</span>，因为 <span class="math inline">\(l(s\cdotsx)=l(x)&gt;l(sx)\)</span>。所以根据提升性质可得 <span class="math inline">\(x\leq w\)</span>。于是 <span class="math inline">\(W\)</span> 中任何元素都在区间 <span class="math inline">\([1,x]\)</span>中，这样的元素显然只有有限多个。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(W\)</span> 是有限群，则对任何<span class="math inline">\(w\in W\)</span> 有 <span class="math inline">\(l(ww_0)=l(w_0)-l(w)\)</span>。</p></div><p><strong>证明</strong>：只要证明 <span class="math inline">\(l(ww_0)\leq l(w_0)-l(w)\)</span> 即可。对 <span class="math inline">\(l(w_0)-l(w)\)</span> 归纳，等于 0 的情况对应 <span class="math inline">\(w=w_0\)</span>，结论显然成立。设 <span class="math inline">\(w&lt;w_0\)</span> 并且结论对任何 <span class="math inline">\(x&gt;w\)</span> 成立。根据上一个推论，必然存在<span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(sw&gt;w\)</span>。对 <span class="math inline">\(sw\)</span> 应用归纳假设可得</p><p><span class="math display">\[l(ww_0)\leq l(sww_0)+1 \leq l(w_0) -l(sw) + 1 = l(w_0) - l(w).\]</span> <span class="math inline">\(\blacksquare\)</span></p><p>对任何 <span class="math inline">\(l(w)\)</span>，记 <span class="math inline">\(T_L(w)=\{t\in T\mid l(tw) &lt;l(w)\}\)</span>。</p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(W\)</span> 是有限群，则对任何<span class="math inline">\(w\in W\)</span> 有 <span class="math inline">\(T_L(ww_0)=T\setminus T_L(w)\)</span>。</p></div><p><strong>证明</strong>：根据上一个推论，<span class="math inline">\(l(tww_0)=l(w_0)-l(tw)\)</span>。所以 <span class="math inline">\(l(tww_0)&gt;l(ww_0)\)</span> 当且仅当 <span class="math inline">\(l(tw)&lt;l(w)\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span><span class="math inline">\(l(w_0)=|T|\)</span>.</p></div><p><strong>证明</strong>：在上一个推论中取 <span class="math inline">\(w=1\)</span> 有 <span class="math inline">\(T_L(w_0)=T\)</span>，结合 <span class="math inline">\(l(w)=|T_L(w)|\)</span> 对任何 <span class="math inline">\(w\in W\)</span> 成立即得。<span class="math inline">\(\blacksquare\)</span></p><h1 id="subexpressions">5.10 Subexpressions</h1><div id="thm-5.10" class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(w=s_1\cdots s_q\)</span>是一个既约表达式，<span class="math inline">\(u\ne w\)</span> 并且 <span class="math inline">\(u\)</span> 的某个既约表达式恰好是 <span class="math inline">\(s_1\cdots s_q\)</span> 的子表达式。则存在 <span class="math inline">\(v\in W\)</span> 满足以下三点：</p><ol type="1"><li><span class="math inline">\(v &gt; u\)</span>。</li><li><span class="math inline">\(l(v) = l(u)+1\)</span>。</li><li><span class="math inline">\(v\)</span> 的某个既约表达式是 <span class="math inline">\(s_1\cdots s_q\)</span> 的子表达式。</li></ol></div><p><strong>证明</strong>：设 <span class="math inline">\(u\)</span>的既约表达式是从 <span class="math inline">\(s_1\cdots s_q\)</span>中删去 <span class="math inline">\(i_1,\ldots,i_k\)</span> 位置得到的：<span class="math display">\[u = s_1\cdots\hat{s_{i_1}}\cdots\hat{s_{i_k}}\cdots s_q.\]</span> 这样的既约表达式可能不唯一，选择使得<span class="math inline">\(i_k\)</span> 最小的那一个。令 <span class="math display">\[t=s_qs_{q-1}\cdots s_{i_k}\cdotss_{q-1}s_q.\]</span> 则 <span class="math inline">\(ut\)</span> 就是把<span class="math inline">\(s_{i_k}\)</span> 补回 <span class="math inline">\(u\)</span> 的表达式中： <span class="math display">\[ut= s_1\cdots\hat{s_{i_1}}\cdots\hat{s_{i_{k-1}}}\cdots s_{i_k}\cdots s_q.\]</span> 这个 <span class="math inline">\(ut\)</span> 的表达式未必是既约的，但是无论如何<span class="math inline">\(l(ut)\)</span> 不会超过这个表达式的长度，即<span class="math inline">\(l(ut)\leql(u)+1\)</span>。我们来证明等号是成立的。如果确实如此，那么取 <span class="math inline">\(v=ut\)</span> 即可满足要求。</p><p>若不然，<span class="math inline">\(l(ut)&lt;l(u)\)</span>，则根据strong exchange 条件，<span class="math inline">\(ut\)</span> 等于在<span class="math inline">\(u\)</span> 的表达式再删掉一个 <span class="math inline">\(s_p\)</span>。这个 <span class="math inline">\(p\)</span> 出现的位置有两种可能：</p><p>第一种可能是 <span class="math inline">\(p&gt;i_k\)</span>，即 <span class="math display">\[ut=s_1\cdots\hat{s_{i_1}}\cdots\hat{s_{i_k}}\cdots \hat{s_p}\cdotss_q.\]</span> 这种情况下 <span class="math inline">\(t\)</span> 还等于<span class="math inline">\(t=s_qs_{q-1}\cdots s_p\cdotss_{q-1}s_q\)</span>。于是 <span class="math display">\[w=wt^2=w(s_qs_{q-1}\cdots s_{i_k}\cdotss_{q-1}s_q)(s_qs_{q-1}\cdots s_p\cdotss_{q-1}s_q)=s_1\cdots\hat{s_{i_k}}\cdots\hat{s_p}\cdots s_q.\]</span>这与 <span class="math inline">\(s_1\cdots s_q\)</span> 是 <span class="math inline">\(w\)</span> 的既约表达式矛盾。</p><p>第二种可能是 <span class="math inline">\(p&lt;i_k\)</span> 出现在<span class="math inline">\(i_k\)</span> 之前的某个位置，当然 <span class="math inline">\(p\notin\{i_1,\ldots,i_k\}\)</span>。这种情况下<span class="math display">\[u=ut\cdott=s_1\cdots\hat{s_{i_1}}\cdots\hat{s_p}\cdots\hat{s_{i_k}}\cdotss_q\cdot(s_qs_{q-1}\cdots s_{i_k}\cdotss_{q-1}s_q)=s_1\cdots\hat{s_{i_1}}\cdots\hat{s_p}\cdots s_{i_k}\cdotss_q.\]</span> 这与 <span class="math inline">\(i_k\)</span>的极小性矛盾。<span class="math inline">\(\blacksquare\)</span></p><p>在上面的例子中我把 <span class="math inline">\(p\)</span> 写在了<span class="math inline">\(i_1\)</span> 和 <span class="math inline">\(i_k\)</span> 中间的某个位置上，实际上 <span class="math inline">\(p\)</span> 当然可以小于 <span class="math inline">\(i_1\)</span>，但这不影响论证。</p><div id="thm-5.10-1" class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(w=s_1\cdots s_q\)</span>是一个既约表达式，则 <span class="math inline">\(u\leq w\)</span>当且仅当 <span class="math inline">\(u\)</span> 的某个既约表达式是 <span class="math inline">\(s_1\cdots s_q\)</span> 的子表达式。</p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>: 设 <span class="math inline">\(u=x_0\xrightarrow{t_1}x_1\xrightarrow{t_2}\cdots\xrightarrow{t_m}x_m=w\)</span>，则根据strong exchange 条件，<span class="math inline">\(x_{m-1}=wt_m\)</span>是 <span class="math inline">\(w\)</span> 的子表达式，进一步 <span class="math inline">\(x_{m-2}=x_{m-1}t_{m-1}\)</span> 是 <span class="math inline">\(x_{m-1}\)</span>的子表达式，这样一直下去，得到一个 <span class="math inline">\(u=x_0\)</span> 的表达式，它是 <span class="math inline">\(s_1\cdots s_q\)</span> 的子表达式。最后根据deletion condition，这个子表达式又包含一个 <span class="math inline">\(u\)</span> 的既约子表达式。</p><p><span class="math inline">\(\Leftarrow\)</span>: 如果 <span class="math inline">\(u\)</span> 的某个既约表达式是 <span class="math inline">\(s_1\cdots s_q\)</span>的子表达式，根据上面的引理，只要 <span class="math inline">\(u\new\)</span>，那么就存在反射 <span class="math inline">\(t\)</span> 使得<span class="math inline">\(u&lt;ut\)</span>，并且 <span class="math inline">\(ut\)</span> 仍然是 <span class="math inline">\(w\)</span> 的子表达式。对 <span class="math inline">\(ut\)</span> 继续此步骤直到结果 <span class="math inline">\(w\)</span> 为止即可。<span class="math inline">\(\blacksquare\)</span></p><h1 id="more-on-the-geometric-representation">6.2 More on the geometricrepresentation</h1><p>这一节证明了如果几何实现中的二次型 <span class="math inline">\(B(\alpha_s,\alpha_t)=-\cos\frac{\pi}{m_{s,t}}\)</span>是正定的，则 <span class="math inline">\(W\)</span>是有限群。这一点是两个结论合起来的结果：</p><div id="discrete-action" class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span><span class="math inline">\(W\)</span> 是 <span class="math inline">\(O(n,\mathbb{R})\)</span> 的离散子集，即对任何<span class="math inline">\(w\in W\)</span>，存在 <span class="math inline">\(w\)</span> 的开邻域 <span class="math inline">\(w\in U\)</span> 使得 <span class="math inline">\(U\)</span> 不包含 <span class="math inline">\(W\)</span> 中除 <span class="math inline">\(w\)</span> 外的任何元素。</p></div><p>证明：固定一个基本区域中的点 <span class="math inline">\(x\inC\)</span>，考虑从 <span class="math inline">\(\mathrm{GL}(V^\ast)\)</span> 到 <span class="math inline">\(V^\ast\)</span> 的连续映射 <span class="math display">\[g\to g\cdot x,\quadg\in\mathrm{GL}(V^\ast).\]</span> <span class="math inline">\(C\)</span>在此映射下的逆像是 <span class="math inline">\(\mathrm{GL}(V^\ast)\)</span> 中的某个开集 <span class="math inline">\(U\)</span>，并且 <span class="math inline">\(U\)</span> 显然包含恒等元 1，因为 <span class="math inline">\(1\cdot x=x\in C\)</span>，即 <span class="math inline">\(U\)</span> 是 1 的一个开邻域。<span class="math inline">\(U\)</span> 不包含其它任何 <span class="math inline">\(w\ne 1\in W\)</span>，否则 <span class="math inline">\(w\cdot x\in C\)</span>，这与 <span class="math inline">\(C\)</span> 是基本区域矛盾。同理任何 <span class="math inline">\(w\in W\)</span> 都有一个开邻域不包含其它 <span class="math inline">\(W\)</span> 中的点。</p><div id="discrete-subgroup" class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>紧 Hausdorff 拓扑群 <span class="math inline">\(G\)</span>的离散子群 <span class="math inline">\(H\)</span> 必然是有限群。</p></div><p>证明：</p><p>第一步：设 <span class="math inline">\(U\)</span> 是单位元 <span class="math inline">\(e\)</span> 的邻域且满足 <span class="math inline">\(U \cap H = \{e\}\)</span>，我们来说明存在一个邻域<span class="math inline">\(e\in V\subset U\)</span> 满足 <span class="math inline">\(VV^{-1}\subset U\)</span>。</p><p>令 <span class="math inline">\(\sigma:U\times U\to G\)</span> 为映射<span class="math inline">\(\sigma(x, y) =xy^{-1}\)</span>。由连续性，存在一个邻域 <span class="math inline">\(N\subset U\times U\)</span> 包含 <span class="math inline">\((e,e)\)</span> 使得 <span class="math inline">\(\sigma(N)\subset U\)</span>。那么 <span class="math inline">\(N\)</span> 包含一个形如 <span class="math inline">\(V_1\times V_2\)</span> 的开集，其中 <span class="math inline">\(V_1, V_2 \subset U\)</span> 是开集且 <span class="math inline">\(e\in V_1\cap V_2\)</span>。取 <span class="math inline">\(V=V_1 \cap V_2\)</span>，于是 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(e\)</span> 的一个邻域，并且 <span class="math inline">\(V\times V\subset V_1\times V_2\)</span>，因此<span class="math inline">\(VV^{-1}=\sigma(V \timesV)\subset\sigma(V_1\times V_2) \subset U\)</span>。</p><p>第二步：我们来论证 <span class="math inline">\(G\backslash H\)</span>是开集。为此只要说明对任意 <span class="math inline">\(x\in G\backslashH\)</span>，存在 <span class="math inline">\(x\)</span> 的邻域 <span class="math inline">\(U\)</span> 使得 <span class="math inline">\(U\capH=\emptyset\)</span>。设 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(e\)</span> 的邻域且 <span class="math inline">\(U\cap H=\{e\}\)</span>。令 <span class="math inline">\(V\subset U\)</span> 为具有上面第一步中性质的 <span class="math inline">\(e\)</span> 的邻域，则 <span class="math inline">\(N=Vx\)</span> 是 <span class="math inline">\(x\)</span> 的邻域。假设 <span class="math inline">\(h_1, h_2\in N\cap H\)</span>，那么存在 <span class="math inline">\(v_1,v_2\in V\)</span> 满足 <span class="math inline">\(h_1 = v_1x\)</span> 且 <span class="math inline">\(h_2=v_2x\)</span>。于是 <span class="math display">\[v_1^{-1}h_1=x=v_2^{-1}h_2\implies h_1h_2^{-1} =v_1v_2^{-1}\in VV^{-1} \subset U.\]</span> 因此 <span class="math inline">\(v_1v_2^{-1}\in H\cap U\)</span>，所以 <span class="math inline">\(h_1h_2^{-1}=e\)</span>，因此 <span class="math inline">\(h_1=h_2\)</span>。这意味着 <span class="math inline">\(N\)</span> 至多包含 <span class="math inline">\(H\)</span> 的一个元素。如果 <span class="math inline">\(N\)</span> 不包含 <span class="math inline">\(H\)</span> 的任何元素，则 <span class="math inline">\(N\)</span> 即为所求。否则若 <span class="math inline">\(N\cap H=\{h\}\)</span>，由于 <span class="math inline">\(G\)</span> 是 Hausdorff 空间，我们可以取开邻域<span class="math inline">\(U_x, U_h\subset N\)</span> 将 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(h\)</span> 分开，那么 <span class="math inline">\(U_x\)</span> 是所求的邻域。</p><p>第三步：<span class="math inline">\(H\)</span>是有限的。这是因为对每个 <span class="math inline">\(x\inH\)</span>，取其邻域 <span class="math inline">\(U_x\)</span> 使得 <span class="math inline">\(U_x\cap H=\{x\}\)</span>，这些开集加上 <span class="math inline">\(G\backslash H\)</span> 构成 <span class="math inline">\(G\)</span> 的一个开覆盖，由 <span class="math inline">\(G\)</span> 的紧性可得存在 <span class="math inline">\(G\)</span> 的有限子覆盖。于是有限多个 <span class="math inline">\(\{U_{x_i}\}_{i=1}^n\)</span> 覆盖了 <span class="math inline">\(H\)</span>。然而每个 <span class="math inline">\(U_{x_i}\)</span> 只包含一个 <span class="math inline">\(H\)</span> 中的元素 <span class="math inline">\(x_i\)</span>，所以 <span class="math inline">\(H\)</span> 是有限的。<span class="math inline">\(\blacksquare\)</span></p><p>现在 <span class="math inline">\(W\)</span> 保持 Euclidean 内积 <span class="math inline">\(B\)</span> 不变，从而是正交群 <span class="math inline">\(O(n,\mathbb{R})\)</span> 的子群。而 <span class="math inline">\(O(n,\mathbb{R})\)</span> 是紧群，<span class="math inline">\(W\)</span> 是离散子群，所以 <span class="math inline">\(W\)</span> 是有限群。</p><h1 id="and-6.4-radical-of-the-bilinear-form-finite-coxeter-groups">6.3and 6.4 Radical of the bilinear form / Finite Coxeter groups</h1><p>这两节合起来证明了 6.2 的逆命题：如果 <span class="math inline">\(W\)</span> 是有限群，则 <span class="math inline">\(B\)</span>必然是正定的。这个结论是如下几个命题合起来得到的：</p><div id="-------1" class="unnumbered statement sta____1 plain"><p><span class="statement-heading"><span class="statement-label">命题1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(V\)</span> 的一个真 <span class="math inline">\(W-\)</span> 子模，则 <span class="math inline">\(U\subset V^\bot\)</span>。</p></div><p>这个命题背后的关键是任何单根 <span class="math inline">\(\alpha_s\)</span> 必须属于 <span class="math inline">\(U\)</span> 或者 <span class="math inline">\(U^\bot\)</span> 之一。由于 <span class="math inline">\(W\)</span> 是不可约 Coxeter 群，<span class="math inline">\(\Delta\)</span>不能分成两个互相正交的子集，所以要么 <span class="math inline">\(\Delta\in U\)</span>，这与 <span class="math inline">\(U\)</span> 是真子模矛盾；要么 <span class="math inline">\(\Delta\in U^\bot\)</span>，从而 <span class="math inline">\(U\subset V^\bot\)</span>。</p><div id="-------2" class="unnumbered statement sta____2 plain"><p><span class="statement-heading"><span class="statement-label">命题2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 在 <span class="math inline">\(V\)</span> 上的作用是完全可约的。</p></div><p>这是群表示论里面的 Maschke 定理。证明技巧就是取平均构造 <span class="math inline">\(W-\)</span> 不变的正定内积。</p><div id="-------3" class="unnumbered statement sta____3 plain"><p><span class="statement-heading"><span class="statement-label">命题3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B\)</span> 是非退化的。</p></div><p>若不然 <span class="math inline">\(V^\bot\ne(0)\)</span>，完全可约性说明 <span class="math inline">\(V^\bot\)</span> 有直和补 <span class="math inline">\(U\)</span>，但是 <span class="math inline">\(U\)</span> 也在 <span class="math inline">\(V^\bot\)</span> 中，矛盾。</p><div id="-------4" class="unnumbered statement sta____4 plain"><p><span class="statement-heading"><span class="statement-label">命题4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 在 <span class="math inline">\(V\)</span> 上是不可约的。</p></div><p>这是命题 3 的直接结论，因为有非平凡的真子模意味着 <span class="math inline">\(V^\bot\)</span> 也非平凡，与 <span class="math inline">\(B\)</span> 非退化矛盾。</p><div id="-------5" class="unnumbered statement sta____5 plain"><p><span class="statement-heading"><span class="statement-label">命题5</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B\)</span> 是正定的。</p></div><p>实际上 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(W\)</span> 的不可约表示说明 <span class="math inline">\(V\)</span> 上的 <span class="math inline">\(W-\)</span>不变双线性函数构成的向量空间是一维的。而我们已经有一个 <span class="math inline">\(W-\)</span> 不变的正定内积，所以 <span class="math inline">\(B\)</span>必然是它的一个倍数，从而也是正定的。</p><h1 id="affine-coxeter-groups">6.5 Affine Coxeter groups</h1><p>之前第 4 章介绍的仿射 Coxeter群是通过关于超平面的反射构造的，这种反射未必是线性的；而 Coxeter群的几何实现中，<span class="math inline">\(W\)</span>是由线性反射生成的。这一节将这两种方式统一起来。</p><p>设 <span class="math inline">\((W,S)\)</span> 是不可约 Coxeter群，<span class="math inline">\(|S|=n+1\)</span>。根据第 5章几何实现的讨论，我们知道 <span class="math inline">\((W,S)\)</span>可以实现为 <span class="math inline">\(n+1\)</span> 维实向量空间 <span class="math inline">\(V\)</span> 上的反射群。设 <span class="math inline">\(V\)</span> 的一组基为 <span class="math inline">\(\Delta=\{\alpha_i\}\)</span>，每个 <span class="math inline">\(s_i\in S\)</span> 对应于 <span class="math inline">\(V\)</span> 上的反射 <span class="math inline">\(s_{\alpha_i}\)</span>。</p><p>此外设 <span class="math inline">\(V^\ast\)</span> 是 <span class="math inline">\(V\)</span> 的对偶空间，<span class="math inline">\(\langle \cdot,\cdot \rangle\)</span> 是 <span class="math inline">\(V\times V^\ast\to\mathbb{R}\)</span>的自然配对。</p><p>我们来分析当 Cartan 矩阵是半正定，但不是正定时 <span class="math inline">\((W,S)\)</span> 的结构。</p><p>根据 2.6 小节的结论，<span class="math inline">\(\mathrm{rad}{(V)}=\mathbb{R}\delta\)</span>可以由一个向量 <span class="math inline">\(\delta\)</span> 生成，并且<span class="math inline">\(W\)</span> 保持子空间 <span class="math inline">\(\mathbb{R}\delta\)</span> 不变。在 <span class="math inline">\(V/\mathbb{R}\delta\)</span>上诱导的内积是正定的。</p><p>我们知道，<span class="math inline">\(W\)</span> 也作用在 <span class="math inline">\(V^\ast\)</span> 上，这个作用的定义是规定 <span class="math inline">\(W\)</span> 保持双线性对 <span class="math inline">\(\langle \cdot,\cdot \rangle\)</span> 不变： <span class="math display">\[\langle wv,wx \rangle = \langle v, x\rangle.\quad w\in W,v\in V, x\in V^\ast.\]</span> 记 <span class="math display">\[\begin{aligned}H_0&amp;=\{x\in V^\ast\mid \langle\delta,x\rangle=0\},\\H_1&amp;=\{x\in V^\ast\mid \langle\delta,x\rangle=1\}.\end{aligned}\]</span> 则 <span class="math inline">\(H_0\)</span>是线性子空间，<span class="math inline">\(H_1\)</span>是仿射超平面。<span class="math inline">\(W\)</span> 保持 <span class="math inline">\(H_0,H_1\)</span> 不变：因为对任何 <span class="math inline">\(x\in V^\ast\)</span> 都有 <span class="math display">\[\langle\delta,wx\rangle=\langlew^{-1}\delta,x\rangle=\langle\delta,x\rangle.\]</span></p><p>注意到 <span class="math inline">\(H_0\)</span> 与 <span class="math inline">\(V/\mathbb{R}\delta\)</span> 是对偶的，所以它是一个Euclidean空间（通过指定一组对偶基，你可以把一个空间上的度量挪到它的对偶空间上）；<span class="math inline">\(H_1\)</span> 作为 <span class="math inline">\(H_0\)</span> 平移得到的超平面也具有 Euclidean度量。<span class="math inline">\(W\)</span> 同样保持 <span class="math inline">\(H_0\)</span> 和 <span class="math inline">\(H_1\)</span> 上的度量不变。</p><p>所以我们只要在 <span class="math inline">\(V^\ast\)</span>中考虑问题即可。现在的问题变成，已知 <span class="math inline">\(W\leqslant {\rm GL}(V^\ast)\)</span> 保持 <span class="math inline">\(H_0,H_1\)</span> 不变，分析 <span class="math inline">\(W\)</span> 在 <span class="math inline">\(H_1\)</span> 上的作用。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(f: H_1\to H_1\)</span>是映射，如果存在 <span class="math inline">\(T\in {\rmGL}(V^\ast)\)</span> 满足 <span class="math inline">\(f(x + y) - f(x) =T(y)\)</span> 对任何 <span class="math inline">\(x\in H_1,y\inH_0\)</span> 成立，就称 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(H_1\)</span> 上的仿射变换。记 <span class="math inline">\({\bf Aff}(H_1)\)</span> 是 <span class="math inline">\(H_1\)</span> 上所有仿射变换构成的集合，不难验证<span class="math inline">\({\bf Aff}(H_1)\)</span>在映射的复合下构成一个群。</p></div><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span><span class="math inline">\(W\)</span> 在 <span class="math inline">\(H_1\)</span> 上的作用诱导了群同态 <span class="math inline">\(W\to {\bf Aff}(H_1)\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(w\)</span> 在<span class="math inline">\(V^\ast\)</span> 上的作用是线性的，<span class="math inline">\(w(x+y)-w(x)=w(y)\)</span>，所以结论是显然的。<span class="math inline">\(\blacksquare\)</span></p><h1 id="hecke-algebras-and-inverses">7.4 Hecke algebras andinverses</h1><p>这一节引入了 <span class="math inline">\(R\)</span>多项式，并给出了它们满足的递推关系。这部分用对合来处理会比较方便。</p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>对任何 <span class="math inline">\(w\in W\)</span>， <span class="math display">\[q^{l(w)}\,\overline{T_w}=\sum_{x\leqw}(-1)^{l(x)+l(w)}R_{x,w}(q)T_x.\]</span> 其中 <span class="math inline">\(R_{x,w}(q)\in\mathbb{Z}[q]\)</span> 是关于 <span class="math inline">\(q\)</span> 的多项式，满足 <span class="math inline">\(R_{w,w}(q)=1\)</span>。</p></div><p><strong>证明</strong>：由 <span class="math inline">\(q^{l(e)}\,\overline{T_e}=q^0\,\overline{T_e}=T_e\)</span>，结论对<span class="math inline">\(w=e\)</span> 成立。当 <span class="math inline">\(l(w)&gt;0\)</span> 时，设 <span class="math inline">\(w=s_1\cdots s_r\)</span> 是一个既约表示，则 <span class="math display">\[\begin{align}q^{l(w)}\,\overline{T_w}&amp;=q^r\,\overline{T_{s_1\cdots s_r}}\\&amp;=q^r\,\overline{T_{s_1}}\cdots\overline{T_{s_r}}\\&amp;=(qT_{s_1}^{-1})\cdots (qT_{s_r}^{-1})\\&amp;=(T_{s_1}+1-q)\cdots (T_{s_r}+1-q)\\&amp;=\sum_{k=1}^r\sum_{1\leq i_1\leq\cdots\leq i_k\leqr}(1-q)^{r-k}T_{s_{i_1}}\cdots T_{s_{i_k}} + (1-q)^r.\end{align}\]</span> 注意到每个 <span class="math inline">\(T_{s_{i_1}}\cdots T_{s_{i_k}}=T_{s_1\cdotss_k}=T_x\)</span>，<span class="math inline">\(x\)</span> 是 <span class="math inline">\(w\)</span> 的子表达式，所以 <span class="math inline">\(x\leq w\)</span>。合并相同的 <span class="math inline">\(x\)</span> 的系数以后，显然 <span class="math inline">\(T_x\)</span> 的系数在 <span class="math inline">\(\mathbb{Z}[q]\)</span> 中，所以存在 <span class="math inline">\(R_{x,w}\in\mathbb{Z}[q]\)</span> 满足 <span class="math display">\[\sum_{k=1}^r\sum_{1\leq i_1\leq\cdots\leq i_k\leqr}(1-q)^{r-k}T_{s_{i_1}}\cdots T_{s_{i_k}} +(1-q)^r=\sum_{x\leqw}(-1)^{l(x)+l(w)}R_{x,w}(q)T_x.\]</span> 由于 <span class="math inline">\(s_{i_1}\cdots s_{i_k}=w\)</span>只有一种可能，就是 <span class="math inline">\(k=r\)</span> 并且 <span class="math inline">\((i_1,\ldots,i_r)=(1,\ldots,r)\)</span>，所以 <span class="math inline">\(R_{w,w}(q)=1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(s\in S\)</span>，<span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(sw&lt;w\)</span>，则 <span class="math display">\[R_{x,w}(q) = \begin{cases}R_{sx,sw}(q) &amp; \text{if } sx&lt;x,\\qR_{sx,sw}(q)+(q-1)R_{x,sw}(q) &amp; \text{if } x&lt;sx.\end{cases}\]</span></p></div><p><strong>证明</strong>： <span class="math display">\[\begin{aligned}&amp;\qquad\sum_{w\in W}(-1)^{l(x)+l(w)}R_{x,w}(q)T_x =q^{l(w)}\,\overline{T_w}=q^{l(s)+l(sw)}\overline{T_s}\,\overline{T_{sw}}=q\,\overline{T_s}\,q^{l(sw)}\,\overline{T_{sw}}\\&amp;=(T_s +1-q)\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x\\&amp;=\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)(T_sT_x+(1-q)T_x)\\&amp;=(1-q)\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x + \sum_{w\inW}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_sT_x\\&amp;=(1-q)\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x +\sum_{w\inW,\,x&lt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_{sx}\\&amp;\quad +\sum_{w\inW,\,x&gt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)(qT_{sx}+(q-1)T_x)\\&amp;=(1-q)\sum_{w\inW,\,x&lt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x+\sum_{w\inW,\,x&lt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_{sx}\\&amp;\quad+\,q\sum_{w\in W,\,x&gt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_{sx}\\&amp;\overset{y=sx}=(q-1)\sum_{w\inW,\,x&lt;sx}(-1)^{l(w)+l(x)}R_{x,sw}(q)T_x+\sum_{w\in W,\,sy&lt;y}(-1)^{l(sw)+l(sy)}R_{sy,sw}(q)T_y\\&amp;\quad +q\sum_{w\inW,\,sy&gt;y}(-1)^{l(sw)+l(sy)}R_{sy,sw}(q)T_y\\&amp;\overset{y=x}=\sum_{w\inW,\,sx&lt;x}(-1)^{l(w)+l(x)}R_{sx,sw}(q)T_x+\sum_{w\inW,\,sx&gt;x}(-1)^{l(w)+l(x)}\left(qR_{sx,sw}+(q-1)R_{x,sw}\right)T_x.\end{aligned}\]</span> 比较两边 <span class="math inline">\(T_x\)</span>的系数即可得到结论。</p><h1 id="further-properties-of-r-polynomials">7.8 Further properties of<span class="math inline">\(R\)</span>-polynomials</h1><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span><span class="math inline">\(R\)</span>-多项式满足如下性质：</p><ol type="1"><li><span class="math inline">\((-q)^{l(w)-l(x)}\overline{R_{x,w}(q)}=R_{x,w}\)</span>。</li><li><span class="math inline">\(\sum_{x\leq y\leqw}(-1)^{l(x)+l(y)}R_{x,y}(q) R_{y,w}(q)=\delta_{x,w}\)</span>。</li></ol></div><p>1 的证明：对 <span class="math inline">\(w\)</span> 的长度归纳。如果<span class="math inline">\(l(w)=0\)</span> 则 <span class="math inline">\(w=x=e\)</span>，<span class="math inline">\(R_{e,e}=1\)</span>，结论成立。</p><p>设结论对所有长度 <span class="math inline">\(&lt;l(w)\)</span>的元素成立，取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(l(sw)&lt;l(w)\)</span>。考虑两种情况：</p><ul><li><span class="math inline">\(sx &lt; x\)</span>。这时 <span class="math inline">\(R_{x,w}=R_{sx,sw}\)</span>，对 <span class="math inline">\(sw\)</span> 应用归纳假设 <span class="math display">\[(-q)^{l(sw)-l(sx)}\overline{R_{sx,sw}}=R_{sx,sw}=R_{x,w}.\]</span>由于 <span class="math inline">\(l(sw)-l(sx)=l(w)-l(x)\)</span>所以结论对 <span class="math inline">\(w\)</span> 也成立。</li><li><span class="math inline">\(sx&gt;x\)</span>。 <span class="math display">\[\begin{align}(-q)^{l(w) - l(x)} R_{x,w}(q) &amp;= (-1)^{l(w) + l(x)} q^{l(w) - l(x)}R_{x,w}(q^{-1}) \\&amp;= (-1)^{l(w) + l(x)} q^{l(w) - l(x)} \left( q^{-1}R_{sx,sw}(q^{-1}) + (q^{-1} - 1) R_{x,sw}(q^{-1}) \right) \\&amp;= (-1)^{l(w) + l(x)} q^{l(sw) - l(sx)} q^2\left( q^{-1}R_{sx,sw}(q^{-1}) + (q^{-1} - 1) R_{x,sw}(q^{-1}) \right) \\&amp;= q (-1)^{l(sw) + l(sx)} q^{l(sw) - l(sx)} R_{sx,sw}(q^{-1}) \\&amp;\quad - (-1)^{l(sw) + l(x)} q^{l(sw) - l(x)} (1 - q)R_{x,sw}(q^{-1}) \\&amp;= q (-q)^{l(sw) - l(sx)} R_{sx,sw}(q) + (q - 1)(-q)^{l(sw) - l(x)}R_{x,sw}(q) \\&amp;= q R_{sx,sw}(q) + (q - 1) R_{x,sw}(q) \\&amp;= R_{x,w}(q).\end{align}\]</span></li></ul><p>2 的证明：根据 <span class="math inline">\(R\)</span>-多项式的定义，<span class="math display">\[\overline{T_w}=q^{-l(w)}\sum_{y\inW}(-1)^{l(y)+l(w)}R_{y,w}T_y.\]</span> 两边取对合得到 <span class="math display">\[\begin{aligned}T_w&amp;=\overline{q^{-l(w)}\sum_{y\in W}(-1)^{l(y)+l(w)}R_{y,w}T_y}\\&amp;=q^{l(w)}\sum_{y\inW}(-1)^{l(y)+l(w)}\overline{R_{y,w}}\,\overline{T_y}\\&amp;=q^{l(w)}\sum_{y\in W}(-1)^{l(y)+l(w)}q^{l(y)-l(w)}R_{y,w}\cdotq^{-l(y)}\sum_{x\in W}(-1)^{l(x)+l(y)}R_{x,y}T_y\\&amp;=\sum_{x\in W}\left(\sum_{x\leq y\leqw}(-1)^{l(y)+l(x)}R_{x,y}R_{y,w}\right)T_x\end{aligned}\]</span> 比较两边关于 <span class="math inline">\(T_w\)</span> 项的系数即可。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>读书</title>
      <link href="reading/index.html"/>
      <url>reading/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Indra&#39;s pearls 中英双语对照</title>
      <link href="indra/index.html"/>
      <url>indra/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="译者前言">译者前言</h1><p>由于大模型的能力越来越强，现在翻译一本学术著作已经不像之前那么费力。你或许会认为，现在的翻译不过是用软件识别文件结构，然后丢给大模型，等它自动翻译完然后输出结果就完事了。但是如果对翻译质量有追求的话，翻译实际上仍然是一个繁复且高技术含量的工作：你需要反复和模型对话，修正模型的翻译错误，在保持忠于原文的同时尽可能去掉译文腔。</p><p>我选择使用 deepseek-r1进行翻译。这种推理模型用来做翻译是很慢的，但是效果还不错。我不打算 100%翻译全书，仅翻译书中的主要内容。同时，由于几十年来显卡技术的进步，我们可以制作更加精美的插图和动画。我会为书中的一些插图制作交互动画并嵌入在这个网页中。</p><p>本书的翻译完全是我在业余时间完成，所以如果进度不尽人意，请多加谅解。如果你想早些看到完整翻译的话，不妨在打赏页面中给我一点小小的鼓励，让我更有动力肝一波。</p><h1 id="扉页">扉页</h1><figure><img src="/images/indra/inner-cover.jpg" class="fig" width="400" alt="The ancient Buddhist dream of Indra’s Net 佛教古老的因陀罗网想象"><figcaption aria-hidden="true">The ancient Buddhist dream of Indra’s Net佛教古老的因陀罗网想象</figcaption></figure><div class="statement simple plain unnumbered"><p>In the heaven of the great god Indra is said to be a vast andshimmering net, finer than a spider’s web, stretching to the outermostreaches of space. Strung at the each intersection of its diaphanousthreads is a reflecting pearl. Since the net is infinite in extent, thepearls are infinite in number. In the glistening surface of each pearlare reflected all the other pearls, even those in the furthest cornersof the heavens. In each reflection, again are reflected all theinfinitely many other pearls, so that by this process, reflections ofreflections continue without end.</p></div><p>在印度教主神因陀罗的梵天之中，悬有一张璀璨绝伦的珍珠宝网，其纤细更胜蛛丝，绵延至宇宙的终极边际。这轻若云烟的罗网间，每一经纬交汇处皆垂缀明珠，因法界无尽，故明珠无量。每颗宝珠的莹润光华中，俱现十方世界一切珠影，纵使远在梵天极隅之珠亦纤毫毕现。更妙者，珠中所映万千珠影，复现重重无尽珠光，如镜镜相照，光光互摄，遂成华严玄境，映现大千世界之无穷法界。</p><p><strong>Cover picture</strong>: A mathematically generated pictureforetold in the Buddhist myth of Indra’s net? We sometimes call theseKlein Bubbles. The smallest ones are sehr klein.</p><div id="------------" class="statement sta_____ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">封面图片</span>.</span><span class="statement-spah"></span>这幅由数学生成的瑰丽图案，是否暗合了佛教因陀罗网的古老寓言？我们称之为”克莱因泡泡”，其中最小的泡泡在德语中恰被称作“sehr klein”　（“意为极小”）。</p></div><h1 id="前言">前言</h1><h2 id="这是什么类型的书">这是什么类型的书？</h2><div class="statement simple plain unnumbered"><p>This is a book about serious mathematics, but one which we hope willbe enjoyed by as wide an audience as possible. It is the story of ourcomputer aided explorations of a family of unusually symmetrical shapes,which arise when two spiral motions of a very special kind are allowedto interact. These shapes display intricate ‘fractal’ complexity onevery scale from very large to very small. Their visualisation formspart of a century-old dream conceived by the great German geometer FelixKlein. Sometimes the interaction of the two spiral motions is quiteregular and harmonious, sometimes it is total disorder and sometimes andthis is the most intriguing case - it has layer upon layer of structureteetering on the very brink of chaos.</p></div><p>这是一本探讨严谨数学的著作，但我们力求以平易近人的方式呈现给广大读者。本书记录了我们借助计算机探索一系列具有非凡对称性的几何形状的历程，这些形状源于两种特殊螺旋运动的交互。无论观察尺度如何变化，这些形状始终呈现出精妙的分形复杂结构。我们的可视化研究部分地实现了德国几何学大师菲利克斯·克莱因百年前的数学梦想。当两种螺旋运动相互作用时，时而形成和谐有序的图案，时而呈现完全无序的状态，而最引人入胜的当属在秩序与混乱的临界状态，那里层层嵌套着精妙的几何结构。</p><div class="statement simple plain unnumbered"><p>As we progressed in our explorations, the pictures that our computerprograms produced were so striking that we wanted to tell our tale in amanner which could be appreciated beyond the narrow confines of a smallcircle of specialists. You can get a foretaste of their variety bytaking a look at the Road Map on the final page. Mathematicians oftenuse the word ‘beautiful’ in talking about their proofs and ideas, but inthis case our judgment has been confirmed by a number of unbiassed anddefinitely non-mathematical people. The visual beauty of the pictures isa veneer which covers a core of important and elegant mathematicalideas; it has been our aspiration to convey some of this inneraesthetics as well. There is no religion in our book but we were amazedat how our mathematical constructions echoed the ancient Buddhistmetaphor of Indra’s net, spontaneously creating reflections withinreflections, worlds without end.</p></div><p>随着我们探索的深入，计算机程序生成的几何图像呈现出惊人的数学美感，促使我们尝试突破专业领域壁垒，以更科普性的叙事方式呈现研究成果。读者可通过书末的”探索路线图”预览其森罗万象之妙。数学界虽然惯用”美”来评价理论体系，但值得注意的是，本研究的美学价值已获得诸多非数学背景的客观评审者的支持。这些图像的视觉美感如同精密抛光的外壳，包裹着深邃而优雅的数学内核－－我们始终致力于在可视化的同时揭示其内在的数学意蕴。虽然研究本身不涉及宗教议题，但让我们惊叹的是，数学结构通过层层反射自发衍生出无垠的宇宙，这一点竟与佛教中“因陀罗网”的古老隐喻形成跨时空的共鸣。</p><div class="statement simple plain unnumbered"><p>Most mathematics is accessible, as it were, only by crawling througha long tunnel in which you laboriously build up your vocabulary andskills as you abstract your understanding of the world. The mathematicsbehind our pictures, though, turned out not to need too much in the wayof preliminaries. So long as you can handle high school algebra withconfidence, we hope everything we say is understandable. Indeed giventime and patience, you should be able to make programs to create newpictures for yourself. And if not, then browsing through the figuresalone should give a sense of our journey. Our dream is that this bookwill reveal to our readers that mathematics is not alien and remote butjust a very human exploration of the patterns of the world, one whichthrives on play and surprise and beauty.</p></div><p>理解大多数数学领域如同在漫长的知识隧道爬行，需要逐步积累专业术语与解题技巧，同时不断抽象化对世界的认知。然而本书中图像背后的数学理论，实际上并不需要复杂的前置知识。我们相信，只要读者能熟练掌握高中代数基础，就能理解全书内容。实际上如果具备足够的时间与耐心，您甚至可以自主编写程序生成新的数学图像。即便不进行编程实践，单纯浏览书中的可视化成果也能领略研究脉络。我们期待通过这部著作，向读者展现数学并非遥不可及的抽象领域，而是人类探索世界规律的本真方式——这种探索始终根植于游戏性、惊喜感与美感。</p><h2 id="我们是如何开始写它的">我们是如何开始写它的？</h2><div id="david-m----s-story" class="statement sta_david_m__s_story plain unnumbered"><p><span class="statement-heading"><span class="statement-label">DavidM.’s story</span>.</span><span class="statement-spah"> </span>This bookhas been over twenty years in the writing. The project began when BenoitMandelbrot visited Harvard in 1979/80, in the midst of his explorationsof complex iteration - the ‘fractals’ known as Julia sets - and the nowfamous ‘Mandelbrot Set’. He had also looked at some nineteenth centuryfigures produced by infinite repetitions of simple reflections incircles, a prototypical example of which had fascinated Felix Klein.David W. and I pooled our expertise and began to develop these ideasfurther in the Kleinian context. The computer rapidly began producingpictures like the ones you will find throughout the book.</p></div><p><strong>戴维·芒福德（DavidMumford）的故事</strong>。本书的创作跨越二十余载。项目始于 1979-1980年间，贝努瓦·曼德布罗特（Benoit B. Mandelbrot,1924-2010）访问哈佛大学，彼时他正在研究复迭代系统——即著名的朱利亚集（Juliasets）与曼德布罗特集（Mandelbrot Set）。在学术交流中，曼德布罗特特别关注19世纪数学家通过圆反射的无限迭代生成的几何图形，其中一个令菲利克斯·克莱因（FelixKlein,1849-1925）着迷的典型范例，成为我们后续研究的起点。我与合作者大卫·怀特（DavidW.）整合了我们各自的学术专长，开始在克莱因几何理论框架下深化该方向研究。我们很快就使用计算机程序产生出类似你在本书中随处可见的图片。</p><div class="statement simple plain unnumbered"><p>What to do with the pictures? Two thoughts surfaced: the first wasthat they were unpublishable in the standard way. There were notheorems, only very suggestive pictures. They furnished convincingevidence for many conjectures and lures to further exploration, buttheorems were the coin of the realm and the conventions of that daydictated that journals only publish theorems. The second thought wasequally daunting: here was a piece of real mathematics that we couldexplain to our non-mathematical friends. This dangerous temptationprevailed, but it turned out to be much, much more difficult than weimagined.</p></div><p>这些图像能拿来做什么呢？我们面临着双重困境。首先，这些图像无法遵循常规学术途径发表——它们不包含严格定理，仅是一些充满启示的图像。尽管这些图像为许多猜想提供了有力佐证，也为后续研究开辟了探索路径，但在定理至上的学术体系中，当时的期刊规范仅接受严格数学定理的发表。</p><p>第二个挑战更为棘手：这些数学发现具有独特的科普价值，我们可以向非专业的朋友们阐释。我们最终未能抵挡这种极具风险的尝试冲动，然而实际操作中的重重困难，却远超我们最初的预想。</p><div class="statement simple plain unnumbered"><p>We persevered off and on for a decade. One thing held us back:whenever we got together, it was so much more fun to produce morefigures than to write what Dave W. named in his computer TheBook. I havefond memories of traipsing through sub-zero degree gales to thebunker-like supercomputer in Minneapolis to push our calculations stillfurther. The one loyal believer in the project was our ever-faithful andpatient editor, David Tranah. However, things finally took off whenCaroline was recruited a bit more than a decade ago. It took a while tolearn how to write together, not to mention spanning the gulfs betweenour three warring operating systems. But our publisher, our families andour friends told us in the end that enough was enough.</p></div><p>这项研究我们断续推进了十年光景。最大的羁绊在于：每当我们聚在一起时，绘制新图像总比撰写戴夫·W.电脑里那个名为《天书》的文档要有趣的多。我至今犹记在明尼阿波利斯的刺骨寒风中，我们跋涉到堡垒式超级计算机中心，只为将运算推向新的极限。唯一始终如一的守护者，是那位兼具忠诚与耐心的编辑大卫·特拉纳。转机出现在十余年前卡罗琳的加入——我们花了一段时间学会如何协同写作，并克服我们三个相互冲突的操作系统之间的鸿沟。直到最终出版方与亲友们一起告诉我们是时候”见好当收”了。</p><p>You know that ‘word problem’ you hated the most in elementary school?The one about ditch diggers. Ben digs a ditch in 4 hours, Ned in 5 andTed in 6. How long do they take to dig it together? The textbook willtell you 1 hour, 37 minutes and 17 seconds. Baloney! We have uncoveredincontrovertable evidence that the right answer is hours. This is a deepprinciple involving not merely mathematics but sociology, psychology,and economics. We have a remarkable proof of this but even CambridgeUniversity Press’s generous margin allowance is too small to containit.</p><p>还记得小学应用题里最令你抓狂的”挖水沟难题”吗？本挖一条沟需要 4小时，内德要 5 小时，泰德要 6小时，三人合力需要多久完工？教科书会告诉你标准答案是 1 小时 37 分 17秒——纯属扯淡！我们通过实践获得铁证：真实耗时应为 4 + 5 + 6 = 15小时。这背后暗含深刻的原理，不仅涉及数学，还涉及社会学、心理学和经济学。我们对此有一个精彩的证明，可惜即便剑桥大学出版社预留了慷慨的页边距，依然无法容下它。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>Since then, the pioneering team of Klaus and Alice Peters havestarted the journal Experimental Mathematics.</p><p>自那时起，Klaus 和 Alice Peters的先锋团队创办了《实验数学》期刊。</p></div><h1 id="the-glowing-gasket">7 The glowing gasket</h1><div class="statement simple plain unnumbered"><p>The lacy web in Figure 7.1 is called the Apollonian gasket. Usually,it is constructed by a simple geometric procedure, dating back to thosemost famous of geometers, the ancient Greeks. We shall start byexplaining the traditional construction, but as we shall discloseshortly, the gasket also represents another remarkable way in which theSchottky dust can congeal. The pictures you see here were actually alldrawn using a refinement of the DFS algorithm for tangent Schottkycircles.</p></div><p>图 7.1中的镂空结构被称为阿波罗尼奥斯分形。其构造基于一种简单的几何方法，可追溯至古希腊著名的几何学家。我们将首先解释传统构造方法，但稍后也会揭示这个分形结构还展现了肖特基尘埃凝聚的另一种独特方式。本章所有图示均采用改进版DFS 算法绘制，该算法专门用于处理相切肖特基圆的情形。</p><div class="statement simple plain unnumbered"><p>The starting point of the traditional construction is a chain ofthree non-overlapping disks, each tangent to both of the others. Aregion between three tangent disks is a ‘triangle’ with circular arcsfor sides. This shape is often called an ideal triangle: the sides aretangent at each of the three vertices so the angle between them is zerodegrees.</p><p>The gasket is activated by the fact that in the middle of each idealtriangle there is always a unique ‘inscribed disk’ or incircle, tangentto the three outer circles. It is really better to think of the gasketas a construction on the sphere. Insides and outsides don’t matter anymore, so we may as well start with any three mutually tangent circles.You can see lots of disks and incircles in Figure 7.2.</p></div><p>传统构造法的起点是三个互不重叠的圆盘呈链状排列，每个圆盘都与另外两个相切。三个相切圆盘之间的区域形成以圆弧为边的”三角形”，这种几何形状被称为理想三角形：其三条边在顶点处相切，因此相邻边夹角为零。</p><p>该垫片的原理基于如下的几何事实：每个理想三角形中心处必存在唯一的内切圆，同时与外部的三个圆相切。更恰当的视角是将该结构置于球面之上进行考察，此时内外之分不复存在，因此初始构造只需选取任意三个两两相切的圆即可。读者可参见图7.2，其中展示了大量圆盘及其内切圆结构。</p><div class="statement simple plain unnumbered"><p>In the figure, we show two initial configurations of three tangentblue disks. When you take out the three blue disks you are left with twored ideal triangles. Each red ideal triangle has a yellow incircle. Seehow each yellow incircle divides the red triangle into three moretriangles.</p></div><p>在图中，我们展示了三个相切的蓝色圆盘的两种初始排布。当你移除这三个蓝色圆盘后，会留下两个红色的理想三角形。每个红色理想三角形各含一个黄色内切圆。仔细观察这些黄色的内切圆如何将红色三角形进一步分割为三个子三角形。</p><div class="statement simple plain unnumbered"><p>For repetitive people (a necessary quality in this subject, you mightsay), it is only natural to draw the incircles in these new triangles,resulting, of course, in even more triangles of the same kind. Thebottom frame shows this subdivision carried out twice more, with greenand then even smaller purple disks. In The Cat in the Hat Comes Back,’the cat takes off his hat to reveal Little Cat, who then removes his hatand releases Little Cat, who then uncovers Little Cat, and so on. Nowimagine there are not one but three new cats inside each cat’s hat. Thatgives a good impression of the explosive proliferation of these tinyideal triangles. Carry out this process to infinity, and Voom, theApollonian Gasket appears.</p></div><p>对于执着的研究者（可说是本领域必备素质），在新三角形中继续绘制内切圆是再自然不过的事了，这自然会产生更多同类三角形。下图展示了该细分过程再执行两次的结果：先出现绿色圆盘，继而产生更小的紫色圆盘。正如《戴帽子的猫又来了》中的场景——大猫摘帽露出小猫，小猫摘帽又露出更小的小猫，如此无限延续。现在设想每顶帽子里有三只而非一只小猫，就能理解这些微型理想三角形如何爆发式增长。当此过程无限继续时，砰的一声，阿波罗尼奥斯分形便瞬间显现。</p><div class="statement simple plain unnumbered"><p>The Apollonian gasket is indeed very pretty, but the reason forintroducing it here is that, remarkably, it is also the limit set of aSchottky group made by pairing tangent circles. Exactly the sameintricate mathematical object can created by completely different means!You can see better how this works in the beautiful glowing version inFigure 7.3. The solid red circles in this picture are the initialSchottky circles in a very special configuration which we will look atclosely in the next section. The glowing yellow limit set can berecognized as the same as the Apollonian gasket of Figure 7.1. Thepicture was made by pairing four tangent circles arranged in theconfiguration shown in Figure 7.4. The four circles are tangent not onlyin a chain; there are also extra tangencies between <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span>, and between <span class="math inline">\(C_b\)</span> and <span class="math inline">\(C_B\)</span>.</p></div><p>阿波罗尼奥斯分形确实非常美丽，但在此介绍它的原因在于：它竟然也是由配对相切圆构成的肖特基群的极限集。完全相同的复杂数学对象，竟能通过截然不同的方法生成！通过图7.3的发光图示，可以更清晰地理解这一机制。图中的红色实心圆是以特殊构型排列的初始肖特基圆（我们将在下节详细分析），其发光黄色极限集与图7.1的阿波罗尼奥斯分形完全一致。该图像通过配对四个相切圆生成（排列方式见图7.4），这些圆不仅形成链式相切，在<span class="math inline">\(C_a\)</span> ​与 <span class="math inline">\(C_A\)</span>、<span class="math inline">\(C_b\)</span> ​与 <span class="math inline">\(C_B\)</span> ​之间还存在额外切点。</p><div class="statement simple plain unnumbered"><p>As you iterate the pairing transformations <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, the extra tangency proliferates, withthe effect that inside each disk <span class="math inline">\(D\)</span>you see three further Schottky disks tangent to <span class="math inline">\(D\)</span> and each of the other two. In ourversion, the circles have been coloured depending on their level,starting with red at the first or lowest level, gradually changing toyellow, green and then blue. The small yellow and blue circles pile up,highlighting the limit set with a mysterious glow.</p></div><p>当你迭代执行配对变换 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>时，额外切点将呈指数增长，其结果是：在每一个圆盘 <span class="math inline">\(D\)</span>内部，都会新生成三个肖特基子圆盘，这些子圆盘不仅与 <span class="math inline">\(D\)</span>相切，彼此之间也相切。在我们的可视化模型中，圆盘按迭代层级着色——从第一层（最底层）的红色开始，渐次过渡为黄、绿、蓝三色。随着黄蓝两色的小圆盘层层堆叠，极限集逐渐被神秘辉光勾勒显现。</p><div class="statement simple plain unnumbered"><p>In this chapter, we shall be exploring various features of thegasket. Notwithstanding the extra tangency, it turns out that each limitpoint is still associated to exactly one or two infinite words in thegenerators <span class="math inline">\(a,b,A\)</span> and <span class="math inline">\(B\)</span>. You will be able to make your ownversion of the glowing gasket by running our DFS algorithm for the groupgenerated.</p></div><p>在本章中，我们将深入探究这一垫片结构的诸多特性。尽管存在额外的相切条件，但事实证明，每个极限点仍然对应于生成元<span class="math inline">\(a,b,A,B\)</span>所构成的一个或者两个无限词。通过运行我们特别设计的深度优先搜索（DFS）算法，您将能亲手构建出自己专属的的发光垫片。</p><div class="statement simple plain unnumbered"><p>Figure 7.2. Activating the gasket. On the top left, the three largestdisks which activate the gasket are shown in blue. One of the threedisks appears as the outer blue region which frames the picture, becauseit contains the point <span class="math inline">\(\infty\)</span>, theNorth Pole on the Riemann sphere. On the top right, two of the disks aretangent at <span class="math inline">\(\infty\)</span>, so that you seethem in the picture as parallel blue strips. Removing the blue circlesleaves two red ideal triangles. Inside each ideal triangle is anincircle, coloured yellow. Below, we see more levels of incircles.</p><p><img src="/images/indra/fig-7.2.jpg" class="fig" width="400"></p><p>图 7.2激活垫片。左上角，激活垫片的三个最大圆盘以蓝色显示。其中一个圆盘作为蓝色外框环绕整个图示，因为它包含黎曼球面上的北极点<span class="math inline">\(\infty\)</span>。右上角两个圆盘在无穷远点<span class="math inline">\(\infty\)</span>相切，因此在图中呈现为平行蓝色条纹。移除蓝色圆盘后，剩余区域形成两个红色理想三角形，每个三角形内都有一个黄色内切圆。下方展示了更多层级的内切圆。</p></div><h2 id="generating-the-gasket-生成垫片">Generating the gasket生成垫片</h2><div class="statement simple plain unnumbered"><p>The configuration of tangent circles which produced the gasket isshown in the right frame of Figure 7.4. The picture has been arranged sothat <span class="math inline">\(C_a\)</span> goes through <span class="math inline">\(\infty\)</span>, hence it appears in the figure asa straight line. In addition, <span class="math inline">\(C_A\)</span>and <span class="math inline">\(C_a\)</span> are tangent at 0 and <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> are tangent at <span class="math inline">\(-i\)</span>. You can see how this picture is madeby creating extra tangencies among a kissing chain of four circles bycomparing with the nearby arrangement of four circles in the left handframe.</p></div><p>生成垫片的相切圆配置如图 7.4 右图所示。图中特意令圆 <span class="math inline">\(C_a\)</span> 经过 <span class="math inline">\(\infty\)</span>，从而它在图中呈现为一条直线。此外，我们令圆<span class="math inline">\(C_A\)</span> 与 <span class="math inline">\(C_a\)</span> 在原点 0 处相切，圆 <span class="math inline">\(C_B\)</span> 与 <span class="math inline">\(C_b\)</span> 在<span class="math inline">\(-i\)</span>处相切。通过与左边图中四个圆的排列进行对比，可以清晰观察到右图通过在四圆相切链中引入额外切点形成的特殊结构。</p><div class="statement simple plain unnumbered"><p><img src="/images/indra/fig-7.4.jpg" id="fig-7.4" class="fig" width="600"></p><p>Figure 7.4. The right frame shows the starting configuration oftangent Schottky circles which produces the glowing gasket. The redcircles <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span> are paired by the transformation<span class="math inline">\(a\)</span> and the blue circles <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> by <span class="math inline">\(b\)</span>. Using notation from the last chapter,the tangency points <span class="math inline">\(P,Q,R\)</span> and <span class="math inline">\(S\)</span> are at <span class="math inline">\(1,-1,-0.2-0.4i\)</span> and <span class="math inline">\(0.2-0.4i\)</span> respectively. On the left is anearby Schottky configuration of circles which are not quite tangent and<span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are loxodromic. This is similar to theconfiguration shown in frame (vi) of Figure 6.10. The centre frame is anintermediate stage where <span class="math inline">\(a\)</span> isparabolic but <span class="math inline">\(b\)</span> is not.</p><p>图 7.4. 右图展示了生成发光垫片的相切 Schottky 圆的初始配置。红色圆<span class="math inline">\(C_a\)</span> ​与 <span class="math inline">\(C_A\)</span> ​通过变换 <span class="math inline">\(a\)</span> 配对，蓝色圆 <span class="math inline">\(C_B\)</span> 与 <span class="math inline">\(C_b\)</span> 通过变换 <span class="math inline">\(b\)</span> 配对。依照前一章的记号，切点 <span class="math inline">\(P,Q,R,S\)</span> 分别位于坐标 <span class="math inline">\(1,−1,−0.2−0.4i\)</span> 和 <span class="math inline">\(0.2−0.4i\)</span>处。左图展示了一个稍微不同的不相切的 Schottky 圆配置，此时变换 <span class="math inline">\(a\)</span> 与 <span class="math inline">\(b\)</span> 都是斜航的。此配置与图 6.10 (vi)所示的结构相似。中间的图呈现过渡状态：变换 <span class="math inline">\(a\)</span> 是抛物的而 <span class="math inline">\(b\)</span> 不是。</p></div><div class="statement simple plain unnumbered"><p>The generating matrices for the gasket are quite simple: <span class="math display">\[a=\begin{pmatrix}1&amp;0\\-2i&amp;1\end{pmatrix}\quad\text{and}\quadb=\begin{pmatrix}1-i&amp;1\\1&amp;1+i\end{pmatrix}.\]</span></p><p>We shall have more to say about how we arrived at these particularformulas later on. Note that <span class="math inline">\(\mathop{\mathrm{Tr}}{a}=\mathop{\mathrm{Tr}}{b}=2\)</span>,so <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> are parabolic. Looking at thearrangement of Schottky circles in Figure 7.4, you see the fixed pointof <span class="math inline">\(a\)</span> is 0, the tangency point ofthe circles <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span>. In Figure 7.3, you can see twochains of tangent circles nesting down on 0 from above and below. Thesame phenomenon occurs at <span class="math inline">\(-i\)</span>, thetangency point of <span class="math inline">\(C_B\)</span> and <span class="math inline">\(C_b\)</span> and the fixed point of <span class="math inline">\(b\)</span>. Notwithstanding extra tangencies, thegenerators <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span> still pair opposite circles in theinitial tangent chain <span class="math inline">\(C_a,C_b,C_A\)</span>and <span class="math inline">\(C_B\)</span>. This means that fornesting circles we still need the commutator condition <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB}=2\)</span>, which isnot hard to check.</p></div><p>生成该垫片的矩阵非常简单：</p><p><span class="math display">\[a=\begin{pmatrix}1&amp;0\\-2i&amp;1\end{pmatrix}\quad\text{and}\quadb=\begin{pmatrix}1-i&amp;1\\1&amp;1+i\end{pmatrix}.\]</span></p><p>我们稍后将详细说明如何得出这些特定的公式。注意 <span class="math inline">\(\mathop{\mathrm{Tr}}{a}=\mathop{\mathrm{Tr}}{b}=2\)</span>，因此<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 均为抛物型变换。观察 <a href="#fig-7.4">图 7.4</a> 中 Schottky 圆的排列，你会发现 <span class="math inline">\(a\)</span> 的不动点是 0，即圆 <span class="math inline">\(C_a\)</span> ​与 <span class="math inline">\(C_A\)</span> ​的切点。在图 7.3中，你可以看到两条相切圆的链分别从上下两侧向 0点嵌套收敛。同样的现象也发生在 <span class="math inline">\(−i\)</span>处，即 <span class="math inline">\(C_b\)</span> ​与 <span class="math inline">\(C_B\)</span> ​的切点，也是 <span class="math inline">\(b\)</span> 的不动点。尽管存在额外的切点，生成元<span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 仍然将初始的相切链 <span class="math inline">\(C_a,C_b,C_A,C_B\)</span>​中的圆两两配对。这意味着要实现圆链嵌套，我们仍然需要交换子条件 <span class="math inline">\(\mathop{\mathrm{Tr}}{abAB}=-2\)</span>，这一点不难验证。</p><div class="statement simple plain unnumbered"><p>We have been speaking as if there is only one Apollonian gasket, butcould we not get different gaskets by starting with different tangentchains? Not really, because it turns out that any chain of three tangentcircles can be conjugated to any other three. As you can work out inProject 7.1, this stems from the fact that there is always a Möbius mapcarrying any three points to any other three. Since the gasket isactivated by its initial ideal triangle, and since the procedure at eachstep consists in adding incircles, a Möbius map which conjugates oneideal triangle to another carries the whole gasket along in itswake.</p><p>This explains why it makes sense to talk about the Apollonian gasket,because up to conjugation by Möbius maps there is really only one.</p></div><p>我们的讨论似乎一直都假定了阿波罗尼奥斯垫片是唯一的，但如果我们从不同的相切圆链开始，难道不能得到不同的垫片吗？当然不是。实际上，任意三个相切圆构成的初始链都可以共轭到其它任何三个。正如你在项目7.1中推导的那样，这源于一个事实：总存在一个莫比乌斯变换，可以将任意三点映射到任何其他三个点。由于垫片是由其初始理想三角形激活的，并且每一步都是添加内切圆，因此将某个理想三角形共轭到另一个理想三角形的莫比乌斯变换，必将整个垫片结构同步地变换过去。</p><p>这就解释了为什么我们可以谈论“阿波罗尼奥斯垫片”，因为在莫比乌斯变换的共轭变换下，实际上只有一个垫片。</p><div id="pinching-tiles" class="statement sta_pinching_tiles plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Pinching tiles</span>.</span><span class="statement-spah"> </span>Figure 7.6 is a wonderful picture of whathappened when we introduced Dr.&nbsp;Stickler to Apollonius! It is a prettyintricate arrangement, so let’s take a bit of time understanding whathas happened to the tiles. To get a grasp on the situation, look back atthe three pictures in Figure 7.4, and watch the progression across thethree frames. On the left the limit set is a loop or quasicircle, so theordinary set - what is left when you take away the limit set - has twoparts, a pink inside and a white outside. In the central picture, thepink part has collapsed into a myriad of tangent disks, and the redSchottky circles <span class="math inline">\(C_a\)</span> and <span class="math inline">\(C_A\)</span> touch at 0. On the right, the gasketgroup, the ‘horns’ of the pink region have also come together, causingthe white outside to fracture into disks as well. Notice how the memoryof which was inside and which was outside still persists, because whatwere the ‘inside’ disks are pink while the ‘outside’ ones are white.</p></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Shadertoy 学习</title>
      <link href="learn-shadertoy/index.html"/>
      <url>learn-shadertoy/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter groups, automata and uniform tilings</title>
      <link href="uniform-tilings/index.html"/>
      <url>uniform-tilings/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Since using POV-Ray to render 3D hyperbolic honeycombs was incrediblyslow, I’ve decided to abandon this approach and have removed the codefrom the main branch on GitHub. You can find the code used in thisarticle in the <a href="https://github.com/neozhaoliang/pywonderland/releases/tag/0.1.0">oldrelease version</a>. For how to render hyperbolic honeycombs, readerscan refer to <a href="https://github.com/neozhaoliang/Hyperbolic-Honeycombs/">anotherproject</a>.</p></blockquote><p>This article introduces a <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/uniform-tilings">Pythonprogram</a> I just finished. Although it’s freshly completed, it took upmost of my free time over the last six months. It was quite thechallenge, requiring a lot of effort and dedication. The main reason isthat it involves a few complicated theories, specifically the deepproperties of Coxeter groups, known as the automatic property. Asignificant portion of these months was spent learning from articles byCasselman, Brink &amp; Howlett, and others, which helped me understandthe mathematicas of this project (see references at the end).</p><p>Although finishing this program is a great achievement for me, Idon’t mean to boast about any superiority of this program: thecomputational method it uses for Coxeter groups is not advanced andmight not impress the experts. Moreover, its code is somewhat ugly, andlikely difficult for other people to use.</p><p>The purpose of this program is to use group theory to draw varioustwo-dimensional and three-dimensional <a href="https://en.wikipedia.org/wiki/Uniform_tiling">uniform tilings</a>.You can think of uniform tiling as using some regular polygons to tilethe space so that the vertices of the tiles are transitive under theaction of a symmetry group (forming a single orbit).</p><p>I will first show some examples of what this program can do, and thenexplain how it works.</p><h1 id="examples">Examples</h1><ul><li><p>Below is the 2d Euclidean tiling omnitruncated (4, 2, 4):</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-4-2-4.png" width="600"></p></li><li><p>Below is the 2d hyperbolic tiling regular (2, 3, 13) inPoincaré’s disk model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/2-3-13.png" width="600"></p></li><li><p>Below is the 2d hyperbolic tiling omnitruncated (4, 3, 3) inupper half plane model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/uhp-4-3-3.png" width="600"></p></li><li><p>A hyperbolic weave pattern:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/weave_pattern.png" width="500"></p></li><li><p>Below is the 3d hyperbolic tiling regular (3, 5, 3) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/3-5-3.png" width="600"></p></li><li><p>Below is the 3d hyperbolic tiling regular (5, 3, 5) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/5-3-5.png" width="600"></p></li><li><p>Below is the 3d hyperbolic tiling regular (5, 3, 4) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/5-3-4.png" width="600"></p></li><li><p>Below is the 3d hyperbolic tiling regular (4, 3, 5) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/4-3-5.png" width="600"></p></li><li><p>The above four regular tilings are the only regular ones withcompact cells. If we drop the restriction on compactness and requiresthe cells must have finite volume, then we have ten more regulartilings, with each has a Euclidean vertex configure. For example (6, 3,3)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/6-3-3.png" width="600"></p><p>You can see the cells have ideal vertices, i.e.&nbsp;vertices at theinfinity. These tilings are called “paracompact”.</p></li><li><p>If we drop the restriction on being “regular” then we have lotsmore examples, like rectified (3, 5, 3) and rectified (5, 3, 4)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/rectified-3-5-3.png" width="600"></p><p><img style="margin:0px auto;display:block" src="/images/coxeter/rectified-5-3-4.png" width="600"></p><p>and the <a href="https://en.wikipedia.org/wiki/Uniform_honeycombs_in_hyperbolic_space#%5B5,31,1%5D_family">canticorder-5 cubic</a> tiling from the [5, 3<sup>1,1</sup>] family:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/cantic-order-5-cubic.png" width="600"></p></li><li><p>Below is a 2d spherical tiling rendered in 3d:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-5-2-3.png" width="600"></p></li><li><p>Finally a shader program exported from Matt Zucker’s excellentwork on <a href="https://www.shadertoy.com/view/3tsSzM">shadertoy</a>:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/wythoff_shader.png" width="600"></p></li></ul><h1 id="wythoff-construction">Wythoff construction</h1><p>The main theoretical tool for drawing uniform tilings is theso-called <a href="https://en.wikipedia.org/wiki/Wythoff_construction">Wythoffconstruction</a>, also known as the kaleidoscope method. This involvesplacing several reflecting planes (mirrors) in space, then starting froman initial point, and repeatedly applying reflection transformationsabout these mirrors to obtain all the virtual images, which gives allthe vertices of the tiling.</p><p>The following video demonstrates the effect of the Wythoffconstruction: in the 2D Poincaré hyperbolic disk, the walls around theroom are all mirrors. The scene in the room is repeatedly reflected inthe mirrors, creating infinitely many virtual image rooms, filling theentire hyperbolic space. Note that, there is only one ‘real’ room,namely the room where the observer is standing in; all other rooms arevirtual images of the real one.</p><video src="/images/hyperbolic-honeycombs/lego-hyperbolic-kaleido.mp4" width="600" controls=""></video><p>There are two different approaches to implemente the Wythoffconstruction in a program:</p><ol type="1"><li><p>Inverse Pixel Method. This method involves calculating, for eachpixel in the image, its corresponding point <span class="math inline">\(p\)</span> in the world space. Then, <span class="math inline">\(p\)</span> is repeatedly reflected off mirrorsuntil it falls within the fundamental region, say the final location is<span class="math inline">\(q\)</span>. Essentially, we find thepre-image <span class="math inline">\(q\)</span> of <span class="math inline">\(p\)</span> in the real room (called thefundamental domain). Then, based on <span class="math inline">\(q\)</span>’s position within the fundamentaldomain, the pixel corresponding to <span class="math inline">\(p\)</span> is colored. This method allows forparallel computation on all pixels, and when combined with shaderprogramming, it can produce very stunning effects. Here are two examplesfrom shadertoy:</p><p><iframe width="480" height="270" frameborder="0" src="https://www.shadertoy.com/embed/mlGfzV?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe></p><p><iframe width="480" height="270" frameborder="0" src="https://www.shadertoy.com/embed/Nd3cR2?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe></p><p>The inverse pixel method cares solely about the final pixel color. Itdoesn’t care about the actual coordinates. It produces raster images andcannot output vector graphics. Moreover, exporting data for use inmodeling software is not very convenient with this method.</p></li><li><p>Coordinate Method. This approach starts from a given initialpoint <span class="math inline">\(v_0\)</span> and calculates all itsvirtual images (within some maximum number of vertices) as well as theconnections between edges and faces, then draws them one by one. Thismethod allows for the acquisition of specific vertex coordinateinformation and outputs vector graphics and model files, making it moresuitable for usage in academic papers. However, it cannot beparallelized and is quite slow in computing hyperbolic tilings, as thestructures grows exponentially.</p></li></ol><p>My program uses the coordinate method. It first performs symboliccalculations within the symmetry group of the tiling to determine theword representation corresponding to each vertex in the shortestlexicographical order (a word is a tuple where each element is aninteger), as well as the connections between edges and faces (alsotuples of integers), and then applies the word corresponding to eachvertex to the initial vertex to obtain the floating-point coordinates ofthat vertex. In other words, before computing the final coordinates ofeach vertex, it has already pre-calculated how many vertices there are,how each vertex is obtained through reflections from the initial vertex,which vertices form edges, which form faces, which form cells, etc.These calculations involve only integer operations, completely avoidingissues with floating-point precision loss.</p><p>Sounds amazing? Let me demonstrate the specific steps with anexample.</p><h1 id="example-omnitruncated-7-2-3-tiling">Example: omnitruncated (7,2, 3) tiling</h1><p>The Coxeter-Dynkin diagram for the omnitruncated (7, 2, 3) tilingis:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/coxeter723.svg" width="250"></p><p>This is a hyperbolic tiling, its symmetry group <span class="math inline">\(G\)</span> is the Coxeter group determined byCoxeter matrix</p><p><span class="math display">\[M=\begin{pmatrix} 1 &amp; 7 &amp; 2 \\ 7&amp;1 &amp;3\\ 2 &amp; 3 &amp;1\end{pmatrix}\]</span></p><p>and has presentation</p><p><span class="math display">\[W = \langle s_0,s_1, s_2\ |\s_0^2=s_1^2=s_2^2=(s_0s_1)^7=(s_1s_2)^3=(s_0s_2)^2=1\rangle.\]</span></p><p>The initial vertex <span class="math inline">\(v_0\)</span> is not onany of the three mirrors, so its stabilizing subgroup is <span class="math inline">\(\langle 1\rangle\)</span>, by <a href="https://en.wikipedia.org/wiki/Group_action_(mathematics)#Orbit-stabilizer_theorem">orbit-stabilizertheorem</a> each element <span class="math inline">\(w\)</span> of <span class="math inline">\(W\)</span> maps <span class="math inline">\(v_0\)</span> to a distinct vertex in thetiling.</p><p>Every element <span class="math inline">\(w\)</span> in <span class="math inline">\(W\)</span> can be expressed as a product of thegenerators <span class="math inline">\(s_0,s_1,s_2\)</span>. We call anysuch expression a word representation of <span class="math inline">\(w\)</span>. If <span class="math inline">\(w=s_{i_1}s_{i_2}\cdots s_{i_k}\)</span> is a wordexpression, and there are no other expressions of <span class="math inline">\(w\)</span> with length less than <span class="math inline">\(k\)</span>, we call <span class="math inline">\(s_{i_1}s_{i_2}\cdots s_{i_k}\)</span> a reducedexpression, and define <span class="math inline">\(l(w)=k\)</span> to bethe length of <span class="math inline">\(w\)</span>. The reducedexpression of <span class="math inline">\(w\)</span> is generally notunique. For example, from the defining relations of <span class="math inline">\(W\)</span>, we can see that <span class="math inline">\(s_0s_2=s_2s_0\)</span> and <span class="math inline">\(s_1s_2s_1=s_2s_1s_2\)</span>, etc. However, allreduced expressions of <span class="math inline">\(w\)</span> must havethe same length, so the definition of <span class="math inline">\(l(w)\)</span> is reasonable.</p><p>We can choose a smallest one among all reduced expressions <span class="math inline">\(w\)</span> as the normal form of <span class="math inline">\(w\)</span>. This sorting is called shortlex order.As the name implies, shortlex order is the order used by dictionaries toarrange words.</p><p>First, define the alphabetical order of the generators <span class="math inline">\(s_0,s_1,s_2\)</span> as <span class="math inline">\(s_0&lt;s_1&lt;s_2\)</span>​, then extend this orderto any two reduced expression <span class="math inline">\(w_1\)</span>and <span class="math inline">\(w_2\)</span>:</p><blockquote><p><strong>Shortlex Order</strong>: Let <span class="math inline">\(w_1= s_{i_1}s_{i_2}\ldots s_{i_n}\)</span> and <span class="math inline">\(w_2=s_{j_1}s_{j_2}\cdots s_{j_m}\)</span> be twodifferent reduced expressions, where <span class="math inline">\(w_1,w_2\)</span> can be different group elements. The relationship betweenthem in shortlex order is determined as follows:</p><ol type="1"><li>First, compare the lengths. If the lengths are different, the onewith the shorter length is considered smaller, that is, if <span class="math inline">\(n &lt; m\)</span> then <span class="math inline">\(w_1 &lt; w_2\)</span>, conversely if <span class="math inline">\(n &gt; m\)</span> then <span class="math inline">\(w_1 &gt; w_2\)</span>.</li><li>If the lengths are the same, then compare the alphabetical orderfrom left to right. Let <span class="math inline">\(k\)</span> be thefirst index such that for any <span class="math inline">\(l &lt;k\)</span>, <span class="math inline">\(s_{i_l} = s_{j_l}\)</span> but<span class="math inline">\(s_{i_k} \ne s_{j_k}\)</span>, then therelationship between <span class="math inline">\(w_1, w_2\)</span> isthe same as the relationship between <span class="math inline">\(s_{i_k}\)</span> and <span class="math inline">\(s_{j_k}\)</span>.</li></ol></blockquote><p>Thus, every <span class="math inline">\(w\in W\)</span> has a uniquenormal form under shortlex order.</p><p>Define <span class="math inline">\(\mathcal{SL}(W)\)</span> as theset consisting of the normal forms of all elements in <span class="math inline">\(W\)</span>. Below is a list of all elements in<span class="math inline">\(\mathcal{SL}(W)\)</span> with lengths up to5, totaling 37: (arranged in rows from smallest to largest)</p><p><span class="math display">\[\begin{array}{lllll}e&amp;s_{0}&amp;s_{1}&amp;s_{2}&amp;s_{0}s_{1}\\s_{0}s_{2}&amp;s_{1}s_{0}&amp;s_{1}s_{2}&amp;s_{2}s_{1}&amp;s_{0}s_{1}s_{0}\\s_{0}s_{1}s_{2}&amp;s_{0}s_{2}s_{1}&amp;s_{1}s_{0}s_{1}&amp;s_{1}s_{0}s_{2}&amp;s_{1}s_{2}s_{1}\\s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{1}&amp;s_{0}s_{1}s_{0}s_{2}&amp;s_{0}s_{1}s_{2}s_{1}&amp;s_{0}s_{2}s_{1}s_{0}\\s_{1}s_{0}s_{1}s_{0}&amp;s_{1}s_{0}s_{1}s_{2}&amp;s_{1}s_{0}s_{2}s_{1}&amp;s_{1}s_{2}s_{1}s_{0}&amp;s_{2}s_{1}s_{0}s_{1}\\s_{0}s_{1}s_{0}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{1}s_{2}&amp;s_{0}s_{1}s_{0}s_{2}s_{1}&amp;s_{0}s_{1}s_{2}s_{1}s_{0}&amp;s_{0}s_{2}s_{1}s_{0}s_{1}\\s_{1}s_{0}s_{1}s_{0}s_{1}&amp;s_{1}s_{0}s_{1}s_{0}s_{2}&amp;s_{1}s_{0}s_{1}s_{2}s_{1}&amp;s_{1}s_{0}s_{2}s_{1}s_{0}&amp;s_{1}s_{2}s_{1}s_{0}s_{1}\\s_{2}s_{1}s_{0}s_{1}s_{0}&amp;s_{2}s_{1}s_{0}s_{1}s_{2}&amp;\end{array}\]</span></p><p>Note the number of all words in <span class="math inline">\(s_0,s_1,s_2\)</span> with length less or equalthan five is <span class="math inline">\(1+3+\cdots+3^5=364\)</span>,the list above tells us that they indeed contain only 37 different ones,the remaining 364 - 37 = 327 ones are duplicates. A further computationshows that the number of all words with length no more than six is 1093but they contain only 53 different elements. So we can gain a greatimprovement in efficiency if we only use words in <span class="math inline">\(\mathcal{SL}(W)\)</span> instead of traversing allpossible combinations of the generators.</p><p>How can we generate those words that are precisely in <span class="math inline">\(\mathcal{SL}(W)\)</span>? This leads us to a veryimportant theorem on Coxeter groups:</p><blockquote><p><strong>Theorem [Brigitte Brink &amp; Robert B. Howlett,1993]</strong>: If <span class="math inline">\(G\)</span> is a finitelygenerated Coxeter group then <span class="math inline">\(\mathcal{SL}(W)\)</span> is a regularlanguage.</p></blockquote><p>The term “regular language” comes from computer science, a basic factabout a regular language over a finite alphabetical set is that thislanguage can always be recognized by a definite finite automaton (DFA),such DFA may not be unique but there is a “minimal one” with the leastnumber of states and this minimal one is unique if we don’t distinctrelabellings of the states.</p><p>Below is the automaton recognizes <span class="math inline">\(\mathcal{SL}(W)\)</span> for the (7, 2, 3)group:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/dfa_723.svg" width="600"></p><p>You can see there are 19 nodes (i.e.&nbsp;states) in the automaton. Thelabels of the states are irrevalent because renumbering the states of anautomaton does not change the language it recognizes.</p><p>The red node is the initial state.</p><p>The directed edges in the graph tell us the transition rule betweenthe states. The edges are labelled by the generators of the group,i.e.&nbsp;<span class="math inline">\(i\)</span> for <span class="math inline">\(s_i\)</span>. If we start from the initial stateand keep on moving to a next state along an edge up to a finite numberof steps, then the path we travelled gives a word in <span class="math inline">\(\mathcal{SL}(W)\)</span>. All words in <span class="math inline">\(\mathcal{SL}(W)\)</span> can be generated in thisway.</p><p>For example:</p><ol type="1"><li>The only path of length 0 correspondes to the identidy 1.</li><li>The three paths of length 1 <span class="math display">\[\begin{align*}0&amp;\xrightarrow{\ s_0\ }1,\\0&amp;\xrightarrow{\ s_1\ }2,\\0&amp;\xrightarrow{\ s_2\ }8.\end{align*}\]</span> corresponde to the three generators <span class="math inline">\(s_0,s_1,s_2\)</span> in <span class="math inline">\(\mathcal{SL}(W)\)</span>.</li><li>The five paths <span class="math display">\[\begin{align*}0&amp;\xrightarrow{\ s_0\}1\xrightarrow{\ s_1\ }2\\0&amp;\xrightarrow{\ s_0\ }1\xrightarrow{\ s_2\ }8\\0&amp;\xrightarrow{\ s_1\ }2\xrightarrow{\ s_0\ }3\\0&amp;\xrightarrow{\ s_1\ }2\xrightarrow{\ s_2\ }8\\0&amp;\xrightarrow{\ s_2\ }8\xrightarrow{\ s_1\ }9\end{align*}\]</span> corresponde to the five elements of length 2 in <span class="math inline">\(\mathcal{SL}(W)\)</span>: <span class="math inline">\(s_0s_1,s_0s_2,s_1s_0,s_1s_2,s_2s_1\)</span>.</li></ol><p>Using breadth-first search we can easily generate all words in <span class="math inline">\(\mathcal{SL}(W)\)</span> up to any givendepth.</p><p>Note for an infinite Coxeter group the automaton must have cycles,but for a finite Coxeter group the automaton must be a directed tree,for example the symmetry group <span class="math inline">\(S_4\)</span>of tetrahedron:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/tetrahedron.svg" width="600"></p><p>The 24 different paths corresponde to the 24 group elements of <span class="math inline">\(S_4\)</span>:</p><p><span class="math display">\[\begin{array}{llll}e&amp;s_{0}&amp;s_{1}&amp;s_{2}\\s_{0}s_{1}&amp;s_{0}s_{2}&amp;s_{1}s_{0}&amp;s_{1}s_{2}\\s_{2}s_{1}&amp;s_{0}s_{1}s_{0}&amp;s_{0}s_{1}s_{2}&amp;s_{0}s_{2}s_{1}\\s_{1}s_{0}s_{2}&amp;s_{1}s_{2}s_{1}&amp;s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{2}\\s_{0}s_{1}s_{2}s_{1}&amp;s_{0}s_{2}s_{1}s_{0}&amp;s_{1}s_{0}s_{2}s_{1}&amp;s_{1}s_{2}s_{1}s_{0}\\s_{0}s_{1}s_{0}s_{2}s_{1}&amp;s_{0}s_{1}s_{2}s_{1}s_{0}&amp;s_{1}s_{0}s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{2}s_{1}s_{0}\end{array}\]</span></p><p>Now the big question:</p><blockquote><p><strong>Question 1</strong>: How to compute <span class="math inline">\(\mathcal{SL}(W)\)</span>?</p></blockquote><p>The answer to this question is too complicated to be covered in thisarticle, a simple sketch of the main thread is appended at the end. WhenI was developing this program I mainly referred to Casselman’s notes <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> andthe textbook by Humphreys <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. These should be enoughfor a reader with a solid background in undergradute abstractalgebra.</p><p>Once we have the normal forms of the group elements, we can easilyuse them to map the initial vertex <span class="math inline">\(v_0\)</span> to other vertices in the tiling:</p><p>Let <span class="math inline">\(w=s_{i_0}s_{i_1}\cdotss_{i_n}\)</span>, we adopt the convention that the action of <span class="math inline">\(w\)</span> on <span class="math inline">\(v_0\)</span> is to successively apply eachgenerator in <span class="math inline">\(w\)</span> from right to left:<span class="math display">\[w\cdot v_0 = s_{i_0}(s_{i_1}(\cdotss_{i_n}(v_0))).\]</span> Since <span class="math inline">\(W\)</span> isinfinite we can only generate words up to a given depth. Suppose we havethe 37 words listed above stored in a list <span class="math inline">\(L\)</span>, they map <span class="math inline">\(v_0\)</span> to 37 different vertices in thetiling. To draw the edges between them we need to compute which of themare adjacent. How can we do this?</p><p>Firstly we need a multiplicaiton table <span class="math inline">\(T\)</span> for the words in <span class="math inline">\(L\)</span>. <span class="math inline">\(T\)</span>is a 2d array with its <span class="math inline">\(i\)</span>-th rowcorrespondes to the <span class="math inline">\(i\)</span>-th word <span class="math inline">\(w_i\)</span> in <span class="math inline">\(L\)</span> and its <span class="math inline">\(j\)</span>-th column correspondes to the <span class="math inline">\(j\)</span>-th generator <span class="math inline">\(s_j\)</span>. The entry <span class="math inline">\(T[i][j]\)</span> records the index of <span class="math inline">\(s_jw_j\)</span> in <span class="math inline">\(L\)</span> (note this multiplication may not be anormal form). If <span class="math inline">\(s_jw_i\)</span> does notexist in <span class="math inline">\(L\)</span> we simply return<code>None</code>. The usage of <span class="math inline">\(T\)</span>is, for any given word <span class="math inline">\(w\)</span>, we canquickly find the index of <span class="math inline">\(w\)</span> in<span class="math inline">\(L\)</span> by using <span class="math inline">\(T\)</span> as a lookup table.</p><p>In our example <span class="math inline">\(T\)</span> is listedbelow, the words in <span class="math inline">\(L\)</span> are put intothe second column:</p><details><summary><font color="#D00"><strong>Click to expand <span class="math inline">\(T\)</span></strong></font></summary><div><table><thead><tr><th style="text-align: center;">V</th><th style="text-align: center;">word</th><th style="text-align: center;"><span class="math inline">\(s_0\)</span></th><th style="text-align: center;"><span class="math inline">\(s_1\)</span></th><th style="text-align: center;"><span class="math inline">\(s_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(e\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(s_{0}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">6</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(s_{1}\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">0</td><td style="text-align: center;">8</td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(s_{2}\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">7</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">12</td><td style="text-align: center;">11</td></tr><tr><td style="text-align: center;">5</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">13</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">6</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}\)</span></td><td style="text-align: center;">9</td><td style="text-align: center;">1</td><td style="text-align: center;">15</td></tr><tr><td style="text-align: center;">7</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}\)</span></td><td style="text-align: center;">10</td><td style="text-align: center;">3</td><td style="text-align: center;">14</td></tr><tr><td style="text-align: center;">8</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}\)</span></td><td style="text-align: center;">11</td><td style="text-align: center;">14</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;">9</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">20</td><td style="text-align: center;">19</td></tr><tr><td style="text-align: center;">10</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">21</td><td style="text-align: center;">18</td></tr><tr><td style="text-align: center;">11</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">8</td><td style="text-align: center;">22</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;">12</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">16</td><td style="text-align: center;">4</td><td style="text-align: center;">24</td></tr><tr><td style="text-align: center;">13</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">17</td><td style="text-align: center;">5</td><td style="text-align: center;">23</td></tr><tr><td style="text-align: center;">14</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">18</td><td style="text-align: center;">8</td><td style="text-align: center;">7</td></tr><tr><td style="text-align: center;">15</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">19</td><td style="text-align: center;">23</td><td style="text-align: center;">6</td></tr><tr><td style="text-align: center;">16</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">12</td><td style="text-align: center;">30</td><td style="text-align: center;">29</td></tr><tr><td style="text-align: center;">17</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">13</td><td style="text-align: center;">31</td><td style="text-align: center;">28</td></tr><tr><td style="text-align: center;">18</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">14</td><td style="text-align: center;">32</td><td style="text-align: center;">10</td></tr><tr><td style="text-align: center;">19</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">15</td><td style="text-align: center;">33</td><td style="text-align: center;">9</td></tr><tr><td style="text-align: center;">20</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">25</td><td style="text-align: center;">9</td><td style="text-align: center;">35</td></tr><tr><td style="text-align: center;">21</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">26</td><td style="text-align: center;">10</td><td style="text-align: center;">36</td></tr><tr><td style="text-align: center;">22</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">27</td><td style="text-align: center;">11</td><td style="text-align: center;">34</td></tr><tr><td style="text-align: center;">23</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">28</td><td style="text-align: center;">15</td><td style="text-align: center;">13</td></tr><tr><td style="text-align: center;">24</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">29</td><td style="text-align: center;">34</td><td style="text-align: center;">12</td></tr><tr><td style="text-align: center;">25</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">20</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">26</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">21</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">27</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">22</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">28</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">23</td><td style="text-align: center;">None</td><td style="text-align: center;">17</td></tr><tr><td style="text-align: center;">29</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">24</td><td style="text-align: center;">None</td><td style="text-align: center;">16</td></tr><tr><td style="text-align: center;">30</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">16</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">31</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">17</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">32</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">18</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">33</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">19</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">34</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">24</td><td style="text-align: center;">22</td></tr><tr><td style="text-align: center;">35</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">None</td><td style="text-align: center;">20</td></tr><tr><td style="text-align: center;">36</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">None</td><td style="text-align: center;">21</td></tr></tbody></table></div></details><p>Hence for any word <span class="math inline">\(w=s_{i_0}s_{i_1}\cdotss_{i_n}\)</span>, we can start from the first row of <span class="math inline">\(T\)</span>, find the index of <span class="math inline">\(s_{i_n}\)</span> in <span class="math inline">\(L\)</span>, say <span class="math inline">\(k\)</span>, then jump to the <span class="math inline">\(k\)</span>-th row and find the index of <span class="math inline">\(s_{i_{n-1}}s_{i_n}\)</span> in <span class="math inline">\(L\)</span>, …, and finally get the index of <span class="math inline">\(w\)</span> (or <code>None</code>).</p><p>Suppose the reflection of the initial vertex <span class="math inline">\(v_0\)</span> about the <span class="math inline">\(i\)</span>-th mirror gives a virtual image <span class="math inline">\(v_1=s_i(v_0)\)</span>, then <span class="math inline">\(e=(v_0,v_1)\)</span> is an edge of type <span class="math inline">\(i\)</span>. By the orbit-stabilizer theorem alledges of type <span class="math inline">\(i\)</span> can be obtained byapplying the coset representatives in <span class="math inline">\(G/H\)</span> to <span class="math inline">\(e\)</span>, where <span class="math inline">\(H=\langle i\rangle\)</span> is the stabilizingsubgroup of <span class="math inline">\(e\)</span> (<span class="math inline">\(H\)</span> is called a standard parabolicsubgroup). It’s easy to see the words of the two ends of <span class="math inline">\(e\)</span> are <span class="math inline">\(1\)</span> and <span class="math inline">\(s_i\)</span> respectively. We then compute thecoset representatives of the words in <span class="math inline">\(L\)</span> for the subgroup <span class="math inline">\(H\)</span>, use a set to remove duplicates, applyeach resulting coset representative <span class="math inline">\(w\)</span> to the two ends of <span class="math inline">\(e\)</span>. The words of the two ends of <span class="math inline">\(w\cdot e\)</span> are <span class="math inline">\(w\)</span> and <span class="math inline">\(ws_i\)</span> respectively. We can find theindices of <span class="math inline">\(w\)</span> and <span class="math inline">\(ws_i\)</span> as shown above to get <span class="math inline">\(w\cdot e\)</span>.</p><p>The edges between the 37 vertices in <span class="math inline">\(L\)</span> are drawn below:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/723_edges.png" width="500"></p><p>0 is the initial vertex, the number of white strips in an edgeindices the type of it (no white strips for <span class="math inline">\(s_0\)</span>, one for <span class="math inline">\(s_1\)</span> and two for <span class="math inline">\(s_2\)</span>).</p><p>It’s worth noting that one can easily read the shortlex wordrepresentation of any vertex <span class="math inline">\(v\)</span> fromthe above image, just start from vertex 0, trace a shortest path from 0to <span class="math inline">\(v\)</span> (if there are more than oneshortest path then always choose the smaller vertex at bifurcatonpoints) and record the edges along the way. For example there are twopaths with shortest length from vetex 0 to vertex 33: <span class="math display">\[\begin{align*}&amp;0\xrightarrow{\ s_1\ }2\xrightarrow{\ s_0\}6\xrightarrow{\ s_2\ }13\xrightarrow{\ s_1\ }22\xrightarrow{\ s_0\}33.\\&amp;0\xrightarrow{\ s_1\ }2\xrightarrow{\ s_2\ }7\xrightarrow{\ s_0\}13\xrightarrow{\ s_1\ }22\xrightarrow{\ s_0\ }33.\end{align*}\]</span> By concatenating edge labels from left to right wehave two words that both map vertex 0 to vertex 33: <span class="math inline">\(s_1s_0s_2s_1s_0\)</span> and <span class="math inline">\(s_1s_2s_0s_1s_0\)</span>. The first is theshortlex one.</p><blockquote><p><strong>Question 2</strong>: How to compute the normal form of themultiplicaiton of two words? How to compute the coset representative ofa word for a standard parabolic subgroup?</p></blockquote><p>Again the answer is too long to be included here. A short sketch ofthe procedure is attached below.</p><p>The procedure for computing faces is very similar with the case ofedges. The reflections about the <span class="math inline">\(i\)</span>-th and <span class="math inline">\(j\)</span>-th mirrors generate a polygon <span class="math inline">\(f_0\)</span> centered at a vertex of thefundamental triangle. The stabilizing subgroup of <span class="math inline">\(f_0\)</span> is the standard parabolic subgroup<span class="math inline">\(\langle i,j\rangle\)</span>. Again we find aword representation for each vertex in <span class="math inline">\(f_0\)</span>, apply the words in <span class="math inline">\(L\)</span> to <span class="math inline">\(f_0\)</span>, and use <span class="math inline">\(T\)</span> to get the indices of the transformedface.</p><p>The final image is shown below, it contains 30517 vertices, 42057edges and 11541 polygons.</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-7-2-3.png" width="500"></p><h1 id="about-the-code">About the code</h1><p>The entire code mainly includes the following functionalities:</p><ol type="1"><li>Computation of Coxeter groups. This part is implemented by the<code>CoxeterGroup</code> class in the <code>coxeter</code> module. Thecomputation of Coxeter groups includes the following aspects:<ul><li>Compute the minimal root reflection table of the Coxeter group.</li><li>Compute the multiplication of two words in the Coxeter group, andreturning the result in its normal form.</li><li>Compute the coset representatives of group elements with respect toa given standard parabolic subgroup, and returning the result in itsnormal form.</li><li>Compute of the finite state machine that recognizes <span class="math inline">\(\mathcal{SL}(W)\)</span>, minimizing it, anddrawing the state machine.</li></ul></li><li>Tiling drawing. Mainly implemented in the <code>tiling.py</code>file. It includes the following steps:<ul><li>For a given Coxeter group and specified initial vertex position,calculate the reflection mirrors and fundamental domain.</li><li>Compute the normal forms of all vertices, as well as the connectionsof edges and faces.</li><li>Apply the words of vertices obtained in the previous step to theinitial vertex to obtain the floating-point coordinates of all vertices.These calculations are all performed in one higher dimension, because inthe higher dimension all reflections are linear transformations, whichavoids the use of affine transformations and inversion. Then project totwo dimensions.</li><li>Call the drawing library to draw the tiling.</li></ul></li></ol><p>The drawing of the finite state machine of <span class="math inline">\(\mathcal{SL}(W)\)</span> requires the use of the<code>pygraphviz</code> module, which depends on the<code>graphviz</code> software and <code>libgraphviz-dev</code>.</p><p>The minimization of the finite state machine was referenced from <a href="https://link.springer.com/article/10.1007/BF00264025">Gries’spaper</a>. Gries’s article is excellent, but I think he did not clarifythe property of the list that storing the <span class="math inline">\((B,a)\)</span> pairs.</p><p>The drawing of the hyperbolic case uses a third-party library <a href="https://github.com/cduck/hyperbolic/">hyperbolic</a>. I’m actuallynot very satisfied with this library, but I don’t have the energy towrite another one at the moment, so I’ll make do for now. The biggestadvantage of this library is that it can draw edges with a constanthyperbolic width, namely the so-called <a href="https://en.wikipedia.org/wiki/Hypercycle_(hyperbolic_geometry)">hypercycle</a>.</p><p>The algorithm for calculating minimal roots is the biggestperformance bottleneck in this code. In determining whether a minimalroot <span class="math inline">\(\gamma\)</span> remains a minimal rootafter a single reflection <span class="math inline">\(s_\alpha\)</span>,the method used is to determine whether <span class="math inline">\(s_\gamma\)</span> and <span class="math inline">\(s_\alpha\)</span> generate a finite dihedralgroup, that is, whether the matrix corresponding to <span class="math inline">\(s_\gamma s_\alpha\)</span> under the basis <span class="math inline">\(\Delta\)</span> of simple roots becomes theidentity matrix after a certain power. The elements of the matrix arealgebraic integers in the cyclotomic field, in the form of <span class="math inline">\(p(\xi)\)</span>, where <span class="math inline">\(p(x)\)</span> is an irreducible polynomial withinteger coefficients, and <span class="math inline">\(\xi\)</span> is aprimitive <span class="math inline">\(m\)</span>-th root of unity, where<span class="math inline">\(m\)</span> is twice the least commonmultiple of all elements in the Coxeter matrix. <span class="math inline">\(\xi\)</span> can be described by the cyclotomicpolynomial <span class="math inline">\(\Phi_m(x)\)</span>. Thus, thecomputation of the matrix is reduced to polynomial operations in <span class="math inline">\(\mathbb{Z}[x]/(\Phi_m(x))\)</span>. Thiscomputational complexity heavily depends on the value of <span class="math inline">\(m\)</span>: for example, for a triangle group like(19, 20, 21), the expression of <span class="math inline">\(\Phi_m(x)\)</span> is very complicated, and thecomputation speed is very slow. This is different from the inverse pixelreflection method, whose computational complexity hardly changes withthe group.</p><p>A more reasonable implementation method can be seen <a href="https://github.com/ulthiel/CoxeterGroups.jl">here</a>.</p><h1 id="more-explainations-on-the-math-stuff">More explainations on themath stuff</h1><p>In this section I’ll give a short sketch of the core part of the mathstuff. This requires you know some basic concepts like geometricrealizations of Coxeter groups, Tit’s cone, root systems. These arefairly standard materials and can be found in Humphreys’s book.</p><p>Almost everything relies upon a 2d table called <strong>reflectiontable of minimal roots</strong>. Again we use group (7, 2, 3) asexample:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/roots.png" width="800"></p><p>This image is the same with the last one except that it has 12labelled mirrors, these mirror have particular importance among allroots in the root system: they are the set of minimal roots in the rootsystem.</p><p>You can think the root system of <span class="math inline">\(W\)</span> as all the circular arcs in thediagram, each of which is a reflection mirror. These mirrors are theresult of the action of the group <span class="math inline">\(W\)</span>on the initial mirrors <span class="math inline">\(AB, AC, BC\)</span>that are the edges of <span class="math inline">\(\Delta ABC\)</span>.Each mirror has two sides, where the side where the fundamental domain<span class="math inline">\(\Delta ABC\)</span> is located is consideredthe positive side of the mirror, and the other side is the negativeside. The normal vector of the mirror’s positive side gives a positiveroot, while the normal vector corresponding to the other side is thenegative of that positive root (negative root).</p><p>We always use a mirror’s positive normal vector (positive root) torepresent that mirror.</p><p>Intuitively, a minimal root <span class="math inline">\(\gamma\)</span> is characterized by the followingcondition: suppose a person stands inside <span class="math inline">\(\Delta ABC\)</span> looking outward, there existsno mirror <span class="math inline">\(\beta \neq \gamma\)</span>completely blocking the view of <span class="math inline">\(\gamma\)</span>, preventing the person from seeingany part of <span class="math inline">\(\gamma\)</span>. In other words,this means that if the person wants to walk from the inside of <span class="math inline">\(\Delta ABC\)</span> to the negatve side of <span class="math inline">\(\gamma\)</span>, and he must cross another mirror<span class="math inline">\(\beta \neq \gamma\)</span> first, regardlessof the path he chooses, then <span class="math inline">\(\gamma\)</span>is <strong>not</strong> a minimal root.</p><p>Simple roots are necessarily minimal roots, as they are theboundaries of the fundamental domain <span class="math inline">\(\DeltaABC\)</span>, and it is impossible for there to be another mirrorblocking between them and the basic region.</p><p>The most important fact about minimal root is:</p><blockquote><p><strong>Theorem</strong>: The set of minimal roots is finite.</p></blockquote><p>This theorem is the key step in Brink and Howlett’s proof thatCoxeter groups are automatic groups.</p><p>The reflection table of minimal roots <code>reftable</code> isdefined as follows: it’s a 2d array with its <span class="math inline">\(i\)</span>-th row correspondes to the <span class="math inline">\(i\)</span>-th minimal root <span class="math inline">\(\alpha_i\)</span> and <span class="math inline">\(j\)</span>-th column correspondes to the <span class="math inline">\(j\)</span>-th generator <span class="math inline">\(s_j\)</span>. The <span class="math inline">\((i,j)\)</span>-entry records the action of <span class="math inline">\(s_j\)</span> on <span class="math inline">\(\alpha_i\)</span>. Let <span class="math inline">\(\beta=s_j(\alpha_i)\)</span>:</p><ol type="1"><li>If <span class="math inline">\(\beta=\alpha_k\)</span> is the <span class="math inline">\(k\)</span>-th minimal root then set this entry to<span class="math inline">\(k\)</span>.</li><li>If <span class="math inline">\(\beta\)</span> is a negative rootthen set this entry to <span class="math inline">\(-1\)</span>.</li><li>Else <span class="math inline">\(\beta\)</span> is a positive rootbut not minimal, set this entry to <code>None</code>.</li></ol><p>The <code>reftable</code> of the (7, 2, 3) group is listed below:</p><table><thead><tr><th style="text-align: center;">root</th><th style="text-align: center;"><span class="math inline">\(s_0\)</span></th><th style="text-align: center;"><span class="math inline">\(s_1\)</span></th><th style="text-align: center;"><span class="math inline">\(s_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;">0</td><td style="text-align: center;">-1</td><td style="text-align: center;">3</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;">1</td><td style="text-align: center;">4</td><td style="text-align: center;">-1</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">5</td><td style="text-align: center;">-1</td></tr><tr><td style="text-align: center;">3</td><td style="text-align: center;">6</td><td style="text-align: center;">0</td><td style="text-align: center;">7</td></tr><tr><td style="text-align: center;">4</td><td style="text-align: center;">1</td><td style="text-align: center;">8</td><td style="text-align: center;">9</td></tr><tr><td style="text-align: center;">5</td><td style="text-align: center;">9</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;">6</td><td style="text-align: center;">3</td><td style="text-align: center;">10</td><td style="text-align: center;">11</td></tr><tr><td style="text-align: center;">7</td><td style="text-align: center;">11</td><td style="text-align: center;">7</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;">8</td><td style="text-align: center;">10</td><td style="text-align: center;">4</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">9</td><td style="text-align: center;">5</td><td style="text-align: center;">None</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;">10</td><td style="text-align: center;">8</td><td style="text-align: center;">6</td><td style="text-align: center;">None</td></tr><tr><td style="text-align: center;">11</td><td style="text-align: center;">7</td><td style="text-align: center;">None</td><td style="text-align: center;">6</td></tr></tbody></table><p>Let <span class="math inline">\(\Sigma\)</span> be the set of minimalroots of <span class="math inline">\(G\)</span>, all states in theautomaton are subsets of <span class="math inline">\(\Sigma\)</span>,the transition rule between the subsets is:</p><p><span class="math display">\[S\xrightarrow{\ s_i\ } \{s_i\} \cup(s_i(S)\cup\{ s_i(\alpha_j),j&lt;i\})\cap\Sigma.\]</span></p><p>One can use breadth-first search to build this automaton and use <a href="https://en.wikipedia.org/wiki/DFA_minimization#Hopcroft's_algorithm">Hopcroft’salgorithm</a> to get a minimized version of it.</p><p>The image below shows the subsets of minimal roots for each state inthe automaton:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/723_dfa_subsets.png" width="800"></p><p>The code for computing the multiplication of a generator and a wordis given below:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">left_mul_invshortlex</span>(<span class="hljs-params">reftable, s, w</span>):</span><br>    w = <span class="hljs-built_in">tuple</span>(w)<br>    t = s<br>    k = -<span class="hljs-number">1</span><br>    mu = s<br>    <span class="hljs-keyword">for</span> i, s_i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(w):<br>        <span class="hljs-keyword">if</span> mu <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> w[:k+<span class="hljs-number">1</span>] + (t,) + w[k+<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">elif</span> mu &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> w[:i] + w[i+<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">elif</span> mu &lt; s_i:<br>            t = mu<br>            k = i<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">return</span> w[:k+<span class="hljs-number">1</span>] + (t,) + w[k+<span class="hljs-number">1</span>:]<br></code></pre></td></tr></tbody></table></figure><p>Here <span class="math inline">\(s\)</span> is a generator and <span class="math inline">\(w\)</span> is a word in the normal form of the<em>inverse shortlex ordering</em> (invshortlex). The function returnsthe normal form of <span class="math inline">\(s\cdot w\)</span> also inthe invshortlex ordering. The computations in shortlex can be obtainedby doing computations in invshortlex first and then reverse the resultback.</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>The intermedian step of doing computations in invshortlexordering is mainly for keeping consistent with Casselman’s paper.</p></div><p>Finding the coset representative of a given word for a standardparabolic subgroup is quite straight-forward: let <span class="math inline">\(T\)</span> be the set of generators of thisstandard parabolic subgroup, the pseudocode for the procedure is givenbelow:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">x := w<br>u := 1<br>while l(xt) &lt; l(x) for some t in T<br>    x := xt<br>    u := t<br>end<br><br>return x<br></code></pre></td></tr></tbody></table></figure><p>Where <span class="math inline">\(l(\cdot)\)</span> is the lengthfunction.</p><p>For finite Coxeter groups all positive roots are minimal. For affineCoxeter groups the root system consists of families of parallel affinehyperplanes. In each family there is a pair of minimal roots such thatthe fundamental domain lies between them and all other mirrors in thisfamily are completely screened off by them hence are not minimal. Seethe image for (6, 2, 3) (affine <span class="math inline">\(\widetilde{G}_2\)</span>) for an example:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/roots_623.png" width="600"></p><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://www.math.ubc.ca/~cass/research/pdf/banff.pdf">Automata toperform basic calculations in Coxeter groups, by Bill Casselman</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://www.math.ubc.ca/~cass/research/pdf/cm.pdf">Computation inCoxeter groups I. Multiplication, by Bill Casselman</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://www.math.ubc.ca/~cass/research/pdf/roots.pdf">Computationin Coxeter groups II. Constructing minimal roots, by BillCasselman</a>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>Reflection Groups and Coxeter Groups, by James E.Humphreys.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd-Coxeter algorithm and uniform polytopes</title>
      <link href="polytopes/index.html"/>
      <url>polytopes/index.html</url>
      
        <content type="html"><![CDATA[<p>This project uses Python and POV-Ray to render 3D/4D uniformpolytopes. The code is hosted on <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/polytopes">GitHub</a>and requires the <code>numpy</code> library and the free raytracer,<code>POV-Ray</code>.</p><h1 id="examples">Examples</h1><p>All the images and videos displayed below are created using thisprogram. The polytope data is computed in Python and then exported toPOV-Ray for rendering.</p><ul><li><p>All Platonic solids and Archimedean solids, prims and antiprisms,for example the <a href="https://en.wikipedia.org/wiki/Snub_dodecahedron">snubdodecahedron</a>:</p><p><video src="/images/polytopes/snub-dodecahedron.mp4" controls=""></video></p></li><li><p>All Kepler-Poinsot solids, for example the <a href="https://en.wikipedia.org/wiki/Great_icosahedron">greaticosahedron</a>:</p><p><video src="/images/polytopes/great-icosahedron.mp4" controls=""></video></p></li><li><p>All uniform 4d polytopes (except the <a href="https://en.wikipedia.org/wiki/Grand_antiprism">grandantiprism</a>, which is non-Wythoffian), for example my github favicon,the <a href="https://en.wikipedia.org/wiki/Runcinated_120-cells">runcinated120-cell</a>:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/github-favicon.png"></p></li><li><p>5-cell:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/5-cell.png"></p></li><li><p>4d cube:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/4-cube.png"></p></li><li><p><a href="https://en.wikipedia.org/wiki/Truncated_tesseract">Truncatedtesseract</a>:</p><p><video src="/images/polytopes/truncated-tesseract.mp4" controls=""></video></p></li><li><p><a href="https://en.wikipedia.org/wiki/600-cell">600-cell</a>:(you can render the bubble faces and choose which of them are shown)</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/600-cell.png"></p></li><li><p><a href="https://en.wikipedia.org/wiki/16-cell">runcinated16-cell</a>:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/runcinated-16-cell.png"></p></li><li><p><a href="https://en.wikipedia.org/wiki/Snub_24-cell">snub24-cell</a>:</p><p><video src="/images/polytopes/snub24-cell.mp4" controls=""></video></p></li><li><p>You can also render uniform star 4d polytopes, for example the <a href="https://en.wikipedia.org/wiki/Grand_stellated_120-cell">grandstellated 120-cell</a>:</p><p><video src="/images/polytopes/grand-stellated-120-cell.mp4" controls=""></video></p><p>and its rectified version (rendered in a curved fashion):</p><p><video src="/images/polytopes/rectified-grand-stellated-120-cell.mp4" controls=""></video></p></li><li><p>And finally, uniform 5D polytopes like 5-cube:</p><p><video src="/images/polytopes/5-cube.mp4" controls=""></video></p></li></ul><h1 id="what-are-these-examples-about">What are these examplesabout?</h1><p>The polytopes showcased above are convex and non-convex uniformpolytopes in 3D or 4D Euclidean spaces. Key terms to note include“convex/non-convex”, “Euclidean”, and “uniform”.</p><p>The term “convex” refers to the property of a polytope such that anyline segment joining two points on the polytope lies entirely within theenclosure of the polytope. Examples of convex polytopes include Platonicsolids, Archimedean solids, and Catalan solids, while non-convex onesinclude Kepler-Poinsot solids and star polychora.</p><p>In 3D Euclidean space, there are 18 different convex uniformpolytopes (excluding the two infinite classes of prisms and antiprisms)and 57 different non-convex uniform polytopes. Currently, my program canonly render the convex ones and a few non-convex ones, but I’m workingon figuring out how to make it work for all of them in the future.</p><p>The term “Euclidean” is emphasized here because we also have uniformpolytopes in other metric spaces, such as the hyperbolic metric, whichbends the space and makes the polytopes look “deformed”. A famousexample of this is the logo “Spikey” of Mathematica, which is based onthe dodecahedron in hyperbolic 3-space.</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/spikey.png"></p><p>The term “uniform” requires some mathematical subtleties. Roughlyspeaking, it means that</p><ol type="1"><li>All vertices are the same.</li><li>All faces are regular polygons.</li><li>All cells are uniform polyhedra (a polyhedron that satisfiesconditions 1 and 2).</li></ol><p>To explain what “the same” means, we need to use terms from grouptheory: it means that the symmetry group <span class="math inline">\(G\)</span> of the polytope acts transitively onthe set of vertices, such that for any pair of vertices <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>, there is some <span class="math inline">\(g\in G\)</span> that transforms <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>: <span class="math inline">\(g \cdot u= v\)</span>.</p><p>In the above examples, the polytopes are colored such that allvertices, edges, and faces that are in the same orbit under the actionof the symmetry group have the same color.</p><h1 id="how-to-compute-the-data-of-a-uniform-polytope">How to computethe data of a uniform polytope</h1><p>Though these polytopes appear quite different from each other, theycan all be constructed using a uniform approach called the <a href="https://en.wikipedia.org/wiki/Wythoff_construction">Wythonffconstruction</a> (also known as the kaleidoscope construction). Inprinciple, this construction works in the same way as a kaleidoscope: weplace reflection planes (mirrors) in space, passing through the originand with carefully chosen angles between them (which must be of the form<span class="math inline">\(\pi-\pi/p\)</span> for some rational <span class="math inline">\(p\)</span>). These mirrors partition space into“rooms”. We choose any room (called the fundamental domain) and aninitial vertex <span class="math inline">\(v_0\)</span> in it, and thenrepeatedly reflect <span class="math inline">\(v_0\)</span> about themirrors to obtain a set of virtual images. All virtual images togetherwith <span class="math inline">\(v_0\)</span> form the vertices of ourpolytope. If <span class="math inline">\(v_1\)</span> is the virtualimage of <span class="math inline">\(v_0\)</span> about the <span class="math inline">\(i\)</span>-th mirror, then <span class="math inline">\((v_0,v_1)\)</span> form an edge of type <span class="math inline">\(i\)</span>. We can use the symmetry group totransform it to other edges in the same orbit. Also, if <span class="math inline">\(v_0\)</span> is firstly reflected about mirror<span class="math inline">\(i\)</span> and then reflected about mirror<span class="math inline">\(j\)</span>, then since the composition oftwo reflections is a rotation, <span class="math inline">\(v_0\)</span>is rotated about the center of some face <span class="math inline">\(f\)</span> by an angle of <span class="math inline">\(2\pi/m\)</span> (assuming the angle between mirror<span class="math inline">\(i\)</span> and mirror <span class="math inline">\(j\)</span> is <span class="math inline">\(\pi-\pi/m\)</span>). We can recover <span class="math inline">\(f\)</span> by applying this rotation <span class="math inline">\(m\)</span> times and using the symmetry group toobtain other faces.</p><p>To implement the above strategy in a practical program, we need toaddress two main issues:</p><ol type="1"><li>How to position the mirrors and select the initial vertex <span class="math inline">\(v_0\)</span> for a given convex uniformpolytope?</li><li>Once the mirrors and <span class="math inline">\(v_0\)</span> aredetermined, how do we compute all the virtual images of <span class="math inline">\(v_0\)</span>?</li></ol><p>The solution to the first problem is known as the <a href="https://en.wikipedia.org/wiki/Coxeter%E2%80%93Dynkin_diagram">Coxeter-Dynkindiagram</a>, which is a labeled undirected graph that encodes all thenecessary information. Each uniform polytope has a correspondingCoxeter-Dynkin diagram that represents it, although different diagramsmay represent the same polytope.</p><p>For example, the Coxeter-Dynkin diagram of the cube is:</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="250"></p><p>Let’s delve deeper into the Coxeter-Dynkin diagram. Each node in thediagram represents a mirror in the kaleidoscope. In the diagram above,there are three nodes, and therefore three mirrors, which we label fromleft to right as <span class="math inline">\(m_0\)</span>, <span class="math inline">\(m_1\)</span>, and <span class="math inline">\(m_2\)</span>. The labelled edge between two nodesencodes the angle between their corresponding mirrors, as follows:</p><ol type="1"><li>Two nodes are connected if and only if the angle between theirmirrors is not equal to <span class="math inline">\(\pi/2\)</span>.</li><li>Two nodes are connected by an unlabelled edge if and only if theangle between their mirrors equals <span class="math inline">\(\pi-\pi/3\)</span>.</li><li>Two nodes are connected by an edge labelled with a rational number<span class="math inline">\(m&gt;2\)</span> and <span class="math inline">\(m\ne3\)</span> if and only if the angle betweentheir mirrors equals <span class="math inline">\(\pi-\pi/m\)</span>.</li></ol><p>Moreover, we use “circled” nodes to indicate which mirrors are“active”, i.e., those that do not contain the initial vertex <span class="math inline">\(v_0\)</span>. In this case, reflecting <span class="math inline">\(v_0\)</span> about an active mirror produces avirtual image.</p><p>In the above example we have <span class="math inline">\(\langlem_0,m_1\rangle=\pi-\pi/4\)</span>, <span class="math inline">\(\langlem_1,m_2\rangle=\pi-\pi/3\)</span>, <span class="math inline">\(\langlem_0,m_2\rangle=\pi/2\)</span>. <span class="math inline">\(m_0\)</span>is active, but <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> are not.</p><p>Therefore, we can place the three mirrors as follows: (<span class="math inline">\(n_i\)</span> is the normalized normal vector ofmirror <span class="math inline">\(m_i\)</span>)</p><ol type="1"><li>The normal of <span class="math inline">\(m_0\)</span> can be chosenarbitrarily, for example <span class="math inline">\(n_0=(1,0,0)\)</span>.</li><li>The angle between <span class="math inline">\(n_1\)</span> and <span class="math inline">\(n_0\)</span> is <span class="math inline">\(3\pi/4\)</span>, so we can choose <span class="math inline">\(n_1\)</span> to be <span class="math inline">\(n_1=(\cos\dfrac{3\pi}{4}, \sin\dfrac{3\pi}{4},0)\)</span>.</li><li>The normal of <span class="math inline">\(m_2\)</span> isperpendicular to <span class="math inline">\(n_0\)</span>, so <span class="math inline">\(n_2\)</span> has the form <span class="math inline">\((0,y_3,z_3)\)</span>. Using <span class="math inline">\(\langle n_1,n_2\rangle=2\pi/3\)</span>, we have<span class="math inline">\(y_3\sin\dfrac{3\pi}{4}=\cos\dfrac{2\pi}{3}\)</span>,and since <span class="math inline">\(z_3\)</span> is a unit vector,<span class="math inline">\(z_3=\sqrt{1−y_3^2}\)</span>. We can solvethese two equations to obtain <span class="math inline">\(y_3,z_3\)</span>.</li></ol><p>To choose an initial vertex <span class="math inline">\(v_0\)</span>that lies on both <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> but not on <span class="math inline">\(m_0\)</span>, we can choose <span class="math inline">\(v_0\)</span> so that its distance to <span class="math inline">\(m_0\)</span> is 1 and its distance to <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> are both 0:</p><p><span class="math display">\[\begin{align*}\langle v_0,n_0\rangle=1,\\\langle v_0, n_1\rangle=0,\\\langle v_0,n_2\rangle=0.\\\end{align*}\]</span></p><p>Then solve this linear system to get <span class="math inline">\(v_0\)</span>.</p><p>As mentioned before the angles between the mirrors must be chosencarefully to ensure <span class="math inline">\(v_0\)</span> and itsvirtual images form the vertices of an uniform polytope, this restrictsus to only finitely many choices of Coxeter diagrams, you can refer tothis <a href="https://en.wikipedia.org/wiki/Uniform_polytope">wikipage</a> for the complete list.</p><p>The answer to the second question is called the Todd-Coxeteralgorithm, I’ll discuss it in the next section.</p><h1 id="finitely-presented-groups-and-todd-coxeter-algorithm">Finitelypresented groups and Todd-Coxeter algorithm</h1><p>How can we obtain all the virtual images of the initial vertex <span class="math inline">\(v_0\)</span> with respect to all mirrors? Anobvious but crude method is to repeatedly reflect <span class="math inline">\(v_0\)</span> about the mirrors and compare theresulting images with the set of virtual images obtained so far (withina predefined rounding error bound) until no new virtual images emerge.This approach is easy to program but it’s unappealing from amathematician’s perspective, as it fails to utilize the abundantsymmetries inherent in the polytope.</p><p>This program takes a “symbolic computation” approach by solving the<a href="https://en.wikipedia.org/wiki/Coset_enumeration">cosetenumeration problem</a> in the symmetry group. It offers the advantageof providing exact information about the polytope without resorting torounding errors or approximation procedures. However, the price we payis that the math involved is somewhat complex (and hence so is thecode), and readers should have some basic knowledge of group theory tounderstand it.</p><p>Firstly, let’s recall the <a href="https://en.wikipedia.org/wiki/Group_action_(mathematics)#Orbit-stabilizer_theorem">orbit-stabilizertheorem</a> from group theory:</p><blockquote><p><strong>Theorem</strong>: Suppose a group <span class="math inline">\(G\)</span> acts transitively on a set <span class="math inline">\(S\)</span>, and let <span class="math inline">\(x\in S\)</span> have stabilizer subgroup <span class="math inline">\(H\leq G\)</span>. Then there exists a one-to-one correspondence between<span class="math inline">\(S\)</span> and the right cosets of <span class="math inline">\(G/H\)</span>: <span class="math inline">\(x \cdotg \mapsto Hg\)</span>.</p></blockquote><p>Note that the action of <span class="math inline">\(G\)</span> on<span class="math inline">\(S\)</span> is written as “applying on theright”, this is mainly for programming convenience and has nosignificant difference from applying on the left.</p><p>The theorem mentioned above tells us that if a group <span class="math inline">\(G\)</span> acts transitively on a set <span class="math inline">\(S\)</span> and we know the stabilizing subgroup ofsome <span class="math inline">\(x\in S\)</span> in <span class="math inline">\(G\)</span> is <span class="math inline">\(H\)</span>, then we can recover the entire orbit<span class="math inline">\(S\)</span> by applying a set of cosetrepresentatives of <span class="math inline">\(G/H\)</span> to <span class="math inline">\(x\)</span>.</p><p>Therefore, to compute all vertices of a given uniform polytope <span class="math inline">\(P\)</span>, we can follow these steps:</p><ol type="1"><li>Obtain a presentation of the symmetry group <span class="math inline">\(G\)</span> and the coordinates of an initialvertex <span class="math inline">\(v_0\)</span> from the Coxeter-Dynkindiagram.</li><li>Obtain a presentation of the stabilizing subgroup <span class="math inline">\(H\)</span> of <span class="math inline">\(v_0\)</span> in <span class="math inline">\(G\)</span> and calculate a set of right cosetrepresentatives of <span class="math inline">\(G/H\)</span>.</li><li>Apply these representatives to <span class="math inline">\(v_0\)</span> to obtain all vertices of <span class="math inline">\(P\)</span>.</li></ol><p>Again we use the cube as an example to show this procedure: recallthe Coxeter-Dynkin diagram of the cube is</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="250"></p><p>The mirrors of the cube are <span class="math inline">\(m_0,m_1,\)</span> and <span class="math inline">\(m_2\)</span>, with normals<span class="math inline">\(n_0, n_1,\)</span> and <span class="math inline">\(n_2\)</span>, respectively, all of which are unitvectors. The reflections about these mirrors are denoted as <span class="math inline">\(\rho_0, \rho_1,\)</span> and <span class="math inline">\(\rho_2\)</span>, and the matrix of <span class="math inline">\(\rho_i\)</span> is <span class="math inline">\(M_i= I - 2n_in_i^T\)</span> (see <a href="https://en.wikipedia.org/wiki/Householder_transformation">Householdertransformation</a>).</p><p>The symmetry group <span class="math inline">\(G\)</span> of the cubeis generated by the three aforementioned “generator reflections”: <span class="math inline">\(\rho_0, \rho_1,\)</span> and <span class="math inline">\(\rho_2\)</span>. A presentation of the groupis:</p><p><span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p>This is because a reflection always has order 2 and since <span class="math inline">\(\rho_0\)</span> and <span class="math inline">\(\rho_1\)</span> are two reflections with an angleof <span class="math inline">\(3\pi/4\)</span> between their mirrors,<span class="math inline">\(\rho_0\rho_1\)</span> is a rotation aboutthe line of intersection of their mirrors with an angle of <span class="math inline">\(3\pi/2\)</span>. Therefore, <span class="math inline">\((\rho_0\rho_1)^4=1\)</span>. Similarly, we havethe relations for <span class="math inline">\(\rho_1\rho_2\)</span> and<span class="math inline">\(\rho_0\rho_2\)</span>.</p><blockquote><p><strong>Note</strong>: It is natural to wonder if we might be missingsome “hidden” relations. For convex polytopes, the answer is no, but forcertain star polytopes, the answer is yes. In these cases, we need toadd extra relations to ensure the procedure works correctly. Asignificant difference is that, in convex cases, the symmetry groupalways maps the interior of the fundamental domain to another disjointone, whereas in star polytopes, the fundamental domain may be coveredmultiple times by other domains. For more information, refer toVinberg’s paper “Discrete linear groups generated by reflections”.</p></blockquote><p>One can employ the Todd-Coxeter algorithm (which will be explainedlater) to calculate a comprehensive list of all 48 elements in <span class="math inline">\(G\)</span>.</p><p><span class="math display">\[\begin{array}{lll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{0}&amp;\rho_{1}&amp;\rho_{0}\rho_{2}\\\rho_{2}&amp;\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\end{array}\]</span></p><p>Since the initial vertex <span class="math inline">\(v_0\)</span> ison <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> but not on <span class="math inline">\(m_0\)</span> in the Coxeter-Dynkin diagram, onlythe mirror <span class="math inline">\(m_0\)</span> is active. Thus,both <span class="math inline">\(\rho_1\)</span> and <span class="math inline">\(\rho_2\)</span> map <span class="math inline">\(v_0\)</span> to itself, while <span class="math inline">\(\rho_0\)</span> maps <span class="math inline">\(v_0\)</span> to its virtual image about <span class="math inline">\(m_0\)</span>. Therefore, the stabilizing subgroupof <span class="math inline">\(v_0\)</span> is given by:</p><p><span class="math display">\[H=\langle \rho_1, \rho_2\ |\\rho_1^2=\rho_2^2=(\rho_1\rho_2)^3=e\rangle.\]</span></p><blockquote><p><strong>Note</strong>: You may wonder if we can only claim that thesubgroup generated by <span class="math inline">\({\rho_0,\rho_1}\)</span> is contained in thestabilizing subgroup of <span class="math inline">\(v_0\)</span> but maynot be exactly equal to it. Indeed, this is a possibility. However, forCoxeter groups, it is a property that in the geometric realization of aCoxeter group <span class="math inline">\(W\)</span> (that is,representing <span class="math inline">\(W\)</span> as a set ofreflections about hyperplanes in <span class="math inline">\(\mathbb{R}^n\)</span>), the stabilizing subgroupof any point <span class="math inline">\(v\)</span> in the fundamentaldomain is a standard parabolic subgroup generated by those simplereflections whose hyperplanes contain <span class="math inline">\(v\)</span>. This may seem like an obviousgeometric intuition, but it requires a quite non-trivial proof, whichcan be found in Humphreys’s book “Reflection Groups and Coxeter Groups”,chapter 1.</p></blockquote><p>It is clear that <span class="math inline">\(H\)</span> is thedihedral group <span class="math inline">\(D_3\)</span>, thus <span class="math inline">\(|H|=6\)</span> and <span class="math inline">\(|G/H|=8\)</span>. Using the Todd-Coxeteralgorithm, we can obtain a complete list of coset representatives for<span class="math inline">\(G/H\)</span>:</p><p><span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span></p><p>Applying these coset representatives to <span class="math inline">\(v_0\)</span> gives us the 8 vertices of the cube.For example, the action of <span class="math inline">\(\rho_0\rho_1\)</span> on <span class="math inline">\(v_0\)</span> is as follows:</p><p><span class="math display">\[v_0(\rho_0\rho_1)=(v_0\rho_0)\rho_1=(v_0M_0)\rho_1=v_0M_0M_1.\]</span></p><p>Here, <span class="math inline">\(v_0\)</span> is represented as arow vector since all <span class="math inline">\(M_i\)</span>’s aresymmetric matrices.</p><p>We can also use the same procedure to find all edges and faces of thecube. To find all edges of type <span class="math inline">\(i\)</span>,we proceed as follows:</p><ol type="1"><li>Check if the initial vertex <span class="math inline">\(v_0\)</span>lies on the mirror <span class="math inline">\(m_i\)</span>. If it does,then the reflection <span class="math inline">\(\rho_i\)</span> fixes<span class="math inline">\(v_0\)</span>, and there are no edges of type<span class="math inline">\(i\)</span>. Otherwise, let <span class="math inline">\(v_1=\rho_i(v_0)\)</span>. Then, the segment <span class="math inline">\((v_0,v_1)\)</span> forms an edge <span class="math inline">\(e\)</span> of type <span class="math inline">\(i\)</span></li><li>To find the stabilizing subgroup of <span class="math inline">\(e\)</span>, we note that a symmetry fixes <span class="math inline">\(e\)</span> if and only if it fixes the midpoint<span class="math inline">\(p\)</span> of <span class="math inline">\(e\)</span>. Thus, the stabilizing subgroup of<span class="math inline">\(e\)</span> is the same as the stabilizingsubgroup of <span class="math inline">\(p\)</span>. From the previouscomment, we know that this subgroup is generated by those simplereflections whose mirrors contain <span class="math inline">\(p\)</span>. These mirrors are either <span class="math inline">\(m_i\)</span> (bisects <span class="math inline">\(e\)</span>), or those containing <span class="math inline">\(v_0\)</span> and orthogonal to <span class="math inline">\(m_i\)</span> (contain <span class="math inline">\(e\)</span>), so the stabilizing subgroup of <span class="math inline">\(e\)</span> is generated by <span class="math inline">\(\rho_i\)</span> and those simple reflections thatfix <span class="math inline">\(v_0\)</span> and commute with <span class="math inline">\(\rho_i\)</span>. In the case of the cube, we have<span class="math inline">\(H=\langle \rho_0,\rho_2\rangle\)</span>, so<span class="math inline">\(|H|=4\)</span> and <span class="math inline">\(|G/H|=12\)</span>, confirming that the cube has 12edges.</li><li>We then find a set of coset representatives of <span class="math inline">\(G/H\)</span> and apply them to <span class="math inline">\(e\)</span> to obtain all edges of type <span class="math inline">\(i\)</span>.</li></ol><p>To find all faces of type <span class="math inline">\((i,j)\)</span>,where <span class="math inline">\(i\neq j\)</span>, we use the sameprocedure. If at least one of <span class="math inline">\(m_i,m_j\)</span> is active, then the rotation<span class="math inline">\(r_{ij}=\rho_i\rho_j\)</span> generates aface <span class="math inline">\(f\)</span> of type <span class="math inline">\((i,j)\)</span>, which is invariant under <span class="math inline">\(\rho_i\)</span> and <span class="math inline">\(\rho_j\)</span>. However, if <span class="math inline">\(v_0\)</span> lies on exactly one of the twomirrors and they are perpendicular, we need to be careful. In this case,the stabilizing subgroup of <span class="math inline">\(f\)</span> isgenerated by <span class="math inline">\(\rho_i\)</span>, <span class="math inline">\(\rho_j\)</span>, and those generators that fix<span class="math inline">\(v_0\)</span> and commute with both <span class="math inline">\(\rho_i\)</span> and <span class="math inline">\(\rho_j\)</span>. We then find a set of cosetrepresentatives of <span class="math inline">\(G/H\)</span> and applythem to <span class="math inline">\(f\)</span> to obtain all faces oftype <span class="math inline">\((i,j)\)</span>.</p><p>Now the key step is to compute a set of coset representatives of<span class="math inline">\(G/H\)</span> for a finitely presented group<span class="math inline">\(G\)</span> and its subgroup <span class="math inline">\(H\)</span>, which is exactly what the Todd-Coxeteralgorithm does.</p><p>The Todd-Coxeter algorithm can be thought of as a Sudoku game wherethe table to complete is a dynamically growing 2D array <span class="math inline">\(T\)</span>. The rows of <span class="math inline">\(T\)</span> are labeled by the right cosets in<span class="math inline">\(G/H\)</span>, and the columns of <span class="math inline">\(T\)</span> are labeled by the generators of <span class="math inline">\(G\)</span>. Each entry <span class="math inline">\(T[i][j]\)</span> records the right coset obtainedby multiplying the <span class="math inline">\(j\)</span>-th generatoron the right of the <span class="math inline">\(i\)</span>-th coset. Thealgorithm uses the defining relations in the presentation of <span class="math inline">\(G\)</span> and <span class="math inline">\(H\)</span> as guidelines to find new cosets andfill their corresponding entries in <span class="math inline">\(T\)</span>. The game ends when all entries in<span class="math inline">\(T\)</span> are filled, and the coset in eachentry has a row in <span class="math inline">\(T\)</span> and satisfiesall relations. The resulting <span class="math inline">\(T\)</span> isthe adjacency matrix of the Schreier graph of <span class="math inline">\(G/H\)</span>, and one can easily obtain a completelist of word representations for all cosets in <span class="math inline">\(G/H\)</span>.</p><p>For a more detailed treatment of the Todd-Coxeter algorithm, pleaserefer to the Handbook of Computational Group Theory (HCGT) or otherrelated literature.</p><blockquote><p>Chapter 5, Handbook of Computational Group Theory, Holt, D., Eick,B., O’Brien, E.</p></blockquote><p>I will demonstrate below how the algorithm works using the cube as anexample:</p><blockquote><p><strong>Example</strong>: let <span class="math inline">\(G\)</span>be the symmetric group of the cube: <span class="math display">\[\begin{align*}G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2&amp;=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3\\&amp;=(\rho_0\rho_2)^2=1\rangle.\end{align*}\]</span>and subgroup <span class="math inline">\(H=\langle \rho_1,\rho_2\rangle\)</span>. Find a set of coset representatives of <span class="math inline">\(G/H\)</span>.</p></blockquote><p><strong>Our known relations</strong>:</p><ol type="1"><li>For each generator word <span class="math inline">\(w\)</span> of<span class="math inline">\(H\)</span>, it holds <span class="math inline">\(Hw=H\)</span>, i.e.&nbsp;<span class="math inline">\(H\rho_1=H\)</span> and <span class="math inline">\(H\rho_2=H\)</span>.</li><li>For any coset <span class="math inline">\(K\)</span> and anygenerator relation <span class="math inline">\(r\)</span> of <span class="math inline">\(G\)</span> it holds <span class="math inline">\(Kr=K\)</span>, i.e.&nbsp;<span class="math inline">\(K\rho_i^2=K,i=0,1,2\)</span>, and <span class="math inline">\(K(\rho_0\rho_1)^4=K(\rho_1\rho_2)^3=K(\rho_0\rho_2)^2=K.\)</span></li></ol><p>These relations can be stored in two lists, one for the relations in<span class="math inline">\(H\)</span> and one for the relations in<span class="math inline">\(G\)</span>, each relation can be furtherstored as an array of int type.</p><p>The first list stores the generator words of <span class="math inline">\(H\)</span>:</p><blockquote><ol start="0" type="1"><li>(1,) // <span class="math inline">\(\rho_1\)</span></li><li>(2,) // <span class="math inline">\(\rho_2\)</span></li></ol></blockquote><p>The second list stores the defining relations of <span class="math inline">\(G\)</span>:</p><blockquote><ol start="2" type="1"><li>(0, 0) // <span class="math inline">\(\rho_0^2=1\)</span></li><li>(1, 1) // <span class="math inline">\(\rho_1^2=1\)</span></li><li>(2, 2) // <span class="math inline">\(\rho_2^2=1\)</span></li><li>(0, 1, 0, 1, 0, 1, 0, 1) // (<span class="math inline">\(\rho_0\rho_1)^4=1\)</span></li><li>(1, 2, 1, 2, 1, 2) // (<span class="math inline">\(\rho_1\rho_2)^3=1\)</span></li><li>(0, 2, 0, 2) // (<span class="math inline">\(\rho_0\rho_2)^2=1\)</span></li></ol></blockquote><p>The relations are numbered from 0 to 7 for easy reference in thefollowing steps.</p><blockquote><p><strong>Note</strong>: When <span class="math inline">\(G\)</span> isnot represented as a Coxeter group, for example in the case of snubpolytopes, we need to consider the inverse of the generators as well,and they also occupy their own columns in <span class="math inline">\(T\)</span>. Therefore, the actual number ofcolumns in <span class="math inline">\(T\)</span> is twice the number ofgenerators. However, for Coxeter groups, all generators are involutions,so there is no need to insert columns for their inverses.</p></blockquote><p>Initially, the table <span class="math inline">\(T\)</span> has onlyone row, corresponding to the coset <span class="math inline">\(H\)</span> (which is the only coset we know atthis point).</p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>Here, the algorithm initializes <span class="math inline">\(H_0\)</span> to be the subgroup <span class="math inline">\(H\)</span> and checks if it satisfies allrelations in the first list. Once this check is done, the first list canbe discarded. Then, the algorithm scans all cosets of <span class="math inline">\(T\)</span> from top to bottom and verifies if thecurrent coset satisfies all relations in the second list. During thisprocess, new cosets may be defined and their rows are appended at theend of <span class="math inline">\(T\)</span>. However, it is importantto note that some cosets in the table may actually represent the samecoset, so care must be taken.</p><hr><p>Let’s start by scanning <span class="math inline">\(H_0\)</span> andchecking whether the relations in the first list are satisfied byit:</p><ol type="1"><li>For relation 0, we have <span class="math inline">\(H_0\rho_1=H_0\)</span>, i.e., <span class="math inline">\(T[0][1]=0\)</span>.</li><li>For relation 1, we have <span class="math inline">\(H_0\rho_2=H_0\)</span>, i.e., <span class="math inline">\(T[0][2]=0\)</span>.</li></ol><p><span class="math inline">\(T\)</span> is now updated as follows:</p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><p><strong>Now that <span class="math inline">\(H_0\)</span> satisfiesall relations in the first list, we can discard it and focus on checkingthe relations in the second list</strong>.</p><p>We move on to check the relations in the second list for <span class="math inline">\(H_0\)</span>:</p><p>(2). Relation 2 says <span class="math inline">\(H_0\rho_0^2=H_0\)</span>. Since we do not know<span class="math inline">\(H_0\rho_0\)</span> yet, we define it to be<span class="math inline">\(H_1\)</span>, fill in 1 in its entry <span class="math inline">\(T[0][0]\)</span>, and append a new row for <span class="math inline">\(H_1\)</span>:</p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><strong>Note that each time we define or find <span class="math inline">\(H_i\rho_j=H_k\)</span> for some <span class="math inline">\(i,j,k\)</span>, we automatically get the “dual”relation <span class="math inline">\(H_k\rho_j=H_i\)</span>. Therefore,we always fill in a pair of entries <span class="math inline">\(T[i][j]=k\)</span> and <span class="math inline">\(T[k][j]=i\)</span> at a time</strong>.</p><p>(3). Relations 3 and 4 are already satisfied, so we continue.</p><p>(4). Relation 5 says <span class="math inline">\(H_0\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1=H_0\)</span>.We already know <span class="math inline">\(H_0\rho_0=H_1\)</span>, but<span class="math inline">\(H_1\rho_1\)</span> is unknown, so we defineit to be <span class="math inline">\(H_2\)</span>. We fill in the twoentries <span class="math inline">\(T[1][3]=2\)</span> and <span class="math inline">\(T[2][3]=1\)</span> and append a new row for <span class="math inline">\(H_2\)</span>.</p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><span class="math inline">\(H_2\rho_0\)</span> is not yet defined, sowe set <span class="math inline">\(H_2\rho_0=H_3\)</span> and update thecorresponding entries in <span class="math inline">\(T\)</span>:</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>Continuing with the scan, we notice that <span class="math inline">\(H_3\rho_1\)</span> is unknown, and we might betempted to define it as a new coset <span class="math inline">\(H_4\)</span> and continue. However, this strategycan create many redundant cosets, leading to a rapid growth of <span class="math inline">\(T\)</span>. Instead, we scan the relation inreverse order, trying to fill the gaps without introducing new cosets.Recall that we scanned from left to right, and we arrived at thefollowing position: <span class="math display">\[H_0\rho_0\rho_1\rho_0(=H_3)\rho_1\rho_0\rho_1\rho_0\rho_1=H_0.\]</span>Now, scanning from right to left, we get <span class="math inline">\(H_0\rho_1\rho_0\rho_1\rho_0=H_3\)</span>, whichmeans that <span class="math display">\[H_0\rho_0\rho_1\rho_0(=H_3)\rho_1=H_0\rho_1\rho_0\rho_1\rho_0=H_3.\]</span> Thus, we have deduced that<span class="math inline">\(H_3\rho_1=H_3\)</span>, instead of definingit as a new coset. This technique is called a<strong>deduction</strong>, as described in the book HCGT. Therefore, weupdate <span class="math inline">\(T\)</span> accordingly:</p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><strong>So in the actual program we always scan a relation from bothends and define new cosets if necessary until they meet</strong>.</p><p>(5). Relation 6 is already satisfied, continue.</p><p>(6). Relation 7 says <span class="math inline">\(H_0\rho_0\rho_2\rho_0\rho_2=H_0\)</span>, scanningfrom both ends gives <span class="math display">\[H_0\rho_0(=H_1)\rho_2=H_0\rho_2\rho_0=H_1,\]</span>hence <span class="math inline">\(H_1\rho_2=H_1\)</span> and we makeanother deduction. <span class="math inline">\(T\)</span> nowbecomes</p><table><thead><tr><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>Now, <span class="math inline">\(H_0\)</span> satisfies all relationsin the two lists and the scanning of the first row is completed. We canmove on to begin scanning of the row for <span class="math inline">\(H_1\)</span>. Note the first list is nowdiscarded, and we will only check relations 2-7.</p><p>(1). Relations 2, 3, 4, and 5 are already satisfied. We can continueto the next relation. (2). Relation 6 says <span class="math inline">\(H_1\rho_1\rho_2\rho_1\rho_2\rho_1\rho_2=H_1\)</span>.We know that <span class="math inline">\(H_1\rho_1=H_2\)</span>, but<span class="math inline">\(H_2\rho_2\)</span> is unknown. Backwardscanning also gets stuck here: <span class="math display">\[H_1\rho_1(=H_2)\rho_2\rho_1=H_1\rho_2\rho_1\rho_2=H_2\rho_2.\]</span>So we define <span class="math inline">\(H_2\rho_2=H_4\)</span>. Then wehave <span class="math inline">\(H_4\rho_1=H_4\)</span>, and <span class="math inline">\(T\)</span> becomes:</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr></tbody></table><ol start="3" type="1"><li>Relation 7 is already satisfied for <span class="math inline">\(H_1\)</span>, so we can move on to scan the rowfor <span class="math inline">\(H_2\)</span>.</li></ol><hr><p>I’ll leave it as an exercise for you to complete the scanning of<span class="math inline">\(H_2\)</span>, <span class="math inline">\(H_3\)</span>, <span class="math inline">\(H_4\)</span>, and <span class="math inline">\(H_5\)</span>. These are relatively easy tasks.Once <span class="math inline">\(H_2\)</span> has been scanned, your<span class="math inline">\(T\)</span> should look like this:</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">3</td></tr></tbody></table><p>After completing the scanning of <span class="math inline">\(H_3\)</span>, your <span class="math inline">\(T\)</span> should be:</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr></tbody></table><p>After completing the scanning for <span class="math inline">\(H_4\)</span>, your <span class="math inline">\(T\)</span> should be:</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>And when we scan <span class="math inline">\(H_6\)</span>, we findthat relations 2-6 are already satisfied. From relation 7, <span class="math inline">\(H_6\rho_0\rho_2\rho_0\rho_2=H_6\)</span>, we get adeduction <span class="math inline">\(H_7\rho_2=H_7\)</span>, and <span class="math inline">\(T\)</span> is updated as follows:</p><table><thead><tr><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td></tr></tbody></table><p>One can check that <span class="math inline">\(H_7\)</span> satisfiesall relations in the second list, so no more cosets can be found and thegame is over.</p><p>The multiplication relations between these cosets can be obtainedusing breadth-first search:</p><p><span class="math display">\[\begin{array}{l}H_0 = H_0\cdot e,\\H_1=H_0\cdot\rho_0,\\H_2=H_1\cdot\rho_1=H_0\cdot\rho_0\rho_1,\\H_3=H_2\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0,\\H_4=H_2\cdot\rho_2=H_0\cdot\rho_0\rho_1\rho_2,\\H_5=H_3\cdot\rho_2=H_0\cdot \rho_0\rho_1\rho_0\rho_2,\\H_6=H_5\cdot\rho_1=H_0\cdot \rho_0\rho_1\rho_0\rho_2\rho_1,\\H_7=H_6\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0\rho_2\rho_1\rho_0.\end{array}\]</span></p><p>So a set of representatives can be chosen as</p><p><span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span> This is exactly what we have seen before.</p><blockquote><p><strong>Note</strong>: This example is a bit tedious, but it is stilla simple one because we did not encounter the case where two cosets inthe table are found to be the same (in the book HCGT, this is called a<strong>coincidence</strong>). When this occurs, the scanning must bepaused, and the control flow is jumped to handle this coincidence: a newstack <span class="math inline">\(q\)</span> is opened, and this pair ofcoincidences is pushed into <span class="math inline">\(q\)</span>.Then, one pair of coincidences is popped from <span class="math inline">\(q\)</span> at a time, their rows are merged, andnew coincidences that occur in the merging process are pushed into <span class="math inline">\(q\)</span>.</p></blockquote><h1 id="snub-polytopes">Snub polytopes</h1><p>Snub polytopes can be constructed by applying rotations in the fullsymmetry group to the initial vertex <span class="math inline">\(v_0\)</span>. In the case of the cube, we haveseen the full symmetry group <span class="math inline">\(G\)</span>is</p><p><span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p><span class="math inline">\(G\)</span> consists of 48 elements, halfof which are rotations, so totaling 24 rotations. These rotationsconstitute the symmetry group <span class="math inline">\(\widetilde{G}\)</span> of the snub cube, which canbe generated by three fundamental rotations: <span class="math inline">\(r_0=\rho_0\rho_1\)</span>, <span class="math inline">\(r_1=\rho_1\rho_2\)</span>, and <span class="math inline">\(r_2=\rho_0\rho_2\)</span>. Since <span class="math inline">\(r_0r_1=r_2\)</span>, it follows that <span class="math inline">\(\widetilde{G}\)</span> can be generated by only<span class="math inline">\(r_0\)</span> and <span class="math inline">\(r_1\)</span>.</p><p>A presentation of <span class="math inline">\(\widetilde{G}\)</span>is <span class="math display">\[\widetilde{G}=\langle r_0,r_1\ |\r_0^4=r_1^3=(r_0r_1)^2=1\rangle.\]</span> Using the Todd-Coxeteralgorithm, we can obtain a complete list of word representations of<span class="math inline">\(\widetilde{G}\)</span>:</p><p><span class="math display">\[\begin{array}{lll}e&amp;r_{0}&amp;r_{0}r_{0}\\r_{0}r_{0}r_{0}&amp;r_{1}&amp;r_{1}r_{1}\\r_{0}r_{1}&amp;r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{1}\\r_{0}r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}\\r_{1}r_{0}r_{0}&amp;r_{1}r_{0}r_{0}r_{0}&amp;r_{1}r_{1}r_{0}\\r_{1}r_{1}r_{0}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}\\r_{0}r_{0}r_{1}r_{1}r_{0}&amp;r_{1}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}r_{0}r_{1}r_{1}\\r_{1}r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{1}r_{0}r_{0}r_{1}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}r_{1}\end{array}\]</span></p><p>We choose the initial vertex <span class="math inline">\(v_0\)</span>so that it’s not on any of the three mirrors, and apply the above wordrepresentations of <span class="math inline">\(\widetilde{G}\)</span> to<span class="math inline">\(v_0\)</span>. This gives the 24 vertices ofthe snub cube.</p><p>To obtain the edges of the snub cube, the following steps can betaken:</p><ol type="1"><li>Each rotation <span class="math inline">\(r_i\,(i=0,1,2)\)</span>generates a base edge <span class="math inline">\(e\)</span>. These baseedges are in different orbits under the action of <span class="math inline">\(\widetilde{G}\)</span>.</li><li>The stabilizing subgroup of <span class="math inline">\(e\)</span>is <span class="math inline">\(H=\langle 1\rangle\)</span> if the orderof <span class="math inline">\(r_i\)</span> is greater than 2, or thecyclic group <span class="math inline">\(H=\langle r_i\rangle\)</span>if the order of <span class="math inline">\(r_i\)</span> is 2. The cosetrepresentatives of <span class="math inline">\(G/H\)</span> can becomputed, and applied to <span class="math inline">\(e\)</span> toobtain all other edges of type <span class="math inline">\(i\)</span>.</li></ol><p>The case of faces is slightly more involved:</p><ol type="1"><li><p>Each rotation <span class="math inline">\(r_i\,(i=0,1)\)</span>generates a base face <span class="math inline">\(f={v_0,r_i(v_0),\ldots, r_i^{m-1}(v_0)}\)</span> for <span class="math inline">\(m&gt;2\)</span>, where <span class="math inline">\(m\)</span> is the order of <span class="math inline">\(r_i\)</span>. For <span class="math inline">\(i=2\)</span>, <span class="math inline">\(m=2\)</span>, and <span class="math inline">\(f\)</span> is degenerated to an edge. Thestabilizing subgroup of <span class="math inline">\(f\)</span> is thecyclic group <span class="math inline">\(H=\langle r_i\rangle\)</span>.The coset representatives of <span class="math inline">\(G/H\)</span>can be computed, and applied to <span class="math inline">\(f\)</span>to obtain all other faces of type <span class="math inline">\(i\)</span>. For the snub cube, there are <span class="math inline">\(6\)</span> square faces generated by <span class="math inline">\(r_0\)</span> (since <span class="math inline">\(24/|\langle r_0\rangle|=24/4=6\)</span>), and<span class="math inline">\(8\)</span> triangle faces generated by <span class="math inline">\(r_1\)</span> (since <span class="math inline">\(24/|\langle r_1\rangle|=24/3=8\)</span>).</p></li><li><p>There is another type of triangle faces which comes from therelation <span class="math inline">\(r_0r_1=r_2\)</span>. Let’s considerthe three vertices <span class="math inline">\({v_0,v_0r_1,v_0r_2}\)</span>. We see that <span class="math inline">\((v_0, v_0r_1)\)</span> is an edge of type 1 and<span class="math inline">\((v_0, v_0r_2)\)</span> is an edge of type 2.But we also have <span class="math display">\[(v_0,v_0r_0)\xrightarrow{\ r_1\ }(v_0r_1, v_0r_0r_1) = (v_0r_1,v_0r_2).\]</span> That is, <span class="math inline">\((v_0r_1,v_0r_2)\)</span> is an edge of type 0 obtained by applying <span class="math inline">\(r_1\)</span> to the base edge <span class="math inline">\((v_0, v_0r_0)\)</span>. The stabilizing subgroupof this triangle must be <span class="math inline">\(\langle1\rangle\)</span> since all its three edgesare in different orbits. Thereforre, we have <span class="math inline">\(|\widetilde{G}|/1=24\)</span> triangle faces ofthis “mixed type”, which are not generated by any of the “fundamentalrotations”.</p></li></ol><p>So the snub cube has <span class="math inline">\(6+8+24=38\)</span>faces in total.</p><h1 id="star-polytopes">Star polytopes</h1><p>Most star polytopes can be generated using the Wythoff construction,but generally, it is not enough to use the method described abovedirectly. You also need to add an additional generating relation intothe group’s presentation.</p><p>To illustrate, let’s take the great dodecahedron as an example. ItsCoxeter-Dynkin diagram is shown below:</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/coxeter552.svg" width="250"></p><p>Therefore, the angles between the mirrors are <span class="math inline">\(\pi-2\pi/5, \pi/2, \pi-\pi/5\)</span>. If wecontinue with the previous analysis, we obtain the presentation of thesymmetry group as:</p><p><span class="math display">\[K = \langle\tau_0,\tau_1,\tau_2 \|\  \tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=(\tau_0\tau_2)^2=1\rangle.\]</span></p><p>This group is infinite, and since the quotient group of thestabilizer subgroup of <span class="math inline">\(v_0\)</span> is alsoinfinite, the Todd-Coxeter algorithm will not work here.</p><p>In fact, we just need to add another generating relation to thepresentation, namely <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>. With thisaddition, the presentation of the symmetry group becomes:</p><p><span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>Note that I intentionally used <span class="math inline">\(\tau\)</span> to represent reflections and <span class="math inline">\(K\)</span> to denote the symmetry group of thegreat dodecahedron. What’s happening here? Let’s take a look at thevideo:</p><video src="/images/polytopes/great-dodecahedron.mp4" controls=""></video><p>From the video, we can observe that the great dodecahedron and theicosahedron share the exact same set of vertices. However, it seems thatthe great dodecahedron can be obtained by digging some triangular holeson the surface of the icosahedron. In general, if the hole of astar-shaped polyhedron is a polygon with <span class="math inline">\(h\)</span> sides, the corresponding extra relationis given by <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^h=1\)</span>.</p><p>Let’s take a closer look at the fundamental region of the greatdodecahedron:</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/star.png" width="600"></p><p>The figure above shows <span class="math inline">\(\DeltaABC\)</span> as the fundamental domain of the icosahedron. Its internalangles are <span class="math inline">\(\angle CAB=\pi/5\)</span>，<span class="math inline">\(\angle CBA=\pi/2\)</span>，<span class="math inline">\(\angle ACB=\pi/3\)</span>. Reflections about thearcs <span class="math inline">\(BC\)</span>, <span class="math inline">\(AC\)</span>, and <span class="math inline">\(AB\)</span> are denoted by <span class="math inline">\(\rho_0\)</span>, <span class="math inline">\(\rho_1\)</span>, and <span class="math inline">\(\rho_2\)</span>, respectively. The presentation ofthe symmetry group of icosahedron, <span class="math inline">\(G\)</span>, can be expressed as follows: <span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^3=(\rho_1\rho_2)^5=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p>The great dodecahedron can be constructed as follows: we keep thevertices and edges of the icosahedron untouched, but change its faces.To do this we start a walk from vertex <span class="math inline">\(Q\)</span> and move along edge <span class="math inline">\(QA\)</span> to reach the next vertex <span class="math inline">\(A\)</span>. At <span class="math inline">\(A\)</span>, we skip the first edge on the right(<span class="math inline">\(AO\)</span>) and choose the second one,which is <span class="math inline">\(AK\)</span>, to follow and move tovertex <span class="math inline">\(K\)</span> (sorry for abusing thenotation <span class="math inline">\(K\)</span> here). We continuemoving in this way by always choosing the second edge to the right. Ittakes five steps to return to <span class="math inline">\(Q\)</span>,forming a pentagonal face of the great dodecahedron. By performing thisoperation for all edges of the icosahedron, we can generate all thefaces of the great dodecahedron.</p><p>This operaion is called <strong>faceting</strong>, it changes thefaces of a given polyhedron while preserving its vertices and edges.This is achieved by walking along the edges of the original polyhedronand choosing the <span class="math inline">\(k\)</span>-th edge to theright of the current path, where <span class="math inline">\(k\geq2\)</span> is a fixed integer. By repeating this process until a closedloop is formed, a new face is created. In our project, we use <span class="math inline">\(k=2\)</span>.</p><p>Let’s derive the relations between the symmetry groups <span class="math inline">\(G\)</span> and <span class="math inline">\(K\)</span>:</p><p>Consider the triangle <span class="math inline">\(\DeltaOAB\)</span>, which has internal angles <span class="math inline">\(\angle OAB=2\pi/5\)</span>, <span class="math inline">\(\angle OBA=\pi/2\)</span>, and <span class="math inline">\(\angle AOB=\pi/5\)</span>, and contains threecongruent triangles with the triangle <span class="math inline">\(\DeltaABC\)</span>. The reflections about its three edges <span class="math inline">\(OA\)</span>, <span class="math inline">\(OB\)</span>, and <span class="math inline">\(AB\)</span> are denoted by <span class="math inline">\(\tau_1=\rho_1\rho_2\rho_1\)</span>, <span class="math inline">\(\tau_0=\rho_0\)</span>, and <span class="math inline">\(\tau_2=\rho_2\)</span>.</p><p>In the language of group theory, the faceting operation <span class="math inline">\(\varphi_k\)</span> can be described astransforming the group <span class="math inline">\(G\)</span> intoanother group <span class="math inline">\(K\)</span>:</p><p><span class="math display">\[G=\langle\rho_0,\rho_1,\rho_2\rangle\xrightarrow{\ \varphi_k\}\langle\rho_0,\rho_1(\rho_2\rho_1)^{k-1},\rho_2\rangle=\langle\tau_0,\tau_1,\tau_2\rangle=K.\]</span></p><p>Usually, <span class="math inline">\(K\)</span> is a subgroup of<span class="math inline">\(G\)</span>, but in many cases, including thegreat dodecahedron here, <span class="math inline">\(G\)</span> and<span class="math inline">\(K\)</span> are the same group.</p><p>To see that <span class="math inline">\(K\)</span> is indeed thesymmetry group of the great dodecaheron, we can argue as follows:</p><p>Firstly, <span class="math inline">\(\langle\tau_1,\tau_2\rangle=\langle \rho_1,\rho_2\rangle\)</span> is thestabilizer subgroup of the vertex <span class="math inline">\(A\)</span>, so the great dodecahedron has the sameset of vertices as that of the icosahedron. However, <span class="math inline">\(\tau_1\tau_2\)</span> gives a rotation of <span class="math inline">\(4\pi/5\)</span>, which differs from <span class="math inline">\(\rho_1\rho_2\)</span> that gives a rotation of<span class="math inline">\(2\pi/5\)</span>. Consequently, the vertexconfiguration of the great dodecahedron forms a pentagram, whereas thatof the icosahedron forms a pentagon.</p><p>Secondly, the subgroup <span class="math inline">\(\langle\tau_0,\tau_2\rangle=\langle \rho_0,\rho_2\rangle\)</span> is thestabilizer of the edge <span class="math inline">\(AQ\)</span>. Thus,the great dodecahedron shares its edges with those of theicosahedron.</p><p>Thirdly, <span class="math inline">\(\langle\tau_0,\tau_1\rangle\)</span> is thestabilizer subgroup of one of the faces of the great dodecahedron. Notethat <span class="math inline">\(\tau_0\tau_1\)</span> is a rotation of<span class="math inline">\(2\pi/5\)</span> arounds <span class="math inline">\(O\)</span>. It maps the edge <span class="math inline">\(QA\)</span> to the edge <span class="math inline">\(AK\)</span>, corresponding to the operation ofselecting the <span class="math inline">\(k\)</span>-th edge to walk on.Repeatedly applying <span class="math inline">\(\tau_0\tau_1\)</span> to<span class="math inline">\(QA\)</span> will give the five edges of oneface of the great dodecahedron.</p><p>Let’s find out a hidden relation among <span class="math inline">\(\tau_0,\tau_1\)</span> and <span class="math inline">\(\tau_2\)</span>:</p><p>Note that <span class="math inline">\(\tau_1\tau_2\tau_1=\tau_1\rho_2\tau_1\)</span> isa reflection about <span class="math inline">\(AP\)</span>, and itscomposition with <span class="math inline">\(\tau_0=\rho_0\)</span> is arotation around the vertex <span class="math inline">\(P\)</span> by anangle of <span class="math inline">\(2\pi/3\)</span>, so <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>. Addingthis additional generating relation to the presentation of gives thecorrect presentation of <span class="math inline">\(K\)</span>:</p><p><span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>The remaining steps of the construction are identical to the previousones.</p><p>This extra relation has a geometric explanation: By applying thefaceting operation to the great dodecahedron again, we can restore ouricosahedron. We simply walk from <span class="math inline">\(Q\)</span>to <span class="math inline">\(A\)</span>, and when we reach <span class="math inline">\(A\)</span>, instead of selecting the edge <span class="math inline">\(AK\)</span> to continue moveing, we choose itsprevious one clockwise, which is <span class="math inline">\(AO\)</span>. Continuing to walk gives us back thetriangle face <span class="math inline">\(\Delta OAB\)</span> of theicosahedron. This correspondes to the exponent 3 in the extrarelation.</p><p>In terms of group theory, this can be expressed as <span class="math display">\[K=\langle\tau_0,\tau_1,\tau_2\rangle\xrightarrow{\ \varphi_2\}\langle\tau_0,\tau_1\tau_2\tau_1,\tau_2\rangle=\langle\rho_0,\rho_2\rho_1\rho_2,\rho_2\rangle=G.\]</span></p><p>One might wonder if there are more such relationships we haveoverlooked. However, since we know that <span class="math inline">\(K\)</span> is isomorphic to <span class="math inline">\(G\)</span> (though not proved in this article),there’s no cause for concern.</p><h1 id="appendix">Appendix</h1><p>I also added a script <code>run_coset_enumeration.py</code> forshowing how to compute the coset table of <span class="math inline">\(G/H\)</span> for a given finitely presented group<span class="math inline">\(G\)</span> and its subgroup <span class="math inline">\(H\)</span> (necessarily <span class="math inline">\(|G/H|&lt;\infty\)</span>). It assumes a<code>yaml</code> file as input which describes the presentation of<span class="math inline">\(G\)</span> and <span class="math inline">\(H\)</span>. An example format is</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">G8723</span><br><span class="hljs-attr">relators:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">a^8</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">b^7</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">(ab)^2</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">(Ab)^3</span><br><span class="hljs-attr">subgroup-generators:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">aa</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Ab</span><br></code></pre></td></tr></tbody></table></figure><p>Here we use the convention that uppercase means the inverse oflowercase, i.e.&nbsp;<span class="math inline">\(A=a^{-1},B=b^{-1}\)</span>.</p><p>So the presentation of this group is <span class="math display">\[G =\langle a, b\ |\ a^8=b^7=(ab)^2=(a^{-1}b)^3=1\rangle\]</span> and <span class="math inline">\(H=\langle a^2, a^{-1}b\rangle\)</span>.</p><p>Save this file as <code>G8723.yaml</code> and run </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python run_coset_enumeration.py G8723.yaml<br></code></pre></td></tr></tbody></table></figure> Theoutput should be (with some output omitted)<p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">           a    A    b    B<br>------------------------------<br>    1:     2    2    3    2<br>    2:     1    1    1    4<br>    3:     4    5    6    1<br>    4:     7    3    2    8<br>  ...    ...  ...  ...  ...<br>  ...    ...  ...  ...  ...<br>  ...    ...  ...  ...  ...<br>  446:   444  444  441  430<br>  447:   438  433  432  443<br>  448:   445  445  440  445<br></code></pre></td></tr></tbody></table></figure><p>so <span class="math inline">\(G/H\)</span> has 448 cosets.</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd Kemp 概率论课程笔记</title>
      <link href="todd-kemp/index.html"/>
      <url>todd-kemp/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="probability-motivation">1.1 Probability Motivation</h1><p>无要点</p><h1 id="sigma--fields">1.2 <span class="math inline">\(\sigma\)</span>-Fields</h1><p>介绍了 <span class="math inline">\(\sigma\)</span>-域的概念，以及最重要的 <span class="math inline">\(\sigma\)</span>-域的例子：拓扑空间中开集生成的 Borel 域。</p><h1 id="measures-definition-and-examples">2.1 Measures Definition andExamples</h1><p>介绍了可测空间，以及测度的定义和基本性质。</p><blockquote><p><strong>定义</strong>：设 <span class="math inline">\(\mathcal{F}\)</span> 是一个 <span class="math inline">\(\sigma\)</span>- 域，称 <span class="math inline">\(\mu:\ \mathcal{F}\to[0,\infty]\)</span>是测度，如果对任何可数多个不交并有 <span class="math inline">\(\mu(\uplus_{n=1}^\inftyE_n)=\sum_{n=1}^\infty\mu(E_n)\)</span> 成立。</p></blockquote><p>测度的三个基本性质：</p><ul><li>单调性：<span class="math inline">\(A\subseteq B\Rightarrow\mu(A)\leq\mu(B)\)</span>。</li><li>加法等式 <span class="math inline">\(\mu(A\cup B) + \mu(A\cap B) =\mu(A) + \mu(B)\)</span>。</li><li>次可数可加：<span class="math inline">\(\mu(\cup_{n=1}^\inftyE_n)\leq\sum_{n=1}^\infty\mu(E_n)\)</span>。</li></ul><p>此外如果 <span class="math inline">\(\{\mu_n\}_{n=1}^\infty\)</span>是一列测度，则它们的和 <span class="math inline">\(\mu=\sum\limits_{n=1}^\infty\mu_n\)</span>也是测度。</p><p>预告了接下来构造测度的过程：有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 预测度 <span class="math inline">\(\Rightarrow\)</span> ·测度。</p><h1 id="finitely-additive-measures">2.2 Finitely Additive Measures</h1><p>这一讲介绍了<strong>有限可加测度</strong>，<strong>预测度(pre-measure，即域上的可数可加测度)</strong>，<strong>半代数(semi-algebra)</strong> 等概念。</p><blockquote><p><strong>定义 1</strong>：</p><ol type="1"><li>域上的可数可加测度叫做 <strong>预测度</strong>。</li><li>域上的有限可加测度叫做 <strong>有限可加测度</strong>。</li></ol></blockquote><blockquote><p><strong>核心思想</strong>：半代数 <span class="math inline">\(\mathcal{S}\)</span> 上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数 <span class="math inline">\(\mathcal{A}\)</span> 上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数 <span class="math inline">\(\mathcal{A}\)</span> 上的可数可加测度 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\sigma\)</span>- 域上的可数可加测度。</p></blockquote><p>域 <span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度的基本性质：</p><ul><li>单调性、加法等式同可数可加的情形。</li><li><strong>超可数可加</strong>：如果 <span class="math inline">\(\{E_n\}_{n=1}^{\infty}\)</span>是一列不相交的集合，则 <span class="math inline">\(\mu(\uplus_{n=1}^\inftyE_n)\geq\sum_{n=1}^\infty\mu(E_n)\)</span>。这是由于单调性左边始终是右边部分和的上界。注意这里要求每个<span class="math inline">\(E_n\in\mathcal{A}\)</span> 以及 <span class="math inline">\(\mu(\uplus_{n=1}^\inftyE_n)\in\mathcal{A}\)</span>。</li></ul><blockquote><p><strong>定义</strong>：一个半代数 <span class="math inline">\(\mathcal{S}\)</span>是指满足如下条件的集合族：</p><ol type="1"><li><span class="math inline">\(\emptyset\in\mathcal{S}\)</span>。</li><li>若 <span class="math inline">\(A,\,B\in\mathcal{S}\)</span> 则 <span class="math inline">\(A\cap B\in\mathcal{S}\)</span>。</li><li>若 <span class="math inline">\(A\in\mathcal{S}\)</span> 则 <span class="math inline">\(A^c\)</span> 可以表示为 <span class="math inline">\(\mathcal{S}\)</span> 中有限多个成员的不交并。</li></ol></blockquote><p>半代数 <span class="math inline">\(\mathcal{S}\)</span> 生成一个代数<span class="math inline">\(\mathcal{A}\)</span>： <span class="math display">\[\mathcal{A}=\{\text{all finite disjoint unions ofsets from }\mathcal{S} \}.\]</span></p><p>第一步<strong>半代数 <span class="math inline">\(\mathcal{S}\)</span>上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数<span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度</strong>：这一步是显然的，只需要验证定义不依赖于 <span class="math inline">\(\mathcal{A}\)</span> 作为 <span class="math inline">\(\mathcal{S}\)</span>中集合不交并的表示方式即可。</p><p>第三步<strong>代数 <span class="math inline">\(\mathcal{A}\)</span>上的可数可加测度 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\sigma\)</span>-域上的可数可加测度</strong>：这一步总是可以做到的，由后面的测度扩张定理给出。</p><p>第二步<strong>代数 <span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数<span class="math inline">\(\mathcal{A}\)</span>上的可数可加测度</strong>：这一步并不总是可以做到。举个例子，在是整数集<span class="math inline">\(\mathbb{Z}\)</span> 的所有子集上定义如下测度<span class="math inline">\(\mu\)</span>：若子集 <span class="math inline">\(E\)</span> 或者 <span class="math inline">\(E^c\)</span> 之一是有限集，则规定 <span class="math inline">\(\mu(E)=0\)</span>，否则 <span class="math inline">\(\mu(E)=1\)</span>。此测度有限可加但不是可数可加，所以也不会有可数可加的扩张。</p><p>最重要的半代数 <span class="math inline">\(\mathcal{S}\)</span>的例子：所有形如 <span class="math inline">\(\{(a, b],-\infty\leqa&lt;b\leq \infty\}\)</span> 的半开区间。</p><p>任何单调函数 <span class="math inline">\(F\)</span>都可以给出其上的一个有限可加测度：<span class="math inline">\(F((a, b]))= F(b) - F(a)\)</span>，从而可以扩张为代数 <span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度。<strong>但是要使得这个测度是可数可加的，我们必须限制<span class="math inline">\(F\)</span>是右连续的</strong>，这样的测度叫做 Stieltjes 测度，会在下一讲介绍。</p><h1 id="stieltjes-premeasures">3.1 Stieltjes Premeasures</h1><p>本讲接着上一讲的内容，证明了当 <span class="math inline">\(F\)</span>单调且右连续时，<span class="math inline">\(\mu((a,b])=F(b)-F(a)\)</span> 确实给出 Borel 域<span class="math inline">\(\mathcal{A}\)</span>上的一个可数可加测度。当然 Borel 域还是太复杂了(虽然它们都是有限多个半开区间的不交并)，无法用可数可加的定义来验证。我们还是要回到由半开区间构成的半代数<span class="math inline">\(\mathcal{S}\)</span> 上。</p><p>我们要从有限可加推出可数可加，而有限可加蕴涵了可数<strong>超</strong>可加，所以我们还缺少可数<strong>次</strong>可加。而<span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>上的可数次可加实际上可以由 <span class="math inline">\(\mathcal{S}\)</span> 上的可数次可加给出：</p><blockquote><p><strong>引理</strong>：代数 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span> 上的有限可加测度<span class="math inline">\(\mu\)</span>是可数可加的，<strong>当且仅当它限制在 <span class="math inline">\(\mathcal{S}\)</span>上是次可数可加的</strong>。这个话需要仔细解释清楚：<span class="math inline">\(\mu\)</span> 在 <span class="math inline">\(\mathcal{S}\)</span> 上次可数可加是指如果 <span class="math inline">\(\{E_n\}\)</span> 是半代数 <span class="math inline">\(\mathcal{S}\)</span>中互不相交的集合，并且它们的可数并 <span class="math inline">\(\uplus_{n} E_n\)</span> 也在半代数 <span class="math inline">\(\mathcal{S}\)</span> 中，则 <span class="math inline">\(\mu(\uplus_nE_n)\leq\sum_n\mu(E_n)\)</span>。</p></blockquote><p><strong>证明概要</strong>：<span class="math inline">\(\Rightarrow\)</span>是显然的，可数可加必然蕴含次可数可加。</p><p><span class="math inline">\(\Leftarrow\)</span>：<span class="math inline">\(\mu\)</span> 作为 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>上的有限可加测度自然是超可数可加的，要证明它可数可加，只要再证明它次可数可加：即若<span class="math inline">\(\uplus_n A_n\)</span> 是 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>中的可数不交并，则 <span class="math inline">\(\mu(\uplus_nA_n)\leq\sum_n\mu(A_n)\)</span>。记住 <span class="math inline">\(\uplus_n A_n\)</span> 以及所有 <span class="math inline">\(A_n\)</span> 现在都是 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span> 中的元素，所以<span class="math inline">\(\uplus_n A_n = \uplus_{j=1}^NE_j\)</span>，其中 <span class="math inline">\(E_j\in\mathcal{S}\)</span>。于是 <span class="math display">\[E_j = \uplus_n (A_n\capE_j)=\uplus_n\uplus_{i=1}^{N_n}E_i^n\cap E_j.\]</span> 利用 <span class="math inline">\(\mu\)</span> 在 <span class="math inline">\(\mathcal{S}\)</span> 上的次可数可加性有 <span class="math display">\[\mu(E_j)\leq \sum_n\sum_{i=1}^{N_n}\mu(E_i^n\capE_j).\]</span> 再利用 <span class="math inline">\(\mu\)</span> 在 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span> 上的有限可加性有<span class="math display">\[\sum_{i=1}^{N_n}\mu(E_i^n\capE_j)=\mu(A_n\cap E_j).\]</span> 于是 <span class="math display">\[\mu(\uplus_jE_j)=\sum_{j=1}^N\mu(E_j)\leq\sum_{j=1}^N\sum_{n=1}^\infty\mu(A_n\capE_j)=\sum_{n=1}^\infty\sum_{j=1}^N\mu(A_n\capE_j)=\sum_{n=1}^\infty\mu(A_n).\]</span> 即为所证。</p><blockquote><p><strong>定理</strong>：由单调右连续的函数 <span class="math inline">\(F\)</span> 给出的半代数 <span class="math inline">\(\mathcal{S}=\{(a,b]\ -\infty\leqa&lt;b\leq\infty\}\)</span> 上的 Stieltjes测度是次可数可加的，因而由上面引理它给出 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>上的可数可加测度。</p></blockquote><p><strong>Todd-Kemp 的精彩证明讲解</strong>：设 <span class="math inline">\((a,b]=\uplus_{i=1}^\infty (a_i,b_i]\)</span>，我们要证明 <span class="math display">\[F(b)-F(a)=\mu((a,b])\leq\sum_{i=1}^\infty\mu((a_i,b_i])=\sum_{i=1}^\infty(F(b_i)-F(a_i)).\]</span> 我们可以先假设 <span class="math inline">\(a,b\)</span> 都是有限的。</p><p><strong>不要幻想可以给区间 <span class="math inline">\((a_i,b_i]\)</span>之间按照大小排顺序，它们可能有无穷多个聚点</strong>。</p><p><strong>想法是把 <span class="math inline">\((a, b]\)</span>缩小一点变成 <span class="math inline">\([a+\delta, b]\)</span>，把<span class="math inline">\((a_i,b_i]\)</span> 放大一点变成 <span class="math inline">\((a_i,b_i+\delta_i)\)</span>，这样可以使用紧集的有限开覆盖性质</strong>。从而存在<span class="math inline">\(N\)</span> 使得前 <span class="math inline">\(N\)</span> 个开区间就足以覆盖 <span class="math inline">\([a+\delta,b]\)</span>： <span class="math display">\[[a+\delta,b] \subseteq \cup_{j=1}^N (a_j,b_j+\delta_j).\]</span> 现在 <span class="math inline">\(\mu\)</span>作为一个有限可加测度，由于 <span class="math inline">\((a+\delta,b]\)</span> 被 <span class="math inline">\(\cup_{j=1}^N (a_j,b_j+\delta_j]\)</span> 覆盖，因而必然有 <span class="math display">\[\mu((a+\delta, b])\leq \sum_{j=1}^N \mu((a_j,b_j+\delta_j])\leq\sum_{j=1}^\infty \mu((a_j, b_j+\delta_j]).\]</span>上式左边等于 <span class="math inline">\(F(b)-F(a+\delta)\)</span>，<span class="math inline">\(\delta\)</span> 是任意正数，所以令其趋于 0 并利用<span class="math inline">\(F\)</span> 的右连续有 <span class="math inline">\(F(a+\delta)\downarrow F(a)\)</span>，所以上式变为<span class="math display">\[\mu((a, b])\leq\sum_{j=1}^\infty\mu((a_j,b_j+\delta_j])=\sum_{j=1}^\infty \mu((a_j, b_j]) + \sum_{j=1}^\infty\mu((b_j, b_j+\delta_j]).\]</span> 注意到 <span class="math inline">\(\delta_j\)</span> 也是任意的，并且 <span class="math inline">\(F\)</span> 右连续，所以对任何 <span class="math inline">\(\epsilon&gt;0\)</span> 我们可以取 <span class="math inline">\(\delta_j\)</span> 足够小，使得 <span class="math inline">\(F(b_j+\delta_j)- F(b_j) &lt;\epsilon/2^j\)</span>。于是 <span class="math display">\[\mu((a,b])\leq\sum_{j=1}^\infty\mu((a_j, b_j+\delta_j])=\sum_{j=1}^\infty\mu((a_j, b_j]) + \epsilon.\]</span> 由 <span class="math inline">\(\epsilon\)</span> 任意性定理得证。</p><h1 id="outer-measure">3.2 Outer Measure</h1><p>这一节介绍了外测度的概念。</p><p>如果我们有一个集合族 <span class="math inline">\(\mathcal{A}\)</span>(<span class="math inline">\(\mathcal{A}\)</span>一般是个代数)，以及其上的函数 <span class="math inline">\(\mu:\\mathcal{A}\to[0,+\infty]\)</span>，则我们可以定义 <span class="math inline">\(2^{\Omega}\)</span> 上的外测度 <span class="math inline">\(\mu^\ast\)</span> 为 <span class="math display">\[\mu^\ast(E) =\inf\left\{\sum_{n=1}^\infty\mu(E_n),\ E_n\in\mathcal{A},E\subset\bigcup_{n=1}^\infty E_n\right\}.\]</span> 外测度 <span class="math inline">\(\mu^\ast\)</span> 满足：</p><blockquote><ol type="1"><li><span class="math inline">\(\mu^\ast(\emptyset)=0\)</span>。</li><li>单调性。</li><li>次可数可加性。</li></ol></blockquote><p>Todd Kemp 视频里面提到 <span class="math inline">\(\mu^\ast\)</span>可以用来区别有限可加测度和预测度：</p><blockquote><ol type="1"><li>如果 <span class="math inline">\((\mu, \mathcal{A})\)</span>是预测度，则<strong>在 <span class="math inline">\(\sigma(\mathcal{A})\)</span> 上有 <span class="math inline">\(\mu(E)\leq\mu^\ast(E)\)</span>，并且在 <span class="math inline">\(\mathcal{A}\)</span> 上有 <span class="math inline">\(\mu=\mu^\ast\)</span></strong>。</li><li>如果 <span class="math inline">\((\mu, \mathcal{A})\)</span>是有限可加测度，则<strong>在 <span class="math inline">\(\mathcal{A}\)</span> 上有 <span class="math inline">\(\mu(E)\geq\mu^\ast(E)\)</span></strong>。</li></ol></blockquote><h1 id="radon-measures">5.1 Radon Measures</h1><p>本讲介绍了实直线上的 Radon 测度等价于 Stieltjes 测度。</p><p>Radon 测度是指对任何紧集 <span class="math inline">\(K\)</span> 有<span class="math inline">\(\mu(K)&lt;\infty\)</span>的测度。这种测度的分布函数必然是单调、右连续的，从而根据之前介绍的预测度和测度扩张定理给出了实直线上的一个可数可加测度。</p><h1 id="random-variables-motivation">6.1 Random VariablesMotivation</h1><p>本节介绍了随机变量，分布函数的概念。样本空间 <span class="math inline">\(\Omega\)</span> (modelling space)是难以接触到的，我们对其的观测是通过随机变量来进行的。</p><p>随机变量 <span class="math inline">\(X\)</span> 的分布函数为 <span class="math inline">\(F(t) = \mathbb{P}(X\leq t),\,t\in\overline{\mathbb{R}}\)</span>。<span class="math inline">\(F(t)\)</span> 是单调递增且右连续的。</p><h1 id="riemann-stieltjes-integration">7.2 Riemann-StieltjesIntegration</h1><p>无要点。</p><h1 id="the-radon-nikodym-theorem">11.1 The Radon-Nikodym Theorem</h1><p>本讲介绍了 Radon-Nikodym 定理，不过没有给出证明。</p><p><strong>Motivation</strong>: 设 <span class="math inline">\(\mu,\nu\)</span> 是两个测度，是否存在非负可测函数<span class="math inline">\(\rho\)</span> 使得 <span class="math inline">\(\nu(A)=\int_A\rho\,\mathrm{d}\mu\)</span>对任何可测集 <span class="math inline">\(A\)</span> 成立？</p><p><strong>必要条件</strong>：<span class="math inline">\(\mu(A)=0\Rightarrow\nu(A)=0\)</span>。这时我们称<span class="math inline">\(\nu\)</span> 关于 <span class="math inline">\(\mu\)</span> <strong>绝对连续</strong>，记作 <span class="math inline">\(\nu\ll\mu\)</span>。</p><p>此条件同样也是充分的：若 <span class="math inline">\(\nu\)</span>关于 <span class="math inline">\(\mu\)</span> 绝对连续，则存在 <span class="math inline">\(\rho\)</span> 使得 <span class="math inline">\(\rho=\dfrac{\mathrm{d}\nu}{\mathrm{d}\mu}\)</span>。</p><p><strong>奇异连续测度的例子</strong>：Cantor 函数 (devilstaircase)。<a href="https://www.youtube.com/watch?v=dQXVn7pFsVI">YouTube科普</a>。此函数没有点质量，也没有密度函数，但是确实给出一个全质量为 1的概率测度。</p><ul><li>此函数是连续递增的，所以是一个分布函数。</li><li>此函数是连续的，所以没有点质量，即单个点的测度是 0。</li><li>此函数是奇异的，因为它在除去 Cantor集对应的点之外几乎处处是常数。</li></ul><h1 id="dynkins-multiplicative-systems-theorem">14.1 Dynkin’sMultiplicative Systems Theorem</h1><p>本讲介绍了 Dynkin <span class="math inline">\(\pi-\lambda\)</span>定理的函数形式的版本。</p><blockquote><p><strong>定义</strong>：设 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 是一个可测空间，称<span class="math inline">\(f\)</span> 是一个关于 <span class="math inline">\(\mathcal{F}\)</span> 可测的有界函数，如果存在<span class="math inline">\(M&gt;0\)</span> 使得 <span class="math inline">\(|f|\leq M\mathrm{a.e.}\)</span> 成立。记 <span class="math inline">\(\mathbb{B}(\Omega,\mathcal{F})\)</span>为全体这样的有界函数构成的向量空间。若 <span class="math inline">\(\{f_n\}\in\mathbb{B}(M,\mathcal{F})\)</span> 满足<span class="math inline">\(|f_n|\leq M\mathrm{a.e.}\)</span> 并且 <span class="math inline">\(f_n\to f\mathrm{a.e.}\)</span>，就称 <span class="math inline">\(f_n\)</span> <strong>一致有界收敛到 <span class="math inline">\(f\)</span></strong>。</p></blockquote><blockquote><p><strong>定理</strong>：设 <span class="math inline">\(\mathcal{I}\subseteq\mathcal{F}\)</span> 是一个<span class="math inline">\(\pi\)</span>- 系，设 <span class="math inline">\(\mathbb{H}(\mathcal{I})\subseteq\mathbb{B}(\Omega,\mathcal{F})\)</span>满足如下条件：</p><ol type="1"><li><span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span>是一个向量空间。</li><li><span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span> 包含<span class="math inline">\(\Omega\)</span> 上的常函数 <span class="math inline">\(\mathbb{1}\)</span>。</li><li>若 <span class="math inline">\(\{f_n\}\)</span> 是 <span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span>中的可测函数序列，且 <span class="math inline">\(f_n\)</span>一致有界收敛到 <span class="math inline">\(f\)</span>，则 <span class="math inline">\(f\in\mathbb{H}(\mathcal{I})\)</span>。</li><li><span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span> 包含<span class="math inline">\(\mathcal{I}\)</span> 中的所有指标函数 <span class="math inline">\(\mathbb{1}_{A},\,A\in\mathcal{I}\)</span>。</li></ol><p><strong>结论</strong>：<span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span> 包含所有关于<span class="math inline">\(\sigma(\mathcal{I})\)</span>-可测的有界函数。</p></blockquote><p><strong>证明概要</strong>：设 <span class="math display">\[\mathcal{A}=\{A\in\mathcal{F}:\\mathbb{1}_A\in\mathbb{H}(\mathcal{I})\}.\]</span></p><ul><li>由 2 <span class="math inline">\(\Omega\in\mathcal{A}\)</span>。</li><li>由 1, 2 结合有若 <span class="math inline">\(A\in\mathcal{A}\)</span> 则 <span class="math inline">\(A^c\in\mathcal{A}\)</span>。</li><li>由 3 有若 <span class="math inline">\(\{A_n\}\in\mathcal{A}\)</span>，<span class="math inline">\(A_n\uparrow\)</span> 则 <span class="math inline">\(\cup_{n}A_n\in\mathcal{A}\)</span>。</li></ul><p>于是 <span class="math inline">\(\mathcal{A}\)</span> 是一个 <span class="math inline">\(\lambda\)</span>- 系，并且由 4 有 <span class="math inline">\(\mathcal{A}\supseteq\mathcal{I}\)</span>，从而<span class="math inline">\(\mathcal{A}\supseteq\sigma(\mathcal{I})\)</span>。于是<span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span>包含所有形如 <span class="math inline">\(\mathbb{1}_A,\,A\in\sigma(\mathcal{I})\)</span>的指标函数，也就包含所有 <span class="math inline">\(\sigma(\mathcal{I})\)</span>上的简单可测函数，从而包含它们的所有一致有界极限，即全体 <span class="math inline">\(\sigma(\mathcal{I})\)</span>- 可测的有界函数。</p><p><strong>补充</strong>：条件 3 其实可以减弱为 <span class="math inline">\(\{f_n\}\)</span> 是非负可测函数序列，且 <span class="math inline">\(f_n\uparrow f\)</span>，<span class="math inline">\(f\)</span> 有界。这样我们首先得到 <span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span> 包含所有 <span class="math inline">\(\sigma(\mathcal{I})\)</span>上的非负简单函数，因而包含所有的非负有界可测函数，而对任何一般的 <span class="math inline">\(\sigma(\mathcal{I})\)</span> 有界可测函数 <span class="math inline">\(f\)</span>，<span class="math inline">\(f^{\pm}\)</span> 都是 <span class="math inline">\(\sigma(\mathcal{I})\)</span>上的非负有界可测函数，因而 <span class="math inline">\(f^{\pm}\)</span>和它们的差 <span class="math inline">\(f=f^+-f^-\)</span> 都属于 <span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span>。</p><h1 id="product-measure">14.2 Product Measure</h1><p>本讲介绍了乘积测度的构造。<strong>记住乘积测度的构造是用到重积分的</strong>。</p><p><strong>可测空间的乘积</strong>：设 <span class="math inline">\((\Omega_1,\mathcal{F_1}),\,(\Omega_2,\mathcal{F_2})\)</span>是两个可测空间，其乘积空间定义为 <span class="math inline">\((\Omega_1\times\Omega_2,\,\sigma(\mathcal{F}_1\times\mathcal{F}_2))\)</span>。其中<span class="math inline">\(\mathcal{F}_1\otimes\mathcal{F}_2=\sigma(\mathcal{F}_1\times\mathcal{F}_2)\)</span>是由所有形如 <span class="math inline">\(\{A_1\times A_2,A_i\in\mathcal{F}_i\}\)</span> 的集合生成的 <span class="math inline">\(\sigma\)</span>- 域。</p><p><span class="math inline">\(\mathcal{F}_1\otimes\mathcal{F}_2\)</span>还有一种等价的刻画：它是使得投影映射 <span class="math inline">\(\pi_i(\omega_1,\omega_2)=\omega_i\)</span>均可测的最小 <span class="math inline">\(\sigma\)</span>- 域。</p><blockquote><p><strong>引理</strong>：随机向量 <span class="math inline">\(f:(\Omega,\mathcal{F})\to(\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>是可测的，当且仅当其每个分量 <span class="math inline">\(f_i\)</span>是可测的。</p></blockquote><p><span class="math inline">\(\Rightarrow\)</span>: 每个 <span class="math inline">\(f_i=\pi_i\circ f\)</span>作为两个可测映射的复合当然是可测的。</p><p><span class="math inline">\(\Leftarrow\)</span>: 本质是证明如果每个<span class="math inline">\(X_i\)</span> 都是随机变量，则 <span class="math inline">\(X=(X_1,\ldots,X_n)\)</span> 是随机向量。对任何形如<span class="math inline">\(E=E_i\times_{j\nei}\mathcal{B}_i(\mathbb{R})\)</span> 的集合，<span class="math inline">\(X^{-1}(E) =\{\omega\in\Omega: X_i(\omega)\inE_i\}\)</span> 是可测集，而这样的 <span class="math inline">\(E\)</span>生成了 <span class="math inline">\(\mathcal{B}(\mathbb{R}^d)\)</span>，所以 <span class="math inline">\(X^{-1}(E)\)</span> 对任何 <span class="math inline">\(E\subset\mathcal{B}(\mathbb{R}^d)\)</span>都可测。结论得证。</p><p>如果每个 <span class="math inline">\((\Omega_i,\mathcal{F}_i)\)</span>还是测度空间，其上的测度为 <span class="math inline">\(\mu_i\)</span>，则我们可以在 <span class="math inline">\((\Omega_1\times\Omega_2,\mathcal{F}_1\otimes\mathcal{F}_2)\)</span>上定义测度 <span class="math inline">\(\mu_1\otimes\mu_2\)</span> 使得<span class="math inline">\((\mu_1\otimes\mu_2)(E_1\timesE_2)=\mu_1(E_1)\mu_2(E_2)\)</span> 对任何 <span class="math inline">\(E_i\in\mathcal{F}_i,\, i=1,2\)</span> 成立。</p><p>实际上我们可以让这个乘积测度满足</p><p><span class="math display">\[\int_{\Omega_1\times\Omega_2}f_1\otimesf_2\mathrm{d}(\mu_1\otimes\mu_2) =\int_{\Omega_1}f_1\mathrm{d}\mu_1\cdot\int_{\Omega_2}f_2\mathrm{d}\mu_2.\]</span></p><p>考虑满足如下条件的乘积空间 <span class="math inline">\(\Omega_1\times\Omega_2\)</span> 上的可测函数 <span class="math inline">\(f\)</span>:</p><blockquote><ol type="1"><li><span class="math inline">\(\omega_1\tof(\omega_1,\omega_2)\)</span> 对任何 <span class="math inline">\(\omega_2\)</span> 都是可测函数。</li><li><span class="math inline">\(\omega_2\tof(\omega_1,\omega_2)\)</span> 对任何 <span class="math inline">\(\omega_1\)</span> 都是可测函数。</li><li><span class="math inline">\(\omega_1\to\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2(\mathrm{d}\omega_2)\)</span> 是<span class="math inline">\(\mathcal{F}_1/\mathcal{B}(\overline{\mathbb{R}})\)</span>可测函数。注意这个积分值可能是无穷。</li><li><span class="math inline">\(\omega_2\to\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1(\mathrm{d}\omega_1)\)</span> 是<span class="math inline">\(\mathcal{F}_2/\mathcal{B}(\overline{\mathbb{R}})\)</span>可测函数。</li><li><span class="math display">\[\int_{\Omega_1}\left(\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2(\mathrm{d}\omega_2)\right)\mu_1(\mathrm{d}\omega_1)=\int_{\Omega_2}\left(\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1(\mathrm{d}\omega_1)\right)\mu_2(\mathrm{d}\omega_2).\]</span></li></ol></blockquote><p>容易验证对所有形如 <span class="math inline">\(f_1\otimesf_2\)</span> 的函数它们满足上面的性质。它们构成一个乘法系，包含所有形如<span class="math inline">\(\mathbb{1}_{E_1}\otimes\mathbb{1}_{E_2}\)</span>的函数，然后上面的条件对函数列的有界极限仍然成立。根据函数版本的 Dynkin定理，上面的条件对所有有界可测函数，或者非负可测函数都成立。</p><p>由此我们可以定义乘积空间中的测度为</p><p><span class="math display">\[\mu(E)=\int_{\Omega_1}\left(\int_{\Omega_2}\mathbb{1}_{E}\mu_2(\mathrm{d}\omega_2)\right)\mu_1(\mathrm{d}\omega_1)=\int_{\Omega_2}\left(\int_{\Omega_1}\mathbb{1}_{E}\mu_1(\mathrm{d}\omega_1)\right)\mu_2(\mathrm{d}\omega_2).\]</span>不难验证这样定义的积分是有限可加的(积分的线性性质)，可以取单调上升的极限，所以是可数可加的，并且当 <span class="math inline">\(E\)</span> 形如 <span class="math inline">\(E_1\times E_2\)</span> 时有 <span class="math inline">\(\mu(E)=\mu_1(E_1)\mu_2(E_2)\)</span>，从而确实给出符合要求的乘积测度。</p><h1 id="kolmogorovs-0-1-law">17.1 Kolmogorov’s 0-1 Law</h1><p>本讲介绍了独立随机变量序列的尾事件，以及 Kolmogrov 0-1 律。</p><p>设 <span class="math inline">\(\{X_n\}\)</span> 是独立的随机变量序列(不是两两独立，而是任何有限多个都独立)称 <span class="math inline">\(\mathcal{T}=\cap_{n=1}^\infty\sigma(X_n,X_{n+1},\ldots)\)</span>为尾事件域。</p><blockquote><p><strong>Kolmogrov 0-1 律</strong>：对任何 <span class="math inline">\(A\in\mathcal{T}\)</span> 有 <span class="math inline">\(\mathbb{P}(A)\in\{0,1\}\)</span>。</p></blockquote><p><strong>证明概要</strong>：</p><ul><li><span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span> 和 <span class="math inline">\(\sigma(X_{n+1},X_{n+2},\ldots)\)</span>是独立的。因为考虑如下两个集合族： <span class="math display">\[\{\text{all finite intersections like }\cap A_i,A_i\in\sigma(X_i),i=1,2,\ldots,n\}.\]</span> <span class="math display">\[\{\text{all finite intersections like }\cap A_j,A_j\in\sigma(X_j),j=n+1,n+2,\ldots\}.\]</span> 这俩都是 <span class="math inline">\(\pi\)</span>- 系且互相独立，所以它们生成的 <span class="math inline">\(\sigma\)</span>- 域也独立。前者可以生成 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span>，后者可以生成<span class="math inline">\(\sigma(X_{n+1},X_{n+2},\ldots)\)</span>。</li><li>于是 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span> 和<span class="math inline">\(\mathcal{T}\)</span> 是独立的。</li><li>于是 <span class="math inline">\(\pi\)</span>- 系 <span class="math inline">\(\cup_{n=1}^\infty\sigma(X_1,\ldots,X_n)\)</span>和 <span class="math inline">\(\mathcal{T}\)</span> 是独立的。</li><li>于是 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\sigma(X_1,\ldots,X_n,\ldots)\)</span> 和 <span class="math inline">\(\mathcal{T}\)</span> 独立，从而 <span class="math inline">\(\mathcal{T}\)</span> 和 <span class="math inline">\(\mathcal{T}\)</span> 独立，从而得证。</li></ul><h1 id="convolution">17.2 Convolution</h1><p>本讲介绍了概率测度之间的卷积。</p><blockquote><p><strong>定义</strong>：两个概率测度 <span class="math inline">\(\mu,\nu\)</span> 之间的卷积定义为 <span class="math display">\[\mu\ast \nu(B) =\int_{\mathbb{R}^d\times\mathbb{R}^d}\mathbb{1}_B(x+y)\mu\otimes\nu(\,\mathrm{d}x\,\mathrm{d}y)=\int_{\mathbb{R}^d}\mu(B-y)\vdx{y}.\]</span></p></blockquote><h1 id="strong-law-of-large-numbers-part-1">18.1 Strong Law of LargeNumbers, Part 1</h1><p>本讲介绍了 Kolmogrov 强大数定理的表述，以及证明思想。</p><p>基本思想是利用截断的序列与原序列是尾等价的，先对截断的序列证明结论，再回到原序列。</p><blockquote><p><strong>强大数定理</strong>：设 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span> 的 <span class="math inline">\(L^1\)</span> 序列且 <span class="math inline">\(\mathbb{E}[X_n]=a\)</span>，则 <span class="math inline">\(\dfrac{S_n}{n}\to a, \mathrm{a.e.}\)</span>。</p></blockquote><p><strong>重要技巧</strong>：同一个概率空间上的两个序列 <span class="math inline">\(\{X_n\},\,\{Y_n\}\)</span> 称作是尾等价的，如果<span class="math inline">\(\sum_{n=1}^\infty\mathbb{P}(X_n\neY_n)&lt;\infty\)</span>。</p><p>这样根据 Borel-Cantelli 引理，<span class="math inline">\(\{X_n\neY_n,\mathrm{i.o.}\}\)</span> 是零测集，从而 <span class="math inline">\(X_n=Y_n\)</span>最终会几乎处处成立，从而二者的极限行为一致。即如果 <span class="math inline">\(b_n\uparrow\infty\)</span>，则 <span class="math display">\[\lim\limits_{n\to\infty}\dfrac{1}{b_n}\sum_{j=1}^nX_n = X \Leftrightarrow\lim\limits_{n\to\infty}\dfrac{1}{b_n}\sum_{j=1}^n Y_n = X.\]</span></p><p><strong>截断的序列和原序列是尾等价的</strong></p><blockquote><p><strong>引理</strong>：若 <span class="math inline">\(X\inL^1,\,\epsilon&gt;0\)</span>，则 <span class="math display">\[\sum_{n=1}^\infty\mathbb{P}(X\geq n\epsilon)\leq\frac{1}{\epsilon}\mathbb{E}|X|.\]</span></p></blockquote><p>值得与 Markov 不等式比较一下，这个不等式更强。</p><p><strong>证明概要</strong>：只要证明结论对 <span class="math inline">\(\epsilon=1\)</span> 成立即可。而这非常显然：</p><p><span class="math display">\[X\geq\lfloor X\rfloor =\sum_{n=1}^\infty \mathbb{1}_{\{n\leq X\}}.\]</span></p><blockquote><p><strong>推论</strong>：若 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span> 的 <span class="math inline">\(L^1\)</span> 序列，令 <span class="math inline">\(Y_n = X_n\mathbb{1}_{\{|X_n|\leq n\}}\)</span>，则<span class="math inline">\(\{Y_n\}\)</span> 与 <span class="math inline">\(\{X_n\}\)</span> 是尾等价的。</p></blockquote><p>于是接下来的任务就是证明 <span class="math inline">\(S_n^Y =\dfrac{Y_1+\cdots+Y_n}{n}\to a,\,\mathrm{a.e.}\)</span>。</p><h1 id="kolmogorovs-convergence-criterion">18.2 Kolmogorov’s ConvergenceCriterion</h1><p>本讲介绍了 Kolmogrov 收敛判定：独立随机变量序列如果是 <span class="math inline">\(L^2\)</span> 意义下的 Cauchy序列，则也是逐点收敛意义下的 Cauchy 序列。</p><p>在上一讲中，我们通过把 <span class="math inline">\(L^1\)</span>的序列 <span class="math inline">\(\{X_n\}\)</span> 取截断得到 <span class="math inline">\(Y_n=X_n\mathbb{1}_{\{|X_n|\leqn\}}\)</span>，这是一个与 <span class="math inline">\(\{X_n\}\)</span>尾等价的序列。从而只要证明 <span class="math inline">\(\frac{\sum_{k=1}^n Y_k}{n}\toa\)</span>。为此我们分两步：</p><ol type="1"><li>证明 <span class="math inline">\(\frac{\sum_{k=1}^n(Y_k-\mathbb{E}Y_k)}{n}\to 0\)</span>。</li><li>证明 <span class="math inline">\(\mathbb{E}Y_n\to a\)</span>，从而<span class="math inline">\(\frac{\sum_{k=1}^n\mathbb{E}Y_k}{n}\toa\)</span>。结合上一点就证明了强大数定理。</li></ol><p>2 用控制收敛定理很容易得出，所以关键是证明 1。</p><p>我们首先证明 <span class="math inline">\(\sum_{k=1}^n\frac{Y_k-\mathbb{E}Y_k}{n}\)</span> 是个收敛的序列，然后用下一讲介绍的Kronecker 引理来得出 <span class="math inline">\(\frac{\sum_{k=1}^n(Y_k-\mathbb{E}Y_k)}{n}\to 0\)</span>。</p><blockquote><p><strong>Kolmogrov 收敛判定</strong>：若 <span class="math inline">\(\mathrm{i.i.d}\)</span> 序列 <span class="math inline">\(Z_n\)</span> 满足 <span class="math inline">\(\sum\mathrm{Var}(Z_n)&lt;\infty\)</span> 则 <span class="math inline">\(\sum(Z_n-\mathbb{E}Z_n)\)</span>几乎处处收敛。</p></blockquote><p><strong>证明概要</strong>：我们可以不妨假设 <span class="math inline">\(\mathbb{E}Z_n=0\)</span>，则问题变为若 <span class="math inline">\(\mathrm{i.i.d}\)</span> 序列 <span class="math inline">\(\sum\mathbb{E}|Z_n|^2\)</span> 收敛，则 <span class="math inline">\(\sum Z_n\)</span> 几乎处处收敛。</p><p>记 <span class="math inline">\(S_n=\sum_{k=1}^nZ_k\)</span>，利用Markov 不等式不难有 <span class="math display">\[\mathbb{P}(|S_n|\geq\epsilon)\leq\frac{1}{\epsilon^2}\mathbb{E}[S_n^2].\]</span>有意思的是，上面的不等式中在左边把 <span class="math inline">\(S_n\)</span> 换成 <span class="math inline">\(S_n^\ast=\max_{1\leq i\leq n}|S_n|\)</span>仍然成立：</p><blockquote><p><strong>Kolmogrov 极大不等式</strong>：对任何正数 <span class="math inline">\(\epsilon&gt;0\)</span> 有 <span class="math display">\[\mathbb{P}(S_n^\ast\geq\epsilon)\leq\frac{1}{\epsilon^2}\mathbb{E}[S_n]^2.\]</span></p></blockquote><p>证明：记 <span class="math inline">\(\tau=\inf\{j\in\mathbb{Z}_{\geq1}:\|S_j|\geq\epsilon\}\)</span>。则 <span class="math inline">\(\mathbb{P}(S_n^\ast\geq\epsilon)=\mathbb{P}(\tau\leqn)\)</span>。 <span class="math display">\[\mathbb{E}[S_n^2:\S_n^\ast\geq\epsilon]=\mathbb{E}[S_n^2:\ \tau\leqn]=\sum_{k=1}^n\mathbb{E}[S_n^2:\ \tau=k].\]</span> 使用技巧 <span class="math inline">\(S_n^2=(S_k + S_n - S_k)^2\)</span> 我们有 <span class="math display">\[\mathbb{E}[S_n^2:\ \tau=k] = \mathbb{E}[S_k^2 +(S_n-S_k)^2:\ \tau=k] + \mathbb{E}[2S_k(S_n-S_k):\ \tau=k].\]</span>注意到第二项 <span class="math display">\[\mathbb{E}[2S_k(S_n-S_k):\\tau=k] =\mathbb{E}[2S_k\mathbb{1}_{\{\tau=k\}}(S_n-S_k)]=2\mathbb{E}[S_k\mathbb{1}_{\{\tau=k\}}]\cdot\mathbb{E}[S_n-S_k]=0.\]</span>所以 <span class="math display">\[\mathbb{E}[S_n^2]\geq\sum_{k=1}^n\mathbb{E}[S_n^2:\\tau=k] \geq \sum_{k=1}^n\mathbb{E}[S_k^2:\\tau=k]\geq\epsilon^2\sum_{k=1}^n\mathbb{E}\mathbb{1}_{\{\tau=k\}}=\epsilon^2\mathbb{P}(\tau\leqn)=\epsilon^2 \mathbb{P}(S_n^\ast\geq\epsilon).\]</span></p><p>回到 Kolmogrov 收敛定理的证明。</p><p>Kolmogrov 极大不等式告诉我们</p><p><span class="math display">\[\mathbb{P}(\max_{n\leq k \leq m}|S_k -S_n|\geq\epsilon)\leq\frac{1}{\epsilon^2}\mathbb{E}|S_m-S_n|^2=\frac{1}{\epsilon^2}\sum_{k=n}^m\mathbb{E}Z_k^2.\]</span> 令 <span class="math inline">\(m\to\infty\)</span> 我们有 <span class="math display">\[\mathbb{P}(\sup_{k\geq n}|S_k -S_n|\geq\epsilon)\leq\frac{1}{\epsilon^2}\sum_{k=n}^\infty\mathbb{E}Z_k^2.\]</span> 于是 <span class="math display">\[\mathbb{P}(\sup_{k,j\geq n}|S_k -S_j|\geq\epsilon)\leq\frac{2}{\epsilon^2}\sum_{k=n}^\infty\mathbb{E}Z_k^2.\]</span> 所以随机变量序列 <span class="math inline">\(\delta_n = \sup_{k,j\geq n}|S_k - S_j|\)</span>依测度收敛到 0。但是 <span class="math inline">\(\delta_n\)</span>是一个单调下降的非负序列，它必然有一个几乎处处收敛的极限 <span class="math inline">\(\delta\)</span>，<span class="math inline">\(\delta\)</span> 也非负。<span class="math inline">\(\delta\)</span> 依测度收敛到 0，又几乎处处收敛到<span class="math inline">\(\delta\)</span>，那必须 <span class="math inline">\(\delta\)</span> 几乎处处为 0，即 <span class="math inline">\(\{S_n\}\)</span> 是 Cauchy 序列。</p><h1 id="strong-law-of-large-numbers-part-2">19.1 Strong Law of LargeNumbers, Part 2</h1><p>介绍了证明强大数定理的第二个工具：Kronecker 引理。</p><blockquote><p><strong>Kronecker 引理</strong>：若 <span class="math inline">\(\{b_k\}\uparrow\infty\)</span> 且 <span class="math inline">\(\lim\limits_{n\to\infty}\sum\limits_{k=1}^n\dfrac{x_k}{b_k}\)</span>存在，则 <span class="math inline">\(\lim\limits_{n\to\infty}\dfrac{1}{b_n}\sum\limits_{k=1}^nx_k=0\)</span>。</p></blockquote><p><strong>证明概要</strong>：记 <span class="math inline">\(u_n=\sum\limits_{k=1}^n\dfrac{x_k}{b_k},\,u_0=0\)</span>，则<span class="math inline">\(\lim\limits_{n\to\infty}u_n=s\)</span>存在。 <span class="math display">\[\begin{align*}\frac{1}{b_n}\sum_{k=1}^nx_k&amp;=\frac{1}{b_n}\sum_{k=1}^n(u_k-u_{k-1})b_k=\frac{1}{b_n}\sum_{k=1}^nu_kb_k-\frac{1}{b_n}\sum_{k=0}^{n-1}u_kb_{k+1}\\&amp;=u_n-\frac{b_n-b_1}{b_n}s-\sum_{k=1}^{n-1}\frac{b_{k+1}-b_k}{b_n}(u_k-s).\end{align*}\]</span>而最后一个余项的绝对值小于等于 <span class="math display">\[\begin{align*}\sum_{k=1}^{n-1}\frac{b_{k+1}-b_k}{b_n}|u_k-s|=\left(\sum_{k=1}^{N}+\sum_{k=N+1}^{n-1}\right)\frac{b_{k+1}-b_k}{b_n}|u_k-s|\end{align*}\]</span>这里对 <span class="math inline">\(n&gt;N\)</span> 有 <span class="math inline">\(|u_n-s|&lt;\epsilon\)</span> 成立。</p><p>当 <span class="math inline">\(n\to\infty\)</span>时第一个和项是一个有界的值除以 <span class="math inline">\(b_n\)</span>从而趋于 0。第二个和项显然不大于 <span class="math inline">\(\dfrac{b_n}{b_n}\epsilon\)</span>，所以这个余项可以任意小。</p><blockquote><p><strong>引理</strong>：<span class="math inline">\(Y_n' =Y_n/n\)</span> 满足 Kolmogrov 收敛判定。</p></blockquote><p><strong>证明概要</strong>： <span class="math display">\[\begin{align*}\sum_{n=1}^\infty\mathrm{Var}(Y_n')&amp;=\sum_{n=1}^\infty\frac{\mathbb{E}Y_n^2- (\mathbb{E}Y_n)^2}{n^2}\leq\sum_{n=1}^\infty\frac{\mathbb{E}Y_n^2}{n^2}\\&amp;=\sum_{n=1}^\infty\frac{\mathbb{E}X_n^2\mathbb{1}_{\{|X_n|\leqn\}}}{n^2}\\&amp;=\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}}\right]\\&amp;\leq\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2},\|X_1|\leq 2\right] +\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}},\|X_1|&gt;2\right]\\&amp;\leq4\sum_{n=1}^\infty\frac{1}{n^2}+\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}},\ |X_1|&gt;2\right] .\end{align*}\]</span> 为什么要用 <span class="math inline">\(|X_1|\)</span> 是否大于 2把它分成两部分？这里其实可以用任何大于等于 2 的数，不过 2已经足够了，这样做的原因下面就会看到。</p><p>现在第一项是有限的，我们只要说明第二项也有限即可。你可能想把 <span class="math inline">\(\mathbb{1}_{\{|X_1|\leq n\}}\)</span>扔掉，但是注意强大数定律中 <span class="math inline">\(|X_1|\)</span> 是<span class="math inline">\(L^1\)</span> 可积的，未必是 <span class="math inline">\(L^2\)</span> 可积的，所以扔掉是不行的。我们得把<span class="math inline">\(\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}}\)</span> 这个东西估计一下。注意到对任何正整数 <span class="math inline">\(k\)</span>，<span class="math inline">\(\sum_{n=k}^\infty\frac{1}{n^2}\)</span> 就是 <span class="math inline">\(\frac{1}{\lfloor t\rfloor^2}\)</span> 在 <span class="math inline">\([k,\infty)\)</span> 上的积分， 所以当 <span class="math inline">\(x&gt;2\)</span> 时 <span class="math display">\[\begin{align*}\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{x\leq n\}}&amp;=\sum_{n\geqx}^\infty\frac{1}{n^2}=\sum_{n= \lceilx\rceil}^\infty\frac{1}{n^2}\\&amp;=\int_{\lceilx\rceil}^\infty\frac{1}{\lfloor t\rfloor^2}\,\mathrm{d}t\\&amp;\leq\int_{\lceilx\rceil}^\infty\frac{1}{(t-1)^2}\,\mathrm{d}t\\&amp;=\frac{1}{\lceilx\rceil -1}\\&amp;\leq\frac{1}{x-1}&lt;\frac{2}{x}.\end{align*}\]</span> 所以取<span class="math inline">\(x&gt;2\)</span> 主要是为了最后一步的 <span class="math inline">\(\frac{1}{x-1}&lt;\frac{2}{x}\)</span>。</p><p>于是我们就证明了在 <span class="math inline">\(|X_1|&gt;2\)</span>上有 <span class="math display">\[\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}}&lt;\frac{2}{|X_1|}.\]</span> 两边乘以 <span class="math inline">\(|X_1|^2\)</span> 并积分，则 <span class="math display">\[\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}},\ |X_1|&gt;2\right] &lt; 2\mathbb{E}|X_1|.\]</span>这就证明了结论。</p><h1 id="renewal-theory">19.2 Renewal Theory</h1><p>本讲以灯泡寿命为例子，介绍了强大数定理在更新理论中的应用。</p><p>设灯泡的寿命互相独立，且服从某个共同的非负随机变量 <span class="math inline">\(X,\ \mathbb{E}X&lt;\infty\)</span>。设长度为 <span class="math inline">\(t\)</span> 的时刻内需要报废的灯泡数最多为 <span class="math inline">\(N_t\)</span>，即 <span class="math inline">\(S_{N_t}\leq t &lt; S_{N_t+1}\)</span>。则 <span class="math display">\[\lim_{t\to\infty}\frac{N_t}{t}\to\frac{1}{\mathbb{E}X},\quad\mathrm{a.e.}\]</span> 实际上由定义有 <span class="math display">\[\frac{S_{N_t}}{N_t}\leq \frac{t}{N_t} &lt;\frac{S_{N_t+1}}{N_t}.\]</span> 如果我们能证明 <span class="math inline">\(t\to\infty\)</span> 时同样有 <span class="math inline">\(N_t\to\infty,\mathrm{a.e.}\)</span>，则利用强大数定理就有<span class="math inline">\(S_{N_t}/N_t\to\mathbb{E}X\)</span>，从而结论得证。</p><p>我们考虑 <span class="math inline">\(\Omega_1=\{\omega\in\Omega\midS_n(\omega)&lt;\infty,\ \forall n\geq1\}\)</span>。<span class="math inline">\(\Omega_1\)</span> 作为一列递减的测度均为 1的集合列的极限，测度显然也是 1。我们只要证明在 <span class="math inline">\(\Omega_1\)</span> 上有 <span class="math inline">\(S_{N_t}/N_t\to\mathbb{E}X\)</span> 成立。</p><p>首先 <span class="math inline">\(N_t\)</span> 随着 <span class="math inline">\(t\)</span> 递增是没有问题的，如果它对某个 <span class="math inline">\(\omega\)</span> 是有界的，则 <span class="math inline">\(N_t(\omega)\leq M\)</span> 对所有 <span class="math inline">\(t\)</span> 成立。即不管 <span class="math inline">\(t\)</span> 是多少都有 <span class="math inline">\(S_M\leq t &lt; S_{M+1}\)</span>，这只能要求 <span class="math inline">\(S_{M+1}(\omega)=\infty\)</span>，从而 <span class="math inline">\(\omega\)</span> 不属于 <span class="math inline">\(\Omega_1\)</span>。</p><p>一个有意思的引理：</p><blockquote><p><strong>引理</strong>：设 <span class="math inline">\(X\inL^1\)</span>，如果 <span class="math inline">\(\{X_n\}\)</span> 是一列<span class="math inline">\(\mathrm{i.i.d}\)</span> 且服从和 <span class="math inline">\(X\)</span> 同样的分布，则 <span class="math inline">\(\dfrac{X_n}{n}\to0,\mathrm{a.e.}\)</span>。</p></blockquote><p>老技巧，只要证明 <span class="math inline">\(\mathbb{P}(\{|X_n|\geqn\epsilon,\ \mathrm{i.o.}\})=0\)</span> 即可。根据 Borel-Cantelli引理，只要证明 <span class="math inline">\(\sum_{n=1}^\infty\mathbb{P}(|X_n|\geqn\epsilon)&lt;\infty\)</span> 即可，而这在 18.1 中已经证明过了。</p><h1 id="complex-integration-and-dynkins-theorem">24.1 ComplexIntegration and Dynkin’s Theorem</h1><p>无要点</p><h1 id="characteristic-function">24.2 Characteristic Function</h1><p>本讲介绍了随机变量的特征函数及其基本性质。整体内容比较基础。</p><h1 id="the-continuity-theorem">25.3 The Continuity Theorem</h1><p>本讲介绍了测度弱收敛的连续性定理。</p><blockquote><p><strong>定理</strong>：如果 <span class="math inline">\(\{\mu_n\}_{n=1}^\infty\)</span> 是一列 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>上的概率测度。假设极限 <span class="math inline">\(\varphi(t) =\lim\limits_{n\to\infty}\hat{\mu_n}\)</span> 存在，并且 <span class="math inline">\(\varphi(t)\)</span> 在 <span class="math inline">\(t=0\)</span> 处连续，则存在概率测度 <span class="math inline">\(\mu\)</span> 使得 <span class="math inline">\(\hat{\mu}=\varphi\)</span>，并且 <span class="math inline">\(\mu_n\rightarrow_{w}\mu\)</span>。</p></blockquote><blockquote><p><strong>引理</strong>：对两个概率测度 <span class="math inline">\(\mu,\nu\)</span> 有 <span class="math display">\[\int_{\mathbb{R}^d}\hat{\mu}(x)\vdx{x}=\int_{\mathbb{R}^d}\hat{\nu}(y)\udx{y}.\]</span></p></blockquote><p>直接 Fubini 即可。</p><blockquote><p><strong>引理</strong>： <span class="math display">\[\int_{\mathbb{R}^d}[1-\mathrm{Re}\,\hat{\mu}(x)]\vdx{x}=\int_{\mathbb{R}^d}[1-\mathrm{Re}\,\hat{\nu}(y)]\udx{x}.\]</span></p></blockquote><p>在前一个引理中两边取实部，然后被 1 减去即可。</p><blockquote><p><strong>推论</strong>：假设 <span class="math inline">\(\rho\)</span>是一个 <span class="math inline">\(\mathbb{R}^d\)</span>上的概率测度，其支集位于闭的单位球 <span class="math inline">\(\bar{B}_1\)</span> 内。设 <span class="math inline">\(M&gt;0\)</span> 使得 <span class="math inline">\(|\hat{\rho}(t)|\leq1/2\)</span> 对任何 <span class="math inline">\(|t|\geq M\)</span> 成立，则对任何 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>上的概率测度 <span class="math inline">\(\mu\)</span> 和正数 <span class="math inline">\(\alpha&gt;0\)</span> 有 <span class="math display">\[\mu\{x\in\mathbb{R}^d:\ |x|\geq\alpha\}\leq2\int_{\bar{B}_1}[1-\mathrm{Re}\,\hat{\mu}(\frac{M}{\alpha}x)]\rho(x)\,\mathrm{d}x.\]</span></p></blockquote><h1 id="orthogonal-projections">31.1 Orthogonal Projections</h1><p>无要点</p><h1 id="probability-kernels-part-1">33.1 Probability Kernels, Part1</h1><p>本讲引入了概率核的概念。</p><p>设 <span class="math inline">\((S_i,\mathcal{B}_i), i=1,2\)</span>是两个可测空间，一个概率核 <span class="math inline">\(Q(x,B):(S_1,\mathcal{B}_2)\to[0,1]\)</span> 是一个二元函数，满足：</p><ol type="1"><li>对任何 <span class="math inline">\(x\in S_1\)</span>，<span class="math inline">\(Q(x,\cdot):\mathcal{B}_2\to[0,1]\)</span> 是 <span class="math inline">\((S_2,\mathcal{B}_2)\)</span> 上的概率测度。</li><li>对任何 <span class="math inline">\(B\in\mathcal{B}_2\)</span>，<span class="math inline">\(Q(\cdot,B):S_1\to[0,1]\)</span> 是 <span class="math inline">\((S_1,\mathcal{B}_1)\)</span> 上的可测函数。</li></ol><blockquote><p><strong>引理</strong>：假设 <span class="math inline">\(f(x,y)\in(S_1\times S_2, \mathcal{B}_1\otimes\mathcal{B}_2)\)</span>是乘积空间上的可测函数，并且是有界的或者非负的，则积分 <span class="math display">\[x\to\int_{S_2}f(x,y)Q(x,\pd{y})\]</span> 是关于<span class="math inline">\(x\)</span> 的可测函数。</p></blockquote><p>此引理不难从简单函数 <span class="math inline">\(\mathbb{1}_{B_1\timesB_2}(x,y)=\mathbb{1}_{B_1}(x)\mathbb{1}_{B_2}(y)\)</span>出发，使用函数形式的 Dynkin 引理得到。</p><p>由此对任何 <span class="math inline">\((S_1,\mathcal{B}_1)\)</span>上的测度 <span class="math inline">\(\mu\)</span>，我们可以定义乘积空间<span class="math inline">\((S_1\times S_2,\mathcal{B}_1\otimes\mathcal{B}_2)\)</span> 上的乘积测度 <span class="math inline">\(\mu\otimes Q\)</span>，这个乘积测度是随 <span class="math inline">\(x\)</span> 变化而变化的： <span class="math display">\[\mu\otimesQ(E)=\int_{S_1}\mu(\pd{x})\int_{S_2}\mathbb{1}_{C}(x,y)Q(x,\pd{y}).\]</span>不过这真的是一个概率测度吗？你可以用积分的线性性质立刻看出它是有限可加的，并且利用积分项有界和控制收敛定理立刻看出它是可数可加的，所以确实是个概率测度。</p><p>有了概率核的乘积测度，我们自然要研究对这种测度的积分。由于这个测度本身就是通过对示性函数积分来定义的，所以其上的积分也具有类似的性质：</p><blockquote><p><strong>引理</strong>：假设 <span class="math inline">\(f(x,y)\)</span>是乘积空间的可测函数，并且是有界或者非负的，则 <span class="math display">\[\int_{S_1\times S_2}f\pd{(\mu\otimes Q)} =\int_{S_1}\mu(\pd{x})\int_{S_2}f(x,y)Q(x,\pd{y}).\]</span></p></blockquote><p>后面花了很大力气证明当 <span class="math inline">\(Q(x,\cdot)=\widetilde{Q}(x,\cdot)\)</span> 对几乎处处的 <span class="math inline">\(x\)</span> 成立时有 <span class="math inline">\(\mu\otimesQ=\mu\otimes\widetilde{Q}\)</span>。没仔细看。</p><h1 id="regular-conditional-distributions">33.2 Regular ConditionalDistributions</h1><p>本讲使用概率核给出了 <span class="math inline">\(\mathbb{E}[f(X,Y)\mid X=x]\)</span> 这种条件期望的严格定义。</p><blockquote><p><strong>定理</strong>：设 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\)</span>是一个概率空间，<span class="math inline">\((S_i,\mathcal{B}_i),\,i=1,2\)</span>是两个可测空间，<span class="math inline">\(X:(\Omega,\mathcal{F})\to(S_1,\mathcal{B}_1),\,Y:(\Omega,\mathcal{F})\to(S_2,\mathcal{B}_2)\)</span>是两个随机变量。于是 <span class="math inline">\((X,Y):(\Omega,\mathcal{F})\to(S_1\timesS_2,\,\mathcal{B}1\otimes\mathcal{B}_2)\)</span> 是随机向量。记 <span class="math inline">\(\mu_{X,Y}\)</span> 为此随机向量在 <span class="math inline">\((S_1\timesS_2,\,\mathcal{B}1\otimes\mathcal{B}_2)\)</span> 上 push forward给出的测度，<span class="math inline">\(\mu_X\)</span> 是 <span class="math inline">\(X\)</span> 在 <span class="math inline">\((S_1,\mathcal{B}_1)\)</span> 上 push forward给出的测度。如果存在概率核 <span class="math inline">\(Q(x,B)\)</span>使得 <span class="math display">\[\mu_{X,Y}=\mu_X\otimes Q.\]</span></p><p>则对任何 <span class="math inline">\(f\in L^1(S_1\timesS_2,\mathcal{B}1\otimes\mathcal{B}_2)\)</span> 有 <span class="math display">\[\mathbb{E}[f(X,Y)\mid X = x] =\int_{S_2}f(x,y)Q(x, \pd{y}).\]</span></p></blockquote><p>这里需要解释 <span class="math inline">\(\mathbb{E}[f(X,Y)\mid X =x]\)</span> 这个记号的含义。这里其实引用了条件期望 (后面才会讲到)的性质：<span class="math inline">\(\mathbb{E}[f(X,Y)\mid X]\)</span>是一个关于 <span class="math inline">\(\sigma(X)\)</span>可测的随机变量，从而由 Doob-Dynkin 表示定理，存在可测函数 <span class="math inline">\(g\)</span> 使得 <span class="math inline">\(\mathbb{E}[f(X,Y)\mid X] = g(X)\)</span>，所以<span class="math inline">\(\mathbb{E}[f(X,Y)\mid X = x] =g(x)\)</span>。这个定理说的就是 <span class="math display">\[\mathbb{E}[f(X,Y)\mid X = x] = g(x) =\int_{S_2}f(x,y)Q(x, \pd{y}).\]</span></p><p><strong>证明</strong>：怎么证明两个关于 <span class="math inline">\(\sigma(X)\)</span> 可测的函数 (几乎处处)相等呢？我们可以给它们同时乘以 <span class="math inline">\(h(x)\)</span>，这里 <span class="math inline">\(h(x)\)</span> 是任何一个关于 <span class="math inline">\(\sigma(X)\)</span> 可测的有界函数，然后证明它们对<span class="math inline">\(\mu_X\)</span>积分以后的值相等，则这两个可测函数必相等。</p><p><span class="math inline">\(g(x)h(x)\)</span> 这个函数对 <span class="math inline">\(\mu_X\)</span> 积分，根据积分变量替换定理，正是<span class="math inline">\(\mathbb{E}[g(X)h(X)]\)</span>。而根据 <span class="math inline">\(g(x)\)</span> 的定义和条件期望的性质， <span class="math display">\[\mathbb{E}[g(X)h(X)]=\mathbb{E}[\mathbb{E}[f(X,Y)|X]h(X)]= \mathbb{E}[\mathbb{E}[f(X,Y)h(X)|X]] = \mathbb{E}[f(X,Y)h(X)].\]</span> 注意右边的期望悄悄地变成了关于 <span class="math inline">\(\mu_X\otimes Q\)</span>的积分。这是因为上式最后的等号使用了条件期望的 telescoping 性质，而<span class="math inline">\(f(X,Y)g(X)\)</span> 是关于 <span class="math inline">\(\mathcal{B}_1\otimes\mathcal{B}_2\)</span>可测的函数。</p><p>另一方面，<span class="math inline">\(h(x)\int_{S_2}f(x,y)Q(x,\pd{y})\)</span>这个函数对 <span class="math inline">\(\mu_X\)</span> 积分，正是 <span class="math display">\[\int_{S_1}\mu(\pd{x})\int_{S_2}f(x,y)h(x)Q(x,\pd{y}).\]</span>所以 <span class="math display">\[\begin{align*}\mathbb{E}[f(X,Y)h(X)] &amp;= \int_{S_1\timesS_2}f(x,y)h(x)\mu_{X,Y}(\pd{x}\pd{y}) \\&amp;= \int_{S_1\times S_2}f(x,y)h(x)\mu_X\otimes Q \\&amp;= \int_{S_1}\mu_X \int_{S_2}f(x,y)h(x)Q(x,\pd{y}) \\&amp;= \int_{S_1}\mu_X h(x)\int_{S_2}f(x,y)Q(x,\pd{y}).\end{align*}\]</span> 正是所要证明的。</p><p>不过在上面的证明中我们都假定了所有的可积性的前提，我们实际上需要假定<span class="math inline">\(f(x,y)\)</span>有界才能确保推导成立。对一般的 <span class="math inline">\(f(x,y)\inL^1(S_1\times S_2,\mathcal{B}_1\otimes\mathcal{B}_2)\)</span>，我们需要用有界函数列 <span class="math inline">\(f_n\to f\)</span> 且此收敛是在 <span class="math inline">\(L^1(\mu_{X,Y})\)</span> 意义下的。由于条件期望是contraction，所以 <span class="math display">\[\mathbb{E}[f_n(X, Y)| X]\xrightarrow{L^1} \mathbb{E}[f(X,Y)|X].\]</span> 此外我们已经证明了<span class="math display">\[\mathbb{E}[f_n(X, Y)| X] =\left.\int_{S_2}f_n(x,y)Q(x,\pd{y})\right|_{x=X}.\]</span> 所以只要证明<span class="math display">\[\left.\int_{S_2}f_n(x,y)Q(x,\pd{y})\right|_{x=X}\xrightarrow{L^1}\left.\int_{S_2}f(x,y)Q(x,\pd{y})\right|_{x=X}.\]</span> 即可。这个<span class="math inline">\(L^1\)</span> 收敛的意思是对 <span class="math inline">\(\mu_X\)</span> 取积分，因此我们要估计 <span class="math display">\[\int_{S_1}\mu(\pd{x})\int_{S_2}|f_n(x,y)-f(x,y)|Q(x,\pd{y}).\]</span>这不正是 <span class="math inline">\(|fn-f|\)</span>对乘积测度的积分嘛，而我们已经知道了它是 <span class="math inline">\(L^1\)</span> 收敛的了。</p><p>所以如果我们能把一个联合分布分解为边际分布和一个概率核的乘积，则我们就得到了条件概率的一个表示。</p><blockquote><p><strong>问题</strong>：<span class="math inline">\(\mu_{X,Y}\)</span>总可以表示为 <span class="math inline">\(\mu_X\otimes Q\)</span>的形式吗？</p></blockquote><blockquote><p><strong>定理</strong>：如果概率核 <span class="math inline">\(Q(x,B)\)</span> 满足 <span class="math display">\[\mathbb{P}(Y\in B | X=x) =Q(x, B)\]</span> (这个条件等价于 <span class="math display">\[\mathbb{E}[h(Y) | X] = \left.\int h(y)Q(x,\pd{y})\right|_{x=X}.\]</span> 对任何有界的可测函数 <span class="math inline">\(h(y)\)</span> 成立) 则对 <span class="math inline">\(f(x,y)\)</span> 同样有 <span class="math display">\[\mathbb{E}[f(X,Y) | X] = \left.\int f(x,y)Q(x,\pd{y})\right|_{x=X}.\]</span> 成立。</p></blockquote><p>这个定理可以先从 <span class="math inline">\(f(x,y)=f(x)\otimesg(y)\)</span> 形式的函数出发，然后用 Dynkin 函数系引理得到。</p><p>总结一下，至此我们讨论了：</p><ol type="1"><li>如果 <span class="math inline">\(\mu_{X,Y}=\mu_X\otimesQ\)</span>，那我们就有了 <span class="math inline">\(\mathbb{E}[f(X,Y)|X]\)</span> 的计算方法：积分<span class="math inline">\(\int_{S_2}f(X,y)Q(X,\pd{y})\)</span>。特别地我们可以算条件概率了。</li><li>反之如果我们有一个概率核给出条件概率：<span class="math inline">\(\mathbb{P}(Y\in B | X=x) = Q(x,B)\)</span>，那么它就给出 <span class="math inline">\(\mu_{X,Y}\)</span>的一个分解：<span class="math inline">\(\mu_{X,Y}=\mu_X\otimesQ\)</span>。</li></ol><p>本讲后面讨论了离散和连续情形概率核是什么样子的。</p><h1 id="probability-kernels-part-2">34.1 Probability Kernels, Part2</h1><p>本讲介绍了概率核的本质是 Markov生成元，即可测函数空间上的非负线性泛函。</p><p>当有一个概率核 <span class="math inline">\(Q: S_1\times\mathcal{B}_2\to[0, 1]\)</span> 时， <span class="math display">\[f\to\int_{S_2}f(y)Q(x,\pd{y}),\quadf\in\mathbb{B}(S_2,\mathcal{B}_2)\]</span> 给出了从 <span class="math inline">\(L^\infty(S_2,\mathcal{B}_2)\)</span> 到 <span class="math inline">\(L^\infty(S_1,\mathcal{B}_1)\)</span> 的线性映射<span class="math inline">\(L_Q\)</span>，<span class="math inline">\(L_Q\)</span> 满足</p><ol type="1"><li><span class="math inline">\(L_Q(1)=1\)</span>。</li><li>若 <span class="math inline">\(f\geq 0\)</span> 非负可测，则 <span class="math inline">\(L_Q(f)\geq 0\)</span> 也非负可测。</li><li>若 <span class="math inline">\(f_n\uparrow f\)</span> 则 <span class="math inline">\(L_Q(f_n)\uparrow L_Q(f)\)</span>。</li><li><span class="math inline">\(\|L_Q(f)\|_{\infty} \leq\|f\|_{\infty}\)</span>。</li></ol><p>所以 <span class="math inline">\(L_Q\)</span>是一个连续的正线性泛函？</p><p>反过来，如果有这样的一个泛函 <span class="math inline">\(L\)</span>，<span class="math inline">\(L\)</span>是否给出一个概率核 <span class="math inline">\(Q\)</span> 呢？</p><p>答案是否定的，一般来说这不成立。但是在 <span class="math inline">\((S_1,\mathcal{B}_1)=(S_2,\mathcal{B}_2)\)</span>的情形，这确实是对的。</p><blockquote><p><strong>定理</strong>：如果 <span class="math inline">\(L:\mathbb{B}(S,\mathcal{B})\to\mathbb{B}(S,B)\)</span>满足以上四个条件，则 <span class="math display">\[Q(x, B) =L(\mathbb{1}_B)(x)\]</span> 给出一个概率核。并且 <span class="math inline">\(L_Q=L\)</span>，即此概率核给出的线性泛函正是 <span class="math inline">\(L\)</span>。</p></blockquote><p>证明：由于 <span class="math inline">\(0\leq \mathbb{1}_B\leq1\)</span> 总是成立的，所以 <span class="math inline">\(L(0)\leqL(\mathbb{1}_B)\leq L(1)=1\)</span>，即 <span class="math inline">\(L(\mathbb{1}_B)(x)\)</span> 对任何 <span class="math inline">\(x\)</span> 都在 <span class="math inline">\([0,1]\)</span> 中，这符合概率的定义约束。</p><p>固定 <span class="math inline">\(x\)</span>，我们需要证明 <span class="math inline">\(L(\mathbb{1}_B)(x) = \sum_{k=1}^\inftyL(\mathbb{1}_{B_k})(x)\)</span> 对可数不交并 <span class="math inline">\(B = \uplus_{k=1}^\infty B_k\)</span> 成立。记<span class="math inline">\(f_n=\sum_{k=1}^n B_k\)</span>，则 <span class="math inline">\(f_n\uparrow \mathbb{1}_B\)</span>，于是 <span class="math inline">\(L(f_n)\uparrow L(f)=L(\mathbb{1}_B)\)</span>，即<span class="math inline">\(\sum_{k=1}^\inftyL(\mathbb{1}_{B_k})\uparrow L(\mathbb{1}_B)\)</span>，成立！</p><p>要证明 <span class="math inline">\(L = L_Q\)</span>，即对任何 <span class="math inline">\(f\in\mathbb{B}(S,\mathcal{B})\)</span> 有 <span class="math display">\[L(f) = \int_S f(y)Q(x,\pd{y})\]</span>成立。这个很容易从示性函数出发取极限得到。</p><p>如果 <span class="math inline">\(Q_1,Q_2\)</span> 是两个 <span class="math inline">\((S,\mathcal{B})\)</span> 到自身的概率核，则 <span class="math inline">\(L_{Q_1}L_{Q_2}\)</span> 也满足性质1-4，因而也是由一个概率核给出：存在概率核 <span class="math inline">\(Q\)</span> 使得 <span class="math inline">\(L_Q =L_{Q_1}L_{Q_2}\)</span>。我们可以把 <span class="math inline">\(Q\)</span> 明确的写出来： <span class="math display">\[L_Q(f) =L_{Q_1}L_{Q_2}(f)=\int_{S}Q_1(x,\pd{y})\left(\int_Sf(z)Q_2(y,\pd{z})\right).\]</span>这看起来很像乘积测度，实际上我们后面会讨论 <span class="math display">\[Q_1(x,dy)Q_2(d, dz)= Q_1\otimes Q_2(x,dz)\]</span> 的具体含义。</p><h1 id="random-dynamics">34.2 Random Dynamics</h1><p>什么是随机动力系统：</p><p>有一个概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\)</span>，一个可测空间<span class="math inline">\((R,\mathcal{G})\)</span>，以及一些 i.i.d随机变量 <span class="math inline">\(\xi_n:(\Omega,\mathcal{F},\mathbb{P})\to(R,\mathcal{G})\)</span>。此外设 <span class="math inline">\((S,\mathbb{R})\)</span> 是一个可测空间。</p><p>如果 <span class="math inline">\(f\)</span> 是一个 <span class="math inline">\((S, R)\to S\)</span> 的可测函数映射满足</p><p><span class="math display">\[X_{n+1} = f(X_n, \xi_{n+1}) =F_n(X_0,\xi_1,\xi_2,\ldots,\xi_n),\quad F_n:S\times R^n\to S.\]</span>即 <span class="math inline">\(f(\cdot,\xi_n)\)</span> 是一个由随机序列<span class="math inline">\(\{\xi_n\}\)</span>驱动的映射，则我们就称这是一个随机动力系统。</p><p>注意 <span class="math inline">\(X_n\)</span> 由 <span class="math inline">\(\xi_1\sim\xi_n\)</span> 决定，所以 <span class="math inline">\(\mathcal{F}_n=\sigma(X_0,X_1,\ldots,X_n)=\sigma(X_0,\xi_1,\ldots,\xi_n)\)</span>。</p><p>记 <span class="math inline">\(Q_n(x,\cdot)=\mathrm{Law}f(x,\xi_n)\)</span>，则 <span class="math inline">\(Q_n\)</span>是一个概率核。设 <span class="math inline">\(L_n\)</span> 是其 Markov生成元。则</p><p><span class="math display">\[\begin{align*}\mathbb{E}[g(X_{n+1})|\mathcal{F}_n]&amp;= \mathbb{E}[g(f(X_n,\xi_{n+1}))|\mathcal{F}_n]\\&amp;=\left.\mathbb{E}[g\circ f(x,\xi_{n+1})]\right|_{x=X_n} \\&amp;=\left.\int g(y)Q_{n+1}(x,\pd{y})\right|_{x=X_n}\\&amp;=L_{n+1}(g)(X_n).\end{align*}\]</span> 但是 <span class="math inline">\(L_{n+1}(g)(X_n)\)</span> 是 <span class="math inline">\(X_n\)</span> 的函数，所以它关于 <span class="math inline">\(\sigma(X_n)\)</span>是可测的，而且是有界可测，从而两边对 <span class="math inline">\(\sigma(X_n)\)</span> 这个子 <span class="math inline">\(\sigma\)</span>- 域取条件期望，并注意到 <span class="math inline">\(\sigma(X_n)\subset\mathcal{F}_n\)</span> 有 <span class="math display">\[\mathbb{E}[g(X_{n+1})|\mathcal{F}_n] =\mathbb{E}[g(X_{n+1})|X_n].\]</span> 这正是 Markov 性质。</p><h1 id="stochastic-processes">35.1 Stochastic Processes</h1><p>本讲介绍了随机过程的定义，以及它们的有限维分布、滤过(filtration)、适应 (adapted) 等概念。</p><h1 id="the-markov-property">36.1 The Markov property</h1><p>我们称随机过程 <span class="math inline">\(X_t:(\Omega,\mathcal{F}_t)\to(S_,\mathcal{B})\)</span>Markov 性质，如果对任何有界可测函数 <span class="math inline">\(f\in\mathbb{B}(S,\mathcal{B})\)</span> 有</p><p><span class="math display">\[\mathbb{E}[f(X_t)|\mathcal{F}_s] =\mathbb{E}[f(X_t)|X_s],\quad \mathrm{a.e.},\ \forall s &lt;t.\]</span></p><p>Markov过程貌似是关于过去和当前的，但实际上它也告诉了我们关于未来的信息：</p><blockquote><p><strong>推论</strong>：<span class="math inline">\(\mathbb{E}[Y|\mathcal{F}_s] = E[Y|X_s],\quad\forall Y\in\mathbb{B}(\Omega, \mathcal{F}_{\geq s})\)</span>。</p></blockquote><p>这个推论的证明很有意思，要用到 Dynkin multiplicative system。</p><p>考虑形如 <span class="math inline">\(Y =g_0(X_{t_0})g_1(X_{t_1})\cdots g_n(X_{t_n})\)</span> 的函数，这里 <span class="math inline">\(s =t_0&lt;t_1&lt;\cdots &lt;t_n\)</span>，且每个<span class="math inline">\(g_i\)</span> 都是有界可测的，从而 <span class="math inline">\(Y\)</span> 也是有界可测的，并且 <span class="math inline">\(Y\in\mathcal{F}_{\geq s}\)</span>。</p><blockquote><p><strong>引理</strong>：设 <span class="math display">\[\mathcal{M} =\{g_0(X_{t_0})g_1(X_{t_1})\cdots g_n(X_{t_n}): n\in\mathbb{Z}_{\geq0},s=t_0&lt;t_1&lt;\cdots&lt;t_n,g_j\in\mathbb{B}(S,\mathcal{B})\},\]</span> 则 <span class="math inline">\(\mathcal{M}\)</span> 是乘法系，且 <span class="math inline">\(\sigma(M) = \mathcal{F}_{\geq s}\)</span>。</p></blockquote><p>回到推论的证明。</p><p>设 <span class="math inline">\(\mathcal{H}\)</span>是所有满足推论要求的函数构成的空间。我们只要证明 <span class="math inline">\(\mathcal{H} \supset\mathcal{M}\)</span>。这样由于<span class="math inline">\(\mathcal{H}\)</span> 是向量空间，包含常数1，在有界收敛下封闭，并且包含乘法系 <span class="math inline">\(\mathcal{M}\)</span>，从而根据 Dynkin函数系引理包含所有关于 <span class="math inline">\(\sigma(\mathcal{M})=\mathcal{F}_{\geq s}\)</span>可测的有界可测函数，这正是所要证明的。</p><p><span class="math display">\[\begin{align*}\mathbb{E}_{\mathcal{F}_s}[Y]&amp;=\mathbb{E}_{\mathcal{F}_s}[E_{\mathcal{F}_{t_{n-1}}}[Y]]\\&amp;=\mathbb{E}_{\mathcal{F}_s}[g_0(X_{t_0})\cdotsg_{n-1}(X_{t_{n-1}})h(X_{t_{n-1}})]\\&amp;=\mathbb{E}_{\mathcal{F}_s}[g_0(X_{t_0})\cdots\widetilde{g_{n-1}}(X_{t_{n-1}})]\\&amp;=\cdots\\&amp;=\mathbb{E}_{\mathcal{F}_s}[F(X_{s})]\\&amp;=F(X_s)\end{align*}\]</span> 再利用 <span class="math inline">\(\mathbb{E}_{X_s}[Y]=\mathbb{E}_{X_s}[\mathbb{E}_{\mathcal{F}_s}[Y]]=\mathbb{E}_{X_s}[F(X_s)]=F(X_s)\)</span>即得所证。</p><p>上面是 Markov性质的第一种刻画：将对未来可测的函数对当前和过去取条件期望，相当于只对当前取条件期望。</p><p>本讲接下来用条件独立给出了 Markov 性质的第二种刻画：</p><blockquote><p><strong>定理</strong>：随机过程 <span class="math inline">\(\{X_t\}\)</span> 满足 Markov 性质当且仅当 <span class="math inline">\(\mathcal{F}_s\)</span> 和 <span class="math inline">\(\mathcal{F}_{\geq s}\)</span> 关于 <span class="math inline">\(\sigma(X_s)\)</span>是条件独立的，即对任何有界可测函数 <span class="math inline">\(Z\in\mathbb{B}(\Omega,\mathcal{F}_s)\)</span>，<span class="math inline">\(Y\in\mathbb{B}(\Omega,\mathcal{F}_{\geqs})\)</span> 有 <span class="math display">\[\mathbb{E}[ZY|X_s] =\mathbb{E}[Z|X_s]\cdot \mathbb{E}[Y|X_s].\]</span></p></blockquote><p>注意到 <span class="math inline">\(\mathcal{F}_s=\sigma(X_t: t\leqs)\)</span> 以及 <span class="math inline">\(\mathcal{F}_{\geqs}=\sigma(X_T:t\geq s)\)</span>，所以这个结论可以概括为：对 Markov过程，给定当下，过去与未来独立。</p><p>这个结论的证明主要使用了 Tower 性质，不算困难。</p><h1 id="probability-kernels-revisited">36.2 Probability KernelsRevisited</h1><p>回顾了之前概率核的概念。没啥新的。</p><h1 id="kolmogorovs-extended-extension-theorem">37.2 Kolmogorov’s(Extended) Extension Theorem</h1><p>本讲介绍了连续情形的 Kolmogrov扩张定理：可以构造一般的有限维分布，只要它们满足相容性条件。</p><h1 id="walds-identity">46.3 Wald’s Identity</h1><p>本讲介绍了 Wald 引理。</p><blockquote><p><strong>Wald 引理</strong>：设 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span> 的随机变量序列，<span class="math inline">\(\tau\)</span> 是一个停时，则在 <span class="math inline">\(\mathbb{E}|X_1|&lt;\infty\)</span> 且 <span class="math inline">\(\mathbb{E}\tau&lt;\infty\)</span> 的条件下有 <span class="math inline">\(\mathbb{E}\sum\limits_{n=1}^\tauX_n=\mathbb{E}X_1\cdot \mathbb{E}\tau\)</span>。</p></blockquote><p>这里的关键在于将上面的求和变成一个二重级数求和，然后交换求和次序。</p><p><span class="math display">\[\begin{align*}\sum_{n=1}^\tau\mathbb{E}X_n&amp;=\sum_{n=1}^\infty\mathbb{E}X_n\cdot\mathbb{1}_{\tau\geqn}=\sum_{n=1}^\infty\mathbb{E}X_n\cdot\sum_{k=n}^\infty\mathbb{1}_{\tau=k}\\&amp;=\sum_{k=1}^\infty\mathbb{1}_{\tau=k}\sum_{n=1}^k\mathbb{E}X_n\\&amp;=\mathbb{E}X_1\sum_{k=1}^\inftyk\cdot\mathbb{1}_{\tau=k}\\&amp;=\mathbb{E}X_1\cdot\mathbb{E}\tau.\end{align*}\]</span></p><p>我们为什么可以在第一行的第二个等号处交换求和次序？这是因为上面的推导对<span class="math inline">\(|X_n|\)</span> 是成立的，并且离散积分值<span class="math inline">\(\mathbb{E}|X_1|\cdot\mathbb{E}\tau&lt;\infty\)</span>，所以由控制收敛定理对原序列<span class="math inline">\(X_n\)</span> 交换求和也是 OK 的。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd Kemp 概率论课程笔记</title>
      <link href="todd-kemp/bak2.html"/>
      <url>todd-kemp/bak2.html</url>
      
        <content type="html"><![CDATA[<h1 id="banach-tarski">0 Banach Tarski</h1><p><strong>不可测集的例子</strong>：记单位圆 <span class="math inline">\(S^1=\{e^{it},\,t\in\mathbb{R}\}\)</span>，子群<span class="math inline">\(H=\{e^{iq},\,q\in\mathbb{Q}\}\)</span>，在每个左陪集<span class="math inline">\(S^1/H\)</span> 中选择一个代表元组成集合<span class="math inline">\(E\)</span>，则 <span class="math inline">\(E\)</span> 是不可测集合。这是因为 <span class="math inline">\(S^1 = \bigcup_{q\in\mathbb{Q}}Ee^{iq}\)</span>是可数多个互不相交的集合的并，这些集合两两之间只差乘以一个单位复数，即差一个旋转，所以测度均相等，于是<span class="math display">\[1 = \sum_{q\in\mathbb{Q}}\mu(E) =\infty\cdot \mu(E)\Rightarrow E\text{\ is not measuabe.}\]</span></p><h1 id="measurable-functions">6.2 Measurable Functions</h1><p>本讲介绍了测度空间上可测映射的概念。</p><blockquote><p><strong>引理</strong>：设 <span class="math inline">\(f:\Omega\to\mathcal{S}\)</span> 是一个映射，<span class="math inline">\(\mathcal{A}\subset2^\mathcal{S}\)</span> 是 <span class="math inline">\(\mathcal{S}\)</span> 中一个集合族，定义 <span class="math display">\[f^{-1}(\mathcal{A}) =\{f^{-1}(E),E\in\mathcal{A}\}.\]</span> 则 <span class="math inline">\(\sigma(f^{-1}(\mathcal{A}))=f^{-1}(\sigma(\mathcal{A}))\)</span>。</p></blockquote><p>引理的证明不难， 只要注意到一个 <span class="math inline">\(\sigma-\)</span> 域在映射下的像 (push forward)和逆映射下的原像 (push back) 都是 <span class="math inline">\(\sigma-\)</span> 域即可。</p><blockquote><p><strong>定义：</strong>若 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 和 <span class="math inline">\((\mathcal{S}, \mathcal{B})\)</span>是两个可测空间，我们称 <span class="math inline">\(f:\Omega\to\mathcal{S}\)</span>是一个可测映射，如果有 <span class="math inline">\(f^{-1}(\mathcal{B})\subseteq\mathcal{F}\)</span>。</p></blockquote><p>要检查一个映射是不是可测的，我们不必对每个 <span class="math inline">\(B\in\mathcal{B}\)</span> 都检查，只要对满足 <span class="math inline">\(\sigma(\mathcal{A})=\mathcal{B}\)</span>的一个子集合族 <span class="math inline">\(\mathcal{A}\)</span> 检查有<span class="math inline">\(f^{-1}(\mathcal{A})\subseteq\mathcal{F}\)</span>即可。这是因为由上面的引理， <span class="math display">\[f^{-1}(\mathcal{B})=f^{-1}(\sigma(\mathcal{A}))=\sigma(f^{-1}(\mathcal{A}))\subseteq\mathcal{F}.\]</span></p><blockquote><p><strong>推论</strong>：如果 <span class="math inline">\(X_1,\ldots,X_n\)</span> 都是测度空间 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 上的可测函数，<span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}\)</span>是一个连续或者 Borel 可测的多元函数，则 <span class="math inline">\(Y=f(X_1,\ldots,X_n)\)</span> 也是可测函数。</p></blockquote><p>证明：记 <span class="math inline">\(X=(X_1,\ldots,X_n)\)</span>，我们要说明复合映射<span class="math display">\[\Omega\xrightarrow{\ X\}\mathbb{R}^n\xrightarrow{\ f\ }\mathbb{R}\]</span> 是可测的。由于 <span class="math inline">\(f\)</span> 显然可测，只要再说明 <span class="math inline">\(X\)</span> 是可测的。根据上面的引理，只要验证<span class="math display">\[X^{-1}\left((-\infty, t_1], (-\infty,t_2],\ldots, (-\infty, t_n]\right)=\bigcap_{i=1}^n \{X_i\leqt_i\}.\]</span> 是可测的，这显然。</p><h1 id="robustness-of-measurability">7.1 Robustness ofMeasurability</h1><p>本讲主要介绍了可测函数集合在通常的运算，以及取极限的操作下得到的仍然是可测函数。</p><p>下面这个结论在整个课程中都会频繁用到：</p><blockquote><p><strong>推论 (Doob-Dynkin 分解)</strong>：设 <span class="math inline">\(X_1,\ldots,X_d, Y\)</span> 都是 <span class="math inline">\((\Omega,\mathcal{F})\to(\mathbb{R},\mathcal{B}(\mathbb{R}))\)</span>的可测函数，而且 <span class="math inline">\(Y\)</span> 还关于 <span class="math inline">\(\sigma(X_1,\ldots,X_d)\)</span> 可测，则存在 Borel可测函数 <span class="math inline">\(f:\mathbb{R}^d\to\mathbb{R}\)</span> 使得 <span class="math inline">\(Y=f(X_1,\ldots,X_d)\)</span>。</p></blockquote><p>记 <span class="math inline">\(X=(X_1,\ldots,X_d)\)</span>，则 <span class="math inline">\(X:\Omega\to\mathbb{R}^d\)</span> 是 <span class="math inline">\(\mathcal{F}/\mathcal{B}(\mathbb{R}^d)\)</span>可测的。</p><p>我们先来说明有 <span class="math inline">\(\sigma(X_1,\ldots,X_n)=X^{-1}(\mathcal{B}(\mathbb{R}^d))\)</span>成立。这个基本就是把之前 6.2 讲的引理证了一遍。为方便记 <span class="math display">\[I^d=\{(-\infty,t_1]\times\cdots\times(-\infty,t_d],\ t_i\in\mathbb{R}\text{ or }t_i=+\infty\}.\]</span> 首先 <span class="math inline">\(\mathcal{B}(\mathbb{R}^d)\)</span> 在 <span class="math inline">\(X^{-1}\)</span> 下的 pull back <span class="math inline">\(X^{-1}(\mathcal{B}(\mathbb{R}^d))\)</span> 是一个<span class="math inline">\(\sigma\)</span>- 域，而且包含 <span class="math inline">\(X^{-1}(I^d)\)</span>，所以包含任何形如 <span class="math inline">\(\{X_i\leq t_i\}\)</span> 的集合，从而包含所有的<span class="math inline">\(\sigma(X_i)\)</span>，即包含 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span>。</p><p>另一方面 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span>在 <span class="math inline">\(X\)</span> 下的 push forward <span class="math inline">\(X(\sigma(X_1,\ldots,X_n))\)</span> 也是一个 <span class="math inline">\(\sigma\)</span>- 域，并且包含 <span class="math inline">\(I^d\)</span>，所以也就包含 <span class="math inline">\(\mathcal{B}(\mathbb{R}^d)\)</span>。</p><p>回到推论证明。我们首先对 <span class="math inline">\(Y=\mathbb{1}_{A},\,A\in\sigma(X_1,\ldots,X_n)\)</span>是指标函数的情形证明。由于 <span class="math inline">\(\sigma(X_1,\ldots,X_n)=X^{-1}(\mathcal{B}(\mathbb{R}^d)\)</span>，所以存在<span class="math inline">\(B\in\mathcal{B}(\mathbb{R}^d)\)</span> 使得<span class="math inline">\(A=X^{-1}(B)\)</span>。于是 <span class="math display">\[\mathbb{1}_{A}=\mathbb{1}_{X^{-1}(B)} =\mathbb{1}_{B}\circ X.\]</span> <span class="math inline">\(\mathbb{1}_B\)</span> 当然是 <span class="math inline">\(\mathcal{B}(\mathbb{R}^d)/\mathcal{B}\)</span>可测函数，所以结论成立。</p><p>由此很容易得出结论对任意简单函数都成立。</p><p>对一般的可测函数 <span class="math inline">\(Y\in\sigma(X_1,\ldots,X_d)\)</span>，取简单函数列<span class="math inline">\(\phi_n\toY,\,\phi_n\in\sigma(X_1,\ldots,X_d)\)</span>。根据上面的结论，存在可测函数<span class="math inline">\(f_n:\mathbb{R}^d\to\mathbb{R}\)</span> 使得<span class="math inline">\(\phi_n=f_n(X)\)</span>。记 <span class="math inline">\(f=\varlimsup f_n\)</span>，则有 <span class="math display">\[f(X)=\varlimsup f_n(X)=\varlimsup \phi_n =\lim\phi_n = Y.\]</span> 结论得证。</p><h1 id="monotone-convergence-theorem">8.2 Monotone convergencetheorem</h1><p>本讲给出了<strong>非负可测函数积分</strong>的定义：设 <span class="math inline">\(f\in L^+\)</span> 为非负可测函数，其积分定义为<span class="math display">\[\int f\,\mathrm{d}\mu=\sup\left\{\int\varphi\,\mathrm{d}\mu:\ \varphi\leq f,\ \varphi \text{simple and measuable}\right\}.\]</span></p><p>这个定义的问题在于不容易直接得出积分的可加性： <span class="math display">\[\int (f+g) \,\mathrm{d}\mu=\int f\,\mathrm{d}\mu+\int g\,\mathrm{d}\mu.\]</span></p><p>为此先证明了单调收敛定理：</p><blockquote><p><strong>单调收敛定理 (MCT)</strong>：若 <span class="math inline">\(\{f_n\}\in L^+\)</span> 且 <span class="math inline">\(f_n\uparrow f\)</span>，则 <span class="math inline">\(\int f_n\,\mathrm{d}\mu\uparrow \intf\,\mathrm{d}\mu\)</span>。</p></blockquote><p><strong>证明概要</strong>：显然 <span class="math inline">\(\lim\limits_{n\to\infty}\intf_n\,\mathrm{d}\mu\)</span> 存在且小于等于 <span class="math inline">\(\intf\,\mathrm{d}\mu\)</span>。为了证明二者相等，只要证明对任何简单函数<span class="math inline">\(\varphi\leq f\)</span> 有 <span class="math display">\[\lim_{n\to\infty} \int f_n\,\mathrm{d}\mu\geq\int \varphi\,\mathrm{d}\mu\]</span> 即可。<strong>不要指望通过分析集合<span class="math inline">\(\{f_n\geq \varphi\}\)</span>来得出结论</strong>，这完全可能对任何 <span class="math inline">\(n\)</span> 都是空集。但是如果可以证明对任何 <span class="math inline">\(0&lt;c&lt;1\)</span> 有 <span class="math display">\[\lim_{n\to\infty} \int f_n\,\mathrm{d}\mu\geq c\int \varphi\,\mathrm{d}\mu\]</span> 成立，那么令 <span class="math inline">\(c\uparrow1\)</span>即得结论（两边都是非负的）。而集合 <span class="math inline">\(E_n=\{f_n\geq c\varphi\}\)</span> 满足 <span class="math inline">\(E_n\uparrow\Omega\)</span>。于是由 <span class="math inline">\(f_n\geq c\varphi\mathbb{1}_{E_n}\)</span>以及积分单调性有 <span class="math display">\[\intf_n\,\mathrm{d}\mu\geqc\int\varphi\mathbb{1}_{E_n}\,\mathrm{d}\mu.\]</span> 由于 <span class="math inline">\(\varphi\)</span> 是简单函数，所以可设 <span class="math inline">\(\varphi = \sum_{k} a_k\mathbb{1}_{A_k}\)</span>并代入上面右边，有 <span class="math display">\[\intf_n\,\mathrm{d}\mu\geq c\int\varphi\mathbb{1}_{E_n}\,\mathrm{d}\mu=c\sum_{k}a_k\mu(A_k\cap E_n).\]</span> 令 <span class="math inline">\(n\to\infty\)</span> 并利用测度连续性 <span class="math inline">\(\mu(A_k\cap E_n)\uparrow\mu(A_k)\)</span> 即得<span class="math display">\[\lim_{n\to\infty} \intf_n\,\mathrm{d}\mu\geq c\sum_ka_k\mu(A_k)= c \int\varphi\,\mathrm{d}\mu.\]</span> 单调收敛定理得证。</p><p><strong>MCT告诉我们总是可以用一个只取有限多个值、每个值都有限的简单函数来逼近 <span class="math inline">\(f\)</span> 的积分</strong>。</p><p>非负可测函数 <span class="math inline">\(f\)</span>可以用简单函数序列 <span class="math display">\[\varphi_n =\sum_{k=1}^{2^{2n}}\frac{k-1}{2^n}\mathbb{1}_{\{\frac{k-1}{2^n}\leqf&lt;\frac{k}{2^n}\}} + 2^n\mathbb{1}_{\{f\geq 2^n\}}\]</span>来逼近。在第 <span class="math inline">\(n\)</span>次切割中，我们将切割范围扩大为原来的 2 倍以逼近 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\infty\)</span>的部分，同时将切割的间隔缩小为原来的 1/2 以保证逼近的误差是减小的。</p><h1 id="integrals-and-null-sets">9.1 Integrals and Null Sets</h1><p>本讲主要是论证积分的基本结论在 <span class="math inline">\(\mathrm{a.e.}\)</span>的情形下也都成立。此外介绍了非负可测函数列积分的 Fatou定理，它是上一讲中单调收敛定理的直接推论：</p><blockquote><p><strong>Fatou 定理</strong>：设 <span class="math inline">\(f_n\inL^+\)</span> 是非负可积函数列，则 <span class="math display">\[\int\liminf f_n\,\mathrm{d}\mu\leq \liminf \intf_n\,\mathrm{d}\mu.\]</span></p></blockquote><p>证明：设 <span class="math inline">\(g_n=\inf_{m\geqn}f_m\)</span>，则 <span class="math inline">\(g_n\leqf_m\)</span>，所以 <span class="math display">\[\intg_n\,\mathrm{d}\mu\leq\int f_m\,\mathrm{d}\mu,\quad n\leq m\]</span>从而 <span class="math inline">\(\int g_n\,\mathrm{d}\mu\leq\liminf\intf_m\,\mathrm{d}\mu\)</span>。 另一方面 <span class="math inline">\(g_n\uparrow\liminf f_n\)</span>，所以利用 MCT 有<span class="math display">\[\int\liminff_n\,\mathrm{d}\mu=\int\lim_{n\to\infty}g_n\,\mathrm{d}\mu=\lim_{n\to\infty}\intg_n\,\mathrm{d}\mu\leq\liminf\int f_m\,\mathrm{d}\mu.\]</span></p><hr><p>另一个重要结论是 Borel-Cantelli 引理：</p><blockquote><p><strong>Borel-Cantelli (Ⅰ)</strong>：如果 <span class="math inline">\(\sum_{n=0}^\infty\mu(A_n)&lt;\infty\)</span>，则<span class="math inline">\(\mu\{A_n,\ \mathrm{i.o.}\}=0\)</span>。</p></blockquote><p>这个用积分很容易看出来： <span class="math display">\[\sum_{n=0}^\infty\mu(A_n)=\int\sum_{n=0}^\infty\mathbb{1}_{A_n}\,\mathrm{d}\mu.\]</span>左边如果有限，那么右边的函数必须几乎处处有限，所以 <span class="math inline">\(\{A_n,\ \mathrm{i.o.}\}\)</span> 是零测集。</p><h1 id="l1-and-the-dct">9.2 L1 and the DCT</h1><p>本讲引入了一般可积函数的定义，并证明了控制收敛定理。</p><blockquote><p><strong>定义</strong>：称 <span class="math inline">\(f\inL^1(\Omega,\mathcal{F},\mathbb{P})\)</span> 为可积函数，如果 <span class="math inline">\(f^+,f^-\)</span> 都是可积的：<span class="math inline">\(\intf^{\pm}\,\mathrm{d}\mu&lt;\infty\)</span>。此时我们定义 <span class="math inline">\(\int f=\int f^+-\intf^-\)</span>。或者等价地，<span class="math inline">\(f\)</span>可积当且仅当 <span class="math inline">\(\int|f|\,\mathrm{d}\mu&lt;\infty\)</span>。</p></blockquote><p>对可积函数，积分是<strong>线性的</strong>、<strong>保持单调性的</strong>。</p><p>如果我们将几乎处处相等的函数看作是同一个函数的话，<span class="math inline">\(\|\cdot\|_{L^1}\)</span>是可积函数空间上的度量。</p><blockquote>  <meta charset="utf-8">  <meta name="generator" content="pandoc">  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">  <title>dummy</title>  <style>    html {      color: #1a1a1a;      background-color: #fdfdfd;    }    body {      margin: 0 auto;      max-width: 36em;      padding-left: 50px;      padding-right: 50px;      padding-top: 50px;      padding-bottom: 50px;      hyphens: auto;      overflow-wrap: break-word;      text-rendering: optimizeLegibility;      font-kerning: normal;    }    @media (max-width: 600px) {      body {        font-size: 0.9em;        padding: 12px;      }      h1 {        font-size: 1.8em;      }    }    @media print {      html {        background-color: white;      }      body {        background-color: transparent;        color: black;        font-size: 12pt;      }      p, h2, h3 {        orphans: 3;        widows: 3;      }      h2, h3, h4 {        page-break-after: avoid;      }    }    p {      margin: 1em 0;    }    a {      color: #1a1a1a;    }    a:visited {      color: #1a1a1a;    }    img {      max-width: 100%;    }    svg {      height: auto;      max-width: 100%;    }    h1, h2, h3, h4, h5, h6 {      margin-top: 1.4em;    }    h5, h6 {      font-size: 1em;      font-style: italic;    }    h6 {      font-weight: normal;    }    ol, ul {      padding-left: 1.7em;      margin-top: 1em;    }    li > ol, li > ul {      margin-top: 0;    }    blockquote {      margin: 1em 0 1em 1.7em;      padding-left: 1em;      border-left: 2px solid #e6e6e6;      color: #606060;    }    code {      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;      font-size: 85%;      margin: 0;      hyphens: manual;    }    pre {      margin: 1em 0;      overflow: auto;    }    pre code {      padding: 0;      overflow: visible;      overflow-wrap: normal;    }    .sourceCode {     background-color: transparent;     overflow: visible;    }    hr {      background-color: #1a1a1a;      border: none;      height: 1px;      margin: 1em 0;    }    table {      margin: 1em 0;      border-collapse: collapse;      width: 100%;      overflow-x: auto;      display: block;      font-variant-numeric: lining-nums tabular-nums;    }    table caption {      margin-bottom: 0.75em;    }    tbody {      margin-top: 0.5em;      border-top: 1px solid #1a1a1a;      border-bottom: 1px solid #1a1a1a;    }    th {      border-top: 1px solid #1a1a1a;      padding: 0.25em 0.5em 0.25em 0.5em;    }    td {      padding: 0.125em 0.5em 0.25em 0.5em;    }    header {      margin-bottom: 4em;      text-align: center;    }    #TOC li {      list-style: none;    }    #TOC ul {      padding-left: 1.3em;    }    #TOC > ul {      padding-left: 0;    }    #TOC a:not(:hover) {      text-decoration: none;    }    code{white-space: pre-wrap;}    span.smallcaps{font-variant: small-caps;}    div.columns{display: flex; gap: min(4vw, 1.5em);}    div.column{flex: auto; overflow-x: auto;}    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}    /* The extra [class] is a hack that increases specificity enough to       override a similar rule in reveal.js */    ul.task-list[class]{list-style: none;}    ul.task-list li input[type="checkbox"] {      font-size: inherit;      width: 0.8em;      margin: 0 0.8em 0.2em -1.6em;      vertical-align: middle;    }  </style>  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><p><strong>控制收敛定理</strong>：设 <span class="math inline">\(f_n,g\)</span> 都是可积函数并且 <span class="math inline">\(|f_n|\leqg\)</span>，<span class="math inline">\(\lim\limits_{n\to\infty}f_n=f\)</span>。 则 <span class="math inline">\(f\)</span> 也是可积函数并且 <span class="math inline">\(\lim\limits_{n\to\infty}\int f_n=\intf\)</span>。</p></blockquote><p><strong>证明概要</strong>：显然 <span class="math inline">\(|f|\leqg\)</span>，所以 <span class="math inline">\(f\)</span>可积，从而由线性性质 <span class="math inline">\(g\pm f\)</span>都是可积的。对可积函数序列 <span class="math inline">\(g\pm f_n\)</span>使用 Fatou 引理，有 <span class="math display">\[\int (g\pmf)\,\mathrm{d}\mu=\int\varliminf_{n\to\infty} (g\pmf_n)\,\mathrm{d}\mu\leq \varliminf_{n\to\infty}\int (g\pmf_n)\,\mathrm{d}\mu= \int g\,\mathrm{d}\mu\pm\varliminf_{n\to\infty}\intf_n\,\mathrm{d}\mu.\]</span> 比较两边有 <span class="math display">\[\int (g\pm f)\,\mathrm{d}\mu\leq \intg\,\mathrm{d}\mu\pm \varliminf_{n\to\infty}\intf_n\,\mathrm{d}\mu.\]</span> 消去 <span class="math inline">\(g\)</span>的积分，并注意对任何实数列 <span class="math inline">\(\{a_n\}\)</span>有 <span class="math inline">\(\varliminf\limits_{n\to\infty}(-a_n)=-\varlimsup\limits_{n\to\infty}a_n\)</span>，从而 <span class="math display">\[\varlimsup\intf_n\,\mathrm{d}\mu\leq \int f\,\mathrm{d}\mu\leq \varliminf\intf_n\,\mathrm{d}\mu.\]</span> 即得结论。</p><h1 id="probability-laws-revisited">11.2 Probability Laws Revisited</h1><blockquote><p><strong>积分的变量替换定理</strong>：设 <span class="math inline">\(X:\(\Omega,\mathcal{F},\mu)\to(\mathcal{S},\mathcal{B})\)</span>是一个可测映射，<span class="math inline">\((\mathcal{S},\mathcal{B})\)</span> 上的测度 <span class="math inline">\(\nu\)</span> 由 <span class="math inline">\(\nu(E)= \mu(X^{-1}(E))\)</span> 给出，<span class="math inline">\(g:\(\mathcal{S},\mathcal{B},\nu)\to\mathbb{R}\)</span> 是一个可积函数，则<span class="math display">\[\int_{\Omega}g\circX\,\mathrm{d}\mu=\int_{\mathcal{S}}g\,\mathrm{d}\nu.\]</span></p></blockquote><p><strong>证明概要</strong>：首先考察 <span class="math inline">\(g=\mathbb{1}_B,\,B\in\mathcal{B}\)</span>是指标函数的情形。 <span class="math display">\[\int_{\mathcal{S}}g\,\mathrm{d}\nu= \nu(B) =\mu(X^{-1}(B))=\int_{\Omega}\mathbb{1}_{X^{-1}(B)}\,\mathrm{d}\mu.\]</span>由于 <span class="math inline">\(\omega\in X^{-1}(B)\LeftrightarrowX(\omega)\in B\)</span>，所以 <span class="math inline">\(\mathbb{1}_{X^{-1}(B)} = \mathbb{1}_{B}\circX\)</span>，所以上式右边的积分等于 <span class="math display">\[\int_{\Omega}\mathbb{1}_{B}\circX\,\mathrm{d}\nu.\]</span>此时结论成立。根据积分的线性性质结论对简单函数也成立，从而进一步取极限可得对任何可积函数<span class="math inline">\(g\)</span> 都成立。</p><h1 id="convergence-in-measure">13.1 Convergence in measure</h1><p>本讲介绍了可测函数的依测度收敛概念，及其与逐点收敛之间的联系。</p><blockquote>  <meta charset="utf-8">  <meta name="generator" content="pandoc">  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">  <title>dummy</title>  <style>    html {      color: #1a1a1a;      background-color: #fdfdfd;    }    body {      margin: 0 auto;      max-width: 36em;      padding-left: 50px;      padding-right: 50px;      padding-top: 50px;      padding-bottom: 50px;      hyphens: auto;      overflow-wrap: break-word;      text-rendering: optimizeLegibility;      font-kerning: normal;    }    @media (max-width: 600px) {      body {        font-size: 0.9em;        padding: 12px;      }      h1 {        font-size: 1.8em;      }    }    @media print {      html {        background-color: white;      }      body {        background-color: transparent;        color: black;        font-size: 12pt;      }      p, h2, h3 {        orphans: 3;        widows: 3;      }      h2, h3, h4 {        page-break-after: avoid;      }    }    p {      margin: 1em 0;    }    a {      color: #1a1a1a;    }    a:visited {      color: #1a1a1a;    }    img {      max-width: 100%;    }    svg {      height: auto;      max-width: 100%;    }    h1, h2, h3, h4, h5, h6 {      margin-top: 1.4em;    }    h5, h6 {      font-size: 1em;      font-style: italic;    }    h6 {      font-weight: normal;    }    ol, ul {      padding-left: 1.7em;      margin-top: 1em;    }    li > ol, li > ul {      margin-top: 0;    }    blockquote {      margin: 1em 0 1em 1.7em;      padding-left: 1em;      border-left: 2px solid #e6e6e6;      color: #606060;    }    code {      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;      font-size: 85%;      margin: 0;      hyphens: manual;    }    pre {      margin: 1em 0;      overflow: auto;    }    pre code {      padding: 0;      overflow: visible;      overflow-wrap: normal;    }    .sourceCode {     background-color: transparent;     overflow: visible;    }    hr {      background-color: #1a1a1a;      border: none;      height: 1px;      margin: 1em 0;    }    table {      margin: 1em 0;      border-collapse: collapse;      width: 100%;      overflow-x: auto;      display: block;      font-variant-numeric: lining-nums tabular-nums;    }    table caption {      margin-bottom: 0.75em;    }    tbody {      margin-top: 0.5em;      border-top: 1px solid #1a1a1a;      border-bottom: 1px solid #1a1a1a;    }    th {      border-top: 1px solid #1a1a1a;      padding: 0.25em 0.5em 0.25em 0.5em;    }    td {      padding: 0.125em 0.5em 0.25em 0.5em;    }    header {      margin-bottom: 4em;      text-align: center;    }    #TOC li {      list-style: none;    }    #TOC ul {      padding-left: 1.3em;    }    #TOC > ul {      padding-left: 0;    }    #TOC a:not(:hover) {      text-decoration: none;    }    code{white-space: pre-wrap;}    span.smallcaps{font-variant: small-caps;}    div.columns{display: flex; gap: min(4vw, 1.5em);}    div.column{flex: auto; overflow-x: auto;}    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}    /* The extra [class] is a hack that increases specificity enough to       override a similar rule in reveal.js */    ul.task-list[class]{list-style: none;}    ul.task-list li input[type="checkbox"] {      font-size: inherit;      width: 0.8em;      margin: 0 0.8em 0.2em -1.6em;      vertical-align: middle;    }  </style>  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><p><strong>定义</strong>：称 <span class="math inline">\(f_n\to_{\mu}f\)</span> 为依测度收敛，如果对任意 <span class="math inline">\(\epsilon&gt;0\)</span> 有 <span class="math display">\[\lim_{n\to\infty}\mu\{|f_n-f|\geq0\}=0.\]</span></p></blockquote><p><strong>依测度收敛但不处处收敛的例子</strong>：将区间 <span class="math inline">\([0, 1]\)</span> 等分为 <span class="math inline">\(2^n\)</span>份，将它们的指标函数排成一排，再对所有 <span class="math inline">\(n\)</span> 将这些片段排列起来得到序列 <span class="math inline">\(f_n\)</span>，则 <span class="math inline">\(f_n\)</span> 依测度收敛到 0 但不逐点收敛。</p><p><strong>接下来是一个将测度和逐点收敛联系起来的重要技巧</strong>：根据几乎处处收敛的定义，<span class="math inline">\(f_n\to f,\mathrm{a.e.}\)</span> 收敛即要求对任何<span class="math inline">\(\epsilon&gt;0\)</span> 有 <span class="math display">\[\mu\{|f_n-f|\geq\epsilon,\ \mathrm{i.o.}\} =0.\]</span>这样就可以把逐点收敛和测度联系起来。有时候我们还可以使用更强的条件：<span class="math display">\[\mu\{|f_n-f|\geq 2^{-n},\ \mathrm{i.o.}\} =0.\]</span> 这是因为对任何 <span class="math inline">\(\epsilon\)</span>，<span class="math inline">\(n\)</span> 足够大时 <span class="math inline">\(2^{-n}&lt;\epsilon\)</span>, 从而 <span class="math inline">\(\{|f_n-f|\geq\epsilon\}\subseteq\{|f_n-f|\geq2^{-n}\}\)</span>，前者发生无穷多次自然意味着后者也发生无穷多次。这样就可以和Borel-Cantelli 引理结合起来使用，只要 <span class="math display">\[\sum_{n}\mu\{|f_n - f|\geq 2^{-n}\} &lt;\infty,\]</span> 就可以保证 <span class="math inline">\(\{f_n\}\)</span>是几乎处处收敛的。</p><blockquote>  <meta charset="utf-8">  <meta name="generator" content="pandoc">  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">  <title>dummy</title>  <style>    html {      color: #1a1a1a;      background-color: #fdfdfd;    }    body {      margin: 0 auto;      max-width: 36em;      padding-left: 50px;      padding-right: 50px;      padding-top: 50px;      padding-bottom: 50px;      hyphens: auto;      overflow-wrap: break-word;      text-rendering: optimizeLegibility;      font-kerning: normal;    }    @media (max-width: 600px) {      body {        font-size: 0.9em;        padding: 12px;      }      h1 {        font-size: 1.8em;      }    }    @media print {      html {        background-color: white;      }      body {        background-color: transparent;        color: black;        font-size: 12pt;      }      p, h2, h3 {        orphans: 3;        widows: 3;      }      h2, h3, h4 {        page-break-after: avoid;      }    }    p {      margin: 1em 0;    }    a {      color: #1a1a1a;    }    a:visited {      color: #1a1a1a;    }    img {      max-width: 100%;    }    svg {      height: auto;      max-width: 100%;    }    h1, h2, h3, h4, h5, h6 {      margin-top: 1.4em;    }    h5, h6 {      font-size: 1em;      font-style: italic;    }    h6 {      font-weight: normal;    }    ol, ul {      padding-left: 1.7em;      margin-top: 1em;    }    li > ol, li > ul {      margin-top: 0;    }    blockquote {      margin: 1em 0 1em 1.7em;      padding-left: 1em;      border-left: 2px solid #e6e6e6;      color: #606060;    }    code {      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;      font-size: 85%;      margin: 0;      hyphens: manual;    }    pre {      margin: 1em 0;      overflow: auto;    }    pre code {      padding: 0;      overflow: visible;      overflow-wrap: normal;    }    .sourceCode {     background-color: transparent;     overflow: visible;    }    hr {      background-color: #1a1a1a;      border: none;      height: 1px;      margin: 1em 0;    }    table {      margin: 1em 0;      border-collapse: collapse;      width: 100%;      overflow-x: auto;      display: block;      font-variant-numeric: lining-nums tabular-nums;    }    table caption {      margin-bottom: 0.75em;    }    tbody {      margin-top: 0.5em;      border-top: 1px solid #1a1a1a;      border-bottom: 1px solid #1a1a1a;    }    th {      border-top: 1px solid #1a1a1a;      padding: 0.25em 0.5em 0.25em 0.5em;    }    td {      padding: 0.125em 0.5em 0.25em 0.5em;    }    header {      margin-bottom: 4em;      text-align: center;    }    #TOC li {      list-style: none;    }    #TOC ul {      padding-left: 1.3em;    }    #TOC > ul {      padding-left: 0;    }    #TOC a:not(:hover) {      text-decoration: none;    }    code{white-space: pre-wrap;}    span.smallcaps{font-variant: small-caps;}    div.columns{display: flex; gap: min(4vw, 1.5em);}    div.column{flex: auto; overflow-x: auto;}    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}    /* The extra [class] is a hack that increases specificity enough to       override a similar rule in reveal.js */    ul.task-list[class]{list-style: none;}    ul.task-list li input[type="checkbox"] {      font-size: inherit;      width: 0.8em;      margin: 0 0.8em 0.2em -1.6em;      vertical-align: middle;    }  </style><p><strong>定理</strong>：逐点收敛可以推出依测度收敛。</p></blockquote><p><strong>简要证明</strong>：对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，记 <span class="math inline">\(A_n=\{|f_n-f|\geq\epsilon\}\)</span>，则 <span class="math display">\[\mu\{A_n,\ \mathrm{i.o.}\} =\lim_{n\to\infty}\mu(\bigcup_{k\geq n}A_k)\geq\lim_{n\to\infty}\mu(A_n).\]</span></p><blockquote>  <meta charset="utf-8">  <meta name="generator" content="pandoc">  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">  <title>dummy</title>  <style>    html {      color: #1a1a1a;      background-color: #fdfdfd;    }    body {      margin: 0 auto;      max-width: 36em;      padding-left: 50px;      padding-right: 50px;      padding-top: 50px;      padding-bottom: 50px;      hyphens: auto;      overflow-wrap: break-word;      text-rendering: optimizeLegibility;      font-kerning: normal;    }    @media (max-width: 600px) {      body {        font-size: 0.9em;        padding: 12px;      }      h1 {        font-size: 1.8em;      }    }    @media print {      html {        background-color: white;      }      body {        background-color: transparent;        color: black;        font-size: 12pt;      }      p, h2, h3 {        orphans: 3;        widows: 3;      }      h2, h3, h4 {        page-break-after: avoid;      }    }    p {      margin: 1em 0;    }    a {      color: #1a1a1a;    }    a:visited {      color: #1a1a1a;    }    img {      max-width: 100%;    }    svg {      height: auto;      max-width: 100%;    }    h1, h2, h3, h4, h5, h6 {      margin-top: 1.4em;    }    h5, h6 {      font-size: 1em;      font-style: italic;    }    h6 {      font-weight: normal;    }    ol, ul {      padding-left: 1.7em;      margin-top: 1em;    }    li > ol, li > ul {      margin-top: 0;    }    blockquote {      margin: 1em 0 1em 1.7em;      padding-left: 1em;      border-left: 2px solid #e6e6e6;      color: #606060;    }    code {      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;      font-size: 85%;      margin: 0;      hyphens: manual;    }    pre {      margin: 1em 0;      overflow: auto;    }    pre code {      padding: 0;      overflow: visible;      overflow-wrap: normal;    }    .sourceCode {     background-color: transparent;     overflow: visible;    }    hr {      background-color: #1a1a1a;      border: none;      height: 1px;      margin: 1em 0;    }    table {      margin: 1em 0;      border-collapse: collapse;      width: 100%;      overflow-x: auto;      display: block;      font-variant-numeric: lining-nums tabular-nums;    }    table caption {      margin-bottom: 0.75em;    }    tbody {      margin-top: 0.5em;      border-top: 1px solid #1a1a1a;      border-bottom: 1px solid #1a1a1a;    }    th {      border-top: 1px solid #1a1a1a;      padding: 0.25em 0.5em 0.25em 0.5em;    }    td {      padding: 0.125em 0.5em 0.25em 0.5em;    }    header {      margin-bottom: 4em;      text-align: center;    }    #TOC li {      list-style: none;    }    #TOC ul {      padding-left: 1.3em;    }    #TOC > ul {      padding-left: 0;    }    #TOC a:not(:hover) {      text-decoration: none;    }    code{white-space: pre-wrap;}    span.smallcaps{font-variant: small-caps;}    div.columns{display: flex; gap: min(4vw, 1.5em);}    div.column{flex: auto; overflow-x: auto;}    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}    /* The extra [class] is a hack that increases specificity enough to       override a similar rule in reveal.js */    ul.task-list[class]{list-style: none;}    ul.task-list li input[type="checkbox"] {      font-size: inherit;      width: 0.8em;      margin: 0 0.8em 0.2em -1.6em;      vertical-align: middle;    }  </style>  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><p><strong>定理</strong>：设 <span class="math inline">\(\{f_n\}\)</span> 为依测度收敛的 Cauchy 序列：<span class="math display">\[\lim_{n,m\to\infty}\mu\{|f_n-f_m|\geq\epsilon\} =0.\]</span> 则 <span class="math inline">\(f_n\)</span>必有逐点收敛的子序列 <span class="math inline">\(f_{n_k}\to f\\mathrm{a.e.}\)</span>，并且 <span class="math inline">\(f_n\)</span>依测度收敛到 <span class="math inline">\(f\)</span>。</p></blockquote><p><strong>简要证明必有逐点收敛的子序列</strong>：利用上面介绍的技巧，归结为抽取子序列<span class="math inline">\(\{f_{n_k}\}\)</span> 满足 <span class="math display">\[\mu\{|f_{n_{k+1}} - f_{n_k}|\geq2^{-k},\\mathrm{i.o.}\} = 0.\]</span> 利用 Borel-Cantelli 引理这只要让 <span class="math inline">\(\sum_{k=1}^\infty\mu\{|f_{n_{k+1}} - f_{n_k}|\geq2^{-k}\}&lt;\infty\)</span> 即可。为此又只要让 <span class="math inline">\(\mu\{|f_{n_{k+1}} - f_{n_k}|\geq 2^{-k}\}\leq2^{-k}\)</span> 即可。根据 Cauchy 条件这是可以做到的。</p><p><strong>简要证明这个子序列的逐点极限是原序列的依测度极限</strong>：对任何<span class="math inline">\(n\)</span>，取 <span class="math inline">\(n_{k}&gt;n\)</span> 则有 <span class="math display">\[\{|f_n-f|\geq\epsilon\}\subseteq\{|f_n-f_{n_k}|\geq\epsilon/2\}\cup\{|f_{n_k}-f|\geq\epsilon/2\}.\]</span> 显然 <span class="math inline">\(n\)</span> 足够大时右边两个集合测度都趋于 0。</p><h1 id="lp-is-complete">13.2 <span class="math inline">\(L^p\)</span> isComplete</h1><p>首先我们来证明 <span class="math inline">\(L^p\)</span>收敛可以推出依测度收敛。</p><blockquote><p><strong>定理</strong>：<span class="math inline">\(L^p\)</span>度量是完备的，任何 Cauchy 序列必有极限。</p></blockquote><p><strong>证明概要</strong>：<span class="math inline">\(L^p\)</span>Cauchy 列也都是依测度 Cauchy 列，从而有几乎处处收敛的子序列 <span class="math inline">\(f_{n_k}\to f\)</span>。对固定的 <span class="math inline">\(k\)</span>，当 <span class="math inline">\(j&gt;k\)</span> 时有 <span class="math display">\[\begin{align*}\int\|f_{n_k}-f\|^p\,\mathrm{d}\mu&amp;=\int\lim_{j\to\infty}\|f_{n_k}-f_{n_j}\|^p\,\mathrm{d}\mu\leq\liminf_{j\to\infty}\int\|f_{n_k}-f_{n_j}\|^p\,\mathrm{d}\mu\\&amp;\leq\limsup_{j\to\infty}\int\|f_{n_k}-f_{n_j}\|^p\,\mathrm{d}\mu.\end{align*}\]</span>两边令 <span class="math inline">\(k\to\infty\)</span> 并利用 Cauchy条件即得子序列 <span class="math inline">\(f_{n_k}\xrightarrow{L^p}f\)</span>。再利用 Cauchy条件可得原序列 <span class="math inline">\(f_n\xrightarrow{L^p}f\)</span>。</p><blockquote><p><strong>依测度控制收敛定理</strong>：设 <span class="math inline">\(f_n\)</span> 依测度收敛到 <span class="math inline">\(f\)</span>，且 <span class="math inline">\(|f_n|\leq f,\, f\in L^1\)</span>。则 <span class="math inline">\(f_n\xrightarrow{L^1} f\)</span>。</p></blockquote><p><strong>证明概要</strong>：假设 <span class="math inline">\(f_n\)</span> 不 <span class="math inline">\(L^1\)</span> 收敛到 <span class="math inline">\(f\)</span>，则对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，存在子序列 <span class="math inline">\(f_{n_k}\)</span> 满足：</p><ul><li><span class="math inline">\(\|f_{n_k} -f\|_{L^1}\geq\epsilon\)</span>。</li><li><span class="math inline">\(f_{n_k}\)</span> 几乎处处收敛到 <span class="math inline">\(f\)</span>。</li></ul><p>这与控制收敛定理矛盾。</p><h1 id="independence">15.1 Independence</h1><p>本讲介绍了事件和 <span class="math inline">\(\sigma\)</span>-域之间的独立性概念。</p><p>要点总结：</p><ol type="1"><li>若干个事件 <span class="math inline">\(\{A_n\}\)</span>独立不是指它们两两独立，而是其中任何有限多个子事件都独立。</li><li>验证若干 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\{\mathcal{F}_i\}\)</span>独立只需要验证生成它们的 <span class="math inline">\(\pi\)</span>- 系<span class="math inline">\(\{C_i:\ \mathcal{F}_i=\sigma(C_i)\}\)</span>独立。</li></ol><blockquote><p><strong>Borel-Cantelli 引理 II</strong>：设 <span class="math inline">\(\{A_n\}\)</span> 是独立的事件列，则若 <span class="math inline">\(\sum_{n=1}^\infty\mathbb{P}(A_n)=\infty\)</span>，则<span class="math inline">\(\mathbb{P}(\{A_n,\mathrm{i.o.}\})=1\)</span>。</p></blockquote><p>想法还是要用独立性，转到事件的交上去。</p><p><span class="math display">\[\mathbb{P}(\{A_n,\\mathrm{i.o.}\})=\mathbb{P}(\bigcap_{n=1}^\infty\bigcup_{k\geqn}A_k)=\lim_{n\to\infty}\mathbb{P}(\bigcup_{k\geq n}A_k).\]</span>观察两边，要想用上独立性，就得取补： <span class="math display">\[1-\mathbb{P}(\bigcup_{k\geqn}A_k)=\mathbb{P}(\bigcap_{k\geqn}A_k^c)=\lim_{M\to\infty}\prod_{k=n}^M\mathbb{P}(A_k^c)=\lim_{M\to\inftyy}\prod_{k=n}^M(1-\mathbb{P}(A_k)).\]</span> 利用 <span class="math inline">\(1-x\leq e^{-x}\)</span> 有 <span class="math display">\[\lim_{M\to\infty}\prod_{k=n}^M(1-\mathbb{P}(A_k))\leq\lim_{M\to\infty}\prod_{k=n}^Me^{-\mathbb{P}(A_k)}=\lim_{M\to\infty}e^{-\sum_{k=n}^M\mathbb{P}(A_k)}.\]</span>上式右边对任何固定的 <span class="math inline">\(n\)</span> 其极限都是0，从而 <span class="math inline">\(\mathbb{P}(\bigcup_{k\geqn}A_k)\to1\)</span>，结论得证。</p><h1 id="independent-random-variables">15.2 Independent RandomVariables</h1><p>上一讲介绍了独立事件和独立事件域的概念，这一讲介绍了独立随机变量的概念。</p><blockquote><p><strong>定义</strong>：一族随机变量 <span class="math inline">\(\{X_i\}_{i\in I}\)</span> 称作是独立的，如果它们的<span class="math inline">\(\sigma-\)</span> 域 <span class="math inline">\(\{\sigma(X_i)\}_{i\in I}\)</span> 是独立的。</p></blockquote><p>由于 <span class="math inline">\(\sigma(X_i)\)</span> 可以由 <span class="math inline">\(\pi-\)</span> 系 <span class="math inline">\(\{X_i\in(-\infty, t_i]\}\)</span>生成，所以只要验证这个 <span class="math inline">\(\pi-\)</span>系的独立性即可。</p><blockquote><p><strong>定理</strong>：设 <span class="math inline">\(X=(X_1,\ldots,X_n)\)</span>，其中每个 <span class="math inline">\(X_i:(\Omega,\mathcal{F},\mathbb{P})\to(\mathcal{S}_i,\mathcal{B}_i)\)</span>是随机变量，<span class="math inline">\(\mu_X\)</span> 是 <span class="math inline">\(\mathcal{B}_1\otimes\cdots\otimes\mathcal{B}_n\)</span>上的测度: <span class="math inline">\(\mu_X(B)=\mathbb{P}(X\inB)\)</span>。则 <span class="math inline">\(X_1,X_2,\ldots,X_n\)</span>独立当且仅当 <span class="math inline">\(\mu_X=\mu_{X_1}\otimes\cdots\otimes\mu_{X_n}\)</span>。</p></blockquote><p>证明：<span class="math inline">\(\Leftarrow\)</span>:</p><p><span class="math display">\[\begin{align*}\mathbb{P}(X_1\inB_1,\ldots,X_n\in B_n)&amp;=\mu_X(B_1\times \cdots\times B_n)\\&amp;=\mu_{X_1}(B_1)\cdots\mu_{X_n}(B_n)\\&amp;=\mathbb{P}(X_1\in B_1)\cdots\mathbb{P}(X_n\inB_n).\end{align*}\]</span></p><p><span class="math inline">\(\Rightarrow\)</span>: 简单。</p><blockquote><p><strong>推论</strong>：如果 <span class="math inline">\(X_1,X_2,\ldots,X_n\)</span> 都是 <span class="math inline">\(L^1\)</span> 可积的随机变量，则 <span class="math inline">\(X_1X_2\cdots X_n\in L^1\)</span> 且 <span class="math inline">\(\mathbb{E}[X_1\cdotsX_n]=\mathbb{E}[X_1]\cdots\mathbb{E}[X_n]\)</span>。</p></blockquote><p>首先对 <span class="math inline">\(|X_1X_2\cdots X_n|\)</span> 用Tonelli 定理得出 <span class="math inline">\(|X_1X_2\cdots X_n|\)</span>可积，然后再对 <span class="math inline">\(X_1X_2\cdots X_n\)</span> 用Fubini 定理。</p><blockquote><p><strong>推论</strong>：如果 <span class="math inline">\(X_1,\ldots,X_n,Y_1,\ldots,Y_m\)</span>是一组独立的随机变量，则 <span class="math inline">\(f(X_1,\ldots,X_n)\)</span> 和 <span class="math inline">\(g(Y_1,\ldots,Y_m)\)</span> 也是独立的。</p></blockquote><p>这是因为 <span class="math inline">\(\sigma(f(X_1,\ldots,X_n))\subseteq\sigma(X_1,\ldots,X_n)\)</span>，<span class="math inline">\(\sigma(g(Y_1,\ldots,Y_m))\subseteq\sigma(Y_1,\ldots,Y_m)\)</span>，所以也是独立的。</p><h1 id="kolmogorovs-extension-theorem">16.1/16.2 Kolmogorov’s ExtensionTheorem</h1><p>这两讲的目的是介绍 Kolmogorov扩张定理，即构造无穷乘积可测空间使得其有限维分布为给定的、满足相容性条件的有限维分布。</p><p>Kolmogorov扩张定理看起来是一个纯测度论定理，但它本质与空间的拓扑性质有关。</p><p>设 <span class="math inline">\(I\)</span> 是指标集，<span class="math inline">\(\{\mathcal{A}_i,\, i\in I\}\)</span>是某个样本空间 <span class="math inline">\(\Omega\)</span> 的一族子<span class="math inline">\(\sigma-\)</span> 代数（每个 <span class="math inline">\(\mathcal{A}_i\)</span> 都是一个 <span class="math inline">\(\sigma-\)</span> 代数），满足条件：对任何两个<span class="math inline">\(\sigma-\)</span> 代数 <span class="math inline">\(\mathcal{A}_\alpha,\mathcal{A}_\beta\)</span>，都存在<span class="math inline">\(\mathcal{A}_\gamma\)</span> （<span class="math inline">\(\mathcal{A}_\gamma\)</span> 未必唯一）使得 <span class="math inline">\(\mathcal{A}_\alpha\subset\mathcal{A}_\gamma,\,\mathcal{A}_\beta\subset\mathcal{A}_\gamma\)</span>。</p><p>设 <span class="math inline">\(\mathbb{P}_i\)</span> 是 <span class="math inline">\(\mathcal{A}_i\)</span> 上的概率测度，如果对任何<span class="math inline">\(\mathcal{A}_\alpha\subset\mathcal{A}_\gamma\)</span>还有 <span class="math display">\[\mathbb{P}_\gamma \big|_{A_\alpha} =\mathbb{P}_\alpha.\]</span> 这时我们就称概率空间 <span class="math inline">\(\{(\mathcal{A}_i,\mathbb{P}_i)\}\)</span><strong>满足 Kolmogorov 相容性条件</strong>。</p><p>这就自然地引出一个问题：是否存在代数 <span class="math inline">\(\mathcal{A}=\cup_{i\in I}\mathcal{A}_i\)</span>上存在一个可数可加的概率测度 <span class="math inline">\(\mathbb{P}\)</span>，使得它是所有 <span class="math inline">\(\mathbb{P}_i\)</span> 的扩张？即对任何 <span class="math inline">\(\mathcal{A}_i\)</span> 都有 <span class="math inline">\(\mathbb{P}\big|_{\mathcal{A}_i}=\mathbb{P}_i\)</span>？如果有这样的 <span class="math inline">\(\mathbb{P}\)</span>，我们就可以用 Carathéodory定理将 <span class="math inline">\(\mathbb{P}\)</span> 扩张为 <span class="math inline">\(\sigma(\mathcal{A})\)</span>上的可数可加测度。</p><p>基本逻辑是：</p><ol type="1"><li>根据 Carathéodory 测度扩张定，我们只要证明代数 <span class="math inline">\(\mathcal{A}=\cup_{n=1}^\infty\mathcal{B}_n\)</span>上的有限可加测度是可数可加的。这里 <span class="math display">\[\mathcal{B}_n=\mathcal{B}([0,1])^n\times Q,\quadQ=[0,1]^{\infty}.\]</span> 而这只要证明测度的连续性：若 <span class="math inline">\(B_n\in\mathcal{A}, B_n\downarrow\)</span> 且 <span class="math inline">\(\inf_n\mathbb{P}(B_n)=\epsilon&gt;0\)</span>，则<span class="math inline">\(\cap B_n\ne\emptyset\)</span>。</li><li>我们可以不妨假设 <span class="math inline">\(B_n\in\mathcal{B}_n\)</span>。这可以通过拉伸整个序列，在缝隙中塞上<span class="math inline">\(\Omega_k\)</span> 或者 <span class="math inline">\(B_k\)</span> 来得到。</li><li>我们可以取紧集 <span class="math inline">\(K_n\in B_n\)</span> 使得<span class="math inline">\(\mu(B_n\backslashK_n)&lt;\epsilon/2^n\)</span>，然后证明对任何 <span class="math inline">\(N\)</span>，<span class="math inline">\(\cap_{n=1}^NK_n\)</span> 非空，然后利用 <span class="math inline">\(Q\)</span> 的紧性，和紧集的有限交性质，证明 <span class="math inline">\(\cap_{n=1}^\infty K_n\)</span> 非空，从而 <span class="math inline">\(\cap_{n=1}^\infty B_n\)</span> 非空。</li><li>在上一步中，可以取这样的紧集 <span class="math inline">\(K_n\)</span> 要用到 <span class="math inline">\(R^d\)</span> 上的概率测度是 Radon测度这一性质：它们同时被开集从外部逼近和紧集从内部逼近。<span class="math inline">\(Q\)</span> 的紧性是用了 Tychonoff 定理。</li></ol><blockquote><p><strong>引理</strong>：<span class="math inline">\(K\)</span></p></blockquote><h1 id="kolmogorovs-0-1-law">17.1 Kolmogorov’s 0-1 Law</h1><p>本讲介绍了独立随机变量序列的尾事件，以及 Kolmogrov 0-1 律。</p><p>设 <span class="math inline">\(\{X_n\}\)</span> 是独立的随机变量序列(不是两两独立，而是任何有限多个都独立)称 <span class="math inline">\(\mathcal{T}=\cap_{n=1}^\infty\sigma(X_n,X_{n+1},\ldots)\)</span>为尾事件域。</p><blockquote><p><strong>Kolmogrov 0-1 律</strong>：对任何 <span class="math inline">\(A\in\mathcal{T}\)</span> 有 <span class="math inline">\(\mathbb{P}(A)\in\{0,1\}\)</span>。</p></blockquote><p><strong>证明概要</strong>：</p><ul><li><span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span> 和 <span class="math inline">\(\sigma(X_{n+1},X_{n+2},\ldots)\)</span>是独立的。因为考虑如下两个集合族： <span class="math display">\[\{\text{all finite intersections like }\cap A_i,A_i\in\sigma(X_i),i=1,2,\ldots,n\}.\]</span> <span class="math display">\[\{\text{all finite intersections like }\cap A_j,A_j\in\sigma(X_j),j=n+1,n+2,\ldots\}.\]</span> 这俩都是 <span class="math inline">\(\pi\)</span>- 系且互相独立，所以它们生成的 <span class="math inline">\(\sigma\)</span>- 域也独立。前者可以生成 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span>，后者可以生成<span class="math inline">\(\sigma(X_{n+1},X_{n+2},\ldots)\)</span>。</li><li>于是 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span> 和<span class="math inline">\(\mathcal{T}\)</span> 是独立的。</li><li>于是 <span class="math inline">\(\pi\)</span>- 系 <span class="math inline">\(\cup_{n=1}^\infty\sigma(X_1,\ldots,X_n)\)</span>和 <span class="math inline">\(\mathcal{T}\)</span> 是独立的。</li><li>于是 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\sigma(X_1,\ldots,X_n,\ldots)\)</span> 和 <span class="math inline">\(\mathcal{T}\)</span> 独立，从而 <span class="math inline">\(\mathcal{T}\)</span> 和 <span class="math inline">\(\mathcal{T}\)</span> 独立，从而得证。</li></ul><h1 id="uniform-integrability">48.1 Uniform Integrability</h1><p>这一讲介绍了随机变量集合的一致可积性，要点非常多。</p><p>对任何 <span class="math inline">\(L^1\)</span> 的随机变量 <span class="math inline">\(X\)</span>，总是可以找一个紧集 <span class="math inline">\(K\)</span>，使得 <span class="math inline">\(|X|\)</span> 在 <span class="math inline">\(K^c\)</span> 上的积分任意小：对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，存在 <span class="math inline">\(a&gt;0\)</span> 使得 <span class="math inline">\(\mathbb{E}[|X|:\ |X|\geqa]&lt;\epsilon\)</span>。但是如果是一族可积的随机变量的话，这个统一的<span class="math inline">\(a\)</span> 就未必存在了。</p><p>如果这样的 <span class="math inline">\(a\)</span>总是存在的话，我们就称这族随机变量是一致可积的。</p><blockquote><p><strong>定义</strong>：随机变量列 <span class="math inline">\(\{X_n\}\)</span> 称作是一致可积的 (UI)的，如果它们满足以下条件：</p><ol type="1"><li>每个 <span class="math inline">\(X_i\)</span> 都是 <span class="math inline">\(L^1\)</span> 的。</li><li>对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，存在<span class="math inline">\(a&gt;0\)</span> 使得 <span class="math inline">\(\sup_n\mathbb{E}[X_n:\ |X_n|\geq a]&lt;\epsilon\)</span>。</li></ol></blockquote><p>不难验证如果 <span class="math inline">\(\{X_n\}\)</span>被一个可积随机变量控制，则它们是一致可积的：</p><blockquote><p><strong>例子 1</strong>：如果 <span class="math inline">\(|X_n|\leqY,\ Y\in L^1\)</span>，则 <span class="math inline">\(\{X_n\}\)</span>是一致可积的。</p></blockquote><p>这是因为被积函数和积分区域都可以放大：<span class="math inline">\(\mathbb{E}[|X_n|:\ |X_n|\geqa]\leq\mathbb{E}[|Y|:\ |Y|\geq a]\)</span>。</p><blockquote><p><strong>例子 2</strong>：如果 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(L^p,\,p&gt;1\)</span> 一致有界的：<span class="math inline">\(\sup_n\mathbb{E}|X_n|^p&lt;\infty\)</span>，则<span class="math inline">\(\{X_n\}\)</span> 是一致可积的。</p></blockquote><p>这是因为被积函数可以放大： <span class="math display">\[\mathbb{E}[|X|: |X|\geq a]\leq\mathbb{E}[|X|\cdot\frac{|X|^{p-1}}{a^{p-1}}: |X|\geq a] =\frac{1}{a^{p-1}}\mathbb{E}[|X|^p: |X|\geq a]\leq\frac{M}{a^{p-1}}.\]</span></p><p>这个例子中的 <span class="math inline">\(p&gt;1\)</span> 是不能减弱为<span class="math inline">\(p\geq1\)</span> 的。不过我们可以证明 UI的变量族必然是 <span class="math inline">\(L^1\)</span> 一致有界的：</p><blockquote><p><strong>定理</strong>：若 <span class="math inline">\(\{X_n\}\)</span> 一致可积，则 <span class="math inline">\(\sup_n E|X_n| &lt;\infty\)</span>。</p></blockquote><p>取 <span class="math inline">\(a\)</span> 使得 <span class="math inline">\(\sup_n \mathbb{E}[|X_n|: |X_n|\geq a] &lt;1\)</span>，则不难证明 <span class="math inline">\(\mathbb{E}|X_n| &lt;a+1\)</span>。</p><p>现在我们来给出一致绝对连续的概念，并将说明<strong>一致可积 = <span class="math inline">\(L^1\)</span> 一致有界 +一致绝对连续</strong>。</p><blockquote><p><strong>定义</strong>：随机变量序列 <span class="math inline">\(\{X_n\}\)</span> 是一致绝对连续的，如果对任何<span class="math inline">\(\epsilon&gt;0\)</span>，都存在 <span class="math inline">\(\delta&gt;0\)</span>，使得只要集合 <span class="math inline">\(B\)</span> 满足 <span class="math inline">\(\mu(B)&lt;\delta\)</span>，就有 <span class="math inline">\(\sup_n\mathbb{E}[|X_n|:B]&lt;\epsilon\)</span>。</p></blockquote><blockquote><p><strong>定理</strong>：<span class="math inline">\(\{X_n\}\)</span>一致可积当且仅当它们 <span class="math inline">\(L^1\)</span>一致有界且一致绝对连续。</p></blockquote><p><span class="math inline">\(\Rightarrow\)</span>: <span class="math inline">\(L^1\)</span>一致有界已经有了。下证一致绝对连续性质。对任何可测集 <span class="math inline">\(B\)</span>，我们考虑用一个待定的 <span class="math inline">\(a&gt;0\)</span> 把积分 <span class="math inline">\(\mathbb{E}[|X_n|: B]\)</span> 变成 <span class="math display">\[\mathbb{E}[|X_n|: B,\ |X_n|\geq a] +\mathbb{E}[|X_n|: B,\ |X_n|&lt;a].\]</span> 第一项小于等于 <span class="math inline">\(\mathbb{E}[|X_n|: |X_n|\geqa]\)</span>，由一致可积性我们可以取 <span class="math inline">\(a\)</span> 使得它小于 <span class="math inline">\(\epsilon/2\)</span>。第二项小于等于 <span class="math inline">\(a\mu(B)\)</span>。所以只要 <span class="math inline">\(\mu(B)&lt;\delta=\frac{\epsilon}{2a}\)</span>即可。</p><p><span class="math inline">\(\Leftarrow\)</span>: 我们可以料想 <span class="math inline">\(\{|X_n|\geq a\}\)</span>的测度是会一致地越来越小的：</p><p><span class="math display">\[\mathbb{P}(\{|X_n|\geqa\})=\mathbb{E}[1: |X_n|\geq a]\leq \mathbb{E}[\frac{|X_n|}{a}:|X_n|\geq a]\leq \frac{\mathbb{E}|X_n|}{a}=\frac{K}{a}.\]</span> 其中<span class="math inline">\(K\)</span> 是 <span class="math inline">\(\{X_n\}\)</span> 的 <span class="math inline">\(L^1\)</span> 上界。所以确实可以取 <span class="math inline">\(a\)</span> 适当大使得 <span class="math inline">\(\{|X_n|\geq a\}\)</span>的测度一致地小于一致绝对连续性中所需要的那个 <span class="math inline">\(\delta\)</span>。</p><blockquote><p><strong>定理</strong>：一致可积性是平移不变的： <span class="math inline">\(\{X_n\}\)</span> 一致可积且 <span class="math inline">\(Y\in L^1\)</span>，则 <span class="math inline">\(\{X_n+Y\}\)</span> 也是一致可积的。</p></blockquote><p>为此只要证明它们一致 <span class="math inline">\(L^1\)</span>有界且一致绝对连续。其中一致 <span class="math inline">\(L^1\)</span>有界是显然的。</p><p>对于一致绝对连续，我们有 <span class="math display">\[\mathbb{E}[|X_n+Y|: B]\leq\mathbb{E}[|X_n|:B] +\mathbb{E}[|Y|: B].\]</span> 取 <span class="math inline">\(\delta_1\)</span> 使得只要 <span class="math inline">\(\mu(B)&lt;\delta_1\)</span> 就有 <span class="math inline">\(\mathbb{E}[|X_n|:B]&lt;\frac{\epsilon}{2}\)</span>，再取<span class="math inline">\(\delta_2\)</span> 使得只要 <span class="math inline">\(\mu(B)&lt;\delta_2\)</span> 就有 <span class="math inline">\(\mathbb{E}[|Y|:B]&lt;\frac{\epsilon}{2}\)</span>，则<span class="math inline">\(\delta=\min\{\delta_1,\delta_2\}\)</span>符合要求。</p><p>最后一个重要定理是：<strong>依 <span class="math inline">\(L^1\)</span> 范数收敛 = 一致可积 +依测度收敛</strong>。</p><blockquote><p><strong>定理</strong>：随机变量序列 <span class="math inline">\(X_n\xrightarrow{L^1} X\)</span> 当且仅当 <span class="math inline">\(X_n\xrightarrow{\mathbb{P}}X\)</span> 且 <span class="math inline">\(\{X_n\}\)</span> 一致可积。</p></blockquote><p><span class="math inline">\(\Rightarrow\)</span>: <span class="math inline">\(L^1\)</span> 收敛当然可以得出依测度收敛 (Markov不等式一步即得)。要证明一致可积，我们只要根据平移不变性，证明 <span class="math inline">\(Y_n=X_n-X\)</span> 是一致可积的即可。</p><p>考虑取一个待定的正整数 <span class="math inline">\(N\)</span>，则<span class="math display">\[\sup_n\mathbb{E}[|Y_n|: |Y_n|\geq a] \leq\sup_{n&lt; N}\mathbb{E}[|Y_n|: |Y_n|\geq a] \vee \sup_{n\geqN}\mathbb{E}[|Y_n|: |Y_n|\geq a]\]</span>上面右边第一项是有限多个可积随机变量组成的集合，是一致可积的，所以只要<span class="math inline">\(a\)</span>足够大第一项是可以任意小的。第二项小于等于 <span class="math inline">\(\mathbb{E}|Y_n|\)</span> 并且由于 <span class="math inline">\(\mathbb{E}|Y_n|\to 0\)</span> 所以只要 <span class="math inline">\(N\)</span> 足够大也是可以任意小的。所以我们先取<span class="math inline">\(N\)</span> 足够大使得 <span class="math inline">\(\mathbb{E}|Y_n|&lt;\epsilon/2\)</span>，再取 <span class="math inline">\(a\)</span> 足够大使得 <span class="math inline">\(n&lt;N\)</span> 时 <span class="math inline">\(\sup_{n&lt; N}\mathbb{E}[|Y_n|: |Y_n|\geqa]&lt;\epsilon/2\)</span>，就得到了一致可积性。</p><p><span class="math inline">\(\Leftarrow\)</span>: 记 <span class="math inline">\(Y_n = X_n - X\)</span>，则 <span class="math inline">\(Y_n\mathbb{1}_{|Y_n|&lt;a}\)</span> 是一个不大于<span class="math inline">\(a\)</span> 的函数序列，且依测度收敛到0，从而由<strong>依测度的控制收敛定理</strong>有 <span class="math inline">\(Y_n\mathbb{1}_{|Y_n|&lt;a}\xrightarrow{L^1}0\)</span>。从而 <span class="math display">\[\|X_n-X\|_{L^1} =\mathbb{E}[Y_n\mathbb{1}_{\{|Y_n|&lt;a\}}] +\mathbb{E}[Y_n\mathbb{1}_{\{|Y_n|\geq a\}}].\]</span> 第一项取 <span class="math inline">\(n\)</span> 足够大就可以任意小，第二项取 <span class="math inline">\(a\)</span> 足够大也可以任意小，得证。</p><blockquote><p><strong>推论</strong>：正则鞅 <span class="math inline">\(X_n =\mathbb{E}[X|\mathcal{F}_n]\)</span> 是一致可积的。</p></blockquote><p>反过来也是对的：鞅序列如果是一致可积的，则一定是正则鞅。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>TODO List</title>
      <link href="todo/index.html"/>
      <url>todo/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="写作">写作</h1><ul><li>关于 SO3 的表示的文章，与球谐函数、有限群的不变量、Shephard-Todd定理的关系。配一个 shadertoy demo。</li><li>S_n 和 GL(n) 的表示论，Schur-Weyl 对偶。</li><li>六顶点模型，Yang-Baxter 方程和 ASM 的证明。</li><li>对称平面分拆的 Macdonald 猜想，Hall 多项式，SL(n)表示在计数中的应用。</li><li>永不回到原点的二维随机游动，介绍 Doob h-变换、调和测度。</li><li>扭结与动力系统</li><li>Lie 代数的 Minuscule 表示与对称平面分拆</li><li>GTM A course in enumeration 中剩余的 highlight 问题。</li><li>二维码与 Reed-Solomon 编码算法介绍</li><li>图的环空间与割空间，顶点膨胀技巧</li><li>Hilbert 曲线算法与 Golay 码</li><li>Aztec diamond arctic circle 现象的解释</li><li>Random walk, circle packing and conformal mapping.</li><li>Billiard ball，测度论，Poncelet 定理</li><li>Durrett 概率论 Brownian 运动部分改写</li><li>Indra’s pearls 部分内容介绍，附 shadertoy 动画</li><li>Raymarching 中 sdf 函数与各种变换的数学证明</li><li>正的 Hausdoff 维数意味常返性http://www.cmat.edu.uy/~lessa/resource/randomwalknotes.pdf</li><li>准晶，Faraday 驻波。</li><li>连分数，圆堆，Fary。</li><li>Fulton algebraic curves, Poncelet porism 的代数几何证明和 Jacobi椭圆函数证明</li><li>G2 and the rolling ball 是啥回事。</li><li>Mobius gear 和 Quaternion 是啥关系，flockaroo 的 shadertoy</li><li>蜂巢和 Gauss整数的关系：https://twitter.com/roice713/status/1497252225785204738?s=20&amp;t=WN0vB5s3eU_riCbC37nWiA</li><li>stable diffusion 学习</li><li>互锁的折纸 origami 正十二面体 | Interlock 多面体</li><li>hyperbolic billiards and modular group 似乎可以用 computeshader</li><li>局部中心极限定理 | 电流与同调 | 改写随机游动</li><li>手臂旋转翻面、旋转到底能不能给出反射？</li><li>quaternions and polytopes</li><li>概率论常用结论？单调类、Dynkin…</li><li>双曲内积</li></ul><h1 id="编程">编程</h1><ul><li>Python + cairo 实现 hyperbolic tiling 矢量绘图库。</li><li>shadertoy 实现 sphere gears，并解释与 SO3 的表示的关系</li><li>shaderoty 演示相对论</li><li>shadertoy 演示 Schottky 变换和 Droste 效应</li><li>shadertoy 实现自动微分和 implicit surface 渲染</li><li>用这个 https://www.shadertoy.com/view/NlKXWt 写一个 doyle spiral的例子</li><li>shadertoy 版本的 Jigsaw Penrose tiling</li><li>Python 实现 Voronoi + LLoyd 算法，理解 mapbox 的那个实现原理</li><li>Stange + sl2c 的 shader 研究实现</li><li>missing mirror，用正方体万花筒内部反射实现 pseudo kleinian</li><li>把 gifmaze 中 hilbert 曲线的例子改成对输入图像生成 hilbert曲线图</li><li>二维随机游动常返，如双曲、Penrose 等的判断。</li><li>继续可视化项目系列，可视化复分析 + indra’s pearls，可视化 circlepackings，可视化双曲空间 (Hee Oh)。</li><li>把 creative blocks 改改，渲染 mobius 变换</li><li>Shadertoy 实现双曲 dodecaheron space</li><li>Shadertoy 实现 hyperbolic weave</li><li>相对论 + 机器猫</li><li>Faraday 驻波模拟</li><li>Thurston 的圆堆算法</li><li>Conway’s Topograph</li><li>magicavoxel and magicaCSG</li><li>matsuba</li><li>Bruhat 树</li><li>正二十面体准晶</li><li>Voxel Turtle</li><li>Modular flow</li><li>格点参数化　https://www.shadertoy.com/view/fllXzl</li><li>纸壳制作多面体?</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd Kemp 概率论课程笔记</title>
      <link href="todd-kemp/new.html"/>
      <url>todd-kemp/new.html</url>
      
        <content type="html"><![CDATA[<h1 id="optional-stopping-and-sampling">49.1 Optional Stopping andSampling</h1><p>这一节介绍了停时，以及停时鞅序列 <span class="math inline">\(\{X_{n\wedge \tau}\}\)</span> 的性质。</p><p>一个简单的股票市场模型：设 <span class="math inline">\(\{X_n\}_{n=0}^\infty\)</span> 是股票价格，<span class="math inline">\(\{U_n\}_{n=1}^\infty\)</span>是你的投资策略，即在时刻 <span class="math inline">\(n-1\)</span> 买入<span class="math inline">\(U_n\)</span> 并在时刻 <span class="math inline">\(n\)</span> 抛出。或者说，<span class="math inline">\(U_n\)</span> 是你在 <span class="math inline">\((n-1,n]\)</span>这个时间区间内的股票交易数量，那么到时刻 <span class="math inline">\(n\)</span> 时，你的净收益为 <span class="math display">\[I_n(U,X) = \sum_{j=1}^nU_j(X_j-X_{j-1}).\]</span> 这里 <span class="math inline">\(U_n\)</span>必须是关于 <span class="math inline">\(\mathcal{F}_{n-1}=\sigma(X_0,X_1,\ldots,X_{n-1})\)</span>可测。</p><p>第一个重要观察是：</p><div id="martingale-discrete-integration" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.1</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\{X_n\}\)</span> 是鞅/下鞅/上鞅，并且 <span class="math inline">\(U_n\geq0\)</span>，则 <span class="math inline">\(I_n(U,X)\)</span> 也是鞅/下鞅/上鞅。</p></div><p>证明：对下面的恒等式两边关于 <span class="math inline">\(\mathcal{F}_n\)</span> 取条件期望即可。 <span class="math display">\[I_{n+1}(U,X) =\underbrace{I_{n}(U,X)}_{\in\mathcal{F}_n} +\underbrace{U_{n+1}}_{\in\mathcal{F}_n}\underbrace{(X_{n+1}-X_{n})}_{\rm(sub/sup)martingale}.\]</span></p><p>我们可以设定两个随机时间，比如 <span class="math inline">\(\sigma\)</span> 是股票首次低于 1 美元的时刻,这时立刻买入；<span class="math inline">\(\tau\)</span> 是股票首次高于10 美元的时刻，这时立刻抛出；在区间 <span class="math inline">\((\sigma,\tau]\)</span> 中保持持有股票，即 <span class="math inline">\(U_j=\mathbb{1}_{\sigma&lt;j\leq\tau}\)</span>。于是 <span class="math inline">\(U_j\mathbb{1}_{n\geqj}=\mathbb{1}_{(\sigma\wedge n, \tau\wedge n]}(j)\)</span>。</p><p>那么净收益 <span class="math display">\[I_n(U,X) = \sum_{j=1}^n\mathbb{1}_{\sigma\wedge n&lt;j\leq \tau\wedge n}(X_j-X_{j-1})=X_{\tau\wedge n} - X_{\sigma\wedge n}.\]</span></p><p>特别地，取 <span class="math inline">\(\sigma=0\)</span>，则 <span class="math inline">\(U_j=\mathbb{1}_{j\leq\tau}\)</span>，则我们有如下结论：</p><div id="stopping-time-also-martingale" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\{X_n\}\)</span> 是鞅，那么 <span class="math inline">\(\{X_{n\wedge \tau}\}\)</span> 也是鞅。</p></div><p>证明：首先每一项 <span class="math inline">\(X_{n\wedge\tau}\)</span> 可以看成是一个关于 <span class="math inline">\(X_1,\ldots,X_n\)</span> 的部分和：</p><p><span class="math display">\[X_{n\wedge \tau} =\sum_{k=0}^n\mathbb{1}_{\tau=k}X_k.\]</span></p><p>显然 <span class="math inline">\(X_{n\wedge \tau}\)</span>是可积的。</p><p>另一方面在 <a href="#martingale-discrete-integration" title="定理 1.1">定理 1.1</a> 中取 <span class="math inline">\(U_n=\mathbb{1}_{n\leq\tau}\)</span>，则 <span class="math inline">\(X_{n\wedge \tau} - X_0 = I_n(U,X)\)</span>仍然是鞅，那么加上一个 <span class="math inline">\(X_0\)</span> 得到的<span class="math inline">\(X_{n\wedge\tau}\)</span> 当然还是鞅。</p><h1 id="holders-inequality">49.2 Holder’s Inequality</h1><p>无特别内容</p><h1 id="submartingale-maximal-inequalities-未完成">49.3 (Sub)martingaleMaximal Inequalities （未完成）</h1><p>开篇第一句话就是，鞅在一个有限区间上的极大值，可以以多种方式被它在区间终点的值所控制。</p>]]></content>
      
    </entry>
    
    
  
</search>
