<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>IFS 分形揭秘</title>
      <link href="ifs-demystified/"/>
      <url>ifs-demystified/</url>
      
        <content type="html"><![CDATA[<p>本文整理自我 2024 年 6 月 14日在上海科技大学数学所的一个小报告，标题是“GPU涂鸦与数学可视化”。本文整理了报告的技术内容，略去了报告中介绍 demoscene文化和分形文化的部分。</p><span id="more"></span><hr><p>在 Shadertoy上有很多效果酷炫，但是代码非常短的分形作品。我挑选了其中三个优秀的例子展示如下：</p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr class="odd"><td style="text-align: center;"><a href="https://www.shadertoy.com/view/ltB3DG">Ethereal</a> by Kali</td><td style="text-align: center;"><a href="https://www.shadertoy.com/view/NsVyRz">Apollonian fractal</a> byXor</td><td style="text-align: center;"><a href="https://www.shadertoy.com/view/mdG3Wy">Radiosity</a> by Xor</td></tr><tr class="even"><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/ltB3DG.jpg"></td><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/NsVyRz.jpg"></td><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/mdG3Wy.jpg"></td></tr></tbody></table><p>然而代码短可不代表它们容易看懂。特别是很多作者还喜欢故弄玄虚，把代码作了混淆处理以增加神秘感。对我来说，这种被人秀了一脸结果还没搞明白对面是怎么装的逼的感觉让人很不爽。当然我不是在抱怨，这种炫技的行为本身就是黑客文化的一部分，可以理解。后来分形玩的多了，我也慢慢明白了其中的奥妙，这次上科大之行是一次很好的机会，促使我把这些理解完整的写下来。</p><p>在这篇文章中，我将为大家揭示这些作品背后的奥秘。这些分形作品别看场景千变万化，其实都是用同一个套路制作出来的。这个套路可以简述为：首先将像素的2D 坐标映射为空间中的某个 3D 的点，然后用一个 <code>fold</code>函数，即所谓的 <a href="https://en.wikipedia.org/wiki/Iterated_function_system">迭代函数系统</a>（iteratedfunction system，简称IFS）反复作用在该点上。每次迭代结束后，生成一个颜色并将其添加到当前的颜色<code>color</code> 上。当达到一定的迭代次数后，返回 <code>color</code>的值作为像素最终的颜色。</p><p>如果用伪代码来描述，大概是这样：</p><figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec3</span> getPixelColor(<span class="hljs-type">vec2</span> pixel) {<br>    <span class="hljs-type">vec3</span> p = screenToSpace(pixel);  <span class="hljs-comment">// map 2D pixel to 3D space</span><br>    <span class="hljs-type">vec3</span> color = <span class="hljs-type">vec3</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;max_iterations; i++) {<br>        p = fold(p);  <span class="hljs-comment">// transform p in each iteration</span><br>        color += someColorFunc(p);  <span class="hljs-comment">// add a bit color</span><br>    }<br>    <span class="hljs-keyword">return</span> color;<br>}<br></code></pre></td></tr></tbody></table></figure><p>整个过程主要包括三个要素：</p><ol type="1"><li>用 IFS 来构造分形。</li><li>用轨道着色技巧给分形上色。</li><li>在着色器 (shader) 中编程实现。</li></ol><p>下面我来逐一来解释这些步骤。</p><h1 id="ifs-方法">IFS 方法</h1><div id="------------" class="unnumbered statement sta_____ plain"><p><span class="statement-heading"><span class="statement-label">压缩映射</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}^n\)</span>是一个映射，如果存在 <span class="math inline">\(0&lt;r&lt;1\)</span>使得对任何 <span class="math inline">\(x,y\in\mathbb{R}^n\)</span> 有<span class="math display">\[d(f(x),f(y))\leq r\cdot d(x,y)\]</span>成立，我们就称 <span class="math inline">\(f\)</span>是一个压缩映射，<span class="math inline">\(r\)</span> 是压缩比例。这里<span class="math inline">\(d\)</span> 是通常的 Euclidean 距离。</p></div><p>记 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span>中所有紧集组成的集合，可以证明 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 在 <a href="https://en.wikipedia.org/wiki/Hausdorff_distance">Hausdorff度量</a> 下构成一个完备度量空间。读者不必关心 Hausdoff度量的具体细节，只要知道它是一个度量，可以衡量两个紧集的接近程度。</p><p>设 <span class="math inline">\(f_1,\ldots,f_N\)</span>是一组压缩映射，<span class="math inline">\(f_i\)</span> 的压缩比例是<span class="math inline">\(r_i\)</span>。定义映射 <span class="math inline">\(F:K(\mathbb{R}^n)\to K(\mathbb{R}^n)\)</span>如下： <span class="math display">\[F(X) = f_1(X)\cupf_2(X)\cup\cdots\cup f_N(X),\quad X\in K(\mathbb{R}^n).\]</span> 即<span class="math inline">\(F\)</span> 把 <span class="math inline">\(X\)</span> 变成 <span class="math inline">\(N\)</span> 个更小的集合。</p><p>可以证明 <span class="math inline">\(F\)</span> 是空间 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 上的压缩映射，其压缩比例<span class="math inline">\(r=\max\{r_1,\ldots,r_N\}\)</span>。于是根据<a href="https://en.wikipedia.org/wiki/Banach_fixed-point_theorem">Banach不动点定理</a>，存在唯一的紧集 <span class="math inline">\(A\subset\mathbb{R}^n\)</span> 使得 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(F\)</span> 的不动点： <span class="math display">\[F(A) = A.\]</span> 不仅如此，对 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 中的任何一点（注意 <span class="math inline">\(K(\mathbb{R}^n)\)</span>是紧集组成的度量空间，里面的点都是紧集）<span class="math inline">\(B\subset\mathbb{R}^n\)</span>，都有 <span class="math display">\[\lim_{n\to\infty} F^n(B) =A.\]</span> 紧集 <span class="math inline">\(A\)</span> 叫做 <span class="math inline">\(F\)</span> 的极限集，<span class="math inline">\(A\)</span> 是一个分形，它具有自相似的特征。</p><p>我们以著名的 <a href="https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle">Sierpiński三角形</a> 为例来说明这个过程。我们选择的三个压缩映射分别是</p><p><span class="math display">\[\begin{align}f_1(x,y) &amp;= (x/2, y/2),\\f_2(x,y) &amp;= (x/2, y/2) + (0, 1/2),\\f_3(x,y) &amp;= (x/2, y/2) + (1/2, 0).\\\end{align}\]</span></p><p>这三个压缩映射的压缩比都是 1/2。初始的紧集 <span class="math inline">\(K_0\)</span> 可以随便选，比如就取为一个圆： <span class="math display">\[K_0 =\img{/images/ifs/dot0.svg}{-1.75em}{}{4em}.\]</span></p><p>在第 1 次迭代后，它变成</p><p><span class="math display">\[K_1 = f_1(K_0)\cup f_2(K_0)\cup f_3(K_0)= \img{/images/ifs/dot1.svg}{-1.75em}{}{4em}.\]</span></p><p>在第 2 次迭代后，结果是</p><p><span class="math display">\[K_2 = f_1(K_1)\cup f_2(K_1)\cup f_3(K_1)= \img{/images/ifs/dot2.svg}{-1.75em}{}{4em}.\]</span></p><p>第 3 次迭代：</p><p><span class="math display">\[K_3 = f_1(K_2)\cup f_2(K_2)\cup f_3(K_2)= \img{/images/ifs/dot3.svg}{-1.75em}{}{4em}.\]</span></p><p>当迭代次数趋于无穷，就得到了 Sierpiński 分形：</p><p><span class="math display">\[\lim_{n\to\infty} K_n = K = f_1(K)\cupf_2(K)\cup f_3(K) =\img{/images/ifs/dot6.svg}{-1.75em}{}{4em}.\]</span></p><p>你可以很容易看出来为什么初始紧集的选择是不重要的：因为在压缩的过程中，任何紧集都会逐渐缩小到一个单点，所以<span class="math inline">\(K_0\)</span> 甚至取成一个点也是可以的。</p><p>压缩映射是无穷无尽的，所以 IFS给出的分形也是无穷无尽的。为了避免选择困难，我们一般只使用平移、旋转、反射、缩放、球反演这几种变换（球反演变换是将单位球的外部反演到内部，单位球内部保持不动），通过它们的复合变换来实现空间压缩。</p><p>你可能想问，那应该怎样具体选择 <span class="math inline">\(f_1,\ldots,f_N\)</span>？我会在后面介绍，在着色器中实现IFS 是通过“空间折叠”操作进行的，这个操作可以看作是 <span class="math inline">\(F\)</span>的逆映射，它自动包含了多个压缩映射，所以你根本不需要单独指定每个 <span class="math inline">\(f_i\)</span>！</p><h1 id="轨道着色">轨道着色</h1><p>我们希望给分形染上漂亮的颜色，这个染色应该满足如下的条件：</p><ol type="1"><li>在分形上颜色是连续变化的；</li><li>在分形和非分形的交界处（即 <span class="math inline">\(A\)</span> 和<span class="math inline">\(A^c\)</span>的边界上）颜色应该是不连续的，从而产生泾渭分明的效果。</li></ol><p>做到这一点并不难，但是需要在每一次迭代时考虑当前点的位置信息。</p><p>我们首先取一个底色，比如说<code>color=vec3(0)</code>，在每一次迭代中，根据当前位置 <code>p</code>生成一个颜色，并以一定的权重加到 <code>color</code> 上。理论上颜色的 rgb的取值范围应该是 <span class="math inline">\([0,1]\)</span>，但是多数情况下我们要放宽到 <span class="math inline">\([-1,1]\)</span>之间，即颜色可以增加也可以减少。否则如果颜色只增不减的话，那么多次迭代以后rgb值很可能会溢出，变成白色。此外，随着迭代次数的增加，新颜色的权重应该单调下降，这样才能保证突出分形细节的部分。这也符合我们的生活直觉：想象一下，当一位画家作画时，在开始的时候他可以浓墨重彩地画一个轮廓，但是越到后面描绘更加精细的部分时，他就会换用更细的画笔，小心地蘸一点颜料。</p><p>根据 <code>p</code>生成颜色的着色方案无穷无尽，请随便发挥你的创造力。一般来说你需要反复试验各种不同的方案才能找到最合适的。以下是两个示例：</p><figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec3</span> colorFunc1(<span class="hljs-type">vec3</span> p) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">cos</span>(<span class="hljs-built_in">dot</span>(p, <span class="hljs-type">vec3</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)) + iTime);<br>}<br><br><span class="hljs-type">vec3</span> colorFunc2(<span class="hljs-type">vec3</span> p) {<br>    <span class="hljs-keyword">return</span> hsv2rgb(<span class="hljs-built_in">length</span>(p) + iTime);<br>}<br></code></pre></td></tr></tbody></table></figure><h1 id="着色器编程基础">着色器编程基础</h1><p>我简单介绍一下着色器编程的基本概念。打开 shadertoy网站，点击右上角的<code>新建</code>按钮，你会看到一个 <a href="https://www.shadertoy.com/new">最简单的动画</a>：</p><p><img style="margin:0px auto;display:block" width="600" src="/images/ifs/shadertoy.png"></p><p>左边的窗口是画布，显示渲染的结果；右边窗口是代码编辑器，你在这里书写着色器代码。</p><p>画布是由若干像素组成的，你需要根据每个像素的位置，即它的<code>fragCoord</code> 值指定一个颜色。这个过程是在<code>mainImage</code> 函数中实现的：</p><figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> mainImage(<span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> fragColor, <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> fragCoord);<br></code></pre></td></tr></tbody></table></figure><p>其中 <code>fragCoord</code> 是像素的位置，<code>fragColor</code>是需要设置的像素颜色。</p><p>现实生活中有一个很形象的例子可以帮你理解着色器编程：假设你是一场方阵表演的导演，所有演员排成一个<span class="math inline">\(W\times H\)</span>的方阵，每个演员可以改变自己衣服的颜色。你的任务是发出合适的指令让每个演员根据自己的位置计算出正确的颜色，使得整个方阵呈现出漂亮的图案。</p><p><img style="margin:0px auto;display:block" width="600" src="/images/ifs/array.png"></p><p>如果你一个一个地对每个演员下指令，张三你应该显示红色，李四你应该显示蓝色，等等…对成千上万个演员，这么挨个下指令还不得把人累死？正确的做法是，你应该同时对所有演员发出相同的指令，比如：“每个人，根据自己的位置，<span class="math inline">\(x\)</span> 坐标 （即 <code>fragCoord.x</code>）是偶数的显示红色，<span class="math inline">\(x\)</span>坐标是奇数的显示蓝色”。这样你应该会看到红蓝相间、纵向排列的条纹图案。每个演员本质上就是一个单独的GPU计算单元，他们可以根据相同的指令独立计算各自的颜色。这种基于相同指令并行计算的工作方式才是GPU 流水线的机制。</p><p>再举一个例子，比如你希望阵列的中心呈现一个圆盘的图案，那就可以这样下指令：“每个人，把自己的纵坐标转换到区间<span class="math inline">\([-1, 1]\)</span>，然后计算各自到原点 <span class="math inline">\((0,0)\)</span> 的距离。距离大于 0.5的显示红色，否则就显示蓝色”。这样一来，每个演员就会首先根据</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">vec2 p = (<span class="hljs-number">2.0</span> * fragCoord  - iResolution.xy) / iResolution.y;<br><span class="hljs-keyword">float</span> d = length(p) - <span class="hljs-number">0.5</span>;<br></code></pre></td></tr></tbody></table></figure><p>将自己的像素坐标 <code>fragCoord</code> 转换为世界坐标下的点<code>p</code>，使得 <code>fragCoord.y</code> 的范围是 <span class="math inline">\([-1,1]\)</span>。然后计算各自到以原点为中心、半径为0.5 的圆的距离 <span class="math inline">\(d\)</span>。最终根据</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (d &gt; <span class="hljs-number">0.0</span>)<br>    fragColor = vec4(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span><br>    fragColor = vec4(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></tbody></table></figure><p>来设置各自的颜色。</p><p>这个例子其实蕴含了 shader编程的一个非常核心的概念，即<strong>距离场</strong> (distancefield)。当我们想绘制某个图案时，我们通过计算像素到这个图案的距离来对像素进行着色。</p><h1 id="空间折叠">空间折叠</h1><p>在前面关于 IFS 的介绍中我们可以看到，如果有 <span class="math inline">\(N\)</span> 个不同的压缩映射 <span class="math inline">\(f_1,\ldots,f_N\)</span>，那么每次迭代后集合的数目会乘以<span class="math inline">\(N\)</span>，这是指数增长的，10次迭代可能会产生多达 <span class="math inline">\(10^N\)</span>个不同的集合。维护如此数量的集合是计算上不可行的。这该怎么办呢？</p><p>回忆我们之前介绍的，在着色器里面画 IFS就是给每个像素指定一个颜色，这个颜色应该由这个像素对应的空间中的点到分形的距离来决定。假设像素对应的空间中的点是<span class="math inline">\(p\)</span>，初始紧集是 <span class="math inline">\(K\)</span>，我们用迭代 <span class="math inline">\(n\)</span> 次的结果 <span class="math inline">\(F^n(K)\)</span> 作为分形的近似，这里 <span class="math inline">\(n\)</span> 是某个常数，在绝大多数场景下 <span class="math inline">\(n=30\)</span> 就足够了。我们需要计算距离 <span class="math inline">\(d(p,F^n(K))\)</span>并根据这个距离值对像素染色。我们已经看到 <span class="math inline">\(F^n(K)\)</span>是没法计算的，但有个巧妙的做法可以绕过这个困难：把 <span class="math inline">\(F^n\)</span> 挪到另一侧并取逆，转而计算 <span class="math inline">\(d(F^{-n}(p), K)\)</span>！实际上，如果 <span class="math inline">\(F\)</span>只包含旋转、平移、反射、缩放、球反演这些变换的话，<span class="math inline">\(d(p,F^n(K))\)</span> 和 <span class="math inline">\(d(F^{-n}(p), K)\)</span>之间存在非常简单的关系，我们可以通过计算后者来得到前者！这个关系的推导我放在后面介绍。</p><p>所以我们需要将压缩迭代映射的步骤倒过来，采取相反的操作：即将逆映射<span class="math inline">\(F^{-1}\)</span> 迭代作用在 <span class="math inline">\(p\)</span> 上，执行足够的迭代次数后，再绘制紧集<span class="math inline">\(K\)</span>。即我们实际是用一个<strong>空间折叠</strong>的映射作用反复作用在<span class="math inline">\(p\)</span>上，这个映射是<strong>放大距离</strong>的。</p><p>这个先折叠后画图的操作，也可以用一个生活中的例子来形象地解释，即剪纸艺术：</p><p><img style="margin:0px auto;display:block" width="480" src="/images/ifs/papercut.jpg"></p><p>在剪纸过程中，首先把纸张反复折叠，然后在折叠后的纸张上画出某个特定的图形，沿着这个图形裁剪，再将纸张展开得到的就是美丽的图案。</p><p>这里<strong>展开</strong>纸张的操作对应的就是迭代映射 <span class="math inline">\(F\)</span>，它把一个初始的紧集铺开到空间中变成分形，是个“一对多”的映射；<strong>折叠</strong>纸张的操作就是<span class="math inline">\(F^{-1}\)</span>，它把分形折叠回最初的紧集，是个“多对一”的映射。</p><p>如果你去看那些分形作品的代码的话，会发现它们几乎都使用了<code>abs</code>函数。这个函数是多对一的，它会把整个空间折叠到第一象限，这对应了 <span class="math inline">\(F\)</span> 包含 4 个不同的 <span class="math inline">\(f_i\)</span> （这是在 2D 的情形；3D 的情形会有 8个不同的 <span class="math inline">\(f_i\)</span>）。进一步，再叠加关于其它平面/球面的折叠可以产生出更多的<span class="math inline">\(f_i\)</span>。这就解释了为什么在着色器中我们不需要显示地写出每个单独的<span class="math inline">\(f_i\)</span>。</p><p>最后我们来推导 <span class="math inline">\(d(p,F^n(K))\)</span> 和<span class="math inline">\(d(F^{-n}(p), K)\)</span> 之间的关系。</p><p>如果 <span class="math inline">\(F\)</span>是平移、旋转、反射这样的保持 Euclidean 距离不变的刚体运动，那么自然有<span class="math display">\[d(p, F(K)) = d(F^{-1}(p), K).\]</span></p><p>但如果 <span class="math inline">\(F\)</span> 是一个缩放变换，比如<span class="math inline">\(F(x) = x/s\,(s&gt;1)\)</span>，那么 <span class="math display">\[d(p, F(K)) = d(p, 1/s\cdot K) = 1/s\cdot d(s\cdotp, K) = 1/s\cdot d(F^{-1}(p), K).\]</span>即我们要对折叠以后算出来的距离值再除以 <span class="math inline">\(s\)</span>。</p><p>对球的反演变换也有类似的结论，这是因为球反演在空间中每个点的局部是一个缩放。</p><p>既然每次迭代 <span class="math inline">\(F\)</span> 以比例 <span class="math inline">\(1/s\)</span> 缩小，那么用 <span class="math inline">\(F^{-1}\)</span> 迭代 <span class="math inline">\(n\)</span> 次以后累积放大的比例就是 <span class="math inline">\(s^n\)</span>，我们要将 <span class="math inline">\(d(F^{-n}(p), K)\)</span> 再除以 <span class="math inline">\(s^n\)</span> 才是最终正确的距离值。</p><p>对于一般的映射 <span class="math inline">\(F\)</span>，我们可以通过计算 <span class="math inline">\(F^{-1}\)</span> 在 <span class="math inline">\(p\)</span> 处 Jacobian 矩阵的行列式的绝对值，作为<span class="math inline">\(p\)</span> 处缩放的近似。</p><h1 id="实战演示">实战演示</h1><p>我以 Shadertoy 上一个混淆过的 <a href="https://www.shadertoy.com/view/WlGyWK">作品</a>为例子来完整展示上面的理论。下面是重新改写后的可读版本，我在注释中解释了每一步的含义：</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/l3cXR7?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe>]]></content>
      
      
      <categories>
          
          <category> Shadertoy </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>咖啡杯中的焦散线</title>
      <link href="envelope-and-caustics/"/>
      <url>envelope-and-caustics/</url>
      
        <content type="html"><![CDATA[<p>春节的晚上，外面鞭炮喧天，家人在看电视，我躲在屋里看数学，还是挺惬意的。</p><p>我看的是 <a href="https://johncarlosbaez.wordpress.com">John Baez</a>和 <a href="https://www.gregegan.net">Greg Egan</a> 的博客。John Baez是一位在科普方面非常高产的数学家，写过不计其数的科普文章。读他的文章非常让人享受，因为他总是从直观的例子入手，一步步启发读者，展开到更高级的数学。GregEgan是澳大利亚的一位非常高产的科幻小说作家，有不少作品已经被国内引入。他的小说属于硬科幻风格，而且是非常硬的那种。他也有不少有趣的<a href="https://www.gregegan.net/SCIENCE/Science.html">博客文章</a>。不过与John Baez 不同的是，Greg Egan的文章不太会去兼顾不同水平的读者，对我来说，要看懂他在说什么经常不是一件容易的事情。</p><p>John Baez 博客上有一个系列 <a href="https://johncarlosbaez.wordpress.com/2012/08/31/rolling-circles-and-balls-part-1/">Rollingcircles and balls</a> 讨论了圆的外摆线和焦散，Greg Egan 也有一篇 <a href="https://www.gregegan.net/SCIENCE/Catacaustics/Catacaustics.html">文章</a>更深入的讨论了曲线的焦散。这个话题非常有意思，我也一时手痒写代码实验了一番并记录在此。</p><span id="more"></span><h1 id="pov-ray-光学实验">POV-Ray 光学实验</h1><p>有个有趣的物理现象，当光线照在咖啡杯的内壁上时，光线反射以后会形成一个亮斑，术语叫做焦散(caustic)。</p><p><img style="margin:0px auto;display:block" width="400" src="/images/caustics/cup.jpg"></p><p>形成焦散的原因是，光线在杯子内壁反射以后，光子的分布是不均匀的，某些区域经过的光子特别密集，所以亮度就更高。</p><p>焦散是一条曲线，它和所有的反射光线相切，即它是所有反射光线的包络(envelope)。焦散的具体形状和杯子的形状、光源的位置都有关。假设杯子是圆形的，则当光源是一个点光源且恰好位于杯子边缘上某一点时，得到的焦散叫做<a href="https://en.wikipedia.org/wiki/Cardioid">心脏线</a>(cardioid)。当光源位于无穷远时（可以视作平行光源），得到的焦散是 <a href="https://en.wikipedia.org/wiki/Nephroid">肾形线</a>(nephroid)。一般情况下焦散的形状介于心脏线和肾形线之间。</p><p>更有意思的是，如果杯子的外形是心脏线，而且光源正好位于心脏线的尖点时，得到的焦散正好是肾形线。我写了一个<a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/catacaustic">POV-Ray脚本</a>，模拟了这一现象：</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr class="odd"><td style="text-align: center;">圆形杯子给出心脏线</td><td style="text-align: center;">心脏线杯子给出肾形线</td></tr><tr class="even"><td style="text-align: center;"><img style="margin:0px auto;display:block" width="400" src="/images/caustics/caustics_cardioid.png"></td><td style="text-align: center;"><img style="margin:0px auto;display:block" width="400" src="/images/caustics/caustics_nephroid.png"></td></tr></tbody></table><p>心脏线和肾形线都是所谓的 <a href="https://en.wikipedia.org/wiki/Epicycloid">外摆线</a>，只是两圆的半径之比不同：</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr class="odd"><td style="text-align: center;">心脏线</td><td style="text-align: center;">肾形线</td></tr><tr class="even"><td style="text-align: center;"><video src="/images/caustics/cardioid.mp4" controls=""></video></td><td style="text-align: center;"><video src="/images/caustics/nephroid.mp4" controls=""></video></td></tr></tbody></table><p>所以我们很容易作出如下的猜想：如果在肾形线的内部或者尖点放一个光源，是不是又会得到下一个外摆线？然而根据Greg Egan 在他博客中的实验，这个应该是不成立的。</p><p>理论上这个 POV-Ray 脚本可以渲染任意的参数曲线反射的效果，但是 POV-Ray渲染 parametric surface + radiosity非常慢，所以如果你想试一试的话，最好还是用 POV-Ray 原生的 CSG来构造曲线。</p><h1 id="求解参数曲线的焦散">求解参数曲线的焦散</h1><p>这一节我们来介绍怎样计算一般的参数曲线 <span class="math inline">\(\mathbf{c}(t)=(x(t),y(t))\)</span>的焦散曲线。</p><p>设点光源的位置是 <span class="math inline">\((a,b)\)</span>，则在曲线上的一点 <span class="math inline">\((x,y)\)</span> 处，入射光线的方向是 <span class="math display">\[\mathbf{l}=(x-a,y-b).\]</span> 不需要把 <span class="math inline">\(\mathbf{l}\)</span>单位化，因为我们列方程的时候只需要光线的方向，并不在乎长度。</p><p>同样是在 <span class="math inline">\((x,y)\)</span>处，曲线的法向量是 <span class="math display">\[\mathbf{n}=\frac{(-y',x')}{\sqrt{(x')^2+(y')^2}}=\frac{(-y',x')}{|\mathbf{c}'|}.\]</span> 这里我们用 <span class="math inline">\(x',y'\)</span> 表示 <span class="math inline">\(x,y\)</span> 关于 <span class="math inline">\(t\)</span> 的导数。</p><p>于是 <span class="math inline">\((x,y)\)</span> 处的反射光线的方向<span class="math inline">\(\mathbf{r}\)</span> 由如下反射公式给出：<span class="math display">\[\mathbf{r}= \mathbf{l}- 2(\mathbf{l}\cdot\mathbf{n})\mathbf{n}.\]</span> 设 <span class="math inline">\((X,Y)\)</span> 是反射光线上的任一点，由于 <span class="math inline">\((x,y)\)</span> 是反射光线的起点，所以 <span class="math inline">\((X-x,Y-y)\)</span> 与 <span class="math inline">\(\mathbf{r}\)</span> 平行。记 <span class="math inline">\(\mathbf{r}=(r_x,r_y)\)</span>，则 <span class="math inline">\((X-x,Y-y)\)</span> 与 <span class="math inline">\((-r_y, r_x)\)</span> 垂直，即 <span class="math display">\[(X-x, Y-y)\cdot(-r_y, r_x)=0.\]</span> 记 <span class="math display">\[F(X,Y,t)=(X-x, Y-y)\cdot(-r_y, r_x),\]</span>则我们得到了反射光线 <span class="math inline">\((X(t), Y(t))\)</span>满足的曲线族方程 <span class="math inline">\(F(X,Y,t)=0\)</span>。于是焦散曲线可以通过联立方程组<span class="math display">\[\begin{align}F(X,Y,t)=0,\\\frac{\partialF}{\partial t}F(X,Y,t)=0.\end{align}\]</span> 也就是 <span class="math display">\[\begin{align}(X-x, Y-y)\cdot(-r_y,r_x)&amp;=0,\\-(x',y')\cdot(-r_y, r_x) +(X-x,Y-y)\cdot(-r_y', r_x') &amp;=0.\end{align}\]</span>然后解出 <span class="math inline">\(X,Y\)</span> 得到。</p><p>如果你还记得 2x2矩阵的逆公式的话，这个方程组其实可以目视写出解来。我们把它写成</p><p><span class="math display">\[\begin{pmatrix}-r_y &amp; r_x\\-r_y'&amp;r_x'\end{pmatrix}\cdot\begin{pmatrix}X-x\\Y-y\end{pmatrix}=\begin{pmatrix}0\\r_xy'-r_yx'\end{pmatrix}.\]</span> 于是 <span class="math display">\[\begin{align}\begin{pmatrix}X-x\\Y-y\end{pmatrix}&amp;=\begin{pmatrix}-r_y&amp; r_x\\ -r_y'&amp;r_x'\end{pmatrix}^{-1}\begin{pmatrix}0\\r_xy'- r_yx'\end{pmatrix}\\&amp;=\frac{1}{r_xr_y'-r_yr_x'}\begin{pmatrix}r_x' &amp;-r_x\\ r_y'&amp;-r_y\end{pmatrix}\begin{pmatrix}0\\r_xy'-r_yx'\end{pmatrix}\\&amp;=\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\end{align}\]</span> 即 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix} +\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span></p><p>按照上面的理论，我写了一个小脚本，用 <code>sympy</code>(version=1.12) 来计算圆的焦散线。其中圆的中心在原点，半径为 1，光源在<span class="math inline">\((1,0)\)</span> 处。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>t, X, Y = symbols(<span class="hljs-string">"t X Y"</span>)<br>C = Matrix([cos(t), sin(t)]) <span class="hljs-comment"># curve</span><br>light = Matrix([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]) <span class="hljs-comment"># light source</span><br>l = C - light <span class="hljs-comment"># incident ray</span><br>dx, dy = diff(C, t)<br>n = Matrix([dy, -dx]) <span class="hljs-comment"># normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n)) <span class="hljs-comment"># reflected ray</span><br>F = (Y - y) * r[<span class="hljs-number">0</span>] - (X - x) * r[<span class="hljs-number">1</span>]<br>dF = diff(F, t)<br>result = solve((F, dF), X, Y) <span class="hljs-comment"># solve the envelope</span><br>print(<span class="hljs-string">f"X(t)=<span class="hljs-subst">{trigsimp(result[X], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br>print(<span class="hljs-string">f"Y(t)=<span class="hljs-subst">{trigsimp(result[Y], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 给出的结果是：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X(t)=<span class="hljs-number">2</span>*cos(t)/<span class="hljs-number">3</span> + cos(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span><br>Y(t)=<span class="hljs-number">2</span>*sin(t)/<span class="hljs-number">3</span> + sin(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>这正是喜闻乐见的心脏线的参数表示： <span class="math display">\[\left\{\begin{align}x(t)&amp;=\frac{\cos(2t) +2\cos(t)}{3},\\ y(t)&amp;=\frac{\sin(2t) +2\sin(t)}{3}.\end{align}\right.\]</span></p><p>使用这个参数表示，我们继续计算当光源放在心脏线的尖点，即 <span class="math inline">\(t=\pi\)</span> 对应的点 <span class="math inline">\((-\frac{1}{3},0)\)</span> 时得到的焦散：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>t, X, Y = symbols(<span class="hljs-string">"t X Y"</span>)<br>C = Matrix([(<span class="hljs-number">2</span>*cos(t) + cos(<span class="hljs-number">2</span>*t)) / <span class="hljs-number">3</span>, (<span class="hljs-number">2</span>*sin(t) + sin(<span class="hljs-number">2</span>*t)) / <span class="hljs-number">3</span>])<br>light = Matrix([S(<span class="hljs-string">'-1/3'</span>, evaluate=<span class="hljs-literal">False</span>), <span class="hljs-number">0</span>])<br>l = C - light <span class="hljs-comment"># incident ray</span><br>dx, dy = diff(C, t)<br>n = Matrix([dy, -dx]) <span class="hljs-comment"># normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n)) <span class="hljs-comment"># reflected ray</span><br>F = (Y - y) * r[<span class="hljs-number">0</span>] - (X - x) * r[<span class="hljs-number">1</span>]<br>dF = diff(F, t)<br>result = solve((F, dF), X, Y) <span class="hljs-comment"># solve the envelope</span><br>print(<span class="hljs-string">f"X(t)=<span class="hljs-subst">{trigsimp(result[X], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br>print(<span class="hljs-string">f"Y(t)=<span class="hljs-subst">{trigsimp(result[Y], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 很快算出了正确的结果：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X(t)=sin(t)*sin(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span> + cos(t)/<span class="hljs-number">3</span><br>Y(t)=-sin(t)*cos(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span> + sin(t)/<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>不难验证</p><p><span class="math display">\[\begin{align}\frac{\sin(t)\sin(2t) +\cos(t)}{3}&amp;=\frac{3\cos(t) - \cos(3t)}{6},\\ \frac{-\sin(t)\cos(2t)+ \sin(t)}{3}&amp;=\frac{3\sin(t) -\sin(3t)}{6}.\end{align}\]</span></p><p>这正是 <a href="https://en.wikipedia.org/wiki/Nephroid#Parametric">维基百科</a>中所列的肾形线的参数方程中取 <span class="math inline">\(a=1/6\)</span>的结果。</p><p>把上面的曲线画出来是这样的：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/caustics/caustics_matplotlib.svg"></p><h1 id="求解多项式曲线的焦散">求解多项式曲线的焦散</h1><p>很多时候曲线的方程是通过隐函数 <span class="math inline">\(P(x,y)=0\)</span> 的形式给出的，其中 <span class="math inline">\(P(x,y)\)</span> 是关于两个变元 <span class="math inline">\(x,y\)</span>的多项式。这样的曲线叫做平面代数曲线。这时求解焦散要用到 Gröbner基的工具。</p><p>让我们回到参数方程的情形，我们已经看到，这时焦散 <span class="math inline">\((X,Y)\)</span> 有显式解</p><p><span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix} +\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span></p><p>其中 <span class="math inline">\(x,y,r_x,r_y\)</span> 都是关于 <span class="math inline">\(t\)</span>的函数，它们的导数也是可计算的，所以可以算出 <span class="math inline">\((X,Y)\)</span> 来。</p><p>但是在隐函数的情形，我们没有 <span class="math inline">\(x,y\)</span>的某种关于 <span class="math inline">\(t\)</span>的表达式。不过没关系，我们先假设有这样的参数表达式，看看能得到什么结论。设<span class="math inline">\(x=x(t),y=y(t)\)</span> 是某个参变元 <span class="math inline">\(t\)</span> 的函数，在 <span class="math inline">\(P(x,y)=0\)</span> 两边对 <span class="math inline">\(t\)</span> 求导可得 <span class="math display">\[\frac{\partial P}{\partial t}=\frac{\partialP}{\partial x}x'(t) + \frac{\partial P}{\partialy}y'(t)=0.\]</span> 记 <span class="math inline">\(k=-\frac{\partialP}{\partial x}/\frac{\partial P}{\partial y}\)</span>，则 <span class="math inline">\(y'(t)=kx'(t)\)</span>。</p><p>对反射光线 <span class="math inline">\(\mathbf{r}\)</span> 的两个分量<span class="math inline">\(r_x,r_y\)</span> 也分别使用链式求导，我们有<span class="math display">\[\begin{align}\frac{\partial r_x}{\partialt}&amp;=\frac{\partial r_x}{\partial x}x'(t) + \frac{\partialr_x}{\partial y}y'(t),\\\frac{\partial r_y}{\partial t}&amp;=\frac{\partial r_y}{\partialx}x'(t) + \frac{\partial r_y}{\partialy}y'(t).\end{align}\]</span> 于是我们发现比值 <span class="math display">\[\begin{align}\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}&amp;=\frac{r_xk-r_y}{r_y(\frac{\partialr_x}{\partial x}+\frac{\partial r_x}{\partial y}k)-r_x(\frac{\partialr_y}{\partial x} + \frac{\partial r_y}{\partial y}k)}\\&amp;=-\frac{r_x\frac{\partial P}{\partial x}+r_y\frac{\partialP}{\partial y}}{r_y(\frac{\partial r_x}{\partial x}\frac{\partialP}{\partial y}-\frac{\partial r_x}{\partial y}\frac{\partial P}{\partialx})-r_x(\frac{\partial r_y}{\partial x}\frac{\partial P}{\partial y} -\frac{\partial r_y}{\partial y}\frac{\partial P}{\partial x})}.\end{align}\]</span> 变成了一个不需要显式用到 <span class="math inline">\(t\)</span> 的量，即变量 <span class="math inline">\(t\)</span> “消掉”了。代入上面焦散的表达式中，我们得到 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix}-\frac{r_x\frac{\partialP}{\partial x}+r_y\frac{\partial P}{\partial y}}{r_y(\frac{\partialr_x}{\partial x}\frac{\partial P}{\partial y}-\frac{\partialr_x}{\partial y}\frac{\partial P}{\partial x})-r_x(\frac{\partialr_y}{\partial x}\frac{\partial P}{\partial y} - \frac{\partialr_y}{\partial y}\frac{\partial P}{\partial x})}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span> 这个式子还可以再简化一点：注意到曲线在 <span class="math inline">\((x,y)\)</span> 处的法向量由 <span class="math inline">\(\mathbf{n}=\frac{\nabla P}{|\nabla P|}\)</span>给出，其中 <span class="math inline">\(\nabla P=(\frac{\partialP}{\partial x},\frac{\partial P}{\partial y})\)</span>。于是由 <span class="math display">\[\mathbf{r}= \mathbf{l}- 2(\mathbf{l}\cdot\mathbf{n})\mathbf{n}\]</span> 可得 <span class="math display">\[\mathbf{r}\cdot \nabla P=-\mathbf{l}\cdot \nablaP.\]</span> 从而 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix}+\frac{\mathbf{l}\cdot\nablaP}{r_y(\frac{\partial r_x}{\partial x}\frac{\partial P}{\partialy}-\frac{\partial r_x}{\partial y}\frac{\partial P}{\partialx})-r_x(\frac{\partial r_y}{\partial x}\frac{\partial P}{\partial y} -\frac{\partial r_y}{\partial y}\frac{\partial P}{\partialx})}\begin{pmatrix}r_x\\ r_y\end{pmatrix}.\]</span></p><p>这是四个变量 <span class="math inline">\(x,y,X,Y\)</span>满足的两个方程，形如 <span class="math inline">\(F(X,x,y)=0\)</span> 和<span class="math inline">\(G(Y,x,y)=0\)</span>。记住我们还有已知的方程<span class="math inline">\(P(x,y)=0\)</span>。为了从这三个方程中消掉<span class="math inline">\(x,y\)</span>，得到一个仅包含 <span class="math inline">\((X,Y)\)</span> 的表达式，我们可以尝试用 <a href="https://en.wikipedia.org/wiki/Gr%C3%B6bner_basis">Gröbnerbasis</a> 方法。Gröbner 基方法会把多项式方程组 <span class="math display">\[F=G=P=0\]</span> 转化为一组等价的新方程组 <span class="math display">\[g_1=g_2=\cdots=g_m=0.\]</span>即它们有完全相同的解集。</p><p><span class="math inline">\(\{g_1,\ldots,g_m\}\)</span> 是 <span class="math inline">\(F,G,P\)</span> 在多项式环 <span class="math inline">\(\mathbb{R}[x,y,X,Y]\)</span> 中生成的理想 <span class="math inline">\(I=\langle F,G,P\rangle\)</span>的一组生成元，<span class="math inline">\(\{g_1,\ldots,g_m\}\)</span>叫做 <span class="math inline">\(I\)</span> 的约化的 Gröbner基。在字典序 <span class="math inline">\(x\succ y\succ X\succ Y\)</span>下，约化的 Gröbner 基会有一个好的属性，即从 <span class="math inline">\(g_1\)</span> 到 <span class="math inline">\(g_m\)</span>，其中的变元会按照从 <span class="math inline">\(x\to y\to X\to Y\)</span>的先后顺序被消除掉。注意这是个不太严格的说法，我们并不是总能消掉顺序靠前的变元，但是如果消除发生的话，它就会按照这个顺序来。这样我们就可以执行类似高斯消元法中的回代操作，从而新方程组的求解会更加简单。</p><p>我们来用 <code>sympy</code> 实验一下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>x, y, X, Y = symbols(<span class="hljs-string">"x y X Y"</span>)<br>P = x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>dx = diff(P, x)  <span class="hljs-comment"># gradient of P</span><br>dy = diff(P, y)<br>curve = Matrix([x, y])<br>light_source = Matrix([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>l = curve - light_source  <span class="hljs-comment"># the incident ray</span><br>n = Matrix([dx, dy])  <span class="hljs-comment"># the normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n))  <span class="hljs-comment"># the reflected ray</span><br>rx, ry = r<br>dxrx = diff(rx, x)<br>dyrx = diff(rx, y)<br>dxry = diff(ry, x)<br>dyry = diff(ry, y)<br>denominator = ry * (dxrx * dy - dyrx * dx) - rx * (dxry * dy - dyry * dx)<br>nominator = dx * l[<span class="hljs-number">0</span>] + dy * l[<span class="hljs-number">1</span>]<br>F = (X - x) * denominator - nominator * rx<br>G = (Y - y) * denominator - nominator * ry<br>eqs = [eq.as_numer_denom()[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> eq <span class="hljs-keyword">in</span> [F, G, P]]<br>gb = groebner(eqs, [x, y, X, Y])<br>print(gb)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 给出的结果的最后一项是</p><p><span class="math display">\[27 X^{4} y^{2} + 54 X^{2} Y^{2} y^{2} -18 X^{2} y^{2} - 8 X y^{2} + 27 Y^{4} y^{2} - 18 Y^{2} y^{2} -y^{2}.\]</span></p><p><span class="math inline">\(x\)</span> 被消掉了！原方程组 <span class="math inline">\(F=G=P\)</span>的解必然是上面这个方程的解的子集。观察它的每一项都带有一个 <span class="math inline">\(y^2\)</span>，这显然不是我们要的解。把 <span class="math inline">\(y^2\)</span> 去掉，剩下的因子</p><p><span class="math display">\[27X^{4}+54X^{2}Y^{2}-18X^{2} -8X +27Y^{4}-18Y^{2}-1=0.\]</span></p><p>就是心脏线的隐函数表示。不信？在 <a href="https://www.desmos.com/geometry/vtjbq3ete1">Desmos</a>里面画出来看看！</p><p><img style="margin:0px auto;display:block" width="300" src="/images/caustics/desmos_cardioid.png"></p><h1 id="注记">注记</h1><p>这篇文章主要覆盖了 Greg Egan博文的前半部分，他的后半部分内容我觉得有点放飞自我，也没怎么仔细看。</p><p>虽然我们用 <code>sympy</code>的实验很成功，但注意并不是所有情况下都能得到焦散曲线（比如光源位于抛物线的焦点时，反射光线都是平行的），而且对复杂的曲线<code>sympy</code> 算起来非常慢。</p><p>我研究生的时候上过计算机代数的课程，当时用的教学软件是 Maple。Maple编程是很不方便的，所以我其实没有多少计算机代数的编程经验。我之前一直觉得<code>sympy</code>运行又慢，输出的表达式也不够简化，所以不太愿意用它。这次实验有点刷新我对<code>sympy</code>的认知。我还记得当时课程要求每人提交一份读书报告，我写的是 <a href="https://link.springer.com/book/10.1007/978-3-319-16721-3">Ideals,Varieties, and Algorithms</a> 的笔记，但毕业多年以来这还是我第一次用到Gröbner 基！</p><p>我写这篇文章的时候正好临近情人节，所以我在想有没有什么曲线的焦散能给出<a href="https://www.desmos.com/geometry/ngdpq0zrei">爱心曲线</a>：</p><p><img style="margin:0px auto;display:block" width="300" src="/images/caustics/heart.png"></p><p>于是我找到了 <a href="https://www.tandfonline.com/doi/full/10.1080/00029890.2020.1722019">这篇文章</a>。不过看起来里面给出的结论计算量很大，很难用在爱心线上（也许是我错了）。</p>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Möbius 变换与球的刚体运动</title>
      <link href="mobius-ball-rigid-motion/"/>
      <url>mobius-ball-rigid-motion/</url>
      
        <content type="html"><![CDATA[<p>五一期间我写了一个 shadertoy 小动画，演示 Möbius变换与球的刚体运动之间的关系：</p><span id="more"></span><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/fljfRm?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><p>这个动画的名字叫做 Möbius transformation revealed，想法源自 DouglasN. Arnold 和 Jonathan Rogness 于 2007 年发布的 <a href="https://www-users.cse.umn.edu/~arnold/moebius/">同名视频</a>。这是一个很有名的视频，它表达的核心思想是，扩充复平面<span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的 Möbius变换可以由球在三维空间中的刚体运动给出：</p><ol type="1"><li>我们称一个球 <span class="math inline">\(S\)</span>是<strong>容许</strong>的，如果 <span class="math inline">\(S\)</span>的最高点，也就是北极点位于半空间 <span class="math inline">\(\{z&gt;0\}\)</span> 中。</li><li>取任何一个可容许的球 <span class="math inline">\(S\)</span>，将<span class="math inline">\(\overline{\mathbb{C}}\)</span>在逆球极投影下对应到 <span class="math inline">\(S\)</span>的球面上。</li><li>对 <span class="math inline">\(S\)</span> 作刚体变换 （平移和旋转）<span class="math inline">\(S\to T(S)\)</span>，使得 <span class="math inline">\(T(S)\)</span> 也是一个容许的球，即 <span class="math inline">\(T(S)\)</span> 的最高点也在半空间 <span class="math inline">\(\{z&gt;0\}\)</span> 中。</li><li>将 <span class="math inline">\(T(S)\)</span>的表面通过球极投影再映射回 <span class="math inline">\(\overline{\mathbb{C}}\)</span>，我们就得到了一个<span class="math inline">\(\overline{\mathbb{C}}\to\overline{\mathbb{C}}\)</span>的变换，此变换是一个 Möbius 变换，且所有 Möbius变换都可以通过此种方式得到。</li></ol><p>整个过程如下所示：</p><p><span class="math display">\[\underbrace{\overline{\mathbb{C}}\xrightarrow{\text{inversestereographic projection}} S\xrightarrow{\text{rigid motion}}T(S)\xrightarrow{\text{stereographicprojection}}\overline{\mathbb{C}}}_{\text{Möbiustransformation}}.\]</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>球极投影使用的北极点始终是球面的最高点。</p></div><p>详细的解释可以见原视频的解释 <a href="https://www-users.cse.umn.edu/~arnold/papers/moebius.pdf">文章</a>。但是从直观上理解也不难：</p><ul><li><p><span class="math inline">\(S\)</span> 在 <span class="math inline">\(xy\)</span> 平面内的平移给出的是 <span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的平移。<video src="/images/mobius/translation.mp4" height="300" controls=""></video></p></li><li><p><span class="math inline">\(S\)</span> 在 <span class="math inline">\(z\)</span> 方向上的平移给出的是 <span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的缩放。<video src="/images/mobius/scale.mp4" height="300" controls=""></video></p></li><li><p>保持 <span class="math inline">\(S\)</span>的北极点不动的旋转给出的是 <span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的旋转。<video src="/images/mobius/rotation.mp4" height="300" controls=""></video></p></li><li><p>绕 <span class="math inline">\(x\)</span> 轴旋转 180 度给出的是<span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的逆变换<span class="math inline">\(z\to 1/z\)</span>。<video src="/images/mobius/inversion.mp4" height="300" controls=""></video></p></li></ul><p>以上几种运动方式的复合可以给出可容许球的任何刚体运动，而任何 Möbius变换都是平移、缩放、旋转、逆变换的复合，所以 Möbius变换确实与可容许球体的刚体运动是对应的。</p><p>反过来对给定的 Möbius 变换 <span class="math inline">\(M\)</span>和容许的球 <span class="math inline">\(S\)</span>，当 <span class="math inline">\(S\)</span> 的初始位置确定以后，给出 <span class="math inline">\(M\)</span> 的刚体运动 <span class="math inline">\(T\)</span> 也是唯一确定的。证明见 <a href="https://scholar.rose-hulman.edu/cgi/viewcontent.cgi?article=1218&amp;context=rhumj">这个论文</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>遛狗中的数学：曲线的环绕数、Rouché 定理和开映射定理</title>
      <link href="Rouche-theorem-winding-number/"/>
      <url>Rouche-theorem-winding-number/</url>
      
        <content type="html"><![CDATA[<p>我写了一个 <a href="https://www.shadertoy.com/view/fdK3RD">shadertoy小动画</a>，演示 <span class="citation" data-cites="Needham1997">(<a href="#ref-Needham1997" role="doc-biblioref">Needham 1997</a>)</span>书中第 7 章 “Winding numbers and topology” 中的结论：</p><span id="more"></span><div class="statement simple plain unnumbered"><p>一个人和他的狗在公园里绕着一棵树散步，人和狗各自走的路径都是闭曲线，即经过一段时间后都会回到起点。如果人把狗绳抓的紧一些，使得整个过程中狗<strong>无法接触</strong>到树，则结束后人和狗绕着树走的圈数是一样的，这就是下面这个动画演示的：（树的位置是原点，用一个表盘标记）</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/fdK3RD?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe></div><p>对应的数学结论是：两条闭曲线 <span class="math inline">\(\gamma_1,\gamma_2\)</span> 如果都不经过原点，且<span class="math inline">\(\gamma_1\)</span>可以在不碰触到原点的前提下通过连续的形变变为 <span class="math inline">\(\gamma_2\)</span>（同伦），则 <span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点的环绕数相等。</p><p>注意这个结论只要求 <span class="math inline">\(\gamma_1,\gamma_2:\,[0,1]\to\mathbb{R}^2\)</span>是两条连续曲线，并不涉及解析性。因为环绕数和同伦都是拓扑概念，只涉及连续性。</p><p>当 <span class="math inline">\(\gamma_1=f(S^1),\gamma_2=g(S^1)\)</span>分别是单位圆 <span class="math inline">\(S^1:\{z\in\mathbb{C}:|z|=1\}\)</span>在两个解析函数 <span class="math inline">\(f,g\)</span> 下的像时，<a href="https://en.wikipedia.org/wiki/Argument_principle">幅角原理</a>告诉我们 <span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点的环绕数分别等于 <span class="math inline">\(f,g\)</span> 在<span class="math inline">\(S^1\)</span> 内部的零点个数。进一步 <a href="https://en.wikipedia.org/wiki/Rouch%C3%A9%27s_theorem">Rouché定理</a> 告诉我们，如果对任何 <span class="math inline">\(z\inS^1\)</span> 都有 <span class="math inline">\(|f(z)|&gt;|f(z)-g(z)|\)</span> 成立，即可保证<span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点有相同的环绕数，从而 <span class="math inline">\(f,g\)</span> 在<span class="math inline">\(S^1\)</span>内部的零点个数也是相同的。Rouché 定理的条件说的就是，假设人的位置是<span class="math inline">\(f(z)\)</span>，狗的位置是 <span class="math inline">\(g(z)\)</span>，绳子 <span class="math inline">\(l(z)=f(z)-g(z)\)</span> 的长度 <span class="math inline">\(|l(z)|\)</span> 始终小于人到原点的距离 <span class="math inline">\(|f(z)|\)</span>，就可以保证狗始终够不到原点。</p><p>动画中左下角的圆周是 <span class="math inline">\(S^1\)</span>，动画右边红、绿两条路径分别是 <span class="math inline">\(f(S^1)\)</span> 和 <span class="math inline">\(g(S^1)\)</span>。这里的 <span class="math inline">\(f\)</span> 我取的形如 <span class="math display">\[f(z)=\frac{z-a}{1-\overline{a}z}\frac{z-b}{1-\overline{b}z}\frac{z-c}{1-\overline{c}z}(z-2-2i),\quad |a|,|b|,|c|&lt;1.\]</span> <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(S^1\)</span> 的内部有 3 个根（我用红点标出来了），在 <span class="math inline">\(S^1\)</span> 上不为0，在 <span class="math inline">\(S^1\)</span>外部有一个根（图中没有画）。<span class="math inline">\(f(z)\)</span>的前三个因子构成一个 Blaschke 乘积，它把 <span class="math inline">\(S^1\)</span> 的内部仍然映射为内部，把 <span class="math inline">\(S^1\)</span> 仍然映射为 <span class="math inline">\(S^1\)</span>，于是对任何 <span class="math inline">\(z\in S^1\)</span> 有 <span class="math display">\[|f(z)| = |z - 2 - 2i| \geq 2\sqrt{2} - 1,\quadz\in S^1.\]</span> 所以只要绳子 <span class="math inline">\(l(z)\)</span> 满足 <span class="math inline">\(|l(S^1)| &lt; 2\sqrt{2}-1\)</span>，则狗走的路径<span class="math inline">\(g(S^1)=f(S^1)+l(S^1)\)</span>就不可能接触到原点。我这里取了 <span class="math inline">\(l(z) =cz\)</span>，其中 <span class="math inline">\(c\)</span> 是一个小于<span class="math inline">\(2\sqrt{2}-1\)</span> 的正实数。</p><p>Needham 的书中还介绍了曲线 <span class="math inline">\(\gamma\)</span> 的环绕数在 <span class="math inline">\(\mathbb{C}\setminus\gamma\)</span>的每个连通分支上都是常数。对不在 <span class="math inline">\(\gamma\)</span> 上的一点 <span class="math inline">\(z\)</span>，我们可以稍稍移动 <span class="math inline">\(z\)</span> 到另一个点 <span class="math inline">\(z'\)</span>，只要保持 <span class="math inline">\(z'\)</span> 仍然位于 <span class="math inline">\(z\)</span> 所在的连通分支内，则 <span class="math inline">\(\gamma\)</span> 关于 <span class="math inline">\(z\)</span> 和 <span class="math inline">\(z'\)</span>有相同的环绕数。利用这个事实并结合幅角原理不难得出下面的结论：</p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(\gamma\)</span>是一条简单闭曲线，内部围的区域为 <span class="math inline">\(\Omega\)</span>，<span class="math inline">\(f(z)\)</span> 是一个非常数的解析函数，<span class="math inline">\(f\)</span> 在包含 <span class="math inline">\(\gamma\)</span>的某个区域内解析。假设有两棵树分别位于 <span class="math inline">\(w_0,\,w_1\)</span> 两点，且人行走的路线 <span class="math inline">\(f(\gamma)\)</span> 到 <span class="math inline">\(w_0\)</span> 的距离始终大于两棵树之间的距离：<span class="math display">\[|f(z)-w_0| &gt; |w_0-w_1|,\quad\forallz\in\gamma.\]</span> 则 <span class="math inline">\(f(\gamma)\)</span>关于 <span class="math inline">\(w_0,w_1\)</span> 的环绕数相等，从而<span class="math inline">\(w_0,w_1\)</span> 在 <span class="math inline">\(\gamma\)</span> 内部的原像个数相同： <span class="math display">\[\sharp\{z\in \Omega: f(z)=w_0\} = \sharp\{z\in\Omega: f(z)=w_1\}.\]</span></p></div><p>这是因为根据条件，从 <span class="math inline">\(w_0\)</span>沿着线段 <span class="math inline">\([w_0,w_1]\)</span> 移动到 <span class="math inline">\(w_1\)</span> 的过程中始终不会碰触到曲线 <span class="math inline">\(f(\gamma)\)</span>，所以 <span class="math inline">\(w_0,w_1\)</span> 必然位于同一连通分支内。</p><p><img style="margin:0px auto;display:block" src="/images/rouche/winding_number.svg" width="250"></p><p>利用此推论我们不难得出复分析中的 <a href="https://en.wikipedia.org/wiki/Open_mapping_theorem_(complex_analysis)">开映射定理</a>：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>如果 <span class="math inline">\(U\subseteq\mathbb{C}\)</span>是开集，<span class="math inline">\(f:U\to\mathbb{C}\)</span>是非常数的解析函数，则 <span class="math inline">\(f(U)\)</span>也是开集。</p></div><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Needham1997" class="csl-entry" role="listitem">Needham, Tristan. 1997. <em>Visual Complex Analysis</em>. The ClarendonPress, Oxford University Press, New York.</div></div>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静电场与 Marden 定理</title>
      <link href="Marden-theorem/"/>
      <url>Marden-theorem/</url>
      
        <content type="html"><![CDATA[<p>我昨晚刚完成了一个 <a href="https://www.shadertoy.com/view/7lf3Wn">shadertoy小动画</a>，演示平面几何中的 <a href="https://en.wikipedia.org/wiki/Marden%27s_theorem">Marden定理</a>、复分析中的 <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Lucas_theorem">Gauss-Lucas定理</a> 和静电场之间的关系：</p><span id="more"></span><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/7lf3Wn?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><p>这个动画的含义如下：</p><ol type="1"><li><p>在复平面上三角形 <span class="math inline">\(\Delta ABC\)</span>的三个顶点处各自放置一个单位正电荷，则平面上电场强度为 0的点有两个（这两个点可能重合），它们位于 <span class="math inline">\(\Delta ABC\)</span> 的内部，并且是三次复多项式<span class="math inline">\(P(z) = (z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span> 的零点。</p></li><li><p>不仅如此，这两个零点还是一个内切于 <span class="math inline">\(\Delta ABC\)</span>的椭圆的两个焦点，此椭圆是所有内切于 <span class="math inline">\(\DeltaABC\)</span> 的椭圆中面积最大者，并且其与 <span class="math inline">\(\Delta ABC\)</span>的三边的切点均为各边中点。这个椭圆叫做 <a href="https://en.wikipedia.org/wiki/Steiner_inellipse">Steiner内切椭圆</a>。</p></li></ol><p>这个动画是受几天前 Albert Chern 的 <a href="https://twitter.com/theAlbertChern/status/1395468792788967428?s=20">一篇推文</a>启发所作，John Baez 也写了一篇关于这个话题的 <a href="https://johncarlosbaez.wordpress.com/2021/05/24/electrostatics-and-the-gauss-lucas-theorem/">文章</a>。我是由此才了解到Marden 定理还有如此有趣的物理学解释，的确大开眼界！</p><hr><p>在平面上不全共线的 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(a_1,\ldots,a_n\)</span>处放置若干单位正电荷，这规定了一个平面上的电势函数 <span class="math inline">\(V(z)\)</span> （标量） 和一个电场 <span class="math inline">\(\mathbf{E}(z)\)</span>（二维向量场）。电学知识告诉我们，在忽略物理常数意义下有 <span class="math display">\[V(z)=\sum_{i=1}^n\ln|z-a_i|=\ln\prod_{i=1}^n|z-a_i|=\ln|P(z)|.\]</span> 其中<span class="math inline">\(P(z)=(z-a_1)(z-a_2)\cdots(z-a_n)\)</span>是以 <span class="math inline">\(a_1,\ldots,a_n\)</span>为根的多项式。</p><p>此外 <span class="math inline">\(\mathbf{E}(z) = -\nablaV(z)\)</span> 为电势的梯度向量取负。</p><blockquote><p><strong>问题</strong>：怎样确定平面上场强为 0 的点呢？</p></blockquote><p>场强为 0的点也叫做<strong>平衡点</strong>、<strong>鞍点</strong>，因为在这一点处的电荷不受电场的库仑力。</p><p>答案有点出人意料：平衡点必然是 <span class="math inline">\(P'(z)\)</span> 的零点，而且这些点都属于 <span class="math inline">\(a_1,\ldots,a_n\)</span> 的凸包！</p><p>注意 <span class="math inline">\(V(z)\)</span> 是 <span class="math inline">\(\ln P(z) = \ln |P(z)| + i\arg{P(z)}\)</span>的实部，由 Cauchy-Riemann 方程不难看出使得亚纯函数实部梯度为 0的点一定是其导数的零点，即满足 <span class="math inline">\(\nablaV=0\)</span> 的点都是 <span class="math inline">\((\lnP(z))'=P'(z)/P(z)\)</span> 的零点，所以平衡点都是 <span class="math inline">\(P'(z)\)</span> 的零点。平衡点属于 <span class="math inline">\(\{a_1,\ldots,a_n\}\)</span> 的凸包是根据 <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Lucas_theorem">Gauss-Lucas定理</a>：任何复多项式 <span class="math inline">\(f\)</span>的导数的零点都属于 <span class="math inline">\(f\)</span>的零点构成的凸包！</p><p>John Baez 的文章中利用凸集分离定理给出了 Gauss-Lucas定理的一个简洁证明。</p><p>需要注意的是，反过来 <span class="math inline">\(P'(z)\)</span>的零点未必都是电场的平衡点，当 <span class="math inline">\(P(z)\)</span>有重根时，重根也是 <span class="math inline">\(P'(z)\)</span>的零点，但不是 <span class="math inline">\(P'(z)/P(z)\)</span>的零点，所以不是平衡点。</p><p>此外平衡点是鞍点 (saddle point) 是由于 <span class="math inline">\(V(z)\)</span>的调和性质，其不存在局部的极大极小值，所以使得 <span class="math inline">\(\nabla V=0\)</span> 的点都是鞍点。</p><p>在三个点电荷 <span class="math inline">\(A,B,C\)</span>的情形，平衡点有两个，它们位于 <span class="math inline">\(\DeltaABC\)</span> 的内部，且是多项式 <span class="math inline">\(P(z) =(z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span>的零点。那关于这两个点的具体位置我们可以说什么吗？这就是优美的 Marden定理，要表述这个定理，我们需要先介绍 Steiner 内切椭圆的概念：</p><div id="steiner-inellipse" class="unnumbered statement sta_steiner_inellipse plain"><p><span class="statement-heading"><span class="statement-label">Steinerinellipse</span>.</span><span class="statement-spah"></span>在所有内切于 <span class="math inline">\(\Delta ABC\)</span>的椭圆中，存在唯一的一个面积最大者，叫做 Steiner inellipse，此椭圆与<span class="math inline">\(\Delta ABC\)</span>三边的切点为各边的中点。</p></div><p>Marden 定理断言 <span class="math inline">\(P'(z)\)</span>的两个根正是 Steiner 内切椭圆的两个焦点：</p><div id="marden-------" class="unnumbered statement sta_marden___ plain"><p><span class="statement-heading"><span class="statement-label">Marden定理</span>.</span><span class="statement-spah"> </span>复多项式 <span class="math inline">\(P(z)=(z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span> 的两个零点正是 <span class="math inline">\(\Delta ABC\)</span> 的 Steiner inellipse的两个焦点。</p></div><p>Steiner inellipse 和 Marden定理的证明并不复杂，美国数学月刊上出现过两篇介绍其证明的文章，都非常值得一读：</p><ol type="1"><li><p><a href="https://www.researchgate.net/publication/228698127_Triangles_Ellipses_and_Cubic_Polynomials">Triangles,Ellipses, and Cubic Polynomials</a>.</p></li><li><p><a href="https://www.researchgate.net/publication/263136028_An_Elementary_Proof_of_Marden%27s_Theorem">AnElementary Proof of Marden’s Theorem</a>.</p></li></ol><p>其中第一篇文章采用了复数和仿射变换的途径，第二篇使用了椭圆的光学性质。</p>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Todd-Coxeter 算法和 3D/4D 均匀多胞体</title>
      <link href="Todd-Coxeter-and-uniform-polytopes/"/>
      <url>Todd-Coxeter-and-uniform-polytopes/</url>
      
        <content type="html"><![CDATA[<p>本文介绍我写的一个高颜值的、脱离了低级趣味的小程序：用 Python 和POV-Ray 绘制各种三维多面体和四维多胞体，代码在 <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/polytopes">Github</a>上。</p><p>以下是用这个程序渲染的一些例子，其中不同颜色的顶点/边/面表示它们在对称群的作用下位于不同的轨道中，具体解释见后。</p><span id="more"></span><h1 id="例子">例子</h1><ul><li><p>所有的 Platonic 多面体，Archimedean 多面体，比如 snubdodecahedron:</p><p><video src="/images/polytopes/snub-dodecahedron.mp4" controls=""></video></p></li><li><p>所有的 Kepler-Poinsot 多面体，比如 great icosahedron:</p><p><video src="/images/polytopes/great-icosahedron.mp4" controls=""></video></p></li><li><p>所有的四维均匀多胞体 （除去一个特例 <a href="https://en.wikipedia.org/wiki/Grand_antiprism">The grandantiprism</a>），比如我的 Github 头像 (runcinated 120-cell)：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/github-favicon.png"></p></li><li><p>截断的四维正方体 truncated tesseract:</p><p><video src="/images/polytopes/truncated-tesseract.mp4" controls=""></video></p></li><li><p>4d cube:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/4-cube.png"></p></li><li><p>也可以是非凸的，比如星状正多胞体中的 grand stellated120-cell:</p><p><video src="/images/polytopes/grand-stellated-120-cell.mp4" controls=""></video></p></li><li><p>甚至是 5 维欧氏空间中的均匀多胞体，如 5-cube:</p><p><video src="/images/polytopes/5-cube.mp4" controls=""></video></p></li></ul><p>等等，可玩的效果是非常多的。</p><p>以上这些都是在 Python 中做好计算以后，将多胞体的数据导出到 POV-Ray中渲染得到的。你完全可以通过改写代码中的 POV-Ray的部分来渲染得出不同的效果，当然前提是需要掌握 POV-Ray的场景描述语言，不过这属于另一段故事，就不在本文的讨论范围内了。</p><p>下面介绍程序背后的数学原理。</p><h1 id="这些图画的都是什么">这些图画的都是什么？</h1><p>这些图都是三维或者四维<strong>欧氏空间</strong>中<strong>凸/非凸</strong>的<strong>均匀</strong>多胞体(polytope)，三维的情形更常用的称呼是多面体。这里有几个关键词需要注意：凸/非凸、均匀。</p><p>凸比较好理解，就是指多胞体上任意两点间的连线仍然属于此多胞体，否则就是非凸。上面的例子中Platonic 多面体、Archimedean 多面体都是凸的，Kepler-Poinsot多面体、星状正多胞体都是非凸的。</p><p>均匀这个词就不太好理解了。简单说就是：多胞体的所有顶点都一样，且每个面都是正多边形，每个胞腔都是三维的均匀多面体（这是个递归的定义）。</p><p>要准确解释什么叫所有顶点都一样，就要用到群论的语言：一个多胞体 <span class="math inline">\(P\)</span> 的对称群 <span class="math inline">\(G\)</span>是欧氏空间中一组正交变换构成的有限群，<span class="math inline">\(G\)</span> 作用在 <span class="math inline">\(P\)</span> 上保持 <span class="math inline">\(P\)</span> 不变。所有顶点都一样的严格说法是 <span class="math inline">\(G\)</span> 传递地作用在 <span class="math inline">\(P\)</span> 的顶点集上，即对 <span class="math inline">\(P\)</span> 的任何两个顶点 <span class="math inline">\(u,v\)</span>，都存在 <span class="math inline">\(g\in G\)</span>，<span class="math inline">\(g\)</span> 把 <span class="math inline">\(u\)</span> 映射为 <span class="math inline">\(v\)</span>。</p><h1 id="这些图是怎么画出来的">这些图是怎么画出来的？</h1><p>这些多胞体看起来样子大不相同，但它们都可以用同一种方法计算出来，叫做<a href="https://en.wikipedia.org/wiki/Wythoff_construction">Wythoff构造法</a>，也称万花筒构造法。它的原理跟我们小时候玩的万花筒的原理是一样的：在空间中放置若干过原点的反射平面（镜子），镜面之间的夹角是精心设计好的，都形如 <span class="math inline">\(\pi-\pi/p\)</span>，其中 <span class="math inline">\(p\)</span> 为有理数。在空间中选定一个初始顶点<span class="math inline">\(v_0\)</span>，将 <span class="math inline">\(v_0\)</span>关于这些镜子反复作反射变换，得到的全部镜像就是多胞体的顶点。如果 <span class="math inline">\(v_0\)</span> 关于第 <span class="math inline">\(i\)</span> 面镜子反射后得到的镜像是 <span class="math inline">\(v_1\)</span>，则 <span class="math inline">\((v_0,v_1)\)</span> 构成一条类型为 <span class="math inline">\(i\)</span>的边，我们把它以及在对称群作用下同轨道的所有边都染成 <span class="math inline">\(i\)</span> 号色。如果 <span class="math inline">\(v_0\)</span> 先关于镜面 <span class="math inline">\(i\)</span> 作反射，再关于镜面 <span class="math inline">\(j\)</span>作反射，则由于两个反射变换的复合是一个旋转变换，<span class="math inline">\(v_0\)</span>实际上是绕着某个面的中心和原点的连线作了一次旋转，旋转的角度为 <span class="math inline">\(2\pi/m\)</span> （假设镜面 <span class="math inline">\(i\)</span> 和镜面 <span class="math inline">\(j\)</span> 的法向量夹角是 <span class="math inline">\(\pi-\pi/m\)</span>），重复此旋转 <span class="math inline">\(m\)</span> 次即可得到多胞体的一个类型为 <span class="math inline">\((i,j)\)</span>的面，我们把它在对称群作用下同轨道的所有面都染成同一颜色。</p><p>这里的关键问题有两个：</p><ol type="1"><li>对于不同的均匀多胞体，应该如何放置这些镜面，并选择初始顶点？</li><li>摆好镜面和初始顶点以后，怎样不重复不遗漏地计算初始顶点的所有镜像？</li></ol><p>第一个问题的答案叫做 <a href="https://en.wikipedia.org/wiki/Coxeter%E2%80%93Dynkin_diagram">Coxeter-Dynkin图</a>，Coxeter-Dynkin图是一个带标记信息的无向图，它编码了多胞体的全部信息，即只要知道了多胞体对应的Coxeter-Dynkin 图，就可以求出该多胞体的所有数据（仅缩放大小和在空间中的摆放位置除外）。每个均匀多胞体都有一个Coxeter-Dynkin 图与之对应，但是不同的 Coxeter-Dynkin图可能描述的是相同的多胞体。</p><p>比如正方体的 Coxeter-Dynkin 图为：</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="200"></p><p>我们来解释这个图的含义：</p><p>在一个 Coxeter-Dynkin图中，每个顶点代表一面镜子，在上图中有三个顶点，所以有三面镜子。将这三面镜子从左到右依次记作<span class="math inline">\(m_0, m_1,m_2\)</span>，顶点之间的边记录了镜子间的夹角：</p><ol type="1"><li>若两个镜面之间的夹角为 <span class="math inline">\(\pi/2\)</span>则它们之间没有边相连。</li><li>若两个镜面之间的夹角为 <span class="math inline">\(\pi-\pi/3\)</span>则它们之间用一条无标记的边相连。</li><li>若两个镜面之间的夹角为 <span class="math inline">\(\pi-\pi/m\)</span> (<span class="math inline">\(m\)</span> 为有理数且 <span class="math inline">\(m&gt;2, m\ne3\)</span>)，则它们之间用一条标号为<span class="math inline">\(m\)</span> 的边相连。</li></ol><p>此外用圈出的镜面来标记初始顶点的位置，<strong>一个镜面被圈出当且仅当初始顶点不在这个镜面上</strong>。</p><p>从而在正方形的情形 <span class="math inline">\(\langlem_0,m_1\rangle=\pi-\pi/4\)</span>，<span class="math inline">\(\langlem_1,m_2\rangle=\pi-\pi/3\)</span>，<span class="math inline">\(\langlem_0,m_2\rangle=\pi/2\)</span>。初始顶点落在 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 上但是不属于 <span class="math inline">\(m_0\)</span>。</p><p>于是这三面镜子可以这样摆放：</p><ol type="1"><li>镜子 <span class="math inline">\(m_0\)</span> 的法向量可以随意，比如<span class="math inline">\(n_0=(1, 0, 0)\)</span>。</li><li>镜子 <span class="math inline">\(m_1\)</span> 的法向量 <span class="math inline">\(n_1\)</span> 与 <span class="math inline">\(n_0\)</span> 夹角为 <span class="math inline">\(3\pi/4\)</span>，于是 <span class="math inline">\(n_1\)</span> 可以取为 <span class="math inline">\((\cos\dfrac{3\pi}{4}, \sin\dfrac{3\pi}{4},0)\)</span>。</li><li>镜子 <span class="math inline">\(m_2\)</span> 的法向量 <span class="math inline">\(n_2\)</span> 与 <span class="math inline">\(n_0\)</span> 垂直，所以 <span class="math inline">\(n_2\)</span> 形如 <span class="math inline">\((0,y_3,z_3)\)</span>，它与 <span class="math inline">\(n_1\)</span> 夹角是 <span class="math inline">\(2\pi/3\)</span>，所以 <span class="math inline">\(y_3\sin\dfrac{3\pi}{4}=\cos\dfrac{2\pi}{3}\)</span>，再结合 <span class="math inline">\(n_2\)</span> 是单位向量，<span class="math inline">\(z_3=\sqrt{1-y_3^2}\)</span>，解出 <span class="math inline">\(y_3, z_3\)</span> 即可。</li></ol><p>要选择一个落在 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 上但是不落在 <span class="math inline">\(m_0\)</span> 上的初始点 <span class="math inline">\(v_0\)</span>，我们可以让 <span class="math inline">\(v_0\)</span> 到平面 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 的距离为 0，到平面 <span class="math inline">\(m_0\)</span> 的距离为 1，即</p><p><span class="math display">\[\langle v_0, n_0\rangle=1,\quad \langlev_0, n_1\rangle=0,\quad\langle v_0, n_2\rangle=0.\]</span></p><p>求解这个线性方程组即可。</p><p>我们前面提到过，要使得初始顶点的所有镜像恰好构成一个均匀多胞体，镜子之间的夹角必须精心设置，这实际上只有有限种可能。换句话说，只有有限个Coxeter-Dynkin 图可以给出 3D/4D 的均匀多胞体。在 <a href="https://en.wikipedia.org/wiki/Uniform_polytope">维基百科</a>上完整的列出了每种均匀多胞体对应的 Coxeter-Dynkin图，这里就不再专门列举了，但是特别指出两点：</p><ol type="1"><li>Coxeter-Dynkin图的标号完全决定了多胞体的对称性，而初始顶点的位置则决定了多胞体的截断类型。</li><li>对偶的多胞体具有相同的 Coxeter-Dynkin图，只不过要把边的标号从右到左反过来。比如正八面体和正方体的Coxeter-Dynkin 图是一样的，但是边的标号是 (3, 4)。</li></ol><p>第二个问题的答案叫做 Todd-Coxeter算法，展开讲的话比较复杂，我们单列一节专门谈谈。</p><h1 id="有限表现群和-todd-coxeter-算法">有限表现群和 Todd-Coxeter算法</h1><p>怎样求出初始顶点在所有镜子中的镜像？有个简单的办法：只要反复地将初始顶点关于每个镜面作反射，算出得到的镜像点的坐标，并与之前得到的点的坐标相比较（浮点数比较需要在一定的误差范围内考虑），直到不再有新的镜像点出现为止，不就得到全部顶点集吗？这个方法确实可行，但是既笨又丑陋：它完全没有用到多胞体具有对称性这一事实！</p><p>这个程序采用的是基于符号计算的途径，这个方法可以精准地得出所有顶点/边/面的信息，代价就是涉及的数学略复杂。我们先回忆一下群在集合上的作用的轨道—稳定化子定理：</p><div id="-----------------------------" class="unnumbered statement sta____________ plain"><p><span class="statement-heading"><span class="statement-label">轨道 —稳定化子定理</span>.</span><span class="statement-spah"> </span>设群<span class="math inline">\(G\)</span> 传递地作用在集合 <span class="math inline">\(S\)</span> 上，设 <span class="math inline">\(x\inS\)</span> 的稳定化子群是 <span class="math inline">\(H\)</span>，则集合<span class="math inline">\(S\)</span> 与 <span class="math inline">\(G/H\)</span> 中的右陪集之间有一一对应：<span class="math inline">\(x\cdot g\leftrightarrow Hg\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>和一般的约定不同，这里群在集合上的作用为作用在右边，主要是为了编程方便，实际上左边右边都一样。</p></div><p>这个定理告诉我们，如果群 <span class="math inline">\(G\)</span>传递地作用在一个集合 <span class="math inline">\(S\)</span> 上，而且对<span class="math inline">\(S\)</span> 中某个元素 <span class="math inline">\(x\)</span> 我们知道了它的稳定化子群 <span class="math inline">\(H\)</span>，则只要对 <span class="math inline">\(G/H\)</span> 的每个陪集代表元 <span class="math inline">\(g\)</span>，将 <span class="math inline">\(g\)</span> 作用在 <span class="math inline">\(x\)</span> 上就可以得到整个 <span class="math inline">\(S\)</span>。</p><p>于是给定一个均匀多胞体 <span class="math inline">\(P\)</span>，要求出其全部顶点集合，我们只要：</p><ol type="1"><li>根据 <span class="math inline">\(P\)</span> 的 Coxeter-Dynkin图确定其对称群 <span class="math inline">\(G\)</span> 和初始顶点 <span class="math inline">\(v_0\)</span>。</li><li>定出 <span class="math inline">\(v_0\)</span> 的稳定化子群 <span class="math inline">\(H\)</span> 并求出 <span class="math inline">\(G/H\)</span> 的一组陪集代表元。</li><li>将 <span class="math inline">\(G/H\)</span> 中的每个陪集代表元作用在<span class="math inline">\(v_0\)</span> 上即得 <span class="math inline">\(P\)</span> 的全部顶点。</li></ol><p>我们仍然以正方体为例来讲解：正方体的 Coxeter-Dynkin 图是</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="200"></p><p>仍然记三个镜面为 <span class="math inline">\(m_0,m_1,m_2\)</span>，其法向量分别为 <span class="math inline">\(n_0,n_1,n_2\)</span>，设 <span class="math inline">\(\rho_0,\rho_1,\rho_2\)</span>分别是关于它们的反射变换，<span class="math inline">\(\rho_i\)</span>对应的矩阵为 <span class="math inline">\(M_i=I-2n_in_i^T\)</span>（见 <a href="https://en.wikipedia.org/wiki/Householder_transformation">Householder变换</a>）。</p><p>正方体的对称群 <span class="math inline">\(G\)</span> 由 <span class="math inline">\(\rho_0,\rho_1,\rho_2\)</span>这三个基本反射生成，其表现为： <span class="math display">\[G =\langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span>这是因为反射的平方总是恒等变换，所以 <span class="math inline">\(\rho_i^2=1\)</span>。<span class="math inline">\(\rho_0,\rho_1\)</span> 是两个夹角为 <span class="math inline">\(3\pi/4\)</span> 的反射，所以 <span class="math inline">\(\rho_0\rho_1\)</span> 是一个角度为 <span class="math inline">\(3\pi/2\)</span> 的旋转，旋转轴为 <span class="math inline">\(m_0\)</span> 和 <span class="math inline">\(m_1\)</span> 的交线，从而 <span class="math inline">\((\rho_0\rho_1)^4=1\)</span>。<span class="math inline">\(\rho_1\rho_2,\rho_0\rho_2\)</span>的情形是类似的。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>利用 Todd-Coxeter 算法 （后面有解释） 不难求出这个群包含 48个元素，罗列如下： <span class="math display">\[\begin{array}{lll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{0}&amp;\rho_{1}&amp;\rho_{0}\rho_{2}\\\rho_{2}&amp;\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\end{array}\]</span> 由于在正方形的 Coxeter-Dynkin 图中只有镜面 <span class="math inline">\(m_0\)</span> 是被圈出的，即初始顶点 <span class="math inline">\(v_0\)</span> 落在 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 上，但不属于 <span class="math inline">\(m_0\)</span>，所以反射 <span class="math inline">\(\rho_1,\rho_2\)</span> 保持 <span class="math inline">\(v_0\)</span> 不动，<span class="math inline">\(\rho_0\)</span> 将 <span class="math inline">\(v_0\)</span> 映射为其关于 <span class="math inline">\(m_0\)</span> 的镜像，于是 <span class="math inline">\(v_0\)</span> 的稳定化子群是 <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a><span class="math display">\[H=\langle \rho_1, \rho_2\ |\\rho_1^2=\rho_2^2=(\rho_1\rho_2)^3=e\rangle.\]</span> 显然 <span class="math inline">\(H\)</span> 就是二面体群 <span class="math inline">\(D_3\)</span>，所以 <span class="math inline">\(|H|=6\)</span>，从而 <span class="math inline">\(|G/H|=8\)</span>。利用 Todd-Coxeter算法可得其一组右陪集代表元为 <span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span> 将它们作用在 <span class="math inline">\(v_0\)</span>上即可得到正方体的 8 个顶点。例如 <span class="math inline">\(\rho_0\rho_1\)</span> 作用在 <span class="math inline">\(v_0\)</span> 上为 <span class="math display">\[v_0(\rho_0\rho_1)=(v_0\rho_0)\rho_1=(v_0M_0)\rho_1=v_0M_0M_1.\]</span>其中 <span class="math inline">\(v_0\)</span> 写成行向量的形式，每个<span class="math inline">\(M_i\)</span> 是对称矩阵。</p><p>计算边/面/胞腔的原理是类似的，但考虑的细节要多一些。比如我们想求出所有关于第<span class="math inline">\(i\,(i=0,1,2)\)</span> 个镜面 <span class="math inline">\(m_i\)</span> 反射生成的类型为 <span class="math inline">\(i\)</span> 的边，可以这样做：</p><ol type="1"><li>检查初始顶点 <span class="math inline">\(v_0\)</span> 是否落在 <span class="math inline">\(m_i\)</span>上。如果答案为是，那么关于此镜面的反射保持 <span class="math inline">\(v_0\)</span> 不变，此多面体不含类型 <span class="math inline">\(i\)</span> 的边。否则设 <span class="math inline">\(v_0\)</span> 关于 <span class="math inline">\(m_i\)</span> 的镜像为 <span class="math inline">\(v_1\)</span>，则 <span class="math inline">\((v_0,v_1)\)</span> 构成一条类型为 <span class="math inline">\(i\)</span> 的边<span class="math inline">\(e\)</span>。</li><li>关于 <span class="math inline">\(m_i\)</span> 的反射 <span class="math inline">\(\rho_i\)</span> 把 <span class="math inline">\(v_0\)</span> 和 <span class="math inline">\(v_1\)</span> 互换，从而保持 <span class="math inline">\(e\)</span> 不变。<strong>注意其它任何与 <span class="math inline">\(m_i\)</span> 垂直并且包含初始点 <span class="math inline">\(v_0\)</span> 的镜面反射也会保持 <span class="math inline">\(e\)</span> 不变</strong>。在正方形的情形中，反射<span class="math inline">\(\rho_0\)</span> 互换 <span class="math inline">\(e\)</span> 的两端因而保持 <span class="math inline">\(e\)</span> 不变，此外镜面 <span class="math inline">\(m_0\)</span> 和 <span class="math inline">\(m_2\)</span> 是垂直的，且 <span class="math inline">\(v_0\)</span> 包含在 <span class="math inline">\(m_2\)</span> 中，所以反射 <span class="math inline">\(\rho_2\)</span> 保持 <span class="math inline">\(e\)</span> 上的每个点不变，于是 <span class="math inline">\(e\)</span> 的稳定化子群为 <span class="math inline">\(H=\langle \rho_0,\rho_2 \rangle\)</span>。显然<span class="math inline">\(H\)</span> 同构于 <span class="math inline">\(\mathbb{Z}_2\times\mathbb{Z}_2\)</span>，所以<span class="math inline">\(|H|=4\)</span>，从而 <span class="math inline">\(|G/H|=12\)</span>，即正方体有 12 条边 <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>。</li><li>求出 <span class="math inline">\(G/H\)</span>的一组陪集代表元并作用在 <span class="math inline">\(e\)</span>上得出全部类型为 <span class="math inline">\(i\)</span> 的边。</li></ol><p>求面的情形复杂一些，基本原理是这样的：</p><ol type="1"><li>对 <span class="math inline">\(i\ne j\)</span>，如果初始顶点 <span class="math inline">\(v_0\)</span> 不同时属于镜面 <span class="math inline">\(i\)</span> 和镜面 <span class="math inline">\(j\)</span>，则旋转 <span class="math inline">\(\rho_i\rho_j\)</span> 就可以生成一个面 <span class="math inline">\(f\)</span>。需要注意的是，如果这两个镜面恰好垂直，则必须二者均不包含<span class="math inline">\(v_0\)</span>才能得到一个非退化的面，这个面是个正方形。在正方体的情形，<span class="math inline">\(\rho_0\rho_1\)</span> 可以生成一个面，<span class="math inline">\(\rho_0\rho_2\)</span>（两镜面垂直但只有一个镜面包含<span class="math inline">\(v_0\)</span>）和 <span class="math inline">\(\rho_1\rho_2\)</span>（两镜面均包含 <span class="math inline">\(v_0\)</span>）都不能给出面。</li><li><span class="math inline">\(f\)</span> 的稳定化子群是由 <span class="math inline">\(\rho_i,\rho_j\)</span> 和那些包含 <span class="math inline">\(v_0\)</span> 且与 <span class="math inline">\(m_i,m_j\)</span>均垂直的镜面反射生成。在正方形的情形是 <span class="math inline">\(H=\langle \rho_0,\rho_1 \rangle\)</span> <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>，显然 <span class="math inline">\(H\)</span> 同构于二面体群 <span class="math inline">\(D_8\)</span>，因此 <span class="math inline">\(|H|=8\)</span>，<span class="math inline">\(|G/H|=6\)</span>，即正方体有 6 个面。</li></ol><p>总之关键的步骤都是给定群 <span class="math inline">\(G\)</span>和某个子群 <span class="math inline">\(H\)</span>，求 <span class="math inline">\(G/H\)</span> 的一组陪集代表元。</p><p>这里用到的算法叫做 <a href="https://en.wikipedia.org/wiki/Todd%E2%80%93Coxeter_algorithm">Todd-Coxeter算法</a>。</p><p>Todd-Coxeter算法在许多抽象代数或者群论的教材都有，用到的数学知识并不复杂。但完整描述并证明一份程序实现的细节还是很费功夫的，恐怕要好几页纸才能说清楚。限于篇幅，我这里仅用正方体的情形为例说明算法的步骤，具体的证明和更多的细节读者请参考</p><blockquote><p>Handbook of Computational Group Theory, Holt, D., Eick, B., O’Brien,E.</p></blockquote><p>中的 coset enumeration 一章。我个人认为这是讲解 Todd-Coxeter算法最棒的文献。</p><p>Todd-Coxeter 算法非常类似玩数独游戏，这里要填的表是一个变化的二维数组<span class="math inline">\(T\)</span>，<span class="math inline">\(T\)</span> 的行 <span class="math inline">\(i\)</span> 代表第 <span class="math inline">\(i\)</span> 个右陪集，<span class="math inline">\(T\)</span> 的列 <span class="math inline">\(j\)</span> 代表第 <span class="math inline">\(j\)</span> 个生成元 <span class="math inline">\(\rho_j\)</span>，<span class="math inline">\(T[i][j]\)</span> 的值等于 <span class="math inline">\(\rho_j\)</span> 右乘以第 <span class="math inline">\(i\)</span>个陪集后得到的陪集。初始时，我们知道肯定有一个陪集，就是 <span class="math inline">\(H\)</span>自身，还有没有其它的陪集我们不清楚。算法的主要流程就是根据 <span class="math inline">\(G\)</span> 和 <span class="math inline">\(H\)</span>的表现中包含的关系来发现新的陪集并填入表中，直到无法找到新的陪集为止。最终得到的<span class="math inline">\(T\)</span> 实际上是 <span class="math inline">\(G/H\)</span> 的 schreier 图的邻接矩阵，它记录了<span class="math inline">\(G/H\)</span> 的陪集间的乘法关系，由 <span class="math inline">\(T\)</span> 出发我们很容易求出这些陪集的 word表示。</p><div class="unnumbered statement example definition"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>设 <span class="math inline">\(G\)</span>是正方体的对称群，其表现为 <span class="math display">\[G =\langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span>子群 <span class="math inline">\(H=\langle \rho_1,\rho_2\rangle\)</span> 是初始顶点的稳定化子群，求 <span class="math inline">\(G/H\)</span> 的一组右陪集代表元。</p></div><p>我们先罗列一下这个数独游戏已知的关系：</p><p><strong>已知关系</strong>：</p><ol type="1"><li>对 <span class="math inline">\(H\)</span> 的任何生成字 <span class="math inline">\(w\)</span> 有 <span class="math inline">\(H\cdotw=H\)</span>，即 <span class="math inline">\(H\rho_1=H\rho_2=H\)</span>。注意此关系仅要求对<span class="math inline">\(H\)</span> 成立。</li><li>对任何陪集 <span class="math inline">\(K\)</span> 和 <span class="math inline">\(G\)</span> 的任何生成关系 <span class="math inline">\(r\)</span> 有 <span class="math inline">\(K\cdotr=K\)</span>，即 <span class="math inline">\(K\rho_i^2=K,i=0,1,2\)</span> 以及 <span class="math inline">\(K(\rho_0\rho_1)^4=K(\rho_1\rho_2)^3=K(\rho_0\rho_2)^2=K\)</span>。注意此关系要求对所有陪集成立。</li></ol><p>这些关系可以存储在两个列表里面，每个关系用一个数组表示。</p><p>第一个列表存储的是 <span class="math inline">\(H\)</span>的生成字，即</p><blockquote><p><strong><span class="math inline">\(H\)</span>的生成字列表</strong>：</p><ol start="0" type="1"><li>(1,)</li><li>(2,)</li></ol></blockquote><p>第二个列表存储的是 <span class="math inline">\(G\)</span>的生成关系，即</p><blockquote><p><strong><span class="math inline">\(G\)</span>的生成关系列表</strong>：</p><ol start="2" type="1"><li>(0, 0)</li><li>(1, 1)</li><li>(2, 2)</li><li>(0, 1, 0, 1, 0, 1, 0, 1)</li><li>(1, 2, 1, 2, 1, 2)</li><li>(0, 2, 0, 2)</li></ol></blockquote><p>其中每条关系前面的数字是我们加上的编号以便于称呼。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在非 Coxeter 群的情形还要把每个生成元的逆也作为生成元加入，其在<span class="math inline">\(T\)</span> 中也占据一列，所以实际上 <span class="math inline">\(T\)</span> 的列的个数要 <span class="math inline">\(\times2\)</span>。但是在 Coxeter群的情形每个生成元是 2阶的，其逆元素等于自身，所以不需要额外考虑逆元素。</p></div><p>初始时刻表格 <span class="math inline">\(T\)</span> 是这样的：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>其中 <span class="math inline">\(H_0\)</span> 代表 <span class="math inline">\(H\)</span> 对应的陪集。程序首先验证 <span class="math inline">\(H_0\)</span> 所在的行满足第一个关系列表 （<span class="math inline">\(H\)</span>的生成字列表，随后此列表可以被丢弃），然后依次从上到下扫描 <span class="math inline">\(T\)</span> 的每一行，假设当前扫描的是第 <span class="math inline">\(i\)</span> 行，对应的陪集为 <span class="math inline">\(H_i\)</span>，程序验证确保对第二个列表 （<span class="math inline">\(G\)</span> 的生成关系列表） 中的每条关系 <span class="math inline">\(w\)</span>，<span class="math inline">\(H_i\)</span> 满足 <span class="math inline">\(H_iw=H_i\)</span>，这个过程中可能发现新的陪集，也可能发现已有的某些陪集是重复的，也有可能需要强行定义新的陪集来使得这个验证能够完成。</p><hr><p>我们来开始扫描 <span class="math inline">\(H_0\)</span>所在的行：首先检查第一个列表中的关系，<strong>这个列表仅在扫描 <span class="math inline">\(H_0\)</span>时使用一次，扫描完就可以丢弃</strong>。</p><p>(1). 对第 0 条关系 <span class="math inline">\(H_0\rho_1=H_0\)</span>，即 <span class="math inline">\(T[0][1]=0\)</span>。对第 1 条关系 <span class="math inline">\(H_0\rho_2=H_0\)</span>，即 <span class="math inline">\(T[0][2]=0\)</span>，这时 <span class="math inline">\(T\)</span> 变成了</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><p>第一个列表扫描完毕，接下来扫描第二个列表。</p><p>(2). 对第 2 条关系 <span class="math inline">\(H_0\rho_0^2=H_0\)</span>，由于 <span class="math inline">\(H_0\rho_0\)</span> 还不知道，我们将其定义为新陪集<span class="math inline">\(H_1\)</span> 并将 1 填入 <span class="math inline">\(T[0][0]\)</span> 位置，此外还要为 <span class="math inline">\(H_1\)</span> 开辟新的一行：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>每次定义新陪集时，比如定义 <span class="math inline">\(H_i\rho_j=H_k\)</span>，我们同时自动得到了与之对称的关系<span class="math inline">\(H_k\rho_j=H_i\rho_j^2=H_i\)</span>，因此每次填表时我们都填写一对数字而不是一个，这样可以保证表格<span class="math inline">\(T\)</span> 的 “对称性”。</p></div><p>(3). 第 3 条和第 4 条关系已经满足，继续。</p><p>(4). 第 5 条关系，<span class="math inline">\(H_0\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1=H_0\)</span>，我们已经知道<span class="math inline">\(H_0\rho_0=H_1\)</span> 但是 <span class="math inline">\(H_1\rho_1\)</span> 还不知道，将其定义为 <span class="math inline">\(H_2\)</span>，于是 <span class="math inline">\(T\)</span> 中又添两项，并开辟新的一行给 <span class="math inline">\(H_2\)</span>：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>但是 <span class="math inline">\(H_2\rho_0\)</span>还是不知道，所以继续定义 <span class="math inline">\(H_2\rho_0=H_3\)</span>，于是 <span class="math inline">\(T\)</span> 变成</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>于是现在关系变成了</p><p><span class="math display">\[\underbrace{\overbrace{\underbrace{H_0\rho_0}_{=H_1}\,\rho_1}^{=H_2}\,\rho_0}_{=H_3}\,\rho_1\rho_0\rho_1\rho_0\rho_1=H_0.\]</span></p><p>但是 <span class="math inline">\(H_3\rho_1\)</span>还是不知道，你可能会想把它继续定义为新的陪集 <span class="math inline">\(H_4\)</span>，然后继续扫描。<strong>这样做不是不可以，但是每次都定义新陪集会生成大量重复的陪集，导致<span class="math inline">\(T\)</span>增长的非常快，对更复杂的群非常耗费计算资源</strong>。我们采用更聪明的办法：倒着扫描整个关系，即从右到左扫描<span class="math inline">\(H_0\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1=H_0\)</span>这条关系。记住我们现在已经正向 （从左到右） 扫描到了下面的位置： <span class="math display">\[\underbrace{H_0\rho_0\rho_1\rho_0}_{=H_3}\,\rho_1|\rho_0\rho_1\rho_0\rho_1=H_0.\]</span>反向扫描意味着我们把上式左边末尾的 <span class="math inline">\(\rho_0\rho_1\rho_0\rho_1\)</span>挪到右边去，变形为 <span class="math display">\[\underbrace{H_0\rho_0\rho_1\rho_0}_{=H_3}\,\rho_1=\underbrace{H_0\rho_1}_{=H_0}\rho_0\rho_1\rho_0=H_0\rho_0\rho_1\rho_0=H_3.\]</span> 从而 <span class="math inline">\(H_3\rho_1=H_3\)</span>。这样通过反向扫描我们就推断出了<span class="math inline">\(H_3\rho_1\)</span>的值，避免了定义冗余的陪集。按照 Holt 书中的说法这叫做一个deduction。这时 <span class="math inline">\(T\)</span> 为</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在实际的程序实现中，我们总是从关系的两头同时开始扫描，直到它们相遇为止。</p></div><p>(5). 关系 6 已经满足，继续。</p><p>(6). 对关系 7 <span class="math inline">\(H_0\rho_0\rho_2\rho_0\rho_2=H_0\)</span>，从两头扫描我们得到<span class="math display">\[\underbrace{H_0\rho_0}_{=H_1}\,\rho_2=\underbrace{\overbrace{H_0\rho_2}^{=H_0}\rho_0}_{=H_1}.\]</span>即 <span class="math inline">\(H_1\rho_2=H_1\)</span>，我们又得到了一个deduction，从而 <span class="math inline">\(T\)</span> 变成</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>至此对 <span class="math inline">\(H_0\)</span>的扫描全部完成，我们转入扫描 <span class="math inline">\(H_1\)</span>所在的行。</p><hr><p><strong>注意：从现在起至程序结束，我们不再使用第一个列表</strong>。</p><p>下面开始扫描 <span class="math inline">\(H_1\)</span> 所在的行。</p><p>(1). 经检查关系 2, 3, 4, 5 已经满足，继续。</p><p>(2). 对关系 6 有 <span class="math inline">\(H_1\rho_1\rho_2\rho_1\rho_2\rho_1\rho_2=H_1\)</span>，其中<span class="math inline">\(H_1\rho_1=H_2\)</span> 已知但 <span class="math inline">\(H_2\rho_2\)</span> 未知。反向的扫描也会卡在这里：<span class="math display">\[\underbrace{H_1\rho_1}_{=H_2}\rho_2\rho_1=H_1\rho_2\rho_1\rho_2=H_2\rho_2.\]</span>所以我们定义新陪集 <span class="math inline">\(H_2\rho_2=H_4\)</span>，于是 <span class="math inline">\(H_4\rho_1=H_4\)</span>，从而此时 <span class="math inline">\(T\)</span> 为</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr></tbody></table><p>(3). 关系 7 已经满足，从而 <span class="math inline">\(H_1\)</span>检查完毕，接下来开始扫描 <span class="math inline">\(H_2\)</span>的行。</p><hr><p>下面开始扫描 <span class="math inline">\(H_2\)</span> 的行。</p><p>(1). 经检查关系 2, 3, 4, 5, 6 都已经满足，继续。</p><p>(2). 对关系 7 有 <span class="math inline">\(H_2\rho_0\rho_2\rho_0\rho_2=H_2\)</span>，两边同时扫描的结果为：<span class="math display">\[\underbrace{H_2\rho_0}_{=H_3}\rho_2\rho_0=H_2\rho_2=H_4.\]</span>即 <span class="math inline">\(H_3\rho_2\rho_0=H_4\)</span>，但是继续正向扫描<span class="math inline">\(H_3\rho_2\)</span> 不知道，继续反向扫描<span class="math inline">\(H_4\rho_0\)</span> 不知道。定义新陪集 <span class="math inline">\(H_3\rho_2=H_5\)</span>，于是 <span class="math inline">\(H_5\rho_0=H_4\)</span>，我们又可以填入两对 4个数字，此时 <span class="math inline">\(T\)</span> 为：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">3</td></tr></tbody></table><p><span class="math inline">\(H_2\)</span> 扫描完毕，下面扫描 <span class="math inline">\(H_3\)</span> 的行。</p><hr><p>我把 <span class="math inline">\(H_3, H_4, H_5\)</span>的扫描过程留给你作为练习，<span class="math inline">\(H_3\)</span>扫描结束后你得到的 <span class="math inline">\(T\)</span>应该如下图：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr></tbody></table><p><span class="math inline">\(H_4\)</span> 扫描结束后你得到的 <span class="math inline">\(T\)</span> 应该如下图：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><span class="math inline">\(H_5\)</span> 的扫描给不出新的信息。</p><p>扫描 <span class="math inline">\(H_6\)</span> 时，关系 2, 3, 4, 5, 6都已经满足，由关系 7 <span class="math inline">\(H_6\rho_0\rho_2\rho_0\rho_2=H_6\)</span> 可得deduction <span class="math inline">\(H_7\rho_2=H_7\)</span>，于是 <span class="math inline">\(T\)</span> 可以补全为</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td></tr></tbody></table><p>扫描 <span class="math inline">\(H_7\)</span>发现所有关系都已经满足。</p><p>至此 <span class="math inline">\(T\)</span>的空白位置都已经填满，没有新的陪集可以发现，数独游戏结束，这时得到的<span class="math inline">\(T\)</span> 就是 <span class="math inline">\(G/H\)</span> 的最终乘法表。</p><p>由此利用宽度优先搜索不难得出陪集间的关系为： <span class="math display">\[\begin{array}{l}H_0 = H_0\cdot e,\\H_1=H_0\cdot\rho_0,\\H_2=H_1\cdot\rho_1=H_0\cdot\rho_0\rho_1,\\H_3=H_2\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0,\\H_4=H_2\cdot\rho_2=H_0\cdot\rho_0\rho_1\rho_2,\\H_5=H_3\cdot\rho_2=H_0\cdot \rho_0\rho_1\rho_0\rho_2,\\H_6=H_5\cdot\rho_1=H_0\cdot \rho_0\rho_1\rho_0\rho_2\rho_1,\\H_7=H_6\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0\rho_2\rho_1\rho_0.\end{array}\]</span></p><p>从而其一组陪集代表元可以选为 <span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span></p><p>这正是我们前面看到过的。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个例子看似有点长，但还是一个比较简单的例子，其中并没有出现已知陪集重复的情形（Holt的书中称之为coincidence）。这种情形的处理麻烦一些，因为一旦出现重复的陪集，就有可能顺藤摸瓜找到更多重复的陪集。这时就要立刻暂停扫描，流程跳转到处理coincidence：开辟一个栈来存放已知的coincidence，每次弹出一对，将它们合并，然后把新发现的 coincidence压入栈中。</p></div><h1 id="星状多胞体的计算">星状多胞体的计算</h1><p>星状多胞体也可以使用 Wythoff构造法来生成，但是直接套用上面的方法一般是行不通的，我们需要在生成元中加入额外的生成关系。</p><p>这里以 <a href="https://en.wikipedia.org/wiki/Great_dodecahedron">Greatdodecahedron</a> 为例来说明：其 Coxeter-Dynkin 图为</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/coxeter552.svg" width="200"></p><p>于是三面镜子的法向量夹角分别为 <span class="math inline">\(\pi-2\pi/5, \pi/2,\pi-\pi/5\)</span>。如果我们仍然沿用以前的分析，会得出其对称群的表现为<span class="math display">\[K=\langle\tau_0,\tau_1,\tau_2 \|\  \tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=(\tau_0\tau_2)^2=1\rangle.\]</span></p><p>这是一个无限群，而且顶点的稳定化子的商群也是无限的，所以还想按以前的方法计算就行不通了。</p><p>实际上我们只要在生成关系中再加上一条 <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>即可，即对称群的表现为</p><p><span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>注意到我使用了字母 <span class="math inline">\(\tau\)</span>来表示反射，<span class="math inline">\(K\)</span> 表示 Greatdodecahedron的对称群，这个记号选择是有意的。这是怎么回事呢？先看视频：</p><video src="/images/polytopes/great-dodecahedron.mp4" width="480" controls=""></video><p>由视频可见，Great dodecahedron 与正二十面体 (icosahedron)共用相同的顶点，并且看起来 Great dodecahedron 可以通过在 icosahedron表面挖一些三角形的洞得到。这个结论也可以推广：一般地如果星状多面体的洞是一个有<span class="math inline">\(h\)</span>条边的多边形，则对应的额外生成关系就是 <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^h=1\)</span>。</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/star.png" width="600"></p><p>在上图中，<span class="math inline">\(\Delta ABC\)</span>是正二十面体的基本区域，三个内角分别是 <span class="math inline">\(\angle CAB=\pi/5\)</span>，<span class="math inline">\(\angle CBA=\pi/2\)</span>，<span class="math inline">\(\angle ACB=\pi/3\)</span>，<span class="math inline">\(\rho_0,\rho_1,\rho_2\)</span> 分别是关于弧 <span class="math inline">\(BC, AC, AB\)</span>的反射。正二十面体的对称群的表现为 <span class="math display">\[G =\langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^3=(\rho_1\rho_2)^5=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p>Great dodecahedron 可以这样得到：沿着正二十面体的边从顶点 <span class="math inline">\(Q\)</span> 走到 <span class="math inline">\(A\)</span>，右手边的面是三角形 <span class="math inline">\(\Delta OAQ\)</span>，接下来的第一条边应该是 <span class="math inline">\(AO\)</span>，我们跳过这条边，选择第二条边 <span class="math inline">\(AK\)</span>，到达 <span class="math inline">\(K\)</span> 后继续选择右手边的第二条边，这样绕着<span class="math inline">\(O\)</span> 一圈下来共经过 5条边，它们正好围成 Great dodecahedron的一个面。对正二十面体的其它边也如此操作会得到 Great dodecahedron其它的面。</p><p>像这样对一个多面体，保持它的顶点和边的集合不变，但是每次选择右手边的第<span class="math inline">\(k\)</span>个边走下去绕一圈获得一个面，这样构造新多面体的方法叫做 <strong>Facetting手术</strong>。在我们这个项目中 <span class="math inline">\(k\)</span>总是等于 2。</p><p>我们来导出正二十面体的对称群 <span class="math inline">\(G\)</span>和 Great dodecahedron 的对称群 <span class="math inline">\(K\)</span>之间的关系。</p><p>来看三角形 <span class="math inline">\(\DeltaOAB\)</span>，它的三个内角分别是 <span class="math inline">\(\angleOAB=2\pi/5\)</span>，<span class="math inline">\(\angleOBA=\pi/2\)</span>，<span class="math inline">\(\angleAOB=\pi/5\)</span>，它包含三个与 <span class="math inline">\(\DeltaABC\)</span> 全等的三角形，关于其三条边 <span class="math inline">\(OA,OB,AB\)</span> 的反射分别是 <span class="math inline">\(\tau_1=\rho_1\rho_2\rho_1,\tau_0=\rho_0,\tau_2=\rho_2\)</span><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>。</p><p>Facetting 操作 <span class="math inline">\(\varphi_k\)</span>用群的语言来描述就是（记住 <span class="math inline">\(k=2\)</span>）<span class="math display">\[G=\langle\rho_0,\rho_1,\rho_2\rangle\xrightarrow{\ \varphi_k\}\langle\rho_0,\rho_1(\rho_2\rho_1)^{k-1},\rho_2\rangle=\langle\tau_0,\tau_1,\tau_2\rangle=K.\]</span>一般来说 <span class="math inline">\(K\)</span> 是 <span class="math inline">\(G\)</span> 的子群，但在这里 <span class="math inline">\(G\)</span> 和 <span class="math inline">\(K\)</span> 就是同一个群。我们不解释为什么 <span class="math inline">\(G=K\)</span>，这里只承认这一点，然后借助这个事实来说明<span class="math inline">\(K\)</span> 就是 Great dodecahedron的对称群。</p><p>首先 <span class="math inline">\(\langle \tau_1,\tau_2\rangle=\langle\rho_1,\rho_2\rangle\)</span> 是顶点 <span class="math inline">\(A\)</span> 的稳定化子群，所以 Great dodecahedron和正二十面体的顶点集是一样的。但 <span class="math inline">\(\tau_1\tau_2\)</span> 是一个角度为 144度的旋转，这一点和 <span class="math inline">\(\rho_1\rho_2\)</span>是一个 72 度的旋转不同，所以 Great dodecahedron 的 vertex configure是一个五角星，而不像正二十面体那样是一个五边形。</p><p>其次 <span class="math inline">\(\langle\tau_0,\tau_2\rangle=\langle\rho_0,\rho_2\rangle\)</span>为边 <span class="math inline">\(AQ\)</span> 的稳定化子群，所以 Greatdodecahedron 的边集和正二十面体也是一样的。</p><p>它俩的区别在于边组成面的方式不一样。<span class="math inline">\(\langle\tau_0,\tau_1\rangle\)</span> 是 Greatdodecahedron 面的稳定化子群，注意到 <span class="math inline">\(\tau_1\)</span> 是关于 <span class="math inline">\(AO\)</span> 的反射，它会把 <span class="math inline">\(AQ\)</span> 映射为 <span class="math inline">\(AK\)</span>，这正对应选择第 <span class="math inline">\(k\)</span> 条边的操作。<span class="math inline">\(\tau_0\tau_1\)</span> 是一个绕着顶点 <span class="math inline">\(O\)</span> 的角度为 <span class="math inline">\(2\pi/5\)</span> 的旋转，所以 <span class="math inline">\(AQ\)</span> 在子群 <span class="math inline">\(\langle \tau_0,\tau_1\rangle\)</span> 作用下会绕<span class="math inline">\(O\)</span> 转一圈，正对应 Facetting操作得到的一个面。</p><p>我们来找出 <span class="math inline">\(\tau_0,\tau_1,\tau_2\)</span>之间隐藏的一条生成关系：</p><p>注意到 <span class="math inline">\(\tau_1\tau_2\tau_1=\tau_1\rho_2\tau_1\)</span>是关于 <span class="math inline">\(AP\)</span> 的反射，它和 <span class="math inline">\(\tau_0=\rho_0\)</span> 的复合是绕着 <span class="math inline">\(P\)</span> 点角度为 <span class="math inline">\(2\pi/3\)</span> 的旋转，所以 <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>。加入这个额外的生成关系得到的就是<span class="math inline">\(K\)</span> 的正确的表现： <span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>所以我们就可以对 <span class="math inline">\(K\)</span>照搬之前的绘制步骤了。</p><p>这个额外的生成关系其实也有背后的解释：对 Faceting手术得到的新多面体再进行一次 Faceting 手术是可以回到原来的多面体的。对great dodecahedron每次沿着它的边，选择当前离开的边的右手第二个边走下去，即从 <span class="math inline">\(Q\)</span> 走到 <span class="math inline">\(A\)</span> 时，不是选择 <span class="math inline">\(AK\)</span> 继续走下去，而是选择 <span class="math inline">\(AO\)</span>，这样走下去又会得到正二十面体的三角形的面，这对应的就是额外的生成关系中的指数3。</p><p>这一点从群上也可以得到验证。</p><p><span class="math display">\[K=\langle\tau_0,\tau_1,\tau_2\rangle\xrightarrow{\ \varphi_2\}\langle\tau_0,\tau_1\tau_2\tau_1,\tau_2\rangle=\langle\rho_0,\rho_2\rho_1\rho_2,\rho_2\rangle=G.\]</span></p><blockquote><p>关于 Faceting 手术可以在 McMullen 和 Schulte 所著的 <a href="https://doi.org/10.1017/CBO9780511546686">Abstract RegularPolytopes</a> 一书中找到。</p></blockquote><h1 id="snub-cube-的计算">Snub cube 的计算</h1><p>如果你理解了上面的内容，snub 多面体的情形也是不难理解的。我以 snubcube 来说明：</p><p>Snub cube 和 cube 的区别在于它的对称群只包含旋转，我们已经看到 cube的对称群 <span class="math inline">\(G\)</span> 的表现为 <span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span>它有 48 个元素，其中 24 个是旋转。这些旋转可以由 <span class="math inline">\(r_0=\rho_0\rho_1,r_1=\rho_1\rho_2,r_2=\rho_0\rho_2\)</span> 生成 （由于 <span class="math inline">\(r_0r_1=r_2\)</span> 因此实际上可以由 <span class="math inline">\(r_0\)</span> 和 <span class="math inline">\(r_1\)</span> 生成）。这 24 个旋转就构成了 Snubcube 的对称群 <span class="math inline">\(\widetilde{G}\)</span>。</p><p>不难写出 <span class="math inline">\(\widetilde{G}\)</span> 的表现为<span class="math display">\[\widetilde{G}=\langle r_0,r_1\ |\r_0^4=r_1^3=(r_0r_1)^2=1\rangle.\]</span></p><p>利用 Todd-Coxeter 算法不难求出这个群的所有 24 个元素：</p><p><span class="math display">\[\begin{array}{lll}e&amp;r_{0}&amp;r_{0}r_{0}\\r_{0}r_{0}r_{0}&amp;r_{1}&amp;r_{1}r_{1}\\r_{0}r_{1}&amp;r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{1}\\r_{0}r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}\\r_{1}r_{0}r_{0}&amp;r_{1}r_{0}r_{0}r_{0}&amp;r_{1}r_{1}r_{0}\\r_{1}r_{1}r_{0}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}\\r_{0}r_{0}r_{1}r_{1}r_{0}&amp;r_{1}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}r_{0}r_{1}r_{1}\\r_{1}r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{1}r_{0}r_{0}r_{1}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}r_{1}\end{array}\]</span></p><p>注意在 snub 的情形初始顶点 <span class="math inline">\(v_0\)</span>不属于任何镜面，所以其稳定化子群只有单位元 1，即每个 <span class="math inline">\(g\in\widetilde{G}\)</span> 把 <span class="math inline">\(v_0\)</span> 变换为不同的顶点。将它们作用在 <span class="math inline">\(v_0\)</span> 上即得 snub cube 的所有顶点。</p><p>我们现在利用轨道—稳定化子的理论来求 snub cube 的边。snub cube的边也是分类型的，每个 <span class="math inline">\(r_i(i=0,1,2)\)</span>作用在 <span class="math inline">\(v_0\)</span> 上可得一个类型为 <span class="math inline">\(i\)</span> 的边 <span class="math inline">\(e_i=(v_0, v_0\cdot r_i)\)</span> <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>，我们来定出 <span class="math inline">\(e_i\)</span> 的稳定化子群 <span class="math inline">\(H\)</span>。</p><p>首先注意到任何 <span class="math inline">\(g\in G\)</span> 如果保持<span class="math inline">\(e_i\)</span>不变，则只有两种可能，要么它保持 <span class="math inline">\(e_i\)</span> 上每个点不变，要么它将 <span class="math inline">\(e_i\)</span> 关于其中点进行翻转。这一点对 <span class="math inline">\(g\in\widetilde{G}\)</span> 自然也成立。所以若<span class="math inline">\(g\in\widetilde{G}\)</span> 保持 <span class="math inline">\(e_i\)</span> 不变，则要么 <span class="math inline">\(v_0g = v_0, v_0r_i=v_0r_ig\)</span>，要么 <span class="math inline">\(v_0g = v_0r_i,v_0r_ig=v_0\)</span>。前一种情形说明<span class="math inline">\(g\)</span> 属于 <span class="math inline">\(v_0\)</span>的稳定化子群从而只能是单位元；后一种情形说明 <span class="math inline">\(r_ig\)</span> 和 <span class="math inline">\(r_ig^{-1}\)</span> 都属于 <span class="math inline">\(v_0\)</span> 的稳定化子群从而 <span class="math inline">\(r_ig=r_ig^{-1}=1\)</span>，即 <span class="math inline">\(g=r_i\)</span> 且 <span class="math inline">\(r_i^2=1\)</span>。总之我们证明了只有在 <span class="math inline">\(r_i^2=1\)</span> 时 <span class="math inline">\(e_i\)</span>才有非平凡的稳定化子群，这时稳定化子群是二阶循环群 <span class="math inline">\(\langle r_i\rangle\)</span>。</p><p>于是 snub cube 的类型为 <span class="math inline">\(r_0\)</span> 和<span class="math inline">\(r_1\)</span> 的边的个数都是 24/1=24个；类型为 <span class="math inline">\(r_2\)</span> 的边的个数为 24/2=12个，从而 snub cube 总共有 24+24+12=60 条边。</p><p>snub cube 的面可以这样求：由于 <span class="math inline">\(r_0^4=1\)</span> 所以 <span class="math inline">\(r_0\)</span> 可以生成一个正四边形的面，类似地由于<span class="math inline">\(r_1^3=1\)</span> 所以 <span class="math inline">\(r_1\)</span> 可以生成一个正三角形的面，而由于<span class="math inline">\(r_2^2=1\)</span> 所以 <span class="math inline">\(r_2\)</span>生成的面是退化的。这种由单个旋转生成的面的稳定化子群是很好求的：若 <span class="math inline">\(g\)</span> 保持 <span class="math inline">\(r_i\)</span> 生成的面不变，则其必然把某个形如<span class="math inline">\(v_0r_i^k\)</span> 的顶点变换为 <span class="math inline">\(v_0\)</span>，即 <span class="math inline">\(g=r_i^{-k}\)</span> 是 <span class="math inline">\(r_i\)</span> 的某次幂，反之易见 <span class="math inline">\(r_i\)</span>的任何幂都保持此面不变，所以其稳定化子群即为循环群 <span class="math inline">\(\langle r_i\rangle\)</span>。</p><p>于是 <span class="math inline">\(r_0\)</span> 生成的面的个数为24/4=6，<span class="math inline">\(r_1\)</span> 生成的面的个数为24/3=8，<span class="math inline">\(r_2\)</span>生成的面都退化因而个数是 0，总计 14 个面。</p><p>小心！我们还漏掉了一种三角面，它源自 <span class="math inline">\(r_0r_1=r_2\)</span> 这个关系。考虑 <span class="math inline">\(\{v_0, v_0r_1, v_0r_2\}\)</span>这三个顶点，这三个顶点中 <span class="math inline">\((v_0,v_0r_1)\)</span> 构成一条类型为 <span class="math inline">\(r_1\)</span> 的边， <span class="math inline">\((v_0,v_0r_2)\)</span> 构成一条类型为 <span class="math inline">\(r_2\)</span> 的边，而 <span class="math inline">\(r_0r_1=r_2\)</span> 这个关系告诉我们 <span class="math display">\[(v_0, v_0r_0)\xrightarrow{\ r_1\ }(v_0r_1,v_0r_0r_1) = (v_0r_1, v_0r_2).\]</span> 即 <span class="math inline">\((v_0r_1, v_0r_2)\)</span> 是一条类型为 <span class="math inline">\(r_0\)</span> 的边，它是由将 <span class="math inline">\(r_1\)</span> 作用在类型为 <span class="math inline">\(r_0\)</span> 的初始边 <span class="math inline">\((v_0, v_0r_0)\)</span> 上得到的，于是 <span class="math inline">\(\{v_0, v_0r_1, v_0r_2\}\)</span>构成一个三角形的三个顶点，其三条边在对称群作用下属于不同的轨道，所以这个三角形的稳定化子必然保持每条边不变，从而只能是恒等元，从而这样的面有24/1=24 个。</p><p>于是 snub cube 一共有 14+24=38 个不同的面。</p><p>这里介绍的方法也适用于其它的 snub 多面体以及 snub 24-cell。</p><h1 id="多面体的顶点投影到-coxeter-平面">多面体的顶点投影到 Coxeter平面</h1><p>项目中还实现了一个<code>draw_on_coxeter_plane(*args, **kwargs)</code>方法，用于绘制将多面体的顶点投影到其 Coxeter平面上后得到的图案，例如下图显示的是将 600-cell 的 120 个顶点投影到其Coxeter 平面上的结果：</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/600-cell.svg" width="350"></p><p>你可以和 <a href="https://en.wikipedia.org/wiki/600-cell#2D_projections">wikipedia上的效果</a> 比较一下。</p><h1 id="附录手算-todd-coxeter">附录：手算 Todd-Coxeter</h1><p>对简单的群，Todd-Coxeter 算法完全可以用手算快速得出结果。我非常推荐Borcherds 的视频，他的演示非常精彩：</p><iframe width="560" height="315" src="https://www.youtube.com/embed/BHezLvEH1DU?si=fw7X2z37wZEYcIG-" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe><p>仿照 Borcherds 的方法，前面正方形的例子可以很快写出来：</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/todd-coxeter.svg" width="600"></p><p>我来解释一下步骤：我们将画出一个有限图，图的每个顶点代表 <span class="math inline">\(H=\langle s_0,s_1\rangle\)</span>的一个陪集，每个顶点有三条不同颜色的边，表示此陪集在生成元 <span class="math inline">\(s_i\)</span> 作用下的结果。</p><ol type="1"><li>首先我们在空白纸上画出第一个顶点，它对应的陪集是 <span class="math inline">\(H=H_0\)</span> 自身。<span class="math inline">\(H\)</span> 包含 <span class="math inline">\(s_0,s_1\)</span>，所以红、绿边是自边。<span class="math inline">\(s_2\)</span>，即蓝色的边，会把它映射为一个新顶点<span class="math inline">\(H_1\)</span>。</li><li>从 <span class="math inline">\(H_0\)</span>出发，利用红蓝交换，可得红色保持 <span class="math inline">\(H_1\)</span> 不动。但是绿蓝不交换，所以绿色将<span class="math inline">\(H_1\)</span> 映射为新顶点 <span class="math inline">\(H_2\)</span>。</li><li><span class="math inline">\((\text{绿蓝})^3=1\)</span>，即 <span class="math inline">\(H_2\xrightarrow{(\text{绿蓝})^3}H_2\)</span>，所以<span class="math display">\[H_2\xrightarrow{\text{绿}}H_1\xrightarrow{\text{蓝}} H_0\xrightarrow{\text{绿}}H_0\xrightarrow{\text{蓝}} H_1\xrightarrow{\text{绿}}H_2\xrightarrow{\text{蓝}} H_2.\]</span> 所以蓝色保持 <span class="math inline">\(H_2\)</span> 不动。红绿不交换，所以红色将 <span class="math inline">\(H_2\)</span> 映射为新顶点 <span class="math inline">\(H_3\)</span>。</li><li>仿照上面的分析继续下去，可以发现到 <span class="math inline">\(H_5\)</span> 时，三种颜色的边不会给出新顶点。所以<span class="math inline">\(\{H_0,\ldots,H_5\}\)</span> 就是 <span class="math inline">\(G/H\)</span> 的全部陪集。</li></ol><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>你可能要问了，你怎么就敢肯定这个群的表现恰好就包含这些生成关系，而不会包含其它什么隐藏的生成关系呢？这是个好问题，回答起来并不容易，答案是对凸的多胞体而言这些生成关系确实给出了其对称群的一个表现，但是对星状多面体而言则未必。事实上星状多面体都和某个凸多面体有相同的对称群，但是群表现是不一样的（需要补上额外的生成关系）。这其中的根本原因是凸多面体的镜面法向量之间的夹角都形如<span class="math inline">\(\pi-\pi/m\)</span>，这里 <span class="math inline">\(m\)</span>是整数，这保证了所有镜面围成的凸锥构成一个基本区域。而星状多面体的镜面所夹的二面角至少有一个形如<span class="math inline">\(\pi-\pi/p\)</span>，其中 <span class="math inline">\(p\)</span>是一个非整数的有理数，这时所有镜面围成的凸锥并不是基本区域，在对称群的作用下这个凸锥会被覆盖若干次。见Vinberg 的文章 “Discrete linear groups generated by reflections” 和Coxeter 的著作 “The beauty of geometry: twelve essays”.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>以本文介绍的知识，这里似乎应该说 <span class="math inline">\(H\)</span> 保持 <span class="math inline">\(v_0\)</span> 不变，从而 <span class="math inline">\(v_0\)</span> 的稳定化子群包含 <span class="math inline">\(H\)</span>，怎么能断言 <span class="math inline">\(v_0\)</span> 的稳定化子群就等于 <span class="math inline">\(H\)</span> 呢？这实际上是 Coxeter 群的一个性质：在Coxeter 群 <span class="math inline">\(W\)</span>的标准几何实现中，对其基本区域闭包中的任何一点 <span class="math inline">\(v\)</span>，<span class="math inline">\(v\)</span>的稳定化子群是一个标准椭圆子群，其生成元恰好由超平面包含 <span class="math inline">\(v\)</span> 的那些单反射组成。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p>道理与注解 2 类似。易见边 <span class="math inline">\(e\)</span> 的稳定化子群 <span class="math inline">\(H\)</span> 就是 <span class="math inline">\(e\)</span>的中点的稳定化子群，这也是一个标准椭圆子群，由那些包含 <span class="math inline">\(e\)</span>的中点的镜面对应的单反射生成。这样的镜面只能是 <span class="math inline">\(\rho_i\)</span> 和那些与 <span class="math inline">\(m_i\)</span> 垂直且包含 <span class="math inline">\(v_0\)</span> 的镜面。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>解释与注解 2, 3 类似。<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p>有这么一个结论：如果 <span class="math inline">\(s_\alpha\)</span> 是关于镜面 <span class="math inline">\(\alpha\)</span> 的反射，镜面 <span class="math inline">\(\beta=g\alpha\)</span>，这里 <span class="math inline">\(g\)</span> 是空间中的可逆线性变换，则关于 <span class="math inline">\(\beta\)</span> 的反射 <span class="math inline">\(s_\beta=gs_\alpha g^{-1}\)</span>。令 <span class="math inline">\(\alpha=AB\)</span>，<span class="math inline">\(g=\rho_1\)</span>，<span class="math inline">\(\beta=AD\)</span> 即为结论。<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p>注意本文没有解释为什么这些边确实是不同类型的，即它们在对称群的作用下处于不同的轨道。严格说明这一点也要用到Coxeter 群的几何实现。<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Möbius 变换的分类与上半双曲空间的等距</title>
      <link href="mobius-h3space/"/>
      <url>mobius-h3space/</url>
      
        <content type="html"><![CDATA[<p>本文的想法源自 Roice Nelson 的 <a href="https://www.shadertoy.com/view/MstcWr">shadertoy项目</a>，我觉得他的创意很棒，就是效果有点糙，于是 <a href="https://www.shadertoy.com/view/4scfR2">动手改进了一番</a>。乍一看，这个动画的场景很简单，其实它背后的数学并不平凡。</p><p>这个动画从三个角度了演示 Möbius 变换，这三个角度是密切相关的：</p><ol type="1"><li>Möbius 变换作为扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 到自身的全纯函数。</li><li>Möbius 变换作为 Riemann 球面 <span class="math inline">\(S^2\)</span> 到自身的全纯函数。</li><li>Möbius 变换作为上半双曲空间中的等距变换。</li></ol><p>本文只作概括性的介绍，并不展开详细的数学证明。读者可以参考下面的资料：</p><blockquote><ol type="1"><li><a href="https://en.wikipedia.org/wiki/M%C3%B6bius_transformation">维基百科</a>.</li><li><span class="citation" data-cites="Needham1997">Needham (<a href="#ref-Needham1997" role="doc-biblioref">1997</a>)</span> .</li><li><span class="citation" data-cites="indra">Mumford, Series, andWright (<a href="#ref-indra" role="doc-biblioref">2002</a>)</span>,chapter 3.</li><li><span class="citation" data-cites="palka1991">Palka (<a href="#ref-palka1991" role="doc-biblioref">1991</a>)</span>, chapter IX,section 2.</li></ol></blockquote><p>本文的动画应该可以帮助你更好地理解这些资料中的内容。</p><span id="more"></span><h1 id="预备知识之正交圆族">预备知识之正交圆族</h1><p>设 <span class="math inline">\(z_1,z_2\)</span>是复平面上的两点，我们考虑两个不同的圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span>：</p><ol type="1"><li><span class="math inline">\(\mathcal{C}_1\)</span> 由所有同时过<span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 的圆组成（包含过 <span class="math inline">\(z_1,z_2\)</span> 的直线）。</li><li><span class="math inline">\(\mathcal{C}_2\)</span> 由所有使得 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 关于 <span class="math inline">\(C\)</span> 互为反演点的圆 <span class="math inline">\(C\)</span> 组成（包含线段 <span class="math inline">\([z_1,z_2]\)</span> 的垂直平分线）。</li></ol><p>则圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 中的任何圆<span class="math inline">\(C_1\)</span> 与 <span class="math inline">\(\mathcal{C}_2\)</span> 中的任何圆 <span class="math inline">\(C_2\)</span> 正交（交点处的切线互相垂直）。</p><p>我们将考察当 <span class="math inline">\(z_1,z_2\)</span> 是一个Möbius 变换 <span class="math inline">\(M\)</span> 的两个不动点时，<span class="math inline">\(M\)</span> 作用在 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span> 上的效果。</p><h1 id="möbius-变换的共轭分类">Möbius 变换的共轭分类</h1><p>一个 Möbius 变换 <span class="math inline">\(M\)</span>是一个分式线性变换，它将扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 一对一地映射为自身：<span class="math display">\[M(z) = \frac{az+b}{cz+d},\quada,b,c,d\in\mathbb{C},ad-bc\ne0, z\in \hat{\mathbb{C}}.\]</span> 所有的Möbius 变换构成一个群 <span class="math inline">\({\rmPSL}_2(\mathbb{C})\)</span>。</p><p>我们称两个 Möbius 变换 <span class="math inline">\(M_1,M_2\)</span>是共轭的，当且仅当存在 <span class="math inline">\(g\in{\rmPSL}_2(\mathbb{C})\)</span> 使得 <span class="math display">\[M_1=gM_2g^{-1}.\]</span></p><p>可以证明，在共轭的意义下，任何非恒等元的 Möbius变换都属于下面四种类型之一：</p><ol type="1"><li><span class="math inline">\(M\)</span> 称作是抛物型的(parabolic)，如果它共轭于平移：<span class="math inline">\(z\toz+1\)</span>。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上仅有一个不动点。</li><li><span class="math inline">\(M\)</span> 称作是椭圆型的(elliptic)，如果它共轭于旋转：<span class="math inline">\(z\toe^{i\theta}z\)</span>，其中 <span class="math inline">\(\theta\in\mathbb{R}\)</span> 且 <span class="math inline">\(\theta\ne0\)</span>。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li><li><span class="math inline">\(M\)</span> 称作是双曲型的(hyperbolic)，如果它共轭于缩放：<span class="math inline">\(z\to\lambdaz\)</span>，其中 <span class="math inline">\(\lambda&gt;0\)</span>是实数且不为 1。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li><li><span class="math inline">\(M\)</span> 称作是斜航型的(loxodromic)，如果它共轭于一个缩放和一个旋转的复合：<span class="math inline">\(z\to cz\)</span>，其中 <span class="math inline">\(c\in\mathbb{C}\setminus \mathbb{R}\)</span>。这时<span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li></ol><p>我们把形如 <span class="math inline">\(z\to z+a\)</span> 和 <span class="math inline">\(z\to\lambda z\)</span>的变换称作<strong>特殊位置</strong>的变换，前者是抛物型的，以 <span class="math inline">\(\infty\)</span>为唯一不动点，后者包含了所有非抛物型的变换，它的两个不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>。这两种 Möbius变换具有简单的表现形式，并且它们在两个圆族上的作用也很容易分析，所以在研究每种类型的变换时，我们都先考虑这种简单的形式，然后再通过取共轭扩展到一般的情形。</p><h2 id="抛物型">1. 抛物型</h2><p>我们先考察最简单的抛物型变换 <span class="math inline">\(z\toz+1\)</span>。</p><p>这时唯一的不动点是 <span class="math inline">\(\infty\)</span>，<span class="math inline">\(\mathcal{C}_1\)</span> 是直线族 <span class="math inline">\(\{y=k\mid k\in\mathbb{R}\}\)</span>，<span class="math inline">\(\mathcal{C}_2\)</span> 是直线族 <span class="math inline">\(\{x=l\mid l\in\mathbb{R}\}\)</span>。<span class="math inline">\(M\)</span> 保持 <span class="math inline">\(\mathcal{C}_1\)</span> 中的每条直线不变，把 <span class="math inline">\(\mathcal{C}_2\)</span>中的每条直线变成同族中的另一条直线：</p><object data="/images/mobius/parabolic-plane.svg"></object><p>由动画可见所有点都向着不动点 <span class="math inline">\(\infty\)</span> 的方向“前进”。</p><p>对一般的抛物型变换 <span class="math inline">\(M\)</span> 且 <span class="math inline">\(M\)</span> 的唯一不动点 <span class="math inline">\(z_0\)</span> 有限的情形，结论仍然类似：圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 中的圆都在 <span class="math inline">\(z_0\)</span> 处相切且共用同一条切线 <span class="math inline">\(\ell_1\)</span>，圆族 <span class="math inline">\(\mathcal{C}_2\)</span> 也都在 <span class="math inline">\(z_0\)</span> 处相切且共用同一条切线 <span class="math inline">\(\ell_2\)</span>，<span class="math inline">\(\ell_1\)</span> 和 <span class="math inline">\(\ell_2\)</span> 互相垂直：</p><object data="/images/mobius/parabolic-plane2.svg"></object><p>由动画可见左右两侧的圆在旋转，但是圆本身保持不变，它们是圆族 <span class="math inline">\(\mathcal{C}_1\)</span>；上下两侧的圆在“扩散”，它们是圆族<span class="math inline">\(\mathcal{C}_2\)</span>。可以证明对任何 <span class="math inline">\(z\in\mathbb{C}\)</span> 都有 <span class="math inline">\(\lim\limits_{n\to\infty}M^n(z)=z_0\)</span>，即任何点在<span class="math inline">\(M\)</span> 反复作用下的轨迹都朝着 <span class="math inline">\(z_0\)</span> 的位置移动。</p><p>在 <a href="http://klein.math.okstate.edu/IndrasPearls/">Indra’spearls</a> 一书中，把 <span class="math inline">\(\mathcal{C}_1\)</span>和 <span class="math inline">\(\mathcal{C_2}\)</span>形象地比喻为两组“扇贝壳”：</p><p><img style="margin:0px auto;display:block" width="200" src="/images/mobius/seashell.jpeg"></p><h2 id="椭圆型">2. 椭圆型</h2><p>我们先考察最简单的椭圆型变换 <span class="math inline">\(z\toe^{i\theta}z\)</span>。</p><p>这时两个不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>。圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 由所有过 <span class="math inline">\(0\)</span> 的直线组成，<span class="math inline">\(\mathcal{C}_2\)</span> 由所有以 <span class="math inline">\(0\)</span> 为中心的同心圆组成。<span class="math inline">\(M\)</span> 是个旋转，所以会把 <span class="math inline">\(\mathcal{C}_1\)</span>中的直线变成同族的另一条直线，同时保持 <span class="math inline">\(\mathcal{C}_2\)</span> 中的每个圆不变：</p><object data="/images/mobius/elliptic-plane.svg"></object><p>对两个不动点 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 都有限的情形，结论同样成立，<span class="math inline">\(M\)</span> 保持 <span class="math inline">\(\mathcal{C}_2\)</span> 中的每个圆不变，把 <span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆变为同族中的另一个圆：</p><object data="/images/mobius/elliptic-plane2.svg"></object><h2 id="双曲型">3. 双曲型</h2><p>与椭圆变换 <span class="math inline">\(z\to e^{i\theta}z\)</span>的情形类似，<span class="math inline">\(z\to\lambda z\)</span> 也以<span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span> 为不动点，但是圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span> 的运动方式发生了互换：这次<span class="math inline">\(\mathcal{C}_1\)</span>中的每条直线在放缩下保持不变，<span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆在放缩下变成同族的另一个圆：</p><object data="/images/mobius/hyperbolic-plane.svg"></object><p>对两个不动点 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 都有限的双曲变换，结论仍然成立，圆族<span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆保持不变，<span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆被变成同族的另一个：</p><object data="/images/mobius/hyperbolic-plane2.svg"></object><p>这时在 <span class="math inline">\(M\)</span> 的作用下 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span>一个是“源点”，另一个是“汇点”，轨迹从源点源源不竭地发出，汇聚到汇点中。</p><h2 id="斜航型">4. 斜航型</h2><p>仍然先看 <span class="math inline">\(z\to cz\)</span> 的情形。</p><p>这时不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>，<span class="math inline">\(M\)</span> 把圆族 <span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆变为同族中的另一个圆，同样地也把圆族 <span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆变为同族中的另一个圆，<strong>所以斜航型的变换没有不变圆</strong>：</p><object data="/images/mobius/loxodromic-plane.svg"></object><p>这时平面上一点 <span class="math inline">\(z\)</span> 在 <span class="math inline">\(M\)</span>的反复作用下的轨迹是一条形如“旋臂”的曲线，方程为 <span class="math inline">\(\gamma(t)=c^tz\)</span>，这是一条对数螺线(spiral)，其与 <span class="math inline">\(\mathcal{C}_1\)</span> 和<span class="math inline">\(\mathcal{C}_2\)</span> 的夹角都是常数。</p><p>这个结论对一般的斜航型变换也成立：</p><object data="/images/mobius/loxodromic-plane2.svg"></object><p>由于斜航型变换包含双曲变换作为组成成分，因此看起来它也有一个源点和一个汇点。这时任意一点<span class="math inline">\(z\)</span> 在 <span class="math inline">\(M\)</span> 的反复作用下的轨迹是一条双螺线 (doublespiral)，其与 <span class="math inline">\(\mathcal{C}_1\)</span> 和<span class="math inline">\(\mathcal{C}_2\)</span> 的夹角仍然都是常数（Möbius 变换是保角的）。</p><p>判断 Möbius 变换 <span class="math inline">\(M\)</span>具体属于哪一类可以根据其迹的平方 <span class="math inline">\(\mu=(a+d)^2\)</span> 来判断（当然，需要把 <span class="math inline">\(M\)</span> 归一化使得 <span class="math inline">\(ad-bc=1\)</span>）：</p><ol type="1"><li><span class="math inline">\(M\)</span> 是抛物型的当且仅当 <span class="math inline">\(\mu=4\)</span>。</li><li><span class="math inline">\(M\)</span> 是椭圆型的当且仅当 <span class="math inline">\(0\leq\mu&lt;4\)</span>。</li><li><span class="math inline">\(M\)</span> 是双曲型的当且仅当 <span class="math inline">\(\mu&gt;4\)</span>。</li><li><span class="math inline">\(M\)</span> 是斜航型的当且仅当 <span class="math inline">\(\mu&lt;0\)</span> 或者 <span class="math inline">\(\mu\notin\mathbb{R}\)</span>。</li></ol><h2 id="斜航-loxodromic-是什么意思">斜航 (loxodromic) 是什么意思？</h2><p>斜航这个词听起来好像和船的航行有关，怎么就用来给 Möbius变换分类了呢？这里面肯定有故事，值得扒一扒。</p><p>斜航线 (loxodrome)指的是地球上的一条航行路径，其在每个点处的切线与过该点的经线的夹角为定值。比如说，如果船始终朝着东北方向30 度行驶，走过的轨迹就是一条斜航线。Loxodrome 最初是一个希腊词，loxos的意思是 oblique，即倾斜的，dromos 意为bearing，方位的意思，后来拉丁化以后成为现在的样子。葡萄牙数学家 PedroNunes (1492-1577)第一个认识到斜航线并非两点之间最短路径，而且它无限接近但永不可能到达极点。</p><p><img style="margin:0px auto;display:block" width="300" src="/images/mobius/loxodrome.png"></p><p>在大航海的时代，没有卫星导航，只能靠罗盘或者星座来标识船的航向，而星座的方法在遇到恶劣天气的时候又不能使用，只有罗盘是最可靠的方法。理论上地球表面两点之间的最短路径是过球心的大圆，但罗盘只能定出经线的方向（原理是地球的磁极和南北极近似重合），这二者的夹角不是固定的，要保持沿着大圆的弧走就必须不停调整船的航向，但现实中的船不可能一直有人守在船舵处调整方向，一般是事先定好航向以后接下来的若干天都沿着这个方向走，所以在一定路程内船实际上走的是斜航线。</p><p>荷兰地图学家墨卡托 (Mercator) 据此于 1569年提出了墨卡托地图，将地球投影至墨卡托地图是一个保角变换，即曲线的夹角保持不变。不仅如此，球面上的斜航线在墨卡托地图中成为一条直线：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/mobius/mercator.jpg"></p><p>所以要从地球上的 <span class="math inline">\(A\)</span> 点航向到<span class="math inline">\(B\)</span>点，只要找到它们在墨卡托地图上的对应点 <span class="math inline">\(A',B'\)</span>，算出地图上的直线 <span class="math inline">\(A'B'\)</span> 与经线的夹角 <span class="math inline">\(\theta\)</span>，航行时只要让罗盘与经线一直保持角度为<span class="math inline">\(\theta\)</span> 就可以按照斜航线从 <span class="math inline">\(A\)</span> 航行到 <span class="math inline">\(B\)</span>了。这个路径虽不是最短，但是好在不容易迷失航向。</p><p>那这和 Möbius 变换有什么关系呢？</p><h1 id="möbius-变换作用在-riemann-球面上">Möbius 变换作用在 Riemann球面上</h1><p>由于 Möbius 变换都是扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 到 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 的自同构，而 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 在球极投影下等同于Riemann 球面 <span class="math inline">\(S^2\)</span>，所以 Möbius变换也都是 Riemann 球面的自同构。我们来看看 Möbius 变换作用在 Riemann球面上是什么样子的。</p><p>这是一个作用在 Riemann 球上的斜航型变换：</p><object data="/images/mobius/loxodromic-sphere.svg"></object><p>我来解释一下这个动画的含义：从动画可见 Riemann球面上有一对源点和汇点，这对源点和汇点可以理解为球面的“北极”和“南极”，它们在球极投影下对应于<span class="math inline">\(M\)</span>在扩充复平面上的两个不动点。当这两个不动点分别是原点和无穷远点时，这两个极点就是通常意义下的北极和南极。这时球面上的“经线”是所有过两个极点的大圆，在球极投影下它们对应于同时过两个不动点的圆族<span class="math inline">\(\mathcal{C}_1\)</span>；球面上的纬线是所有与经线正交的圆，在球极投影下它们对应于反演圆族<span class="math inline">\(\mathcal{C}_2\)</span>，球面上每个点的轨迹是对数螺线轨迹在逆球极投影下在球面上的对应曲线，这条曲线与经线纬线的夹角都是常数（因为球极投影是保角的），从而是一条斜航线！</p><div class="unnumbered statement exercise-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">练习</span>：</span><span class="statement-spah"> </span>解释下面这个动画的含义：</p><object data="/images/mobius/parabolic-sphere.svg"></object></div><p>提示：这个动画有两种解释，它既可以看作是一个抛物型变换在 Riemann球面上作用的效果，也可以看作是一个上半双曲空间中的 horosphere在抛物型变换下作用的效果。horosphere 是指上半双曲空间中与无穷远平面<span class="math inline">\(z=0\)</span>相切的球，其半径为无穷大。Möbius变换在上半双曲空间上的作用见下一节。</p><h1 id="möbius-变换作为上半双曲空间的等距">Möbius变换作为上半双曲空间的等距</h1><p>上半双曲空间 <span class="math inline">\(\mathbb{H}_3\)</span>的定义为 <span class="math display">\[\mathbb{H}_3 =\{(x,y,t)\in\mathbb{R}^3\ |\ t&gt;0\}.\]</span>这个空间中的度量是双曲度量：</p><p><span class="math display">\[\mathrm{d}s=\frac{(\mathrm{d}x)^2+(\mathrm{d}y)^2+(\mathrm{d}t)^2}{t}.\]</span></p><p>注意 <span class="math inline">\(xy\)</span> 平面，即复平面不属于<span class="math inline">\(\mathbb{H}_3\)</span>，它是 <span class="math inline">\(\mathbb{H}_3\)</span> 的无穷远边界，<span class="math inline">\(\mathbb{H}_3\)</span> 中任何一点到 <span class="math inline">\(xy\)</span> 平面的距离是无穷大。</p><p>一个复分析教材中不太常讲到的事实是：<strong>任何 Möbius变换都可以唯一地扩展为 <span class="math inline">\(\mathbb{H}_3\)</span>的一个等距变换 <span class="math inline">\(\overline{M}\)</span></strong>，此即所谓的Poincaré Extension。这个扩展用四元数来描述的话很简单：设 <span class="math display">\[M: z\to\frac{az+b}{cz+d},\quad ad-bc=1.\]</span>是任一 Möbius 变换。注意我们这里要求 <span class="math inline">\(ad-bc\)</span> 的值是1，其实任何非零实数都可以。这是可以做到的，因为给 Möbius 变换中的 <span class="math inline">\(a,b,c,d\)</span>同时乘以一个非零复数并不改变这个变换，所以同时乘以 <span class="math inline">\(1/\sqrt{ad-bc}\)</span> 就可以使得 <span class="math inline">\(ad-bc=1\)</span>。</p><p>对 <span class="math inline">\(p=(x,y,t)\in\mathbb{H}^3\)</span>，令<span class="math inline">\(q=x+yi+tj\)</span> 为与 <span class="math inline">\(p\)</span> 对应的四元数，定义 <span class="math display">\[\overline{M}(p) = (aq+b)(cq+d)^{-1}.\]</span>这里的运算都是在四元数体中进行。则 <span class="math inline">\(\overline{M}(p)\)</span> 是 <span class="math inline">\(\mathbb{H}_3\)</span> 到自身的等距，并且它限制在<span class="math inline">\(xy\)</span> 平面上与 <span class="math inline">\(M\)</span> 的作用一致。</p><p>关于 Poincaré Extension 读者可以参考 <span class="citation" data-cites="Bea95">(<a href="#ref-Bea95" role="doc-biblioref">Beardon1995, vol. 91, secs. 3.3, 4.1</a>)</span>。</p><p>我们还能像上面那样用动画演示 Möbius 变换 <span class="math inline">\(\overline{M}\)</span> 在 <span class="math inline">\(\mathbb{H}_3\)</span>上的作用吗？可以！比如下图是一个形如 <span class="math inline">\(z\tocz\)</span> 的斜航型变换扩展到 <span class="math inline">\(\mathbb{H}_3\)</span>后作用在一个<strong>圆柱</strong>体上的效果：</p><object data="/images/mobius/loxodromic-cone.svg"></object><p>你可能要问了：这明明是个圆锥体，你怎么说它是圆柱体呢？是不是笔误了啊？</p><p>其实是因为我们现在是在双曲空间里看待它，在双曲度量下，锥面上所有点到<span class="math inline">\(t\)</span>轴的距离都是一样的，实际上如果设锥的顶角为 <span class="math inline">\(2\alpha\)</span>，则锥面上任何一点到 <span class="math inline">\(t\)</span> 轴的双曲距离 <span class="math inline">\(d\)</span> 满足（见 <span class="citation" data-cites="Bea95">(<a href="#ref-Bea95" role="doc-biblioref">Beardon1995, vol. 91, sec. 7.9.1</a>)</span>） <span class="math display">\[\sinh d\cdot \cot\alpha = 1.\]</span> 即 <span class="math inline">\(d\)</span> 是定值。所以虽然在 <span class="math inline">\(\mathbb{R}^3\)</span> 中它是一个锥体，但是在 <span class="math inline">\(\mathbb{H}_3\)</span> 中它其实是圆柱体。</p><p>你可以看到这时 <span class="math inline">\(\overline{M}\)</span>有两个不动点，都位于无穷远边界上，这样的点叫做“理想点”。两个不动点之间的连线构成圆柱的轴。两个不动点一个是源点，一个是汇点，空间中的点在变换的作用下“远离”源点，“趋向”汇点。</p><p>对于一般的斜航型变换 <span class="math inline">\(M\)</span>，且其两个不动点都是扩充复平面上的有限点时，<span class="math inline">\(M\)</span> 在 <span class="math inline">\(\mathbb{H}_3\)</span> 上的扩展 <span class="math inline">\(\overline{M}\)</span> 仍然保持一个 <span class="math inline">\(\mathbb{H}_3\)</span> 中的圆柱体不变：</p><object data="/images/mobius/loxodromic-dupin.svg"></object><p>这个曲面叫做 <a href="https://www.maths.ox.ac.uk/about-us/departmental-art/dupin-cyclides">Dupincyclide</a>，它的两个端点恰好是 <span class="math inline">\(M\)</span>的两个不动点。但在双曲空间中它其实是一个圆柱体，由于其两端落在无穷远平面上，因此也是无限长的。圆柱体的轴是连接两个端点的测地线。如果<span class="math inline">\(M\)</span> 是椭圆型的话，那么 <span class="math inline">\(\overline{M}\)</span> 将该圆柱绕着轴旋转：</p><object data="/images/mobius/elliptic-dupin.svg"></object><h1 id="这些动画是怎么生成的">这些动画是怎么生成的？</h1><p>我以 Dupin cyclide 的动画为例子来说明动画的绘制过程。</p><p>一个非抛物型的变换 <span class="math inline">\(M\)</span>总是可以表示为 <span class="math inline">\(M = gM_\lambdag^{-1}\)</span> 的形式，其中 <span class="math inline">\(M_\lambda=z\to\lambda z\)</span>。我这里的 <span class="math inline">\(g\)</span> 取的是 <span class="math display">\[g^{-1}(z)=\frac{z-1}{z+1}.\]</span>注意我这里写的是 <span class="math inline">\(g^{-1}\)</span>，原因是我们不需要 <span class="math inline">\(g\)</span> 的显式表达式，相反我们只需要 <span class="math inline">\(g^{-1}\)</span>。</p><p>不难验证 <span class="math inline">\(g^{-1}(1)=0\)</span> 和 <span class="math inline">\(g^{-1}(-1)=\infty\)</span>，从而 <span class="math inline">\(g(0)=1\)</span> 和 <span class="math inline">\(g(\infty)=-1\)</span>，即 <span class="math inline">\(g\)</span> 将 <span class="math inline">\(M_\lambda\)</span> 的不动点 <span class="math inline">\(\{0,\infty\}\)</span> 分别映射为 <span class="math inline">\(M\)</span> 的不动点 <span class="math inline">\(\{1,-1\}\)</span>。<span class="math inline">\(g\)</span> 同时将 <span class="math inline">\(M_\lambda\)</span> 对应的圆族 <span class="math inline">\(\{\mathcal{C}_i,i=1,2\}\)</span> 映射为 <span class="math inline">\(M\)</span> 的圆族 <span class="math inline">\(\{g(\mathcal{C}_i),i=1,2\}\)</span>。</p><p><span class="math inline">\(g\)</span> 当然也可以扩展为 <span class="math inline">\(\mathbb{H}_3\)</span> 的等距，我们把扩展以后的<span class="math inline">\(g\)</span> 仍然记作 <span class="math inline">\(g\)</span>。</p><p>由 <span class="math inline">\(M = gM_\lambda g^{-1}\)</span> 可得<span class="math display">\[Mg(\mathcal{C}_i) = gM_\lambda(\mathcal{C}_i),\quad i=1,2.\]</span> 左边的 <span class="math inline">\(Mg(\mathcal{C}_i)\)</span> 是我们真正想绘制的<span class="math inline">\(M\)</span> 在其自己的圆族 <span class="math inline">\(g(\mathcal{C}_i)\)</span>上的作用，这等价于绘制右边的 <span class="math inline">\(gM_\lambda(\mathcal{C})_i\)</span>。<span class="math inline">\(M_\lambda(\mathcal{C}_i)\)</span>很好画，就是把一些同心圆和过原点的直线旋转或者放缩一下；但是它前面加了一个畸变<span class="math inline">\(g\)</span>。为此我们只要用 <span class="math inline">\(g^{-1}\)</span>作用在当前场景的物体上，把它们“去畸变”即可。所以在动画中，我其实根本没有计算Dupin cyclide 的任何显式或者隐式的曲面方程，而是直接用 <span class="math inline">\(g^{-1}\)</span> 作用在场景上。由于 <span class="math inline">\(g^{-1}\)</span> 是 <span class="math inline">\(\mathbb{H}_3\)</span> 上的等距，它一定会把连接<span class="math inline">\(\{\pm1\}\)</span> 的测地线映射为连接 <span class="math inline">\(\{0,\infty\}\)</span>的测地线，即锥面。换言之，判断场景中的一个点 <span class="math inline">\(p\)</span> 是不是落在 Dupin cyclide 上，只要判断<span class="math inline">\(g^{-1}(p)\)</span>是不是落在锥面上。这就好办了。</p><p>抛物的情形更简单一些，可以用 <span class="math inline">\(g(z)=1/z\)</span>把位于无穷远的不动点变到原点。</p><p>动画使用的是 GLSL 语言和 raymarching 的技术。我在 Roice的代码基础上作了许多优化，但肯定还可以更精炼。限于我写 shader的能力不足，做出更美轮美奂的效果就不指望了 …</p><p>严格讲，这些动画其实还是尝试在 Euclidean空间中去观察双曲空间中的对象，因为 raymarching技术假定的是光走直线，但在双曲空间中光一般不走直线，所以我们这里看到的效果与真实的生活在双曲空间中的“外星人”所看到的还是有差别的。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Bea95" class="csl-entry" role="listitem">Beardon, Alan F. 1995. <em>The Geometry of Discrete Groups</em>. Vol.91. Graduate Texts in Mathematics. Springer-Verlag, New York.</div><div id="ref-indra" class="csl-entry" role="listitem">Mumford, David, Caroline Series, and David J. Wright. 2002. <em>Indra’sPearls: An Atlas of Kleinian Groups</em>. Cambridge University Press.</div><div id="ref-Needham1997" class="csl-entry" role="listitem">Needham, Tristan. 1997. <em>Visual Complex Analysis</em>. The ClarendonPress, Oxford University Press, New York.</div><div id="ref-palka1991" class="csl-entry" role="listitem">Palka, B. P. 1991. <em>An Introduction to Complex Function Theory</em>.An Introduction to Complex Function Theory. World PublishingCorporation.</div></div>]]></content>
      
      
      <categories>
          
          <category> 可视化复分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>碉堡的小程序：用 Python 制作演示各种算法的 GIF 动画</title>
      <link href="gifmaze-cn/"/>
      <url>gifmaze-cn/</url>
      
        <content type="html"><![CDATA[<p>本文要介绍的是我写的一个有趣的 Python小程序，一个脱离了低级趣味的程序，一个有益于广大人民了解算法的程序。代码在<a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/gifmaze">Github</a>上。</p><p>这个程序可以用来制作各种各样的算法动画，包含但不限于：</p><span id="more"></span><ul><li><p>Wilson 均匀生成树算法：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/wilson-bfs.gif"></p></li><li><p>Prim 算法：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/prim.gif"></p></li><li><p>Kruskal 算法：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/kruskal.gif"></p></li><li><p>Langton 蚂蚁：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/langton-ant.gif"></p></li><li><p>Hilbert 曲线：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/hilbert.gif"></p></li><li><p>Conway 的生命游戏 (gosper glider gun)：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/gosperglidergun.gif"></p></li></ul><p>以上这些动画有一个共同特点：它们都位于二维的网格图上，这也是这个程序的一个限制。</p><p>这个程序有如下特点：</p><ol type="1"><li><p>所有代码全部由纯 Python写成，没有用到任何第三方库或者外部软件，也不包含任何 <code>draw</code>,<code>fill</code> 之类的函数调用，仅使用了内置的 <code>struct</code>,<code>random</code> 模块和一些内置函数。后来的版本中为了显示进度条引入了<code>tqdm</code>；为了把整个动画嵌入一张背景图片引入了<code>pillow</code>，这些都属于特效，本质不需要。</p></li><li><p>实现了一个小型但高效的 GIF编码器，<strong>通过直接将动画过程编码为字节流</strong>，可以在数秒之内生成高度优化的动态图。比如前面那张Langton ant 的动图，它包含 2300 帧，但是大小只有158KB，而且只需要一秒多一点就可以生成。这是这个程序最让人意外的一点：Python生成图像的慢是出了名的，它居然能在几秒内生成一张包含几千帧的 GIF动图？这是个大新闻啊！</p></li><li><p>严格遵循 GIF89a 协议，生成的图片在 chrome, firefox, IE 和 Eog中都可以正常显示。</p></li></ol><p>程序运行的相当快，生成一副 600x400 像素，演示 Wilson算法的动图只要数秒，得到的文件包含 1000~3000 帧，但大小不超过 1M左右。没想到吧？<span class="emoji" data-alias="astonished" style="" data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f632.png?v8">😲</span></p><p>这个程序是怎么来的呢？许多年前我在网上闲逛的时候，偶然发现了 d3.js <a href="https://bl.ocks.org/mbostock">作者的网站</a>（原链接已重定向，作者现在已经创业搞<a href="https://observablehq.com/">observablehq</a>去了），当时我对上面展示的各种丰富炫酷的动态效果惊羡不已，尤其是其中 <a href="https://bl.ocks.org/mbostock/11357811">Wilson算法的演示</a>，让我对此算法有了更直观和深入的理解。我立刻萌发了用Python 制作一个 GIF版本动画演示的想法，但是思考了许久也不知道从何入手。这里困难的地方在于Wilson算法是一个随机算法，其运行时间是不确定的，一个动画里面可能包含数千帧，如果采用把每一帧保存为图像再合并到一起的话，最终得到的文件会非常庞大。而且这种纯暴力的做法逼格不高，我实在不屑于采用。限于能力不足，这个想法只好被暂时压在心底，但是一直念念不忘。过了几年后，一个偶然的机会我接触到了GIF图像的编码协议，豁然开朗：为什么不直接把动画过程编码为字节流呢？通过精确定位每一帧的位置，控制LZW压缩过程的编码长度，文件过大的问题是可以解决的！前后捣鼓了半个月，反复研究协议细节，debug了无数次后，这才作出了上面的效果。后来慢慢又加上了其它迷宫算法和元胞自动机的演示。</p><p>关键的地方有这么几个：</p><ol type="1"><li><p>由于 GIF图像的每一帧占据的是整个图像窗口的一个矩形子区域，在一个包含很多帧的动图中，相邻的两帧之间的变动可能很小，没有必要每次都将整个图像全部编码。我们只需要记录帧和帧之间的变化情况，得出每一帧所占的矩形子区域，每次编码时只针对这个子区域编码即可，这样就大大减小了生成的文件体积。</p></li><li><p>采用变长的 LZW 压缩算法。GIF89a协议允许每个打包的数据块指明其所使用的最小码字的长度，如果你事先知道这一帧图像用到的颜色数目，比如4 种颜色，那么 2 个比特就足以表示这 4 种颜色，从而最小编码长度可以设置为2。这样根据具体情况采用不同的编码长度能有效减少文件体积。</p></li><li><p>因为要频繁的进行字节流的操作，所以每次将编码后的数据先写入一个<code>BytesIO</code> 对象中，放在内存里，最后一次性输出到硬盘。</p></li></ol><p>代码的组织结构是简单的三层论：顶层是抽象的 <code>Maze</code>类，其本质就是一个 2D网格图，用来跑各种图算法，它不关心动图的任何细节。底层是<code>GIFSurface</code> 类，负责维护 GIF图片的全局信息，比如图片宽高，循环次数，背景颜色，全局调色板等。中间层是<code>Animation</code>类，用来控制帧的信息，在算法运行过程中它按照一定的频率将<code>Maze</code> 染色并编码写入 <code>GIFSurface</code>。</p><p>目前程序的核心代码加起来大约在 1000行左右，但是如果牺牲一些可读性和功能的话，是可以压缩到 500行以内的。我曾经把这个项目投稿到 Github 上的 <a href="https://github.com/aosabook/500lines">500lines</a>上，可惜未能入选。但是我始终觉得它的优雅、奇妙并不逊色于那些大神们的作品。</p>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模任何素数都可约的整系数不可约多项式</title>
      <link href="reducible-mod-p/"/>
      <url>reducible-mod-p/</url>
      
        <content type="html"><![CDATA[<p>几年前在知乎上有这么 <a href="https://www.zhihu.com/question/38156113/answer/139354565">一个问题</a>：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>有哪些 <span class="math inline">\(\mathbb{Z}[x]\)</span> 中的多项式，它们在有理数域<span class="math inline">\(\mathbb{Q}\)</span>上是不可约的，而对任意素数 <span class="math inline">\(p\)</span>，模<span class="math inline">\(p\)</span> 以后在 <span class="math inline">\(\mathbb{Z}_p[x]\)</span> 上都是可约的？</p></div><p>当时我给了回答，后来账号注销了，答案也一并删除了。现在把我的原答案贴在这里：</p><span id="more"></span><p>我所知道的有两大类多项式：</p><p>第一类是所有的 Swinnerdon-Dyer 多项式，它们形如 <span class="math display">\[f(x)=\prod(x\pm\sqrt{p_1}\pm\sqrt{p_2}\cdots\pm\sqrt{p_n}),\]</span>其中 <span class="math inline">\(p_1,\ldots,p_n\)</span>是互不相同的素数，乘积跑遍所有 <span class="math inline">\(2^n\)</span>种不同的组合。这种多项式都是不可约的整系数多项式，但是模任何素数 <span class="math inline">\(p\)</span>以后都分解为一次或者二次因式的乘积。</p><p>第二类来自分圆多项式，分圆多项式 <span class="math inline">\(\Phi_n(x)\)</span> 是本原 <span class="math inline">\(n\)</span> 次单位根在 <span class="math inline">\(\mathbb{Q}\)</span> 上的首 1 极小多项式，其次数为<span class="math inline">\(\phi(n)\)</span>，这里 <span class="math inline">\(\phi(\cdot)\)</span> 是 Euler totient函数。绝大多数分圆多项式模任何素数 <span class="math inline">\(p\)</span> 都是可约的！实际上我们有如下结论：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>分圆多项式 <span class="math inline">\(\Phi_n(x)\)</span>模任何素数 <span class="math inline">\(p\)</span> 都可约当且仅当 <span class="math inline">\(n\ne1,2,p,2p^k\)</span>，其中 <span class="math inline">\(p\)</span> 是奇素数，<span class="math inline">\(k\)</span> 是正整数。</p></div><p>你可以看到知乎那个问题下的回答中举的例子都是最简单的 Swinnerdon-Dyer多项式或者分圆多项式。</p><p>我知道这个结论还是研究生时上夏壁灿老师的符号计算课程，讲到分解整系数多项式的Zassenhaus算法，这两类多项式被用来分析算法的最差复杂度。我还在校园书摊上淘到了一本破损的<a href="https://www.cambridge.org/core/books/modern-computer-algebra/DB3563D4013401734851CF683D2F03F0">ModernComputer Algebra</a>，在 15.3 节 “Frobenius’ and Chebotarev’s densitytheorems” 中有介绍。</p><p>这两类多项式属于比较容易分析的，还有别的例子吗？也是有的，<a href="https://projecteuclid.org/euclid.rmjm/1289916905">这篇文章</a>给出了更多不那么显然的构造。</p>]]></content>
      
      
      <categories>
          
          <category> 代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Coupling from the past</title>
      <link href="coupling-from-the-past/"/>
      <url>coupling-from-the-past/</url>
      
        <content type="html"><![CDATA[<p>今天我要介绍一个 Markov 链采样中的精彩算法，叫做 coupling from thepast(CFTP)。这个算法看似简单，实则充满玄机。我相信你可以在五分钟内理解算法的步骤，然后再花五分钟左右看懂算法的证明，但是我打赌你需要几个星期甚至更久的时间来细细回味其中奥妙。</p><p>作为启发，我们从一个计数问题开始：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>下图是一个边长分别为 <span class="math inline">\(a,b,c\)</span> 的平行六边形，其中 <span class="math inline">\(a,b,c\)</span> 都是正整数，内角均为 120 度：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/cftp/hexagon.svg"></p><p>请问：用边长为 1 的菱形密铺它，有多少种不同的方法？</p></div><span id="more"></span><p>比如下图就是一种密铺的示例：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/cftp/random_lozenge_tiling.svg"></p><p>图中三种不同摆放角度的菱形被染成了不同的颜色。</p><p>这个问题的答案很不容易猜到，叫做 Macmahon 公式：</p><div id="macmahon-------" class="unnumbered statement sta_macmahon___ plain"><p><span class="statement-heading"><span class="statement-label">Macmahon 公式</span>.</span><span class="statement-spah"> </span>记 <span class="math inline">\(H(a,b,c)\)</span>为所求的六边形的不同菱形密铺的个数，则 <span class="math display">\[H(a,b,c)=\prod_{i=1}^a\prod_{j=1}^b\prod_{k=1}^c\frac{i+j+k-1}{i+j+k-2}.\]</span></p></div><p>关于 Macmahon 公式，以及它背后的 plane partition理论是另一段精彩的故事，这里不作介绍。需要注意的是，<span class="math inline">\(H(a,b,c)\)</span> 的值是指数级增长的，比如对 <span class="math inline">\(a=b=c=10\)</span> 这种比较小的情形 <span class="math inline">\(H(a,b,c)\approx9.265\times10^{33}\)</span>，已经是一个天文数字了。</p><p>真正的问题来了：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>怎样在全部 <span class="math inline">\(H(a,b,c)\)</span>种不同的密铺中完全随机地任选一种？（即按照均匀分布采样）</p></div><p>由于 <span class="math inline">\(H(a,b,c)\)</span>太太太大了，我们不可能先把所有密铺都列出来然后再挑选，那样的话全世界的计算机内存加起来也装不下。所以得设计一个聪明点的方法，这就是CFTP 要做的。</p><h1 id="markov-链的随机取样">Markov 链的随机取样</h1><p>设 <span class="math inline">\(M\)</span> 是一个有限遍历的 Markov链，其状态空间为 <span class="math inline">\(S\)</span>，平稳分布为<span class="math inline">\(\pi\)</span>，我们希望以分布 <span class="math inline">\(\pi\)</span> 从 <span class="math inline">\(S\)</span> 中随机地取样，即对任何 <span class="math inline">\(s\in S\)</span>，取样抽到 <span class="math inline">\(s\)</span> 的概率为 <span class="math inline">\(\pi(s)\)</span>。这在许多实际应用中都有重要意义。通常的方法是任选一个初始状态<span class="math inline">\(s_0\)</span> 然后从 <span class="math inline">\(s_0\)</span> 出发跑这个 Markov链。可以证明只要运行的时间 <span class="math inline">\(n\)</span>足够大，其 <span class="math inline">\(n\)</span> 时刻的状态 <span class="math inline">\(s_n\)</span> 服从的分布就可以任意逼近平稳分布：<span class="math display">\[|\mathbb{P}(s_n=s) - \pi(s)| &lt;\epsilon,\quad\forall s\in S,\ \forall\epsilon&gt;0.\]</span>这个方法非常简单易行，但是它有两个缺陷：首先它只是一个近似算法，不管<span class="math inline">\(n\)</span> 取得多么大，返回的 <span class="math inline">\(s_n\)</span> 的分布只是近似而非严格等于平稳分布<span class="math inline">\(\pi\)</span>；其次为了获得足够的精度采样所需的时间<span class="math inline">\(n\)</span> （叫做 mixingtime）也不总是那么容易估计的。那么有没有什么办法可以获得精确地服从 <span class="math inline">\(\pi\)</span> 的采样呢？</p><p>Propp 和 Wilson 提出了如下的想法：既然从初始状态出发向未来 （<span class="math inline">\(+\infty\)</span> 方向） 跑 Markov链得不到真正的平稳分布，我们何不从无穷远的过去 （<span class="math inline">\(-\infty\)</span> 方向） 向现在 （时刻 0）跑呢？可以想象当这个链经过了无穷次迭代后，其 0 时刻的状态 <span class="math inline">\(s^\ast\)</span> 服从的分布就是 <span class="math inline">\(\pi\)</span>。当然，一个可行的算法必须在有限时间内输出结果，我们不可能做到真的从无穷远的过去出发。我们能做的只是选择一个足够大的<span class="math inline">\(n\)</span> 然后从 <span class="math inline">\(-n\)</span> 时刻出发向时刻 0 跑，但是这种做法和从0 时刻向时刻 <span class="math inline">\(n\)</span>跑没有什么区别。Propp 和 Wilson的观察的关键之处在于，只跑一个链是不行的，我们需要从每个 <span class="math inline">\(s\in S\)</span> 出发，同时跑 <span class="math inline">\(M\)</span> 的 <span class="math inline">\(|S|\)</span> 个不同的版本，并且观察它们是否在时刻0 时耦合在一起 (coupled together)，即相遇到了相同的状态 <span class="math inline">\(s^\ast\)</span>。一旦这件事情发生的话，那么假设我们还有一个额外的从无穷远出发、初始分布是<span class="math inline">\(\pi\)</span> 的链，由于它来到 0时刻必然也处于状态 <span class="math inline">\(s^\ast\)</span>，所以<span class="math inline">\(s^\ast\)</span> 就服从分布 <span class="math inline">\(\pi\)</span>。如果没有相遇呢？那就从某个更久远的位置开始再来一遍，直到耦合出现为止，这就是coupling from the past 的由来。</p><p>用不太准确的话说，我们是在时间 <span class="math inline">\(-n\)</span> 处设置了 <span class="math inline">\(|S|\)</span>个不同的链，封死了从无穷远过去出发的链在 <span class="math inline">\(-n\)</span>处的所有可能状态，然后通过将所有链在时刻 0“坍缩”为单个状态来获得采样。</p><p>其实我上面的描述仍然遗漏了 CFTP 的一些关键细节。为了准确的描述CFTP，我们首先引入 Markov 链的随机映射表示 (random mappingrepresentation)。</p><h1 id="markov-链的随机映射表示">Markov 链的随机映射表示</h1><p>随机映射表示能够让我们用计算机程序来模拟 Markov链，它是一个由随机数流驱动的更新函数 <span class="math inline">\(f:S\times [0, 1]\to S\)</span>。<span class="math inline">\(f\)</span>本身是确定的，对任何状态 <span class="math inline">\(s\in S\)</span> 和<span class="math inline">\(u\in [0,1]\)</span>，<span class="math inline">\(s'=f(s,u)\)</span> 给出 Markov链更新后的状态。我们要求 <span class="math inline">\(f\)</span> 满足当<span class="math inline">\(U\)</span> 是服从 <span class="math inline">\([0, 1]\)</span> 上的均匀分布的随机变量时，<span class="math inline">\(\mathbb{P}(f(s,U)=s')=P_{s,s'}\)</span>。这里 <span class="math inline">\(P_{s,s'}\)</span> 是 Markov 链从 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(s'\)</span> 的转移概率。任何有限 Markov链都存在随机映射表示，而且表示方法不是唯一的。最简单的构造方式是用一个阶梯函数：<span class="math display">\[f(s_i, u) =\begin{cases}\begin{array}{ll}s_1, &amp;\text{for } u\in[0,P_{i,1}),\\s_2, &amp;\text{for } u\in[P_{i,1}, P_{i,1}+P_{i,2}),\\\vdots&amp;\vdots\\s_j, &amp;\text{for } u\in\left[\sum_{k=1}^{j-1}P_{i,k},\sum_{k=1}^jP_{i,k}\right),\\\vdots &amp;\vdots\\s_n, &amp;\text{for }u\in\left[\sum_{k=1}^{n-1}P_{i,k},1\right].\end{array}\end{cases}\]</span></p><p>假设有一个随机数发生器可以产生独立且服从 <span class="math inline">\([0,1]\)</span> 上均匀分布的随机变量序列 <span class="math inline">\(U_0,U_{-1},U_{-2},\ldots\)</span>，则我们可以由此来驱动Markov 链 <span class="math inline">\(M\)</span>从过去的某个时刻向现在运行： <span class="math display">\[s_{-n}\xrightarrow{f(s_{-n+1},\,U_{-n+1})}s_{-n+1}\xrightarrow{f(s_{-n+2},\,U_{-n+2})}\cdots\xrightarrow{f(s_0,\,U_0)}s_0.\]</span></p><h1 id="coupling-from-the-past-算法">Coupling from the past 算法</h1><p>现在我们可以来表述 coupling from the past 算法了。</p><p>设 <span class="math inline">\(M\)</span> 是一个有限遍历的 Markov链，状态空间为 <span class="math inline">\(S\)</span>，<span class="math inline">\(f: S\times [0, 1]\to S\)</span>是其随机映射表示。<span class="math inline">\(U_0,U_{-1},\ldots\)</span>是一列随机数，它们分别来自一列独立且服从 <span class="math inline">\([0,1]\)</span> 上均匀分布的随机变量。记 <span class="math inline">\((N_1,N_2,\ldots)=(1,2,4,8,\ldots)\)</span>，<span class="math inline">\(-N_{m}\)</span> 将作为我们第 <span class="math inline">\(m\)</span> 次重启的出发时间。</p><blockquote><p><strong>Coupling from the past 算法</strong>：</p><ol type="1"><li>令 <span class="math inline">\(m=1\)</span>。</li><li>对每个 <span class="math inline">\(s\in S\)</span>，以 <span class="math inline">\(s\)</span> 为初始状态，以 <span class="math inline">\(-N_m\)</span> 为初始时刻向时刻 0 的方向运行 Markov链 <span class="math inline">\(M\)</span>，所有 <span class="math inline">\(|S|\)</span> 个链使用的随机数流是一样的，都是<span class="math inline">\((U_{-N_m+1},\ldots,U_{-1},U_0)\)</span>。</li><li>如果步骤 2 中的 <span class="math inline">\(|S|\)</span> 个链在时刻0 给出的状态相同，记此状态为 <span class="math inline">\(s^\ast\)</span>，则输出 <span class="math inline">\(s^\ast\)</span> 并退出程序。否则将 <span class="math inline">\(m\)</span> 的值加 1 并重复步骤 2。</li></ol><p>下图显示了算法的每个重启时刻，相同颜色的随机数是在同一批中生成的。</p><p><img style="margin:0px auto;display:block" src="/images/cftp/random_numbers.svg"></p><p><strong>断言</strong>：如果上述步骤以概率 1在有限时间内结束，则其返回值 <span class="math inline">\(s^\ast\)</span>服从平稳分布 <span class="math inline">\(\pi\)</span>: <span class="math display">\[\mathbb{P}(s^\ast = s) = \pi(s),\quad \foralls\in S.\]</span></p></blockquote><p>注意这里的两个细节：</p><ol type="1"><li>我们强调了前提<strong>如果算法以概率 1在有限时间内结束，则返回值服从平稳分布</strong>。为了保证这个前提成立更新函数<span class="math inline">\(f\)</span>的选择就不能是任意的，特别地在后面的 monotone CFTP 中更新函数还要与<span class="math inline">\(S\)</span>上的偏序相容，更不能是任意的。</li><li>当第 <span class="math inline">\(m\)</span> 次执行步骤 2时，使用的随机数为 <span class="math inline">\((U_{-N_m+1},U_{-N_m+2},\ldots,U_{-1},U_0)\)</span>，其中的后半部分<span class="math inline">\((U_{-N_{m-1}+1},U_{-N_{m-1}+2},\ldots,U_{-1},U_0)\)</span>需要与上一次使用的相同，<strong>即每一次都重复使用上一次的随机数作为后半段的随机源</strong>，否则每次都重新生成一列新的随机数的话得到的最终状态未必服从平稳分布。</li></ol><p><strong>证明</strong>：任取 <span class="math inline">\(s_i\inS\)</span>，只要证明对任何 <span class="math inline">\(\epsilon&gt;0\)</span> 都有 <span class="math display">\[|\mathbb{P}(s^\ast=s_i) -\pi(s_i)|&lt;\epsilon.\]</span> 设 <span class="math inline">\(\Omega=\{(U_{-1},U_{-2},\ldots)\mid U_i \text{i.i.d on } [0,1]\}\)</span> 是所有随机数流组成的样本空间， <span class="math display">\[A=\{\text{the algorithm terminates in finitetime}\}.\]</span> 即 <span class="math inline">\(A\)</span>为那些可以使得算法在有限时间内结束的序列组成的集合，则 <span class="math inline">\(\mathbb{P}(A)=1\)</span>。</p><p>又记 <span class="math display">\[A_i = \{ \text{the algorithm doesnot need to try starting times earlier than} -N_i\}.\]</span> 即 <span class="math inline">\(A_i\)</span> 为事件“算法从 <span class="math inline">\(-N_i\)</span> 或者更早的时间出发可以结束”。</p><p>显然我们有 <span class="math inline">\(A_i\uparrow A\)</span>，<span class="math inline">\(\mathbb{P}(A_i)\uparrow\mathbb{P}(A)=1\)</span>。因此对充分大的<span class="math inline">\(K\)</span> 有 <span class="math inline">\(\mathbb{P}(A_K) \geq1-\epsilon\)</span>。取定这样的 <span class="math inline">\(K\)</span>，则在事件 <span class="math inline">\(A_K\)</span> 上，所有的链在时刻 0 耦合到相同的状态<span class="math inline">\(s^\ast\)</span>。</p><p>除了以上 <span class="math inline">\(|S|\)</span>条链之外，我们再额外跑一条单独的链 <span class="math inline">\(Y\)</span>，这条链的初始状态选自平稳分布 <span class="math inline">\(\pi\)</span>，也从时刻 <span class="math inline">\(-N_K\)</span> 出发，也使用相同的随机数 <span class="math inline">\((U_{-N_K+1},\ldots,U_0)\)</span> 运行至时刻0，并设这个链在时刻 0 的状态为 <span class="math inline">\(Y_0\)</span>，则 <span class="math inline">\(Y_0\)</span> 服从平稳分布。</p><p>在事件 <span class="math inline">\(A_K\)</span>上，不管这条单独的链初始状态是什么，由于它使用了同样的随机数序列，所以它最后一定会和其余<span class="math inline">\(|S|\)</span> 条链一起耦合，所以 <span class="math display">\[\mathbb{P}(s^\ast=Y_0) \geq \mathbb{P}(A_K)\geq 1- \epsilon.\]</span> 从而对任何 <span class="math inline">\(s_i\inS\)</span>， <span class="math display">\[\begin{aligned}\mathbb{P}(s^\ast =s_i)-\pi(s_i)&amp;= \mathbb{P}(s^\ast = s_i)-\mathbb{P}(Y_0 =s_i)\\&amp;\leq\mathbb{P}(s^\ast=s_i, Y_0\ne s_i)\\&amp;\leq\mathbb{P}(Y_0\nes^\ast)\\&amp;\leq\epsilon.\end{aligned}\]</span> 类似地 <span class="math display">\[\begin{aligned}\pi(s_i)-\mathbb{P}(s^\ast =s_i)&amp;=\mathbb{P}(Y_0 = s_i)-\mathbb{P}(s^\ast =s_i)\\&amp;\leq\mathbb{P}(Y_0=s_i, s^\ast\ne s_i)\\&amp;\leq\mathbb{P}(Y_0\nes^\ast)\\&amp;\leq\epsilon.\end{aligned}\]</span> 从而 <span class="math display">\[|\mathbb{P}(s^\ast = s_i)-\pi(s_i)| \leq\epsilon.\]</span> 令 <span class="math inline">\(K\to\infty\)</span>，则 <span class="math inline">\(\epsilon\downarrow0\)</span>。注意到对任何样本点<span class="math inline">\(\omega\in A_K\)</span>，如果 <span class="math inline">\(\omega\)</span> 给出的所有链的耦合状态是 <span class="math inline">\(s^\ast=s_i\)</span>，则从更久远的时刻出发，<span class="math inline">\(\omega\)</span> 给出的耦合状态仍然是 <span class="math inline">\(s_i\)</span>，即 <span class="math inline">\(\omega\)</span> 输出的采样结果 <span class="math inline">\(s^\ast\)</span> 是不会随着 <span class="math inline">\(K\)</span> 增大而改变的，所以由 <span class="math inline">\(\epsilon\)</span> 的任意性即得 <span class="math inline">\(s^\ast\)</span> 服从平稳分布。</p><h1 id="算法中的若干陷阱">算法中的若干陷阱</h1><p>CFTP算法的证明看似不难，但其实微妙之处不少，值得细细品味。最主要的地方有三个：</p><blockquote><p><strong>问题 1</strong>：为什么说更新函数 <span class="math inline">\(f\)</span> 的选择不能是任意的？</p><p><strong>问题 2</strong>：既然 “coupling from the past” 可以，那“coupling to the future” 可不可以？从时刻 0 开始从每个 <span class="math inline">\(s\in S\)</span> 出发跑 <span class="math inline">\(|S|\)</span> 个不同的链，直到它们在未来某个时刻<span class="math inline">\(n\)</span>耦合为止，然后输出第一次耦合时的状态不行吗？</p><p><strong>问题 3</strong>：每次重启步骤 2时需要复用之前的随机数，这一点在证明中哪里用到了？使用一列新的随机数为什么不可以？</p></blockquote><p>我们用几个例子来说明这三个问题。</p><h2 id="为什么更新函数不能是任意的">为什么更新函数不能是任意的</h2><p>考虑含有两个状态 <span class="math inline">\(S=\{s_1, s_2\}\)</span>的 Markov 链，其转移矩阵为 <span class="math inline">\(P=\begin{bmatrix}0.5 &amp; 0.5\\0.5 &amp;0.5\end{bmatrix}\)</span>，更新函数为 <span class="math display">\[f(s_1, u) =\begin{cases}\begin{array}{ll}s_1&amp; \text{for } u \in [0, 0.5)\\s_2 &amp; \text{for } u \in [0.5,1]\end{array}\end{cases}\]</span> 和 <span class="math display">\[f(s_2,u) =\begin{cases}\begin{array}{ll}s_2 &amp; \text{for } u \in [0,0.5)\\s_1 &amp; \text{for } u \in [0.5,1]\end{array}\end{cases}\]</span> 于是若从 <span class="math inline">\(s_1,s_2\)</span>分别出发跑两个不同的链，但是每次使用相同的随机数，则它们要么保持不动，要么交换状态，永不耦合。</p><h2 id="为什么-coupling-into-the-future-不行">为什么 Coupling into thefuture 不行</h2><p>我打赌任何看到 CFTP算法的人都会想到同样的问题：为什么不能向未来耦合呢？</p><blockquote><p><strong>Coupling into the future</strong>: 从时刻 0 出发同时跑 <span class="math inline">\(|S|\)</span> 个不同的链，其中链 <span class="math inline">\(i\)</span> 的初始状态是 <span class="math inline">\(s_i\)</span>。当所有链首次耦合到同一状态 <span class="math inline">\(s^\ast\)</span> 时，终止算法并输出 <span class="math inline">\(s^\ast\)</span> 作为采样状态。</p></blockquote><p>向未来耦合与 CFTP有一个根本不同：向未来耦合的结束时间是一个随机时间，而在 CFTP中，我们总是在固定的时刻 0 观察所有链是否耦合。</p><p>我们来试试把上面 CFTP 的证明照抄在这里：设 <span class="math inline">\(\tau\)</span> 是所有 <span class="math inline">\(|S|\)</span> 条链首次耦合的时间，<span class="math inline">\(Y\)</span> 是额外的从时刻 0出发的、初始分布为平稳分布的链，并且使用相同的随机数流，则对任何时刻<span class="math inline">\(n\ge0\)</span>，<span class="math inline">\(Y_n\)</span>都服从平稳分布。但是当把下标换成随机时间 <span class="math inline">\(\tau\)</span> 时，<span class="math inline">\(Y_\tau\)</span>未必仍然服从平稳分布，所以之前的证明不再可用。</p><p>我们用一个反例来说明：仍然考虑两个状态 <span class="math inline">\(S=\{s_1, s_2\}\)</span> 的 Markov 链，其转移矩阵为<span class="math inline">\(P=\begin{bmatrix}0.5 &amp; 0.5\\1 &amp;0\end{bmatrix}\)</span>，即从 <span class="math inline">\(s_1\)</span>出发的话以 0.5 的概率待在原地，以 0.5 的概率跳到 <span class="math inline">\(s_2\)</span>，从 <span class="math inline">\(s_2\)</span> 出发的话则总是跳到 <span class="math inline">\(s_1\)</span>。</p><p><img style="margin:0px auto;display:block" width="250" src="/images/cftp/counter_example.svg"></p><p>这个链的平稳分布为 <span class="math inline">\(\pi=(\frac{2}{3},\frac{1}{3})\)</span>。现在假设从<span class="math inline">\(s_1,s_2\)</span> 分别出发，从时刻 0 开始向<span class="math inline">\(+\infty\)</span> 方向跑两个不同的链，<span class="math inline">\(\tau\)</span> 是它们首次耦合的时间，则 <span class="math inline">\(\tau-1\)</span> 时刻它俩必然一个位于 <span class="math inline">\(s_1\)</span>，一个位于 <span class="math inline">\(s_2\)</span>。但是位于 <span class="math inline">\(s_2\)</span> 的状态只能转移到 <span class="math inline">\(s_1\)</span>，所以 <span class="math inline">\(\tau\)</span> 时刻的输出永远是 <span class="math inline">\(s_1\)</span>，从而得到的采样 <span class="math inline">\(Y_\tau\)</span> 不满足平稳分布。</p><h2 id="为什么每次不能重新生成随机数">为什么每次不能重新生成随机数</h2><p>思考一下，在算法的证明当中，如果在每次迭代中都使用全新的随机数序列的话，那么事件<span class="math inline">\(A\)</span> 的定义会变成什么？难道是 <span class="math inline">\(\Omega\)</span>的某个有限子集，使得其包含一个可以耦合的序列？Hmm，这就不太对劲了。直观上看，在第<span class="math inline">\(m\)</span>次迭代时，由于生成的序列是全新的，有可能它实际上对某个 <span class="math inline">\(i&lt;m\)</span>，从 <span class="math inline">\(-N_i\)</span>出发就可以耦合，这会导致算法过度采样那些很快就可以耦合的短链，从而使得最终的分布不服从平稳分布。</p><p>我们继续用上一小节中的例子来说明。我们指定其更新函数 <span class="math inline">\(f\)</span>为随机映射表示一节中给出的阶梯函数形式。假设算法每次都使用一列新的随机数，其最终输出为<span class="math inline">\(s^\ast\)</span>。定义随机变量 <span class="math inline">\(\tau\)</span> 为正整数 <span class="math inline">\(m\)</span> 使得算法中使用的最早的出发时间为 <span class="math inline">\(-N_m\)</span>，则 <span class="math display">\[\begin{aligned}\mathbb{P}(s^\ast=s_1)&amp;=\sum_{m=1}^\infty\mathbb{P}(s^\ast=s_1,\tau=m)\\&amp;\geq\mathbb{P}(s^\ast=s_1,\tau=1)+\mathbb{P}(s^\ast=s_1,\tau=2)\\&amp;=\mathbb{P}(\tau=1)\mathbb{P}(s^\ast=s_1|\tau=1)+\mathbb{P}(\tau=2)\mathbb{P}(s^\ast=s_1|\tau=2)\end{aligned}\]</span> 注意事件 <span class="math inline">\(\{\tau=1\}\)</span> 包含两种不同的演化路径： <span class="math display">\[\begin{aligned}(1)\quad &amp; s_1\to s_1,\quads_2\to s_1.\\(2)\quad &amp; s_1\to s_2,\quad s_2\to s_1.\end{aligned}\]</span>其中只有前者能成功耦合，所以 <span class="math inline">\(\mathbb{P}(\tau=1)=\frac{1}{2}\)</span>，这时输出的状态只能是<span class="math inline">\(s_1\)</span>，所以<span class="math inline">\(\mathbb{P}(s^\ast=s_1|\tau=1)=1\)</span>。</p><p>可以看到这个长度是 1 的短链的耦合只发生在状态 <span class="math inline">\(s_1\)</span> 上，它非常偏爱 <span class="math inline">\(s_1\)</span>。</p><p>事件 <span class="math inline">\(\{\tau=2\}\)</span>包含四种不同的演化路径： <span class="math display">\[\begin{align*}(1)\quad &amp; s_1\to s_1\tos_1,\quad s_2\to s_1 \to s_1.\\(2)\quad &amp; s_1\to s_2\to s_1,\quad s_2\to s_1 \to s_1.\\(3)\quad &amp; s_1\to s_1\to s_2,\quad s_2\to s_1 \to s_2.\\(4)\quad &amp; s_1\to s_2\to s_1,\quad s_2\to s_1 \tos_2.\end{align*}\]</span>注意以下两种演化路径是非法的，因为每个时刻两个链使用的随机数一样，不可能在某个时刻同时出现一个链<span class="math inline">\(s_1\to s_2\)</span>，另一个 <span class="math inline">\(s_1\to s_1\)</span> 的情况： <span class="math display">\[\begin{array}{ll}(*)\quad &amp; s_1\to s_1\to s_2,\quad &amp;s_2\to s_1 \to s_1.\\(**)\quad &amp; s_1\to s_1\to s_1,\quad &amp;s_2\to s_1 \to s_2.\\\end{array}\]</span></p><p>在我们现在这个错误的版本中，由于使用了全新的随机数流，四种路径都是合法的。这四个路径中前三种都成功耦合，两个耦合于<span class="math inline">\(s_1\)</span> 一个耦合于 <span class="math inline">\(s_2\)</span>，所以 <span class="math inline">\(\mathbb{P}(s^\ast=s_1|\tau=2)=\frac{2}{3}\)</span>。</p><p>注意到其中第二条路径 <span class="math display">\[(2)\quad  s_1\tos_2\to s_1,\quad s_2\to s_1 \to s_1.\]</span> 从时刻 <span class="math inline">\(-1\)</span> 出发就可以耦合，它不应该属于事件 <span class="math inline">\(\{\tau=2\}\)</span>。每次使用全新的随机数流会导致偏爱<span class="math inline">\(s_1\)</span> 的短链被过度采样。</p><p>我们来具体验证一下： <span class="math display">\[\mathbb{P}(\tau=2)=\mathbb{P}(\tau\ne1)\cdot\mathbb{P}(\tau=2\\text{时耦合})=\frac{1}{2}\cdot\frac{3}{4}=\frac{3}{8}.\]</span></p><p>所以 <span class="math display">\[\begin{align*}\mathbb{P}(s^\ast=s_1)&amp;\geq\mathbb{P}(\tau=1)\mathbb{P}(s^\ast=s_1|\tau=1)+\mathbb{P}(\tau=2)\mathbb{P}(s^\ast=s_1|\tau=2)\\&amp;=\frac{1}{2}\cdot1+ \frac{3}{8}\cdot\frac{2}{3}\\&amp;=\frac{3}{4}&gt;\pi(s_1).\end{align*}\]</span></p><p>确实如我们的预言，<span class="math inline">\(s_1\)</span>被过度采样了。</p><h1 id="monotone-coupling-from-the-past">Monotone coupling from thepast</h1><p>在 CFTP 算法中，我们需要同时跑 <span class="math inline">\(|S|\)</span> 个不同的链并要求它们在时刻 0处耦合，当 <span class="math inline">\(|S|\)</span>很大时所耗的时间和计算量都很不划算，所以这个算法在应用中是有限制的。但是有一种情形它是非常好用的：如果<span class="math inline">\(S\)</span> 是一个偏序集 <span class="math inline">\((S, \preceq)\)</span>，有最大最小元 <span class="math inline">\(s_\max, s_\min\)</span>，并且更新函数 <span class="math inline">\(f\)</span> 与偏序 <span class="math inline">\(\preceq\)</span> 相容，即对任何 <span class="math inline">\(s,s'\in S\)</span>，<span class="math inline">\(u\in[0,1]\)</span>， <span class="math display">\[s\preceq s' \Rightarrow f(s, u) \preceqf(s', u),\]</span> 则我们只要对 <span class="math inline">\(s_\max,s_\min\)</span>这两个状态跑两个不同的链即可，当它俩耦合时，所有其它的链也会被“挤压”到相同的状态。这就是前面六边形的菱形密铺取样所采取的方法。</p><p>我们在所有菱形密铺组成的集合 <span class="math inline">\(S\)</span>上定义一个偏序 <span class="math inline">\(\preceq\)</span>，这个偏序的定义颇有技巧性，它需要将任一密铺对应到一个不相交的格点路径组，如下图所示：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/non-intersecting_paths_lozenge.svg"></p><p>图中一共出现了 <span class="math inline">\(c+2\)</span>条不相交的路径，其中最上方和最下方两条路径对任何密铺都是固定的（它俩是用来约束中间的 <span class="math inline">\(c\)</span>条路径，让它们在翻转的过程不要越界），中间的 <span class="math inline">\(c\)</span>条路径，每条路径的起点和终点也是固定的，它们从菱形最左边的边的每个单位线段中点出发，每一步分别向右上或者右下走一步，经过<span class="math inline">\(a+b\)</span>步后到达最右边的边的对应位置。</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/two_paths.svg"></p><p>上图中从菱形的最左边到最右边共有 <span class="math inline">\(a+b+1\)</span>条竖直的网格线，每一步向右上或者右下走一步会向右移动到下一个网格线，所以总共需要<span class="math inline">\(a + b\)</span>次到达最右边。不同的路径互不相交，所以它们的终点必须互不相同，因此这些终点必然分别依次是菱形最右边的单位线段的中点。</p><p>不难说明所有的菱形密铺和所有不相交路径组之间的一一对应关系：当密铺给定时，从左边每个起点出发开始，根据当前菱形的倾斜方向依次描出路径即可；反之当路径组给定时，可以沿着每条路径铺砖，这样确定所有的“斜”菱形的位置，余下的空白位置只有唯一的方式可以被水平的菱形填充。</p><p>我们在所有不相交的路径组之间定义一个偏序：两个路径组 <span class="math inline">\(\mathcal{P}\preceq\mathcal{P}'\)</span>当且仅当对任何 <span class="math inline">\(1\leq i\leqc+2\)</span>，<span class="math inline">\(\mathcal{P}\)</span> 中的第<span class="math inline">\(i\)</span> 条路径 <span class="math inline">\(p_i\)</span> 整体地位于 <span class="math inline">\(\mathcal{P}'\)</span> 中第 <span class="math inline">\(i\)</span> 条路径 <span class="math inline">\(p_i'\)</span>的下方。在这个偏序下的最大元就是所有路径尽可能地“向上拱”：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/max_state.svg"></p><p>而最小元则是所有路径尽可能地“向下走”：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/cftp/min_state.svg"></p><p>有了偏序，我们还要定义一个与之相容的更新函数 <span class="math inline">\(f\)</span>。<span class="math inline">\(f\)</span>的定义是这样的：对一个不相交路径组 <span class="math inline">\(\mathcal{P}\)</span>，我们每次在 <span class="math inline">\(\mathcal{P}\)</span> 的中间 <span class="math inline">\(c\)</span> 条路径中，在路径内部 （两头端点除外）任选一个顶点 <span class="math inline">\(v\)</span>：</p><ol type="1"><li>如果 <span class="math inline">\(v\)</span> 是一个“山峰”，即形如<span class="math inline">\(\wedge\)</span>，则我们以 1/2 的概率保持<span class="math inline">\(\mathcal{P}\)</span> 不变，以 1/2的概率尝试将 <span class="math inline">\(\mathcal{P}\)</span> 在 <span class="math inline">\(v\)</span> 处翻转为一个“山谷” <span class="math inline">\(\vee\)</span>，如果翻转之后得到的路径组 <span class="math inline">\(\mathcal{P}'\)</span>仍然满足路径之间不相交的约束，则规定 <span class="math inline">\(\mathcal{P}'=f(\mathcal{P})\)</span>，否则仍然保持<span class="math inline">\(\mathcal{P}\)</span> 不变。</li><li>如果 <span class="math inline">\(v\)</span> 是一个“山谷”，即形如<span class="math inline">\(\vee\)</span>，则与上面的情形类似，我们以1/2 的概率保持 <span class="math inline">\(\mathcal{P}\)</span> 不变，以1/2 的概率尝试将 <span class="math inline">\(\mathcal{P}\)</span> 在<span class="math inline">\(v\)</span> 处翻转为一个山峰 <span class="math inline">\(\wedge\)</span>，如果翻转之后得到的路径组满足不相交的约束，则规定<span class="math inline">\(\mathcal{P}'=f(\mathcal{P})\)</span>，否则仍然保持<span class="math inline">\(\mathcal{P}\)</span> 不变。</li><li>如果 <span class="math inline">\(v\)</span>既不是山峰也不是山谷，则保持 <span class="math inline">\(\mathcal{P}\)</span> 不变。</li></ol><p>菱形密铺在三维空间中看起来像是“堆箱子”，这个翻转路径的操作就相当于从中添加/移除一个箱子，并且必须保证这个箱子有三个面可见：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/cftp/flip_lozenge.svg"></p><p>我们来验证 <span class="math inline">\(f\)</span>是和路径组之间的偏序 <span class="math inline">\(\preceq\)</span>相容的：设 <span class="math inline">\(\mathcal{P}\preceq\mathcal{P}'\)</span>是两个不相交路径组，对给定的随机操作 <span class="math inline">\(u\)</span>，<span class="math inline">\(f(\mathcal{P}, u)\)</span> 和 <span class="math inline">\(f(\mathcal{P}', u)\)</span> 就是对 <span class="math inline">\(\mathcal{P}\)</span> 和 <span class="math inline">\(\mathcal{P}'\)</span> 的同一个位置 <span class="math inline">\((k, j)\)</span>（即第 <span class="math inline">\(k\)</span> 条路径中的第 <span class="math inline">\(j\)</span> 个顶点）同时尝试进行一个 <span class="math inline">\(\vee\to\wedge\)</span> 或者 <span class="math inline">\(\wedge\to\vee\)</span> 的操作。不妨假设这个操作是<span class="math inline">\(\vee\to\wedge\)</span>，则有四种可能的结果：<span class="math inline">\(\mathcal{P}\)</span> 和 <span class="math inline">\(\mathcal{P}'\)</span>都操作成功，都保持不变或者一个操作成功另一个保持不变。不难验证这四种情况下都有<span class="math inline">\(f(\mathcal{P},u)\preceq f(\mathcal{P}',u)\)</span>。</p><p>由于每个不相交的路径组都可以通过适当操作变为最大元或者最小元，所以这个链是个互通的Markov 链。并且由于 <span class="math inline">\(\mathcal{P}\)</span>以至少 1/2 的概率在 <span class="math inline">\(f\)</span>下保持不变，这个链还是非周期的，因此是一个遍历的 Markov链，所以有唯一的平稳分布。但是不难看到这个链还是对称的，所以这个唯一的平稳分布是均匀分布。即从最大元和最小元出发跑CFTP，最终得到的样本服从全体菱形密铺上的均匀分布。</p><p>Monotone CFTP 也可以应用在其它许多密铺问题的均匀采样中，例如下图是在<span class="math inline">\(20\times 20\)</span>的矩形区域的所有多米诺骨牌密铺中均匀采样，同样可以把密铺一一对应到不相交的路径组：</p><p><img style="margin:0px auto;display:block" width="600" src="/images/cftp/domino_tiling_example.svg"></p><h1 id="参考文献">参考文献</h1><ol type="1"><li>Finite Markov chains and algorithmic applications, OlleHäggström.</li><li><a href="https://pages.uoregon.edu/dlevin/MARKOV/mcmt2e.pdf">Markovchains and mixing times</a>, Yuval Peres, Elizabeth L. Wilmer, David A.Levin.</li><li><a href="https://www.researchgate.net/publication/2455641_Markov_Chain_Algorithms_for_Planar_Lattice_Structures">MarkovChain Algorithms for Planar Lattice Structures</a>, Michael Luby, DanaRandall, Alistair Sinclair.</li><li><a href="https://arxiv.org/abs/math/0102193">Mixing times of lozengetiling and card shuffling Markov chains</a>, David B. Wilson.</li></ol>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter element</title>
      <link href="coxeter-element/"/>
      <url>coxeter-element/</url>
      
        <content type="html"><![CDATA[<p>如果你对 Lie 代数有所了解的话，相信很大概率你会见过下面的图案： (参考维基百科的 <a href="https://en.wikipedia.org/wiki/Lie_algebra">Liealgebra 词条</a> )</p><p><img style="margin:0px auto;display: block" src="/images/coxeter-element/e8.svg" width="350"></p><p>它展示的是 Lie 代数 <span class="math inline">\(E_8\)</span>的根系图。<span class="math inline">\(E_8\)</span> 的根系由 8 维欧式空间<span class="math inline">\(\mathbb{R}^8\)</span> 中的 240个向量组成，将这 240 个向量投影到一个特殊的 2 维平面 ( 叫做 Coxeter 平面) 上就会呈现出一个具有旋转对称的图案。在上图中可以看到，240个投影点分布在 8 个圆周上，每个圆周包含 30个均匀分布的点，整个图案在角度为 <span class="math inline">\(\frac{2\pi}{30}\)</span> 的旋转下是不变的。<span class="math inline">\(h=30\)</span> 正是 <span class="math inline">\(E_8\)</span> 的 Coxeter 数。</p><p>本文目的是介绍 Coxeter 元的一些基础知识，然后教大家怎样在 Python中编写一个程序绘制上面的投影图案。我主要参考了 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990</a>)</span> 和 <span class="citation" data-cites="CasselmanCoxeterElement">(<a href="#ref-CasselmanCoxeterElement" role="doc-biblioref">Casselman2017</a>)</span>。虽然这里面涉及的数学并不复杂，但是真正动手编程实现的时候会有一些魔鬼藏在细节中，而这些细节是仅凭念书很难发现的。</p><p>本文的代码在 <a href="https://github.com/neozhaoliang/pywonderland/raw/master/src/misc/E8.py">Github上</a> 。David Madore 也有一个很棒的 <a href="http://www.madore.org/~david/math/e8w.html">交互式网页</a>可以绘制 <span class="math inline">\(E_8\)</span>的多种不同风格的图案。</p><span id="more"></span><h1 id="coxeter-元">Coxeter 元</h1><p>在本文中，<span class="math inline">\((W,S)\)</span>总代表一个有限不可约 Coxeter 群，其中 <span class="math inline">\(|S|=n\)</span>。<span class="math inline">\(S\)</span> 中的生成元满足关系</p><ol type="1"><li>对任何 <span class="math inline">\(s\in S\)</span> 有 <span class="math inline">\(s^2=1\)</span>。</li><li>对任何 <span class="math inline">\(s_i,s_j\in S\)</span> 有 <span class="math inline">\((s_is_j)^{m_{ij}}=1\)</span>。其中 <span class="math inline">\(m_{ij}\geq 2\)</span> 是正整数。</li></ol><p>设 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(n\)</span> 维实向量空间，<span class="math inline">\(\Delta=\{\alpha_1,\ldots,\alpha_n\}\)</span> 是<span class="math inline">\(V\)</span> 的一组基，<span class="math inline">\(\Delta\)</span> 叫做一组单根。定义 <span class="math inline">\(V\)</span> 上的内积 <span class="math inline">\(\bullet\)</span> 如下： <span class="math display">\[\alpha_i\bullet\alpha_j=-\cos\frac{\pi}{m_{ij}}.\]</span><span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, secs.6.2–6.4</a>)</span> 中证明了 <span class="math inline">\(( W,S)\)</span> 是有限群当且仅当内积 <span class="math inline">\(\bullet\)</span> 是正定的。</p><p>矩阵 <span class="math inline">\(A= ( a_{ij} )_{1\leq i,j\leq n}= (\alpha_i\bullet\alpha_j )_{1\leq i,j\leq n}\)</span> 叫做 Cartan矩阵。</p><p>规定每个生成元 <span class="math inline">\(s_i\in S\)</span> 在 <span class="math inline">\(V\)</span> 上的作用为 <span class="math display">\[s_i ( v ) = v - 2 ( v\bullet\alpha_i )\alpha_i,\quad v\in V.\]</span> 即 <span class="math inline">\(s_i\)</span> 是关于以 <span class="math inline">\(\alpha_i\)</span>为法向量的超平面的反射。这个作用将 <span class="math inline">\(W\)</span> 同构地映射为 <span class="math inline">\(O ( V )\)</span> 的一个有限反射子群。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{i_1,i_2,\ldots,i_n\}\)</span> 是集合 <span class="math inline">\(\{1,2,\ldots,n\}\)</span> 的一个置换，乘积 <span class="math inline">\(s_{i_1}s_{i_2}\cdots s_{i_n}\)</span> 叫做<strong>Coxeter 元</strong>。</p></div><p>换句话说，Coxeter 元就是把 <span class="math inline">\(W\)</span>的生成元 <span class="math inline">\(s_1,\ldots,s_n\)</span>按照任意顺序排列，然后相乘得到的群元素。</p><div id="coxeter-conjugate" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span> <span class="statement-info">(<span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.3.16</a>)</span>)</span>.</span><span class="statement-spah"></span>所有 Coxeter 元都是互相共轭的。</p></div><p>由于 Coxeter元都是共轭的，所以它们有相同的阶、特征多项式和特征值。任一 Coxeter元的阶叫做 <span class="math inline">\(W\)</span> 的 <strong>Coxeter数</strong>，记作 <span class="math inline">\(h\)</span>。</p><p>设 <span class="math inline">\(\gamma\)</span> 是一个 Coxeter元，由于 <span class="math inline">\(\gamma\)</span> 满足 <span class="math inline">\(\gamma^h=1\)</span>，所以 <span class="math inline">\(\gamma\)</span> 的特征值必然都是 <span class="math inline">\(h\)</span>- 次单位根，而且复特征值成对共轭出现：<span class="math display">\[\{\zeta^{m_1},\ldots,\zeta^{m_n},0\leqm_i&lt;h\}.\]</span> 其中 <span class="math inline">\(\zeta\)</span>是本原 <span class="math inline">\(h\)</span>- 次单位根。在 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec. 3.16</a>)</span> 中证明了 1不可能是 <span class="math inline">\(\gamma\)</span>的特征值，所以实际上每个指数 <span class="math inline">\(1\leqm_i&lt;h\)</span>。<span class="math inline">\(\gamma\)</span>如果有实特征值的话只可能是 <span class="math inline">\(-1\)</span>( 对应<span class="math inline">\(\zeta^{h/2}\)</span> ) 。</p><p>我们选择一个特殊的 Coxeter 元如下：任取 <span class="math inline">\(\Gamma\)</span> 的一个顶点作为 <span class="math inline">\(s_n\)</span>，将 <span class="math inline">\(\Gamma\)</span> 的顶点按照与 <span class="math inline">\(s_n\)</span> 的图距离分成两个不相交的集合 <span class="math inline">\(\Gamma=I\sqcup J\)</span>：<span class="math inline">\(I\)</span> 由所有与 <span class="math inline">\(s_n\)</span> 的距离为偶数的顶点组成（包含 <span class="math inline">\(s_n\)</span>）；<span class="math inline">\(J\)</span> 由所有与 <span class="math inline">\(s_n\)</span> 的距离为奇数的顶点组成。于是 <span class="math inline">\(I\)</span> 中的顶点两两不相邻，从而 <span class="math inline">\(\{s_i,i\in I\}\)</span> 中的生成元两两交换。<span class="math inline">\(J\)</span> 也是如此。记 <span class="math display">\[x=\prod_{i\in I}s_i,\quad y=\prod_{j\inJ}s_j.\]</span> 取 Coxeter 元 <span class="math inline">\(\gamma=xy\)</span>。我们下面对 <span class="math inline">\(\gamma\)</span> 进行分析。</p><h1 id="coxeter-平面">Coxeter 平面</h1><p>设 <span class="math inline">\(\{\omega_i\}_{i=1}^n\)</span> 是 <span class="math inline">\(\{\alpha_i\}_{i=1}^n\)</span> 在内积 <span class="math inline">\(\bullet\)</span> 下的对偶基： <span class="math display">\[(\alpha_i\bullet\omega_j)=\delta_{ij}.\]</span><span class="math inline">\({\bf A}\)</span> 是把每个 <span class="math inline">\(\omega_i\)</span> 映射为 <span class="math inline">\(\alpha_i\)</span> 的线性变换： <span class="math display">\[{\bf A}\omega_i=\alpha_i,\quad \forall 1\leqi\leq n.\]</span> 则 <span class="math inline">\({\bf A}\)</span> 在<span class="math inline">\(\{\omega_i\}_{i=1}^n\)</span>这组基下的矩阵就是 Cartan 矩阵 <span class="math inline">\(A\)</span>。</p><p>在 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.2.6</a>)</span> 中证明了矩阵 <span class="math inline">\(A\)</span>的极小特征值 <span class="math inline">\(c&gt;0\)</span> 的重数是1，并且对应的特征向量 <span class="math inline">\({\bfc}=(c_1,\ldots,c_n)\)</span> 的所有分量都是正的。于是 <span class="math display">\[{\bf A}\sum_{i=1}^nc_i\omega_i =c\left(\sum_{i=1}^nc_i\omega_i\right).\]</span> 特征向量 <span class="math inline">\(\sum_{i=1}^nc_i\omega_i\)</span> 可以写成两个向量<span class="math inline">\(\lambda,\mu\)</span> 的和，其中 <span class="math display">\[\lambda=\sum_{i\in I} c_i\omega_i,\quad\mu=\sum_{j\in J}c_j\omega_j.\]</span> <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec. 3.17</a>)</span> 中证明了<span class="math inline">\(\lambda,\mu\)</span> 张成一个二维子空间<span class="math inline">\(P\)</span>，<span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 限制在 <span class="math inline">\(P\)</span> 上分别是保持直线 <span class="math inline">\(\mathbb{R}\mu\)</span> 和 <span class="math inline">\(\mathbb{R}\lambda\)</span> 不动的反射，从而 <span class="math inline">\(\gamma=xy\)</span> 限制在 <span class="math inline">\(P\)</span> 上是一个旋转，并且这个旋转的角度就是<span class="math inline">\(2\pi/h\)</span>。由于 <span class="math inline">\(\gamma\)</span> 置换根系 <span class="math inline">\(\Phi\)</span>，所以如果我们把 <span class="math inline">\(\Phi\)</span> 投影到 <span class="math inline">\(P\)</span> 上，就会看到一个具有 <span class="math inline">\(h\)</span> 阶旋转对称性的图案。</p><p>不过直接使用上面 <span class="math inline">\(\lambda,\mu\)</span>的定义来计算 <span class="math inline">\(P\)</span>是很不方便的，因为其中涉及了对偶基 <span class="math inline">\(\{\omega_i\}\)</span>。我们可以绕开对偶基的计算，这一点其实隐藏在<span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990,78</a>)</span> 中，那里证明了 <span class="math display">\[\begin{aligned}(c-1)\mu+\lambda &amp;=\sum_{i\in I}c_i\alpha_i,\\(c-1)\lambda+\mu &amp;=\sum_{j\in J}c_j\alpha_j.\end{aligned}\]</span></p><p>由于 <span class="math inline">\(c\ne 1\)</span>（1 不是 Coxeter元的特征值），上式告诉我们 <span class="math display">\[P=\mathop{\mathrm{span}}\{\lambda,\,\mu\}=\mathop{\mathrm{span}}\left\{\sum_{i\inI}c_i\alpha_i,\,\sum_{j\inJ}c_j\alpha_j\right\}.\tag{$\ast$}\label{eq:alpha}\]</span>所以我们完全可以通过特征向量 <span class="math inline">\({\bfc}\)</span> 和 <span class="math inline">\(\Delta\)</span> 得出 <span class="math inline">\(P\)</span> 的一组基。</p><h1 id="进一步改进">进一步改进</h1><p>如果你去看 <a href="https://github.com/neozhaoliang/pywonderland/blob/master/src/misc/E8.py">Github代码</a>的话，会发现那里并不是完全按上面的逻辑写的。这是怎么回事呢？</p><p>前面的计算有个美中不足之处，就是我们需要显式地将 <span class="math inline">\(S\)</span> 的划分为两个不相交的子集 <span class="math inline">\(S=I\sqcup J\)</span>，使得 <span class="math inline">\(I,J\)</span>各自的生成元之间互相交换。这一步是可以避免的，下面的方法我是从 <span class="citation" data-cites="CasselmanCoxeterElement">(<a href="#ref-CasselmanCoxeterElement" role="doc-biblioref">Casselman2017</a>)</span> 中学到的。</p><p>我们仍然用 <span class="math inline">\(\gamma\)</span> 表示 <span class="math inline">\(\gamma\)</span> 在 <span class="math inline">\(\{\omega_i\}_{i=1}^n\)</span> 这组基下的矩阵。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.1</span> <span class="statement-info">(<span class="citation" data-cites="CasselmanCoxeterElement">(<a href="#ref-CasselmanCoxeterElement" role="doc-biblioref">Casselman 2017,lemma. 3.3</a>)</span>)</span>.</span><span class="statement-spah"></span><span class="math inline">\(2I + \gamma + \gamma^{-1}= ( 2I-A)^2\)</span>。</p></div><p>根据这个结论，如果 <span class="math inline">\(V_s,V_{\bar{s}}\)</span> 分别是 <span class="math inline">\(\gamma\)</span> 的一对共轭的复特征值 <span class="math inline">\(s=e^{i\theta}\)</span> 和 <span class="math inline">\(\bar{s}=e^{-i\theta}\)</span> 对应的特征子空间，记<span class="math inline">\(U=V_s\oplus V_{\bar{s}}\)</span>，则对 <span class="math inline">\(v\in U\)</span> 有 <span class="math display">\[(2I-A )^2 ( v ) = ( 2+e^{i\theta}+e^{-i\theta} ) v=4\cos^2\frac{\theta}{2} v.\]</span> 即 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(( 2I-A)^2\)</span> 的特征值为 <span class="math inline">\(4\cos^2\frac{\theta}{2}\)</span>的特征子空间。</p><p>我们想把这个结论中的平方去掉，即证明 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(2I-A\)</span> 的特征值为 <span class="math inline">\(\pm 2\cos\frac{\theta}{2}\)</span>的特征子空间的直和。</p><div id="u-pm" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(U=U_+\oplus U_-\)</span>，其中 <span class="math inline">\(U_{\pm}\)</span> 分别是 <span class="math inline">\(2I-A\)</span> 的 <span class="math inline">\(\pm2\cos\frac{\theta}{2}\)</span> 特征子空间，并且<span class="math inline">\(\dim U_+=\dim U_-\)</span>。</p></div><p><strong>证明</strong>：显然 <span class="math inline">\(U_+\oplusU_-\subseteq U\)</span>。下面证明反向包含。</p><p><span class="math inline">\(U\)</span> 当然是 <span class="math inline">\(2I-A\)</span> 的不变子空间。由于 <span class="math inline">\(2I-A\)</span> 是可对角化的，从而 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(2I-A\)</span> 的特征子空间的直和。显然 <span class="math inline">\(2I-A\)</span> 在 <span class="math inline">\(U\)</span> 上的特征值只有可能是 <span class="math inline">\(\pm 2\cos\frac{\theta}{2}\)</span>，从而 <span class="math inline">\(U\subseteq U_+\oplus U_-\)</span>，即 <span class="math inline">\(U=U_+\oplus U_-\)</span>。</p><p>为了说明 <span class="math inline">\(\dim U_+=\dimU_-\)</span>，我们需要下面的引理：</p><div id="same-characteristic" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.3</span> <span class="statement-info">(<span class="citation" data-cites="CasselmanCoxeterElement">(<a href="#ref-CasselmanCoxeterElement" role="doc-biblioref">Casselman 2017,lemma. 3.5</a>)</span>)</span>.</span><span class="statement-spah"></span><span class="math inline">\(2I-A\)</span> 和 <span class="math inline">\(A-2I\)</span> 有同样的特征多项式。</p></div><p>这个引理告诉我们，若 <span class="math inline">\(\lambda\)</span> 是<span class="math inline">\(A-2I\)</span> 的特征值，则 <span class="math inline">\(-\lambda\)</span>也是，并且二者对应的特征子空间的维数相同（注意 <span class="math inline">\(A-2I\)</span> 是可对角化的）。于是 <span class="math inline">\(\dim U_+=\dim U_-\)</span>。<span class="math inline">\(\blacksquare\)</span>。</p><p>现在我们抛弃 <span class="math inline">\(2I-A\)</span>，注意 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(A\)</span> 的特征值为 <span class="math inline">\(2\pm2\cos\frac{\theta}{2}\)</span>的特征子空间的直和。</p><p>一般来说 <span class="math inline">\(U\)</span> 的维数未必是 2，所以<span class="math inline">\(U\)</span> 未必是一个平面。但是假设 <span class="math inline">\(c=2-2\cos\frac{\theta_0}{2}\)</span> 是 <span class="math inline">\(A\)</span> 的极小特征值，我们知道 <span class="math inline">\(c\)</span> 的重数是 1，从而 <span class="math inline">\(A\)</span> 的极大特征值 <span class="math inline">\(d=2+2\cos\frac{\theta_0}{2}\)</span> 的重数也是1，这时 <span class="math inline">\(U\)</span> 是二维平面。<span class="math inline">\(\gamma\)</span> 在 <span class="math inline">\(U\)</span> 上的作用是角度为 <span class="math inline">\(\theta_0\)</span> 的旋转。这个 <span class="math inline">\(U\)</span> 就是 Coxeter 平面 <span class="math inline">\(P\)</span>。</p><p>于是计算 <span class="math inline">\(P\)</span> 归结为计算线性变换<span class="math inline">\({\bf A}\)</span> 在 <span class="math inline">\(\{\omega_i\}_{i=1}^n\)</span>这组基下极小/极大特征值对应的特征向量。设 <span class="math inline">\((c_1,\ldots,c_n)\)</span> 和 <span class="math inline">\((d_1,\ldots,d_n)\)</span> 分别是矩阵 <span class="math inline">\(A\)</span> 对应 <span class="math inline">\(c,d\)</span> 的特征向量，不难验证 <span class="math inline">\(\sum_{i=1}^nc_i\alpha_i\)</span> 和 <span class="math inline">\(\sum_{i=1}^nd_i\alpha_i\)</span>就是所求。比如由于 <span class="math display">\[\sum_{i=1}^nc_i\alpha_i={\bfA}\left(\sum_{i=1}^nc_i\omega_i\right)=c\sum_{i=1}^nc_i\omega_i.\]</span>所以 <span class="math display">\[{\bfA}\left(\sum_{i=1}^nc_i\alpha_i\right)={\bfA}\left(c\sum_{i=1}^nc_i\omega_i\right)=c\sum_{i=1}^nc_i\alpha_i.\]</span>同理 <span class="math inline">\({\bfA}\left(\sum\limits_{i=1}^nd_i\alpha_i\right)=d\sum\limits_{i=1}^nd_i\alpha_i\)</span>。所以<span class="math display">\[P=\mathop{\mathrm{span}}\left\{\sum_{i=1}^nc_i\alpha_i,\,\sum_{i=1}^nd_i\alpha_i\right\}.\]</span>这样我们就找到了只用 Cartan 矩阵和 <span class="math inline">\(\Delta\)</span> 计算 <span class="math inline">\(P\)</span> 的方法。</p><h1 id="e_8-的例子"><span class="math inline">\(E_8\)</span> 的例子</h1><p><span class="math inline">\(E_8\)</span> 的 Coxeter 图如下：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter-element/e8-dynkin.svg" width="400"></p><p>单根系 <span class="math inline">\(\Delta\)</span>的选择不是唯一的，我们采用如下的选择，使得 <span class="math inline">\(\bullet\)</span> 就是 Euclidean 标准内积： <span class="math display">\[\Delta=\begin{bmatrix}1&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\0&amp;1&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;-1&amp;0&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;1&amp;-1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;0&amp;1&amp;-1&amp;0&amp;0\\0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;1&amp;0\\-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}\\0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;-1&amp;0\end{bmatrix}.\]</span>Coxeter 图中编号为 <span class="math inline">\(i\)</span>的顶点对应的单根 <span class="math inline">\(\alpha_i\)</span>是矩阵的第 <span class="math inline">\(i\)</span>行。注意每个单根的长度是 <span class="math inline">\(\sqrt{2}\)</span>，并不是单位向量，这样主要是为了书写代码更方便。</p><p>Cartan 矩阵 <span class="math inline">\(A\)</span>由单根之间两两内积给出： <span class="math display">\[A=(\alpha_i\bullet\alpha_j)_{1\leq i,j\leq8}=\begin{pmatrix}2&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\-1&amp;2&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0\\0&amp;-1&amp;2&amp;-1&amp;0&amp;0&amp;0&amp;0\\0&amp;0&amp;-1&amp;2&amp;-1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;-1&amp;2&amp;-1&amp;0&amp;-1\\0&amp;0&amp;0&amp;0&amp;-1&amp;2&amp;-1&amp;0\\0&amp;0&amp;0&amp;0&amp;0&amp;-1&amp;2&amp;0\\0&amp;0&amp;0&amp;0&amp;-1&amp;0&amp;0&amp;2\end{pmatrix}.\]</span></p><p>用代码来写的话，就是</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># A set of simple roots listed by rows of 'delta'</span><br>delta = np.array([<br>    [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>    [-<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>])<br><br><span class="hljs-comment"># The cartan matrix:</span><br>cartan = np.dot(delta, delta.transpose())<br></code></pre></td></tr></tbody></table></figure><p>所有单反射 <span class="math inline">\(\{s_i\}_{i=1}^8\)</span>生成的群 <span class="math inline">\(W\)</span> 叫做 <span class="math inline">\(E_8\)</span> 的 Weyl 群，这个群包含 696729600个元素。单根系在 <span class="math inline">\(W\)</span> 作用下生成的集合<span class="math inline">\(\Phi = \{w\cdot\alpha\,|\, w\in W,\alpha\in\Delta\}\)</span> 叫做 <span class="math inline">\(E_8\)</span>的根系，<span class="math inline">\(\Phi\)</span> 中包含 240个不同的向量，<span class="math inline">\(W\)</span> 置换 <span class="math inline">\(\Phi\)</span> 中的向量。</p><p><span class="math inline">\(\Phi\)</span>中的向量从形式上看分为两类：</p><ol type="1"><li>第一类包含 <span class="math inline">\((\pm1,\pm1,0,0,0,0,0,0)\)</span>的所有置换，即有两个分量是 <span class="math inline">\(+1\)</span> 或者<span class="math inline">\(-1\)</span>，其余６个分量都是 0的向量。这样的向量有 112 个。</li><li>第二类包含所有形如 <span class="math inline">\(1/2\times(\pm1,\pm1,\cdots,\pm1)\)</span>的向量，其中 <span class="math inline">\(-1\)</span>的个数是偶数。这样的向量有 128 个。</li></ol><p>为了编程方便，我们可以把所有根都乘以2，使得它们都是整数向量。于是生成根系 <span class="math inline">\(\Phi\)</span> 的代码可以这样写：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br>roots = []<br><br><span class="hljs-comment"># Roots of the form (+-1, +-1, 0, 0, 0, 0, 0, 0),</span><br><span class="hljs-comment"># signs can be chosen independently and the two non-zeros can be anywhere.</span><br><span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> combinations(<span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>), <span class="hljs-number">2</span>):<br>    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> product([-<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], repeat=<span class="hljs-number">2</span>):<br>        v = np.zeros(<span class="hljs-number">8</span>)<br>        v[i] = x<br>        v[j] = y<br>        roots.append(v)<br><br><span class="hljs-comment"># Roots of the form 1/2 * (+-1, +-1, ..., +-1), signs can be chosen</span><br><span class="hljs-comment"># indenpendently except that there must be an even numer of -1s.</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> product([-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], repeat=<span class="hljs-number">8</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(v) % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>:<br>        roots.append(v)<br>roots = np.array(roots).astype(<span class="hljs-built_in">int</span>)<br><br><span class="hljs-comment"># Connect a root to its nearest neighbors,</span><br><span class="hljs-comment"># two roots are connected if and only if they form an angle of pi/3.</span><br>edges = []<br><span class="hljs-keyword">for</span> i, r <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(roots):<br>    <span class="hljs-keyword">for</span> j, s <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(roots[i + <span class="hljs-number">1</span> :], i + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">sum</span>((r - s) ** <span class="hljs-number">2</span>) == <span class="hljs-number">8</span>:<br>            edges.append([i, j])<br></code></pre></td></tr></tbody></table></figure><p>我们来计算 Coxeter 平面 <span class="math inline">\(P\)</span>的一组基。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">eigenvals, eigenvecs = np.linalg.eigh(cartan)<br>u = eigenvecs[:, <span class="hljs-number">0</span>]<br>v = eigenvecs[:, -<span class="hljs-number">1</span>]<br><br>u = np.dot(u, delta)<br>v = np.dot(v, delta)<br></code></pre></td></tr></tbody></table></figure><p>其中 <code>eigenvals</code> 返回 Cartan矩阵的特征值，按照从小到大排列；<code>eigenvecs</code> 的列向量是 Cartan矩阵的特征向量，也是按照特征值递增的顺序排列，第一列<code>u = eigenvecs[:, 0]</code> 和最后一列<code>v = eigenvecs[:, -1]</code>就是最小和最大特征值对应的特征向量。</p><p>把 <code>eigenvals</code> 中的特征值打印出来：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">0.01095621</span> <span class="hljs-number">0.51371035</span> <span class="hljs-number">1.18652671</span> <span class="hljs-number">1.58417662</span> <span class="hljs-number">2.41582338</span> <span class="hljs-number">2.81347329</span> <span class="hljs-number">3.48628965</span> <span class="hljs-number">3.98904379</span>]<br></code></pre></td></tr></tbody></table></figure><p>可以看到最小的特征值 <span class="math display">\[0.01095621 \approx2-2\cos\frac{\theta_0}{2},\quad \theta_0\approx2\arccos0.994521895\approx\frac{2\pi}{30}.\]</span> 所以我们验证了 <span class="math inline">\(\gamma\)</span> 在 <span class="math inline">\(P\)</span> 上的作用是一个 30 阶的旋转，即 <span class="math inline">\(W\)</span> 的 Coxeter 数是 30。</p><p>根据上一节末尾的介绍，<span class="math inline">\(\sum_{i=1}^8u_i\alpha_i\)</span> 和 <span class="math inline">\(\sum_{i=1}^8v_i\alpha_i\)</span> 构成 <span class="math inline">\(P\)</span> 的一组基。作为对称矩阵 <span class="math inline">\(A\)</span> 的不同特征值对应的特征向量，它们在<span class="math inline">\(\bullet\)</span>（即标准内积）下是正交的。把它们归一化为单位向量，然后计算根系<code>roots</code> 到 <span class="math inline">\(P\)</span>的投影：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">u /= np.linalg.norm(u)<br>v /= np.linalg.norm(v)<br><br>roots_2d = [(np.dot(u, x), np.dot(v, x)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> roots]<br></code></pre></td></tr></tbody></table></figure><p>剩下的就是具体的绘图过程了，这里不再赘述。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-CasselmanCoxeterElement" class="csl-entry" role="listitem">Casselman, Bill. 2017. <span>“Coxeter Elements in Finite CoxeterGroups”</span> Essays on Coxeter groups. <a href="https://personal.math.ubc.ca/~cass/research/pdf/Element.pdf">https://personal.math.ubc.ca/~cass/research/pdf/Element.pdf</a>.</div><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div></div>]]></content>
      
      
      <categories>
          
          <category> pywonderland 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Birkhoff 遍历定理</title>
      <link href="Birkhoff-ergodic-theorem/"/>
      <url>Birkhoff-ergodic-theorem/</url>
      
        <content type="html"><![CDATA[<p>我念研究生时的高等概率论课用的是 Durrett 的教材 “Probability: TheoryandExamples”。这本书的好处我就不再介绍了，院长陈大岳老师在世图影印版的前言中已经夸了一遍。我个人的体会是，Durrett的书在讲解证明的时候非常简练，很少写为什么要这样证，我有时候读了半天也没搞明白思路。Birkhoff遍历定理算是其中一个，于是我重新整理了一下书中的证明，作此文留念。</p><p>Birkhoff 遍历定理最初由 Birkhoff 本人在 1931 年发表，原文长达 50页。随后在 1939 年 K.Yosida （吉田耕作） 和 S.Kakutani （角谷）利用极大遍历定理给出了一个 10页的简洁证明，不过他们关于极大遍历定理的证明还是啰嗦了点，后来 Garsia给出了极大遍历定理的一个仅有寥寥数行的惊人证明，这也是当前大多数教材采用的途径，本文就来介绍这一证明。</p><span id="more"></span><h1 id="准备工作">准备工作</h1><p>给定一个概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span>，我们称两个可测集<span class="math inline">\(A,B\in F\)</span>几乎处处相等，是指它们的示性函数 <span class="math inline">\(\mathbb{1}_A,\mathbb{1}_B\)</span>几乎处处相等，记作 <span class="math inline">\(A\stackrel{\mathrm{a.e.}}{=}B\)</span>。等价的说法是<span class="math inline">\(A,B\)</span> 只差一个零测集，或者差集 <span class="math inline">\(A\Delta B\)</span> 是零测集。</p><p>设 <span class="math inline">\(T:\Omega\rightarrow \Omega\)</span>是一个可测变换，即对任何 <span class="math inline">\(E\in\mathcal{F}\)</span> 有 <span class="math inline">\(T^{-1}E\in\mathcal{F}\)</span>。</p><div id="def-1" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>如果可测集 <span class="math inline">\(E\)</span> 满足 <span class="math inline">\(T^{-1}E\stackrel{\mathrm{a.e.}}{=}E\)</span>，就称<span class="math inline">\(E\)</span> 是一个 <span class="math inline">\(T-\)</span> 不变集合。不难验证所有的 <span class="math inline">\(T-\)</span> 不变集合 <span class="math display">\[\mathcal{I}=\{E\in\mathcal{F}\ |\T^{-1}E\stackrel{\mathrm{a.e.}}{=}E\}\]</span> 构成 <span class="math inline">\(\mathcal{F}\)</span> 的一个子 <span class="math inline">\(\sigma-\)</span> 代数。</p></div><div id="def-2" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.2</span>.</span><span class="statement-spah"> </span>如果对任何可测集<span class="math inline">\(E\in\mathcal{F}\)</span> 有 <span class="math inline">\(\mu(T^{-1}E)=\mu(E)\)</span>，就称 <span class="math inline">\(T\)</span> 是一个保测变换。</p></div><p>在本文中，<span class="math inline">\(T\)</span>始终代表一个保测变换。</p><p>保测变换有如下性质：</p><div id="lemma-1" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(f\in L^1(\Omega)\)</span>是一个可积的随机变量，<span class="math inline">\(T\)</span>是保测变换，则 <span class="math display">\[\int_\Omegaf\,\mathrm{d}\mu=\int_\Omega f\circ T\,\mathrm{d}\mu.\]</span></p></div><p><strong>证明</strong>：若 <span class="math inline">\(E\in\mathcal{F}\)</span> 是可测集，由于 <span class="math display">\[\omega\in T^{-1}E\Leftrightarrow T(\omega)\inE\Leftrightarrow(\mathbb{1}_E\circ T) (\omega)=1.\]</span> 所以 <span class="math inline">\(\mathbb{1}_{E}\circT=\mathbb{1}_{\{T^{-1}E\}}\)</span>，因此 <span class="math display">\[\int_\Omega\mathbb{1}_E\,\mathrm{d}\mu=\mu(E)=\mu(T^{-1}E)=\int_\Omega\mathbb{1}_{\{T^{-1}E\}}\,\mathrm{d}\mu=\int_\Omega \mathbb{1}_E\circT\,\mathrm{d}\mu.\]</span>从而结论对集合的示性函数成立，进一步由积分的线性性质对任何简单函数也成立，再取极限即得对一般的可积函数结论成立。</p><div id="lemma-2" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.4</span>.</span><span class="statement-spah"> </span>一个 <span class="math inline">\(\Omega\)</span> 上的随机变量 <span class="math inline">\(X\)</span> 关于 <span class="math inline">\(\mathcal{I}\)</span> 可测，当且仅当有 <span class="math display">\[X\circ T=X\quad \text{a.e.}\]</span>成立。这时我们称 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(T-\)</span> 不变的随机变量。</p></div><p>这是 Durrett书中的一道习题，我一直觉得它很平凡，其实之前的处理有问题，这个结论还是需要论证一番的。</p><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>：如果 <span class="math inline">\(X\)</span> 关于 <span class="math inline">\(\mathcal{I}\)</span> 可测，则对任何 Borel 集 <span class="math inline">\(B\in\mathcal{B}(\mathbb{R}^1)\)</span> 有 <span class="math inline">\(X^{-1}B\in\mathcal{I}\)</span>，即 <span class="math inline">\(T^{-1}(X^{-1}B)\stackrel{\mathrm{a.e.}}{=}X^{-1}B\)</span>，这说明<span class="math inline">\(\{X\circ T\inB\}\stackrel{\mathrm{a.e.}}{=}\{X\in B\}\)</span>。特别地取 <span class="math inline">\(B=(-\infty, t)\)</span> 我们得到 <span class="math inline">\(\{X\circT&lt;t\}\stackrel{\mathrm{a.e.}}{=}\{X&lt;t\}\)</span>。所以只要证明如果<span class="math inline">\(\xi,\,\eta\)</span>是两个可测函数且对任何实数 <span class="math inline">\(t\)</span> 有<span class="math inline">\(\{\xi&lt;t\}\stackrel{\mathrm{a.e.}}{=}\{\eta&lt;t\}\)</span>，则<span class="math inline">\(\xi=\eta,\,\mathrm{a.e.}\)</span>即可。若不然，不妨设 <span class="math inline">\(\{\xi&gt;\eta\}\)</span> 具有正测度，则存在有理数<span class="math inline">\(c\)</span> 使得集合 <span class="math inline">\(\{\xi&gt;c&gt;\eta\}\)</span>具有正测度，这个集合在 <span class="math inline">\(\{\eta&lt;c\}\)</span> 中，但是不在 <span class="math inline">\(\{\xi&lt;c\}\)</span> 中，这与 <span class="math inline">\(\{\eta&lt;c\}\)</span> 和 <span class="math inline">\(\{\xi&lt;c\}\)</span> 只差一个零测集矛盾。</p><p><span class="math inline">\(\Leftarrow\)</span>：如果 <span class="math inline">\(X\circ T=X\)</span> 几乎处处成立，则对任何 <span class="math inline">\(B\in\mathcal{B}(\mathbb{R}^1)\)</span> 有 <span class="math inline">\(X^{-1}B\stackrel{\mathrm{a.e.}}{=}T^{-1}X^{-1}B\)</span>，这说明<span class="math inline">\(X^{-1}B\in\mathcal{I}\)</span>，即 <span class="math inline">\(X\)</span> 关于 <span class="math inline">\(\mathcal{I}\)</span> 可测。</p><h1 id="birkhoff-遍历定理">Birkhoff 遍历定理</h1><p>设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\Omega\)</span> 上的随机变量，对每个整数 <span class="math inline">\(n\geq 1\)</span>，令 <span class="math display">\[S_n(\omega)= \sum_{k=0}^{n-1}f(T^k(\omega)).\]</span> 我们有如下的定理：</p><div id="birkhoff" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span>（Birkhoff遍历定理）</p><p>设 <span class="math inline">\(T\)</span> 是概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span>上的保测变换，则对任何 <span class="math inline">\(f\inL^1(\Omega)\)</span> 有 <span class="math display">\[\lim_{n\to\infty}\frac{S_n}{n}\rightarrow\mathbb{E}[f\,|\,\mathcal{I}]\quad\text{a.e.}\]</span></p></div><p>证明 Birkhoff遍历定理定理的关键是证明如下的极大遍历定理：（极大遍历定理这个名字来源于分析中的Hardy-Littlewood 极大函数，这一类的不等式统称为极大不等式）</p><div id="max-ergodic" class="statement sta_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">极大遍历定理</span>.</span><span class="statement-spah"> </span>定义极大算子 <span class="math display">\[M_f(\omega)=\sup_{n\geq1}\frac{1}{n}S_n(\omega),\]</span> 则对 <span class="math inline">\(f\inL^1(\Omega)\)</span> 和任一 <span class="math inline">\(a\in\mathbb{R}\)</span>，有 <span class="math display">\[\int_{\{M_f&gt;a\}} f\,\mathrm{d}\mu\geqa\mu(\{M_f&gt;a\}).\]</span></p></div><p>极大遍历定理是整个 Birkhoff遍历定理的证明中最不直观的部分，而且我也确实不知道怎么解释引入它的动机。我第一次看到这个式子的时候是很懵的。一个直观的理解是，观察下面这个显然成立的不等式：<span class="math display">\[\int_{\{M_f&gt;a\}} M_f\,\mathrm{d}\mu\geqa\mu(\{M_f&gt;a\}).\]</span> 极大遍历定理是说把其中的积分函数换成 <span class="math inline">\(f\)</span>，积分范围保持不变的话，不等式仍然成立。</p><p>我把极大遍历定理的证明放在最后，先用它来证明 Birkhoff 遍历定理。</p><h1 id="birkhoff-遍历定理的证明">Birkhoff 遍历定理的证明</h1><p>首先可以假定条件期望 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]=0\)</span>，若不然，我们可以以<span class="math inline">\(f-\mathbb{E}[f\,|\,\mathcal{I}]\)</span>代替 <span class="math inline">\(f\)</span>，注意到 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]\)</span> 是 <span class="math inline">\(T-\)</span> 不变的，所以根据上面的 <a href="#lemma-2" title="引理 1.4">引理 1.4</a> 有 <span class="math display">\[\mathbb{E}[f\,|\,\mathcal{I}]\circ T^k =\mathbb{E}[f\,|\,\mathcal{I}],\quad \mathrm{a.e.}\]</span>对所有的正整数 <span class="math inline">\(k\)</span> 都成立，这时 <a href="#birkhoff" title="定理 2.1">定理 2.1</a> 的左边 <span class="math inline">\(S_n\)</span> 中每一项都会多出来一个 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]\)</span>，除以 <span class="math inline">\(n\)</span> 正好和右边的 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]\)</span>抵消掉。</p><p>这样问题变成在 <span class="math inline">\(\mathbb{E}[f\,|\,\mathcal{I}]=0\)</span>的前提下证明 <span class="math display">\[\lim\limits_{n\to\infty}\frac{S_n}{n}=0.\quad\text{a.e.}\]</span> 设 <span class="math inline">\(a\)</span>是任一正数，考虑集合 <span class="math display">\[A= \left\{\omega \mid\varlimsup_{n\to\infty}\frac{S_n}{n}&gt;a\right\}.\]</span> 我们想证明<span class="math inline">\(\mu(A)=0\)</span>。若真如此，则有 <span class="math inline">\(\varlimsup\limits_{n\to\infty}S_n/n\leq a\)</span>几乎处处成立，根据 <span class="math inline">\(a\)</span> 的任意性就得到<span class="math inline">\(\varlimsup\limits_{n\to\infty}S_n/n\leq0\)</span> 几乎处处成立。再把这个结果用在 <span class="math inline">\(-f\)</span> 上就得到 <span class="math inline">\(\varliminf\limits_{n\to\infty}S_n/n\geq 0\)</span>也几乎处处成立，这样就证明了 <span class="math inline">\(\lim\limits_{n\to\infty}S_n/n=0\)</span>几乎处处成立。（拗口）</p><p>为了证明 <span class="math inline">\(\mu(A)=0\)</span>，我们希望对函数 <span class="math inline">\(f\)</span> 和集合 <span class="math inline">\(A\)</span> 应用极大不等式： <span class="math display">\[\int_A f\,\mathrm{d}\mu\geq a\mu(A).\]</span>这是因为，<span class="math inline">\(A\)</span> 其实是一个 <span class="math inline">\(T-\)</span> 不变的集合，即 <span class="math inline">\(A\in\mathcal{I}\)</span>，我们会在证明末尾再验证这一点。于是根据条件期望的性质，上式的左边其实是0： <span class="math display">\[\int_A f\,\mathrm{d}\mu = \int_A\mathbb{E}[f\,|\,\mathcal{I}]\,\mathrm{d}\mu =0.\]</span> 即 <span class="math inline">\(0\geq a\mu(A)\)</span>，结合 <span class="math inline">\(a&gt;0\)</span> 即得 <span class="math inline">\(\mu(A)=0\)</span>。</p><p>但是，我们能对 <span class="math inline">\(A\)</span>使用极大不等式吗？请注意 <span class="math inline">\(\varlimsup\limits_{n\to\infty}\)</span> 和 <span class="math inline">\(\sup\limits_{n\geq 1}\)</span>的区别，它们定义的是两个不同的随机变量。<span class="math inline">\(A\)</span> 是用 <span class="math inline">\(\varlimsup\limits_{n\to\infty}\)</span>定义的，而极大遍历定理中说的是 <span class="math inline">\(\sup\limits_{n\geq 1}\)</span>。注意到 <span class="math display">\[A=\left\{\varlimsup_{n\to\infty}\frac{S_n}{n}&gt;a\right\}\subseteq\left\{\sup_{n\geq 1}\frac{S_n}{n}&gt;a\right\}=\left\{M_f&gt;a\right\},\]</span> 所以只要证明这样一个结论就好了：</p><blockquote><p>设 <span class="math inline">\(A\subseteq \{M_f&gt;a\}\)</span> 而且<span class="math inline">\(A\)</span> 是一个 <span class="math inline">\(T-\)</span> 不变集合，那么极大遍历定理仍然成立：<span class="math display">\[\int_A f\,\mathrm{d}\mu\geqa\mu(A).\]</span></p></blockquote><p>而这只要对函数 <span class="math inline">\(g=f\cdot\mathbb{1}_A\)</span>应用极大遍历定理即可： <span class="math display">\[\int_{\{M_g&gt;a\}}f\cdot\mathbb{1}_A\,\mathrm{d}\mu\geq a\mu(\{M_g&gt;a\}).\]</span> 但是<span class="math inline">\(M_g=M_f\cdot\mathbb{1}_A\)</span>，这一点要用到<span class="math inline">\(A\)</span> 是 <span class="math inline">\(T-\)</span> 不变集合这个条件，因此 <span class="math display">\[\{M_g&gt;a\}=\{M_f&gt;a\}\cap A=A.\]</span>因此确实有 <span class="math display">\[\int_Af\,\mathrm{d}\mu\geq a \mu(A),\]</span> 这样就证明了 Birkhoff遍历定理。</p><p>实际上定理中的收敛也是一个依 <span class="math inline">\(L^1\)</span>范数的收敛，这点的证明相比几乎处处收敛就容易多了，这里不再赘述。</p><p>好了，我们来验证上面提到的 <span class="math inline">\(A\)</span>确实是 <span class="math inline">\(T-\)</span> 不变的：</p><p>利用 <span class="math inline">\(S_{n+1} = f + S_n\circ T\)</span>可得 <span class="math display">\[\frac{S_{n+1}}{n+1} = \frac{f}{n+1} +\frac{S_n\circ T}{n}\cdot \frac{n}{n+1}.\]</span>在两边同时取上极限，注意到由于 <span class="math inline">\(f\inL^1(\Omega)\)</span> 所以 <span class="math inline">\(f\)</span>几乎处处有限，从而 <span class="math display">\[\lim_{n\to\infty}\frac{f}{n+1}=0,\quad\text{a.e.}\]</span> 所以 <span class="math display">\[\varlimsup_{n\to\infty} \frac{S_{n+1}}{n+1} =\varlimsup_{n\to\infty}\frac{S_{n}\circ T}{n}.\]</span> 这正说的是 <span class="math inline">\(\varlimsup\limits_{n\to\infty}S_n/n\)</span> 是<span class="math inline">\(T-\)</span> 不变的随机变量，从而 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(T-\)</span> 不变的集合。</p><p>最后来证明极大遍历定理。</p><h1 id="极大遍历定理的证明">极大遍历定理的证明</h1><p>只要证明 <span class="math inline">\(a=0\)</span>的情形，然后对一般的 <span class="math inline">\(a\)</span>，将结论应用在函数 <span class="math inline">\(f-a\)</span> 上即可。定义 <span class="math inline">\(S_0=0\)</span> 以及 <span class="math inline">\(M_n =\max\{S_0,S_1,\cdots,S_n\}\)</span>。对每个<span class="math inline">\(k=1,\ldots,n\)</span> 有 <span class="math display">\[S_k=f+S_{k-1}\circ T\leq f+M_n \circ T.\]</span>从而 <span class="math display">\[\max_{1\leq k\leq n}S_k\leq f+M_n\circ T.\]</span></p><p>但是在集合 <span class="math inline">\(\{M_n&gt;0\}\)</span>上，<span class="math inline">\(M_n\)</span> 作为 <span class="math inline">\(S_0,S_1,\ldots,S_n\)</span> 中的最大者肯定不能来自<span class="math inline">\(S_0=0\)</span>，所以 <span class="math inline">\(M_n=\max\limits_{1\leq k\leq n}S_k\)</span>，因此<span class="math display">\[M_n\leq f+M_n \circ T,\quad \omega\in\{M_n&gt;0\}.\]</span> 注意 <span class="math inline">\(M_n\)</span>总是非负的随机变量，从而 <span class="math display">\[\begin{align*}\int_{\{M_n&gt;0\}} f &amp;\geq\int_{\{M_n&gt;0\}}M_n -\int_{\{M_n&gt;0\}}M_n\circ T\\ &amp; =\int_\Omega M_n- \int_{\{M_n&gt;0\}}M_n\circ T\\&amp;\geq \int_\OmegaM_n-\int_\Omega M_n\circ T\\&amp;=0.\end{align*}\]</span> 最后由于 <span class="math inline">\(\{M_n&gt;0\}\uparrow\{M_f&gt;0\}\)</span>，所以由控制收敛定理即可得到 <span class="math display">\[\int_{\{M_f&gt;0\}}f\geq 0.\]</span>极大遍历定理得证。</p>]]></content>
      
      
      <categories>
          
          <category> Durrett 概率论批判 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>相亲问题与倒向归纳法</title>
      <link href="optimal-stopping-and-backward-induction/"/>
      <url>optimal-stopping-and-backward-induction/</url>
      
        <content type="html"><![CDATA[<div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>假设你是一位大龄男士，准备参加 100 场相亲（别介意具体数字）。你打算依次与每个女士 <span class="math inline">\(i\)</span> 约会，然后根据印象给她打一个分数 <span class="math inline">\(X_i\)</span>，<span class="math inline">\(X_i\)</span> 的值介于 <span class="math inline">\([0,1]\)</span> 之间。如果你对女士 <span class="math inline">\(i\)</span>很满意，那么就和她结婚，否则就放弃她，参加下一场相亲，当然拒绝了人家可就没有回头的机会了。如果你拒绝了前99 位女士，那么不论第 100次相亲结果如何你都只能和最后这位女士结婚。在相亲之前，你对这些女士的情况一无所知，所以姑且假定她们的分数<span class="math inline">\(X_i\)</span> 都是 <span class="math inline">\([0,1]\)</span>上均匀分布的独立的随机变量。问题是：应该采取怎样的相亲策略，才能娶到你最中意的女士？</p></div><span id="more"></span><p>再费点笔墨解释下。每次相亲结束以后，你可以选择和当前的女士结婚，或者继续见下一位女士，这依赖于你已经相亲的结果：如果你挑挑拣拣到了90号女士还拿不定主意，最后发现“糟了，我快要变剩男了！”，那很可能接下来你就会放低择偶标准，遇到一个还凑合的就结婚了，即使她比你前面拒绝过的很多女士都有不如。当然也不排除你对第一位女士就一见钟情的可能，因此你最终选择的女士的编号<span class="math inline">\(\tau\)</span>是一个随机变量，你要做的就是让你的未来太太的期望分数 <span class="math inline">\(\mathbb{E}X_\tau\)</span> 尽可能的高。</p><p>那么应该采取怎样的策略为好呢？就像买东西讨价还价时总有一个心理价位一样，似乎可以先设定一个心理的期望值，如果遇到的女士的分数大于等于这个值，那就和她结婚；否则就继续下一位女士。这个思路很合理，但是问题是，期望值应该设定为多少呢？</p><p>在概率论里面我们学过如下关于顺序统计量的经典结论：设 <span class="math inline">\(X_1,\cdots,X_N\)</span> 是 <span class="math inline">\([0,1]\)</span> 上独立同分布的均匀随机变量，则<span class="math inline">\(Y=\max_{1\leq i\leq N}X_i\)</span> 的期望是<span class="math inline">\(\frac{N}{N+1}\)</span>。所以如果你把 100次相亲全部进行完，得分最高的女士的期望值理论上应该是 <span class="math inline">\(\frac{100}{101}\)</span>，于是你应该把心理门槛设置在<span class="math inline">\(\frac{100}{101}\)</span>，是这样吗？</p><p>答案是NO！首先门槛值应该是一个随着相亲的进行而逐渐降低的数列，这才符合实际的情形：如果前面太挑剔，为了不当剩男你后面的标准就会放低。其次我们会用倒向归纳法计算出最优策略下初始的门槛值并不是最中意的女士的期望值<span class="math inline">\(\frac{100}{101}\)</span>，实际上它更接近于得分第二高的女士的期望值<span class="math inline">\(\frac{99}{101}\)</span>。正如梅艳芳在《似是故人来》中唱的那样：“但凡未得到，但凡是过去，总是最登对”— 得不到的才是最好的。</p><h1 id="倒向归纳法">倒向归纳法</h1><p>相亲问题是应用倒向归纳法的一个典型例子。</p><p>我们从最后的情形开始分析，假设只剩一位女士可选，那么你只能去和她结婚，而她的期望值是1/2，我们记作 <span class="math inline">\(a_1=1/2\)</span>。</p><p>假设还剩两位女士可选呢？这种情况下应该先和其中一个相亲，如果她的分数大于等于1/2，那就应该和她结婚 （后者的期望只有 1/2，很可能不如她），而小于 1/2的话则去和第二位女士相亲 （后者的期望是1/2，所以我没道理现在娶一个分数小于 1/2 的）。而第一位女士分数大于等于1/2 的概率是 1/2，在大于等于 1/2 的条件下她的分数服从 <span class="math inline">\([1/2,1]\)</span> 上的均匀分布，期望值是3/4；第二位女士的期望分数就是 1/2。所以你以 1/2 的概率娶到一个期望值为3/4 的女士，以 1/2 的概率娶到一个期望值为 1/2的女士。因此有两位女士可选时这个策略的期望分数为 <span class="math display">\[a_2=\frac{1}{2}\cdot\frac{3}{4}+\frac{1}{2}\cdot\frac{1}{2}=\frac{5}{8}.\]</span></p><p>一般地，假设还剩下 <span class="math inline">\(i\)</span>位女士的时候你的心理期望值是 <span class="math inline">\(a_i\)</span>，我们来导出 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{i+1}\)</span>之间的递推关系：首先和其中一位女士相亲，如果她的分数大于等于 <span class="math inline">\(a_i\)</span> 那么就和她结婚，否则就拒绝她（因为后面 <span class="math inline">\(i\)</span> 个人的心理期望是 <span class="math inline">\(a_i\)</span>，我没道理现在娶一个分数小于 <span class="math inline">\(a_i\)</span> 的）。前一种情形的期望是 <span class="math inline">\(\frac{1+a_i}{2}\)</span> 但是发生的概率是 <span class="math inline">\(1-a_i\)</span>，后一种情形的期望是 <span class="math inline">\(a_i\)</span> 发生的概率也是 <span class="math inline">\(a_i\)</span>，因此 <span class="math display">\[a_{i+1}=(1-a_i)\left(\frac{1+a_i}{2}\right)+a_i\cdota_i=\frac{1+a_i^2}{2}.\]</span> 结合初值 <span class="math inline">\(a_1=\frac{1}{2}\)</span>就可以算出整个序列来，因此我们的相亲策略应该是：</p><blockquote><p>假设当前还剩 <span class="math inline">\(i\)</span>位女士。就把心里期望设定在 <span class="math inline">\(a_i\)</span>，然后进行一次相亲。如果相亲结果大于等于<span class="math inline">\(a_i\)</span>，那就和这位女士结婚；否则就把心里期望降低为<span class="math inline">\(a_{i-1}\)</span>，然后继续去见下一位女士。这里序列<span class="math inline">\(\{a_i\}\)</span> 由 <span class="math inline">\(a_1=1/2\)</span>，<span class="math inline">\(a_{i+1}=\frac{1+a_i^2}{2}\)</span> 给出。</p></blockquote><p>在这个策略下，你最终娶到的女士得分期望是 <span class="math inline">\(a_{100}\)</span>。</p><p>序列 <span class="math inline">\(\{a_n\}\)</span> 是所谓的 QuadraticMap，它的通项公式是求不出来的，只能用计算机来算。不过可以用归纳法证明<span class="math inline">\(\frac{N-1}{N+1}&lt;a_{N}&lt;\frac{N-0.5}{N+1}\)</span>，即<span class="math inline">\(a_N\)</span> 的值更接近于次优女士的期望值<span class="math inline">\(\frac{N-1}{N+1}\)</span>。当 <span class="math inline">\(N=100\)</span> 时，<span class="math inline">\(a_{100}\approx0.981\)</span>，<span class="math inline">\(\frac{N-1}{N+1}\approx 0.98\)</span> 而 <span class="math inline">\(\frac{N}{N+1}=100/101\approx 0.99\)</span>，可见<span class="math inline">\(a_{100}\)</span> 与 <span class="math inline">\(\frac{N-1}{N+1}\)</span>更接近。这印证了之前说过的：和你结婚的往往不是你最中意的那个。</p><p>请注意，虽然我们已经设计出了一个不错的策略，但这个策略到底是不是最优的呢？我们还没有严格证明。而且就算这个策略是最优的，是否只有这一种最优策略呢？没准还有其它最优策略能让你更省时省心地娶到好太太呢！要严格的解释这些，就要用到鞅的理论。</p><h1 id="翻译为鞅的语言">翻译为鞅的语言</h1><p>用鞅的语言重新表述上面的问题，会给人一种画风突变的感觉，看起来非常晦涩，不像是在说人话：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>设 <span class="math inline">\(N\)</span>是一个给定的正整数，<span class="math inline">\(\{\mathcal{F}_n\}_{n=0}^N\)</span>是某概率空间上的递增的 <span class="math inline">\(\sigma\)</span>-域流，<span class="math inline">\(\{X_n\}_{n=0}^N\)</span>是一列可积的随机变量且 <span class="math inline">\(X_k\in\mathcal{F}_k\)</span>。设 <span class="math inline">\(\mathcal{M}\)</span> 是所有满足 <span class="math inline">\(0\leq\tau\leq N\)</span> 的停时 <span class="math inline">\(\tau\)</span> 组成的集合。我们想求出值函数 <span class="math display">\[V= \sup_{\tau\in\mathcal{M}}\mathbb{E}X_\tau\]</span> 以及使得这个最大值取到的停时 <span class="math inline">\(\tau\)</span>。</p></div><p>这里我把下标改成了 从 0 开始到 <span class="math inline">\(N\)</span>，以符合大多数文献的习惯。<span class="math inline">\(\mathcal{F}_n=\{X_0,\ldots,X_n\}\)</span> 是前<span class="math inline">\(n+1\)</span> 位女士得分生成的 <span class="math inline">\(\sigma\)</span>- 域，它包含了所有你第 <span class="math inline">\(n+1\)</span> 次相亲后可能知道的信息。<span class="math inline">\(\mathcal{F}_n\)</span>显然是递增的。你的一个相亲策略对应一个停时 <span class="math inline">\(\tau\)</span>，所有停时构成的集合 <span class="math inline">\(\mathcal{M}\)</span> 就是你所有可能的策略。</p><p>定义 <span class="math inline">\(\{X_n\}\)</span> 的 <strong>Snell包络</strong>为 <span class="math display">\[S_n=\begin{cases}X_N&amp;n=N,\\\max\{X_n,\,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}&amp;n=N-1,\ldots,0.\end{cases}\]</span> 这里的 <span class="math inline">\(S_n\)</span> 是从 <span class="math inline">\(N\)</span> 开始倒向递归定义的。注意 <span class="math inline">\(S_n\)</span> 关于 <span class="math inline">\(\mathcal{F}_n\)</span> 可测。</p><p><span class="math inline">\(S_n\)</span>的直观意义很好理解，它就是在时刻 <span class="math inline">\(n\)</span>对当下女士的分数和后面所有女士期望分数的比较：如果和当前的女士 <span class="math inline">\(n\)</span> 结婚，那么分数就是 <span class="math inline">\(X_n\)</span>；否则继续前进到下一个时刻 <span class="math inline">\(n+1\)</span>，未来太太的期望分数就是 <span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>，二者取最大值<span class="math inline">\(\max\{X_n,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}\)</span>即为 <span class="math inline">\(n\)</span>时刻对最佳分数的估计。注意这里 <span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>要取条件期望，因为一般情况下 <span class="math inline">\(\{X_n\}\)</span>之间不是独立的，从而对未来最佳收益的估计依赖于历史信息。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>在相亲问题中，<span class="math inline">\(\{X_n\}\)</span> 是<span class="math inline">\(\mathrm{i.i.d}\)</span> 序列，<span class="math inline">\(S_{n+1}\)</span> 与 <span class="math inline">\(\mathcal{F}_n\)</span> 独立（你可以倒着从 <span class="math inline">\(S_N\)</span> 开始验证 <span class="math inline">\(S_{n+1}\)</span> 完全由 <span class="math inline">\(X_{n+1},\ldots,X_N\)</span> 决定），从而 <span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]=\mathbb{E}S_{n+1}\)</span>，所以</p><p><span class="math display">\[S_n=\begin{cases}X_N&amp;n=N,\\\max\{X_n,\,\mathbb{E}S_{n+1}\}&amp;n=N-1,\ldots,0.\end{cases}\]</span></p><p>记事件 <span class="math inline">\(A_n=\{X_n&gt;\mathbb{E}S_{n+1}\}\)</span>，于是序列<span class="math inline">\(\{\mathbb{E}S_n\}\)</span> 满足倒向递推关系<span class="math display">\[\mathbb{E}S_n=\mathbb{E}\max\{X_n,\,\mathbb{E}S_{n+1}\}=\mathbb{E}[X_n\mathrm{1}_{A_n}]+ \mathbb{E}S_{n+1}\cdot(1-\mathbb{P}(A_n)).\]</span>这正是我们前一节中看到的递推关系。</p></div><p>设 <span class="math inline">\(\tau=\inf\,\{n:\,S_n=X_n\}\)</span>，则 <span class="math inline">\(\tau\)</span>是停时。由于 <span class="math inline">\(S_N=X_N\)</span>，因此 <span class="math inline">\(0\leq\tau\leq N\)</span>。<span class="math inline">\(\tau\)</span> 就是我们采取的相亲策略：在 <span class="math inline">\(\tau\)</span> 时刻，由于这时 <span class="math inline">\(\max\{X_n,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}=X_n\)</span>，即<span class="math inline">\(n\)</span> 号女士的分数 <span class="math inline">\(X_n\)</span> 大于等于后面所有女士的期望分数 <span class="math inline">\(\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>，剩下的相亲就不必再进行了。</p><p>到目前为止，我们已经把相亲问题完整地翻译成了鞅的语言。我们来证明<span class="math inline">\(\tau\)</span>确实是最优策略。为此我们需要做一些准备：</p><div id="super" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\{S_n\}\)</span> 是控制 <span class="math inline">\(\{X_n\}\)</span> 的最小上鞅。</p></div><p><strong>证明</strong>：由 <span class="math inline">\(S_n=\max\{X_n,\mathbb{E}[S_{n+1}|\mathcal{F}_n]\}\)</span>直接可见 <span class="math inline">\(S_n\geq X_n\)</span> 并且 <span class="math inline">\(\{S_n\}\)</span> 是上鞅。设 <span class="math inline">\(\{Y_n\}\)</span> 是任意满足 <span class="math inline">\(Y_n\geq X_n\)</span> 的上鞅序列，我们要证明必有<span class="math inline">\(Y_n\geq S_n\)</span>。这只要从最后一项 <span class="math inline">\(n=N\)</span> 开始逐项验证即可。由定义 <span class="math inline">\(Y_N\geq X_N=S_N\)</span>，这一项没问题。假设 <span class="math inline">\(Y_n\geq S_n\)</span>，两边对 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 取条件期望可得 <span class="math display">\[Y_{n-1}\geq \mathbb{E}[Y_n|\mathcal{F}_{n-1}]\geq \mathbb{E}[S_n|\mathcal{F}_{n-1}].\]</span>其中第一个不等号是根据上鞅的定义，第二个不等号是根据条件期望的单调性。再结合<span class="math inline">\(Y_{n-1}\geq X_{n-1}\)</span> 可得 <span class="math inline">\(Y_{n-1}\geq\max\{X_{n-1},\mathbb{E}[S_n|\mathcal{F}_{n-1}]\}=S_{n-1}\)</span>，所以<span class="math inline">\(n-1\)</span>项也没有问题。这样倒着向前递推即得结论成立。<span class="math inline">\(\blacksquare\)</span></p><div id="martingale" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\{S_{n\wedge\tau}\}\)</span> 是一个鞅。</p></div><p><strong>证明</strong>：<span class="math display">\[S_{(n+1)\wedge\tau}-S_{n\wedge\tau}=1_{\{\tau&gt;n\}}(S_{n+1}-S_n).\]</span></p><p>对上式右边求条件期望： <span class="math display">\[\mathbb{E}[1_{\{\tau&gt;n\}}(S_{n+1}-S_n)|\mathcal{F}_n]=1_{\{\tau&gt;n\}}\mathbb{E}[(S_{n+1}-S_n)|\mathcal{F}_n]=0.\]</span></p><p>这是因为如果 <span class="math inline">\(\tau&gt;n\)</span>的话那么由 <span class="math inline">\(\tau\)</span> 的定义 <span class="math inline">\(S_n=\mathbb{E}[S_{n+1}|\mathcal{F}_n]\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="expectation-tau" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathbb{E}X_\tau=\mathbb{E}S_0\)</span>。</p></div><p><strong>证明</strong>：注意 <span class="math inline">\(X_\tau=S_\tau\)</span>，利用 <span class="math inline">\(0\leq\tau\leq N\)</span> 和鞅性质即可： <span class="math display">\[\mathbb{E}X_\tau=\mathbb{E}S_\tau=\mathbb{E}S_{\tau\wedgeN}=\mathbb{E}S_{\tau\wedge0}=\mathbb{E}S_0.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div id="optimal" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{M}\)</span> 是所有满足 <span class="math inline">\(0\leq T\leq N\)</span> 的停时 <span class="math inline">\(T\)</span> 组成的集合，则 <span class="math inline">\(\tau\)</span> 是其中最优的： <span class="math display">\[\mathbb{E}S_0=\mathbb{E}X_\tau=\sup_{T\in\mathcal{M}}\mathbb{E}X_T.\]</span></p></div><p><strong>证明</strong>：设 <span class="math inline">\(T\)</span>是任意停时，我们要证明 <span class="math inline">\(\mathbb{E}X_\tau\geq\mathbb{E}X_T\)</span>。为此只要注意到 <span class="math display">\[\mathbb{E}X_\tau =\mathbb{E}S_0\geq \mathbb{E}S_T\geq\mathbb{E}X_T.\]</span> 第一个等号是根据 <a href="#expectation-tau" title="推论 2.3">推论 2.3</a>，中间的不等号是因为 <span class="math inline">\(\{S_n\}\)</span> 是上鞅，所以对任何停时 <span class="math inline">\(T\)</span> 都有 <span class="math inline">\(\mathbb{E}S_T\leq\mathbb{E}S_0\)</span>。最后的不等号是因为 <span class="math inline">\(S_n\)</span> 控制 <span class="math inline">\(X_n\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>至此我们就从数学上严格论证了前面的相亲策略确实是最优的。</p><p>回顾上面的分析，可以发现我们实际上使用了 <span class="math inline">\(\tau\)</span> 的两个性质：<span class="math inline">\(S_\tau=X_\tau\)</span> 和 <span class="math inline">\(\{S_{n\wedge\tau}\}\)</span>是鞅。这两个性质保证了 <span class="math inline">\(\tau\)</span>是最优策略。那这是不是说明还有其它最优的策略呢？</p><div id="suff-nece" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.5</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\nu\in\mathcal{M}\)</span>是最优停时的充要条件是：</p><ol type="1"><li><span class="math inline">\(S_\nu=X_\nu\)</span>。</li><li><span class="math inline">\(\{S_{n\wedge\nu}\}\)</span> 是鞅。</li></ol></div><p><a href="#suff-nece" title="定理 2.5">定理 2.5</a>告诉我们，前面采用的相亲策略是所有最优策略中时间成本最低的：即若 <span class="math inline">\(\nu\)</span> 是任意最优停时，则 <span class="math inline">\(\tau\leq\nu\)</span> （回顾一下 <span class="math inline">\(\tau\)</span> 的定义）。</p><p>我们还可以给出最优策略中最大的一个来：</p><div id="largest" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.6</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(S_n=M_n-A_n\)</span> 是 Snell 包络 <span class="math inline">\(\{S_n\}\)</span> 的 Doob-Meyer 分解，其中 <span class="math inline">\(\{M_n\}\)</span> 是鞅，<span class="math inline">\(A_n\)</span> 是可料递增过程，由 <span class="math display">\[A_n=\sum_{k=1}^n(S_{k-1}-\mathbb{E}[S_k|\mathcal{F}_{k-1}]) \]</span> 给出。定义</p><p><span class="math display">\[\tau_\max = \begin{cases}N &amp; A_N=0,\\\min\{n\geq0 \mid A_{n+1}&gt;0\} &amp; A_N&gt;0.\end{cases}\]</span></p><p>则 <span class="math inline">\(\tau_\max\)</span>是所有最优停时中最大的。</p></div><p>这个策略在现实很有用，它是以最优方式行使美式期权的最大停时。</p><p><a href="#suff-nece" title="定理 2.5">定理 2.5</a> 和 <a href="#largest" title="定理 2.6">定理 2.6</a>的证明都不难，这里就省略了。读者可以参考 <span class="citation" data-cites="RiskNeutralValuation">(<a href="#ref-RiskNeutralValuation" role="doc-biblioref">Bingham and Kiesel 2004, sec. 3.6</a>)</span>。</p><p>我猜某些读者可能会对 <span class="math inline">\(\tau_\max\)</span>对应的相亲策略感兴趣，因为这个策略有点渣男：它会在保证娶到最优女士的前提下和尽可能多的女士相亲。不过在<span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span>的情形，你还是死了这份心吧。因为这时 <span class="math display">\[A_n=\sum_{k=1}^n(S_{k-1}-\mathbb{E}S_k)=\sum_{k=1}^n\max\{X_{k-1}-\mathbb{E}S_k,0\}.\]</span>所以使得 <span class="math inline">\(A_{n+1}&gt;0\)</span> 成立的最小<span class="math inline">\(n\)</span> 正是使得 <span class="math inline">\(X_n&gt;\mathbb{E}S_{n+1}\)</span> 成立的最小 <span class="math inline">\(n\)</span>，即使得 <span class="math inline">\(X_n=S_n\)</span> 成立的最小 <span class="math inline">\(n\)</span>。这不就是前面见好就收的策略 <span class="math inline">\(\tau\)</span> 嘛！换句话说，在 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span>的情形，只有一种最优相亲策略！</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-RiskNeutralValuation" class="csl-entry" role="listitem">Bingham, N. H., and Rüdiger Kiesel. 2004. <em>Risk-Neutral Valuation :Pricing and Hedging of Financial Derivatives / n.h. Bingham and r.Kiesel.</em> Second edition. Springer Finance. London: Springer.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>三质点弹簧系统的简正模式</title>
      <link href="three-mass-spring-system/"/>
      <url>three-mass-spring-system/</url>
      
        <content type="html"><![CDATA[<p>今天的问题是群表示论在物理中的一个小应用：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>平面上有三个质量均为 <span class="math inline">\(m\)</span> 的质点 <span class="math inline">\(A,B,C\)</span>，它们位于正三角形的三个顶点。质点之间两两由弹簧相连，三个弹簧完全一样。弹簧质量忽略不计。</p><p><img style="margin:0px auto;display:block" width="250" src="/images/mass-spring/abc.png"></p><p>初始时所有质点都处于静止状态，弹簧之间没有张力。假设给这三个质点分别施加一个初始速度，使这三个质点在平面内作刚体运动，不考虑任何摩擦力和空气阻力，那么这个系统的简正模式(normal mode) 是什么？</p></div><p>这里 <a href="https://en.wikipedia.org/wiki/Normal_mode">简正模式</a>的含义是所有质点按照一个共同的频率和固定的相位关系相对于各自的平衡位置作简谐振动。</p><span id="more"></span><p>比较容易发现的简正模式有：</p><ol type="1"><li><p>平移。初始时给所有质点以同样的速度，它们会继续以相同的速度移动。</p><p><img style="margin:0px auto;display:block" width="250" src="/images/mass-spring/trans.gif"></p></li><li><p>旋转。初始时给所有质点以相同的切向速度，它们会继续绕中心旋转。</p><p><img style="margin:0px auto;display:block" width="250" src="/images/mass-spring/rot.gif"></p></li><li><p>呼吸。初始时给每个质点相同的径向速度，系统会重复膨胀 —收缩的过程。</p><p><img style="margin:0px auto;display:block" width="250" src="/images/mass-spring/breath.gif"></p></li></ol><p>但是要找出其它的简正模式，并保证没有遗漏，就不能只靠想象了。</p><p>我们把这个物理问题转换为一个线性代数问题，然后用一些群表示论的知识解决它。</p><p>这个质点弹簧系统有 6 个自由度 <span class="math inline">\(\{q_1,\ldots,q_6\}\)</span>，其中 <span class="math inline">\((q_1,q_2)\)</span>，<span class="math inline">\((q_3,q_4)\)</span>，<span class="math inline">\((q_5,q_6)\)</span> 分别是质点 <span class="math inline">\(A,B,C\)</span> 在 <span class="math inline">\(x,y\)</span>方向上相对于其平衡位置的位移，如下图所示：</p><p><img style="margin:0px auto;display:block" width="300" src="/images/mass-spring/coords.svg"></p><p>设弹簧的弹性系数为 <span class="math inline">\(k\)</span>，原点在三角形中心，<span class="math inline">\(x\)</span>轴水平向右，于是三个弹簧所含的弹性势能为 （将形变投影到弹簧所在的方向）<span class="math display">\[\begin{align*}V=&amp;\frac{1}{2}k(q_3-q_1)^2+\frac{1}{2}k\left[\frac{-1}{2}(q_5-q_3) +\frac{\sqrt{3}}{2}(q_6-q_4)\right]^2+\\&amp;\frac{1}{2}k\left[\frac{1}{2}(q_1-q_5)+ \frac{\sqrt{3}}{2}(q_2-q_6)\right]^2.\end{align*}\]</span> 这是一个关于 <span class="math inline">\(\mathbf{q}=(q_1,q_2,\ldots,q_6)^T\)</span>的二次型： <span class="math display">\[V=\frac{1}{2}k\,\mathbf{q}^TU\mathbf{q}.\]</span> 其中 <span class="math display">\[U=\frac{1}{4}\begin{pmatrix}5&amp;\sqrt{3}&amp;-4&amp;0&amp;-1&amp;-\sqrt{3}\\\sqrt{3}&amp;3&amp;0&amp;0&amp;-\sqrt{3}&amp;3\\-4&amp;0&amp;5&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}\\0&amp;0&amp;-\sqrt{3}&amp;3&amp;\sqrt{3}&amp;-3\\-1&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}&amp;2&amp;0\\-\sqrt{3}&amp;-3&amp;\sqrt{3}&amp;-3&amp;0&amp;6\end{pmatrix}.\]</span></p><p>由牛顿第二定律我们有 <span class="math display">\[m\frac{\mathrm{d}^2q_i}{\mathrm{d}t^2}=-\frac{\partialV}{\partial q_i}=-k\sum_{j=1}^6U_{ij}q_j.\]</span>系统的简正模式就是所有 <span class="math inline">\(q_i\)</span>按照同一个频率 <span class="math inline">\(\omega\)</span>作简谐振动，但振幅可以不同，故而可以设 <span class="math inline">\(q_i=\overline{q}_i\mathrm{e}^{i\omegat}\)</span>，其中 <span class="math inline">\(\overline{q}_i\)</span>是振幅，与时间 <span class="math inline">\(t\)</span> 无关。代入上式得到<span class="math display">\[\frac{m\omega^2}{k}\overline{q}_i =\sum_{j=1}^6U_{ij}\overline{q}_j.\]</span> 即 <span class="math inline">\(U\overline{\mathbf{q}}=\lambda\overline{\mathbf{q}}\)</span>，<span class="math inline">\(\lambda=m\omega^2/k\)</span>，于是简正模式的振幅<span class="math inline">\(\overline{\mathbf{q}}=(\overline{q}_1,\overline{q}_2,\ldots,\overline{q}_6)\)</span>是 <span class="math inline">\(U\)</span> 的特征向量，频率可以从特征值<span class="math inline">\(\lambda\)</span> 得出，从而问题转化为求矩阵<span class="math inline">\(U\)</span> 的特征值和特征向量。由于 <span class="math inline">\(U\)</span> 是一个实对称矩阵，所以一定存在 6个线性无关的特征向量。</p><p>你当然可以直接硬算，但是手动求一个 6阶矩阵的特征值还是一件挺麻烦的事情，鉴于搞数学的人一般比较懒，我们可以换个思路想一想。</p><p>注意到这个系统具有对称性，其对称群是 <span class="math inline">\(S_3\)</span>。<span class="math inline">\(S_3\)</span> 这个群是集合 <span class="math inline">\(\{1,2,3\}\)</span>的置换群，同时也是平面上正三角形的对称群，在后者的情形通常称为二面体群<span class="math inline">\(D_3\)</span>。</p><p>回忆 <span class="math inline">\(S_3\)</span> 的一个表现为 <span class="math display">\[S_3=\{a,b\mid a^2=b^3=(ab)^2=1\}.\]</span>当作为置换群时，<span class="math inline">\(a=(12),\,b=(123)\)</span>。当作为二面体群时，<span class="math inline">\(a=\left(\begin{smallmatrix}-1&amp;0\\0&amp;1\end{smallmatrix}\right)\)</span>是关于 <span class="math inline">\(y\)</span> 轴的反射，<span class="math inline">\(b=\left(\begin{smallmatrix}\cos2\pi/3&amp;-\sin2\pi/3\\\sin2\pi/3&amp;\cos2\pi/3\end{smallmatrix}\right)\)</span>是关于原点角度为 <span class="math inline">\(2\pi/3\)</span>的旋转。</p><p>系统状态 <span class="math inline">\(\mathbf{q}\)</span> 所在的空间<span class="math inline">\(\mathbb{R}^6\)</span> 是三个 <span class="math inline">\(\mathbb{R}^2\)</span> 的直和：<span class="math inline">\(\mathbb{R}^6=\mathbb{R}^2_A\oplus\mathbb{R}^2_B\oplus\mathbb{R}^2_C\)</span>。其中<span class="math inline">\(\mathbb{R}^2_A,\mathbb{R}^2_B,\mathbb{R}^2_C\)</span>分别是 <span class="math inline">\(A,B,C\)</span> 的坐标空间。<span class="math inline">\(S_3\)</span> 在置换这三个直和项的同时，又以 <span class="math inline">\(D_3\)</span>的方式作用在每个直和项上，所以这个表示是 <span class="math inline">\(S_3\)</span> 的置换表示和在 <span class="math inline">\(\mathbb{R}^2\)</span> 上二维表示的张量积。</p><p>例如，对换 <span class="math inline">\((12)\)</span> 交换 <span class="math inline">\(A,B\)</span>，同时将它们的坐标关于 <span class="math inline">\(y\)</span> 轴作反射： <span class="math display">\[\begin{aligned}A\otimes (q_1,q_2) &amp;\xrightarrow{(12)} B\otimes(-q_1,q_2),\\B\otimes (q_3,q_4) &amp;\xrightarrow{(12)} A\otimes(-q_3,q_4).\end{aligned}\]</span></p><p>我们把这个张量积表示记作 <span class="math inline">\(\rho\)</span>，并记 <span class="math display">\[R=\begin{pmatrix}\cos\frac{2\pi}{3}&amp;-\sin\frac{2\pi}{3}\\\sin\frac{2\pi}{3}&amp;\cos\frac{\pi}{3}\end{pmatrix},\quadS=\begin{pmatrix}-1&amp;0\\0&amp;1\end{pmatrix}.\]</span></p><p>我们可以明确写出 <span class="math inline">\(a=(12)\)</span>在这个张量积表示下的矩阵：<span class="math inline">\(a\)</span>作为置换对应的矩阵是 <span class="math display">\[A=\begin{pmatrix}0&amp;1&amp;0\\1&amp;0&amp;0\\0&amp;0&amp;1\end{pmatrix}.\]</span>在二面体群 <span class="math inline">\(D_3\)</span> 中，<span class="math inline">\(a\)</span> 是关于 <span class="math inline">\(y\)</span> 轴的反射，其矩阵为 <span class="math inline">\(S\)</span>，所以 <span class="math inline">\(a\)</span> 在 <span class="math inline">\(\mathbb{R}^3\otimes\mathbb{R}^2\)</span>上的作用对应的矩阵是 Kronecker 乘积 <span class="math inline">\(A\otimesS\)</span>。</p><p>下面列出了 <span class="math inline">\(S_3\)</span> 的各个元素在<span class="math inline">\(\rho\)</span> 下对应的矩阵：</p><p><span class="math display">\[\begin{align*}\rho(e)&amp;=I_3\otimesI_2=\begin{pmatrix}I_2&amp;0&amp;0\\0&amp;I_2&amp;0\\0&amp;0&amp;I_2\end{pmatrix},\\\rho(a)&amp;=\begin{pmatrix}0&amp;1&amp;0\\1&amp;0&amp;0\\0&amp;0&amp;1\end{pmatrix}\otimesS=\begin{pmatrix}0&amp;S&amp;0\\S&amp;0&amp;0\\0&amp;0&amp;S\end{pmatrix},\\\rho(b)&amp;=\begin{pmatrix}0&amp;1&amp;0\\0&amp;0&amp;1\\1&amp;0&amp;0\end{pmatrix}\otimesR=\begin{pmatrix}0&amp;R&amp;0\\0&amp;0&amp;R\\R&amp;0&amp;0\end{pmatrix},\\\rho(b^2)&amp;=\begin{pmatrix}0&amp;0&amp;1\\1&amp;0&amp;0\\0&amp;1&amp;0\end{pmatrix}\otimesR^2=\begin{pmatrix}0&amp;0&amp;R^2\\R^2&amp;0&amp;0\\0&amp;R^2&amp;0\end{pmatrix},\\\rho(ab)&amp;=\begin{pmatrix}0&amp;0&amp;1\\0&amp;1&amp;0\\1&amp;0&amp;0\end{pmatrix}\otimesSR=\begin{pmatrix}0&amp;0&amp;SR\\0&amp;SR&amp;0\\SR&amp;0&amp;0\end{pmatrix},\\\rho(ab^2)&amp;=\begin{pmatrix}1&amp;0&amp;0\\0&amp;0&amp;1\\0&amp;1&amp;0\end{pmatrix}\otimesSR^2=\begin{pmatrix}SR^2&amp;0&amp;0\\0&amp;0&amp;SR^2\\0&amp;SR^2&amp;0\end{pmatrix}.\end{align*}\]</span></p><p><span class="math inline">\(S_3\)</span> 在表示 <span class="math inline">\(\rho(g)\)</span>下显然都是正交矩阵，而且保持系统的势能不变，所以对任何状态 <span class="math inline">\(\mathbf{q}\)</span> 有 <span class="math display">\[V(\rho(g)\mathbf{q})=V(\mathbf{q}),\]</span> 即<span class="math display">\[{\bf q^T}\rho(g)^TU\rho(g){\bfq}=U.\]</span> 由于 <span class="math inline">\(\rho(g)\)</span>正交所以 <span class="math inline">\(\rho(g)U=U\rho(g)\)</span>，从而<span class="math inline">\(U\)</span> 是表示 <span class="math inline">\(\rho\)</span> 的一个自同态。</p><p>在数学上，我们非常喜欢这种与一个表示 <span class="math inline">\(\rho\)</span>交换的矩阵，因为这种矩阵的任何特征子空间都是 <span class="math inline">\(\rho\)</span> 的不变子空间，即给出 <span class="math inline">\(\rho\)</span> 的子表示，从而可以帮助我们更好地理解<span class="math inline">\(\rho\)</span>的结构。不过在这个问题中，我们要反过来借助 <span class="math inline">\(\rho\)</span> 的分解来分析 <span class="math inline">\(U\)</span> 的特征子空间的结构。</p><p>我们来确定表示 <span class="math inline">\(\rho\)</span>的结构。注意到 <span class="math inline">\(S_3\)</span> 在 <span class="math inline">\(\{1,2,3\}\)</span>上的置换表示，其特征只有在单位元 <span class="math inline">\(e\)</span>处不为 0（值是 3），在任何非单位元 <span class="math inline">\(g\inS_3\)</span> 处都是 0。这个表示是张量积表示 <span class="math inline">\(\rho\)</span> 的分量，所以 <span class="math inline">\(\rho\)</span> 的特征 <span class="math inline">\(\chi\)</span> 也具有此性质。显然 <span class="math inline">\(\chi(e)=6\)</span>，于是 <span class="math inline">\(\chi\)</span> 与 <span class="math inline">\(S_3\)</span>的正则表示的特征完全相同，从而同构于正则表示，从而 <span class="math inline">\(\chi\)</span>可以分解为两个一次表示和两个二次不可约表示的和： <span class="math display">\[\chi = \chi_1 + \chi_2 + \chi_3+\chi_4.\]</span>其中 <span class="math inline">\(\chi_1\)</span> 是平凡表示的特征，<span class="math inline">\(\chi_2\)</span> 是符号表示的特征（偶置换为+1，奇置换为 -1），这两个特征都是一次的。<span class="math inline">\(\chi_3=\chi_4\)</span> 是 <span class="math inline">\(S_3\)</span>作为二面体群的二维不可约表示的特征。</p><p>记 <span class="math inline">\(\chi_i\)</span> 对应的不可约模是 <span class="math inline">\(V_i\)</span>，则 <span class="math inline">\(\dimV_1=\dim V_2=1\)</span>，<span class="math inline">\(\dim V_3=\dimV_4=2\)</span> 并且 <span class="math display">\[\mathbb{R}^6=V_1\oplusV_2\oplus V_3\oplus V_4.\]</span></p><p><span class="math inline">\(\mathbb{R}^6\)</span> 是 <span class="math inline">\(U\)</span> 的特征子空间的直和，而 <span class="math inline">\(U\)</span> 的特征子空间都是 <span class="math inline">\(\rho\)</span> 的不变子空间，从而可以分解为 <span class="math inline">\(\rho\)</span> 的不可约模的直和。这说明每个 <span class="math inline">\(V_i\)</span> 都包含在 <span class="math inline">\(U\)</span> 的某个特征值 <span class="math inline">\(\lambda_i\)</span> 的特征子空间中。即 <span class="math inline">\(U\)</span> 在 <span class="math inline">\(V_i\)</span> 上的作用是数乘 <span class="math inline">\(\lambda_i\)</span>。</p><p>从 <span class="math inline">\(V_1,\ldots,V_4\)</span>中分别选择一组基，它们合起来构成 <span class="math inline">\(\mathbb{R}^6\)</span> 的一组基。在这组基下 <span class="math inline">\(U\)</span> 是对角矩阵，形如 <span class="math display">\[U=\begin{pmatrix}\lambda_1&amp;0&amp;0&amp;0\\0&amp;\lambda_2&amp;0&amp;0\\0&amp;0&amp;\lambda_3I_2&amp;0\\0&amp;0&amp;0&amp;\lambda_4I_2\end{pmatrix}.\]</span>同时 <span class="math inline">\(\rho(g)\)</span> 形如 <span class="math display">\[\rho(g)=\begin{pmatrix}D_1&amp;0&amp;0&amp;0\\0&amp;D_2&amp;0&amp;0\\0&amp;0&amp;D_3&amp;0\\0&amp;0&amp;0&amp;D_4\end{pmatrix}.\]</span></p><p>我们来计算 <span class="math inline">\(\rho(g)U\)</span> 对不同 <span class="math inline">\(g\in S_3\)</span> 的迹。首先注意到 <span class="math display">\[\mathop{\mathrm{tr}}{\rho(g)U}=\mathop{\mathrm{tr}}{\begin{pmatrix}\lambda_1D_1&amp;0&amp;0&amp;0\\0&amp;\lambda_2D_2&amp;0&amp;0\\0&amp;0&amp;\lambda_3D_3&amp;0\\0&amp;0&amp;0&amp;\lambda_4D_4\end{pmatrix}}=\sum_{i=1}^4\lambda_i\chi_i(g).\]</span></p><p>另一方面，我们对 <span class="math inline">\(S_3\)</span> 中的 <span class="math inline">\(e,a,b\)</span> 这三个元素，根据前面列出的 <span class="math inline">\(\rho(g)\)</span> 矩阵，计算其与 <span class="math inline">\(U\)</span>的乘积，再求迹得到（这是本文计算量最大的部分！） <span class="math display">\[\begin{align*}\mathop{\mathrm{tr}}{\rho(e)U}&amp;=\mathop{\mathrm{tr}}{U}=\frac{1}{4}(5+3+5+3+2+6)=6,\\\mathop{\mathrm{tr}}{\rho(a)U}&amp;=\mathop{\mathrm{tr}}{\begin{pmatrix}0&amp;S&amp;0\\S&amp;0&amp;0\\0&amp;0&amp;S\end{pmatrix}\frac{1}{4}\begin{pmatrix}5&amp;\sqrt{3}&amp;-4&amp;0&amp;-1&amp;-\sqrt{3}\\\sqrt{3}&amp;3&amp;0&amp;0&amp;-\sqrt{3}&amp;3\\-4&amp;0&amp;5&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}\\0&amp;0&amp;-\sqrt{3}&amp;3&amp;\sqrt{3}&amp;-3\\-1&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}&amp;2&amp;0\\-\sqrt{3}&amp;-3&amp;\sqrt{3}&amp;-3&amp;0&amp;6\end{pmatrix}}\\&amp;=\frac{1}{4}(4+0+4+0-2+6)=3,\\\mathop{\mathrm{tr}}{\rho(b)U}&amp;=\mathop{\mathrm{tr}}{\begin{pmatrix}0&amp;R&amp;0\\0&amp;0&amp;R\\R&amp;0&amp;0\end{pmatrix}\frac{1}{4}\begin{pmatrix}5&amp;\sqrt{3}&amp;-4&amp;0&amp;-1&amp;-\sqrt{3}\\\sqrt{3}&amp;3&amp;0&amp;0&amp;-\sqrt{3}&amp;3\\-4&amp;0&amp;5&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}\\0&amp;0&amp;-\sqrt{3}&amp;3&amp;\sqrt{3}&amp;-3\\-1&amp;-\sqrt{3}&amp;-1&amp;\sqrt{3}&amp;2&amp;0\\-\sqrt{3}&amp;-3&amp;\sqrt{3}&amp;-3&amp;0&amp;6\end{pmatrix}}\\&amp;=\frac{1}{4}(2+0-1+3+2+0)=\frac{3}{2}.\end{align*}\]</span> 于是我们得到三个方程 <span class="math display">\[\begin{align*}6&amp;=\lambda_1+\lambda_2+2(\lambda_3+\lambda_4),\\3&amp;=\lambda_1-\lambda_2,\\3/2&amp;=\lambda_1+\lambda_2-(\lambda_3+\lambda_4).\end{align*}\]</span> 于是 <span class="math inline">\(\lambda_1=3\)</span>，<span class="math inline">\(\lambda_2=0\)</span>，<span class="math inline">\(\lambda_3+\lambda_4=3/2\)</span>。</p><p>我们还缺一个方程！可以用 <span class="math inline">\(\mathop{\mathrm{tr}}{U^2}=\lambda_1^2+\lambda_2^2+2(\lambda_3^2+\lambda_4^2)\)</span>来做，但手算 <span class="math inline">\(U^2\)</span>的话计算量还是不小的。更简单的办法是用物理直观：我们已经看到平移和旋转是两种简正模式，这两种模式下质点的振动频率是0，而平移包含了 <span class="math inline">\(x\)</span> 轴和 <span class="math inline">\(y\)</span> 轴两个线性无关的方向上的平移，所以<strong>0 作为 <span class="math inline">\(U\)</span>的特征值至少是三重的</strong>。我们已经解得 <span class="math inline">\(\lambda_2=0\)</span> 是一个，所以 <span class="math inline">\(\lambda_3\)</span> 和 <span class="math inline">\(\lambda_4\)</span> 中必然还有一个是 0，不妨设<span class="math inline">\(\lambda_3=0\)</span>，则 <span class="math inline">\(\lambda_4=3/2\)</span>。</p><p>得到了 <span class="math inline">\(\lambda_1,\lambda_2,\lambda_3,\lambda_4\)</span>，对应的频率就可以用<span class="math inline">\(\omega_i=\sqrt{\frac{\lambda_ik}{m}}\)</span>算出来。</p><p>总结一下，系统总共有 4 种简正模式：</p><ol type="1"><li><p>平凡表示 (<span class="math inline">\(\lambda_1=3\)</span>)对应的简正模式是呼吸，其频率为 <span class="math inline">\(\omega=\sqrt{\frac{3k}{m}}\)</span>：</p><p><img style="margin:0px auto;display:block" width="250" src="/images/mass-spring/breath.gif"></p></li><li><p>符号表示 (<span class="math inline">\(\lambda_2=0\)</span>)对应的简正模式是旋转，其频率 <span class="math inline">\(\omega=0\)</span>：</p><p><img style="margin:0px auto;display:block" width="250" src="/images/mass-spring/rot.gif"></p></li><li><p>第一个二维不可约表示 (<span class="math inline">\(\lambda_3=0\)</span>)包含了两种简正模式，它们分别是沿着 <span class="math inline">\(x\)</span> 方向和 <span class="math inline">\(y\)</span> 方向的平移，其频率 <span class="math inline">\(\omega=0\)</span>。</p><p><img style="margin:0px auto;display:block" width="250" src="/images/mass-spring/trans.gif"></p></li><li><p>第二个二维不可约表示 (<span class="math inline">\(\lambda_4=3/2\)</span>)也包含了两种简正模式，它们分别是两个不同方向上的“鼓掌”：</p><p><img style="margin:0px auto;display:block" width="250" src="/images/mass-spring/clap.gif"></p><p>另一种可以由上面的旋转 <span class="math inline">\(2\pi/3\)</span>后得到。这两个简正模式的频率都是 <span class="math inline">\(\omega=\sqrt{\frac{3k}{2m}}\)</span>。</p></li></ol><p>至此我们就求出了系统的全部简正模式。</p>]]></content>
      
      
      <categories>
          
          <category> 有限群表示与结合代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>模式的等待时间与反直觉概率</title>
      <link href="pattern-occurrence/"/>
      <url>pattern-occurrence/</url>
      
        <content type="html"><![CDATA[<p>著名概率学家 Feller 在他的名著 “An introduction to probability andits applications” 中提到了这样一个实验：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>重复抛掷一枚均匀的硬币，用 <code>H</code>代表正面向上，<code>T</code> 代表背面向上，一直到连续出现 6 次<code>H</code> 为止。这里连续 6 个 <code>Ｈ</code> 组成的模式记作<code>HHHHHH</code>，所需要抛掷硬币的次数叫做等待时间。等待时间是一个随机变量，最小值是6，最大值可以是无限。Feller 问：等待时间的均值是多少？</p></div><p>这个问题可以用 Markov链来解，但是非常繁琐。香港中文大学李硕彦教授在他的论文 <span class="citation" data-cites="Li1980">(<a href="#ref-Li1980" role="doc-biblioref">Li 1980</a>)</span>中用离散鞅的知识给出了一个简洁而巧妙的解法，本文就来介绍他的方法。</p><span id="more"></span><h1 id="鞅和赌博序列">鞅和赌博序列</h1><p>我们用 <code>HTHT</code>这个模式为例子，来演示如何求出它的平均等待时间。</p><p>假设有一个赌徒，怀里揣着 1 元钱来到一家赌场，他的目标是赌中<code>HTHT</code> 这个序列。</p><ul><li><p>第一天，他押上这 1 元钱，赌第一次掷硬币的结果是<code>H</code>。如果他赌错了就得空手走人，而赌对的话则可以赢得 2 元（资金翻番） 并留在赌场。</p></li><li><p>第二天，他押上全部的 2 元，赌第二次掷硬币的结果是<code>Ｔ</code>。跟以前一样，赌错了空手走人，赌对了的话则资金翻番变成 4元并留在赌场。</p></li><li><p>第三天，他押上全部的 4 元，赌第三次掷硬币的结果是<code>H</code>。赌错了空手走人，赌对了的话则资金翻番变成 8元并留在赌场。</p></li><li><p>第四天，他押上全部的 8 元，赌第四次掷硬币的结果是<code>T</code>。赌错了空手走人，赌对了资金翻番变成 16元，赌局结束。</p></li></ul><p>这个赌局很像电视节目里的闯关游戏，赌局一共有 4关，赌徒要一关一关的闯，中间任何一关输了都要空手走人。</p><p>赌局对赌徒和庄家来讲都是公平的：大家在期望的意义下都是不赔不赚。每一天，赌徒都以1/2 的概率输光赌本，也以 1/2 的概率将赌本翻番。</p><p>现在假设有一个赌博团伙，他们每天都派一个人到赌场赌博，每个赌徒的赌局与上面的描述相同，不同的赌徒的赌局互相独立。我们用<span class="math inline">\(\{X_n,n=0,1,2,\ldots\}\)</span> 表示第 <span class="math inline">\(n\)</span> 天结束以后这个团伙的“净收益”，其中<span class="math inline">\(X_0=0\)</span>。由于赌局是公平的，因此 <span class="math inline">\(\{X_n\}\)</span> 是一个鞅。</p><p>设 <span class="math inline">\(\tau\)</span> 是模式 <code>HTHT</code>的等待时间，则 <span class="math inline">\(\tau\)</span>是一个停时。不难验证 <span class="math inline">\(\{X_n\}\)</span> 和<span class="math inline">\(\tau\)</span> 满足 <a href="https://en.wikipedia.org/wiki/Optional_stopping_theorem">Doob可料停时定理</a> 的条件</p><div id="doob-------------------" class="statement sta_doob_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Doob可料停时定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{X_n, n=0,1,2,\ldots\}\)</span> 是一个鞅，<span class="math inline">\(\tau\)</span> 是停时且满足</p><ol type="1"><li><span class="math inline">\(\mathbb{E}\tau &lt;\infty\)</span>，</li><li>存在常数 <span class="math inline">\(M\)</span> 使得 <span class="math inline">\(|X_{n+1}-X_{n}|\leq M\)</span> 对任何 <span class="math inline">\(n\)</span> 都几乎处处成立。</li></ol><p>则 <span class="math inline">\(\mathbb{E}X_\tau =\mathbb{E}X_0\)</span>。</p></div><p>因此在我们的问题中 <span class="math inline">\(\mathbb{E}X_\tau =\mathbb{E}X_0 = 0\)</span>。</p><p>显然 <span class="math inline">\(X_\tau=W-\tau\)</span>，这里 <span class="math inline">\(W\)</span> 表示第 <span class="math inline">\(\tau\)</span>天结束时留在赌场内的赌徒的资金之和，<span class="math inline">\(\tau\)</span> 表示第 <span class="math inline">\(\tau\)</span> 天结束时赌博团伙总共派出了 <span class="math inline">\(\tau\)</span> 个赌徒，他们带入赌场的赌本总共是<span class="math inline">\(\tau\)</span> 元。根据上面的讨论，有 <span class="math inline">\(\mathbb{E}W=\mathbb{E}\tau\)</span>成立。这里的关键在于 <span class="math inline">\(W\)</span>不是一个随机变量，而是一个可以算出来的常数！</p><p>我们仔细分析一下当第 <span class="math inline">\(\tau\)</span>天结束的时候，哪些赌徒还在赌场内，他们各自有多少钱。由于 <span class="math inline">\(\tau\)</span>是首次有某个赌徒闯关成功的时刻，所以只有第 <span class="math inline">\(\tau-3\)</span> 到第 <span class="math inline">\(\tau\)</span> 天来赌场的这 4个赌徒还有可能留在赌场，更早的赌徒都输光走人了。其中第 <span class="math inline">\(\tau-3\)</span>天来的赌徒最幸运，赌对了全部的序列，他还有 16 元；第 <span class="math inline">\(\tau-1\)</span> 天来的赌徒也不错，他赌对了<code>HT</code>，他还有 4 元，因此赌徒们总共有 <span class="math inline">\(W=16+4=20\)</span> 元，即 <span class="math inline">\(\mathbb{E}\tau=20\)</span>。</p><p>这里第 <span class="math inline">\(\tau-1\)</span>天来的赌徒最有趣：他赌的明明是 <code>HTHT</code> 的前缀<code>HT</code>，但是由于 <code>HT</code> 恰好也是 <code>HTHT</code>的后缀，因此他也能赢到钱！</p><p>这个推理完全适用于一般的情形：设 <span class="math inline">\(P=(a_1,a_2,\cdots,a_m)\)</span> 是一个给定的由<code>T</code> 和 <code>H</code>组成的模式，我们计算它的全部既是前缀又是后缀的子序列的长度，设为 <span class="math inline">\(l_1,\cdots,l_r\)</span>，则 <span class="math inline">\(P\)</span> 的等待时间 <span class="math inline">\(\tau\)</span> 的期望为 <span class="math display">\[\mathbb{E}\tau =2^{l_1}+\cdots+2^{l_r}.\]</span></p><p>回到开头的例子：<code>HHHHHH</code>的每一个前缀都同时是它的后缀，因此它的平均等待时间为 <span class="math display">\[2^6+2^5+2^4+2^3+2^2+2^1 = 126.\]</span>所以一个模式的平均等待时间完全由它的自匹配的程度决定。</p><p>把上面的方法稍作修改，还可以用来计算 <span class="math inline">\(\tau\)</span> 的生成函数 <span class="math display">\[ \mathbb{E}[s^\tau] =\sum_{n=1}^\infty\mathbb{P}(\tau=n)s^n.\]</span> 为此只要假设第 <span class="math inline">\(n\)</span> 天来的赌徒怀里揣的钱是 <span class="math inline">\(s^n(0&lt;s&lt;1)\)</span> 即可，这里不再赘述。</p><h1 id="多个模式的等待时间与获胜概率">多个模式的等待时间与获胜概率</h1><p>假设同时有多个模式 <span class="math inline">\(A_1,\ldots,A_m\)</span>加入“赛跑”，我们想计算它们各自胜出的概率。用数学公式表示，就是设 <span class="math inline">\(A_i\)</span> 的等待时间为 <span class="math inline">\(\tau_i\)</span>，令 <span class="math display">\[\tau=\min\{\tau_1,\ldots,\tau_m\},\]</span> 则<span class="math inline">\(\tau\)</span>表示赛跑过程中冠军“撞线”的时刻，又令 <span class="math inline">\(p_i=\mathbb{P}(\tau=\tau_i)\)</span>，则 <span class="math inline">\(p_i\)</span> 表示模式 <span class="math inline">\(A_i\)</span> “夺冠” 的概率。我们想计算出每个 <span class="math inline">\(p_i\)</span> 的值来。</p><p>为此先给一个定义：</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 是两个给定的模式，且 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>都不是对方的连续子序列。我们计算所有既是 <span class="math inline">\(A\)</span> 的后缀又是 <span class="math inline">\(B\)</span> 的前缀的全部子序列，设它们的长度为<span class="math inline">\(l_1,\cdots,l_r\)</span>，定义 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 的匹配指数为 <span class="math display">\[A\ast B = 2^{l_1}+\cdots+2^{l_r}.\]</span> 如果<span class="math inline">\(A\)</span> 的任何后缀都不是 <span class="math inline">\(B\)</span> 的前缀则 <span class="math inline">\(A\ast B\)</span> 定义为 0。特别当 <span class="math inline">\(A=B\)</span> 时，<span class="math inline">\(A\astA\)</span> 就是前面计算的 <span class="math inline">\(A\)</span>的平均等待时间，这个值又叫做 <span class="math inline">\(A\)</span>的自匹配指数。</p></div><p>我们要证明这样一个引理 ：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>如果已知掷硬币的结果是以模式 <span class="math inline">\(A\)</span> 开头的，那么距离模式 <span class="math inline">\(B\)</span> 出现还需要等待的时间的期望为 <span class="math display">\[\mathbb{E}\tau_{AB} = B\ast B -A\astB.\]</span></p></div><p>引理的证明：仍然是采用赌博序列的方法，每天来的赌徒赌的是模式 <span class="math inline">\(B\)</span>，只不过这个时候我们已经知道了前 <span class="math inline">\(k\)</span> 次赌博的结果是模式 <span class="math inline">\(A\)</span>（假设序列 <span class="math inline">\(A\)</span> 的长度为 <span class="math inline">\(k\)</span>），所以不难算出前 <span class="math inline">\(k\)</span> 天赌博团伙的总资金为 <span class="math inline">\(A\ast B\)</span> 元。由于赌局始终是公平的，所以从<span class="math inline">\(k+1\)</span> 天起，直到模式 <span class="math inline">\(B\)</span> 出现的这 <span class="math inline">\(\tau_{AB}\)</span> 天里，赌徒们的净收益期望应该是0。到模式 <span class="math inline">\(B\)</span>出现时，赌徒们的资金将变成 <span class="math inline">\(B\ast B\)</span>元，所以这 <span class="math inline">\(\tau_{AB}\)</span>天中赌徒们的资金增加了 <span class="math inline">\(B\ast B-A\astB\)</span> 元，扣除他们的投入 <span class="math inline">\(\tau_{AB}\)</span>元，就是这段时间的净收益，其期望为 0： <span class="math display">\[\mathbb{E} [B\ast B-A\ast B-\tau_{AB}]=0.\]</span> 引理证毕。</p><p>接下来叙述并证明一个一般的结论：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(A_1\)</span>, <span class="math inline">\(A_2\)</span>, <span class="math inline">\(\cdots\)</span>, <span class="math inline">\(A_m\)</span> 是 <span class="math inline">\(m\)</span>个事先给定的且两两互不嵌套的模式，记矩阵 <span class="math display">\[M=\begin{pmatrix} A_1\ast A_1 &amp; A_1\astA_2&amp;\cdots&amp; A_1\ast A_m\\ A_2\ast A_1&amp;A_2\astA_2&amp;\cdots&amp; A_2\ast A_m\\\cdots&amp;\cdots&amp;\cdots&amp;\cdots\\ A_m\ast A_1&amp;A_m\astA_2&amp;\cdots&amp;A_m\ast A_m\end{pmatrix},\]</span> <span class="math display">\[\pi = (p_1,p_2,\cdots,p_m)^T,\quad\mathbf{1}=(1,1,\cdots,1)^T,\]</span> 则 <span class="math inline">\(M\)</span> 是可逆矩阵，并且 <span class="math display">\[M\pi =\mathbb{E}[\tau]\mathbf{1}.\]</span></p></div><p>在证明定理之前，先说说怎样根据定理的结论来计算 <span class="math inline">\(\mathbb{E}[\tau]\)</span> 和概率分布向量 <span class="math inline">\(\pi\)</span>。首先解出 <span class="math inline">\(MY=\mathbf{1}\)</span> 的解 <span class="math inline">\(Y=(y_1,y_2,\cdots,y_m)^T\)</span>来。根据可逆矩阵解的唯一性，必然有 <span class="math inline">\(\pi=\mathbb{E}[\tau]Y\)</span>。但是 <span class="math inline">\(\pi\)</span> 是一个概率分布，它的所有分量之和为1，因此 <span class="math display">\[\mathbb{E}[\tau]=\frac{1}{y_1+y_2+\cdots+y_m}.\]</span></p><p><span class="math inline">\(M\)</span>是可逆矩阵这一点是需要证明的，本文就省略了。事实上 <span class="math inline">\(A_i\)</span> 之间两两互不嵌套这个条件就可以保证<span class="math inline">\(M\)</span> 是可逆的。</p><p>有了 <span class="math inline">\(Y\)</span> 和 <span class="math inline">\(\mathbb{E}[\tau]\)</span> 自然立刻就得到了 <span class="math inline">\(\pi\)</span>。</p><p>定理的证明：我们有 <span class="math display">\[\mathbb{E}[\tau_i] =\mathbb{E}[\tau] + \mathbb{E}[\tau_i-\tau] =\mathbb{E}[\tau]+\sum_{j=1}^m p_j\mathbb{E}[\tau_i-\tau|\tau=\tau_j].\]</span>根据引理， <span class="math display">\[\mathbb{E}[\tau_i-\tau|\tau=\tau_j] = A_i\astA_i-A_j\ast A_i,\]</span> 因此 <span class="math display">\[A_i\astA_i=\mathbb{E}[\tau]+A_i\ast A_i-\sum_{j=1}^np_j A_j\ast A_i.\]</span>这就证明了定理。</p><h1 id="penney-游戏">Penney 游戏</h1><p>Penney 游戏是两个玩家 Bob 和 Alice的博弈游戏，它以掷硬币为工具：游戏开始前，两人各自选择一个长度为 3 的由<code>H</code> 和 <code>T</code> 组成的模式，比如说 Bob 选择<code>HHH</code>，Alice 选择<code>THH</code>，然后掷硬币直到其中一人选择的模式首先出现，先出现的一方获胜。</p><p>Penney 游戏有一个独特之处：</p><blockquote><p>假设 Bob 先选择他的序列，则不论 Bob 怎样选，Alice总可以“针锋相对”地选一个合适的序列，使得自己的获胜概率更高。总而言之，Penney游戏是所谓的“后发制人，先发者制于人”。</p></blockquote><p>这个有点类似于我们都熟悉的“剪子，石头，布”游戏。在 Penney游戏中，各种策略循环相克，<a href="http://en.wikipedia.org/wiki/Penney's_game">维基百科</a>中给出了各种情形下二人的获胜概率之比。在这个例子中，Alice 的获胜概率为7/8。</p><p>Penney 游戏是非传递博弈的典型例子：策略 <span class="math inline">\(A\)</span> 优于 <span class="math inline">\(B\)</span>，<span class="math inline">\(B\)</span>优于 <span class="math inline">\(C\)</span> 并不能推出 <span class="math inline">\(A\)</span> 优于 <span class="math inline">\(C\)</span>。</p><p>在只有两个模式 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span>的情形，二者各自获胜的概率有一个很简单的表达式：</p><div class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(A,B\)</span>是两个给定的序列，它们互不为对方的连续子序列，则序列 <span class="math inline">\(B\)</span> 和序列 <span class="math inline">\(A\)</span> 的获胜概率之比为 <span class="math inline">\(p_B:p_A = (A\ast A-A\ast B):(B\ast B-B\astA)\)</span>。</p></div><h1 id="还有更不可思议的事情">还有更不可思议的事情</h1><p>我们已经介绍了怎样计算一个模式的平均等待时间，以及多个模式同时“赛跑”时各自的获胜概率。我们现在来看看<code>THTH</code> 和 <code>HTHH</code> 比赛的结果如何。</p><p>首先不难算出 <code>THTH</code> 的平均等待时间是 20，<code>HTHH</code>的平均等待时间是 18，也就是说 <code>THTH</code>跑的慢一些，<code>HTHH</code>跑的快一些，那这是不是意味着让它俩赛跑的话，<code>HTHH</code>获胜的概率更大啊？</p><p>答案是否定的，这其实是一个一面倒的竞赛：</p><blockquote><p>看起来慢一些的模式 <code>THTH</code>，其与 <code>HTHH</code>的胜算之比为 9 比 5，即平均每 14 场赛跑，<code>THTH</code> 会赢 9场，而貌似快一些的 <code>HTHH</code> 倒只赢 5 场。</p></blockquote><p>为什么会出现这种反直觉的现象呢？其实“跑得慢”和“赢得多”并不矛盾。我们随便看一个由<code>H</code> 和 <code>T</code> 组成的随机序列：</p><p>HHTHT<font color="red">H</font><font color="green">H</font>THT<font color="red">H</font><font color="green">H</font>TTTHHTH<font color="green">H</font>HHTTHHTTHTTHT<font color="red">H</font><font color="green">H</font>TH<font color="green">H</font>TH<font color="green">H</font>TH<font color="green">H</font>HHTTHTTTTTTHTTHT<font color="red">H</font>TTHHTH<font color="green">H</font>HHHHTTHT<font color="red">H</font><font color="green">H</font>THT<font color="red">H</font><font color="green">H</font>TTTTTHTTHHHHHHTH<font color="green">H</font>HTTTHTTTHTTTHHHTH<font color="green">H</font>THT<font color="red">H</font>TTTHTTHTTHT<font color="red">H</font><font color="green">H</font>TH<font color="green">H</font>TTHT<font color="red">H</font><font color="green">H</font>HTTHH…</p><p>其中分别用红色和绿色标记了模式 <code>THTH</code> 和 <code>HTHH</code>的出现的位置。注意到任何绿色 <code>H</code>后面连续的三个字符中绝对不会出现红色 <code>H</code>，而大约一半的红色的<code>H</code> 后面紧跟一个绿色的<code>H</code>。所以从一个随机序列中任选一点作为起点开始比赛，那么在红色<code>H</code> 先撞线的比赛中，第二个撞线的绿色 <code>H</code>往往会只落后一个身位，但是在绿色 <code>H</code> 先撞线的比赛中，红色的<code>H</code> 至少要落后四个身位以上。</p><p>用足球来类比，领先一个身位就好比取得一个净胜球。净胜球少和积分领先并不矛盾。<code>THTH</code>击败 <code>HTHH</code> 的方法类似“一比零主义”：虽然平均下来<code>THTH</code>耗时长一些（每场净胜球少），但积分是领先的（赢的场数多）。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Li1980" class="csl-entry" role="listitem">Li, Shuo-Yen Robert. 1980. <span>“<span class="nocase">A MartingaleApproach to the Study of Occurrence of Sequence Patterns in RepeatedExperiments</span>.”</span> <em>The Annals of Probability</em> 8 (6):1171–76. <a href="https://doi.org/10.1214/aop/1176994578">https://doi.org/10.1214/aop/1176994578</a>.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>洛奇绵羊问题</title>
      <link href="mabinogion-sheep-problem/"/>
      <url>mabinogion-sheep-problem/</url>
      
        <content type="html"><![CDATA[<p><img style="margin:0px auto;display:block" src="/images/midjourney/mabinogion.png" width="350"></p><p>今天的问题源自中世纪威尔士人的故事集《Mabinogion》中的一段：</p><blockquote><p>一个男孩来到了一个美丽的山谷，有一条小河在谷中流淌。他看到河一边的草地上有一群黑绵羊，另一边的草地上有一群白绵羊。羊群被施以一种魔法：每个时刻都恰有一只绵羊发出咩咩的叫声。如果发出叫声的是白绵羊，就会有一只黑绵羊趟过小河跑过来并且变成白绵羊；如果发出叫声的是黑绵羊，则会有一只白绵羊趟过小河跑过去并且变成黑绵羊。每个时刻发出叫声的绵羊是完全随机的，整个过程没有绵羊出生或者死亡，一直持续到所有绵羊都变成同一种颜色为止。</p></blockquote><p>问题是这样的：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>如果男孩可以选择在初始时刻 <span class="math inline">\(0\)</span>，或者是每个魔法时刻 <span class="math inline">\(1,2,\ldots\)</span>结束后将任意数量的白绵羊赶出山谷，那么为了最终得到尽可能多的黑绵羊，他应该采取怎样的策略？</p></div><span id="more"></span><p>洛奇绵羊问题出自 <span class="citation" data-cites="Williams1991">(<a href="#ref-Williams1991" role="doc-biblioref">Williams1991</a>)</span>，是一个很有趣的问题。这种在随机的环境中施加一个控制的力，以最大化期望收益的问题属于随机控制的范畴。</p><p>我们首先说明不论男孩采取怎样的策略，最终羊群都会以概率 1全部变成同一种颜色。</p><p>设 <span class="math inline">\(\Omega=\{(w,b)\in\mathbb{Z}_{\geq0}\times\mathbb{Z}_{\geq0}\}\)</span>是羊群所有可能的状态组成的集合，其中 <span class="math inline">\(w\)</span> 和 <span class="math inline">\(b\)</span>分别表示白绵羊和黑绵羊的数目。男孩采取的一个策略 <span class="math inline">\(S\)</span> 就是从一个状态 <span class="math inline">\((w,b)\)</span> 移动到另一个状态 <span class="math inline">\((w',b')\)</span> 的规则：根据当前 <span class="math inline">\((w,b)\)</span> 的值，男孩决定到底是按兵不动（不做任何干预），还是赶走 <span class="math inline">\(c\)</span>只白绵羊，把状态 <span class="math inline">\((w,b)\)</span> 变成状态<span class="math inline">\((w-c,b)\)</span>，这里 <span class="math inline">\(0&lt;c\leq w\)</span>是一个正整数。如果男孩始终不做任何干预的话，那么羊群状态将始终保持在线段<span class="math display">\[\{ (x,y)\mid x\geq0, y\geq0,x+y=w+b\}\]</span> 上，这是一个互通的 Markov 链，因此以概率 1撞到吸收状态 <span class="math inline">\((0,w+b)\)</span> 或 <span class="math inline">\((w+b,0)\)</span>，即最终变成同一种颜色。如果男孩在某个时刻移走了<span class="math inline">\(c\)</span>只白绵羊，那么系统将会被强制转移到线段 <span class="math display">\[\{(x,y)\mid x\geq0, y\geq0, x+y=w+b-c\}\]</span>上，如此下去。由于男孩只能进行有限次移走绵羊的操作，可见不论男孩策略如何，羊群总是会最终变成同色的。</p><p>对任何策略 <span class="math inline">\(S\)</span>，我们用 <span class="math inline">\(V_S(w,b)\)</span> 表示从 <span class="math inline">\((w,b)\)</span> 状态出发，在策略 <span class="math inline">\(S\)</span> 下最终得到的黑绵羊数量的期望值。这里<span class="math inline">\(V_S\)</span> 是一个由 <span class="math inline">\(S\)</span> 决定的确定的函数，它不包含随机性。<span class="math inline">\(V_S\)</span> 叫做策略 <span class="math inline">\(S\)</span> 的值函数。显然 <span class="math inline">\(V_S\)</span> 总是满足边界条件 <span class="math display">\[V_S(0,b)=b,\quadV_S(w,0)=0\label{eq:boundary}\tag{$\ast$}.\]</span></p><p>假设我们能够找到这样一个策略 <span class="math inline">\(A\)</span>，它的值函数 <span class="math inline">\(V_A\)</span> 有如下性质，那么它就是最佳策略：</p><blockquote><p><strong>最优策略的充分条件</strong>：如果策略 <span class="math inline">\(A\)</span> 的值函数 <span class="math inline">\(V_A\)</span> 满足如下条件：对任何初始状态 <span class="math inline">\((w,b)\)</span> 和任何的策略 <span class="math inline">\(S\)</span>，设羊群在策略 <span class="math inline">\(S\)</span> 下第 <span class="math inline">\(n\)</span> 个魔法时刻结束后的状态为 <span class="math inline">\((W_n,B_n)\)</span>，序列 <span class="math inline">\(\{V_A(W_n,B_n),n=0,1,\ldots\}\)</span>是上鞅，则策略 <span class="math inline">\(A\)</span> 就是最优的。</p></blockquote><p>注意这里是把任一策略 <span class="math inline">\(S\)</span>下的状态序列 <span class="math inline">\((W_n, B_n)\)</span> 代入策略<span class="math inline">\(A\)</span> 的值函数中。</p><p>其中的道理非常简单：对任何策略 <span class="math inline">\(S\)</span>，由于其吸收状态 <span class="math inline">\((W_\infty,B_\infty)\)</span> 中必有一个分量是0，从而由值函数边界条件 <span class="math inline">\((\ref{eq:boundary})\)</span> 有 <span class="math inline">\(B_\infty=V_A(W_\infty,B_\infty)\)</span>，所以<span class="math display">\[\mathbb{E}[B_\infty]=\mathbb{E}[V_A(W_\infty,B_\infty)]\leq\mathbb{E}[V_A(w,b)]=V_A(w,b).\]</span> 其中最后一个等号是因为 <span class="math inline">\(V_A(w,b)\)</span>是一个常数，常数的期望等于自身。</p><p>在教材中，Williams 直接“猜出”了策略 <span class="math inline">\(A\)</span>：</p><blockquote><p><strong>策略 <span class="math inline">\(A\)</span></strong>：如果当前黑绵羊的数量多于白绵羊，则什么也不做；否则就把白绵羊的数量变为黑绵羊的数量减1。</p></blockquote><p>显然 <span class="math inline">\(V_A\)</span> 有如下性质：</p><div id="recurrence" class="statement sta_v_a______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label"><span class="math inline">\(V_A\)</span> 的递推关系</span>.</span></p><ol type="1"><li>边界条件 <span class="math inline">\(V_A(0,b)=b\)</span>，<span class="math inline">\(V_A(w,0)=0\)</span>。</li><li><span class="math inline">\(V_A(w,b)=V_A(w-1,b), w\geqb&gt;0\)</span>。</li><li><span class="math inline">\(V_A(w,b)=\frac{w}{w+b}V_A(w+1,b-1)+\frac{b}{w+b}V_A(w-1,b+1)\)</span>,<span class="math inline">\(b&gt;w&gt;0\)</span>。</li></ol></div><p><span class="math inline">\(V_A\)</span> 由边界条件 1 和递推关系 2, 3完全决定。</p><p>从定义上看，关系 2 只在一半的区域上成立，而关系 3则在另一半的区域上成立。但是花费一番功夫，我们其实可以证明它们各自的“弱形式”在整个区域上都是对的：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>在区域 <span class="math inline">\(\Omega\)</span> 上，<span class="math inline">\(V_A\)</span> 函数满足如下的不等式：</p><ol start="4" type="1"><li><span class="math inline">\(V_A(w,b)\geq V_A(w-1,b),w&gt;0\)</span>。</li><li><span class="math inline">\(V_A(w,b)\geq\frac{w}{w+b}V_A(w+1,b-1)+\frac{b}{w+b}V_A(w-1,b+1),w&gt;0,b&gt;0\)</span>。</li></ol></div><p>4, 5 合起来说的就是无论男孩策略如何，<span class="math inline">\(\{V_A(W_n,B_n)\}\)</span> 总是一个上鞅！因此策略 <span class="math inline">\(A\)</span> 确实是最优的。</p><p>引理的证明是纯粹的分析，过程比较繁琐，我把它留给 Williams 的教材第15.3 节。写出 <span class="math inline">\(V(w,b)\)</span>的显式表达式来是很难的，Williams 证明了 <span class="math display">\[\lim_{k\to\infty}V(k,k)-(2k+\frac{\pi}{4}-\sqrt{\pik})=0.\label{eq:vkk}\tag{$\ast\ast$}\]</span> 因此如果开始有黑、白绵羊各10000 只，则策略 <span class="math inline">\(A\)</span>下黑绵羊的期望数目大约是 19824 只。</p><p>我对 Williams给出的估计不太放心，于是用书中给出的递推关系写了一段代码验证了一下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> *<br><br>pi = <span class="hljs-number">3.14159265358979</span><br>getcontext().prec = <span class="hljs-number">20</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solve_sheep</span>(<span class="hljs-params">n</span>):</span><br>    p = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    v = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n + <span class="hljs-number">1</span>)]<br>    v[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span><br>    p[<span class="hljs-number">1</span>] = Decimal(<span class="hljs-number">0.5</span>)<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, n + <span class="hljs-number">1</span>):<br>        p[k] = (<span class="hljs-number">1</span> - <span class="hljs-number">1</span> / Decimal(<span class="hljs-number">2</span> * k)) * p[k - <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>        w = (<span class="hljs-number">1</span> - p[k]) / (<span class="hljs-number">1</span> + p[k])<br>        v[k + <span class="hljs-number">1</span>] = w * v[k] + (<span class="hljs-number">1</span> - w) * (<span class="hljs-number">2</span> * k + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">return</span> v[n]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">estimate_sheep</span>(<span class="hljs-params">n</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * n + pi / <span class="hljs-number">4</span> - (pi * n)**<span class="hljs-number">0.5</span><br><br>print(solve_sheep(<span class="hljs-number">10000</span>))<br>print(estimate_sheep(<span class="hljs-number">10000</span>))<br></code></pre></td></tr></tbody></table></figure><p>递推公式给出的真实值结果是 19823.5422285701，渐进公式给出的结果是19823.540013，准确的有点离谱啊！这真的有点刷新我对 Stirling公式的认知。</p><p>猜出最优策略、证明弱化的不等式、给出渐进公式，每一步都是神操作啊。</p><h1 id="附录">附录</h1><p>Williams 书中对渐进公式 <span class="math inline">\((\ref{eq:vkk})\)</span>的证明比较难读，我这里解释下其中的想法。关键是用对角线上的值 <span class="math inline">\(v_k=V(k,k)\)</span> 来表示出所有的 <span class="math inline">\(V(w, b),b&gt;w&gt;0\)</span>：</p><p><span class="math display">\[\begin{cases}V(k-c,k+c)=v_k+(2k-v_k)a_c,\\ V(k+1-c,k+c)=v_k+(2k+1-v_k)b_c.\end{cases}\]</span></p><p>其中</p><p><span class="math display">\[\begin{cases}a_c=2^{-(2k-2)}\sum\limits_{j=k}^{k+c-1}\dbinom{2k-1}{j},\\b_c=\left(2^{2k-1}+\frac{1}{2}\dbinom{2k}{k}\right)^{-1}\sum\limits_{j=k}^{k+c-1}\dbinom{2k}{j}.\end{cases}\]</span></p><p>Williams没有解释这组公式是怎么求出来的，它看起来很吓人，其实道理不复杂。我们用<span class="math inline">\(V(k-c,k+c)\)</span> 为例子来说明：</p><p>记 <span class="math inline">\(g(c) = V(k-c, k+c),0\leq c\leqk\)</span>，则 <span class="math inline">\(g(0)=v_k,\,g(k)=2k\)</span>，由前面 <a href="#recurrence" title="V_A 的递推关系"><span class="math inline">\(V_A\)</span> 的递推关系</a> 中的 3知其满足递推关系</p><p><span class="math display">\[g(c) = \frac{k-c}{2k}g(c-1) +\frac{k+c}{2k}g(c+1),\quad 1\leq c \leq k-1.\]</span> 这是一个 <span class="math inline">\([0,k]\)</span> 上的递推序列，并且已知边界条件<span class="math inline">\(g(0)\)</span> 和 <span class="math inline">\(g(k)\)</span>，我们来求解这个序列。</p><p>记</p><p><span class="math display">\[h(c) = \frac{g(c) - g(0)}{g(k)-g(0)} =\frac{g(c) - v_k}{g(k)-v_k}.\label{eq:hc}\tag{1}\]</span></p><p>则 <span class="math inline">\(h(c)\)</span>同样满足上述递推关系，但是边界条件为 <span class="math inline">\(h(0)=0\)</span>，<span class="math inline">\(h(k)=1\)</span>。于是</p><p><span class="math display">\[\begin{align}h(c+1)-h(c)&amp;=\frac{k-c}{k+c}(h(c)-h(c-1))\\&amp;=\cdots\\&amp;=\frac{(k-c)\cdots(k-1)}{(k+c)\cdots(k+1)}(h(1)-h(0))\\&amp;=\frac{\dbinom{2k-1}{k+c}}{\dbinom{2k-1}{k}}h(1).\label{eq:hrec}\tag{2}\end{align}\]</span></p><p>利用 <span class="math inline">\((\ref{eq:hrec})\)</span>我们可以解出 <span class="math inline">\(h(1)\)</span> 来：</p><p><span class="math display">\[1=h(k)=\sum_{c=0}^{k-1}\big(h(c+1)-h(c)\big)=h(1)\frac{\sum_{c=0}^{k-1}\dbinom{2k-1}{k+c}}{\dbinom{2k-1}{k}}=h(1)\dfrac{2^{2k-2}}{\dbinom{2k-1}{k}}.\]</span></p><p>即 <span class="math inline">\(h(1)=2^{-(2k-2)}\binom{2k-1}{k}\)</span>。再次利用<span class="math inline">\((\ref{eq:hrec})\)</span> 可得</p><p><span class="math display">\[h(c)=\sum_{j=0}^{c-1}\big(h(j)-h(j-1)\big)=\sum_{j=0}^{c-1}\frac{\dbinom{2k-1}{k+j}}{\dbinom{2k-1}{k}}h(1)=2^{-(2k-2)}\sum_{j=k}^{k+c-1}\dbinom{2k-1}{j}.\]</span></p><p>将上式代入 <span class="math inline">\((\ref{eq:hc})\)</span>即得结论。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Williams1991" class="csl-entry" role="listitem">Williams, David. 1991. <em>Probability with Martingales</em>. CambridgeUniversity Press.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>飞船空间跳跃问题</title>
      <link href="spaceship-jump/"/>
      <url>spaceship-jump/</url>
      
        <content type="html"><![CDATA[<p>本文的问题出自 Williams 的教材 <a href="https://www.cambridge.org/highereducation/books/probability-with-martingales/B4CFCE0D08930FB46C6E93E775503926#overview">ProbabilitywithMartingales</a>，虽然不算很难但是综合使用了许多知识，展示了抽象的鞅理论其实有着丰富多彩的应用。</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"></span>一艘太空船正在宇宙中做星际航行时，飞船的控制系统出了故障，飞船不能正常地进行空间跳跃，而是只能预先设定一个距离，然后以此距离进行一次方向完全随机的跳跃。现在飞船想要返回太阳系。假设太阳系的半径是<span class="math inline">\(r\)</span>，发生故障时飞船与太阳的距离为<span class="math inline">\(R&gt;r\)</span>。好消息是在每个时刻，飞船能够知道自身与太阳系的距离。</p><p>求证：不论采用怎样的跳跃策略，飞船返回太阳系的概率都小于 <span class="math inline">\(r/R\)</span>；但是对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，可以采取适当的策略，使得飞船返回太阳系的概率大于<span class="math inline">\((r-\epsilon)/R\)</span>，即 <span class="math inline">\(r/R\)</span> 是最优概率。这个最优策略是什么？</p></div><span id="more"></span><h1 id="预备知识">预备知识</h1><h2 id="条件期望的预备知识">条件期望的预备知识</h2><p>设 <span class="math inline">\(X,Y\)</span> 是两个随机变量，<span class="math inline">\(\varphi\)</span> 是可测函数。我们考虑条件期望<span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|X]\)</span>，这是一个关于<span class="math inline">\(\sigma(X)\)</span> 可测的随机变量，根据Doob-Dynkin 引理，它可以写成 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|X]=g(X)\]</span>的形式，其中 <span class="math inline">\(g\)</span> 是一个 Borel可测函数。但是这个 <span class="math inline">\(g\)</span>具体是什么呢？下面的 freezing lemma <span class="citation" data-cites="Williams1991">(<a href="#ref-Williams1991" role="doc-biblioref">Williams 1991, sec. 9.10</a>)</span> or <span class="citation" data-cites="Durrett2019">(<a href="#ref-Durrett2019" role="doc-biblioref">Durrett 2019, sec. 4.1</a>)</span>告诉我们，在一定条件下我们可以先将 <span class="math inline">\(X\)</span> 冻结为一个实数值 <span class="math inline">\(x\)</span>，上式的右边变成 <span class="math inline">\(g(x)\)</span>，左边变成 <span class="math inline">\(\{X=x\}\)</span> 条件下的期望 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|X=x]=\mathop{\mathrm{\mathbb{E}}}\varphi(x,Y).\]</span>即 <span class="math inline">\(g(x)=\mathop{\mathrm{\mathbb{E}}}\varphi(x,Y)\)</span>。这就找到了<span class="math inline">\(g\)</span> 的表达式。</p><div id="freeze" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\((\Omega,\mathcal{F},\mu)\)</span>是一个概率空间，<span class="math inline">\(X, Y\)</span>是两个取值在某可测空间 <span class="math inline">\((S,\mathcal{S})\)</span> 中的随机变量，子 <span class="math inline">\(\sigma\)</span> 域 <span class="math inline">\(\mathcal{G}\subseteq\mathcal{F}\)</span> 满足<span class="math inline">\(X\in\mathcal{G}\)</span> 且 <span class="math inline">\(\mathcal{G}\)</span> 与 <span class="math inline">\(Y\)</span> 独立。可测函数 <span class="math inline">\(\varphi: S\times S\to\mathbb{R}\)</span> 满足<span class="math inline">\(\varphi\)</span> 非负或者 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}|\varphi(X,Y)|&lt;\infty\)</span>。令 <span class="math inline">\(g(x)=\mathop{\mathrm{\mathbb{E}}}\varphi(x,Y)\)</span>，则 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|\mathcal{G}]=g(X).\]</span></p></div><p>我们举个例子：假设 <span class="math inline">\(X, Y\)</span>是两个独立的随机变量，<span class="math inline">\(Y\)</span> 服从的是<span class="math inline">\([0, 1]\)</span> 上的均匀分布，<span class="math inline">\(X\)</span> 服从的分布我们可以不用关心。问条件期望<span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\sin(XY)|X]\)</span>是什么？这相当于在引理中取 <span class="math inline">\(\varphi(X,Y)=\sin(XY)\)</span> 和 <span class="math inline">\(\mathcal{G}=\sigma(X)\)</span>。<a href="#freeze" title="引理 1.1">引理 1.1</a> 告诉我们可以把 <span class="math inline">\(\sin(XY)\)</span> 中的 <span class="math inline">\(X\)</span> 冻结为常数 <span class="math inline">\(X=x\)</span>，把 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\sin(XY)|X]\)</span>视作关于常数 <span class="math inline">\(x\)</span> 的积分 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\sin(xY)]=\int_0^1\sin(xy)\,\mathrm{d}y = \frac{1}{x}\int_0^x\sin(z)\,\mathrm{d}z=\frac{1-\cos x}{x}.\]</span> 然后把 <span class="math inline">\(x\)</span> 解冻为 <span class="math inline">\(X\)</span> 即得 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\sin(XY)|X] =\frac{1-\cos X}{X}.\]</span></p><p><a href="#freeze" title="引理 1.1">引理 1.1</a> 中的可测空间 <span class="math inline">\((S,\mathcal{S})\)</span> 可以是多维空间 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>，<span class="math inline">\(X,Y\)</span> 也可以是独立的随机向量。即如果 <span class="math inline">\(\varphi(X_1,\ldots,X_n,Y_1,\ldots,Y_m)\)</span>是关于随机变量的可测函数，<span class="math inline">\(\sigma(X_1,\ldots,X_n)\subset\mathcal{G}\)</span>并且 <span class="math inline">\(\mathcal{G}\)</span> 和 <span class="math inline">\(\sigma(Y_1,\ldots,Y_m)\)</span> 独立，那么条件期望<span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\varphi(X,Y)|\mathcal{G}]\)</span>就是一个以 <span class="math inline">\((x_1,\ldots,x_n)\)</span>为参变元的多重积分 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\varphi(x_1,\ldots,x_n,Y_1,\ldots,Y_m)]=g(x_1,\ldots,x_n).\]</span></p><p><strong>证明</strong>：我们要证明对任何可测集 <span class="math inline">\(C\in\mathcal{G}\)</span> 有</p><p><span class="math display">\[\int_C \varphi(X, Y)\mathrm{d}\mu =\int_C g(X)\mathrm{d}\mu.\]</span> 当 <span class="math inline">\(\varphi(x,y)=\mathbb{1}_A(x)\mathbb{1}_B(y)\)</span> 时，<span class="math inline">\(g(x)=\mathbb{1}_A(x)\mathbb{P}(\{Y\inB\})\)</span>，从而 <span class="math display">\[\begin{align*}\int_C\mathbb{1}_A(X)\mathbb{1}_B(Y)\mathrm{d}\mu&amp;=\mathbb{P}(\{X\inA\}\cap C\cap\{Y\in B\})\\&amp;=\mathbb{P}(\{X\in A\}\capC)\cdot\mathbb{P}(\{Y\inB\})\\&amp;=\int_C\mathbb{1}_A(X)\mathrm{d}\mu\cdot\mathbb{P}(\{Y\inB\})\\&amp;=\int_C g(X)\mathrm{d}\mu.\end{align*}\]</span></p><p>于是结论对所有形如 <span class="math inline">\(A\times B\)</span>的集合的示性函数成立。这些函数构成一个 <span class="math inline">\(\pi-\)</span> 系。根据可测函数的单调类定理(monotone class theorem)，结论对所有非负或者可积函数都成立。</p><h2 id="分析的预备知识">分析的预备知识</h2><div id="newton-potential" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B=B(A,R)\)</span> 是 <span class="math inline">\(\mathbb{R}^3\)</span> 中以点 <span class="math inline">\(A\)</span> 为中心，半径为 <span class="math inline">\(R\)</span> 的球，<span class="math inline">\(X\)</span> 是球面上均匀分布的随机点，则 <span class="math inline">\(X\)</span> 与原点 <span class="math inline">\(O\)</span> 之间距离倒数的期望为 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}\frac{1}{|X|}=\begin{cases}1/a&amp; a&gt;R,\\ 1/R &amp; a\leq R.\end{cases}\]</span> 其中 <span class="math inline">\(a=|A|\)</span> 是 <span class="math inline">\(A\)</span> 与原点之间的距离。</p></div><p>这个引理其实是我们都熟悉的高中物理知识：假设以 <span class="math inline">\(A\)</span> 为中心，半径为 <span class="math inline">\(R\)</span> 的球壳上有总量为 1的均匀分布的电荷，则球壳表面和内部的电势处处等于 <span class="math inline">\(1/R\)</span>，球壳外部任意一点 <span class="math inline">\(P\)</span> 的电势等于 <span class="math inline">\(P\)</span> 和球心距离的倒数，即 <span class="math inline">\(1/|P-A|\)</span>（不计物理常数），此即为结论。</p><p>当然这不是一个严格的证明，实际上这个积分正是 Newton势函数的简单情形。由于这不是本文的重点，就不再展开讲了，读者可以参考<span class="citation" data-cites="Donoghue2014">(<a href="#ref-Donoghue2014" role="doc-biblioref">Donoghue 2014, chap.8</a>)</span>。</p><h1 id="建立模型">建立模型</h1><ol type="1"><li><p>初始时刻为 0，太阳系是以原点为圆心，半径为 <span class="math inline">\(r\)</span> 的球，飞船初始位置在 <span class="math inline">\((R,0,0)\)</span> 处。</p></li><li><p>设 <span class="math inline">\(\{U_n\}_{n\geq 1}\)</span>是定义在某个概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\)</span>上的一组独立同分布的、在单位球面上均匀分布的随机向量，它们表示飞船每次空间跳跃的随机方向。并设<span class="math inline">\(\mathcal{F}_n=\sigma(U_1,\ldots,U_n)\)</span> 以及<span class="math inline">\(\mathcal{F}_0=(\Omega,\emptyset)\)</span>。</p></li><li><p>设第 <span class="math inline">\(n\)</span> 次空间跳跃的距离为<span class="math inline">\(l_n(n\geq1)\)</span>，由于 <span class="math inline">\(l_n\)</span> 是根据 <span class="math inline">\(n\)</span> 时刻之前的信息决定的，所以 <span class="math inline">\(l_n\)</span> 关于 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 可测。</p></li><li><p>设第 <span class="math inline">\(n\)</span>次空间跳跃后飞船的坐标为 <span class="math inline">\(X_n\)</span>，那么<span class="math display">\[X_n=X_{n-1} + l_n U_n.\quadn=1,2,\ldots.\]</span> 其中 <span class="math inline">\(X_0=(R,0,0)\)</span> 是飞船的初始位置。</p></li><li><p>设 <span class="math inline">\(T\)</span>是飞船首次返回太阳系的时间： <span class="math display">\[T = \inf\,\{n\mid X_n\in B(0,r)\},\]</span>则 <span class="math inline">\(T\)</span>的取值范围是 <span class="math inline">\(\mathbb{N^+}\cup\{+\infty\}\)</span>。我们要估算的是事件<span class="math inline">\(\{T&lt;+\infty\}\)</span>的概率，这正是飞船能够在有限时间内回到太阳系的概率。</p></li></ol><p>现在我们着手研究一下飞船的运动规律。</p><p>设 <span class="math inline">\(R_n\)</span> 为第 <span class="math inline">\(n\)</span> 次跳跃以后飞船与太阳系的距离，<span class="math inline">\(R_0=R\)</span>，我们想知道 <span class="math inline">\(R_n\)</span> 和 <span class="math inline">\(R_{n+1}\)</span> 之间的关系。</p><p>对 <span class="math inline">\(\mathcal{F}=\mathcal{F}_n,\,\mathcal{G}=\mathcal{F}_{n-1},\,X=(X_{n-1},l_n),\,Y=U_n,\,\varphi(X,Y)=1/|X_{n-1}+l_nY|\)</span> 应用前面的关于条件期望的 <a href="#freeze" title="引理 1.1">引理 1.1</a> 和 <a href="#newton-potential" title="引理 1.2">引理 1.2</a> 得到</p><p><span class="math display">\[\mathop{\mathrm{\mathbb{E}}}\left[\left.\frac{1}{R_n}\right|\mathcal{F}_{n-1}\right]=\mathop{\mathrm{\mathbb{E}}}\left.\frac{1}{\left|X_{n-1}+l_nU_n\right|}\right|_{X_{n-1}=A}\leq\frac{1}{|A|}=\frac{1}{R_{n-1}}.\]</span></p><p>这里由于 <span class="math inline">\(X_{n-1}\)</span> 和 <span class="math inline">\(l_n\)</span> 都是关于 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 可测的，而 <span class="math inline">\(U_n\)</span> 和 <span class="math inline">\(\mathcal{F}_{n-1}\)</span> 是独立的，所以应用 <a href="#freeze" title="引理 1.1">引理 1.1</a> 的条件是满足的。</p><p>总结一下：</p><div id="supermartingale" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\{1/R_n\}\)</span> 关于 <span class="math inline">\(\{\mathcal{F}_n\}\)</span> 构成一个上鞅（与策略无关）。特别地如果跳跃距离总是不超过当前飞船与太阳系的距离，即对任何<span class="math inline">\(n\geq1\)</span> 有 <span class="math inline">\(l_n\leq R_{n-1}\)</span>，则 <span class="math inline">\(\{1/R_n\}\)</span> 还是一个鞅。</p></div><p><strong>证明</strong>：只要再说明每个 <span class="math inline">\(1/R_n\)</span> 是可积的随机变量即可。由于 <span class="math inline">\(1/R_n\)</span> 是非负的随机变量因此 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[1/R_n|\mathcal{F}_{n-1}]\)</span>是有定义的且已经证明其小于等于 <span class="math inline">\(1/R_{n-1}\)</span>，于是 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[1/R_n]=\mathop{\mathrm{\mathbb{E}}}[\mathop{\mathrm{\mathbb{E}}}[1/R_n|\mathcal{F}_{n-1}]]\leq\mathop{\mathrm{\mathbb{E}}}[1/R_{n-1}],\]</span>所以对 <span class="math inline">\(n\)</span> 归纳即可。</p><p><a href="#supermartingale" title="定理 2.1">定理 2.1</a>是解决整个问题最关键的一步，有了它就海阔天空，没有它就寸步难行。由它我们立刻可以导出一个有趣的观察：由于非负上鞅总是几乎处处收敛的，因此<a href="#supermartingale" title="定理 2.1">定理 2.1</a> 的结论蕴含<span class="math inline">\(\lim\limits_{n\to\infty}R_n(\omega)\)</span>是几乎处处存在的（可以是正无穷），而这有两种可能：<span class="math inline">\(\lim\limits_{n\to\infty}R_n(\omega)=+\infty\)</span>或者 <span class="math inline">\(\lim\limits_{n\to\infty}R_n(\omega)=a&lt;+\infty\)</span>。所以飞船要么飞向无穷远，即迷失在宇宙的深处，要么被吸引到某个有限的位置。</p><p>现在我们可以证明：</p><div id="lessthan" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.2</span>.</span><span class="statement-spah"></span>不论飞船采取怎样的策略，返回太阳系的概率都严格小于 <span class="math inline">\(r/R\)</span>。</p></div><p>证明只用到非常基础的鞅的知识：</p><p>设 <span class="math inline">\(Z_n=1/R_n\)</span>，则 <span class="math inline">\(\{Z_n\}\)</span> 是一个非负上鞅，所以 <span class="math inline">\(Z_\infty=\lim\limits_{n\to\infty}Z_n\)</span>是几乎处处存在的。考虑由停时 <span class="math inline">\(T\)</span>截断得到的非负上鞅序列 <span class="math inline">\(\{Z_{T\wedgen}\}\)</span>，这个上鞅序列也是几乎处处收敛的，其中 <span class="math display">\[\lim_{n\to\infty}Z_{T\wedge n} =\begin{cases}\lim_{n\to\infty}Z_n&amp; T=\infty,\\ Z_T&amp;T&lt;\infty.\end{cases}\]</span> 一方面根据非负可积函数列的 Fatou 引理有<span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]\leq\varliminf_{n\to\infty}\mathop{\mathrm{\mathbb{E}}}[Z_{T\wedgen}]\leq \mathop{\mathrm{\mathbb{E}}}[Z_0]=\frac{1}{R}.\]</span>另一方面</p><p><span class="math display">\[\begin{align*}\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]&amp;=\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]+\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_n\mathbb{1}_{\{T=\infty\}}]\\&amp;\geq \mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]\geq\frac{\mathbb{P}(T&lt;\infty)}{r}.\end{align*}\]</span></p><p>其中最后一个不等号是因为 <span class="math inline">\(Z_T\geq1/r\)</span>。综合这两个不等式就得到了 <span class="math inline">\(\mathbb{P}(T&lt;\infty)\leqr/R\)</span>，即任何策略下飞船最终返回太阳系的概率不大于 <span class="math inline">\(r/R\)</span>。</p><p>要证明这个概率是严格小于 <span class="math inline">\(r/R\)</span>的，我们只要证明上面式子的最后一个不等号是严格成立的： <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]&gt;\frac{\mathbb{P}(T&lt;\infty)}{r}.\]</span></p><p>当然需要假定这里的 <span class="math inline">\(\{T&lt;\infty\}\)</span> 有正概率 （返回概率是 0的话当然小于 <span class="math inline">\(r/R\)</span>，没什么好证的）。为此只要证明在事件<span class="math inline">\(\{T&lt;\infty\}\)</span> 上几乎处处有 <span class="math inline">\(Z_T&gt;1/r\)</span>，即 <span class="math inline">\(R_T&lt;r\)</span> 即可。</p><p>我们来证明对每个 <span class="math inline">\(n\geq0\)</span>，事件<span class="math inline">\(A_n=\{R_n\in\{0,r\}\}\)</span>都是零概率事件。</p><p>对 <span class="math inline">\(n\)</span> 归纳：<span class="math inline">\(n=0\)</span> 时 <span class="math inline">\(R_0=R&gt;r\)</span>，结论自然成立。设当 <span class="math inline">\(k&lt;n\)</span> 时有 <span class="math inline">\(\mathbb{P}(A_k)=0\)</span>，来看 <span class="math inline">\(k=n\)</span> 的情形。</p><p>由于 <span class="math inline">\(\mathbb{P}(A_n)=\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}]=\mathop{\mathrm{\mathbb{E}}}[\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}|\mathcal{F}_{n-1}]]\)</span>，我们只要证明<span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}|\mathcal{F}_{n-1}]\)</span>是几乎处处为 0 的即可。而根据 freezing lemma， <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}|\mathcal{F}_{n-1}]=\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\bigg|\mathcal{F}_{n-1}]=\mathop{\mathrm{\mathbb{E}}}\left[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\right].\]</span>其中上式最右边的期望是对单位球面上均匀分布的 <span class="math inline">\(U_n\)</span> 进行积分，结果是一个关于 <span class="math inline">\(X_{n-1}\)</span> 的函数。</p><ul><li>如果 <span class="math inline">\(|X_{n-1}|\in\{0,r\}\)</span>，显然无论如何上式右边的期望取值在<span class="math inline">\([0,1]\)</span> 中。</li><li>如果 <span class="math inline">\(|X_{n-1}|\notin\{0,r\}\)</span>，这时以 <span class="math inline">\(X_{n-1}\)</span> 为中心，<span class="math inline">\(l_n\)</span> 为半径的球面上，与原点之间的距离为<span class="math inline">\(0\)</span> 或者 <span class="math inline">\(r\)</span> 的点的测度为 0，即积分项 <span class="math inline">\(\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\)</span> 对几乎处处的 <span class="math inline">\(U_n\)</span> 都是 0，当然积分值 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}\left[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\right]=0\)</span>。</li></ul><p>于是我们有 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}\left[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\right]=\begin{cases}\in[0,1], &amp; |X_{n-1}|\in\{0,r\}\\0,        &amp; |X_{n-1}|\notin\{0,r\}\end{cases}\]</span></p><p>根据归纳假设，<span class="math inline">\(|X_{n-1}|\in\{0,r\}\)</span> 的概率是 0，即 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}\left[\mathbb{1}_{\{0,r\}}\circ|X_{n-1}+l_nU_n|\right]\)</span> 是一个几乎处处为 0 的函数，从而 <span class="math inline">\(\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_{A_n}|\mathcal{F}_{n-1}]\)</span>也几乎处处为 0，即得所证。</p><h1 id="对策略的进一步分析">对策略的进一步分析</h1><p>现在我们把注意力转移到飞船不能返回太阳系这个事件上来。前面已经说过，飞船的运动只有两种可能，迷失在无穷远处或者被禁锢在一个有限的区域内，所以如果飞船不能返回太阳系，则飞船要么飞向无穷远，要么在太阳系之外的一个有限区域内打转。我们想知道，怎么判断这两种情形哪一种会发生呢？</p><p>举个例子，考虑这样一个明显不合理的策略：第 <span class="math inline">\(n\)</span> 次的跳跃距离总是设定为 <span class="math inline">\(1/2^n\)</span>，在这个策略下飞船永远飞不出一个半径为1 的空间，所以这种策略是应该避免的。</p><p>你可以注意到这个糟糕的策略的问题出在跳跃距离之和是收敛的。如果我们强迫每次跳跃的距离都大于一个固定的值<span class="math inline">\(\epsilon\)</span>（<span class="math inline">\(\epsilon\)</span>可以是任意的正数），就可以避免这种情形出现，这就是下面的定理：</p><div id="goinf" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\epsilon\)</span> 是任一正数 <span class="math display">\[E:=\{\omega:\T(\omega)=\infty,\  l_n(\omega)\geq\epsilon,\ \forall n\geq1\},\]</span>则我们有 <span class="math display">\[\lim_{n\to\infty}R_n=+\infty,\quad \text{for a.e.}\ \omega\in E.\]</span></p></div><p><strong>证明</strong>：设 <span class="math inline">\(\theta_n\)</span> 为 <span class="math inline">\(X_{n-1}\)</span> 与 <span class="math inline">\(U_n\)</span> 之间的夹角，利用关系 <span class="math inline">\(X_n=X_{n-1}+l_nU_n\)</span>以及三角形的余弦公式可得 <span class="math display">\[R_n^2=R_{n-1}^2+l_n^2+2R_{n-1}l_n\cos\theta_n.\]</span>令 <span class="math inline">\(B_n=\{\cos\theta_n\geq1/2\}\)</span>，则在事件 <span class="math inline">\(B_n\)</span>上我们有</p><p><span class="math display">\[R_n^2\geqR_{n-1}^2+l_n^2+R_{n-1}l_n\geq(R_{n-1}+l_n/2)^2.\]</span> 结合在事件<span class="math inline">\(E\)</span> 上有 <span class="math inline">\(l_n\geq\epsilon\)</span>，于是在事件 <span class="math inline">\(B_n\cap E\)</span> 上有 <span class="math display">\[R_n\geq R_{n-1}+l_n/2\geqR_{n-1}+\epsilon/2,\quad\omega\in B_n\cap E.\]</span> 如果我们能证明<span class="math inline">\(\mathbb{P}(\{B_n\\text{i.o.}\})=1\)</span>，再排除掉使得 <span class="math inline">\(R_n(\omega)\)</span>不收敛的零测集，则对几乎处处的 <span class="math inline">\(\omega\inE\)</span> 都有 <span class="math inline">\(R_n\geqR_{n-1}+\epsilon/2\)</span> 对无穷多个 <span class="math inline">\(n\)</span> 成立。对这些 <span class="math inline">\(\omega\)</span>，<span class="math inline">\(R_n\)</span> 是不可能收敛到一个有限的点的，只能是<span class="math inline">\(\lim\limits_{n\to\infty}R_n(\omega)=\infty\)</span>，这就说明飞船在<span class="math inline">\(E\)</span> 上几乎处处飞向无穷远。</p><p>为了证明 <span class="math inline">\(\mathbb{P}(\{B_n\\text{i.o.}\})=1\)</span>，我们只要证明 <span class="math inline">\(\{B_n\}\)</span> 是独立的事件列，且对每个 <span class="math inline">\(n\)</span> 有 <span class="math inline">\(\mathbb{P}(B_n)=\frac{1}{4}\)</span>，这样由Borel-Cantelli 第二引理就得到了结论。</p><p>注意到（又用到 <a href="#freeze" title="引理 1.1">引理 1.1</a>啦）</p><p><span class="math display">\[\begin{align*}\mathbb{P}[B_n| \mathcal{F}_{n-1}] &amp;= \mathbb{P}[\cos(U_n, v)\geq1/2] \bigg|_{v=X_{n-1}} \\&amp;= \mathbb{P}[U_n\in\{(x,y,z)\in\mathbb{R}^3:\ z\geq 1/2\}]\\&amp;=\frac{1}{4}.\end{align*}\]</span></p><p>于是对任何一组下标 <span class="math inline">\(n_1&lt;n_2&lt;\cdots&lt;n_k\)</span>，记 <span class="math inline">\(A=B_{n_1}\cap\cdots\cap{B_{n_{k-1}}}\)</span> 以及<span class="math inline">\(B=B_{n_k}\)</span>，并注意到由于 <span class="math inline">\(n_{k-1}\leq n_k-1\)</span> 因此 <span class="math inline">\(A\in\mathcal{F}_{n_k-1}\)</span>，所以</p><p><span class="math display">\[\begin{align*}\mathbb{P}[B_{n_1}\cap\cdots\capB_{n_k}] &amp;= \mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_A\mathbb{1}_B] =\mathop{\mathrm{\mathbb{E}}}[\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_A\mathbb{1}_B|\mathcal{F}_{n_k-1}]]\\&amp;=\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_A\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_B|\mathcal{F}_{n_k-1}]]\\&amp;=\frac{1}{4}\mathop{\mathrm{\mathbb{E}}}[\mathbb{1}_A]\\&amp;=\frac{1}{4}\mathbb{P}(B_{n_1}\cap\cdots\capB_{n_{k-1}}).\end{align*}\]</span></p><p>从而由递推可见对每个 <span class="math inline">\(n\)</span> 都有<span class="math inline">\(\mathbb{P}(B_n) =\frac{1}{4}\)</span>且它们是互相独立的。</p><h1 id="最优策略">最优策略</h1><p>现在我们已经知道飞船返回太阳系的概率总是小于 <span class="math inline">\(r/R\)</span>，也知道只要策略得当，就可以避免飞船在原地打转的糟糕情况。接下来的问题是：最好的策略到底是什么？</p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.1</span>.</span><span class="statement-spah"></span>定义如下的跳跃策略：在准备第 <span class="math inline">\(n\)</span> 次跳跃时，如果飞船已经在太阳系内，则令<span class="math inline">\(l_n=0\)</span>，否则令 <span class="math inline">\(l_n=R_{n-1}-r+\epsilon\)</span>，这里 <span class="math inline">\(0&lt;\epsilon&lt;r\)</span>。在这个跳跃策略下，飞船返回太阳系的概率大于<span class="math inline">\((r-\epsilon)/R\)</span>。</p></div><p>注意在这个策略中总是有 <span class="math inline">\(l_n&lt;R_{n-1}\)</span>，因此 <span class="math inline">\(\{Z_n=1/R_n\}\)</span>实际上是一个鞅。此外由于总是有 <span class="math inline">\(R_n\geqr-\epsilon\)</span>，所以 <span class="math inline">\(Z_n\leq1/(r-\epsilon)\)</span>，即 <span class="math inline">\(\{Z_n\}\)</span> 被常数 <span class="math inline">\(1/(r-\epsilon)\)</span> 所控制。</p><p>接下来的证明不过是 <a href="#lessthan" title="定理 2.2">定理 2.2</a>证明的重复：</p><p>这次根据控制收敛定理有 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]=\lim_{n\to\infty}\mathop{\mathrm{\mathbb{E}}}[Z_{T\wedgen}]=\mathop{\mathrm{\mathbb{E}}}[Z_0]=\frac{1}{R}.\]</span> 另一方面<span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]=\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]+\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_n\mathbb{1}_{\{T=\infty\}}].\]</span>这个时候要注意到在 <span class="math inline">\(\{T=\infty\}\)</span>上总是有 <span class="math inline">\(l_n\geq\epsilon\)</span>，因此根据<a href="#goinf" title="定理 3.1">定理 3.1</a>的结论，飞船几乎必然飞向无穷远，即 <span class="math display">\[\lim_{n\to\infty}Z_n=0,\quad\omega\in\{T=\infty\}.\]</span> 所以 <span class="math display">\[\mathop{\mathrm{\mathbb{E}}}[\lim_{n\to\infty}Z_{T\wedgen}]=\mathop{\mathrm{\mathbb{E}}}[Z_T\mathbb{1}_{\{T&lt;\infty\}}]\leq\frac{1}{r-\epsilon}\mathbb{P}(T&lt;\infty).\]</span>综合两个式子就证明了 <span class="math inline">\(\mathbb{P}(T&lt;\infty)\geq(r-\epsilon)/R\)</span>。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Donoghue2014" class="csl-entry" role="listitem">Donoghue, W. F. 2014. <em>Distributions and Fourier Transforms</em>.ISSN. Elsevier Science. <a href="https://books.google.com/books?id=P30Y7daiGvQC">https://books.google.com/books?id=P30Y7daiGvQC</a>.</div><div id="ref-Durrett2019" class="csl-entry" role="listitem">Durrett, Rick. 2019. <em>Probability: Theory and Examples</em>. 5th ed.Cambridge Series in Statistical and Probabilistic Mathematics. CambridgeUniversity Press.</div><div id="ref-Williams1991" class="csl-entry" role="listitem">Williams, David. 1991. <em>Probability with Martingales</em>. CambridgeUniversity Press.</div></div>]]></content>
      
      
      <categories>
          
          <category> Williams 概率和鞅 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>中心单代数的三个基本结论</title>
      <link href="central-simple-algebra/"/>
      <url>central-simple-algebra/</url>
      
        <content type="html"><![CDATA[<p>本文来自我在讨论班上的一个两小时左右的报告，目的是介绍中心单代数的三个基本结论：</p><ol type="1"><li>中心单代数对张量积运算是封闭的。</li><li>Noether-Skolem 定理。</li><li>双重中心化子定理。</li></ol><p>这部分内容比较古老，在很多教材上都有，但是采用的途径却很不一样，找一个完全符合自己口味的讲述不是件容易的事情。<span class="citation" data-cites="Jacobson_alg">Jacobson (<a href="#ref-Jacobson_alg" role="doc-biblioref">1980</a>)</span>我念的就很抓狂。后来查阅了不少教材后经过提炼整理得到了本文，希望我的表述做到了清楚易懂。</p><span id="more"></span><h1 id="中心单代数对张量积运算是封闭的">中心单代数对张量积运算是封闭的</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的一个有限维的结合代数，有乘法单位元<span class="math inline">\(\rm 1\)</span>。如果 <span class="math inline">\(A\)</span> 除了 <span class="math inline">\((0)\)</span> 和自身以外不含有其它的双边理想，就称<span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的<strong>单代数</strong>；进一步如果<span class="math inline">\(A\)</span> 的中心 <span class="math inline">\(Z(A)=F\cdot{\rm 1}\cong F\)</span>，就称 <span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的<strong>中心单代数</strong>。</p></div><p>最基本也是最重要的中心单代数的例子就是矩阵代数 <span class="math inline">\({\rmMat}_n(F)\)</span>。在研究中心单代数的时候，一个有效的手段就是建立它和<span class="math inline">\({\rm Mat}_n(F)\)</span> 之间的同态。</p><p>中心单代数有个很好的性质，就是它们对张量积的运算是封闭的：</p><div id="A-otimes-B" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A,B\)</span> 是域 <span class="math inline">\(F\)</span> 上的两个中心单代数，则 <span class="math inline">\(A\otimes_F B\)</span> 也是中心单代数。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(\dimB=m\)</span>，取定 <span class="math inline">\(B\)</span> 的一组基 <span class="math inline">\(\{b_1,\ldots,b_m\}\)</span>，则 <span class="math inline">\(A\otimes B\)</span> 中的任何元素 <span class="math inline">\(x\)</span> 可以唯一地写成 <span class="math display">\[x= a_1\otimes b_1+a_2\otimesb_2+\cdots+a_m\otimes b_m,\quad a_i\in A.\]</span> 当然这里的 <span class="math inline">\(a_i\)</span> 某些可以是 <span class="math inline">\(0\)</span>。我们称上面这个表达式中非零项的个数为<span class="math inline">\(x\)</span> 的长度。</p><p>设 <span class="math inline">\(I\)</span> 是 <span class="math inline">\(A\otimes B\)</span> 的任一非零理想，取 <span class="math inline">\(x\ne 0\)</span> 使得 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(I\)</span> 中所有非零元素中长度最小的，不妨假设<span class="math display">\[x= a_1\otimes b_1+a_2\otimesb_2+\cdots+a_r\otimes b_r,\quad 0&lt;r\leq m.\]</span> 这里每个 <span class="math inline">\(a_i\)</span> 都不是 <span class="math inline">\(0\)</span>，特别 <span class="math inline">\(a_1\ne0\)</span>。由于 <span class="math inline">\(A\)</span> 是单代数因此 <span class="math inline">\(A=Aa_1A\)</span> （即 <span class="math inline">\(a_1\)</span> 生成的双边理想），所以存在一组 <span class="math inline">\(\{c_j, d_j\mid 1\leq j\leq p\}\)</span> 满足 <span class="math display">\[1=\sum_{j=1}^p c_ja_1d_j.\]</span> 由于 <span class="math inline">\(I\)</span> 是双边理想因此每个 <span class="math display">\[(c_j\otimes 1)x(d_j\otimes 1)=(c_ja_1d_j)\otimesb_1+\cdots+(c_ja_rd_j)\otimes b_r\]</span> 都在 <span class="math inline">\(I\)</span> 中，当然它们的和也在 <span class="math inline">\(I\)</span> 中，设这个和为 <span class="math inline">\(x'\)</span>，则 <span class="math inline">\(x'\)</span> 与 <span class="math inline">\(x\)</span> 有同样的长度但是形如 <span class="math inline">\(x'=1\otimesb_1+\cdots\)</span>，<strong>所以我们不妨一开始就假设在 <span class="math inline">\(x\)</span> 的表达式中有 <span class="math inline">\(a_1=1\)</span></strong>。</p><p>任取 <span class="math inline">\(a\in A\)</span>，则 <span class="math display">\[(a\otimes 1)x -x(a\otimes1) =(aa_2-a_2a)\otimesb_2+\cdots+(aa_r-a_ra)\otimes b_r\in I.\]</span> 然而它的长度小于 <span class="math inline">\(r\)</span> 因此必须是 <span class="math inline">\(0\)</span>，即对每个 <span class="math inline">\(i=2,\ldots,r\)</span> 有 <span class="math inline">\(aa_i=a_ia\)</span>，由 <span class="math inline">\(a\)</span> 的任意性可知每个 <span class="math inline">\(a_i\)</span> 都属于 <span class="math inline">\(A\)</span> 的中心 <span class="math inline">\(Z(A)=F\)</span>，因此这些 <span class="math inline">\(a_i\)</span> 可以拿到 <span class="math inline">\(\otimes\)</span> 的右边去： <span class="math display">\[x=1\otimes b_1+\cdots+1\otimesa_rb_r=1\otimes(b_1+a_2b_2+\cdots+a_rb_r)\in I.\]</span> 注意由于 <span class="math inline">\(b_i\)</span> 是线性无关的所以 <span class="math inline">\(b=b_1+a_2b_2+\cdots+a_rb_r\ne0\)</span>。</p><p>总之我们证明了在 <span class="math inline">\(I\)</span>中存在一个形如 <span class="math inline">\(1\otimes b\)</span>的元素。</p><p>然后我们有 <span class="math display">\[I\supset (1\otimes B)1\otimesb(1\otimes B)=1\otimes BbB=1\otimes B,\]</span> 其中最后一个等号是因为<span class="math inline">\(B\)</span> 是单代数，从而 <span class="math inline">\(B\)</span> 等于元素 <span class="math inline">\(b\)</span> 生成的双边理想 <span class="math inline">\(BbB\)</span>。从而 <span class="math display">\[I\supset (A\otimes1)(1\otimes B)=A\otimesB,\]</span> 这就证明了 <span class="math inline">\(I=A\otimesB\)</span>，即 <span class="math inline">\(A\otimes B\)</span>是单代数。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在上面的证明中，我们只用到了 <span class="math inline">\(A\)</span> 是中心单代数和 <span class="math inline">\(B\)</span> 是单代数作为条件，即只要 <span class="math inline">\(A,B\)</span>中一个是单代数，另一个是中心单代数，则 <span class="math inline">\(A\otimes B\)</span> 就是单代数。这个结论对 <span class="math inline">\(A,B\)</span> 都是单代数的情形是不成立的，比如<span class="math inline">\(\mathbb{C}\)</span> 是 <span class="math inline">\(\mathbb{R}\)</span> 上的单代数但不是中心单的，这时<span class="math inline">\(\mathbb{C}\otimes_\mathbb{R}\mathbb{C}\cong\mathbb{C}\oplus\mathbb{C}\)</span> 就不是单代数。</p></div><p>证明 <span class="math inline">\(Z(A\otimes B)=F\)</span>也可以用同样的套路，不过我们想花点精力证明一个更一般的结论：</p><div id="C-otimes-D" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A,B\)</span> 是域 <span class="math inline">\(F\)</span> 上的代数，<span class="math inline">\(C\subset A\)</span> 和 <span class="math inline">\(D\subset B\)</span> 分别是子代数，则 <span class="math inline">\(C\otimes D\)</span> 在 <span class="math inline">\(A\otimes B\)</span> 中的中心化子是 <span class="math inline">\(C_{A\otimes B}(C\otimes D)=C_A(C)\otimesC_B(D)\)</span>。也就是分别取 <span class="math inline">\(C,D\)</span>在 <span class="math inline">\(A,B\)</span>里的中心化子，然后作张量积。</p></div><p>特别地取 <span class="math inline">\(C=A,D=B\)</span> 我们有 <span class="math inline">\(Z(A\otimes B)=Z(A)\otimes Z(B)\)</span>。</p><p>当 <span class="math inline">\(A,B\)</span>都是中心单代数时，由此引理 <span class="math inline">\(Z(A\otimesB)=Z(A)\otimes Z(B)=F\otimes F\cong F(1\otimes 1)\)</span> 即得 <a href="#A-otimes-B" title="定理 1.2">定理 1.2</a> 结论。</p><p><a href="#C-otimes-D" title="引理 1.3">引理 1.3</a> 的证明：首先<span class="math inline">\(C_{A\otimes B}(C\otimes D)\supseteqC_A(C)\otimes C_B(D)\)</span>是显然的，只要再证明反向的包含关系成立即可。</p><p>任何 <span class="math inline">\(z\in C_{A\otimes B}(C\otimesD)\)</span> 可以唯一地写成 <span class="math display">\[z= a_1\otimesb_1+a_2\otimes b_2+\cdots+a_m\otimes b_m.\]</span> 由于 <span class="math inline">\(z\)</span> 和 <span class="math inline">\(C\otimesD\)</span> 交换，当然也就和 <span class="math inline">\(C\otimes1\)</span> 交换，所以对任何 <span class="math inline">\(c\in C\)</span>有 <span class="math display">\[(c\otimes1)z-z(c\otimes1)=\sum_{i=1}^m(ca_i-a_ic)\otimesb_i=0.\]</span></p><p>由于 <span class="math inline">\(b_i\)</span> 是线性无关的，因此每个<span class="math inline">\(ca_i=a_ic\)</span>，由 <span class="math inline">\(c\)</span> 的任意性有 <span class="math inline">\(a_i\in C_A(C)\)</span>。进一步设 <span class="math inline">\(\{x_1,\ldots,x_r\}\)</span> 是 <span class="math inline">\(C_A(C)\)</span> 的一组基，再将每个 <span class="math inline">\(a_i\)</span> 表示为 <span class="math inline">\(\{x_1,\ldots,x_r\}\)</span> 的线性组合，我们得到<span class="math display">\[z=a_1\otimes b_1+a_2\otimesb_2+\cdots+a_m\otimes b_m=x_1\otimes b_1'+\cdots +x_rb_r'.\]</span> 其中每个 <span class="math inline">\(b_i'\inB\)</span>。进一步 <span class="math inline">\(z\)</span> 与任何形如<span class="math inline">\(1\otimes d,d\in D\)</span> 的元素交换，得到<span class="math display">\[(1\otimes d)z-z(1\otimesd)=\sum_{i=1}^rx_i\otimes (db_i'-b_i'd)=0.\]</span> 由于 <span class="math inline">\(x_1,\ldots,x_r\)</span> 是线性无关的，所以每个<span class="math inline">\(db_i'-b_i'd=0\)</span>，由 <span class="math inline">\(d\)</span> 的任意性可得 <span class="math inline">\(b_i'\in C_B(D)\)</span>，这就证明了任何 <span class="math inline">\(z\in C_{A\otimes B}(C\otimes D)\)</span>可以表示为 <span class="math display">\[z=x_1\otimes b_1'+\cdots +x_rb_r'\]</span> 的形式，其中每个 <span class="math inline">\(x_i\inC_A(B)\)</span>，每个 <span class="math inline">\(b_i'\inC_B(D)\)</span>，从而反向的包含得证。<span class="math inline">\(\blacksquare\)</span></p><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是域 <span class="math inline">\(F\)</span> 上的中心单代数，<span class="math inline">\(\dim_F A=n\)</span>，则 <span class="math inline">\(A\otimes A^{\rm op}\cong{\rmMat}_n(F)\)</span>。</p></div><p>背后的道理很简单：<span class="math inline">\(A\)</span> 显然是 <span class="math inline">\((A,A)\)</span>- 双模，从而是一个左 <span class="math inline">\(A\otimes A^{\rm op}\)</span>- 模（回忆一下，<span class="math inline">\((R,S)\)</span>- 双模与左 <span class="math inline">\(R\otimes S^{\rm op}\)</span>-模是一回事），即存在代数同态 <span class="math display">\[A\otimesA^{\rm op}\to \mathrm{End}_F(A).\]</span> （<span class="math inline">\(M\)</span> 是左 <span class="math inline">\(R\)</span>- 模当且仅当存在环同态 <span class="math inline">\(R\to{\rm End}(M)\)</span>）</p><p>由 <a href="#A-otimes-B" title="定理 1.2">定理 1.2</a> 知道 <span class="math inline">\(A\otimes A^{\rm op}\)</span>是单代数从而这是一个单射，比较维数即得这是一个同构。</p><h1 id="noether-skolem-定理">Noether-Skolem 定理</h1><div id="N-S" class="statement sta_noether_skolem___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">Noether-Skolem 定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span>是一个中心单代数，<span class="math inline">\(B\)</span> 是单代数，<span class="math inline">\(f,g:B\to A\)</span> 是从 <span class="math inline">\(B\)</span> 到 <span class="math inline">\(A\)</span> 的两个代数同态，则存在 <span class="math inline">\(u\in A^{\times}\)</span> 满足 <span class="math display">\[f(b) =u^{-1}g(b)u,\quad \forall b\in B.\]</span>特别的，我们得到中心单代数的自同构都是内自同构。</p></div><p>这个定理背后的想法不难，只是需要一点 Wedderburn-Artin半单代数理论的知识：对于一个单代数 <span class="math inline">\(B\)</span>，在同构意义下 <span class="math inline">\(B\)</span> 只有唯一的不可约模左 <span class="math inline">\(B\)</span>- 模 <span class="math inline">\(V\)</span>。任何左 <span class="math inline">\(B\)</span>- 模都是完全可约的，可以分解为若干 <span class="math inline">\(V\)</span> 的直和，从而两个左 <span class="math inline">\(B\)</span>- 模 <span class="math inline">\(W,W'\)</span> 是同构的当且仅当它们作为 <span class="math inline">\(F\)</span>- 向量空间的维数相同：<span class="math inline">\(W\cong W'\Leftrightarrow\dim_F W=\dim_FW'\)</span>，所以判断两个 <span class="math inline">\(B\)</span>-模是否同构是很简单的，只看维数就行。</p><p>回到 <a href="#N-S" title="Noether-Skolem 定理">Noether-Skolem定理</a> 的证明，我们先处理 <span class="math inline">\(A={\rmMat}_n(F)\)</span> 的情形：这时我们可以在 <span class="math inline">\(F^n\)</span> 上定义两种不同的 <span class="math inline">\(B\)</span>- 模结构：<span class="math inline">\(b\cdot x =f(b)x\)</span> 和 <span class="math inline">\(b\circ x=g(b)x\)</span>。我们已经介绍了在 <span class="math inline">\(B\)</span> 是单代数的情形，两个左 <span class="math inline">\(B\)</span>-模同构当且仅当它们作为向量空间的维数相等。所以 <span class="math inline">\(F^n\)</span> 作为 <span class="math inline">\((B,\cdot)\)</span> 和 <span class="math inline">\((B,\circ)\)</span> 是同构的，因此存在可逆线性变换<span class="math inline">\(T:F^n\to F^n\)</span> 使得 <span class="math display">\[b\cdot (Tx)=T(b\circ x),\]</span> 即 <span class="math inline">\(f(b)=T^{-1}g(b)T\)</span>，因此在 <span class="math inline">\(A={\rm Mat}_n(F)\)</span> 的情形定理成立。</p><p>对于一般的情形，我们当然要向矩阵代数靠拢。考虑 <span class="math inline">\(A\otimes A^{\rm op}\)</span> 的两个单子代数 <span class="math inline">\(f(B)\otimes A^{\rm op}\)</span> 和 <span class="math inline">\(g(B)\otimes A^{\rm op}\)</span>。由于 <span class="math inline">\(A\otimes A^{\rm op}\)</span> 同构于 <span class="math inline">\({\rm Mat}_n(F)\)</span> 因此上面的情形可用，即存在<span class="math inline">\(T \in (A\otimes A^{\rm op})^\times\)</span>满足对任何 <span class="math inline">\(b\otimes a^{\rm op}\)</span> 有<span class="math display">\[f(b)\otimes a^{\rm op}=T^{-1}(g(b)\otimesa^{\rm op})T. \tag{$\ast$}\label{ast}\]</span> 取 <span class="math inline">\(b=1\)</span> 我们有 <span class="math display">\[1\otimes a^{\rm op}=T^{-1}(1\otimes a^{\rmop})T.\]</span> 即 <span class="math inline">\(T\)</span> 与 <span class="math inline">\(1\otimes A^{\rm op}\)</span> 交换。于是根据 <a href="#C-otimes-D" title="引理 1.3">引理 1.3</a>，<span class="math inline">\(T\in A\otimes1\)</span>，从而存在 <span class="math inline">\(u\in A\)</span> 使得 <span class="math inline">\(T=u\otimes1\)</span>，<span class="math inline">\(T\in (A\otimes A^{\rm op})^\times\)</span> 说明<span class="math inline">\(u\in A^{\times}\)</span>，代入到 <span class="math inline">\(\ref{ast}\)</span> 中去即得 <span class="math inline">\(f(b)=u^{-1}g(b)u\)</span>。<span class="math inline">\(\blacksquare\)</span></p><h1 id="双重中心化子定理">双重中心化子定理</h1><div id="------------------------" class="statement sta_________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">双重中心化子定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span>是 <span class="math inline">\(F\)</span> 上的中心单代数，<span class="math inline">\(B\)</span> 是 <span class="math inline">\(A\)</span> 的单子代数，<span class="math inline">\(C\)</span> 是 <span class="math inline">\(B\)</span> 在 <span class="math inline">\(A\)</span> 中的中心化子： <span class="math display">\[C=C_A(B)=\{ c\in A:\ cb=bc,\ \forall b\inB\}.\]</span> 则以下结论成立：</p><ol type="1"><li><span class="math inline">\(C\)</span> 也是 <span class="math inline">\(A\)</span> 的单子代数。</li><li><span class="math inline">\(\dim_F A=(\dim_F B)(\dim_FC)\)</span>。</li><li><span class="math inline">\(C\)</span> 的中心化子是 <span class="math inline">\(B\)</span>。</li></ol></div><p><strong>证明</strong>：参考下图 （<span class="math inline">\(i\)</span> 是嵌入映射）：</p><p><span class="math display">\[\require{amsCd}\begin{CD}B\otimes1 @&gt;{i}&gt;&gt; A\otimes\mathrm{End}_F(B) @&lt;{i}&lt;&lt;1\otimes l(B)\\@V{\rm centralizer}VV @. @VV{\rm centralizer}V \\C\otimes\mathrm{End}_F(B) @&gt;{i}&gt;&gt; A\otimes\mathrm{End}_F(B)@&lt;{i}&lt;&lt; A\otimes r(B)\end{CD}\]</span></p><p>考虑中心单代数 <span class="math inline">\(A\otimes\mathrm{End}_F(B)\)</span>，它有两个子代数<span class="math inline">\(B\otimes 1\)</span> 和 <span class="math inline">\(1\otimes l(B)\)</span>，这里 <span class="math inline">\(l(B)\)</span> 是 <span class="math inline">\(B\)</span> 在自身上的左乘。它们都同构于单子代数<span class="math inline">\(B\)</span>，因此 Noether-Skolem定理断言它俩是共轭的，于是它俩在 <span class="math inline">\(A\otimes\mathrm{End}_F(B)\)</span>中的中心化子也是共轭的。利用 <a href="#C-otimes-D" title="引理 1.3">引理1.3</a> 的结论，对它俩在 <span class="math inline">\(A\otimes\mathrm{End}_F(B)\)</span>中分别求中心化子，得到 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span> 和 <span class="math inline">\(A\otimes r(B)\)</span> 是共轭的。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span><span class="math inline">\(l(B)\)</span> 在 <span class="math inline">\(\mathrm{End}_F(B)\)</span> 中的中心化子是 <span class="math inline">\(r(B)\)</span>，即 <span class="math inline">\(B\)</span> 在自身上的右乘。<span class="math inline">\(r(B)\)</span> 同构于 <span class="math inline">\(B\)</span> 的反环 <span class="math inline">\(B^{\rm op}\)</span>。</p></div><p>由 <a href="#A-otimes-B" title="定理 1.2">定理 1.2</a> <span class="math inline">\(A\otimes r(B)\)</span> 是单代数，于是 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span>也是单代数，从而 <span class="math inline">\(C\)</span> 必须是单代数（否则若 <span class="math inline">\(C\)</span> 有非平凡理想 <span class="math inline">\(I\)</span> 则 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span> 有理想 <span class="math inline">\(I\otimes\mathrm{End}_F(B)\)</span>），这证明了1。</p><p>由于 <span class="math inline">\(C\otimes\mathrm{End}_F(B)\)</span>和 <span class="math inline">\(A\otimes r(B)\)</span>共轭，所以它们的维数相等，即 <span class="math display">\[(\dim_F C)(\dim_F B)^2=(\dim_F A)(\dim_F B),\]</span> 从而可得 <span class="math display">\[(\dim_F C)(\dim_F B)=\dim_F A.\]</span> 这证明了2。</p><p>最后设 <span class="math inline">\(C\)</span> 的中心化子为 <span class="math inline">\(C_A(C)\)</span>，对单子代数 <span class="math inline">\(C\)</span> 应用结论 2， <span class="math display">\[\dim_F C =\frac{\dim_F A}{\dim_FC_A(C)}=\frac{\dim_F A}{\dim_F B}.\]</span> 即 <span class="math inline">\(\dim_F C_A(C)=\dim_F B\)</span>。然而 <span class="math inline">\(B\subsetC_A(C)\)</span>，二者维数相同因此必然相等，这就证明了 3。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Jacobson_alg" class="csl-entry" role="listitem">Jacobson, Nathan. 1980. <em>Basic Algebra. <span>II</span></em>. SanFrancisco, Calif.: W. H. Freeman; Co.</div></div>]]></content>
      
      
      <categories>
          
          <category> 有限群表示与结合代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实化与复化</title>
      <link href="real-complex/"/>
      <url>real-complex/</url>
      
        <content type="html"><![CDATA[<h1 id="实化">实化</h1><p>设 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span> 上的 <span class="math inline">\(n\)</span> 维向量空间，我们可以「忘掉」 <span class="math inline">\(V\)</span> 的复向量空间结构，把 <span class="math inline">\(V\)</span> 看作实向量空间，记作 <span class="math inline">\(V_{\mathbb{R}}\)</span> 以区别于 <span class="math inline">\(V\)</span>。<span class="math inline">\(V_{\mathbb{R}}\)</span> 是 <span class="math inline">\(2n\)</span> 维的，因为很容易验证若 <span class="math inline">\(\{e_i\}_{i=1}^n\)</span> 是 <span class="math inline">\(V\)</span> 的一组基，则 <span class="math inline">\(\{e_i,ie_i\}_{i=1}^n\)</span> 是 <span class="math inline">\(V_\mathbb{R}\)</span> 的一组基。<span class="math inline">\(V_{\mathbb{R}}\)</span> 叫做 <span class="math inline">\(V\)</span> 的<strong>实化</strong>。</p><p>但是 <span class="math inline">\(V_{\mathbb{R}}\)</span> 比一般的<span class="math inline">\(2n\)</span> 维实向量空间还要多出一个结构，即<span class="math inline">\(V\)</span> 上虚数 <span class="math inline">\(i\)</span> 的乘法诱导了 <span class="math inline">\(V_\mathbb{R}\)</span> 上的 <span class="math inline">\(\mathbb{R}\)</span>- 线性变换 <span class="math inline">\(J: v\mapsto iv\)</span>。<span class="math inline">\(J\)</span> 满足 <span class="math inline">\(J^2=-1\)</span>。<span class="math inline">\(J\)</span> 叫做 <span class="math inline">\(V_{\mathbb{R}}\)</span>上的<strong>复结构</strong>。</p><p>反过来，给定一个偶数维的实向量空间 <span class="math inline">\(W\)</span> 以及 <span class="math inline">\(W\)</span> 上的一个复结构 <span class="math inline">\(J\)</span>，<span class="math inline">\(W\)</span>上可以自然地定义复向量空间结构：因为 <span class="math inline">\(J\)</span> 本质就是虚数 <span class="math inline">\(i\)</span> 的乘法，我们只要规定 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(W\)</span> 中向量的乘法为 <span class="math inline">\(iw=J ( w )\)</span>，然后扩展到 <span class="math inline">\(\mathbb{C}\)</span> 上即可： <span class="math display">\[( a+ib ) w = aw+bJ ( w ) ,\quada,b\in\mathbb{R},w\in W.\]</span> 我们用 <span class="math inline">\((W,J )\)</span> 表示这样得到的复向量空间。注意对任何复向量空间 <span class="math inline">\(V\)</span> 有 <span class="math inline">\((V_\mathbb{R},J ) \cong V\)</span>。</p><p>总之一个 <span class="math inline">\(n\)</span> 维复向量空间 <span class="math inline">\(V\)</span> 可以等同于一个 <span class="math inline">\(2n\)</span> 维实向量空间 <span class="math inline">\(V_{\mathbb{R}}\)</span> 加上一个复结构 <span class="math inline">\(J\)</span>。</p><h1 id="反线性映射">反线性映射</h1><p>设 <span class="math inline">\(V\)</span> 是复向量空间，记 <span class="math inline">\(\overline{V}\)</span> 是如下的向量空间：<span class="math inline">\(\overline{V}\)</span> 的向量和 <span class="math inline">\(V\)</span> 完全相同，但是复数与向量的乘法定义为<span class="math inline">\(c\bullet z=\overline{c}z\)</span>。我们称<span class="math inline">\(\overline{V}\)</span> 是 <span class="math inline">\(V\)</span> 的共轭空间。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(V,U\)</span>是复向量空间。如果映射 <span class="math inline">\(f: V\to U\)</span>满足下面两个条件，就称 <span class="math inline">\(f\)</span> 是 <a href="https://en.wikipedia.org/wiki/Antilinear_map">反线性</a>映射：</p><ol type="1"><li><span class="math inline">\(f(v_1+v_2)=f(v_1)+f(v_2)\)</span> 对任何<span class="math inline">\(v_1,v_2\in V\)</span> 成立。</li><li><span class="math inline">\(f(cv)=\overline{c}v\)</span> 对任何<span class="math inline">\(c\in\mathbb{C}\)</span> 和 <span class="math inline">\(v\in V\)</span> 成立。</li></ol></div><p>反线性映射是 <span class="math inline">\(\mathbb{R}\)</span>-线性的，但不是 <span class="math inline">\(\mathbb{C}\)</span>-线性的。</p><p>容易看到 <span class="math inline">\(V\to\overline{U}\)</span> 的<span class="math inline">\(\mathbb{C}\)</span>- 线性映射和 <span class="math inline">\(V\to U\)</span> 的反线性映射是一回事。</p><h1 id="复化">复化</h1><p>与实化相对应的操作是<strong>复化</strong>，即给定一个 <span class="math inline">\(n\)</span> 维实向量空间 <span class="math inline">\(W\)</span>，把域和向量的乘法扩展到 <span class="math inline">\(\mathbb{C}\)</span> 上，使 <span class="math inline">\(W\)</span> 成为一个复向量空间。我们记作 <span class="math inline">\(W^\mathbb{C}\)</span> 以区别于 <span class="math inline">\(W\)</span>。</p><p>构造 <span class="math inline">\(W^\mathbb{C}\)</span>的标准方法是使用张量积，令 <span class="math inline">\(W^\mathbb{C}=\mathbb{C}\otimes_\mathbb{R}W\)</span>，则<span class="math inline">\(W^\mathbb{C}\)</span> 是 <span class="math inline">\(n\)</span> 维复向量空间，复数与向量的乘法定义为<span class="math display">\[c ( z\otimes v ) = cz\otimes v.\]</span><span class="math inline">\(W^\mathbb{C}\)</span>作为实向量空间有直和分解 <span class="math display">\[W^\mathbb{C}=1\otimes W \oplus i\otimesW.\]</span> 通过嵌入 <span class="math inline">\(W\to 1\otimesW\)</span> 把 <span class="math inline">\(W\)</span> 等同于 <span class="math inline">\(1\otimes W\)</span>，则我们有直和分解 <span class="math inline">\(W^\mathbb{C}=W\oplus iW\)</span>。</p><p><span class="math inline">\(W^\mathbb{C}\)</span> 与一般的 <span class="math inline">\(n\)</span>维复向量空间相比也多出一个结构，叫做共轭。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>如果 <span class="math inline">\(\tau: V\to V\)</span>是反线性映射并且 <span class="math inline">\(\tau^2=1\)</span>，就称<span class="math inline">\(\tau\)</span>是一个<strong>共轭</strong>。</p></div><p>复数的共轭诱导了 <span class="math inline">\(\mathbb{C}\otimes_\mathbb{R}W\)</span> 上的共轭：<span class="math display">\[\tau ( c\otimes w ) =\overline{c}\otimesw,\quad c\in\mathbb{C}, w\in W.\]</span> <span class="math inline">\(\tau\)</span> 保持实子空间 <span class="math inline">\(1\otimes W\cong W\)</span> 不变。<span class="math inline">\(W\)</span> 可以理解为 <span class="math inline">\(V\)</span> 在共轭 <span class="math inline">\(\tau\)</span> 下的实部。</p><p>反过来，给定复向量空间 <span class="math inline">\(V\)</span>以及共轭 <span class="math inline">\(\tau\)</span>，我们可以还原出使得<span class="math inline">\(V=W^\mathbb{C}\)</span> 成立的实向量空间<span class="math inline">\(W\)</span> 来。<span class="math inline">\(W\)</span> 正是 <span class="math inline">\(\tau\)</span> 的不动点子空间 <span class="math inline">\(W=\{v\in V\mid \tau ( v ) =v\}\)</span>，即 <span class="math inline">\(\tau\)</span> 的 +1 特征子空间。相应地 <span class="math inline">\(iW\)</span> 是 <span class="math inline">\(\tau\)</span> 的 -1 特征子空间并且 <span class="math inline">\(V=W\oplus iW\)</span>。根据下面的命题，<span class="math inline">\(W\)</span> 的复化就是 <span class="math inline">\(V\)</span>。</p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(V\)</span>是有限维复向量空间，<span class="math inline">\(W\)</span> 是 <span class="math inline">\(V\)</span> 的 <span class="math inline">\(\mathbb{R}\)</span>- 子空间。若有 <span class="math inline">\(V=W\oplus iW\)</span> 成立，则 <span class="math inline">\(V\cong\mathbb{C}\otimes_\mathbb{R}W\)</span>。</p></div><p><strong>证明</strong>：考察如下定义的映射 <span class="math inline">\(f\)</span>： <span class="math display">\[\begin{aligned}f: \ \mathbb{C}\otimes_\mathbb{R}W &amp; \to V\\c\otimes w &amp;\mapsto cw.\end{aligned}\]</span> 显然 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span>- 线性的。我们来验证 <span class="math inline">\(f\)</span> 是双射。</p><p>由于 <span class="math inline">\(V=W\oplus iW\)</span> 所以任何 <span class="math inline">\(v\in V\)</span> 可以写成 <span class="math inline">\(v=w_1+iw_2,\,w_1,w_2\in W\)</span>的形式。不难验证 <span class="math inline">\(f ( 1\otimes w_1 + i\otimesw_2 ) = w_1+iw_2\)</span> 所以 <span class="math inline">\(f\)</span>是满射。并且 <span class="math inline">\(f ( 1\otimes w_1 + i\otimes w_2) =0\)</span> 当且仅当 <span class="math inline">\(w_1+iw_2=0\)</span>，即 <span class="math inline">\(w_1=-iw_2\in W\cap iW= ( 0 )\)</span>，从而 <span class="math inline">\(w_1=w_2=0\)</span>，这说明 <span class="math inline">\(f\)</span> 也是单射。于是 <span class="math inline">\(f\)</span> 是同构。 <span class="math inline">\(\blacksquare\)</span></p><h1 id="先实化后复化">先实化后复化</h1><p>有了上面的准备，我们来分析对一个 <span class="math inline">\(n\)</span> 维复向量空间 <span class="math inline">\(V\)</span>，先实化再复化得到的 <span class="math inline">\((V_\mathbb{R})^\mathbb{C}=\mathbb{C}\otimes_\mathbb{R}V_\mathbb{R}\)</span>的结构。我们需要找到合适的线性变换并分析它在 <span class="math inline">\((V_\mathbb{R})^\mathbb{C}\)</span> 上的作用。</p><p>记 <span class="math inline">\(J\)</span> 是 <span class="math inline">\(V_\mathbb{R}\)</span> 的复结构，则 <span class="math inline">\(J^\mathbb{C}=1\otimes J\)</span> 是 <span class="math inline">\(\mathbb{C}\otimes_\mathbb{R}V_\mathbb{R}\)</span>上的 <span class="math inline">\(\mathbb{C}\)</span>- 线性变换并且 <span class="math inline">\(( J^\mathbb{C})^2 = -1\)</span>。<span class="math inline">\(( V_\mathbb{R})^\mathbb{C}\)</span> 可以分解为<span class="math inline">\(J^\mathbb{C}\)</span> 的 <span class="math inline">\(\pm i\)</span> 特征子空间的直和： <span class="math display">\[( V_\mathbb{R})^\mathbb{C}= V_+\oplusV_-.\]</span> 具体写出来，就是 <span class="math display">\[\begin{aligned}V_+ &amp;= \frac{1\otimes V_\mathbb{R}- i\otimes J(V_\mathbb{R})}{2}, \\V_- &amp;= \frac{1\otimes V_\mathbb{R}+ i\otimes J(V_\mathbb{R})}{2}.\end{aligned}\]</span></p><p>容易验证 <span class="math inline">\(\tau\)</span> 交换 <span class="math inline">\(V_+\)</span> 和 <span class="math inline">\(V_-\)</span>，所以 <span class="math inline">\(V_+\cong\overline{V_-}\)</span>，即二者互为共轭空间。</p><p>进一步我们断言有复向量空间的同构 <span class="math inline">\(V_+\cong V\)</span>。考虑映射 <span class="math display">\[\begin{aligned}f: \ \mathbb{C}\otimes_\mathbb{R}V_\mathbb{R}&amp; \to (V_\mathbb{R},J)\\c\otimes v &amp;\mapsto cv.\end{aligned}\]</span> 这里右边的乘法 <span class="math inline">\(cv\)</span>理解为对 <span class="math inline">\(c=a+ib\)</span> 有 <span class="math inline">\(cv=av+bJ(v)\)</span>。</p><p><span class="math inline">\(f\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span>- 线性的，确实把 <span class="math inline">\(V_+\)</span> 映射到 <span class="math inline">\(V_\mathbb{R}\)</span>： <span class="math display">\[f\left(\frac{1\otimes v- i\otimes J(v)}{2}\right)= \frac{v-J^2(v)}{2}=v.\]</span> 并且 <span class="math inline">\(f\)</span> 限制在 <span class="math inline">\(V_-\)</span> 上是零映射： <span class="math display">\[f\left(\frac{1\otimes v+ i\otimes J(v)}{2}\right)= \frac{v+J^2(v)}{2}=0.\]</span> 所以 <span class="math inline">\(f\)</span> 实际上给出了从 <span class="math inline">\(V_+\)</span> 到 <span class="math inline">\(V_\mathbb{R}\)</span> 的映射。<span class="math inline">\(f\)</span> 有逆映射 <span class="math inline">\(v\to(1\otimes v- i\otimes J(v ))/2\)</span>，所以<span class="math inline">\(V_+\cong (V_\mathbb{R},J)\congV\)</span>。至此我们就证明了 <span class="math display">\[(V_\mathbb{R})^\mathbb{C}\cong V\oplus\overline{V}.\]</span></p><p>这个同构也可以用下面的交换图来表示：</p><p><span class="math display">\[\require{amsCd}\begin{CD}\mathbb{C}\otimes_\mathbb{R}V_\mathbb{R}@&gt;{c\otimes v\,\to\,(cv,\,\overline{c}v)}&gt;&gt; (V,\overline{V})\\@V{\tau}VV  @VV{(u,\,v)\leftrightarrow (v,\,u)}V \\\mathbb{C}\otimes_\mathbb{R}V_\mathbb{R}@&gt;{c\otimes v\,\to\,(cv,\,\overline{c}v)}&gt;&gt; (V,\overline{V})\end{CD}\]</span> 其中 <span class="math inline">\((u,v)\leftrightarrow(v,u)\)</span> 是 <span class="math inline">\(\tau\)</span> 在 <span class="math inline">\(V\oplus\overline{V}\)</span>上诱导的共轭结构，它交换两个直和分量。</p><h1 id="线性变换的复化">线性变换的复化</h1><p>设 <span class="math inline">\(W\)</span> 是实向量空间，<span class="math inline">\(W^\mathbb{C}=\mathbb{C}\otimes_\mathbb{R}W\)</span>是复化，则任何 <span class="math inline">\(f\in\mathrm{Hom}_\mathbb{R}(W,W)\)</span>可以自然地扩展为 <span class="math display">\[f^\mathbb{C}=1\otimesf\in\mathrm{Hom}_\mathbb{C}(W^\mathbb{C},W^\mathbb{C}).\]</span> <span class="math inline">\(f^\mathbb{C}\)</span> 与 <span class="math inline">\(f\)</span> 有相同的矩阵。注意 <span class="math inline">\(f^\mathbb{C}\)</span> 与共轭 <span class="math inline">\(\tau\)</span>交换，因为它们作用在张量积的不同分量上。</p><p>反过来，我们想知道何时 <span class="math inline">\(g\in\mathrm{Hom}_\mathbb{C}(W^\mathbb{C},W^\mathbb{C})\)</span>是某个 <span class="math inline">\(f\in\mathrm{Hom}_\mathbb{R}(W,W)\)</span>的复化：<span class="math inline">\(g=f^\mathbb{C}\)</span>。一个必要条件当然是 <span class="math inline">\(g\)</span> 与共轭 <span class="math inline">\(\tau\)</span>交换。这个条件也是充分的。这是因为，我们有自然同构 <span class="math display">\[\mathrm{Hom}_\mathbb{C}(W^\mathbb{C},W^\mathbb{C})\cong\mathbb{C}\otimes\mathrm{Hom}_\mathbb{R}(W,W).\]</span> 所以 <span class="math inline">\(g\)</span> 可以写成如下的形式： <span class="math display">\[g=1\otimes f_1+i\otimes f_2,\quadf_1,f_2\in\mathrm{Hom}_\mathbb{R}(W,W).\]</span> <span class="math inline">\(g\)</span> 与 <span class="math inline">\(\tau\)</span> 交换说明 <span class="math inline">\(f_2\)</span> 作用在 <span class="math inline">\(W\)</span> 上是零变换，从而 <span class="math inline">\(g=1\otimes f_1\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Jordan 标准形</title>
      <link href="jordan-canonical-form/"/>
      <url>jordan-canonical-form/</url>
      
        <content type="html"><![CDATA[<p>Jordan标准形定理是线性代数中的基本定理，专门为它写一篇长文好像有点多余：这方面的教材讲义实在是太多了！一个陈旧的定理还能写出什么新意来呢？</p><p>理由有两个。第一个原因是我曾经在做助教给学生讲这个定理的时候，突然发现不知道该怎么启发他们为好。虽然我知道Jordan标准形定理的很多种证法，照念几个不在话下，但是感觉有点疙疙瘩瘩的：怎么才能说清定理背后的想法，让学生觉得定理的成立是顺理成章的呢？于是我知道我对这个定理的理解还有模糊的地方。</p><p>第二个原因是 Jordan块有一个重要的代数性质是通常教材中不讲的，而这个性质是代数学中一类重要而常见的性质的雏形，这就是不可分解性。与之对应的是可对角化的线性变换的完全可约性。从一开始就让学生接触这些现象是有好处的。</p><span id="more"></span><h1 id="什么是-jordan-标准形">什么是 Jordan 标准形</h1><p>我们从中学就知道整数环和多项式环有唯一因子分解定理：每个整数可以唯一地分解为素数的乘积，每个域上的多项式可以唯一地分解为不可约多项式的乘积。数学里面有很多这样的唯一分解定理，现在我们想知道：有没有所谓的“线性变换的唯一分解定理”呢？可以猜测如果有这样的定理存在，那么大概可以表述为如下的样子：</p><div id="---------------------------------" class="statement sta____________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">线性变换的唯一分解定理</span>.</span><span class="statement-spah"> </span>（粗糙的版本）：设 <span class="math inline">\(V\)</span> 是域 <span class="math inline">\(F\)</span> 上的有限维向量空间，<span class="math inline">\(T\)</span> 是 <span class="math inline">\(V\)</span> 上的线性变换，则 <span class="math inline">\(T\)</span>可以唯一地分解为若干个“简单的”线性变换，而这些“简单的”线性变换本身不能再分解。</p></div><p>这个表述很不清楚，整数和多项式的分解就是表示为素因子的乘积，那什么是线性变换的分解呢？什么又是不可分解的线性变换呢？正确的概念是直和：</p><div class="statement simple plain unnumbered"><p>设 <span class="math inline">\(T\)</span> 是向量空间 <span class="math inline">\(V\)</span> 上的线性变换，如果 <span class="math inline">\(V\)</span> 可以分解为一些非平凡的子空间的直和<span class="math inline">\(V=V_1\oplus\cdots\oplusV_k\)</span>，使得每一个 <span class="math inline">\(V_i\)</span> 都是<span class="math inline">\(T\)</span>- 不变的子空间，则称 <span class="math inline">\(T\)</span> 是可以分解的； 如果 <span class="math inline">\(V\)</span> 不存在这样的分解，则称 <span class="math inline">\(T\)</span> 是不可分解的线性变换。</p></div><p>这样我们就可以比较准确的表述线性变换的唯一分解定理了：</p><div id="----------------------------------1" class="statement sta____________-1 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">线性变换的唯一分解定理</span>.</span><span class="statement-spah"> </span>（修正的版本）：设 <span class="math inline">\(V\)</span> 是域 <span class="math inline">\(F\)</span> 上的有限维向量空间，<span class="math inline">\(T\)</span> 是 <span class="math inline">\(V\)</span> 上的线性变换，则 <span class="math inline">\(V\)</span> 可以分解为若干个 <span class="math inline">\(T\)</span>- 不变子空间的直和 <span class="math inline">\(V=V_1\oplus\cdots\oplus V_k\)</span>，<span class="math inline">\(T\)</span> 限制在每个 <span class="math inline">\(V_i\)</span>上是不可分解的线性变换。这个分解还是唯一的，即如果 <span class="math inline">\(V=W_1\oplus\cdots\oplus W_l\)</span>是另一种分解，则 <span class="math inline">\(k=l\)</span>且适当重排以后，对每个 <span class="math inline">\(i\)</span>，<span class="math inline">\(T\)</span> 在 <span class="math inline">\(V_i\)</span> 上的限制与 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(W_i\)</span> 上的限制是相似的。</p></div><p>这里有一个重要的问题需要说明：在一般的域上研究“不可分解”的线性变换是一个棘手的多的问题，这个问题的解决要用到Frobenius 有理标准形，而在复数域上问题就简单很多，这就是 Jordan标准形做的事情。在本文中我们都在复数域上讨论。</p><p>那么什么样的线性变换算是不可分解的线性变换呢？</p><p>最简单也是最重要的例子就是移位算子：假设 <span class="math inline">\(T\)</span> 在 <span class="math inline">\(V\)</span> 的一组基 <span class="math inline">\(\{v_1,\cdots,v_n\}\)</span>的作用是一个向右的移位： <span class="math display">\[T:\quadv_n\rightarrow v_{n-1}\rightarrow\cdots\rightarrowv_1\rightarrow0.\]</span> 则称 <span class="math inline">\(T\)</span>是一个移位算子。<span class="math inline">\(T\)</span>在这组基下的矩阵为 <span class="math inline">\(J_0\)</span>: <span class="math display">\[(v_1, v_2, \ldots, v_n)J_0 = (0, v_1, \ldots,v_{n-1}),\quad J_0=\begin{pmatrix}0&amp;1&amp;&amp;\\ &amp;\ddots&amp;\ddots &amp;\\ &amp;&amp;0&amp;1\\&amp;&amp;&amp;0\end{pmatrix}.\]</span></p><p><span class="math inline">\(J_0\)</span> 叫做特征值为 0 的 Jordan块。注意 <span class="math inline">\(T\)</span> 是一个幂零算子：<span class="math inline">\(T^n=0\)</span>，它仅有唯一的特征值 0。</p><p>为什么 <span class="math inline">\(T\)</span> 是不可分解的？假设<span class="math inline">\(V=U\oplus W\)</span> 是两个非平凡 <span class="math inline">\(T\)</span>- 不变子空间的直和，则 <span class="math inline">\(T\)</span> 作为 <span class="math inline">\(U\)</span> 和 <span class="math inline">\(W\)</span> 上的幂零线性变换必然各有一个特征值为 0的特征向量，因此齐次线性方程组 <span class="math inline">\(TX=0\)</span>的解空间至少包含两个线性无关的向量。但是 <span class="math inline">\(T\)</span> 的秩是 <span class="math inline">\(n-1\)</span>，所以 <span class="math inline">\(TX=0\)</span> 的解空间是 1维的，这就导致了矛盾。</p><p>用同样的方法可以说明给移位算子 <span class="math inline">\(T\)</span>加上一个数乘变换以后得到的仍然是不可分解的线性变换：设 <span class="math inline">\(\lambda\in\mathbb{C}\)</span>，<span class="math inline">\(S=T+\lambda I\)</span>，则 <span class="math inline">\(S\)</span> 也是不可分解线性变换，其对应的矩阵<span class="math display">\[J_\lambda=\begin{pmatrix}\lambda&amp;1&amp;&amp;\\&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\lambda&amp;1\\&amp;&amp;&amp;\lambda\end{pmatrix}\]</span>叫做特征值为 <span class="math inline">\(\lambda\)</span> 的 Jordan块。</p><p>现在我们已经找到了一族不可分解的线性变换，那么它们是否就构成了全部的线性变换呢？答案是肯定的，这就是Jordan 标准形定理：</p><div id="jordan-canonical" class="unnumbered statement sta_jordan______ plain"><p><span class="statement-heading"><span class="statement-label">Jordan标准形定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(\mathbb{C}\)</span> 上有限维向量空间 <span class="math inline">\(V\)</span> 上的线性变换，则存在 <span class="math inline">\(V\)</span> 的一组基使得 <span class="math inline">\(T\)</span> 在这组基下的矩阵为 Jordan 块的直和：<span class="math display">\[T=J_{\lambda_1}\oplus\cdots\oplusJ_{\lambda_r}.\]</span> 这种分解是唯一的，意思是如果存在 <span class="math inline">\(V\)</span> 的另一组基使得 <span class="math inline">\(T\)</span> 的矩阵也是 Jordan 块的直和 <span class="math display">\[T=J_{\mu_1}\oplus\cdots\oplus J_{\mu_s},\]</span>则 <span class="math inline">\(r=s\)</span> 且适当重排后有 <span class="math inline">\(J_{\lambda_i}=J_{\mu_i}\)</span>。</p></div><h1 id="jordan-标准形定理的证明">Jordan 标准形定理的证明</h1><p>定理的结论包含存在性和唯一性两部分，我们先来处理存在性的证明。</p><h2 id="分解存在性-1转化为幂零的情形">分解存在性1：转化为幂零的情形</h2><p>首先我们需要另一个重要的定理：准素分解定理。准素分解定理是一个初步的分解，它把<span class="math inline">\(V\)</span> 分解为若干 <span class="math inline">\(T\)</span>- 不变子空间 <span class="math inline">\(V_i\)</span> 的直和，使得 <span class="math inline">\(T\)</span> 在每个 <span class="math inline">\(V_i\)</span> 上的作用是一个数乘变换 <span class="math inline">\(\lambda_iI\)</span> 加上一个幂零线性变换 <span class="math inline">\(N\)</span>。借助准素分解定理，我们把 Jordan标准形的存在性转化为论证任何幂零线性变换可以分解为一些零特征值的 Jordan块的直和。</p><div id="primary-decomposition" class="unnumbered statement sta_______ plain"><p><span class="statement-heading"><span class="statement-label">准素分解定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(T\)</span>的特征多项式为 <span class="math inline">\(f(x)\)</span>，且 <span class="math inline">\(f(x)\)</span> 在复数域上分解为一次因式的乘积 <span class="math display">\[f(x)=(x-\lambda_1)^{n_1}\cdots(x-\lambda_k)^{n_k},\]</span>这里的 <span class="math inline">\(\lambda_i\)</span> 互不相同。令 <span class="math inline">\(V_i=\mathrm{Ker}(T-\lambda_i I)^{n_i}\)</span>，则每个 <span class="math inline">\(V_i\)</span> 都是 <span class="math inline">\(T\)</span>- 不变子空间而且 <span class="math display">\[V=V_1\oplus\cdots\oplus V_m.\]</span></p></div><p><strong>证明</strong>：我们从一个简单的引理出发：</p><div id="coprime" class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(T\)</span> 是域 <span class="math inline">\(F\)</span> 上有限维向量空间 <span class="math inline">\(V\)</span> 上的线性变换，<span class="math inline">\(p(x),q(x)\in F[x]\)</span>是两个互素的多项式，且有 <span class="math inline">\(p(T)\cdotq(T)=0\)</span>。则 <span class="math inline">\(V=\mathrm{Ker}p(T)\oplus\mathrm{Ker}q(T)\)</span>。</p></div><p>引理的证明：由于 <span class="math inline">\(p(x),q(x)\)</span>是互素的多项式，所以存在多项式 <span class="math inline">\(s(x),t(x)\)</span> 满足 <span class="math display">\[s(x)p(x)+t(x)q(x)=1.\]</span> 即 <span class="math display">\[s(T)p(T)+t(T)q(T)=I.\]</span> 于是对任何 <span class="math inline">\(v\in V\)</span> 有 <span class="math display">\[v= \underbrace{s(T)p(T)v}_{\in\mathrm{Ker}q(T)} +\underbrace{t(T)q(T)v}_{\in\mathrm{Ker}p(T)}.\]</span> 这说明 <span class="math inline">\(V = \mathrm{Ker}p(T) +\mathrm{Ker}q(T)\)</span>。要验证这是直和，不妨设 <span class="math inline">\(v\in\mathrm{Ker}p(T)\cap\mathrm{Ker}q(T)\)</span>，则<span class="math inline">\(p(T)v=q(T)v=0\)</span>，于是 <span class="math display">\[v =s(T)p(T)v+t(T)q(T)v = 0.\]</span></p><p>把引理的结论反复应用在 <span class="math inline">\(f(x)\)</span>上即可得出准素分解定理。<span class="math inline">\(\blacksquare\)</span></p><h2 id="分解存在性-2证明幂零的情形">分解存在性 2：证明幂零的情形</h2><p>借助 <a href="#primary-decomposition" title="准素分解定理">准素分解定理</a>，我们把分解存在性转化为论证若<span class="math inline">\(N\)</span> 是某个向量空间 <span class="math inline">\(V\)</span> 上的幂零线性变换，则存在 <span class="math inline">\(V\)</span> 的一组基，使得 <span class="math inline">\(N\)</span> 在这组基下的矩阵是若干零特征值 Jordan块 <span class="math inline">\(J_0\)</span> 的和。注意一个 Jordan块对应的是一个链 <span class="math display">\[v\rightarrow Nv\rightarrow\cdots \rightarrow N^kv\rightarrow 0.\]</span>我们要证明存在若干条这样的互不相交的链，这些链所包含的全部非零向量构成<span class="math inline">\(V\)</span> 的一组基。</p><p>这一步的证明方法很多，但是相差不是很大，具体喜欢那种要看个人主观，这里介绍的是最简单也是最容易被初学者接受的一种。</p><p>对 <span class="math inline">\(V\)</span> 的维数 <span class="math inline">\(\dim V\)</span> 归纳，<span class="math inline">\(\dim V=1\)</span> 时显然结论成立。</p><p>现假设结论对所有维数小于 <span class="math inline">\(\dim V\)</span>的向量空间成立，考虑 <span class="math inline">\(V\)</span> 的像空间<span class="math inline">\(\mathrm{Im}(V)\)</span>。这是一个 <span class="math inline">\(N\)</span>- 不变子空间，且由于 <span class="math inline">\(N\)</span> 是幂零线性变换所以 <span class="math inline">\(\dim \mathrm{Im}(V)&lt;\dim V\)</span>，所以可以对<span class="math inline">\(\mathrm{Im}(V)\)</span> 使用归纳假设：存在<span class="math inline">\(\mathrm{Im}(V)\)</span>的一组基如下，它们构成 <span class="math inline">\(q\)</span>条不相交的链 <span class="math inline">\(\mathcal{O}_1,\cdots,\mathcal{O}_q\)</span>：</p><p><span class="math display">\[\begin{array}{l}&amp;v_{1,1}\rightarrowv_{1,2}\rightarrow\cdots\rightarrow v_{1,n_1}\rightarrow0.\\&amp;v_{2,1}\rightarrow v_{2,2}\rightarrow\cdots\rightarrowv_{2,n_2}\rightarrow 0.\\&amp;\cdots\\&amp; v_{q,1}\rightarrowv_{q,2}\rightarrow\cdots\rightarrow v_{q,n_q}\rightarrow0.\end{array}\]</span></p><p>由于 <span class="math inline">\(v_{i,1}\in \mathrm{Im}(V)\)</span>因此可以设 <span class="math inline">\(v_{i,1}=Nw_i\)</span>，从而我们得到一组更长的链（就是在前面加上一项）</p><p><span class="math display">\[\begin{array}{l}&amp;w_1\rightarrowv_{1,1}\rightarrow v_{1,2}\rightarrow\cdots\rightarrowv_{1,n_1}\rightarrow 0.\\&amp;w_2\rightarrow v_{2,1}\rightarrowv_{2,2}\rightarrow\cdots\rightarrow v_{2,n_2}\rightarrow0.\\&amp;\cdots\cdots\cdots\\&amp;w_q\rightarrow v_{q,1}\rightarrowv_{q,2}\rightarrow\cdots\rightarrow v_{q,n_q}\rightarrow0.\end{array}\]</span></p><p>那么这些新链包含的向量是否构成 <span class="math inline">\(V\)</span>的一组基？答案是我们还要补上一些在 <span class="math inline">\(V\)</span> 中长度是 1，但是在 <span class="math inline">\(\mathrm{Im}(V)\)</span> 中“消失”了的链：注意 <span class="math inline">\(\{v_{1,n_1},\cdots,v_{q,n_q}\}\)</span> 是 <span class="math inline">\(\mathrm{Ker}N\)</span> 中的线性无关元，但是 <span class="math inline">\(\mathrm{Ker}N\)</span>还可能有其它的基向量。将它们扩充为 <span class="math inline">\(\mathrm{Ker}N\)</span> 的一组基</p><p><span class="math display">\[\{ v_{1,n_1},\cdots,v_{q,n_1}\}\cup \{w_{q+1},\cdots,w_{K}\},\quad K=\dim\mathrm{Ker}N.\]</span></p><p>从而我们最终得到下面的链图：</p><p><span class="math display">\[\begin{array}{r}\mathbf{w_1}\rightarrowv_{1,1}\rightarrow v_{1,2}\rightarrow\cdots\rightarrowv_{1,n_1}\rightarrow 0.&amp;\\\mathbf{w_2}\rightarrow v_{2,1}\rightarrowv_{2,2}\rightarrow\cdots\rightarrow v_{2,n_2}\rightarrow0.&amp;\\\cdots\cdots\cdots&amp;\\\mathbf{w_q}\rightarrowv_{q,1}\rightarrow v_{q,2}\rightarrow\cdots\rightarrowv_{q,n_q}\rightarrow 0.&amp;\\\mathbf{w_{q+1}}\rightarrow0.&amp;\\\cdots\cdots&amp;\\\mathbf{w_K}\rightarrow0.\end{array}\]</span></p><p>你可以看到 <span class="math inline">\(w_{q+1},\ldots,w_K\)</span>正是那些在 <span class="math inline">\(V\)</span> 中长度为 1，但是在<span class="math inline">\(\mathrm{Im}(V)\)</span> 中消失了的链。</p><p>最后只剩下验证这些向量确实构成 <span class="math inline">\(V\)</span>的一组基。显然这些向量一共有 <span class="math display">\[\dim\mathrm{Im}(V)+\dim\mathrm{Ker}N=\dim V\]</span>个，所以只要再说明它们是线性无关的。</p><p>假设有线性关系</p><p><span class="math display">\[\cdots+(c_0w_i+c_1v_{i,1}+\cdots+c_{n_i}v_{i,n_i})+\cdots+\sum_{j=q+1}^Kd_jw_j=0,\]</span></p><p>我们要说明出现在上式中的所有系数 <span class="math inline">\(c_i,d_j\)</span> 都是 0。左边用 <span class="math inline">\(N\)</span> 作用得到</p><p><span class="math display">\[\cdots+(c_0v_{i,1}+c_1v_{i,2}+\cdots+c_{n_i-1}v_{i,n_i})+\cdots=0.\]</span></p><p>这是一个关于 <span class="math inline">\(\mathrm{Im}(V)\)</span>的一组基的一个线性关系，于是 <span class="math inline">\(c_0=\cdots=c_{n_i-1}=0\)</span>，从而剩下的线性关系为</p><p><span class="math display">\[\cdots+c_{n_i}v_{i,n_i}+\cdots+\sum_{j=q+1}^Kd_jw_j=0.\]</span></p><p>而这是一个关于 <span class="math inline">\(\mathrm{Ker}N\)</span>的一组基的一个线性关系，于是 <span class="math inline">\(c_{n_i}=d_{q+1}=\cdots=d_K=0\)</span>，从而所有的系数都是0，这就完成了 Jordan 标准形存在性的证明。</p><h2 id="分解唯一性的证明">分解唯一性的证明</h2><p>要证明分解的唯一性，我们只要证明对任一特征值 <span class="math inline">\(\lambda_i\)</span>，<span class="math inline">\(T\)</span> 限制在 <span class="math inline">\(U=\mathrm{Ker}(T-\lambda_i)^{n_i}\)</span>上分解为 Jordan 块的方式是唯一的。我们可以不妨假设 <span class="math inline">\(\lambda_i=0\)</span>。记 <span class="math inline">\(N=T\mid_U\)</span>，则 <span class="math inline">\(N\)</span> 是 <span class="math inline">\(U\)</span> 上的幂零线性变换。根据存在性的证明，在<span class="math inline">\(U\)</span> 上我们有如下的链图： <span class="math display">\[\begin{array}{r}v_{1,1}\rightarrowv_{1,2}\rightarrow\cdots\rightarrow v_{1,n_1}\rightarrow0.&amp;\\v_{2,1}\rightarrow v_{2,2}\rightarrow\cdots\rightarrowv_{2,n_2}\rightarrow 0.&amp;\\\cdots\cdots&amp;\\ v_{q,1}\rightarrowv_{q,2}\rightarrow\cdots\rightarrow v_{q,n_q}\rightarrow0.\end{array}\]</span> 这里每个链代表一个 Jordan块，链按照长度递减的顺序排列。我们要证明链的个数 <span class="math inline">\(q\)</span> 和链的长度 <span class="math inline">\((n_1,\ldots,n_q)\)</span>都是唯一确定的，不依赖于基的选择。</p><p>我用一个具体的例子来说明：</p><p><span class="math display">\[\begin{array}{r}\bullet\rightarrow {\color{blue}{\bullet}}\rightarrow{\color{green}{\bullet}}\rightarrow{\color{red}{\bullet}}\rightarrow 0.\\{\color{blue}{\bullet}}\rightarrow{\color{green}{\bullet}}\rightarrow{\color{red}{\bullet}}\rightarrow0.&amp;\\{\color{green}{\bullet}}\rightarrow{\color{red}{\bullet}}\rightarrow0.&amp;\\{\color{red}{\bullet}}\rightarrow 0.\\{\color{red}{\bullet}}\rightarrow 0.\end{array}\]</span></p><p>注意到在链图中，从右边数起，从第 <span class="math inline">\(1\)</span> 到第 <span class="math inline">\(i\)</span> 列，都会被 <span class="math inline">\(N^i\)</span> 变成零向量。这些向量构成了 <span class="math inline">\(\mathrm{Ker}N^i\)</span>的一组基。例如在上面例子中，<span class="math inline">\(\{{\color{red}{\bullet}} \}\)</span> 的列构成了 <span class="math inline">\(\mathrm{Ker}N\)</span> 的一组基，<span class="math inline">\(\{ {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}\)</span> 的列构成了 <span class="math inline">\(\mathrm{Ker}N^2\)</span> 的一组基，等等。</p><p>于是我们有子空间的升链： <span class="math display">\[(0)\subset\underbrace{\mathrm{Ker}N}_{\{ {\color{red}{\bullet}} \}}\subset\underbrace{\mathrm{Ker}N^2}_{\{ {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}} \subset \underbrace{\mathrm{Ker}N^3}_{\{{\color{blue}{\bullet}}\mid {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}} \subset \underbrace{\mathrm{Ker}N^4}_{\{\bullet\mid {\color{blue}{\bullet}}\mid {\color{green}{\bullet}}\mid{\color{red}{\bullet}}\}}=U.\]</span> 不难看到右边的第 <span class="math inline">\(i\)</span> 列正好构成商空间 <span class="math inline">\(\mathrm{Ker}N^{i}/\mathrm{Ker}N^{i-1}\)</span>的一组基。 <span class="math display">\[\begin{aligned}\mathrm{Ker}N: \quad &amp;  \{ {\color{red}{\bullet}} \}\\\mathrm{Ker}N^2/\mathrm{Ker}N: \quad &amp; \{ {\color{green}{\bullet}}\}\\\mathrm{Ker}N^3/\mathrm{Ker}N^2: \quad &amp; \{ {\color{blue}{\bullet}}\}\\\mathrm{Ker}N^4/\mathrm{Ker}N^3=U/\mathrm{Ker}N^3: \quad &amp; \{\bullet \}\\\end{aligned}\]</span> 所以右边第 <span class="math inline">\(i\)</span> 列的长度等于<span class="math inline">\(\dim\mathrm{Ker}N^i -\dim\mathrm{Ker}N^{i-1}\)</span>，是一个由 <span class="math inline">\(N\)</span>完全确定的值。所有的列都是如此。而各行的长度可以由各列长度得出，从而也是由<span class="math inline">\(N\)</span>唯一确定的。这就证明了分解的唯一性。</p><h1 id="进一步的思考">进一步的思考</h1><p>一个很有意思的问题是，给定</p><p><span class="math display">\[J_\lambda=\begin{pmatrix}\lambda&amp;1&amp;&amp;\\&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\lambda&amp;1\\&amp;&amp;&amp;\lambda\end{pmatrix}_{n\timesn}\]</span></p><p>为一个特征值 <span class="math inline">\(\lambda\)</span> 的 Jordan块，计算其 <span class="math inline">\(k\)</span> 次幂 <span class="math inline">\(J_\lambda^k\)</span> 的 Jordan 标准形。</p><p>当 <span class="math inline">\(\lambda\ne0\)</span> 时，</p><p><span class="math display">\[J_\lambda^k = \begin{pmatrix}\lambda^k&amp;k\lambda^{k-1}&amp;\ddots&amp;\\&amp;\lambda^k&amp;\ddots&amp;\ddots\\&amp;&amp;\ddots&amp;k\lambda^{k-1}\\&amp;&amp;&amp;\lambda^k\end{pmatrix}.\]</span></p><p>你知道怎样计算 <span class="math inline">\(J_\lambda^k\)</span>吗？记住这个技巧：把多项式 <span class="math inline">\(x^k\)</span> 在<span class="math inline">\(\lambda\)</span> 处 Taloy 展开：</p><p><span class="math display">\[x^k=(x-\lambda)^k+a_{k-1}(x-\lambda)^{k-1}+a_1(x-\lambda)+a_0,\]</span></p><p>然后代入即可。</p><p>和 Jordan 块不可分解性的证明完全一样，我们发现 <span class="math inline">\(J_\lambda^k-\lambda^k I\)</span> 的秩是 <span class="math inline">\(n-1\)</span>，因此方程组 <span class="math inline">\(J_\lambda^kX=\lambda^k X\)</span> 的解空间是 1维的，从而 <span class="math inline">\(J_\lambda^k\)</span>是不可分解的，因此其 Jordan 标准形只有一块，就是</p><p><span class="math display">\[\begin{pmatrix}\lambda^k&amp;1&amp;&amp;\\&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\lambda^k&amp;1\\&amp;&amp;&amp;\lambda^k\end{pmatrix}_{n\timesn}.\]</span></p><p>最有意思的情形发生在 <span class="math inline">\(\lambda=0\)</span>时，这个时候 Jordan 会均匀的碎裂为一些小的 Jordan 块的和。</p><p>这时 <span class="math inline">\(J_0\)</span> 是一个移位算子：</p><p><span class="math display">\[J_0:\quad v_n\rightarrowv_{n-1}\rightarrow \cdots \rightarrow v_1\rightarrow 0.\]</span></p><p>整个链只有一条。但是 <span class="math inline">\(J_0^k\)</span> 则是<span class="math inline">\(k\)</span> 步 <span class="math inline">\(k\)</span> 步地跳：</p><p><span class="math display">\[J_0^k:\quad \left\{\begin{array}{l}v_n\rightarrow v_{n-k}\rightarrow \cdots\rightarrow0,\\v_{n-1}\rightarrow v_{n-1-k}\rightarrow \cdots\rightarrow0,\\\cdots\\v_{n-k+1}\rightarrow v_{n-2k+1}\rightarrow \cdots\rightarrow 0.\end{array}\right.\]</span></p><p>所以 <span class="math inline">\(J_0^k\)</span> 有 <span class="math inline">\(k\)</span> 条链，每个链都是一个 Jordan 块，即<span class="math inline">\(J_0^k\)</span> 的标准形中有 <span class="math inline">\(k\)</span> 个 Jordan 块。设 <span class="math inline">\(n=qk+r\)</span>，这里 <span class="math inline">\(0\leq r&lt; k\)</span>，则这 <span class="math inline">\(k\)</span> 个 Jordan 块中有 <span class="math inline">\(r\)</span> 个是 <span class="math inline">\(q+1\)</span> 阶的，<span class="math inline">\(k-r\)</span> 个是 <span class="math inline">\(q\)</span> 阶的。</p><p>举个例子就明白了，一个 8 阶的 0 特征值 Jordan 块 <span class="math inline">\(J_0\)</span>，<span class="math inline">\(J_0^3\)</span> 的 Jordan标准形是什么样子的？这个时候 <span class="math inline">\(J_0^3\)</span>有 3 个链 <span class="math inline">\(\{v_8,v_5,v_2\}\)</span>, <span class="math inline">\(\{v_7,v_4,v_1 \}\)</span>, <span class="math inline">\(\{v_6,v_3\}\)</span>，所以 <span class="math inline">\(J_0^3\)</span> 的 Jordan 标准形有 2 个 3 阶的Jordan 块和 1 个 2 阶的 Jordan 块。</p><p>总结一下：零特征值的 Jordan块的高次幂一定会分裂，而且是尽可能均匀的分裂；非零特征值的 Jordan块的任意次幂都不会分裂。</p><p>一个不可约的代数结构，在某种限制或者扩张的意义下却能均匀的“碎裂”，这是代数学中一个常见而重要的现象。比如设<span class="math inline">\(f\)</span> 是一个有理数域 <span class="math inline">\(\mathbb{Q}\)</span> 上的不可约多项式，<span class="math inline">\(F\)</span> 是 <span class="math inline">\(\mathbb{Q}\)</span> 的一个正规扩域，则如果 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(F\)</span> 上是可约的，那么 <span class="math inline">\(f\)</span>必然分解成一些次数相同的多项式的乘积：</p><p><span class="math display">\[f=f_1f_2\cdots f_r,\quad \degf_1=\cdots=\deg f_r.\]</span></p><p>类似的现象还有代数数论中素理想的分解，群表示论中不可约表示（在诱导和限制下） 的分解，代数几何中不可约代数簇的分解等等。</p>]]></content>
      
      
      <categories>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>国际象棋棋盘的多米诺骨牌密铺</title>
      <link href="Pfaffian-and-chessboard-tiling/"/>
      <url>Pfaffian-and-chessboard-tiling/</url>
      
        <content type="html"><![CDATA[<p>下面的问题与统计物理中的 Dimer 格点模型有关：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>用 <span class="math inline">\(1\times2\)</span> 的多米诺骨牌密铺一张 <span class="math inline">\(8\times8\)</span>的国际象棋棋盘，有多少种不同的方法？</p></div><p>下图是其中一种：</p><p><img style="margin:0px auto;display:block" src="/images/pfaff/chessboard.svg"></p><p>答案是 12988816，非常大的一个数字，显然不可能是逐个枚举数出来的。1961年德国物理学家 Kasteleyn借助线性代数的工具首先解决了这个问题，本文就来介绍他的方法。</p><span id="more"></span><h1 id="反对称矩阵的-pfaffian">反对称矩阵的 Pfaffian</h1><p>我们从一个线性代数的结论说起，先来看一个 4 阶反对称矩阵的行列式：</p><p><span class="math display">\[\det\begin{pmatrix}0&amp;a_{12}&amp;a_{13}&amp;a_{14}\\-a_{12}&amp;0&amp;a_{23}&amp;a_{24}\\-a_{13}&amp;-a_{23}&amp;0&amp;a_{34}\\-a_{14}&amp;-a_{24}&amp;-a_{34}&amp;0\end{pmatrix}=(a_{12}a_{34}-a_{13}a_{24}+a_{14}a_{23})^2.\]</span>你发现了什么？这个反对称矩阵的行列式是一个多项式的平方，而且观察右边每个单项式的下标你发现，它们分别是<span class="math inline">\(\{(12),(34)\}\)</span>，<span class="math inline">\(\{(14),(23)\}\)</span>，<span class="math inline">\(\{(13),(24)\}\)</span>，恰好跑遍集合 <span class="math inline">\(\{1,2,3,4\}\)</span> 的所有匹配！</p><p>这个结论不是偶然的，实际上对任何 <span class="math inline">\(2n\)</span> 阶反对称矩阵 <span class="math inline">\(A\)</span>，<span class="math inline">\(A\)</span>的行列式都可以表示为一个多项式的平方，这个多项式叫做 Pfaffian多项式，记作 <span class="math inline">\(\mathrm{pf}(A)\)</span>。<span class="math inline">\(\mathrm{pf}(A)\)</span> 中的单项式与集合 <span class="math inline">\([2n]=\{1,2,\ldots,2n\}\)</span>的匹配一一对应。</p><p>那么奇数阶反对称矩阵呢？它们的行列式都是 0，所以不考虑它们。</p><p>我们来给出 <span class="math inline">\(\mathrm{pf}(A)\)</span>的定义：考虑一种把 <span class="math inline">\([2n]\)</span>两两配对（从而分成 <span class="math inline">\(n\)</span> 对）的方式：<span class="math display">\[\pi =(i_1,j_1)(i_2,j_2)\cdots(i_n,j_n).\]</span> <span class="math inline">\(\pi\)</span> 叫做集合 <span class="math inline">\([2n]\)</span>的一个匹配，它可以用一个置换来表示，仍然记作 <span class="math inline">\(\pi\)</span>： <span class="math display">\[\pi=\begin{pmatrix}1&amp;2&amp;3&amp;4&amp;\cdots&amp;2n-1&amp;2n\\i_1&amp;j_1&amp;i_2&amp;j_2&amp;\cdots&amp;i_n&amp;j_n\end{pmatrix}.\]</span>定义 <span class="math inline">\(\pi\)</span> 的权为 <span class="math display">\[\mathrm{wt}(\pi)=\text{sgn}(\pi)\cdota_\pi.\]</span> 其中 <span class="math inline">\(\text{sgn}(\pi)\)</span> 就是置换 <span class="math inline">\(\pi\)</span> 的符号，偶置换时为 <span class="math inline">\(+1\)</span>，奇置换时为 <span class="math inline">\(-1\)</span>， <span class="math display">\[a_\pi=a_{i_1j_1}a_{i_2j_2}\cdotsa_{i_nj_n}.\]</span> 于是 <span class="math inline">\(\mathrm{wt}(\pi)\)</span> 是一个次数为 <span class="math inline">\(n\)</span> 的单项式。</p><p><span class="math inline">\(\mathrm{wt}(\pi)\)</span>的定义是合理无歧义的吗？注意一个匹配 <span class="math inline">\(\pi\)</span>可以有多种不同的置换表示：你可以按任意的顺序排列这些 <span class="math inline">\((i_k,j_k)\)</span> 对，比如 <span class="math display">\[\pi=\begin{pmatrix}1&amp;2&amp;3&amp;4&amp;\cdots&amp;2n-1&amp;2n\\i_2&amp;j_2&amp;i_3&amp;j_3&amp;\cdots&amp;i_1&amp;j_1\end{pmatrix}.\]</span>或是交换某一对中 <span class="math inline">\(i_k\)</span> 和 <span class="math inline">\(j_k\)</span> 的位置： <span class="math display">\[\pi=\begin{pmatrix}1&amp;2&amp;\cdots&amp;2k-1&amp;2k&amp;\cdots&amp;2n-1&amp;2n\\i_1&amp;j_1&amp;\cdots&amp;j_k&amp;i_k&amp;\cdots&amp;i_n&amp;j_n\end{pmatrix}.\]</span>不难验证，虽然不同的置换表示给出的 <span class="math inline">\(\text{sgn}(\pi)\)</span> 和 <span class="math inline">\(a_\pi\)</span> 的值可能不同，但是二者的乘积 <span class="math inline">\(\mathrm{wt}(\pi)\)</span>的值总是一样的。比如把某个 <span class="math inline">\((i_k,j_k)\)</span> 改写成 <span class="math inline">\((j_k,i_k)\)</span>，那么 <span class="math inline">\(\text{sgn}(\pi)\)</span> 和 <span class="math inline">\(a_\pi\)</span> 都同时变号，乘积保持不变。总之<span class="math inline">\(\mathrm{wt}(\pi)\)</span> 的定义只与匹配<span class="math inline">\(\pi\)</span>有关，并不依赖于具体置换的选择。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(\mathcal{M}_{2n}\)</span> 为 <span class="math inline">\([2n]\)</span> 的所有匹配组成的集合，矩阵 <span class="math inline">\(A\)</span> 的 Pfaffian 多项式 <span class="math inline">\(\text{pf}(A)\)</span> 定义为 <span class="math display">\[\text{pf}(A) =\sum_{\pi\in\mathcal{M}_{2n}}\mathrm{wt}(\pi).\]</span></p></div><p>现在我们可以叙述本节的主要结论了：</p><div id="pfaff" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(2n\)</span> 阶反对称矩阵，则 <span class="math inline">\(\det A=[\text{pf}(A)]^2\)</span>。</p></div><p><strong>证明</strong>：根据行列式的定义， <span class="math display">\[\det A=\sum_{\sigma\inS_{2n}}\text{sgn}(\sigma)a_{\sigma}=\sum_{\sigma\inS_{2n}}\text{sgn}(\sigma) a_{1\sigma(1)}a_{2\sigma(2)}\cdots.\]</span></p><p>回忆任何置换 <span class="math inline">\(\sigma\)</span>都可以表示为若干不相交的轮换的乘积： <span class="math display">\[\sigma= (i_1i_2\cdots i_k)(j_1j_2\cdots j_l)\cdots.\]</span> 其中 <span class="math inline">\(k,l,\ldots\)</span> 是各个轮换的长度。设 <span class="math inline">\(\mathcal{E}_{2n}\)</span>为轮换长度都是偶数的那些置换组成的集合，我们要证明在上述行列式的求和中，<span class="math inline">\(\sigma\)</span> 只跑遍 <span class="math inline">\(\mathcal{E}_{2n}\)</span>，不属于 <span class="math inline">\(\mathcal{E}_{2n}\)</span>的那些置换整体对行列式的贡献为 0。</p><p>分两种情况：</p><ol type="1"><li>如果 <span class="math inline">\(\sigma\)</span>包含一个不动点：<span class="math inline">\(\sigma(i)=i\)</span>，则由于<span class="math inline">\(a_{i\sigma(i)}=0\)</span> 从而 <span class="math inline">\(\sigma\)</span> 对行列式的贡献为 0。</li><li>如果 <span class="math inline">\(\sigma\)</span>没有不动点，但是包含长度为奇数的轮换，选择其中含有最小元素的那个，设为<span class="math inline">\(C=(i_1i_2\cdots i_k)\)</span>，这里 <span class="math inline">\(k\)</span> 为奇数且大于等于 3。定义置换 <span class="math inline">\(\sigma'\)</span> 如下：<span class="math inline">\(\sigma'\)</span> 的其它轮换与 <span class="math inline">\(\sigma\)</span> 完全相同，只是把 <span class="math inline">\(C\)</span> 整个倒过来变成 <span class="math inline">\((i_k\cdots i_2i_1)\)</span>。显然 <span class="math inline">\(\sigma'\)</span> 对应的和项与 <span class="math inline">\(\sigma\)</span> 抵消，而且如果对 <span class="math inline">\(\sigma'\)</span> 执行此操作又会回到 <span class="math inline">\(\sigma\)</span>。于是所有没有不动点，而且包含长度是奇数的轮换的置换可以两两配对抵消。</li></ol><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span><span class="math inline">\(\sigma=(1\,3)(2\,4\,6)(5\,7\,8)(9\,10)\)</span> 有2 个长度为奇数的轮换 <span class="math inline">\((246)\)</span> 和 <span class="math inline">\((578)\)</span>，这两个轮换中最小的元素是 <span class="math inline">\(2\)</span>，它出现在 <span class="math inline">\((2\,4\,6)\)</span> 中，所以 <span class="math inline">\(\sigma'=(1\,3)(6\,4\,2)(5\,7\,8)(9\,10)\)</span>。</p></div><p>这就证明了在行列式的求和中，我们只需要考虑那些轮换分解长度都是偶数的置换。</p><p>于是为了证明 <span class="math inline">\(\det A=[{\rmpf}(A)]^2\)</span>，只要证明 <span class="math display">\[\sum_{\pi\in\mathcal{M}_{2n}}\sum_{\pi'\in\mathcal{M}_{2n}}{\rmwt}(\pi){\rm wt}(\pi')=\sum_{\sigma\in\mathcal{E}_{2n}}{\rmsgn}(\sigma) a_\sigma.\]</span></p><p>为此我们来建立一个双射 <span class="math display">\[\mathcal{M}_{2n}\times\mathcal{M}_{2n}\rightarrow \mathcal{E}_{2n}:\quad(\pi,\pi')\rightarrow \sigma.\]</span>而且这个双射还保持权的相等，即 <span class="math display">\[\mathrm{wt}(\pi)\cdot\mathrm{wt}(\pi')=\text{sgn}(\sigma)a_{\sigma}.\]</span>这样就证明了定理。</p><p>对任何两个匹配 <span class="math inline">\((\pi,\pi')\in\mathcal{M}_{2n}\times\mathcal{M}_{2n}\)</span>，我们把它俩画在同一张图上，图的顶点集合就是<span class="math inline">\([2n]\)</span>，两个顶点 <span class="math inline">\(i,j\)</span> 如果在 <span class="math inline">\(\pi\)</span>中配成一对就在它们之间连一条红色边，或者如果 <span class="math inline">\(i,j\)</span> 在 <span class="math inline">\(\pi'\)</span>中配成一对就在它们之间连一条蓝色边。这样我们得到的是一个每个顶点恰好有一条红边和一条蓝边的图，即每个顶点度数都是2 的正则图。这个图一定可以表示为若干条不相交的回路的并 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，在一个回路中，红边和蓝边是交错出现的，因此每个回路的长度都是偶数。</p><p>设 <span class="math inline">\(C\)</span> 是这样的一条回路，<span class="math inline">\(i_1\)</span> 是 <span class="math inline">\(C\)</span> 中最小的元素，从 <span class="math inline">\(i_1\)</span> 出发，沿着红色的边，即 <span class="math inline">\(\pi\)</span> 的方向绕 <span class="math inline">\(C\)</span> 一圈： <span class="math display">\[i_1\,{\color{red}{\xrightarrow{\pi}}}\,i_2\,{\color{blue}{\xrightarrow{\pi'}}}\,i_3\,{\color{red}{\xrightarrow{\pi}}}\,\cdots\,{\color{blue}{\xrightarrow{\pi'}}}\,i_1.\]</span>这样得到了一个轮换 <span class="math inline">\((i_1i_2\cdotsi_k)\)</span>。对每个回路都这样做，我们就得到了一组轮换，与 <span class="math inline">\((\pi,\pi')\)</span> 对应的置换 <span class="math inline">\(\sigma\)</span>就定义为所有这些轮换的乘积。由于这些回路互不相交，这些轮换两两交换，所以我们不必关心它们相乘的顺序，任何顺序都给出同样的<span class="math inline">\(\sigma\)</span>。</p><p>逆映射也很显然，对任何 <span class="math inline">\(\sigma\in\mathcal{E}_{2n}\)</span>，在 <span class="math inline">\(\sigma\)</span> 的每个轮换 <span class="math inline">\(C\)</span> 中，找到最小的 <span class="math inline">\(i_1\in C\)</span>，设 <span class="math inline">\(C=(i_1i_2\cdots i_k)\)</span>，那么依次规定 <span class="math display">\[i_1\,{\color{red}{\xrightarrow{\pi}}}\,i_2\,{\color{blue}{\xrightarrow{\pi'}}}\,i_3\,{\color{red}{\xrightarrow{\pi}}}\,\cdots\,{\color{blue}{\xrightarrow{\pi'}}}\,i_1.\]</span>即可。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>下面是将 <span class="math inline">\(2n=12\)</span>，<span class="math inline">\(\sigma=(1\,3\,4\,5\,7\,10)(2\,6\,9\,8)(11\,12)\)</span>对应到两个匹配 <span class="math inline">\(\pi,\pi'\)</span>的示意图：<img style="margin:0px auto;display:block" src="/images/pfaff/matching.svg" width="500"></p></div><p>最后我们来验证这个对应保持权的相等：设 <span class="math inline">\(\sigma\)</span> 的轮换分解式为 <span class="math display">\[\sigma=(i_1i_2\cdots i_{2k-1}i_{2k})(j_1j_2\cdotsj_{2l-1}j_{2l})\cdots.\]</span> 其中 <span class="math inline">\(i_1,j_1,\ldots\)</span>是每个轮换中最小的元素。于是 <span class="math display">\[\pi=\begin{pmatrix}1&amp;2&amp;\cdots&amp;2k-1&amp;2k&amp;2k+1&amp;2k+2&amp;\cdots\\i_1&amp;i_2&amp;\cdots&amp;i_{2k-1}&amp;i_{2k}&amp;j_1&amp;j_2&amp;\cdots\end{pmatrix}.\]</span><span class="math display">\[\pi'=\begin{pmatrix}1&amp;2&amp;\cdots&amp;2k-1&amp;2k&amp;2k+1&amp;2k+2&amp;\cdots\\i_2&amp;i_3&amp;\cdots&amp;i_{2k}&amp;i_1&amp;j_2&amp;j_3&amp;\cdots\end{pmatrix}.\]</span></p><p>容易验证 <span class="math inline">\(a_\pia_{\pi'}=a_\sigma\)</span> 以及 <span class="math inline">\(\pi'=\sigma\cdot\pi\)</span>，从而 <a href="#pfaff" title="定理 1.1">定理 1.1</a> 得证。</p><h1 id="平面图的-pfaffian-定向">平面图的 Pfaffian 定向</h1><p>Pfaffian 多项式的结论启发我们可以用它来计算一个图 <span class="math inline">\(G\)</span> 的所有匹配的个数。</p><p>设 <span class="math inline">\(G\)</span> 有 <span class="math inline">\(2n\)</span> 个顶点。首先给 <span class="math inline">\(G\)</span> 的边任意定向，得到一个简单有向图 <span class="math inline">\(\overrightarrow{G}\)</span>。写出 <span class="math inline">\(\overrightarrow{G}\)</span> 的邻接矩阵 <span class="math inline">\(A=(a_{ij})\)</span>：</p><p><span class="math display">\[a_{ij}=\begin{cases}1&amp; i\rightarrowj,\\-1&amp; j\rightarrow i,\\ 0&amp;\text{else}.\end{cases}\]</span></p><p>则 <span class="math inline">\(A\)</span> 是一个反对称矩阵且</p><p><span class="math display">\[\detA=\left(\sum_{\pi\in\mathcal{M}_{2n}}\mathrm{wt}(\pi)\right)^2=\left(\sum_{\pi\in\mathcal{M}_{2n}}\text{sgn}(\pi)a_{i_1j_1}a_{i_2j_2}\cdotsa_{i_nj_n}\right)^2.\]</span></p><p>这里 <span class="math inline">\(\pi=(i_1,j_1)(i_2,j_2)\cdots(i_n,j_n)\)</span>跑遍集合 <span class="math inline">\([2n]\)</span> 的所有匹配。由于每个<span class="math inline">\(a_{ij}\)</span> 的取值是 <span class="math inline">\(\pm1\)</span> 或者 <span class="math inline">\(0\)</span>，所以 <span class="math inline">\(\mathrm{wt}(\pi)\)</span> 的值也是 <span class="math inline">\(\pm1\)</span> 或者 <span class="math inline">\(0\)</span>，并且 <span class="math inline">\(\mathrm{wt}(\pi)\ne0\)</span> 当且仅当对每个 <span class="math inline">\(1\leq k\leq n\)</span>，<span class="math inline">\(i_k\)</span> 和 <span class="math inline">\(j_k\)</span> 在 <span class="math inline">\(G\)</span> 中是相邻的，即 <span class="math inline">\(\pi\)</span> 给出 <span class="math inline">\(G\)</span> 的一个匹配。于是 <span class="math inline">\(G\)</span> 的所有匹配与 <span class="math inline">\(\mathrm{pf}(A)\)</span>中的非零项一一对应。不幸的是，这些非零项有 +1 有-1，把它们直接加起来得到的可不是 <span class="math inline">\(G\)</span>的所有匹配的个数。但是我们可以这样想： 能否通过适当的定向 <span class="math inline">\(G\)</span>，即适当给 <span class="math inline">\(a_{ij}\)</span> 赋以 +1 或者 -1，使得每一个非零的<span class="math inline">\(\mathrm{wt}(\pi)\)</span> 都同为 +1 或者同为-1？如果可以，那么<span class="math inline">\(\sqrt{|\det A|}\)</span>就是要求的匹配的个数。</p><p>回忆在证明 <a href="#pfaff" title="定理 1.1">定理 1.1</a>时，我们有结论 <span class="math display">\[\mathrm{wt}(\pi)\cdot\mathrm{wt}(\pi')=\text{sgn}(\sigma)a_{\sigma}.\]</span>要使得所有非零的 <span class="math inline">\(\mathrm{wt}(\pi)\)</span>都同为 +1 或者同为 -1，只要让每个非零的 <span class="math inline">\(\text{sgn}(\sigma)a_{\sigma}\)</span> 都等于 1即可。设 <span class="math inline">\(\sigma\)</span> 是一个使得 <span class="math inline">\(a_\sigma\ne0\)</span> 的置换且 <span class="math inline">\(\sigma\)</span> 的轮换分解为 <span class="math inline">\(\sigma=C_1\cdots C_l\)</span>，则 <span class="math inline">\(\text{sgn}(\sigma)=(-1)^l\)</span>，<span class="math inline">\(a_\sigma=a_{C_1}\cdots a_{C_l}\)</span>。这里记号<span class="math inline">\(a_{C_i}\)</span> 的含义是，如果 <span class="math inline">\(C_i=(i_1i_2\cdots i_k)\)</span>，则 <span class="math inline">\(a_{C_i}=a_{i_1i_2}\cdotsa_{i_ki_1}\)</span>。如果我们能够使得每个 <span class="math inline">\(a_{C_i}=-1\)</span>，那么就有 <span class="math display">\[\text{sgn}(\sigma)\cdot a_\sigma = (-1)^l\cdot(-1)^l=1.\]</span> 怎么才能让 <span class="math inline">\(a_{C_i}\)</span> 都等于 -1 呢？注意 <span class="math inline">\(a_{C_i}\)</span> 不等于 0 说明 <span class="math inline">\(i_1\to i_2\to\cdots\to i_k\to i_1\)</span> 是<span class="math inline">\(\overrightarrow{G}\)</span>中的一个回路。又注意 <span class="math inline">\(\sigma\)</span>的每个轮换的长度都是偶数，所以 <span class="math inline">\(k\)</span>是偶数，即回路的长度是偶数。要使得 <span class="math inline">\(a_{C_i}\)</span> 等于 -1，我们需要 <span class="math inline">\(\{a_{i_1i_2},\ldots,a_{i_ki_1}\}\)</span> 中 -1出现的次数是奇数。换句话说，当在 <span class="math inline">\(\overrightarrow{G}\)</span> 中沿着回路 <span class="math display">\[i_1\rightarrow i_2\rightarrow \cdots \rightarrowi_k\rightarrow i_1\]</span> 绕 <span class="math inline">\(C_i\)</span>一圈时，有奇数条边在 <span class="math inline">\(\overrightarrow{G}\)</span>中的定向与行走方向一致，当然也就有奇数条边的定向与行走方向相反。</p><div class="unnumbered statement definition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定义</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(G\)</span> 是有限图。如果 <span class="math inline">\(G\)</span> 的一个回路 <span class="math inline">\(C\)</span> 的长度是偶数，且删除 <span class="math inline">\(C\)</span> 后剩下的部分仍然存在匹配，就称 <span class="math inline">\(C\)</span> 是一个好的回路。如果 <span class="math inline">\(G\)</span> 的一个定向 <span class="math inline">\(\overrightarrow{G}\)</span> 使得 <span class="math inline">\(G\)</span>的所有好的回路都是奇定向的，即沿着回路的任一方向行走都有奇数条边的定向与行走方向一致，就称<span class="math inline">\(\overrightarrow{G}\)</span> 是一个 Pfaffian定向。</p></div><p>对一般的图，找到其 Pfaffian定向是困难的事，但是对平面图却很简单。这就是下面的定理：</p><div id="Kasteleyn" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span> <span class="statement-info">(Kasteleyn)</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(G\)</span>是一个简单平面图，则可以给 <span class="math inline">\(G\)</span>的边适当定向，使得当逆时针沿着 <span class="math inline">\(G\)</span>的每个面行走时（外部的无穷区域不算），都有奇数条边与行走方向一致，这种定向就是<span class="math inline">\(G\)</span> 的 Pfaffian 定向。</p></div><p><strong>证明</strong>：我们首先说明存在这样的定向，使得 <span class="math inline">\(G\)</span>的每个面都是奇定向的。对面的个数归纳：<span class="math inline">\(f=0\)</span>，则 <span class="math inline">\(G\)</span> 是一个树，任何定向都是 Pfaffian定向。设结论对有 <span class="math inline">\(f-1\)</span>个面的简单有向图成立，对有 <span class="math inline">\(f&gt;1\)</span>个面的图 <span class="math inline">\(G\)</span>，找到一条内部面与外部区域相邻的边 <span class="math inline">\(e\)</span>，删去 <span class="math inline">\(e\)</span> 得到的是一个有 <span class="math inline">\(f-1\)</span>个面的有向图，由归纳假设，可以让每个面都是奇定向，然后把 <span class="math inline">\(e\)</span> 补回去，并适当在 <span class="math inline">\(e\)</span>的两种可能的定向中选择一个使得最后这个面也是奇定向的即可。</p><p>其次我们要说明这样的定向是 Pfaffian 定向，即对 <span class="math inline">\(G\)</span> 中任意好的回路 <span class="math inline">\(C\)</span>，当绕着 <span class="math inline">\(C\)</span>的内部逆时针行走一圈时，有奇数条边的定向与行走方向一致。</p><p>设 <span class="math inline">\(C\)</span> 长度为 <span class="math inline">\(l\)</span>，<span class="math inline">\(C\)</span>内部有 <span class="math inline">\(p\)</span> 个顶点，<span class="math inline">\(q\)</span> 条边，<span class="math inline">\(r\)</span> 个面，<span class="math inline">\(C\)</span> 上逆时针定向的边的个数为 <span class="math inline">\(c\)</span>，内部的第 <span class="math inline">\(i\)</span> 个面 (<span class="math inline">\(1\leqi\leq r\)</span>) 上逆时针定向的边的个数为 <span class="math inline">\(c_i\)</span>。</p><p>绕着所有面都逆时针走一圈，遇到的与行走方向定向相同的边的个数是 <span class="math inline">\(\sum\limits_{i=1}^rc_i=c+q\)</span>，这是因为<span class="math inline">\(C\)</span> 内部的 <span class="math inline">\(q\)</span>条边都被走了两次，一次逆时针，一次顺时针，因此都被计算了一次；而 <span class="math inline">\(C\)</span> 上的边只有逆时针定向的那些边（一共有<span class="math inline">\(c\)</span> 条）被计算了一次。</p><p>由于每个 <span class="math inline">\(c_i\)</span> 都是奇数，因此<span class="math display">\[r\equiv c+q\ (\text{mod}\ 2).\]</span></p><p>另一方面对 <span class="math inline">\(C\)</span> 包含的区域用 Euler定理，得到 <span class="math display">\[(p+l)-(q+l)+r=1.\]</span> 从而<span class="math inline">\(p\)</span> 与 <span class="math inline">\(c\)</span> 奇偶性相反，但是 <span class="math inline">\(p\)</span> 是偶数，这是因为删去 <span class="math inline">\(C\)</span> 以后仍然存在匹配说明 <span class="math inline">\(C\)</span> 的内部和外部各有偶数个顶点，因此 <span class="math inline">\(c\)</span> 是奇数，这就证明了定理。</p><h1 id="棋盘的多米诺骨牌密铺的计数">棋盘的多米诺骨牌密铺的计数</h1><p>回到文章开始的问题。</p><p>设棋盘的大小为 <span class="math inline">\(m\times n\)</span>，<span class="math inline">\(m\)</span> 是行数。这里 <span class="math inline">\(m,n\)</span>必须至少有一个是偶数，我们这里假定列数 <span class="math inline">\(n\)</span> 是偶数。</p><p>把棋盘的每个方格看作图 <span class="math inline">\(G\)</span>的顶点，两个方格对应的顶点 <span class="math inline">\(u,v\)</span> 在<span class="math inline">\(G\)</span>中相邻当且仅当它们有公共的边，这样就得到一个有 <span class="math inline">\(mn\)</span> 个顶点的平面图。棋盘的多米诺密铺与<span class="math inline">\(G\)</span>的完美匹配是一一对应的：密铺中的每个骨牌恰好盖住两个相邻的方格，这两个方格匹配在了一起。</p><p>为了求出 <span class="math inline">\(G\)</span>的完美匹配个数，只要标记出 <span class="math inline">\(G\)</span> 的一个Pfaffian 定向，写出对应的邻接矩阵，然后求出行列式，再开平方即可。</p><p>Pfaffian 定向是很容易找的，如下图所示：</p><p><img style="margin:0px auto;display:block" src="/images/pfaff/pfaff.svg" width="300"></p><p>下一步是写出这个定向图的邻接矩阵。我们按照从第一行开始，每一行从左到右的顺序给顶点排序。设<span class="math display">\[B_n=\begin{pmatrix}0&amp;1&amp;0&amp;&amp;\\-1&amp;0&amp;1&amp;&amp;\\&amp;-1&amp;0&amp;1&amp;\\&amp;&amp;&amp;\ddots&amp;1\\&amp;&amp;&amp;-1&amp;0\end{pmatrix}_{n\timesn}.\]</span> 则邻接矩阵为 <span class="math display">\[L(m,n)=\begin{pmatrix}B_n&amp;I_n&amp;&amp;&amp;\\-I_n&amp;-B_n&amp;I_n&amp;&amp;\\&amp;-I_n&amp;B_n&amp;&amp;\\&amp;&amp;&amp;\ddots&amp;I_n\\&amp;&amp;&amp;-I_n&amp;(-1)^{m-1}B_n\end{pmatrix}_{m\timesm}.\]</span></p><p>我把求邻接矩阵的详细过程放在后面的附录中。下面先来求 <span class="math inline">\(L(m,n)\)</span> 的行列式。</p><p>适当给 <span class="math inline">\(L(m,n)\)</span>的行列变号，可以得到 <span class="math display">\[\det L(m,n)=\det(B_n\otimes I_m-I_n\otimes C_m).\]</span> 其中 <span class="math display">\[C_m=\begin{pmatrix}0&amp;1&amp;0&amp;&amp;\\1&amp;0&amp;1&amp;&amp;\\&amp;1&amp;0&amp;1&amp;\\&amp;&amp;&amp;\ddots&amp;1\\&amp;&amp;&amp;1&amp;0\end{pmatrix}_{m\timesm}.\]</span> 这个变号步骤并不显然，我们需要选择 <span class="math inline">\(L(m,n)\)</span> 的一些行列变号，使得对角线上的每个<span class="math inline">\(-B_n\)</span> 所在的行列恰好有一次变号，每个<span class="math inline">\(B_n\)</span>所在的行列要变号两次，要么不变。具体规则是这样的：由于 <span class="math inline">\(-B_n\)</span> 出现在 <span class="math inline">\(L(m,n)\)</span> 对角线上的 <span class="math inline">\(2,4,6,\ldots,\)</span> 位置上，我们选择：</p><ol type="1"><li>将所有形如 <span class="math inline">\(4k+2\)</span>的<strong>列</strong>变号；</li><li>将所有形如 <span class="math inline">\(4k\)</span>的<strong>行</strong>变号；</li><li>将所有形如 <span class="math inline">\(4k+3\)</span>的<strong>行和列</strong>同时变号；</li></ol><p>这样显然可以把对角线上都变成 <span class="math inline">\(B_n\)</span>。对每个位于次对角线上 <span class="math inline">\((i-1, i)\)</span> 位置的 <span class="math inline">\(I_n\)</span>，</p><ul><li>如果 <span class="math inline">\(i=4k+2\)</span>，则 <span class="math inline">\((i-1,i)=(4k+1, 4k+2)\)</span>，根据 1它改变了一次符号；</li><li>如果 <span class="math inline">\(i=4k\)</span>，则 <span class="math inline">\((i-1,i)=(4k-1, 4k)\)</span>，根据 2, 3它改变了三次符号；</li><li>如果 <span class="math inline">\(i=4k+1\)</span>，则 <span class="math inline">\((i-1,i)=(4k, 4k+1)\)</span>，根据 2它改变了一次符号；</li><li>如果 <span class="math inline">\(i=4k+3\)</span>，则 <span class="math inline">\((i-1,i)=(4k+2, 4k+3)\)</span>，根据 1, 3它改变了三次符号。</li></ul><p>总之 <span class="math inline">\(I_n\)</span> 都会变成 <span class="math inline">\(-I_n\)</span>。类似地所有 <span class="math inline">\(-I_n\)</span> 均保持不变。</p><p>剩下的就是线性代数中求特征值的部分，需要一些关于矩阵张量积的知识，这里就不展开写了，大致逻辑是这样的：设<span class="math inline">\(B_n\)</span> 的特征值为 <span class="math inline">\(\lambda_1,\ldots,\lambda_n\)</span>，<span class="math inline">\(C_m\)</span> 的特征值为 <span class="math inline">\(\mu_1,\ldots,\mu_m\)</span>，则 <span class="math inline">\(B_n\otimes I_m- I_n\otimes C_m\)</span> 的 <span class="math inline">\(mn\)</span> 个特征值为 <span class="math inline">\(\{\lambda_i-\mu_j, 1\leq i\leq n, 1\leq j\leqm\}\)</span>，所以 <span class="math display">\[\det(B_n\otimes I_m-I_n\otimes C_m) = \prod_{i=1}^n\prod_{j=1}^m(\lambda_i-\mu_j).\]</span><span class="math inline">\(B_n\)</span> 和 <span class="math inline">\(C_m\)</span>的特征值的计算应该是线性代数课程中行列式部分的常见的习题，我把具体的计算步骤放在附录中，最终结果是<span class="math display">\[\sqrt{|\det L(m,n)|}=\prod_{k=1}^m\prod_{l=1}^n(4\cos^2\frac{k\pi}{m+1}+4\cos^2\frac{l\pi}{n+1})^{\frac{1}{4}}.\]</span>此即为要求的完美匹配的个数。</p><h1 id="未尽的讨论">未尽的讨论</h1><p>我们已经得到了一个关于 <span class="math inline">\(m\times n\)</span>棋盘的多米诺骨牌密铺的漂亮的表达式，事情可以结束了吗？其实还没有，这个表达式虽然很漂亮，但是我们没法用它来具体计算匹配个数的值（一堆三角函数的乘积怎么算？）。那应该怎么办呢？我把后面的故事留给<span class="citation" data-cites="aigner07">(<a href="#ref-aigner07" role="doc-biblioref">Aigner 2007, sec. 10.1</a>)</span>。</p><h1 id="附录">附录</h1><h2 id="求邻接矩阵-lmn-的具体步骤">求邻接矩阵 <span class="math inline">\(L(m,n)\)</span> 的具体步骤</h2><p>将 <span class="math inline">\(L(m,n)\)</span> 简写为 <span class="math inline">\(L=L(m,n)\)</span>。把网格图 <span class="math inline">\(G\)</span> 的顶点标记如下：</p><p><span class="math display">\[\begin{matrix}(1,1)&amp;(1,2)&amp;\cdots&amp;(1,n)\\(2,1)&amp;(2,2)&amp;\cdots&amp;(2,n)\\\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\(m,1)&amp;(m,2)&amp;\cdots&amp;(m, n)\end{matrix}\]</span></p><p>对这些顶点排序，首先是第一行从左到右，然后是第二行从左到右，等等：<span class="math display">\[(1,1)&lt;(1,2)&lt;\cdots&lt;(1,n)&lt;(2,1)&lt;\cdots&lt;(2,n)&lt;\cdots&lt;(m,1)&lt;\cdots&lt;(m,n).\]</span></p><p><span class="math inline">\(L\)</span> 是 <span class="math inline">\(mn\times mn\)</span> 阶矩阵，它的行和列分别由<span class="math inline">\((i,j)_{\begin{smallmatrix}1\leq i\leqm\\1\leq j\leq n\end{smallmatrix}}\)</span> 和 <span class="math inline">\((i',j')_{\begin{smallmatrix}1\leqi'\leq m\\1\leq j'\leq n\end{smallmatrix}}\)</span> 标记。<span class="math inline">\(L\)</span> 可以划分成 <span class="math inline">\(m\times m\)</span> 个子块，每个子块是 <span class="math inline">\(n\times n\)</span> 阶的，其中位于 <span class="math inline">\((i,i')\)</span> 处的子块对应的矩阵是 <span class="math inline">\((L_{(i,j)(i',j')})_{1\leq j,j'\leqn}\)</span>： <span class="math display">\[\begin{array}{c|c|c}&amp;(i',1), \cdots,(i',j'),\cdots, (i',n)&amp;\\ &amp;\hline&amp;\qquad\\(i,1)&amp;&amp;\\\vdots&amp;&amp;\\(i,j)&amp;\ast&amp;\\\vdots&amp;&amp;\\(i,n)&amp;&amp;\\&amp;\hline&amp;\qquad\\ &amp;&amp;\end{array}\]</span></p><p>注意到 <span class="math inline">\((i,j)\)</span> 和 <span class="math inline">\((i',j')\)</span>之间有边相连当且仅当：</p><ol type="1"><li><span class="math inline">\(i=i'\)</span> 且 <span class="math inline">\(j'=j\pm1\)</span>；</li><li><span class="math inline">\(i'=i\pm1\)</span> 且 <span class="math inline">\(j=j'\)</span>。</li></ol><p>这说明 <span class="math inline">\(L\)</span>在除去对角线以及两侧的次对角线以外的位置都是 0。</p><p>在情形 1 中，由于水平的边（红色和绿色）是交替改变方向的，所以 <span class="math display">\[L_{(i,j)(i,j+1)} = (-1)^{i-1} \text{ for } 1\leqi\leq m \text{ and } 1\leq j\leq n-1.\]</span> 这说明 <span class="math inline">\(L\)</span> 对角线上的第 <span class="math inline">\(i\)</span> 个子块是 <span class="math inline">\((-1)^{i-1}B_n\)</span>，其中 <span class="math display">\[B_n=\begin{pmatrix}0&amp;1&amp;0&amp;&amp;\\-1&amp;0&amp;1&amp;&amp;\\&amp;-1&amp;0&amp;1&amp;\\&amp;&amp;&amp;\ddots&amp;1\\&amp;&amp;&amp;-1&amp;0\end{pmatrix}_{n\timesn}.\]</span> 即 <span class="math inline">\(L\)</span> 形如 <span class="math display">\[\begin{pmatrix}B_n &amp;\ast&amp;&amp;&amp;\\\ast&amp; -B_n &amp;\ast&amp;&amp;\\&amp;\ast&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\ddots&amp;\ddots&amp; \ast\\&amp;&amp;&amp;\ast&amp;(-1)^{m-1}B_n\end{pmatrix}.\]</span> 在情形 2中，由于竖直的边（蓝色）是恒定向下的，所以 <span class="math display">\[L_{(i,j),(i+1,j)}  = 1  \text{ for } 1\leq i\leqm-1 \text{ and } 1\leq j\leq n.\]</span> 这说明 <span class="math inline">\(L\)</span> 右上方次对角线上的 <span class="math inline">\((i,i+1)\)</span> 位置的子块都是 <span class="math inline">\(I_n\)</span>。再结合 <span class="math inline">\(L\)</span> 是反对称的，下方次对角线上都是 <span class="math inline">\(-I_n\)</span>，所以 <span class="math inline">\(L\)</span> 形如 <span class="math display">\[\begin{pmatrix}B_n &amp;I_n&amp;&amp;&amp;\\-I_n&amp; -B_n &amp;I_n&amp;&amp;\\&amp;-I_n&amp;\ddots&amp;\ddots&amp;\\&amp;&amp;\ddots&amp;\ddots&amp; I_n\\&amp;&amp;&amp;-I_n&amp;(-1)^{m-1}B_n\end{pmatrix}.\]</span></p><p>此即为 <span class="math inline">\(G\)</span> 的邻接矩阵。</p><h2 id="求-b_n-和-c_m-的特征值">求 <span class="math inline">\(B_n\)</span> 和 <span class="math inline">\(C_m\)</span> 的特征值</h2><p>我们以 <span class="math display">\[C_m=\begin{pmatrix}0&amp;1&amp;0&amp;&amp;\\1&amp;0&amp;1&amp;&amp;\\&amp;1&amp;0&amp;1&amp;\\&amp;&amp;&amp;\ddots&amp;1\\&amp;&amp;&amp;1&amp;0\end{pmatrix}.\]</span>为例来说明怎样求它的特征值，<span class="math inline">\(B_n\)</span>的求解是类似的。</p><p>我们需要求出其特征多项式</p><p><span class="math display">\[f_m(\lambda) =\det\begin{pmatrix}\lambda&amp;-1&amp;0&amp;&amp;\\-1&amp;\lambda&amp;-1&amp;&amp;\\&amp;-1&amp;\lambda&amp;-1&amp;\\&amp;&amp;&amp;\ddots&amp;-1\\&amp;&amp;&amp;-1&amp;\lambda\end{pmatrix}.\]</span></p><p>按第一行展开可得递推关系</p><p><span class="math display">\[f_m = \lambda f_{m-1} -f_{m-2},\]</span></p><p>结合初始条件 <span class="math inline">\(f_0=1, f_1=\lambda\)</span>（初始条件可以从 <span class="math inline">\(m=2\)</span>的情形展开确定） 可得</p><p><span class="math display">\[f_m(\lambda) =\frac{1}{\sqrt{\lambda^2-4}}\left[\left(\frac{\lambda+\sqrt{\lambda^2-4}}{2}\right)^{m+1}-\left(\frac{\lambda-\sqrt{\lambda^2-4}}{2}\right)^{m+1}\right].\]</span></p><p>由此不难确定 <span class="math inline">\(C_m\)</span> 的 <span class="math inline">\(m\)</span> 个特征值为 <span class="math inline">\(2\cos\dfrac{k\pi}{m+1},k=1,\ldots,m.\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-aigner07" class="csl-entry" role="listitem">Aigner, M. 2007. <em>A Course in Enumeration</em>. Graduate Texts inMathematics. Springer Berlin Heidelberg.</div></div><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>提示：从任一顶点 <span class="math inline">\(x\)</span>出发沿着红边到达顶点 <span class="math inline">\(y\)</span>，再从 <span class="math inline">\(y\)</span> 出发沿着蓝边到达顶点 <span class="math inline">\(z\)</span>，再从 <span class="math inline">\(z\)</span> 出发沿着红边到达顶点 <span class="math inline">\(w\)</span>，这样一直继续下去肯定会回到某个访问过的点，从而形成一个回路。拿掉这个回路以后剩下的图每个顶点的度数仍然是偶数，所以可以继续重复这个过程。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
      
      <categories>
          
          <category> 计数组合学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>平面分拆的 Macmahon 公式</title>
      <link href="macmahon-formula-plane-partitions/"/>
      <url>macmahon-formula-plane-partitions/</url>
      
        <content type="html"><![CDATA[<div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>一个边长为 <span class="math inline">\(a\times b\times c\)</span> 的平行六边形（<span class="math inline">\(a,b,c\)</span> 都是正整数），每个内角都是 120度。用边长为 1 的菱形密铺，有多少种不同的方法？</p><p><img style="margin:0px auto;display:block" width="400" src="/images/macmahon/hexagon.svg"></p></div><p>下图是一种密铺的示例：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/macmahon/planepartition.svg"></p><span id="more"></span><p>我们观察这张图，想象在空间中鸟瞰它，发现它很像是在墙角“堆箱子”。不仅如此，箱子的堆放方式还满足规律：从墙角开始，沿着两侧墙壁的方向，箱子的高度是递减的。我们把地面上第<span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 列位置箱子的高度 <span class="math inline">\(a_{ij}\)</span> 填写在一个 <span class="math inline">\(a\)</span> 行 <span class="math inline">\(b\)</span> 列的矩阵 <span class="math inline">\(A\)</span> 中（习惯上空白位置的 0 不写出来）：</p><table><tbody><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">3</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p><span class="math inline">\(A\)</span> 有如下特点：</p><blockquote><ul><li><span class="math inline">\(A\)</span>的每一行从左到右，每一列从上到下都是递减的。</li><li><span class="math inline">\(a_{ij}\)</span> 都是介于 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(c\)</span>之间的整数（箱子的高度不能超过天花板的高度 <span class="math inline">\(c\)</span>）。</li></ul></blockquote><p>我们把矩阵 <span class="math inline">\(A\)</span> 叫做一个参数为<span class="math inline">\((a,b,c)\)</span>的受限制的<strong>平面分拆</strong>。</p><p>每个受限制的平面分拆都对应一种堆箱子的方式，从而对应六边形的一个菱形密铺。这个对应是一一的。较真的读者可能会说：“且慢，你这只是从视觉直观上看出来菱形密铺和堆箱子是一一对应的，这不够严格吧？”没错，严格的证明是可以有的，但是这里我们的目的是欣赏一处数学奇趣，不必搞得那么学究。</p><p>总之，我们把开头的密铺问题转化为平面分拆的计数问题：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>满足如下两个条件的 <span class="math inline">\(a\)</span> 行 <span class="math inline">\(b\)</span> 列矩阵有多少个？</p><ol type="1"><li>元素都是 <span class="math inline">\([0,c]\)</span>之间的非负整数；</li><li>每一行从左到右，每一列从上到下都是递减的。</li></ol></div><p>设答案为 <span class="math inline">\(M(a,b,c)\)</span>，则我们有一个非常令人吃惊的表达式：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>（<strong>Macmahon 公式</strong>）</p><p><span class="math display">\[M(a,b,c)=\prod_{i=1}^a\prod_{j=1}^b\prod_{k=1}^c\frac{i+j+k-1}{i+j+k-2}.\]</span></p></div><p>虽然问题看起来很初等，但是答案的复杂暗示我们它并不像看起来那么容易。接下来你会看到，用一个巧妙的方法可以把问题转化为求一个行列式的值。</p><h1 id="不相交的路径组">不相交的路径组</h1><p>我们知道在平面上从原点 <span class="math inline">\((0,0)\)</span>出发，每次向右或者向上移动一个单位的距离，到达点 <span class="math inline">\((b,a)\)</span> 的路径个数是组合数 <span class="math inline">\(\binom{a+b}{b}\)</span>，这样的一条路径叫做 Gauss路径。</p><p>每个平面分拆的矩阵 <span class="math inline">\(A\)</span> 都对应<span class="math inline">\(c\)</span> 条这样的路径，其中第 <span class="math inline">\(k\)</span> 条路径是高度为 <span class="math inline">\(k\,(1\leq k\leq c)\)</span>的那一层的“等高线”：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/macmahon/paths-on-cubes.svg"></p><p>我们把这些路径投影到 2D，和矩阵 <span class="math inline">\(A\)</span> 画在一起。从最下方的路径开始，第 <span class="math inline">\(i\)</span> 条路径对应的是矩阵中 <span class="math inline">\(\geq i\)</span> 的那些方格构成的区域的边界：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/macmahon/gauss_path.svg"></p><p>注意 <span class="math inline">\(A\)</span>的行和列满足递降关系，这个递降关系反映在这 <span class="math inline">\(c\)</span>条路径上就是，对任何两条路径，它们可以有接触点或者重合的边，但彼此不能穿过对方。</p><p>接下来是关键的一步：如果把这 <span class="math inline">\(c\)</span>条路径沿着 <span class="math inline">\((-1,1)\)</span> 方向，分别平移<span class="math inline">\(0,1,\ldots,c-1\)</span> 个单位，则平移后的<span class="math inline">\(c\)</span>条路径两两之间将没有任何公共点。我们称之为一个不相交的路径组。如下图所示：</p><p><img style="margin:0px auto;display:block" width="600" src="/images/macmahon/nonintersecting_paths.gif"></p><p>这里 <span class="math inline">\(A_i=(1-i,i-1)\)</span>，<span class="math inline">\(B_j=(b+1-j,a-1+j)\)</span>，<span class="math inline">\(\{p_i:A_i\rightarrow B_i,1\leq i\leq c\}\)</span>是一个不相交的路径组。反过来对每一个这样的不相交的路径组，我们也很容易还原出对应的平面分拆来。</p><p>于是我们的问题又进一步转化为</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>设 <span class="math display">\[\{A_i=(1-i,i-1) ,\, 1\leq i\leq c\}\]</span> 和<span class="math display">\[\{B_j=(b+1-j,a-1+j),\, 1\leq j\leqc\}\]</span> 是平面上两组顶点集，求出所有不相交的路径组 <span class="math inline">\(\mathcal{P}=\{p_i,1\leq i\leq c\}\)</span>的数目，其中 <span class="math inline">\(p_i\)</span> 是从 <span class="math inline">\(A_i\)</span> 出发到 <span class="math inline">\(B_i\)</span> 的 Gauss 路径。</p></div><h1 id="gessel-viennot-的巧妙方法">Gessel-Viennot 的巧妙方法</h1><p>考虑这样一个 <span class="math inline">\(c\times c\)</span> 的矩阵<span class="math inline">\(M\)</span>，其元素 <span class="math inline">\(m_{ij}\)</span> 是从点 <span class="math inline">\(A_i\)</span> 出发到达点 <span class="math inline">\(B_j\)</span> 的所有 Gauss 路径的数目。由于点 <span class="math inline">\(A_i\)</span> 坐标为 <span class="math inline">\((1-i,i-1)\)</span>，点 <span class="math inline">\(B_j\)</span> 坐标为 <span class="math inline">\((b+1-j,a-1+j)\)</span>，不难得到 <span class="math inline">\(m_{ij}=\binom{a+b}{b+i-j}\)</span>，这里如果 <span class="math inline">\(b+i-j&lt;0\)</span> 则 <span class="math inline">\(\binom{a+b}{b+i-j}=0\)</span>。Gessel-Viennot引理非常意外地告诉我们：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>（<strong>Gessel-Viennot 引理</strong>）</p><p>记 <span class="math inline">\(\mathcal{A}=\{A_i,1\leq i\leqc\}\)</span> 和 <span class="math inline">\(\mathcal{B}=\{B_j,1\leqj\leq c\}\)</span> 是如上所述的两个顶点集合，对 <span class="math inline">\(c\)</span> 元组上的任一置换 <span class="math inline">\(\sigma\)</span>，记 <span class="math inline">\(\mathcal{P}_\sigma=\{p_i:A_i\toB_{\sigma(i)}\}\)</span> 为一个路径组。如果只有对 <span class="math inline">\(\sigma=1\)</span> 时 <span class="math inline">\(P_\sigma\)</span>之间的路径才有可能互不相交，则这样的不相交路径组的个数恰好为 <span class="math display">\[\det M=\det_{1\leq i,j\leqc}\left(\left(\begin{array}{c}a+b\\b+i-j\end{array}\right)\right).\]</span></p></div><p>Gessel-Viennot引理对更一般的带权的图也成立，它在许多组合问题中都有精彩的应用。关于这方面可以参看<span class="citation" data-cites="thebook">(<a href="#ref-thebook" role="doc-biblioref">Aigner and Ziegler 2018</a>)</span>。</p><p><strong>证明</strong>：把 <span class="math inline">\(\det M\)</span>按照行列式的定义展开：</p><p><span class="math display">\[\begin{aligned}\detM&amp;=\sum_{\sigma}\text{sgn}(\sigma)m_{1\sigma(1)}\cdotsm_{c\sigma(c)}\\&amp;=\sum_{\sigma}\text{sgn}(\sigma)\left(\sum_{p_1:A_1\toB_{\sigma(1)}}1\right)\cdots\left(\sum_{p_c:A_c\toB_{\sigma(c)}}1\right).\end{aligned}\]</span></p><p>其中 <span class="math inline">\(\sigma\)</span> 跑遍对称群 <span class="math inline">\(S_c\)</span> 的所有置换。取出其中的一项</p><p><span class="math display">\[\left(\sum_{p_1:A_1\toB_{\sigma(1)}}1\right)\cdots\left(\sum_{p_c:A_c\toB_{\sigma(c)}}1\right),\]</span></p><p>把它展开得到很多个 1，每个 1 对应一个路径组 <span class="math inline">\(\mathcal{P}_\sigma=\{p_i:A_i\rightarrowB_{\sigma(i)},1\leq i\leq c\}\)</span>，因此</p><p><span class="math display">\[\detM=\sum_{\sigma,\mathcal{P}_\sigma}\text{sgn}(\sigma).\]</span></p><p>这个求和是对每个置换 <span class="math inline">\(\sigma\)</span>，跑遍所有可能的路径组 <span class="math inline">\(P_\sigma\)</span>。</p><p>我们来证明在上面的求和中，相交的路径组对应的项可以两两抵消，剩下的只有不相交的路径组。而根据条件，不相交的路径组只有在<span class="math inline">\(\sigma=1\)</span>时才可能发生（从图上可以很容易看出这个条件是满足的），这样就得到 <span class="math inline">\(\det M=\sum_{\mathcal{P}}1\)</span>，其中 <span class="math inline">\(\mathcal{P}\)</span> 只跑遍 <span class="math inline">\(\sigma=1\)</span>对应的不相交路径组，这就是所求的答案。</p><p>给定一个相交的路径组 <span class="math inline">\(\mathcal{P}\)</span>，我们构造与之抵消的路径组<span class="math inline">\(\mathcal{P}'\)</span> 如下：</p><ol type="1"><li>在 <span class="math inline">\(\mathcal{P}\)</span>的所有交点中，首先选择横坐标最大的那个，如果这样的交点有多个，就选择纵坐标最大的那个，将其记作<span class="math inline">\(C\)</span>。</li><li>在经过 <span class="math inline">\(C\)</span>的所有路径中，首先选择最大的 <span class="math inline">\(i\)</span> 使得<span class="math inline">\(p_i:A_i\rightarrow B_{\sigma(i)}\)</span>经过 <span class="math inline">\(C\)</span>，再选择最大的 <span class="math inline">\(j\ne i\)</span> 使得 <span class="math inline">\(p_j\)</span> 也经过 <span class="math inline">\(C\)</span>。</li><li>交换 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(p_j\)</span> 在 <span class="math inline">\(C\)</span>点之后的部分，保持路径组其它部分不动。记得到的新路径组为 <span class="math inline">\(\mathcal{P}'\)</span>。</li></ol><p>直观上，你可以想象两个人分别从 <span class="math inline">\(A_i\)</span> 和 <span class="math inline">\(A_j\)</span> 出发沿着路径 <span class="math inline">\(p_i\)</span> 和 <span class="math inline">\(p_j\)</span> 前往目的地 <span class="math inline">\(B_{\sigma(i)}\)</span> 和 <span class="math inline">\(B_{\sigma(j)}\)</span>。当他们到达 <span class="math inline">\(C\)</span>时改变路线，沿着对方剩下的路径前往对方的目的地。</p><p><img style="margin:0px auto;display:block" width="600" src="/images/macmahon/gessel_viennot.svg"></p><p>于是 <span class="math inline">\(\mathcal{P}'\)</span> 对应的置换<span class="math inline">\(\sigma'\)</span> 与 <span class="math inline">\(\mathcal{P}\)</span> 对应的置换 <span class="math inline">\(\sigma\)</span> 只差一个对换 <span class="math inline">\((ij)\)</span>，因此 <span class="math inline">\(\text{sgn}(\sigma')=-\text{sgn}(\sigma)\)</span>。更重要的是，如果对<span class="math inline">\(\mathcal{P}'\)</span>也进行上述操作的话，又会回到 <span class="math inline">\(\mathcal{P}\)</span>，因此相交的路径组确实可以两两配对抵消，这就证明了结论。</p><h1 id="dodgsons-condensation-method">Dodgson’s condensation method</h1><p>为了求出行列式的值，我们介绍一个古老的方法：Dodgson’scondensation。这是一个递归求解行列式的方法：设 <span class="math inline">\(A\)</span> 是一个 <span class="math inline">\(n\times n\)</span> 矩阵，用 <span class="math inline">\(A_i^j\)</span> 表示删去 <span class="math inline">\(A\)</span> 的第 <span class="math inline">\(i\)</span> 行和第 <span class="math inline">\(j\)</span> 列后剩下的 <span class="math inline">\(n-1\)</span> 阶矩阵，用 <span class="math inline">\(A_{1,n}^{1,n}\)</span> 表示删去 <span class="math inline">\(A\)</span> 的第 1 行第 1 列和第 <span class="math inline">\(n\)</span> 行第 <span class="math inline">\(n\)</span> 列后剩下的 <span class="math inline">\(n-2\)</span> 阶矩阵，则我们有恒等式</p><p><span class="math display">\[\det A\cdot \det A_{1,n}^{1,n}=\detA_1^1\det A_n^n-\det A_1^n\det A_n^1.\]</span></p><p>用一个形象的图片描述：</p><p><img style="margin:0px auto;display:block" width="450" src="/images/macmahon/dodgson.svg"></p><p>这个结论的证明不难，可以见 <a href="http://en.wikipedia.org/wiki/Dodgson_condensation">维基百科</a>，这里就不再写了。</p><p>我们对 <span class="math inline">\(c\)</span> 归纳来证明</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>（<strong>Macmahon 公式</strong>）</p><p><span class="math display">\[\det_{1\leq i,j\leqc}\left(\left(\begin{array}{c}a+b\\b+i-j\end{array}\right)\right)=\prod_{i=1}^a\prod_{j=1}^b\prod_{k=1}^c\frac{i+j+k-1}{i+j+k-2}.\]</span></p></div><p>首先你需要对 <span class="math inline">\(c=1\)</span> 和 <span class="math inline">\(c=2\)</span> 的情形手算验证（略繁琐，不过只是一个2 阶矩阵），设 <span class="math inline">\(M_c(a, b)\)</span>为所求的行列式，注意到</p><p><span class="math display">\[\begin{cases}(M_c(a,b))_1^1=M_{c-1}(a,b),\\(M_c(a,b))_n^n=M_{c-1}(a,b),\\(M_c(a,b))_1^n=M_{c-1}(a-1,b+1),\\(M_c(a,b))_n^1=M_{c-1}(a+1,b-1),\\(M_c(a,b))^{1,n}_{1,n}=M_{c-2}(a,b).\end{cases}\]</span></p><p>然后应用归纳假设即可。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>问题的 <span class="math inline">\(q-\)</span> 计数版本也可以用Gessel-Viennot 引理来做，只是行列式的求值略复杂。其实也可以用 <a href="https://arxiv.org/abs/math/9902004">Krattenthaler 公式</a>来计算，不过那个方法不是我们要讲的。</p></div><h1 id="番外话">番外话</h1><p>说点八卦的东西。Dodgson 是 19世纪英国牛津大学的数学教授，细心点的读者可能注意到这位老兄的名字实在让人不敢恭维：Dodgson，dog..son？大概他也知道自己的名字难登大雅之堂，所以他给自己取了一个很好听的笔名：LewisCarroll（路易斯·卡罗尔）。</p><p>你对这个名字没有反应么？那好，我们继续说说他的轶事。这位老兄虽然名字略俗，受过的教育可不含糊，是牛津大学的数学教授，也算上层社会体面人物，但是按照今天的话说，是个不折不扣的怪蜀黍，对萝莉有着特别的喜爱，尤其喜爱给她们拍裸照，所以后人基本认定他是一个恋童癖大叔。他曾经专门为邻居家的女儿写了一部童话来哄她开心，这就是大名鼎鼎的《爱丽斯漫游奇境记》。虽然创作动机不纯，但是这部童话非常精彩，以至于当时的英国女王都变成了他的粉丝。女王命令手下的大臣把Dodgson的全部著作都搜集呈上来，于是大臣献上了一本厚厚的《符号逻辑》，当然结果你猜得到的…</p><p>时光一转到了 20 世纪 80 年代，三位数学家 William Mills，David Robbins和 Howard Rumsey 在研究计算行列式的快速数值算法时，受 Dodgson算法的启发，发现了交错符号矩阵猜想。这是计数组合学里面最精彩的猜想之一。我向你推荐Bressoud 的书 <span class="citation" data-cites="Bressoud1999">(<a href="#ref-Bressoud1999" role="doc-biblioref">Bressoud1999</a>)</span>，我保证里面的故事和《爱丽丝漫游奇境记》一样奇妙 …</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-thebook" class="csl-entry" role="listitem">Aigner, Martin, and Gnter M. Ziegler. 2018. <em>Proofs from THEBOOK</em>. 6th ed. Springer Publishing Company, Incorporated.</div><div id="ref-Bressoud1999" class="csl-entry" role="listitem">Bressoud, David M. 1999. <em>Proofs and Confirmations: The Story of theAlternating-Sign Matrix Conjecture</em>. Spectrum. Cambridge UniversityPress.</div></div>]]></content>
      
      
      <categories>
          
          <category> 计数组合学 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="about/index.html"/>
      <url>about/index.html</url>
      
        <content type="html"><![CDATA[<p>欢迎来到 <strong>赵亮</strong>的个人网站。这里记录了我的一些关于数学和编程方面的文章，它们大致可以分为三类：</p><ol type="1"><li>从通俗有趣的问题出发介绍它们背后的数学。</li><li>我写过的（自以为）有趣的开源项目。</li><li>一些念书时的笔记（非常枯燥）。</li></ol><p>由于个人水平不足，文中难免出现错误，还请读者不吝指正。</p><p>个人方面，以下信息也许对你了解我有帮助：</p><ol type="1"><li>80 后，已婚，有娃一只。</li><li>工作之余带娃、念数学、写代码。</li><li>喜欢听罗大佑/邓丽君/Beyond，最喜欢的电影有《肖申克的救赎》，《真实的谎言》，《谍影重重》。</li><li>郑渊洁和刘慈欣爱好者。</li></ol><p>博客使用 <a href="https://hexo.io/">hexo</a> 搭建，主题为 <a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism">raytaylorism</a>，我在其基础上做了一些修改，特此鸣谢作者。</p><p>文章是在 markdown 中书写的，用 <a href="https://pandoc.org/">Pandoc</a> 渲染，<a href="https://github.com/dialoa/statement">statement</a>生成自动编号的定理环境。</p><p>转载文章和图片注明出处即可。所有代码均采用 <a href="https://opensource.org/licenses/MIT">MIT LICENSE</a>。</p><hr><p>Below is a selection of blog posts translated from my Chineseposts:</p><ul><li><a href="/rouche-theorem">Walk the dog: winding number and Rouchétheorem</a></li><li><a href="/e8-and-coxeter-plane">The E8 picture explained throughcode</a></li><li><a href="/catacaustics">Catacaustics of a coffee cup</a></li><li><a href="/uniform-tilings">Coxeter groups, automata and uniformtilings</a></li><li><a href="/gifmaze">Make awesome gif animation in a few seconds withpure Python</a></li><li><a href="/polytopes">Todd-Coxeter algorithm and uniformpolytopes</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Catacaustics of a coffee cup</title>
      <link href="catacaustics/index.html"/>
      <url>catacaustics/index.html</url>
      
        <content type="html"><![CDATA[<p>I love reading the blogs of <a href="https://math.ucr.edu/home/baez/">John Baez</a> and <a href="https://gregegan.net/">Greg Egan</a>. John Baez is a very prolificmathematician in popular science, and he has written countless popularscience articles. Greg Egan is also a very prolific science fictionwriter from Australia. His blog articles are equally wonderful! However,unlike John Baez, Greg Egan’s articles do not tend to cater to readersof different levels. For me, understanding what he is saying is oftennot an easy task.</p><p>John Baez’s blog has a series called <a href="https://johncarlosbaez.wordpress.com/2012/08/31/rolling-circles-and-balls-part-1/">Rollingcircles and balls</a> that discussing the involute of a circle andcatacaustics. Greg Egan also has an <a href="#https://www.gregegan.net/SCIENCE/Catacaustics/Catacaustics.html">article</a>that delves deeper into the catacaustics of curves. This topic is veryinteresting, and I couldn’t resist the temptation to write some code,conduct experiments, and document them here.</p><h1 id="pov-ray-optical-experiment">POV-Ray Optical Experiment</h1><p>There is an interesting physical phenomenon. When light shines on theinner wall of a coffee cup, it reflects and forms a bright spot, calledcatacaustic.</p><p><img style="margin:0px auto;display:block" width="400" src="/images/caustics/cup.jpg"></p><p>The reason for the formation of the catacaustic is that after thelight is reflected on the inner wall of the cup, the distribution ofphotons is uneven, and some areas have a particularly high density ofphotons, resulting in higher brightness.</p><p>The catacaustic is a curve that is tangent to all reflected rays,meaning it is the envelope of all reflected rays. The specific shape ofcatacaustic depends on the shape of the cup and the position of thelight source. Assuming the cup is circular, when the light source is apoint source located exactly on the edge of the cup, the resultingcatacaustic is a <a href="#https://en.wikipedia.org/wiki/Cardioid">cardioid</a>. When thelight source is at infinity (can be considered as a parallel lightsource), the resulting catacaustic is a <a href="https://en.wikipedia.org/wiki/Nephroid">nephroid</a>. In general,the shape of the catacaustic lies between a cardioid and a nephroid.</p><p>What’s even more interesting is that if the shape of the cup is thecardioid curve, and the light source is positioned exactly at the cusp.The resulting catacaustic is exactly the nephroid. I wrote a <a href="#https://gist.github.com/neozhaoliang/15d0350450885b90c5efbc73ddcdbdde">POV-Rayscript</a> to simulate this phenomenon.</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr class="odd"><td style="text-align: center;">A cardioid catacaustic</td><td style="text-align: center;">A nephroid catacaustic</td></tr><tr class="even"><td style="text-align: center;"><img style="margin:0px auto;display:block" width="400" src="/images/caustics/caustics_cardioid.png"></td><td style="text-align: center;"><img style="margin:0px auto;display:block" width="400" src="/images/caustics/caustics_nephroid.png"></td></tr></tbody></table><p>It is worth noting that both the cardioid and the nephroid areso-called <a href="#https://en.wikipedia.org/wiki/Epicycloid">epicycloids</a>, withthe only difference being the ratio of the radii of the two circles.</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr class="odd"><td style="text-align: center;">Cardioid</td><td style="text-align: center;">Nephroid</td></tr><tr class="even"><td style="text-align: center;"><video src="/images/caustics/cardioid.mp4" controls=""></video></td><td style="text-align: center;"><video src="/images/caustics/nephroid.mp4" controls=""></video></td></tr></tbody></table><p>It seems that we can make the following conjecture: if we place alight source inside or at the cusp of a nephroid, will we obtain anotherepicycloid? However, according to Greg Egan’s experiment on his blog,this should not hold true.</p><p>In theory, this POV-Ray script can render the effect of any parametercurve reflection (you need to make some modifications yourself, such asadjusting the scale and light source position). However, renderingparametric surface + radiosity in POV-Ray is very slow. So if you wantto give it a try, it is best to use POV-Ray’s native CSG to constructthe specular curve.</p><h1 id="catacaustics-of-parametric-curves">Catacaustics of parametriccurves</h1><p>In this section, we will introduce how to calculate the catacausticof a general parameter curve <span class="math inline">\(\mathbf{c}(t)=(x(t),y(t))\)</span>。</p><p>If the position of the light source is <span class="math inline">\((a,b)\)</span>, then at a point <span class="math inline">\((x,y)\)</span> on the curve, the direction of theincident light ray is <span class="math display">\[\mathbf{l}=(x-a,y-b).\]</span> We don’t need tonormalize <span class="math inline">\(\mathbf{l}\)</span> because wewill only need the direction of the light ray and not its length.</p><p>At the same point <span class="math inline">\((x,y)\)</span>, thenormal vector of the curve is <span class="math display">\[\mathbf{n}=\frac{(-y',x')}{\sqrt{(x')^2+(y')^2}}=\frac{(-y',x')}{|\mathbf{c}'|}.\]</span></p><p>so the direction of the reflected ray at point <span class="math inline">\((x,y)\)</span> is given by the followingreflection formula: <span class="math display">\[\mathbf{r}= \mathbf{l}-2(\mathbf{l}\cdot \mathbf{n})\mathbf{n}.\]</span></p><p>Let <span class="math inline">\((X,Y)\)</span> be any point on thereflected ray, since <span class="math inline">\((x,y)\)</span> is thestarting point of the reflected ray, <span class="math inline">\((X-x,Y-y)\)</span> is parallel to <span class="math inline">\(\mathbf{r}\)</span>. Let <span class="math inline">\(\mathbf{r}=(r_x,r_y)\)</span>, then <span class="math inline">\((X-x,Y-y)\)</span> is perpendicular to <span class="math inline">\((-r_y, r_x)\)</span>, that is, <span class="math display">\[(X-x, Y-y)\cdot(-r_y, r_x)=0.\]</span> Let <span class="math display">\[F(X,Y,t)=(X-x, Y-y)\cdot(-r_y, r_x),\]</span>then we obtain the equation of the curve family satisfied by thereflected ray: <span class="math inline">\(F(X,Y,t)=0\)</span>.Therefore, the catacaustic, as the envelope of all reflected rays, canbe obtained by solving the system of equations <span class="math display">\[\begin{align*}F(X,Y,t)=0,\\\frac{\partialF}{\partial t}F(X,Y,t)=0.\end{align*}\]</span> that is, <span class="math display">\[\begin{align*}(X-x, Y-y)\cdot(-r_y,r_x)&amp;=0,\\-(x',y')\cdot(-r_y, r_x) +(X-x,Y-y)\cdot(-r_y', r_x') &amp;=0.\end{align*}\]</span> Andthen solving for <span class="math inline">\(X,Y\)</span>.</p><p>If you still remember the inverse formula of a 2x2 matrix, thesolution to this system of equations can actually be visually writtenout. Let’s rewrite it as</p><p><span class="math display">\[\begin{pmatrix}-r_y &amp; r_x\\-r_y'&amp;r_x'\end{pmatrix}\cdot\begin{pmatrix}X-x\\Y-y\end{pmatrix}=\begin{pmatrix}0\\r_xy'-r_yx'\end{pmatrix}.\]</span> So <span class="math display">\[\begin{align*}\begin{pmatrix}X-x\\Y-y\end{pmatrix}&amp;=\begin{pmatrix}-r_y&amp; r_x\\ -r_y'&amp;r_x'\end{pmatrix}^{-1}\begin{pmatrix}0\\r_xy'- r_yx'\end{pmatrix}\\&amp;=\frac{1}{r_xr_y'-r_yr_x'}\begin{pmatrix}r_x' &amp;-r_x\\ r_y'&amp;-r_y\end{pmatrix}\begin{pmatrix}0\\r_xy'-r_yx'\end{pmatrix}\\&amp;=\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\end{align*}\]</span> That is, <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix} +\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span></p><p>According to the deductions above, I wrote a small script tocalculate the catacaustic of a circle using <code>sympy</code>(version=1.12). The center of the circle is at the origin with a radiusof 1, and the light source is at <span class="math inline">\((1,0)\)</span>.</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>t, X, Y = symbols(<span class="hljs-string">"t X Y"</span>)<br>C = Matrix([cos(t), sin(t)]) <span class="hljs-comment"># curve</span><br>light = Matrix([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]) <span class="hljs-comment"># light source</span><br>l = C - light <span class="hljs-comment"># incident ray</span><br>dx, dy = diff(C, t)<br>n = Matrix([dy, -dx]) <span class="hljs-comment"># normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n)) <span class="hljs-comment"># reflected ray</span><br>F = (Y - y) * r[<span class="hljs-number">0</span>] - (X - x) * r[<span class="hljs-number">1</span>]<br>dF = diff(F, t)<br>result = solve((F, dF), X, Y) <span class="hljs-comment"># solve the envelope</span><br>print(<span class="hljs-string">f"X(t)=<span class="hljs-subst">{trigsimp(result[X], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br>print(<span class="hljs-string">f"Y(t)=<span class="hljs-subst">{trigsimp(result[Y], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br></code></pre></td></tr></tbody></table></figure><p>The result returned by <code>sympy</code> is:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X(t)=<span class="hljs-number">2</span>*cos(t)/<span class="hljs-number">3</span> + cos(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span><br>Y(t)=<span class="hljs-number">2</span>*sin(t)/<span class="hljs-number">3</span> + sin(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>This is exactly the parametric representation of the cardioid:</p><p><span class="math display">\[\left\{\begin{align*}x(t)&amp;=\frac{\cos(2t) +2\cos(t)}{3},\\ y(t)&amp;=\frac{\sin(2t) +2\sin(t)}{3}.\end{align*}\right.\]</span></p><p>Using this parameter, we continue to calculate the catacausticobtained when the light source is placed at the cusp of the cardioid,corresponding to point <span class="math inline">\((-\frac{1}{3},0)\)</span> when <span class="math inline">\(t=\pi\)</span>:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>t, X, Y = symbols(<span class="hljs-string">"t X Y"</span>)<br>C = Matrix([(<span class="hljs-number">2</span>*cos(t) + cos(<span class="hljs-number">2</span>*t)) / <span class="hljs-number">3</span>, (<span class="hljs-number">2</span>*sin(t) + sin(<span class="hljs-number">2</span>*t)) / <span class="hljs-number">3</span>])<br>light = Matrix([S(<span class="hljs-string">'-1/3'</span>, evaluate=<span class="hljs-literal">False</span>), <span class="hljs-number">0</span>])<br>l = C - light <span class="hljs-comment"># incident ray</span><br>dx, dy = diff(C, t)<br>n = Matrix([dy, -dx]) <span class="hljs-comment"># normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n)) <span class="hljs-comment"># reflected ray</span><br>F = (Y - y) * r[<span class="hljs-number">0</span>] - (X - x) * r[<span class="hljs-number">1</span>]<br>dF = diff(F, t)<br>result = solve((F, dF), X, Y) <span class="hljs-comment"># solve the envelope</span><br>print(<span class="hljs-string">f"X(t)=<span class="hljs-subst">{trigsimp(result[X], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br>print(<span class="hljs-string">f"Y(t)=<span class="hljs-subst">{trigsimp(result[Y], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> quickly calculated the correct result:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X(t)=sin(t)*sin(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span> + cos(t)/<span class="hljs-number">3</span><br>Y(t)=-sin(t)*cos(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span> + sin(t)/<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>It’s not difficult to verify</p><p><span class="math display">\[\begin{align*}\frac{\sin(t)\sin(2t) +\cos(t)}{3}&amp;=\frac{3\cos(t) - \cos(3t)}{6},\\ \frac{-\sin(t)\cos(2t)+ \sin(t)}{3}&amp;=\frac{3\sin(t) -\sin(3t)}{6}.\end{align*}\]</span></p><p>This is exactly the parametric form in the <a href="#https://en.wikipedia.org/wiki/Nephroid#Parametric">Wikipedia</a>page when <span class="math inline">\(a\)</span> is set to <span class="math inline">\(a=1/6\)</span>.</p><h1 id="catacaustics-of-polynomial-curves">Catacaustics of polynomialcurves</h1><p>Usually, the equation of a curve is given in the form of an implicitfunction <span class="math inline">\(P(x,y)=0\)</span>, where <span class="math inline">\(P\)</span> is a polynomial in two variables <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>. Such curves are called plane algebraiccurves. In this case, solving for the catacaustic requires the use oftools like Gröbner bases.</p><p>Let’s go back to the case of parametric equations. We have alreadyseen that in this case, the catacaustic <span class="math inline">\((X,Y)\)</span> has an explicit expression</p><p><span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix} +\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span></p><p>Where <span class="math inline">\(x,y,r_x,r_y\)</span> are functionsin one-variable <span class="math inline">\(t\)</span>，and theirderivatives are also computable, so <span class="math inline">\((X,Y)\)</span> can be computed.</p><p>However, in the case of implicit functions, we do not have anexpression for <span class="math inline">\(x,y\)</span> in terms of<span class="math inline">\(t\)</span>. But it’s okay, let’s assume thatthere is such a parameter expression and see what conclusions we candraw. Let <span class="math inline">\(x=x(t),y=y(t)\)</span> befunctions of some parameter <span class="math inline">\(t\)</span>, anddifferentiating both sides of <span class="math inline">\(P(x,y)=0\)</span> with respect to <span class="math inline">\(t\)</span> yields <span class="math display">\[\frac{\partial P}{\partial t}=\frac{\partialP}{\partial x}x'(t) + \frac{\partial P}{\partialy}y'(t)=0.\]</span> Let <span class="math inline">\(k=-\frac{\partial P}{\partial x}/\frac{\partialP}{\partial y}\)</span>, then <span class="math inline">\(y'(t)=kx'(t)\)</span>.</p><p>For the two components <span class="math inline">\((r_x,r_y)\)</span>of the reflected light <span class="math inline">\(\mathbf{r}\)</span>,we also use chain rule to differentiate them separately. We have <span class="math display">\[\begin{align*}\frac{\partial r_x}{\partialt}&amp;=\frac{\partial r_x}{\partial x}x'(t) + \frac{\partialr_x}{\partial y}y'(t),\\\frac{\partial r_y}{\partial t}&amp;=\frac{\partial r_y}{\partialx}x'(t) + \frac{\partial r_y}{\partialy}y'(t).\end{align*}\]</span> so we find that the ratio <span class="math display">\[\begin{align*}\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}&amp;=\frac{r_xk-r_y}{r_y(\frac{\partialr_x}{\partial x}+\frac{\partial r_x}{\partial y}k)-r_x(\frac{\partialr_y}{\partial x} + \frac{\partial r_y}{\partial y}k)}\\&amp;=-\frac{r_x\frac{\partial P}{\partial x}+r_y\frac{\partialP}{\partial y}}{r_y(\frac{\partial r_x}{\partial x}\frac{\partialP}{\partial y}-\frac{\partial r_x}{\partial y}\frac{\partial P}{\partialx})-r_x(\frac{\partial r_y}{\partial x}\frac{\partial P}{\partial y} -\frac{\partial r_y}{\partial y}\frac{\partial P}{\partialx})}.\end{align*}\]</span> becomes a quantity that does not explicitlydepend on <span class="math inline">\(t\)</span>, i.e., the variable<span class="math inline">\(t\)</span> “cancels out”. Substituting thisinto the expression for catacaustic above, we obtain <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix}-\frac{r_x\frac{\partialP}{\partial x}+r_y\frac{\partial P}{\partial y}}{r_y(\frac{\partialr_x}{\partial x}\frac{\partial P}{\partial y}-\frac{\partialr_x}{\partial y}\frac{\partial P}{\partial x})-r_x(\frac{\partialr_y}{\partial x}\frac{\partial P}{\partial y} - \frac{\partialr_y}{\partial y}\frac{\partial P}{\partial x})}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span> This equation can be further simplified:noting that the normal vector at point <span class="math inline">\((x,y)\)</span> is given by <span class="math inline">\(\mathbf{n}=\frac{\nabla P}{|\nabla P|}\)</span>,where <span class="math inline">\(\nabla P=(\frac{\partial P}{\partialx},\frac{\partial P}{\partial y})\)</span>. From <span class="math display">\[\mathbf{r}= \mathbf{l}- 2(\mathbf{l}\cdot\mathbf{n})\mathbf{n}\]</span> We can derive <span class="math display">\[\mathbf{r}\cdot \nabla P=-\mathbf{l}\cdot \nablaP.\]</span> and thus <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix}+\frac{\mathbf{l}\cdot\nablaP}{r_y(\frac{\partial r_x}{\partial x}\frac{\partial P}{\partialy}-\frac{\partial r_x}{\partial y}\frac{\partial P}{\partialx})-r_x(\frac{\partial r_y}{\partial x}\frac{\partial P}{\partial y} -\frac{\partial r_y}{\partial y}\frac{\partial P}{\partialx})}\begin{pmatrix}r_x\\ r_y\end{pmatrix}.\]</span> These are twoequations satisfied by four variables <span class="math inline">\((x,y,X,Y)\)</span>, in the form of <span class="math inline">\(F(X,x,y)=0\)</span> and <span class="math inline">\(G(Y,x,y)=0\)</span>. Remember that we also have aknown equation <span class="math inline">\(P(x,y)=0\)</span>. In orderto eliminate <span class="math inline">\(x,y\)</span> from these threeequations and obtain an expression that only contains <span class="math inline">\((X,Y)\)</span>, we can try using the <a href="#https://en.wikipedia.org/wiki/Gr%C3%B6bner_basis">Gröbner basismethod</a>. The Gröbner basis method transforms the polynomialsystem</p><p><span class="math display">\[F=G=P=0\]</span> into a set ofequivalent new equations <span class="math display">\[g_1=g_2=\cdots=g_m=0.\]</span> which have exactlythe same solution set.</p><p><span class="math inline">\(\{g_1,\ldots,g_m\}\)</span> is a set ofgenerators of the ideal <span class="math inline">\(I=\langleF,G,P\rangle\)</span> generated by <span class="math inline">\(F,G,P\)</span> in the ring <span class="math inline">\(\mathbb{R}[x,y,X,Y]\)</span>, and <span class="math inline">\(\{g_1,\ldots,g_m\}\)</span> is called the reducedGröbner basis of <span class="math inline">\(I\)</span>. Underlexicographic order, the reduced Gröbner basis has a nice property thatwhen changing from <span class="math inline">\(g_1\)</span> to <span class="math inline">\(g_m\)</span>, the variables in the polynomials<span class="math inline">\(\{g_1,\ldots,g_m\}\)</span> are eliminatedin the order <span class="math inline">\(x\to y\to X\to Y\)</span>. Notethat this is not a rigorous statement, as we cannot always eliminatevariables in this order, but if elimination occurs, it will follow thisorder. This allows us to perform a “back-substitution” operation similarto the Gaussian elimination. As a result, solving the new system ofequations will be simpler than the original one.</p><p>Let’s try an experiment with <code>sympy</code>:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>x, y, X, Y = symbols(<span class="hljs-string">"x y X Y"</span>)<br>P = x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>dx = diff(P, x)  <span class="hljs-comment"># gradient of P</span><br>dy = diff(P, y)<br>curve = Matrix([x, y])<br>light_source = Matrix([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>l = curve - light_source  <span class="hljs-comment"># the incident ray</span><br>n = Matrix([dx, dy])  <span class="hljs-comment"># the normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n))  <span class="hljs-comment"># the reflected ray</span><br>rx, ry = r<br>dxrx = diff(rx, x)<br>dyrx = diff(rx, y)<br>dxry = diff(ry, x)<br>dyry = diff(ry, y)<br>denominator = ry * (dxrx * dy - dyrx * dx) - rx * (dxry * dy - dyry * dx)<br>nominator = dx * l[<span class="hljs-number">0</span>] + dy * l[<span class="hljs-number">1</span>]<br>F = (X - x) * denominator - nominator * rx<br>G = (Y - y) * denominator - nominator * ry<br>eqs = [eq.as_numer_denom()[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> eq <span class="hljs-keyword">in</span> [F, G, P]]<br>gb = groebner(eqs, [x, y, X, Y])<br>print(gb)<br></code></pre></td></tr></tbody></table></figure><p>The last item of the given results is</p><p><span class="math display">\[27 X^{4} y^{2} + 54 X^{2} Y^{2} y^{2} -18 X^{2} y^{2} - 8 X y^{2} + 27 Y^{4} y^{2} - 18 Y^{2} y^{2} -y^{2}.\]</span></p><p><span class="math inline">\(x\)</span> has been eliminated! Thesolutions to the original system of equations <span class="math inline">\(F=G=P\)</span> must necessarily be a subset of thesolutions to the above single equation. Observing each term, it isevident that they all contain a term <span class="math inline">\(y^2\)</span>, which is clearly not the solution wewant. Removing it, we are left with the remaining factor</p><p><span class="math display">\[27X^{4}+54X^{2}Y^{2}-18X^{2} -8X +27Y^{4}-18Y^{2}-1=0.\]</span></p><p>It is the implicit function representation of the cardioid. Don’tbelieve it? Let’s draw it in <a href="https://www.desmos.com/geometry/vtjbq3ete1">Desmos</a>!</p><p><img style="margin:0px auto;display:block" width="300" src="/images/caustics/desmos_cardioid.png"></p><h1 id="some-notes">Some notes</h1><p>This article mainly covers the first half of Greg Egan’s blog post. Ifeel that the second half is a bit too technical, so I decided not tocover it.</p><p>Although our experiment with <code>sympy</code> was very successful,but keep in mind that it is not always possible to obtain thecatacaustic in all situations, and calculating curves with complicatedexpressions in <code>sympy</code> can be very slow.</p><p>During my graduate studies, I took a course on computer algebra, andat that time, we used Maple as the teaching software. Programming isMaple was very inconvenient, so I actually don’t have much experience incomputer algebra programming. I used to think that <code>sympy</code>was slow and the output were not simplified enough, so I was not verywilling to use it. This experiment has somewhat refreshed myunderstanding of <code>sympy</code>. I still remember that the courserequired each of us to submit a book report, and I wrote notes on“Ideals, Varieties, and Algorithms”. But it’s been many years sincegraduation, and this is the first time I’ve used Gröbner bases!</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>The E8 picture explained through code</title>
      <link href="e8-and-coxeter-plane/index.html"/>
      <url>e8-and-coxeter-plane/index.html</url>
      
        <content type="html"><![CDATA[<p>If you have heard of Lie algebras, chances are you have encounteredthe following pattern: (Refer to Wikipedia’s <a href="https://en.wikipedia.org/wiki/Lie_algebra">Lie algebraentry</a>)</p><p><img style="margin:0px auto;display:block" src="/images/coxeter-element/e8.svg" width="350"></p><p>It displays the root system diagram for the Lie algebra <span class="math inline">\(E_8\)</span>, which consists of 240 vectors in aneight-dimensional Euclidean space <span class="math inline">\(\mathbb{R}^8\)</span>, each vector having exactly56 nearest neighbors. Projecting these 240 vectors onto a specialtwo-dimensional plane (known as the Coxeter plane) reveals arotationally symmetric pattern, as seen in the figure above, where the240 projected points are distributed across 8 concentric circles, eachcontaining 30 evenly spaced vertices, thus remaining invariant under arotation of angle <span class="math inline">\(\frac{2\pi}{30}\)</span>.The number <span class="math inline">\(h=30\)</span> is called theCoxeter number of <span class="math inline">\(E_8\)</span>.</p><p>This phenomenon is not unique to <span class="math inline">\(E_8\)</span> but holds for any finite Coxetergroup, as illustrated by the following figure, which shows the patternobtained by projecting the 32 vertices of a 5-dimensional hypercube andits edges onto its Coxeter plane:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter-element/5-cube.svg" width="350"></p><p>Two vertices are projected to the origin, with the remaining 30vertices distributed across 3 concentric circles, each containing 10evenly spaced vertices. Hence the Coxeter number is <span class="math inline">\(h=10\)</span>.</p><p>In this blog post I will use <span class="math inline">\(E_8\)</span>as an example to explain the mathematics behind this, following thepresentation in section 3.16 of Humphreys’ textbook “Reflection Groupsand Coxeter Groups”.</p><p>The code for this article is available on <a href="https://github.com/neozhaoliang/pywonderland/raw/master/src/misc/E8.py">GitHub</a>.</p><p>David Madore also has a beautiful <a href="http://www.madore.org/~david/math/e8w.html">interactive demo</a>that can draw the root system of <span class="math inline">\(E_8\)</span> in various ways.</p><h1 id="the-structure-of-e_8">The Structure of <span class="math inline">\(E_8\)</span></h1><p>We know that the Dynkin diagram of <span class="math inline">\(E_8\)</span> is as follows:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter-element/e8-dynkin.svg" width="400"></p><p>A set of simple roots is given by</p><p><span class="math display">\[\Delta=\begin{bmatrix}1&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\0&amp;1&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;-1&amp;0&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;1&amp;-1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;0&amp;1&amp;-1&amp;0&amp;0\\0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;1&amp;0\\-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}&amp;-\frac{1}{2}\\0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;-1&amp;0\end{bmatrix}.\]</span></p><p>Here, the vertex numbered <span class="math inline">\(i\)</span> inthe Dynkin diagram corresponds to the simple root <span class="math inline">\(\alpha_i\)</span>, which is the <span class="math inline">\(i\)</span>th row of the matrix. Note that eachsimple root has a length of <span class="math inline">\(\sqrt{2}\)</span>, hence not a unit vector. Thisis mainly for convenience in later computations.</p><p>The Cartan matrix is given by</p><p><span class="math display">\[C=\left((\alpha_i,\alpha_j)\right)_{1\leq i,j\leq8}=\begin{pmatrix}2&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\-1&amp;2&amp;-1&amp;0&amp;0&amp;0&amp;0&amp;0\\0&amp;-1&amp;2&amp;-1&amp;0&amp;0&amp;0&amp;0\\0&amp;0&amp;-1&amp;2&amp;-1&amp;0&amp;0&amp;0\\0&amp;0&amp;0&amp;-1&amp;2&amp;-1&amp;0&amp;-1\\0&amp;0&amp;0&amp;0&amp;-1&amp;2&amp;-1&amp;0\\0&amp;0&amp;0&amp;0&amp;0&amp;-1&amp;2&amp;0\\0&amp;0&amp;0&amp;0&amp;-1&amp;0&amp;0&amp;2\end{pmatrix}.\]</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>Here’s a point that can be easily confusing: please remember thatin the mathematical derivations in this article, the inner product weuse is the one given by the Cartan matrix <span class="math inline">\(C\)</span>. However, in the actual code, we candirectly call <code>np.dot</code> to calculate the inner product of twovectors. The reasoning is as follows:</p><p>Let <span class="math inline">\(u=\sum_{i=1}^8 x_i\alpha_i\)</span>and <span class="math inline">\(v=\sum_{i=1}^8 y_i\alpha_i\)</span> betwo vectors, and let <span class="math inline">\(X=(x_1,\ldots,x_8)\)</span> and <span class="math inline">\(Y=(y_1,\ldots,y_8)\)</span> be their coordinatesin the basis <span class="math inline">\(\Delta\)</span>. Also, let<span class="math inline">\(u=(u_1,\ldots,u_8)\)</span> and <span class="math inline">\(v=(v_1,\ldots,v_8)\)</span> be their coordinatesin the standard basis <span class="math display">\[\{e_i=(0,\ldots,\underbrace{1}_{\text{$i$-thposition}},\ldots,0)\mid 1\leq i\leq 8\},\]</span> then their innerproduct is <span class="math display">\[(u,v)=XCY'=X\Delta\Delta'Y'=\sum_{i=1}^8u_i v_i = \mathrm{np.dot}(u,v).\]</span></p><p>From now on, we will no longer emphasize that <span class="math inline">\((\,,\,)\)</span> is the inner product under <span class="math inline">\(C\)</span>. But readers must be aware of this.</p></div><p>Each simple root <span class="math inline">\(\alpha_i\)</span>corresponds to a simple reflection <span class="math inline">\(s_i\)</span>:</p><p><span class="math display">\[s_i(v) = v -\frac{2(v,\alpha_i)}{(\alpha_i, \alpha_i)}\alpha_i =v-(v,\alpha_i)\alpha_i,\quad 1\leq i\leq 8.\]</span></p><p>This expression shows the advantage of making each simple root <span class="math inline">\(\alpha_i\)</span> have a length of <span class="math inline">\(\sqrt{2}\)</span>: <span class="math inline">\(\alpha_i\)</span> is equal to its coroot <span class="math inline">\(\frac{2\alpha_i}{(\alpha_i,\alpha_i)}\)</span>,resulting in the simple form of reflection about <span class="math inline">\(\alpha_i\)</span>.</p><p>To express this in code:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># A set of simple roots listed by rows of 'delta'</span><br>delta = np.array([<br>    [<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>],<br>    [-<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>, -<span class="hljs-number">0.5</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>])<br><br><span class="hljs-comment"># The cartan matrix:</span><br>cartan = np.dot(delta, delta.transpose())<br></code></pre></td></tr></tbody></table></figure><p>The group <span class="math inline">\(W\)</span> generated by allsimple reflections <span class="math inline">\(\{s_i\}\)</span> iscalled the Weyl group of <span class="math inline">\(E_8\)</span>,containing 696729600 elements. The set <span class="math display">\[\Phi= \{w\cdot\alpha\mid w\in W, \alpha\in\Delta\}\]</span> generated by theaction of the Weyl group on the simple roots is called the root systemof <span class="math inline">\(E_8\)</span>, containing 240 distinctvectors, with <span class="math inline">\(W\)</span> acting on <span class="math inline">\(\Phi\)</span> by permutations.</p><p>The vectors in <span class="math inline">\(\Phi\)</span> can bedivided into two categories:</p><ol type="1"><li>The first category includes all permutations of <span class="math inline">\((\pm1,\pm1,0,0,0,0,0,0)\)</span>, with twocomponents being <span class="math inline">\(+1\)</span> or <span class="math inline">\(-1\)</span> and the remaining six being 0. Thereare 112 vectors of this type.</li><li>The second category includes vectors of the form <span class="math inline">\(1/2\times(\pm1,\pm1,\cdots,\pm1)\)</span>, wherethe number of <span class="math inline">\(-1\)</span>s is even. Thereare 128 vectors of this type.</li></ol><p><strong>For programming convenience, we will multiply all roots by 2to make them integer vectors</strong>. Thus, the code to generate theroot system <span class="math inline">\(\Phi\)</span> can be written asfollows:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> itertools<br><br>roots = []<br><br><span class="hljs-comment"># Roots of the form (+-1, +-1, 0, 0, 0, 0, 0, 0),</span><br><span class="hljs-comment"># signs can be chosen independently and the two non-zeros can be anywhere.</span><br><span class="hljs-keyword">for</span> i, j <span class="hljs-keyword">in</span> combinations(<span class="hljs-built_in">range</span>(<span class="hljs-number">8</span>), <span class="hljs-number">2</span>):<br>    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> product([-<span class="hljs-number">2</span>, <span class="hljs-number">2</span>], repeat=<span class="hljs-number">2</span>):<br>        v = np.zeros(<span class="hljs-number">8</span>)<br>        v[i] = x<br>        v[j] = y<br>        roots.append(v)<br><br><span class="hljs-comment"># Roots of the form 1/2 * (+-1, +-1, ..., +-1), signs can be chosen</span><br><span class="hljs-comment"># indenpendently except that there must be an even numer of -1s.</span><br><span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> product([-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>], repeat=<span class="hljs-number">8</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span>(v) % <span class="hljs-number">4</span> == <span class="hljs-number">0</span>:<br>        roots.append(v)<br>roots = np.array(roots).astype(<span class="hljs-built_in">int</span>)<br><br><span class="hljs-comment"># Connect a root to its nearest neighbors,</span><br><span class="hljs-comment"># two roots are connected if and only if they form an angle of pi/3.</span><br>edges = []<br><span class="hljs-keyword">for</span> i, r <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(roots):<br>    <span class="hljs-keyword">for</span> j, s <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(roots[i + <span class="hljs-number">1</span> :], i + <span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">sum</span>((r - s) ** <span class="hljs-number">2</span>) == <span class="hljs-number">8</span>:<br>            edges.append([i, j])<br></code></pre></td></tr></tbody></table></figure><h1 id="coxeter-element">Coxeter Element</h1><blockquote><p><strong>Definition</strong>: An element <span class="math inline">\(\gamma\in W\)</span> obtained by arranging thesimple reflections <span class="math inline">\(s_1,\ldots,s_8\)</span>in any order and then multiplying them is called a Coxeter element.</p></blockquote><p>Coxeter elements are not unique but are all conjugate to each other<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Therefore, they share the sameorder, characteristic polynomial, and eigenvalues.</p><blockquote><p><strong>Definition</strong>: The order of any Coxeter element iscalled the Coxeter number of <span class="math inline">\(W\)</span>,denoted by <span class="math inline">\(h\)</span>.</p></blockquote><p>Since <span class="math inline">\(\gamma\)</span> is an element ofthe finite group <span class="math inline">\(W\)</span>, its 8eigenvalues are of the form <span class="math display">\[\{\zeta^{m_1},\ldots,\zeta^{m_8},0\leqm_i&lt;h\}.\]</span></p><p>where <span class="math inline">\(\zeta\)</span> is a primitive <span class="math inline">\(h\)</span>-th root of unity. Section 3.16 inHumphrey’s boook shows that <span class="math inline">\(\gamma\)</span>’s eigenvalues cannot be 1, so each<span class="math inline">\(1\leq m_i&lt;h\)</span>. If <span class="math inline">\(\gamma\)</span> has real eigenvalues, the onlypossibility is <span class="math inline">\(-1\)</span> (corresponding to<span class="math inline">\(\zeta^{h/2}\)</span>). <span class="math inline">\(\gamma\)</span>’s complex eigenvalues appear inconjugate pairs, like <span class="math inline">\({\zeta^{m_i},\zeta^{h-m_i}}\)</span>.</p><p>A classical way to choose a Coxeter element is as follows: Note thatthe eight vertices of <span class="math inline">\(E_8\)</span>’s Dynkindiagram can be divided into two groups, <span class="math inline">\(\{1,3, 5, 7\}\)</span> and <span class="math inline">\(\{2, 4, 6,8\}\)</span>, with vertices within the same group not adjacent, hencethe corresponding simple reflections commute. Let <span class="math display">\[x=s_1s_3s_5s_7,\quad y=s_2s_4s_6s_8.\]</span>Then <span class="math inline">\(\gamma=xy\)</span> is a Coxeterelement.</p><h1 id="coxeter-plane">Coxeter Plane</h1><p>Now let’s examine the Cartan matrix <span class="math inline">\(C\)</span>. We assert that <span class="math inline">\(C\)</span> has an eigenvector <span class="math inline">\({\bf c}\)</span> with all positive components anda multiplicity of 1. Note that the diagonal entries of <span class="math inline">\(C\)</span> are all 2, and the off-diagonal entriesare non-positive, making <span class="math inline">\(2I-C\)</span> anon-negative matrix. Since <span class="math inline">\(E_8\)</span> isan irreducible root system, both <span class="math inline">\(C\)</span>and <span class="math inline">\(2I-C\)</span> are irreducible matrices.By the Frobenius-Perron theorem, the largest eigenvalue of <span class="math inline">\(2I-C\)</span> has a multiplicity of 1, and itscorresponding eigenvector <span class="math inline">\({\bf c}\)</span>has all positive components. <span class="math inline">\({\bfc}\)</span> is naturally the smallest eigenvalue’s correspondingeigenvector of <span class="math inline">\(C\)</span>.</p><p>We can use <code>numpy.linalg.eigh</code> to find the eigenvalues andeigenvectors of the Cartan matrix <span class="math inline">\(C\)</span>:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">eigenvals, eigenvecs = np.linalg.eigh(cartan)<br>c = eigenvecs[:, <span class="hljs-number">0</span>]<br></code></pre></td></tr></tbody></table></figure><p>Where <code>eigenvecs</code> columns are all the eigenvectors of<span class="math inline">\(C\)</span>, arranged in ascending order oftheir eigenvalues. Therefore, the first column corresponds to thesmallest eigenvalue’s eigenvector, which is our desired <span class="math inline">\({\bf c}\)</span>.</p><p>Following the notation on page 77 of Humphreys’ book:</p><p>Let <span class="math inline">\({\omega_i,1\leq i\leq 8}\)</span> bethe dual basis of <span class="math inline">\(\Delta\)</span>, i.e.,<span class="math display">\[(\alpha_i,\omega_j)=\delta_{ij}.\]</span>Let <span class="math inline">\({\bf c}=(c_1,c_2,\ldots,c_8)\)</span>,and define <span class="math display">\[\lambda = \sum_{i\inI}c_i\omega_i,\quad \mu= \sum_{j\in J}c_j\omega_j.\]</span> Humphreys’book shows that the two-dimensional plane <span class="math inline">\(P={\rm span}\{\lambda,\mu\}\)</span> remainsinvariant under the actions of <span class="math inline">\(x,y\)</span>.In fact, <span class="math inline">\(x,y\)</span> act as reflections on<span class="math inline">\(P\)</span>, thus <span class="math inline">\(\gamma=xy\)</span> acts on <span class="math inline">\(P\)</span> as a rotation. The order of thisrotation is the order of <span class="math inline">\(\gamma\)</span>,which is the Coxeter number <span class="math inline">\(h\)</span>.Since <span class="math inline">\(\gamma\)</span> permutes the rootsystem <span class="math inline">\(\Phi\)</span>, projecting <span class="math inline">\(\Phi\)</span> onto plane <span class="math inline">\(P\)</span> theoretically should reveal a patternwith <span class="math inline">\(h\)</span>-fold rotational symmetry.(In fact, this is the image at the beginning of this article)</p><p>Using the direct definitions of <span class="math inline">\(\lambda,\mu\)</span> to compute the projection of<span class="math inline">\(\Phi\)</span> onto <span class="math inline">\(P\)</span> is inconvenient because it involves thedual basis <span class="math inline">\({\omega_i}\)</span>. We canbypass the calculation of the dual basis. This is implicitly suggestedin the calculations on page 78 of Humphreys’ book:</p><p>If we define <span class="math display">\[\nu=\sum_{j\inJ}c_j\alpha_j.\]</span> Then <span class="math inline">\(\mu=(1-c)\lambda+\nu\)</span> and <span class="math inline">\(\nu\perp\lambda\)</span>. This amounts to say that<span class="math inline">\(\nu\)</span> is the component of <span class="math inline">\(\mu\)</span> perpendicular to <span class="math inline">\(\lambda\)</span>. Similarly, if we define <span class="math display">\[\nu'=\sum_{i\in I}c_i\alpha_i.\]</span> Then<span class="math inline">\(\nu'\)</span> is the component of <span class="math inline">\(\lambda\)</span> perpendicular to <span class="math inline">\(\mu\)</span>. Hence, <span class="math inline">\(P={\rm span}\{\nu,\nu'\}\)</span>. And <span class="math inline">\(\nu,\nu'\)</span>’s expressions only involve<span class="math inline">\({\alpha_i}\)</span>, which simplifies theprocess.</p><p>The code can be written as follows (using <span class="math inline">\(u,v\)</span> to represent <span class="math inline">\(\nu,\nu'\)</span>):</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">I = [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>]<br>J = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]<br>u = <span class="hljs-built_in">sum</span>(c[i] * delta[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> I)<br>v = <span class="hljs-built_in">sum</span>(c[j] * delta[j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> J)<br>u /= np.linalg.norm(u)<br>v -= np.dot(u, v) * u<br>v /= np.linalg.norm(v)<br></code></pre></td></tr></tbody></table></figure><p>Here, we performed Gram-Schmidt orthogonalization on <span class="math inline">\(u,v\)</span> to obtain an orthonormal basis for<span class="math inline">\(P\)</span>.</p><p>Projecting <span class="math inline">\(\Phi\)</span> onto <span class="math inline">\(P\)</span> is straightforward: for each vector inthe root system, compute its coordinates in the basis <span class="math inline">\(u,v\)</span>:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">roots_2d = [(np.dot(u, x), np.dot(v, x)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> roots]<br></code></pre></td></tr></tbody></table></figure><p>What remains is to draw these points and the edges between them. Thedetails of the drawing process are not discussed here.</p><h1 id="further-improvement">Further Improvement</h1><p>If you look at the <a href="https://github.com/neozhaoliang/pywonderland/blob/master/src/misc/E8.py#L123">GitHubcode</a>, you’ll find that it’s not written exactly as described above.What’s the reason for this?</p><p>A minor drawback of the previous calculation is that we had toexplicitly specify two sets <span class="math inline">\(I,J\)</span>.This step can also be avoided, but it requires a more detailed analysisof the Cartan matrix <span class="math inline">\(C\)</span> and Coxeterelement <span class="math inline">\(\gamma\)</span>. The followingproposition can be found in <a href="https://secure.math.ubc.ca/~cass/research/pdf/Element.pdf">Casselman’sarticle</a>:</p><blockquote><p><strong>Proposition</strong>: <span class="math inline">\(2I + \gamma+ \gamma^{-1}= (2I-C)^2\)</span>.</p></blockquote><p>We can compute and verify that this identity indeed holds. Considerthe matrix of <span class="math inline">\(\gamma\)</span> under thebasis <span class="math inline">\(\Delta\)</span>:</p><p><span class="math display">\[\gamma=xy=\begin{pmatrix}0&amp;-1&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0\\1&amp;-1&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0\\-1&amp;1&amp;-1&amp;1&amp;0&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;-1&amp;1&amp;0&amp;0&amp;0\\0&amp;0&amp;1&amp;-1&amp;2&amp;-1&amp;1&amp;-1\\0&amp;0&amp;0&amp;0&amp;1&amp;-1&amp;1&amp;0\\0&amp;0&amp;0&amp;0&amp;1&amp;-1&amp;0&amp;0\\0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;0&amp;-1\end{pmatrix}.\]</span>Thus, <span class="math display">\[\gamma^{-1} =yx=\begin{pmatrix}-1&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0&amp;0\\-1&amp;1&amp;-1&amp;1&amp;0&amp;0&amp;0&amp;0\\0&amp;1&amp;-1&amp;1&amp;0&amp;0&amp;0&amp;0\\0&amp;1&amp;-1&amp;1&amp;-1&amp;1&amp;0&amp;1\\0&amp;0&amp;0&amp;1&amp;-1&amp;1&amp;0&amp;1\\0&amp;0&amp;0&amp;1&amp;-1&amp;1&amp;-1&amp;1\\0&amp;0&amp;0&amp;0&amp;0&amp;1&amp;-1&amp;0\\0&amp;0&amp;0&amp;1&amp;-1&amp;1&amp;0&amp;0\end{pmatrix}.\]</span>Therefore, <span class="math display">\[2I + \gamma + \gamma^{-1} =\begin{pmatrix}1&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0&amp;0\\0&amp;2&amp;0&amp;1&amp;0&amp;0&amp;0&amp;0\\1&amp;0&amp;2&amp;0&amp;1&amp;0&amp;0&amp;0\\0&amp;1&amp;0&amp;2&amp;0&amp;1&amp;0&amp;1\\0&amp;0&amp;1&amp;0&amp;3&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1&amp;0&amp;2&amp;0&amp;1\\0&amp;0&amp;0&amp;0&amp;1&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1&amp;0&amp;1&amp;0&amp;1\end{pmatrix}=(2I - C)^2.\]</span> This implies that <span class="math inline">\(v\)</span> is an eigenvector of <span class="math inline">\((2I-C)^2\)</span> with an eigenvalue of <span class="math inline">\(4\cos^2\frac{\theta}{2}\)</span>.</p><p>It seems to suggest that <span class="math inline">\(v\)</span> isalso an eigenvector of <span class="math inline">\(2I-C\)</span> witheigenvalues of <span class="math inline">\(\pm2\cos\frac{\theta}{2}\)</span>. However, it’s not clear whether both<span class="math inline">\(\pm 2\cos\frac{\theta}{2}\)</span> willappear, or if they do, whether their multiplicities are equal.</p><p>Casselman demonstrated that this is indeed the case:</p><blockquote><p><strong>Proposition</strong>: <span class="math inline">\(2I-C\)</span> and <span class="math inline">\(C-2I\)</span> have the same characteristicpolynomial.</p></blockquote><p>According to this proposition, <span class="math inline">\(2I-C\)</span> and <span class="math inline">\(C-2I\)</span> have the same dimension for theireigenspaces corresponding to an eigenvalue <span class="math inline">\(\lambda\)</span>. Since the latter is theeigenspace of <span class="math inline">\(2I-C\)</span> for theeigenvalue <span class="math inline">\(-\lambda\)</span>, it followsthat the dimensions of the eigenspaces of <span class="math inline">\(C-2I\)</span> for <span class="math inline">\(\pm\lambda\)</span> are equal. Let <span class="math inline">\(V_s,V_{\bar{s}}\)</span> be the eigenspacescorresponding to a pair of conjugate complex eigenvalues <span class="math inline">\(s=e^{i\theta}\)</span> and <span class="math inline">\(\bar{s}=e^{-i\theta}\)</span> of <span class="math inline">\(\gamma\)</span>. We have seen that <span class="math inline">\(P=V_s\oplus V_{\bar{s}}\)</span> is the eigenspaceof <span class="math inline">\((2I-C)^2\)</span> for the eigenvalue<span class="math inline">\(4\cos^2\frac{\theta}{2}\)</span>. Since<span class="math inline">\(2I-C\)</span> commutes with <span class="math inline">\((2I-C)^2\)</span>, <span class="math inline">\(P\)</span> is also an invariant subspace of <span class="math inline">\(2I-C\)</span>. <span class="math inline">\(2I-C\)</span> is diagonalizable on <span class="math inline">\(P\)</span>, making <span class="math inline">\(P\)</span> the direct sum of eigenspaces of <span class="math inline">\(2I-C\)</span> for eigenvalues <span class="math inline">\(\pm 2\cos\frac{\theta}{2}\)</span>. Thus, <span class="math inline">\(P\)</span> is the direct sum of eigenspaces of<span class="math inline">\(C\)</span> for eigenvalues <span class="math inline">\(2\pm2\cos\frac{\theta}{2}\)</span>.</p><p>Let’s verify this: the eigenvalues of <span class="math inline">\(C\)</span> returned by<code>numpy.linalg.eigh</code> are as follows:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">[<span class="hljs-number">0.01095621</span> <span class="hljs-number">0.51371035</span> <span class="hljs-number">1.18652671</span> <span class="hljs-number">1.58417662</span> <span class="hljs-number">2.41582338</span> <span class="hljs-number">2.81347329</span> <span class="hljs-number">3.48628965</span> <span class="hljs-number">3.98904379</span>]<br></code></pre></td></tr></tbody></table></figure><p>The sum of the first and the last is 4, the second and thesecond-to-last also sum to 4, the third and the third-to-last sum to 4,and the fourth and fifth sum to 4. Therefore, the eigenvalues of <span class="math inline">\(C\)</span> sum pairwise to 4, consistent with thetheory!</p><p>Generally, the dimension of <span class="math inline">\(P=V_s\oplusV_{\bar{s}}\)</span> might not be 2, so <span class="math inline">\(P\)</span> might not always be a plane. However,for the smallest eigenvalue of <span class="math inline">\(C\)</span>,we already know its multiplicity is 1, hence the multiplicity of itslargest eigenvalue is also 1, making <span class="math inline">\(P\)</span> a two-dimensional plane. Thus, <span class="math inline">\(\gamma\)</span>’s action on <span class="math inline">\(P\)</span> is a rotation of angle <span class="math inline">\(\theta_0\)</span>.</p><p>From the printed results, we see</p><p><span class="math display">\[0.01095621 \approx2-2\cos\frac{\theta_0}{2},\quad \theta_0\approx2\arccos0.994521895\approx\frac{2\pi}{30}.\]</span> This verifies that<span class="math inline">\(\gamma\)</span>’s action on <span class="math inline">\(P\)</span> is a rotation of order 30, confirmingthe Coxeter number of <span class="math inline">\(W\)</span> is 30.</p><p>To find a basis for <span class="math inline">\(P\)</span>, one needsonly to find the eigenvectors <span class="math inline">\(u,v\)</span>corresponding to the smallest and largest eigenvalues of <span class="math inline">\(C\)</span>, <span class="math display">\[\alpha=\sum_{i=1}^8 u_i\alpha_i,\quad\beta=\sum_{i=1}^8 v_i\alpha_i.\]</span> These form a basis for <span class="math inline">\(P\)</span>.</p><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>Proof seen in <a href="https://arxiv.org/abs/1302.2842">Conjugacy of Coxeter elements,Henrik Eriksson, Kimmo Eriksson</a>. The proof using graph theorypresented there is particularly appealing.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Make awesome gif animation in a few seconds with pure Python!</title>
      <link href="gifmaze/index.html"/>
      <url>gifmaze/index.html</url>
      
        <content type="html"><![CDATA[<p>This program can help you make gif animations of various algorithmsrunning on the 2d square grid.</p><blockquote><p><strong>Requirements</strong>: <code>tqdm</code> for showing processbar and <code>pillow</code> for reading images.</p></blockquote><h1 id="examples">Examples</h1><ul><li><p>Wilson’s uniform spanning tree algorithm (my favourite, 2349frames, 333KB, generated in 3 seconds):</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/wilson-bfs.gif"></p></li><li><p>Prim’s algorithm:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/prim.gif"></p></li><li><p>Kruskal’s algorithm:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/kruskal.gif"></p></li><li><p>Langton’s ant:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/langton-ant.gif"></p></li><li><p>Hilbert curve：</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/hilbert.gif"></p></li><li><p>Conway’s game of life (gosper glider gun):</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/gosperglidergun.gif"></p></li></ul><h1 id="whats-special-about-this-program">What’s special about thisprogram</h1><p>The code is implemented in pure Python, no third-party modules norsoftwares are required, just built-in modules like <code>struct</code>,<code>random</code>, <code>colorsys</code> and some built-in functions,and without any “color” or “draw” function calls. In later versions Iadded some features like showing process bars (requires<code>tqdm</code>) and enabling the user to embed the animtion into abackground image (requires <code>pillow</code>). The program runs muchfaster than expected, it can generate highly optimized gif output inonly a few seconds. One drawback is that it’s not quite user-friendly:the user must have some basic knowledge of the GIF89a specification toknow how to set parameters correctly in the animation.</p><h1 id="how-did-this-program-come-out">How did this program comeout</h1><p>This program is motivated by Mike Bostock’s wonderful <a href="https://bl.ocks.org/mbostock/11357811">Javascript animation</a>. Afew years ago when I saw Mike’s page I immediately had the idea ofwriting a Python version to produce gif animations of Wilson’salgorithm. A first thought on this was to save the animation into framesand then pack them back into a whole gif. But the animation usuallycontains thousands of frames so this is definitely a horrible task andis far from being efficient. Luckily five years later I learnt theGIF89a specification by chance and suddenly realized the new approach ofencoding the animation into a byte stream. So basically I implemented asmall gif encoder first, then run the algorithm on a 2d grid (use a 2darray to represent it) and encode it into frames along the way.</p><h1 id="what-is-wilsons-algorithm">What is Wilson’s algorithm</h1><p>Consider the following problem:</p><blockquote><p><strong>Problem</strong>: Let <span class="math inline">\(G\)</span>be a finite, connected and undirected graph. How can one choose a randomspanning tree among all spanning trees of <span class="math inline">\(G\)</span> from uniform probability? (we shallcall such a tree an uniform spanning tree, or simply an<strong>UST</strong>.)</p></blockquote><p>The following image shows an UST of a 48x36 grid, the circled dot isthe root vertex:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/ust.png"></p><p>You might say “that’s easy, just write a program that lists allspanning trees and then use a random integer to choose one”. But let’sconsider the complete graph <span class="math inline">\(K_n\)</span> forexample: <span class="math inline">\(K_n\)</span> has <span class="math inline">\(n^{n/2}\)</span> many different spanning trees by<a href="https://en.wikipedia.org/wiki/Cayley%27s_formula">Cayley’sformula</a>, for <span class="math inline">\(n=100\)</span> this numberis <span class="math inline">\(100^{98}\)</span>, far more larger thanthe number of particles in the universe! (which is estimated about <span class="math inline">\(10^{90}\)</span>)</p><p>Currently the most efficient algorithm known is the one proposed inWilson’s paper</p><blockquote><p>“generating random spanning trees more quickly than the covertime”.</p></blockquote><p>It’s a random algorithm, that is, some times you may be very lucky toget an UST soon, or you may wait forever. But one can prove that thisalgorithm will terminate in finite steps with probability one (note thisdoes not exclude the possibility of running forever, think about this),and it performs really well in most cases.</p><p>The key to understand Wilson’s algorithm is the so called <a href="https://en.wikipedia.org/wiki/Loop-erased_random_walk">loop erasedrandom walk</a>, that is, once the random walk visits a vertex thatalready existed in its path, it immediately erases the loop betweenthese two visits and continues the walk from this vertex. Just watch theJavascript animation if you don’t understand this, it’s obvious to seewhat “loop erased random walk” means from it. (click on the canvas torestart the animation)</p><script type="text/javascript" src="/images/code/wilson.js"></script><div data-align="center"><canvas id="wilson" width="600" height="600"></canvas></div><p>The algorithm runs as follows:</p><blockquote><p><strong>Wilson’s algorithm</strong>:</p><ol type="1"><li>Choose any vertex <span class="math inline">\(v\)</span> as the rootand maintain a tree <span class="math inline">\(T\)</span>, initially<span class="math inline">\(T=\{v\}\)</span>.</li><li>For any vertex <span class="math inline">\(z\)</span> that is not in<span class="math inline">\(T\)</span>, start a loop erased random walkfrom <span class="math inline">\(z\)</span> until the walk hits <span class="math inline">\(T\)</span>, then add the resulting path of thewalk to <span class="math inline">\(T\)</span>.</li><li>Repeat step 2 until all vertices of the graph are in <span class="math inline">\(T\)</span>.</li></ol></blockquote><p>The proof of the correctness of this algorithm is a bit tricky andwill not be discussed here, you may refer to Wilson’s original paper orthe book by Russell Lyons and Yuval Peres:</p><blockquote><p>“Probability on Trees and Networks”.</p></blockquote><h1 id="implementation">Implementation</h1><p>As mentioned before, the animation of Wilson’s algorithm (and alsoLangton’s ant animation) usually contains thousands of frames in it, soit’s quite surprising that this program takes only a few seconds toproduce a highly optimized image. The key points are:</p><ul><li><p>Only encode a minimum region at a time. We can maintain arectangular region to store which cells are changed between successiveframes, this enables us to encode only a small portion of the windowinstead of the whole into a frame.</p></li><li><p>Use variable mimimum code length for the LZW compression. Whenencoding a frame into bytearrays LZW compression allows the minimum codelength <span class="math inline">\(k\)</span> can be as small as thecolor depth of this frame (and must satisfy <span class="math inline">\(2\leq k\leq12\)</span>), this is another benifitsince most frames only contain very few colors.</p></li><li><p>Write the frames to a temporary <code>BytesIO</code> file inmemory and flush it to disk in the end.</p></li></ul><p>The code is divided into three layers: at the top layer is the<code>Maze</code> class on which we run various algoirthms. This layerknows nothing about the gif image. At the bottom layer is the<code>GIFSurface</code> class which holds the raw information like imagesize, global color table, number of loops, background color index, etc.It knows nothing about the <code>Maze</code>. At the middle layer is the<code>Animation</code> class which controls how the <code>Maze</code> isencoded and writes to the <code>GIFSurface</code>.</p><h1 id="a-short-introduction-to-the-gif89a-specification">A shortintroduction to the GIF89a specification</h1><p>In this section I’ll give a not-so-detailed introduction to theGIF89a specification. It’s not meant to be comprehensive norself-contained, you should always refer to <a href="http://giflib.sourceforge.net/whatsinagif/index.html">What’s in aGIF</a> when you have difficulties understanding my words here.</p><p>Roughly a GIF image consists of:</p><blockquote><p><strong>Structure of a GIF File</strong></p><ol type="1"><li>Always begins with 6 bytes <code>GIF89a</code>.</li><li>Then follows the <strong>logical screen descriptor</strong> whichspecifies the width and height of the image and the size of the<strong>global color table</strong>.</li><li>Then follows the global color table.</li><li>Then follows the <strong>loop control block</strong> which specifiesthe number of loops of the image.</li><li>Then comes the actual data of the frames. The data of each frame canbe further divided into 3 parts:<ol type="1"><li>the <strong>graphics control block</strong> which specifies thedelay and transparent color of this frame.</li><li>the <strong>image descriptor</strong> which specifies the relativeposition of this frame in the window and the size of the local colortable.</li><li>the local color table of this frame (if there is a local color tablefor this frame).</li><li>the LZW compressed pixel data of this frame.</li></ol></li><li>Finally the image file ends with a byte <code>0x3B</code>.</li></ol></blockquote><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>The above description does not apply to all GIF images, there canbe some variations. For example:</p><ol type="1"><li><p>The image may not contain a global color table (so you have tospecify a local color table for each frame).</p></li><li><p>For a static image the loop control block is not required; for astacit frame the graphcs control block is not required.</p></li><li><p>The file may end without the byte <code>0x3B</code>, mostdecoders can still decode the image correctly.</p></li></ol></div><p>Now we explain each part in more details.</p><h2 id="the-header-gif89a">The header GIF89a</h2><p>In python you can write it as</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">'6s'</span>, <span class="hljs-string">b'GIF89a'</span>)<br></code></pre></td></tr></tbody></table></figure><p>Why <code>b'GIF89a'</code> not simply <code>'GIF89a'</code>? This isfor compatibility with Python2 and 3 since the default encoding inPython3 is unicode whereas in python2 it’s ascii.</p><h2 id="the-logical-screen-descriptor">The logical screendescriptor</h2><p>Example:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">'&lt;2H3B'</span>, width, height, <span class="hljs-number">0b10010001</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><p>Here you shoud note the format string <code>&lt;</code> (littleendian).</p><p>The byte <code>0b10010001</code> is called a packed field. Let’s readit from left to right:</p><ol type="1"><li>The first bit 1 means we have a global color table (0 forabsent).</li><li>The next 3 bits specify the “color depth”. You don’t need care aboutwhat they mean since modern decoders like firefox and chrome do not usethem.</li><li>The fifth bit is the “sort flag” and is not used today, always setto 0.</li><li>The ending 3 bits represent an integer <span class="math inline">\(x\)</span> in range 0-7, <span class="math inline">\(x\)</span> specifies the size of the global colortable (<span class="math inline">\(=2^{x+1})\)</span>.</li></ol><p>The last two bytes are of little importance and we don’t discuss themhere.</p><h2 id="global-color-table">Global color table</h2><p><strong>Example</strong>: if we want to use 4 colors red, green,blue, yellow, then the global color table can be written as</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">bytearray</span>([<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>])<br></code></pre></td></tr></tbody></table></figure><p>It’s important that the number of colors in this array must be apower of 2 and match the size of the global color table specified in thepacked byte in the logical screen descriptor, otherwise the decoder willnot be able to parse the image correctly.</p><h2 id="graphics-control-block">Graphics control block</h2><p><strong>Example</strong>:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">"&lt;4BH2B"</span>, <span class="hljs-number">0x21</span>, <span class="hljs-number">0xF9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0b00000101</span>, delay, trans_index, <span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><p>The 3 beginning bytes <code>0x21, 0xF9, 4</code> are fixed and areused to inform the decoder “Hey, I’m a graphics control block, see thenext 4 bytes!”</p><p>The next byte <code>0b00000101</code> is also a packed field, let’sread it from left to right:</p><ol type="1"><li>The first 3 bits are useless and are always 0.</li><li>The next 3 bits are called “desposal method”, they represent aninteger <span class="math inline">\(x\)</span> in range 0-7 and <span class="math inline">\(x\)</span> specifies how we should dispose thisframe after it’s displayed.<ol type="1"><li><p><span class="math inline">\(x=0\)</span> means it’s undefined,decoders will use default 1 instead in this case.</p></li><li><p><span class="math inline">\(x=1\)</span> is the default, it meansleave this frame here. So if the next frame is not overlapped with thisframe then both these two frames will be displayed. Otherwise theoverlapped area in this frame will be covered by the next one. See theexample below:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/disposal1.gif"></p></li><li><p><span class="math inline">\(x=2\)</span> means remove this frameand restore the image to background image/color, see the followingexample:</p><p><img style="margin:0px auto;display:block" src="/images/gifmaze/disposal2.gif"></p><p>You can see each frame is remove immediately after it’s displayed,and its region is filled with transparent background (so you are reallyseeing the browser’s background color through the image).</p></li><li><p><span class="math inline">\(x=3\)</span> also means remove thisframe, but restore the image to the previous frame.<img style="margin:0px auto;display:block" src="/images/gifmaze/disposal3.gif"></p></li><li><p>4-7 are unused.</p></li></ol></li></ol><p>The next 2 bytes <code>delay</code> specifies the delay of the framein centiseconds, so <code>delay=3</code> means “keep staying here for0.03 second”.</p><p>The last byte <code>trans_index</code> specifies the transparentcolor in this frame, the pixels in this frame using this color aretransparent: you can see the previous frame through them (of course onlywhen the previous frame is still there (reserved), otherwise you areseeing the previous previous frame, …, etc).</p><h2 id="image-descriptor-block">Image descriptor block</h2><p>Example:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">struct.pack(<span class="hljs-string">'&lt;B4HB'</span>, <span class="hljs-number">0x2C</span>, left, top, width, height, <span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure><p>Quite straight-forward to understand. Note the last byte is 0 sincewe do not need local color tables here.</p><h2 id="the-lzw-compression-algorithm">The LZW compressionalgorithm</h2><p>Finally we are left with the most difficult part: the LZW algorithm.It’s too long to include an introduction to the algorithm here, soplease refer to <a href="http://www.matthewflickinger.com/lab/whatsinagif/lzw_image_data.asp">thesecond article in What’s in a gif</a> for a complete treatment. But it’squite simple to implement it in Python, see the file <a href="https://github.com/neozhaoliang/pywonderland/blob/master/src/gifmaze/gifmaze/encoder.py">encoder.py</a>for an example.</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Reaction-Diffusion simulation with pyglet and glsl</title>
      <link href="grayscott/index.html"/>
      <url>grayscott/index.html</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/grayscott">Thisproject</a> is motivated by <a href="http://pmneila.github.io/jsexp/grayscott/">pmneila’s javascriptproject</a>. The core part of the code are the two GLSL shaders<code>reaction.frag</code> and <code>render.frag</code>. The pythonscripts are merely for setting the UI and compiling the GLSL code.</p><blockquote><p>Requirements: <code>pyglet</code> for the UI and OpenGL environmentand <code>ffmpeg</code> for saving the animation to video files.</p></blockquote><h1 id="examples">Examples</h1><ol type="1"><li><p>Unstable</p><p><video src="/images/grayscott/unstable.mp4" controls=""></video></p></li><li><p>Coral</p><p><video src="/images/grayscott/coral.mp4" controls=""></video></p></li><li><p>Baceria</p><p><video src="/images/grayscott/bacteria.mp4" controls=""></video></p></li></ol><h1 id="usage">Usage</h1><p>You may simply run <code>python main.py</code> and then use keyboardand mouse to play with the simulation (for keyboard and mouse controlplease see the printed doc).</p><p>You may also initialize the window by passing more options:</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python main.py -size 800x600 -fps 400 -conf 1 -scale 2<br></code></pre></td></tr></tbody></table></figure><p>Here <code>-size</code> is the size of the window, <code>-fps</code>is the frames per second of the animation, if not specified then maxpossible value will be used, <code>-conf</code> is the line number ofthe pattern that the program will load from the file<code>config.txt</code> (which contains a few precomputed patterns),<code>-scale</code> is the “resolution” factor of the texture.</p><p>You may also use an image file to control the growth of the patternby adding the <code>-mask</code> option:</p><video src="/images/grayscott/mask.mp4" controls=""><h1 id="how-to-save-the-animation-to-a-video-file">How to save theanimation to a video file</h1><p>Make sure <code>ffmpeg</code> is installed on your computer and canbe found on system path, windows users need to manually add the path toyour ffmpeg.exe to environment variables, then press <code>ctrl+v</code>to start saving the video and press <code>ctrl+v</code> again to stopthe saving.</p><p>You can use the option <code>-videorate</code> to control the fps ofthe video (not the animation!) and the option <code>-samplerate</code>to control how often a frame is sampled from the animation. If theframes are sampled too frequently the size of the video file will growvery large.</p><h1 id="about-the-code">About the code</h1><p><code>pyglet</code> is only a thin wrapper of OpenGL so one has towrite his own classes to manage things like <code>vao</code>,<code>vbo</code>, <code>framebuffer</code>, etc. There are some moduleslike <code>vispy</code> and <code>gletools</code> that does similar job,but that lays the burden of learning one more package.</p><p>I wrote two scripts <code>shader.py</code> and<code>framebuffer.py</code> for compiling the shader programs andrendering to texture. They are not meant to be serious tools, just keptsimple and suffice for our work.</p><p>The GLSL code borrows heavily from pmneila’s work, the most geniuspart in his code is the use of a <code>brush</code> variable(<code>u_mouse</code> in our program) as the interface between theshader and the UI.</p></video>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Humphreys《反射群与 Coxeter 群》的一些注解</title>
      <link href="humphreys-coxeter-notes/index.html"/>
      <url>humphreys-coxeter-notes/index.html</url>
      
        <content type="html"><![CDATA[<p><span class="citation" data-cites="Humphreys90">Humphreys (<a href="#ref-Humphreys90" role="doc-biblioref">1990</a>)</span>是学习反射群和 Coxeter群的标准入门教材，书写的很棒，但是个别地方不太好懂。本文整理了我学习时的一些注解。本文的记号与Humphreys 书中保持一致。</p><span id="more"></span><h1 id="generation-by-simple-reflections">1.5 Generation by simplereflections</h1><p>这一节证明了整个反射群 <span class="math inline">\(W\)</span>可以由单反射 <span class="math inline">\(\{s_\alpha\mid\alpha\in\Delta\}\)</span>生成。</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span><span class="math inline">\(W\)</span> 可以由 <span class="math inline">\(\{s_\alpha\mid\alpha\in\Delta\}\)</span>生成。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(W'\)</span>是 <span class="math inline">\(\{s_\alpha\mid\alpha\in\Delta\}\)</span>生成的群。目标是证明 <span class="math inline">\(W'=W\)</span>。我们来一步步推理：</p><ol type="1"><li><span class="math inline">\(W\)</span> 是由全体镜面 <span class="math inline">\(\{s_\beta\mid \beta\in\Phi\}\)</span>生成的，所以只要证明任何 <span class="math inline">\(s_\beta\inW'\)</span> 即可。</li><li>要证明 1，只要证明任何 <span class="math inline">\(\beta\in\Phi\)</span> 可以写成 <span class="math inline">\(\beta=w'\alpha\)</span> 的形式，其中 <span class="math inline">\(w'\in W',\,\alpha\in\Pi\)</span>。这样<span class="math inline">\(s_\beta=w's_\alpha w'^{-1}\inW'\)</span>。</li><li>要证明 2，只需要分析 <span class="math inline">\(\beta\)</span>是正根且不是单根的情形，因为 <span class="math inline">\(-\beta =w's_\alpha\alpha\)</span>。</li><li>如果 <span class="math inline">\(\beta&gt;0\)</span> 但不是单根，设<span class="math inline">\(\beta=\sum c_s\alpha_s\)</span>，那么 <span class="math inline">\(0&lt;(\beta,\beta)=\sum c_s(\beta,\alpha_s)\)</span> 说明一定存在单根 <span class="math inline">\(\alpha_s\)</span> 满足 <span class="math inline">\((\beta,\alpha_s)&gt;0\)</span>。考察 <span class="math inline">\(\gamma=s\beta\)</span>。</li><li><span class="math inline">\(\gamma\)</span> 仍然是正根，并且 <span class="math inline">\(\mathrm{ht}(\gamma) &lt;\mathrm{ht}(\beta)\)</span>。如果 <span class="math inline">\(\gamma\)</span> 不是单根，那就一直重复此步骤直到<span class="math inline">\(\gamma\)</span>变成单根为止。这个操作一定会在有限次后终止，否则我们会得到一个无穷的、高度严格降低、从而互不相同的正根序列，这与根系是有限集矛盾。</li><li>设 <span class="math inline">\(\gamma=s_1\cdotss_r\beta\in\Delta\)</span> 是最终得到的单根，则 <span class="math inline">\(\beta\in W'\Delta\)</span>，结论成立。</li></ol><h1 id="the-length-function">1.6 The length function</h1><p>设 <span class="math inline">\(\mathrm{Neg}(w)\)</span> 是那些被<span class="math inline">\(w\)</span> 变成负根的正根的集合： <span class="math display">\[\mathrm{Neg}(w)=\{\lambda&gt;0\midw\lambda&lt;0\}.\]</span> 并记 <span class="math inline">\(n(w)=|\mathrm{Neg}(w)|\)</span>。这一节证明了<span class="math inline">\(n(w)\)</span> 满足的递推关系。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在后面 5.4 节中，针对一般的 Coxeter 群证明了长度函数 <span class="math inline">\(l(w)\)</span> 也满足同样的递推关系，从而 <span class="math inline">\(l(w)=n(w)\)</span>。但是那里的证明要复杂一些。</p></div><p>首先注意到任何单根 <span class="math inline">\(\alpha\in\Delta\)</span> 必然恰好属于 <span class="math inline">\(\mathrm{Neg}(w)\)</span> 或者 <span class="math inline">\(\mathrm{Neg}(ws_\alpha)\)</span> 之一，这取决于<span class="math inline">\(w\alpha\)</span> 是正根还是负根：</p><ul><li><span class="math inline">\(w\alpha&lt;0\Rightarrow\alpha\in\mathrm{Neg}(w)\)</span>。</li><li><span class="math inline">\(w\alpha&gt;0\Rightarrowws_\alpha\alpha&lt;0\Rightarrow \alpha\in\mathrm{Neg}(ws_\alpha)\)</span>。</li></ul><p>另一方面对任何正根 <span class="math inline">\(\gamma\ne\alpha\)</span>，<span class="math inline">\(s_\alpha\gamma\)</span> 仍然是正根。从恒等式 <span class="math display">\[(ws_\alpha)\gamma &lt; 0\Longleftrightarroww(s_\alpha\gamma)&lt;0\]</span> 可见 <span class="math inline">\(\gamma\in\mathrm{Neg}(ws_\alpha)\)</span> 当且仅当<span class="math inline">\(\gamma\in\mathrm{Neg}(w)\)</span>，所 <span class="math inline">\(\gamma\leftrightarrow s_\alpha\gamma\)</span>给出了 <span class="math inline">\(\mathrm{Neg}(ws_\alpha)\)</span> 和<span class="math inline">\(\mathrm{Neg}(w)\)</span> 中除 <span class="math inline">\(\alpha\)</span> 之外的正根的一一对应，所以</p><p><span class="math display">\[n(ws_\alpha)=\begin{cases}n(w)+1 &amp; \alpha\in\mathrm{Neg}(ws_\alpha),\\n(w)-1 &amp; \alpha\in \mathrm{Neg}(w).\end{cases}\]</span></p><h1 id="deletion-and-exchange-conditions">1.7 Deletion and ExchangeConditions</h1><p>这一节证明了有限反射群必然满足 deletion 和 exchange条件。开头的定理乍看起来非常不直观，包含了一大堆下标。我来解释下背后的几何直观。</p><p>设 <span class="math inline">\(w=s_1\cdots s_r\)</span> 是 <span class="math inline">\(W\)</span> 的任一元素。从基本区域 <span class="math inline">\(C\)</span> 出发，我们有一个gallery，即一列两两相邻的房间</p><p><span class="math display">\[C,\, s_1C,\, s_1s_2C,\, \ldots,\,s_1\cdots s_rC.\]</span></p><p>可以这样理解：记 <span class="math inline">\(w_i=s_1\cdotss_i\)</span>，则 <span class="math inline">\(w_{i-1}\)</span>将相邻的两个房间 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(s_iC\)</span> 映射为另外两个相邻的房间 <span class="math inline">\(w_{i-1}C\)</span> 和 <span class="math inline">\(w_iC\)</span>。</p><p>不仅如此，由于 <span class="math inline">\(C\)</span> 和 <span class="math inline">\(s_iC\)</span> 之间的墙壁是超平面 <span class="math inline">\(H_i = H_{s_i}\)</span>，它在 <span class="math inline">\(w_{i-1}\)</span> 作用下被映射为超平面 <span class="math inline">\(w_{i-1}H_i\)</span>，所以 <span class="math inline">\(w_{i-1}C\)</span> 和 <span class="math inline">\(w_iC\)</span> 之间的墙壁是 <span class="math inline">\(w_{i-1} H_i\)</span>。即</p><p><span class="math display">\[C\stackrel{H_1}{\bigl\lvert} s_1C\stackrel{s_1H_2}{\bigl\lvert}s_1s_2C\stackrel{\quad}{\bigl\lvert}\cdots\stackrel{w_{r-1}H_r}{\bigl\lvert}w_{r}C.\]</span></p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>表达式 <span class="math inline">\(w=s_1s_2\cdots s_r\)</span>是既约的，当且仅当上述镜面集合 <span class="math display">\[\{H_1,s_1H_2,\ldots,s_1\cdotss_{r-1}H_r\}\]</span> 互不相同。</p></div><p>这个引理的含义是，任何既约单词对应的 gallery不能两次跨越同一个超平面。</p><p>证明见 4.5 小节 simpletransitivity。那里仿射的情形和这里的证明是一样的。</p><p>如果一个镜子在上述集合中出现两次会发生什么？设 <span class="math inline">\(1\leq i&lt;j\leq r\)</span> 使得 <span class="math display">\[s_1\cdots s_{i-1}H_i = s_1\cdotss_{j-1}H_j.\]</span> 两边消去 <span class="math inline">\(s_1\cdotss_{i-1}\)</span> 得到 <span class="math display">\[H_i = s_i\cdotss_{j-1}H_j.\]</span> 即 <span class="math display">\[s_i = (s_i\cdotss_{j-1})s_j(s_{j-1}\cdots s_i)=(s_i\cdots s_{j})(s_{j-1}\cdotss_i).\]</span> 把右边的 <span class="math inline">\(s_{j-1}\cdotss_i\)</span> 挪到左边来得到 <span class="math display">\[s_{i+1}\cdotss_{j-1} = s_i\cdots s_j.\]</span> 这意味着 <span class="math inline">\(s_i\cdots s_j\)</span> 这一段可以用更短的 <span class="math inline">\(s_{i+1}\cdots s_{j-1}\)</span> 来代替，这就是定理1.7 中的 (c)。</p><h1 id="generators-and-relations">1.9 Generators and relations</h1><p>这是比较难读的一节。这一节证明了满足 deletion 条件的群一定是 Coxeter群。即任何形如 <span class="math display">\[s_1s_2\cdots s_r=1\]</span>的关系，都可以通过 <span class="math inline">\((s_\alphas_\beta)^{m_{\alpha,\beta}}=1\)</span> 中的关系推导出来。</p><p>若不然设 <span class="math display">\[s_1s_2\cdots s_r=1,\quadr=2q\]</span> 是一个长度最短的反例。这里 <span class="math inline">\(r\)</span> 必须是偶数，因为每个 <span class="math inline">\(\det s_i=-1\)</span>。</p><p>我们将证明有 <span class="math inline">\(s_1=s_3=\cdots\)</span> 以及<span class="math inline">\(s_2=s_4=\cdots\)</span> 成立，把上述关系变成<span class="math inline">\((s_1s_2)^q=1\)</span>，从而得出矛盾。</p><ul><li><p>我们只要证明 <span class="math inline">\(s_1=s_3\)</span>即可。然后将结论用在 <span class="math inline">\(s_2s_3\cdotss_rs_1=1\)</span> 上得到 <span class="math inline">\(s_2=s_4\)</span>；再进一步用在 <span class="math inline">\(s_3s_4\cdots s_rs_2s_1=1\)</span> 上得到 <span class="math inline">\(s_3=s_5\)</span>，等等。</p></li><li><p>为此我们只要证明如下两个等式：</p><p>(I). <span class="math inline">\(s_1s_2\cdots s_q=s_2s_3\cdotss_{q+1}\)</span>.</p><p>(II). <span class="math inline">\(s_3s_2\cdots s_q=s_2s_3\cdotss_{q+1}\)</span>.</p><p>这两个式子几乎是一样的，只有最左边一个是 <span class="math inline">\(s_1\)</span>，另一个是 <span class="math inline">\(s_3\)</span>。所以如果它们都成立，就有 <span class="math inline">\(s_1=s_3\)</span>。</p></li><li><p>为了证明 I，我们把 <span class="math inline">\(s_1\cdotss_r=1\)</span> 改写为 <span class="math display">\[s_1\cdots s_{q+1} =s_r\cdots s_{q+2}.\]</span> 左边是 <span class="math inline">\(q+1\)</span> 项的乘积，右边是 <span class="math inline">\(q-1\)</span> 项的乘积，所以 <span class="math inline">\(l(s_1\cdots s_{q+1})\leqq-1\)</span>。根据删除条件，存在 <span class="math inline">\(1\leqi&lt;j\leq m+1\)</span> 使得有 <span class="math display">\[s_i\cdotss_j = s_{i+1}\cdots s_{j-1}. \tag{$\ast$}\]</span> 我们希望说明有 <span class="math inline">\(i=1,j=q+1\)</span> 成立，从而 I 成立。若不然，则<span class="math inline">\((\ast)\)</span> 式至多包含 <span class="math inline">\(2q-2=r-2\)</span> 项，从而可以由 Coxeter 关系<span class="math inline">\(\{(s_\alphas_\beta)^{m_{\alpha,\beta}}=1\mid \alpha,\beta\in\Delta\}\)</span>推导出来。当然和 <span class="math inline">\((\ast)\)</span> 式等价的<span class="math display">\[s_1\cdots s_r =s_1\cdots\hat{s_i}\cdots\hat{s_j}\cdots s_r.\]</span> 也可以从 Coxeter关系推导出来。但是我们已知 <span class="math display">\[s_1\cdots s_r =s_1\cdots\hat{s_i}\cdots\hat{s_j}\cdots s_r=1.\]</span> 根据 <span class="math inline">\(r\)</span> 的选取，长度小于 <span class="math inline">\(r\)</span> 的关系 <span class="math inline">\(s_1\cdots\hat{s_i}\cdots\hat{s_j}\cdotss_r=1\)</span> 可以由 Coxeter 关系推导得到，从而 <span class="math inline">\(s_1\cdots s_r =1\)</span>也可以，这导致了矛盾，从而 I 得证。</p></li><li><p>为了证明 II，将 <span class="math inline">\(s_1\cdots s_r=1\)</span> 改写为 <span class="math inline">\(s_2\cdotss_rs_1=1\)</span>，仿照 I 的证明，我们可以得到 <span class="math display">\[s_2\cdots s_{q+1} = s_3(s_4\cdotss_{q+2}).\]</span> 把 <span class="math inline">\(s_3\)</span>挪到左边的前面，把 <span class="math inline">\(s_4\cdotss_{q+2}\)</span> 挪到左边的后面，得到 <span class="math display">\[s_3s_2\cdots s_{q+1}s_{q+2}\cdots s_4 =1.\]</span> 仍然和 I 的证明同理，我们可以得到 <span class="math display">\[s_3s_2\cdots s_q = s_2\cdots s_{q+1}.\]</span>这就是 II 中的等式。</p></li></ul><h1 id="subgraphs">2.6 Subgraphs</h1><p>在本节中，<span class="math inline">\(\Gamma\)</span> 是一个不可约Coxeter 图，内积 <span class="math inline">\((\alpha_s,\alpha_t)=-\cos\frac{\pi}{m_{s,t}}\)</span>是半正定的，但不是正定的。</p><p>记 <span class="math inline">\(N=\{v\in V\mid (v,v)=0\}\)</span> 以及<span class="math display">\[\mathrm{rad}(V)=\{v\in V\mid (v, u)=0\text{ for all } u \in V\}.\]</span> 显然 <span class="math inline">\(\mathrm{rad}(V)\)</span> 总是 <span class="math inline">\(V\)</span> 的子空间并且 <span class="math inline">\(\mathrm{rad}(V)\subset N\)</span>，但是一般来说<span class="math inline">\(N\)</span> 并不是 <span class="math inline">\(V\)</span> 的子空间。</p><p>但是在内积半正定时，我们有如下的结论：</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>若内积半正定，则 <span class="math inline">\(N=\mathrm{rad}(V)\)</span>。</p></div><p>证明：只要证明 <span class="math inline">\(N\subset\mathrm{rad}(V)\)</span> 即可，即若 <span class="math inline">\(u\in V\)</span> 满足 <span class="math inline">\((u,u)=0\)</span>，则对任何 <span class="math inline">\(v\in V\)</span> 都有 <span class="math inline">\((u,v)=0\)</span>。若不然，设 <span class="math inline">\(v\)</span> 满足 <span class="math inline">\((u,v)\ne0\)</span>，我们给 <span class="math inline">\(v\)</span> 乘以适当实数使得 <span class="math inline">\((u,v)=1\)</span>。设 <span class="math inline">\(k\)</span> 是实数，考虑向量 <span class="math inline">\(z=ku +v\)</span>： <span class="math display">\[(z,z)=(ku+v,ku+v) = (v,v) + 2k.\]</span>所以只要选择 <span class="math inline">\(k\)</span> 满足 <span class="math inline">\(2k &lt; -(v,v)\)</span> 就有 <span class="math inline">\((z,z)&lt;0\)</span>，这与内积的半正定性矛盾。<span class="math inline">\(\blacksquare\)</span></p><p>这一节的主要结论是：</p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span></p><ol type="1"><li><span class="math inline">\(\mathrm{rad}(V)\)</span>是一维的，由一个向量 <span class="math inline">\(\delta=\sum_{s\inS}c_s\alpha_s\)</span> 生成，并且每个系数 <span class="math inline">\(c_s\)</span> 都大于 0。</li><li><span class="math inline">\(\Gamma\)</span>删去任意多个顶点后得到的子图是正定的。</li></ol></div><p>这里给出一个不同于 Humphreys 书上的证明。</p><p>1 的证明：</p><p>设 <span class="math inline">\(u=\sum_{s\inS}c_s\alpha_s\in\mathrm{rad}(V)\)</span> 是一个非零向量，记 <span class="math display">\[I_+=\{s\in S\mid c_s&gt;0\},\quad I_-=\{s\inS\mid c_s&lt;0\},\quad I_0=\{s\in S\mid c_s=0\}.\]</span> <span class="math display">\[u_+=\sum_{s\in I_+}c_s\alpha_s,\quadu_-=\sum_{s\in I_-}c_s\alpha_s.\]</span> 则 <span class="math inline">\(u=u_++u_-\)</span>，并且 <span class="math display">\[(u_+,u_-)=\sum_{c\in I_+}\sum_{t\inI_-}\underbrace{c_sc_t}_{&lt;0}\,\underbrace{\alpha_s\alpha_t}_{\leq0}\geq0.\]</span></p><p>由于 <span class="math inline">\(u\in\mathrm{rad}(V)\)</span> 所以<span class="math inline">\((u,u)=0\)</span>，即 <span class="math display">\[(u,u)=(u_+,u_+)+(u_-,u_-)+2(u_+,u_-)=0.\]</span>根据半正定性和上面的分析，上式的三项都是非负的，所以只能是 <span class="math display">\[(u_+,u_+)=(u_-,u_-)=(u_+,u_-)=0.\]</span></p><p>此外 <span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 中至少有一个非空，不妨设 <span class="math inline">\(I_+\ne\emptyset\)</span>，我们来证明 <span class="math inline">\(I_-\)</span> 和 <span class="math inline">\(I_0\)</span> 必须都是空集。</p><p>若不然，<span class="math inline">\(I_-\cup I_0\)</span> 非空，任取<span class="math inline">\(t\in I_-\cup I_0\)</span>，设 <span class="math inline">\(\delta\)</span> 是正数，考虑向量 <span class="math inline">\(z=u_+ +\delta\alpha_t\)</span>。我们有</p><p><span class="math display">\[(z,z)=\delta^2+2\delta(u_+,\alpha_t)=\delta^2+2\delta\sum_{s\inI_+}\underbrace{c_s}_{&gt;0}\underbrace{(\alpha_s,\alpha_t)}_{\leq0}.\]</span>注意到每一项 <span class="math inline">\(c_s(\alpha_s,\alpha_t)\leq0\)</span>，所以 <span class="math inline">\(\sum_{s\inI_+}c_s(\alpha_s,\alpha_t)\leq0\)</span>，并且如果存在 <span class="math inline">\(s\in I_+\)</span> 使得 <span class="math inline">\(s\)</span> 与 <span class="math inline">\(t\)</span> 之间有边相连的话则 <span class="math inline">\(\sum_{s\in I_+}c_s(\alpha_s,\alpha_t)\)</span>严格小于 0。这时取 <span class="math inline">\(\delta\)</span>足够小可以使得 <span class="math inline">\((z,z)&lt;0\)</span>，这与内积<span class="math inline">\((,)\)</span>是半正定的矛盾。所以必须是对每个 <span class="math inline">\(s\inI_+\)</span> 有 <span class="math inline">\((\alpha_s,\alpha_t)=0\)</span>。由 <span class="math inline">\(t\)</span> 的任意性可得 <span class="math inline">\(I_-\cup I_0\)</span> 与 <span class="math inline">\(I_+\)</span> 互不连通，但这又与 <span class="math inline">\(\Gamma\)</span> 不可约矛盾。</p><p>总之我们证明了 <span class="math inline">\(\mathrm{rad}(V)\)</span>中非零向量的系数必须同时为正或者同时为负。</p><p>如果 <span class="math inline">\(\mathrm{rad}(V)\)</span>包含两个线性无关的向量 <span class="math inline">\(u,v\)</span>，根据上面的证明，我们可以不妨设 <span class="math inline">\(u,v\)</span>的各项系数都是正数。适当缩放以后我们可以让 <span class="math inline">\(u,v\)</span> 的 <span class="math inline">\(\alpha_1\)</span> 项系数都是 1。于是 <span class="math inline">\(u-v\)</span> 也在 <span class="math inline">\(\mathrm{rad}(V)\)</span> 中，并且其 <span class="math inline">\(\alpha_1\)</span> 项系数是 0，这就导致了矛盾。</p><p>2 的证明：</p><p>我们只要证明若 <span class="math inline">\(I\subsetneqq\Gamma\)</span> 是真子集，则对任何非零向量 <span class="math inline">\(u=\sum_{s\in I}c_s\alpha_s\)</span> 都有 <span class="math inline">\((u,u)&gt;0\)</span>。若不然，<span class="math inline">\(u=\sum_{s\in I}c_s\alpha_s+\sum_{t\notinI}0\cdot\alpha_t\)</span> 并且 <span class="math inline">\((u,u)=0\)</span>，这与 <span class="math inline">\(u\)</span> 的系数必须全部非零矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 id="uniqueness-of-the-degrees">3.7 Uniqueness of the degrees</h1><p>这一节介绍了不变多项式环 <span class="math inline">\(S^G\)</span>的任何一组齐次生成元的次数 <span class="math inline">\(d_1,d_2,\ldots,d_n\)</span>是唯一确定的。证明不难，但是采用的方法很典型，以后会反复用到。</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(f_1,\ldots,f_n\inK[x_1,\ldots,x_n]\)</span> 是一组齐次、代数无关的多项式；其次数分别为<span class="math inline">\(d_1,\ldots,d_n\)</span>；<span class="math inline">\(g_1,\ldots,g_n\)</span>是另一组齐次、代数无关的多项式，次数分别为 <span class="math inline">\(e_1,\ldots,e_n\)</span>，并且每个 <span class="math inline">\(g_i\)</span> 可以写成 <span class="math inline">\(f_1,\ldots,f_n\)</span> 的多项式，则适当重排以后有<span class="math inline">\(e_i\geq d_i\)</span>。</p></div><p>证明：利用链式法则对导可得 <span class="math display">\[\frac{\partial g_i}{\partial x_k} = \sum_{j=1}^n\frac{\partial g_i}{\partial f_j}\frac{\partial f_j}{\partialx_k}.\]</span></p><p>由于 <span class="math inline">\(g_1,\ldots,g_n\)</span>代数无关，根据 Jacobian 判定左边的矩阵 <span class="math inline">\(\left(\frac{\partial g_i}{\partialx_k}\right)\)</span> 可逆，从而右边的矩阵 <span class="math inline">\(\left(\frac{\partial g_i}{\partialf_j}\right)\)</span> 也可逆，其行列式非零，于是存在置换 <span class="math inline">\(\pi\)</span> 使得 <span class="math display">\[\prod_{i=1}^n\frac{\partial g_i}{\partialf_{\pi(i)}}\ne0.\]</span> 适当重排 <span class="math inline">\(g_1,\ldots,g_n\)</span> 以后可以不妨设 <span class="math inline">\(\pi\)</span> 是恒等置换，即 <span class="math display">\[\prod_{i=1}^n\frac{\partial g_i}{\partialf_{i}}\ne0.\]</span> 这说明每个 <span class="math inline">\(\frac{\partial g_i}{\partialf_i}\ne0\)</span>，即当把 <span class="math inline">\(g_i\)</span> 写成<span class="math inline">\(f_1,\ldots, f_n\)</span> 的多项式时，<span class="math inline">\(f_i\)</span> 一定出现在其中。于是至少存在一个形如<span class="math display">\[f_1^{k_1}\cdots f_n^{k_n},\quad k_i\geq1\]</span> 的单项式，它出现在 <span class="math inline">\(g_i\)</span>的表达式中，并且不会被抵消掉。从而 <span class="math inline">\(e_i=\sumk_id_i\geq d_i\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="unique-degrees" class="unnumbered statement corollary-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span><span class="math inline">\(S^G\)</span>的任何一组齐次、代数无关生成元的次数是唯一却定的。</p></div><h1 id="coxeter-elements">3.16 Coxeter elements</h1><p>我们来证明任何两个 Coxeter 元都是共轭的。我们只要取一个特殊的 Coxeter元，并证明其它 Coxeter 元都和这个特殊元共轭即可。</p><p>首先，取 Coxeter 图 <span class="math inline">\(\Gamma\)</span>的一个叶节点，将其记作 <span class="math inline">\(s_n\)</span>。从<span class="math inline">\(\Gamma\)</span> 中移走 <span class="math inline">\(s_n\)</span> 以后，剩下的部分 <span class="math inline">\(\Gamma_1=\Gamma-\{s_n\}\)</span>仍然是一个树，于是我们又可以取其叶节点，记作 <span class="math inline">\(s_{n-1}\)</span>。<span class="math inline">\(\Gamma_1-\{s_{n-1}\}\)</span>仍然是树，又可以取其一个叶节点 <span class="math inline">\(s_{n-2}\)</span>，以此类推。即我们将生成元排列为<span class="math inline">\(s_1,\ldots,s_n\)</span>，使得对每个 <span class="math inline">\(1\leq i\leq n\)</span>，<span class="math inline">\(s_1,\ldots,s_i\)</span> 构成 <span class="math inline">\(\Gamma\)</span> 的一个子树，并且 <span class="math inline">\(s_i\)</span> 是这个树的叶节点。</p><p>首先我们注意到任何 Coxeter 元都可以通过循环移位共轭于某个以 <span class="math inline">\(s_n\)</span> 结尾的 Coxeter 元 <span class="math inline">\(s_{i_1}\cdotss_{i_{n-1}}s_n\)</span>，我们来证明这样的元素都共轭于 <span class="math inline">\(s_1s_2\cdots s_n\)</span>。</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>任何形如 <span class="math inline">\(s_{i_1}\cdotss_{i_{n-2}}{\color{blue}s_{i_{n-1}}}s_n\)</span> 的 Coxeter 元共轭于<span class="math display">\[{\color{blue}s_{i_{n-1}}}s_{i_1}\cdotss_{i_{n-2}}s_n.\]</span></p></div><p>引理的证明：如果 <span class="math inline">\(s_{i_{n-1}}\)</span> 与<span class="math inline">\(s_n\)</span> 交换，那么 <span class="math display">\[s_{i_1}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}s_n\to s_{i_1}\cdotss_{i_{n-2}}s_n\textcolor{blue}{s_{i_{n-1}}}\to\textcolor{blue}{s_{i_{n-1}}}s_{i_1}\cdots s_{i_{n-2}}s_n.\]</span>结论成立。否则 <span class="math inline">\(s_n\)</span> 与 <span class="math inline">\(s_{i_1}\sim s_{i_{n-2}}\)</span> 都交换，所以<span class="math display">\[\begin{aligned}s_{i_1}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}\textcolor{red}{s_n}&amp;\to\textcolor{red}{s_n}s_{i_1}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}\to s_{i_1}\textcolor{red}{s_n}\cdotss_{i_{n-2}}\textcolor{blue}{s_{i_{n-1}}}\\&amp;\to s_{i_1}\cdotss_{i_{n-2}}\textcolor{red}{s_n}\textcolor{blue}{s_{i_{n-1}}}\\&amp;\to\textcolor{blue}{s_{i_{n-1}}}s_{i_1}\cdotss_{i_{n-2}}\textcolor{red}{s_n}.\end{aligned}\]</span> 结论同样成立。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(k\geq1\)</span>，任何形如 <span class="math inline">\(s_{i_1}\cdots\textcolor{blue}{s_{i_{n-k}}}s_{n-k+1}\cdots s_n\)</span> 的 Coxeter 元都共轭于 <span class="math display">\[\textcolor{blue}{s_{i_{n-k}}} s_{i_1}\cdotss_{i_{n-k-1}}s_{n-k+1}\cdots s_n.\]</span></p></div><p><span class="math inline">\(k=1\)</span>的情形在前一个的引理中已经证明了。对 <span class="math inline">\(k\geq2\)</span> 用归纳法，假设结论对小于 <span class="math inline">\(k\)</span> 的情形成立。</p><p>如果 <span class="math inline">\(s_{i_{n-k}}\)</span> 和 <span class="math inline">\(s_{n-k+1}\)</span> 交换，那么 <span class="math display">\[s_{i_1}\cdots \textcolor{blue}{s_{i_{n-k}}}s_{n-k+1}\cdots s_n\to s_{i_1}\cdotss_{n-k+1}\textcolor{blue}{s_{i_{n-k}}}\cdots s_n.\]</span></p><p>然而对 <span class="math inline">\(k-1\)</span>的情形应用归纳假设，上面右边共轭于 <span class="math display">\[\textcolor{blue}{s_{i_{n-k}}} s_{i_1}\cdotss_{n-k+1}\cdots s_n.\]</span> 于是结论成立。</p><p>如果 <span class="math inline">\(s_{i_{n-k}}\)</span> 和 <span class="math inline">\(s_{n-k+1}\)</span> 不交换，那么 <span class="math inline">\(s_{n-k+1}\)</span> 和所有 <span class="math inline">\(s_{i_1}\sim s_{i_{n-k-1}}\)</span>都交换，于是直接用归纳假设有 <span class="math display">\[s_{i_1}\cdots\textcolor{blue}{s_{i_{n-k}}}\textcolor{red}{s_{n-k+1}}\cdotss_n\to\textcolor{red}{s_{n-k+1}}s_{i_1}\cdots\textcolor{blue}{s_{i_{n-k}}}\cdotss_n\tos_{i_1}\cdots\textcolor{red}{s_{n-k+1}}\textcolor{blue}{s_{i_{n-k}}}\cdotss_n.\]</span> 再一次应用归纳假设，上面右边共轭于 <span class="math display">\[\textcolor{blue}{s_{i_{n-k}}}s_{i_1}\cdots\textcolor{red}{s_{n-k+1}}\cdotss_n.\]</span> 结论同样成立。<span class="math inline">\(\blacksquare\)</span></p><p>这样一来，下面的结论就是显然的了：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>任何 Coxeter 元都共轭于 <span class="math inline">\(s_1\cdotss_n\)</span>。</p></div><h1 id="acting-on-a-plane">3.17 Acting on a plane</h1><p>一点预备知识：如果 <span class="math inline">\(V\)</span>上有一个非退化的双线性型，矩阵 <span class="math inline">\(B=((\alpha_i,\beta_j))\)</span> 是两组基 <span class="math inline">\(\{\alpha_i\},\,\{\beta_j\}\)</span>之间两两内积得到的矩阵，设 <span class="math inline">\(\{\gamma_k\}\)</span> 是 <span class="math inline">\(\{\beta_j\}\)</span> 的对偶基，则 <span class="math display">\[(\alpha_i,\beta_j)=({\bfB}\gamma_i,\beta_j).\]</span> 这说明 <span class="math inline">\(B\)</span> 是线性变换 <span class="math inline">\({\bf B}\gamma_k=\beta_k\)</span> 在 <span class="math inline">\(\{\gamma_k\}\)</span> 这组基下的矩阵。</p><p>设 <span class="math inline">\(A=(a_{ij})_{1\leq i,j\leqn}=((\alpha_i,\alpha_j))\)</span> 是 Cartan 矩阵，<span class="math inline">\(\{\omega_i\}_{i=1}^n\)</span> 是关于 <span class="math inline">\(\Delta=\{\alpha_i\}_{i=1}^n\)</span>的对偶基。<span class="math inline">\(A\)</span> 正是 <span class="math inline">\(V\)</span> 上线性变换 <span class="math inline">\(\bf A\)</span> 在基 <span class="math inline">\(\{\omega_i\}\)</span> 下的矩阵： <span class="math display">\[a_{ij}=(\alpha_i,\alpha_j)=({\bfA}\omega_i,\alpha_j).\]</span> 我们知道矩阵 <span class="math inline">\(A\)</span> 有一个特征值 <span class="math inline">\(c\)</span>，它对应的特征向量 <span class="math inline">\((c_1,\ldots, c_n)\)</span> 的分量 <span class="math inline">\(c_i\)</span> 都是大于 0 的，于是 <span class="math inline">\(\sum_{i=1}^nc_i\omega_i\)</span> 是变换 <span class="math inline">\({\bf A}\)</span> 的特征向量： <span class="math display">\[{\bf A}\sum_{i=1}^nc_i\omega_i =\sum_{i=1}^ncc_i\omega_i.\]</span> 另一方面 <span class="math inline">\({\bfA}\sum_{i=1}^nc_i\omega_i=\sum_{i=1}^nc_i\alpha_i\)</span>，所以 <span class="math display">\[\sum_{i=1}^nc_i\alpha_i =\sum_{i=1}^ncc_i\omega_i.\]</span> 两边用某个 <span class="math inline">\(\alpha_j,\,(j\in J)\)</span> 作内积，并注意到<span class="math inline">\(\alpha_j\)</span> 与 <span class="math inline">\(J\)</span> 中除自己之外其它 <span class="math inline">\(J\)</span> 中的 <span class="math inline">\(\alpha_i\)</span> 正交，得到 <span class="math display">\[cc_j=\sum_{i=1}^nc_i(\alpha_i,\alpha_j)=c_j +\sum_{i\in I}c_ia_{ij}.\]</span> 即 <span class="math display">\[(c-1)c_j = \sum_{i\in I}c_ia_{ij}.\]</span>两边乘以 <span class="math inline">\(\omega_j\)</span> 并对 <span class="math inline">\(j\in J\)</span> 求和，然后交换和号得到 <span class="math display">\[\begin{aligned}(c-1)\sum_{j\in J}c_j\omega_j &amp;= \sum_{j\in J}\left(\sum_{i\inI}c_ia_{ij}\right)\omega_j\\&amp;=\sum_{i\in I}c_i\left(\sum_{j\in J}a_{ij}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\sum_{j=1}^n a_{ij}\omega_j- \sum_{j\inI}a_{ij}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\alpha_i- \sum_{j\inI}a_{ij}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\alpha_i- \omega_i-\sum_{j\in I,\,j\nei}\underbrace{a_{ij}}_{=0}\omega_j\right)\\&amp;=\sum_{i\in I}c_i\left(\alpha_i- \omega_i\right)\\&amp;=\sum_{i\in I}c_i\alpha_i- \mu.\\\end{aligned}\]</span> 即 <span class="math inline">\((c-1)\nu + \mu =\sum_{i\in I}c_i\alpha_i\)</span>。注意到 <span class="math inline">\(\sum_{i\in I}c_i\alpha_i\)</span> 被 <span class="math inline">\(x=\prod_{i\in I}s_i\)</span> 映射为它的负 <span class="math inline">\(-\sum_{i\in I}c_i\alpha_i\)</span>。此外 <span class="math inline">\(x\)</span> 保持 <span class="math inline">\(\nu\)</span> 不动，所以 <span class="math inline">\(x\)</span> 保持 <span class="math inline">\(\mu,\nu\)</span> 生成的二维子空间 <span class="math inline">\(P\)</span> 不变。<span class="math inline">\(x\)</span> 作为 <span class="math inline">\(P\)</span> 上的正交变换保持直线 <span class="math inline">\(\nu\)</span> 上的点不动，所以 <span class="math inline">\(x\)</span> 限制在 <span class="math inline">\(P\)</span> 上是一个反射。同理 <span class="math inline">\(y\)</span> 也是如此。所以 <span class="math inline">\(w^t=xy\)</span> 在 <span class="math inline">\(P\)</span> 上的作用是一个旋转。设这个旋转角度是<span class="math inline">\(2\pi/h\)</span>，则 <span class="math inline">\(w^t\)</span> 在 <span class="math inline">\(P\)</span> 上的阶是 <span class="math inline">\(h\)</span>。</p><p>又因为 <span class="math inline">\(\mu+\nu\)</span> 严格属于 <span class="math inline">\(C\cap P\)</span>，所以它在 <span class="math inline">\(w^t\)</span> 作用下一定在 <span class="math inline">\(V\)</span> 中有 <span class="math inline">\(k\)</span> 个不同的像，即 <span class="math inline">\(P\)</span> 上的阶等于它在 <span class="math inline">\(V\)</span> 上的阶。</p><h1 id="the-coxeter-number">3.18 The Coxeter number</h1><p>这一节证明了如下结论：对一个有限 Coxeter 群，正根的个数 <span class="math inline">\(N=|\Phi^+|\)</span>，Coxeter 数 <span class="math inline">\(h\)</span>，单根的个数 <span class="math inline">\(n=|\Delta|\)</span> 满足 <span class="math display">\[N = \frac{nh}{2}.\]</span></p><p>回忆 <span class="math inline">\(y=s_1\cdots s_r,z=s_{r+1}\cdotss_n\)</span> 在 <span class="math inline">\(P\)</span>上的作用都是反射，它们在 <span class="math inline">\(P\)</span>上生成的群是二面体群 <span class="math inline">\(I_2(h)\)</span>，这个群包含 <span class="math inline">\(h\)</span> 个反射和 <span class="math inline">\(h\)</span> 个旋转。记 <span class="math inline">\(I_2(h)\)</span> 中的 <span class="math inline">\(h\)</span> 个反射对应的超平面在 <span class="math inline">\(P\)</span> 上的截线分别是 <span class="math inline">\(L_1,\ldots,L_h\)</span>，这些 <span class="math inline">\(L_i\)</span> 是 <span class="math inline">\(I_2(h)\)</span> 作用在直线 <span class="math inline">\(L=\mathbb{R}\lambda\)</span> 和 <span class="math inline">\(M=\mathbb{R}\mu\)</span> 上得到的。设 <span class="math inline">\(\beta\in\Phi\)</span>，我们来分析 <span class="math inline">\(\beta\)</span> 对应的超平面 <span class="math inline">\(H_\beta\)</span> 在 <span class="math inline">\(P\)</span> 上的截线是什么。</p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span>对任何 <span class="math inline">\(\beta\in\Phi\)</span>，<span class="math inline">\(H_\beta\cap P\in \{L_1,\ldots,L_h\}\)</span>。</p></div><p>证明：首先注意到 <span class="math inline">\(P\)</span> 不可能包含在<span class="math inline">\(H_\beta\)</span> 中。因为 <span class="math inline">\(P\)</span> 和基本区域 <span class="math display">\[C=\{v\in V\mid (\alpha, v)&gt;0 \text { for all}\alpha\in\Delta\}\]</span> 的交是 <span class="math display">\[P\capC=\{a\lambda + b\mu\mid a&gt;0,b&gt;0\}.\]</span> 它当然是非空的，而<span class="math inline">\(H_\beta\)</span> 不可能包含 <span class="math inline">\(C\)</span> 中的点，所以 <span class="math inline">\(H_\beta\cap P\)</span> 是 <span class="math inline">\(P\)</span> 的一条截线。</p><p>其次如果这条截线不是上述 <span class="math inline">\(\{L_i\}\)</span>任何之一，那么我们可以用 <span class="math inline">\(y,z\)</span>的某个组合将其变换到 <span class="math inline">\(P\cap C\)</span>中，这相当于用某个 <span class="math inline">\(w\in I_2(h)\)</span> 使得<span class="math inline">\(\gamma=w\beta\)</span> 的超平面 <span class="math inline">\(H_\gamma\)</span> 与 <span class="math inline">\(P\)</span> 的交线穿过 <span class="math inline">\(P\cap C\)</span>，这与任何根的镜面与 <span class="math inline">\(C\)</span> 之交为空集矛盾。<span class="math inline">\(\blacksquare\)</span></p><p>我们只要讨论哪些 <span class="math inline">\(H_\beta\)</span> 满足<span class="math inline">\(H_\beta\cap P =L\)</span> 或者 <span class="math inline">\(H_\beta\cap P =M\)</span> 即可。其它的 <span class="math inline">\(L_i\)</span> 由于形如 <span class="math inline">\(L_i=wL\)</span> 或者 <span class="math inline">\(L_i=wM\)</span>，这里 <span class="math inline">\(w\in I_2(h)\)</span>，所以对应的是 <span class="math inline">\(wH_\beta\)</span>。</p><p>如果 <span class="math inline">\(H_\beta\cap P = L\)</span>，则反射<span class="math inline">\(s_\beta\)</span> 保持 <span class="math inline">\(L\)</span> 不动。这时 <span class="math inline">\((\beta,\lambda=0)\)</span>。设 <span class="math inline">\(\beta=\sum\limits_{i=1}^n a_i\alpha_i (a_i\geq0)\)</span>，由于 <span class="math inline">\(\lambda=\sum_{i\inI}c_i\omega_i\)</span>，所以 <span class="math display">\[(\beta,\lambda) = \sum_{i\in I} a_ic_i=0.\]</span> 由于 <span class="math inline">\(c_i(1\leq i\leq n)\)</span>都是正的，所以必须对每个 <span class="math inline">\(i\in I\)</span> 有<span class="math inline">\(a_i=0\)</span>，即 <span class="math inline">\(\beta\)</span> 是 <span class="math inline">\(\{\alpha_j,j\in J\}\)</span> 的线性组合，从而<span class="math inline">\(\beta\)</span> 属于标准椭圆子群 <span class="math inline">\(J\)</span> 的根系 <span class="math inline">\(\Phi_J\)</span>。但是 <span class="math inline">\(J\)</span> 中的生成元两两交换，<span class="math inline">\(\Phi_J\)</span> 中的正根只有 <span class="math inline">\(\{\alpha_j,j\in J\}\)</span>，所以满足 <span class="math inline">\(H_\beta\cap P=L\)</span> 的正根 <span class="math inline">\(\beta\)</span> 有 <span class="math inline">\(|J|=n-r\)</span> 个。</p><p>同样的分析可得满足 <span class="math inline">\(H_\beta\capP=M\)</span> 的正根 <span class="math inline">\(\beta\)</span> 有 <span class="math inline">\(|I|=r\)</span> 个。</p><p>当 <span class="math inline">\(h\)</span> 是偶数时，<span class="math inline">\(I_2(h)\)</span> 在 <span class="math inline">\(\{L_1,\ldots,L_h\}\)</span>上的作用分成两个长度同为 <span class="math inline">\(h/2\)</span>的轨道，分别由 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span> 生成，<span class="math inline">\(L\)</span> 所在的轨道每个超平面来自 <span class="math inline">\(n-r\)</span> 个正根，<span class="math inline">\(M\)</span> 所在的轨道每个超平面来自 <span class="math inline">\(r\)</span> 个正根，所以一共是 <span class="math inline">\(h(n-r)/2 + hr/2 = nh/2=N\)</span> 个正根。</p><p>当 <span class="math inline">\(h\)</span> 是奇数时，<span class="math inline">\(I_2(h)\)</span> 传递地作用在 <span class="math inline">\(\{L_1,\ldots,L_h\}\)</span> 上，所以 <span class="math inline">\(L\)</span> 和 <span class="math inline">\(M\)</span> 来自同样数目的正根，即 <span class="math inline">\(r=n-r\)</span>，所以 <span class="math inline">\(r=n/2\)</span>。同样地 <span class="math inline">\(N=nh/2\)</span>。</p><p>这里需要对 <span class="math inline">\(h\)</span>的奇偶性分别讨论是因为在二面体群中，奇数时两个生成元是共轭的，偶数时则不共轭。</p><h1 id="eigenvalues-of-coxeter-elements">3.19 Eigenvalues of Coxeterelements</h1><p>设 <span class="math inline">\(u,v\)</span> 是 Coxeter 平面 <span class="math inline">\(P\)</span> 的一组正交基，则 <span class="math inline">\(z=u+iv\)</span> 是 <span class="math inline">\(w\)</span> 在 <span class="math inline">\(V_{\mathbb{C}}\)</span> 上的特征向量，特征值为<span class="math inline">\(e^{2\pi i/h}\)</span>。对任何 <span class="math inline">\(\beta\in\Phi^+\)</span>，<span class="math inline">\((\beta,z)=(\beta,u) + (\beta,v)i\ne0\)</span>，否则会导致 <span class="math inline">\(P\inH_\beta\)</span>，与 <span class="math inline">\(P\cap C\)</span>非空矛盾。</p><p>设 <span class="math inline">\(\{v_i\}\)</span> 是 <span class="math inline">\(V\)</span> 的一组基，<span class="math inline">\(\{x_i\}\in V^\ast\)</span> 是对偶基：<span class="math inline">\(x_i(v_j)=\delta_{ij}\)</span>。<span class="math inline">\(x_1,\cdots,x_n\)</span>是坐标函数，它们是代数无关的：<span class="math inline">\(\mathbb{C}[x_1,\cdots,x_n]\)</span>是一个多项式环。我们把 <span class="math inline">\(\mathbb{C}[x_1,\cdots,x_n]\)</span> 称作 <span class="math inline">\(V\)</span> 上的坐标环，简记作 <span class="math inline">\(\mathbb{C}[V]\)</span>。设 <span class="math inline">\(G\subset GL(V)\)</span>是一个有限的可逆线性变换群，则 <span class="math inline">\(G\)</span>也作用在 <span class="math inline">\(\mathbb{C}[V]\)</span>上：对任何多项式 <span class="math inline">\(f\in\mathbb{C}[V]\)</span>，定义 <span class="math inline">\(g\)</span> 在<span class="math inline">\(f\)</span> 上作用的结果 <span class="math inline">\(g\cdot f\)</span> 为</p><p><span class="math display">\[g\cdot f(v)=f(g^{-1}v).\]</span> 对<span class="math inline">\(f=\sum a_{i_1\cdots i_n}x_1^{i_1}\cdotsx_n^{i_n}\in\mathbb{C}[V]\)</span>，<span class="math inline">\(f\)</span> 在 <span class="math inline">\(v=\sum_{i}c_iv_i\)</span> 处的值为 <span class="math display">\[f(v)=\sum a_{i_1\cdots i_n}x_1(v)^{i_1}\cdotsx_n(v)^{i_n} = \sum a_{i_1\cdots i_n}c_1^{i_1}\cdots c_n^{i_n}.\]</span>于是如果不含常数项的多项式 <span class="math inline">\(f\in\mathbb{C}[V]\)</span> 满足 <span class="math inline">\(f(v_1)\ne 0\)</span>，则若 <span class="math inline">\(f=\sum a_{i_1\cdots i_n}x_1^{i_1}\cdotsx_n^{i_n}\)</span>，我们有 <span class="math display">\[0\ne f(v_1)=\suma_{i_1\cdots i_n}x_1^{i_1}\cdotsx_n^{i_n}\mid_{x_1=1,x_2=\cdots=x_n=0}.\]</span> 即 <span class="math inline">\(f\)</span> 的单项式里面必有一项只含有 <span class="math inline">\(x_1\)</span>。</p><p>进一步，如果 <span class="math inline">\(\frac{\partial f}{\partialx_i}\)</span> 满足 <span class="math inline">\(\frac{\partialf}{\partial x_i}(v_1)\ne0\)</span>，那就说明 <span class="math inline">\(f\)</span> 的单项式里面必有一项形如 <span class="math inline">\(ax_1^{m}x_i\)</span>，即 <span class="math inline">\(f\)</span> 形如 <span class="math inline">\(f=ax_1^mx_i + \cdots\)</span>。</p><p>设 <span class="math inline">\(T\)</span> 是 <span class="math inline">\(V\)</span> 上可对角化的线性变换，<span class="math inline">\(Tv_i=\lambda_i v_i\)</span>，则 <span class="math inline">\(Tx_i=\lambda_i^{-1}x_i\)</span>。并且设 <span class="math inline">\(f\)</span> 是 <span class="math inline">\(T\)</span>- 不变的多项式，则 <span class="math display">\[f=T\cdot f =a\lambda_1^{-m}x_1^m\lambda_i^{-1}x_i + \cdots.\]</span> 比较即得 <span class="math display">\[ax_1^mx_i =a\lambda_1^{-m}x_1^m\lambda_i^{-1}x_i.\]</span> 即 <span class="math inline">\(1 = \lambda_1^{-m}\lambda_i^{-1}\)</span>，从而<span class="math inline">\(\lambda_i = \lambda_1^{-m}\)</span>。</p><p>对 Coxeter 元 <span class="math inline">\(w\)</span>，它的特征值是<span class="math inline">\(\{\zeta^{m_i},\,1\leq i\leqn\}\)</span>，并且 <span class="math inline">\(m_1=1,m_{n-1}=h-1\)</span>。<span class="math inline">\(m_1=1\)</span> 对应的是 <span class="math inline">\(w\)</span> 的重数为 1 的特征值 <span class="math inline">\(\zeta\)</span>。</p><p>以 <span class="math inline">\(w\)</span> 的特征向量为基，由于 <span class="math inline">\(\zeta\)</span> 对应的特征向量 <span class="math inline">\(v_1\)</span> 在 <span class="math inline">\(C\)</span> 内，它不在任何根平面 <span class="math inline">\(H_\alpha\)</span> 上，所以 Jacobian <span class="math inline">\(J=\det\left(\frac{\partial f_i}{\partialx_j}\right)\)</span> 在 <span class="math inline">\(v_1\)</span> 处不为0，于是某个 <span class="math inline">\(\prod_{i=1}^n \frac{\partialf_i}{\partial x_{\pi(j)}}\)</span> 在 <span class="math inline">\(v_1\)</span> 处不为 0，适当重排 <span class="math inline">\(f_i\)</span> 以后可以不妨设每个 <span class="math inline">\(\frac{\partial f_i}{\partialx_i}(v_1)\ne0\)</span>。根据上面的讨论，<span class="math inline">\(f_i\)</span> 形如 <span class="math display">\[f_i=ax_1^{d_i-1}x_i+\cdots.\]</span> 并且 <span class="math inline">\(\lambda_i=\zeta^{m_i}=\zeta^{1-d_i}\)</span>。从而 <span class="math inline">\(h-m_i\equiv d_i-1\pmodh\)</span>。我们知道对每个 <span class="math inline">\(i\)</span> 有<span class="math inline">\(0&lt;h-m_i&lt;h\)</span>，所以对每个 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(d_i-1\geq h-m_i\)</span>。另一方面，集合 <span class="math inline">\(\{h-m_i\}\)</span> 不过是集合 <span class="math inline">\(\{m_i\}\)</span> 的一个置换，所以 <span class="math display">\[\sum (h-m_i) = \sum m_i = \sum(d_i-1).\]</span>这只能是对每个 <span class="math inline">\(i\)</span> 有 <span class="math inline">\(h-m_i=d_i-1\)</span>，即集合相等 <span class="math inline">\(\{d_i-1\}=\{m_i\}\)</span>。</p><h1 id="counting-hyperplanes">4.4 Counting hyperplanes</h1><p>回忆 <span class="math inline">\(\mathcal{H}\)</span> 是所有超平面<span class="math inline">\(\{H_{\alpha,k}\mid\alpha\in\Phi,k\in\mathbb{Z}\}\)</span> 组成的集合。其中 <span class="math display">\[H_{\alpha,k}=\{v\in V\mid(\alpha,v)=k\}.\]</span></p><div class="unnumbered statement lemma-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">引理</span>.</span><span class="statement-spah"></span><span class="math inline">\(H_s\)</span> 是 <span class="math inline">\(\mathcal{H}\)</span> 中唯一分隔 <span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 的超平面，即 <span class="math inline">\(\mathcal{L}(s)=\{H_s\}\)</span>。</p></div><p>证明：我们先说明对任何正根 <span class="math inline">\(\beta\ne\alpha_s\)</span>，以及任何 <span class="math inline">\(k\in\mathbb{Z}\)</span>，<span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 都在超平面 <span class="math inline">\(H_{\beta,k}\)</span> 的同一侧。</p><p>首先根据 <span class="math inline">\(A_o\)</span>的刻画，它满足对任何正根 <span class="math inline">\(\gamma\)</span>都有 <span class="math inline">\(0&lt;(A_o,\gamma)&lt;1\)</span>，特别地<span class="math inline">\(0&lt;(A_o,\beta)&lt;1\)</span>。由于 <span class="math inline">\(\beta\ne\alpha_s\)</span> 所以 <span class="math inline">\(s\beta\)</span> 仍然是正根，因此 <span class="math display">\[0&lt;(A_o,s\beta)&lt;1\Longrightarrow0&lt;(sA_o,\beta)&lt;1.\]</span> 这说明 <span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 在 <span class="math inline">\(H_\beta\)</span> 和 <span class="math inline">\(H_{\beta,1}\)</span>围成的带状区域中间。所以对任何 <span class="math inline">\(k\)</span>它们都在 <span class="math inline">\(H_{\beta,k}\)</span> 的同一侧。</p><p>另一方面不难看出 <span class="math inline">\(-1 &lt;(sA_o,\alpha_s)&lt;0\)</span>，也就是说 <span class="math inline">\(sA_o\)</span> 和 <span class="math inline">\(A_o\)</span> 位于 <span class="math inline">\(H_{\alpha_s,0}\)</span> 的两侧，但是对任何 <span class="math inline">\(k\ne0\)</span>，它们位于 <span class="math inline">\(H_{\alpha_s,k}\)</span> 的同侧。</p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>固定 <span class="math inline">\(s\in S_a\)</span>。对任何 <span class="math inline">\(w\in\widehat{W_a}\)</span>，有如下结论成立：</p><ul><li><span class="math inline">\(H_s\)</span> 恰好属于 <span class="math inline">\(\mathcal{L}(w)\)</span> 和 <span class="math inline">\(\mathcal{L}(sw)\)</span> 之一。</li><li><span class="math inline">\(s(\mathcal{L}(w)\setminus\{H_s\}) =\mathcal{L}(sw)\setminus\{H_s\}\)</span>。</li></ul></div><p>证明：第一点是显然的，因为 <span class="math inline">\(wA_o\)</span>和 <span class="math inline">\(swA_o\)</span> 位于 <span class="math inline">\(H_s\)</span> 的两侧，它俩有且恰有一个和 <span class="math inline">\(A_o\)</span> 位于 <span class="math inline">\(H_s\)</span> 的同一侧。</p><p>对于第二点，我们要证明的是 <span class="math inline">\(H\leftrightarrow sH\)</span> 给出了 <span class="math inline">\(\mathcal{L}(w)\)</span> 和 <span class="math inline">\(\mathcal{L}(sw)\)</span> 中除 <span class="math inline">\(H_s\)</span> 之外的超平面的一一对应。然而若 <span class="math inline">\(H\ne H_s\)</span>，根据上面的引理，<span class="math inline">\(A_o\)</span> 和 <span class="math inline">\(sA_o\)</span> 位于 <span class="math inline">\(H\)</span> 的同一侧，所以</p><p><span class="math display">\[H\in\mathcal{L}(w)\Longleftrightarrow\begin{matrix}A_o\\ sA_o\end{matrix}\stackrel{H=0}{\biggl\lvert} wA_o\Longleftrightarrow \begin{matrix}sA_o\\A_o\end{matrix}\stackrel{sH=0}{\biggl\lvert} swA_o.\]</span> 可见 <span class="math inline">\(sH\in \mathcal{L}(sw)\)</span> 并且显然 <span class="math inline">\(sH\ne H_s\)</span>。此即为所证。</p><h1 id="a-formula-for-the-order-of-w">4.9 A formula for the order of<span class="math inline">\(W\)</span></h1><p>从前面的学习中我们知道，一个仿射 Weyl 群 <span class="math inline">\(W_a\)</span> 总是可以写成一个有限 Weyl 群 <span class="math inline">\(W\)</span> 和一个格点群 <span class="math inline">\(L\)</span> 的半直积：<span class="math inline">\(W_a=W\ltimes L\)</span>。这里的 <span class="math inline">\(L\)</span> 实际上是 <span class="math inline">\(W\)</span> 的余根格点：<span class="math inline">\(L=L(\Phi^\vee)\)</span>。这一节介绍了怎样计算<span class="math inline">\(W\)</span> 的阶 <span class="math inline">\(|W|\)</span>。</p><p>我们以 <span class="math inline">\(\widetilde{B}_2\)</span>为例来说明。<span class="math inline">\(\Delta\)</span> 包含两个单根<span class="math inline">\(\alpha_1=e_1-e_2,\,\alpha_2=e_2\)</span>。最高根<span class="math inline">\(\widetilde{\alpha}=\alpha_1+2\alpha_2\)</span>，于是<span class="math inline">\(c_1=1,c_2=2\)</span>。</p><p><img style="margin:0px auto;display:block" width="500" src="/images/humphreys/b2.svg"></p><ul><li>图中<strong>黄色</strong>区域是由所有的房间 <span class="math inline">\(\{wA_o\mid w\in W\}\)</span> 组成。即 <span class="math inline">\(\Pi=\bigcup_{w\inW}wA_o\)</span>。另一个等价的描述是 <span class="math display">\[ \Pi =\{x\in V\mid -1 &lt; (x,\alpha) &lt; 1 \text{ for all }\alpha\in\Phi^+\}.\]</span> 所以 <span class="math inline">\(\mathrm{Vol}(\Pi)=|W|\cdot\mathrm{Vol}(A_o)\)</span>。<span class="math inline">\(\Pi\)</span> 是余根格点 <span class="math inline">\(L(\Phi^\vee)\)</span>的基本区域，因为书中已经证明了 <span class="math inline">\(W_a=W\ltimesL\)</span>，并且 <span class="math inline">\(A_o\)</span> 是 <span class="math inline">\(W_a\)</span> 作用下的基本区域，所以 <span class="math inline">\(\Pi\)</span> 在 <span class="math inline">\(L\)</span>的作用下互不相交，并且密铺了整个平面。</li><li>图中<strong>绿色</strong>区域是余权格点 <span class="math inline">\(\hat{L}(\Phi^\vee)\)</span> 的基本区域 <span class="math inline">\(\hat{\Pi}\)</span>，它是一个平行多面体，由基本余权<span class="math inline">\(\{\omega_1,\ldots,\omega_n\}\)</span>张成，并且 <span class="math inline">\(\dfrac{\mathrm{Vol}(\Pi)}{\mathrm{Vol}(\hat{\Pi}) } = f\)</span>。</li><li>基本区域 <span class="math inline">\(A_o\)</span> 是由 <span class="math inline">\(\left\{0,\dfrac{\omega_1}{c_1},\ldots,\dfrac{\omega_n}{c_n}\right\}\)</span>生成的单纯形，它和 <span class="math inline">\(\{\omega_1,\ldots,\omega_n\}\)</span>生成的平行多面体 <span class="math inline">\(\hat{\Pi}\)</span>的体积关系为 <span class="math display">\[\mathrm{Vol}(\hat{\Pi}) =n!c_1\cdots c_n\cdot\mathrm{Vol}(A_o).\]</span></li><li>综上可得 <span class="math display">\[\dfrac{\mathrm{Vol}(\Pi)}{\mathrm{Vol}(\hat{\Pi}) } =\frac{|W|\mathrm{Vol}(A_o)}{n!c_1\cdotsc_n\cdot\mathrm{Vol}(A_o)}=f.\]</span> 即 <span class="math inline">\(|W| = n!c_1\cdots c_n f\)</span>。</li></ul><h1 id="more-on-the-geometric-representation">6.2 More on the geometricrepresentation</h1><p>这一节证明了如果几何实现中的二次型 <span class="math inline">\(B(\alpha_s,\alpha_t)=-\cos\frac{\pi}{m_{s,t}}\)</span>是正定的，则 <span class="math inline">\(W\)</span>是有限群。这一点是两个结论合起来的结果：</p><div id="discrete-action" class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span><span class="math inline">\(W\)</span> 是 <span class="math inline">\(O(n,\mathbb{R})\)</span> 的离散子集，即对任何<span class="math inline">\(w\in W\)</span>，存在 <span class="math inline">\(w\)</span> 的开邻域 <span class="math inline">\(w\in U\)</span> 使得 <span class="math inline">\(U\)</span> 不包含 <span class="math inline">\(W\)</span> 中除 <span class="math inline">\(w\)</span> 外的任何元素。</p></div><p>证明：固定一个基本区域中的点 <span class="math inline">\(x\inC\)</span>，考虑从 <span class="math inline">\(\mathrm{GL}(V^\ast)\)</span> 到 <span class="math inline">\(V^\ast\)</span> 的连续映射 <span class="math display">\[g\to g\cdot x,\quadg\in\mathrm{GL}(V^\ast).\]</span> <span class="math inline">\(C\)</span>在此映射下的逆像是 <span class="math inline">\(\mathrm{GL}(V^\ast)\)</span> 中的某个开集 <span class="math inline">\(U\)</span>，并且 <span class="math inline">\(U\)</span> 显然包含恒等元 1，因为 <span class="math inline">\(1\cdot x=x\in C\)</span>，即 <span class="math inline">\(U\)</span> 是 1 的一个开邻域。<span class="math inline">\(U\)</span> 不包含其它任何 <span class="math inline">\(w\ne 1\in W\)</span>，否则 <span class="math inline">\(w\cdot x\in C\)</span>，这与 <span class="math inline">\(C\)</span> 是基本区域矛盾。同理任何 <span class="math inline">\(w\in W\)</span> 都有一个开邻域不包含其它 <span class="math inline">\(W\)</span> 中的点。</p><div id="discrete-subgroup" class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>紧 Hausdorff 拓扑群 <span class="math inline">\(G\)</span>的离散子群 <span class="math inline">\(H\)</span> 必然是有限群。</p></div><p>证明：</p><p>第一步：设 <span class="math inline">\(U\)</span> 是单位元 <span class="math inline">\(e\)</span> 的邻域且满足 <span class="math inline">\(U \cap H = \{e\}\)</span>，我们来说明存在一个邻域<span class="math inline">\(e\in V\subset U\)</span> 满足 <span class="math inline">\(VV^{-1}\subset U\)</span>。</p><p>令 <span class="math inline">\(\sigma:U\times U\to G\)</span> 为映射<span class="math inline">\(\sigma(x, y) =xy^{-1}\)</span>。由连续性，存在一个邻域 <span class="math inline">\(N\subset U\times U\)</span> 包含 <span class="math inline">\((e,e)\)</span> 使得 <span class="math inline">\(\sigma(N)\subset U\)</span>。那么 <span class="math inline">\(N\)</span> 包含一个形如 <span class="math inline">\(V_1\times V_2\)</span> 的开集，其中 <span class="math inline">\(V_1, V_2 \subset U\)</span> 是开集且 <span class="math inline">\(e\in V_1\cap V_2\)</span>。取 <span class="math inline">\(V=V_1 \cap V_2\)</span>，于是 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(e\)</span> 的一个邻域，并且 <span class="math inline">\(V\times V\subset V_1\times V_2\)</span>，因此<span class="math inline">\(VV^{-1}=\sigma(V \timesV)\subset\sigma(V_1\times V_2) \subset U\)</span>。</p><p>第二步：我们来论证 <span class="math inline">\(G\backslash H\)</span>是开集。为此只要说明对任意 <span class="math inline">\(x\in G\backslashH\)</span>，存在 <span class="math inline">\(x\)</span> 的邻域 <span class="math inline">\(U\)</span> 使得 <span class="math inline">\(U\capH=\emptyset\)</span>。设 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(e\)</span> 的邻域且 <span class="math inline">\(U\cap H=\{e\}\)</span>。令 <span class="math inline">\(V\subset U\)</span> 为具有上面第一步中性质的 <span class="math inline">\(e\)</span> 的邻域，则 <span class="math inline">\(N=Vx\)</span> 是 <span class="math inline">\(x\)</span> 的邻域。假设 <span class="math inline">\(h_1, h_2\in N\cap H\)</span>，那么存在 <span class="math inline">\(v_1,v_2\in V\)</span> 满足 <span class="math inline">\(h_1 = v_1x\)</span> 且 <span class="math inline">\(h_2=v_2x\)</span>。于是 <span class="math display">\[v_1^{-1}h_1=x=v_2^{-1}h_2\implies h_1h_2^{-1} =v_1v_2^{-1}\in VV^{-1} \subset U.\]</span> 因此 <span class="math inline">\(v_1v_2^{-1}\in H\cap U\)</span>，所以 <span class="math inline">\(h_1h_2^{-1}=e\)</span>，因此 <span class="math inline">\(h_1=h_2\)</span>。这意味着 <span class="math inline">\(N\)</span> 至多包含 <span class="math inline">\(H\)</span> 的一个元素。如果 <span class="math inline">\(N\)</span> 不包含 <span class="math inline">\(H\)</span> 的任何元素，则 <span class="math inline">\(N\)</span> 即为所求。否则若 <span class="math inline">\(N\cap H=\{h\}\)</span>，由于 <span class="math inline">\(G\)</span> 是 Hausdorff 空间，我们可以取开邻域<span class="math inline">\(U_x, U_h\subset N\)</span> 将 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(h\)</span> 分开，那么 <span class="math inline">\(U_x\)</span> 是所求的邻域。</p><p>第三步：<span class="math inline">\(H\)</span>是有限的。这是因为对每个 <span class="math inline">\(x\inH\)</span>，取其邻域 <span class="math inline">\(U_x\)</span> 使得 <span class="math inline">\(U_x\cap H=\{x\}\)</span>，这些开集加上 <span class="math inline">\(G\backslash H\)</span> 构成 <span class="math inline">\(G\)</span> 的一个开覆盖，由 <span class="math inline">\(G\)</span> 的紧性可得存在 <span class="math inline">\(G\)</span> 的有限子覆盖。于是有限多个 <span class="math inline">\(\{U_{x_i}\}_{i=1}^n\)</span> 覆盖了 <span class="math inline">\(H\)</span>。然而每个 <span class="math inline">\(U_{x_i}\)</span> 只包含一个 <span class="math inline">\(H\)</span> 中的元素 <span class="math inline">\(x_i\)</span>，所以 <span class="math inline">\(H\)</span> 是有限的。<span class="math inline">\(\blacksquare\)</span></p><p>现在 <span class="math inline">\(W\)</span> 保持 Euclidean 内积 <span class="math inline">\(B\)</span> 不变，从而是正交群 <span class="math inline">\(O(n,\mathbb{R})\)</span> 的子群。而 <span class="math inline">\(O(n,\mathbb{R})\)</span> 是紧群，<span class="math inline">\(W\)</span> 是离散子群，所以 <span class="math inline">\(W\)</span> 是有限群。</p><h1 id="and-6.4-radical-of-the-bilinear-form-finite-coxeter-groups">6.3and 6.4 Radical of the bilinear form / Finite Coxeter groups</h1><p>这两节合起来证明了 6.2 的逆命题：如果 <span class="math inline">\(W\)</span> 是有限群，则 <span class="math inline">\(B\)</span>必然是正定的。这个结论是如下几个命题合起来得到的：</p><div id="-------1" class="unnumbered statement sta____1 plain"><p><span class="statement-heading"><span class="statement-label">命题1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(U\)</span> 是 <span class="math inline">\(V\)</span> 的一个真 <span class="math inline">\(W-\)</span> 子模，则 <span class="math inline">\(U\subset V^\bot\)</span>。</p></div><p>这个命题背后的关键是任何单根 <span class="math inline">\(\alpha_s\)</span> 必须属于 <span class="math inline">\(U\)</span> 或者 <span class="math inline">\(U^\bot\)</span> 之一。由于 <span class="math inline">\(W\)</span> 是不可约 Coxeter 群，<span class="math inline">\(\Delta\)</span>不能分成两个互相正交的子集，所以要么 <span class="math inline">\(\Delta\in U\)</span>，这与 <span class="math inline">\(U\)</span> 是真子模矛盾；要么 <span class="math inline">\(\Delta\in U^\bot\)</span>，从而 <span class="math inline">\(U\subset V^\bot\)</span>。</p><div id="-------2" class="unnumbered statement sta____2 plain"><p><span class="statement-heading"><span class="statement-label">命题2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 在 <span class="math inline">\(V\)</span> 上的作用是完全可约的。</p></div><p>这是群表示论里面的 Maschke 定理。证明技巧就是取平均构造 <span class="math inline">\(W-\)</span> 不变的正定内积。</p><div id="-------3" class="unnumbered statement sta____3 plain"><p><span class="statement-heading"><span class="statement-label">命题3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B\)</span> 是非退化的。</p></div><p>若不然 <span class="math inline">\(V^\bot\ne(0)\)</span>，完全可约性说明 <span class="math inline">\(V^\bot\)</span> 有直和补 <span class="math inline">\(U\)</span>，但是 <span class="math inline">\(U\)</span> 也在 <span class="math inline">\(V^\bot\)</span> 中，矛盾。</p><div id="-------4" class="unnumbered statement sta____4 plain"><p><span class="statement-heading"><span class="statement-label">命题4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 在 <span class="math inline">\(V\)</span> 上是不可约的。</p></div><p>这是命题 3 的直接结论，因为有非平凡的真子模意味着 <span class="math inline">\(V^\bot\)</span> 也非平凡，与 <span class="math inline">\(B\)</span> 非退化矛盾。</p><div id="-------5" class="unnumbered statement sta____5 plain"><p><span class="statement-heading"><span class="statement-label">命题5</span>.</span><span class="statement-spah"> </span><span class="math inline">\(B\)</span> 是正定的。</p></div><p>实际上 <span class="math inline">\(V\)</span> 是 <span class="math inline">\(W\)</span> 的不可约表示说明 <span class="math inline">\(V\)</span> 上的 <span class="math inline">\(W-\)</span>不变双线性函数构成的向量空间是一维的。而我们已经有一个 <span class="math inline">\(W-\)</span> 不变的正定内积，所以 <span class="math inline">\(B\)</span>必然是它的一个倍数，从而也是正定的。</p><h1 id="hecke-algebras-and-inverses">7.4 Hecke algebras andinverses</h1><p>这一节引入了 <span class="math inline">\(R\)</span>多项式，并给出了它们满足的递推关系。这部分用对合来处理会比较方便。</p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>对任何 <span class="math inline">\(w\in W\)</span>， <span class="math display">\[q^{l(w)}\,\overline{T_w}=\sum_{x\leqw}(-1)^{l(x)+l(w)}R_{x,w}(q)T_x.\]</span> 其中 <span class="math inline">\(R_{x,w}(q)\in\mathbb{Z}[q]\)</span> 是关于 <span class="math inline">\(q\)</span> 的多项式，满足 <span class="math inline">\(R_{w,w}(q)=1\)</span>。</p></div><p><strong>证明</strong>：由 <span class="math inline">\(q^{l(e)}\,\overline{T_e}=q^0\,\overline{T_e}=T_e\)</span>，结论对<span class="math inline">\(w=e\)</span> 成立。当 <span class="math inline">\(l(w)&gt;0\)</span> 时，设 <span class="math inline">\(w=s_1\cdots s_r\)</span> 是一个既约表示，则 <span class="math display">\[\begin{align}q^{l(w)}\,\overline{T_w}&amp;=q^r\,\overline{T_{s_1\cdots s_r}}\\&amp;=q^r\,\overline{T_{s_1}}\cdots\overline{T_{s_r}}\\&amp;=(qT_{s_1}^{-1})\cdots (qT_{s_r}^{-1})\\&amp;=(T_{s_1}+1-q)\cdots (T_{s_r}+1-q)\\&amp;=\sum_{k=1}^r\sum_{1\leq i_1\leq\cdots\leq i_k\leqr}(1-q)^{r-k}T_{s_{i_1}}\cdots T_{s_{i_k}} + (1-q)^r.\end{align}\]</span> 注意到每个 <span class="math inline">\(T_{s_{i_1}}\cdots T_{s_{i_k}}=T_{s_1\cdotss_k}=T_x\)</span>，<span class="math inline">\(x\)</span> 是 <span class="math inline">\(w\)</span> 的子表达式，所以 <span class="math inline">\(x\leq w\)</span>。合并相同的 <span class="math inline">\(x\)</span> 的系数以后，显然 <span class="math inline">\(T_x\)</span> 的系数在 <span class="math inline">\(\mathbb{Z}[q]\)</span> 中，所以存在 <span class="math inline">\(R_{x,w}\in\mathbb{Z}[q]\)</span> 满足 <span class="math display">\[\sum_{k=1}^r\sum_{1\leq i_1\leq\cdots\leq i_k\leqr}(1-q)^{r-k}T_{s_{i_1}}\cdots T_{s_{i_k}} +(1-q)^r=\sum_{x\leqw}(-1)^{l(x)+l(w)}R_{x,w}(q)T_x.\]</span> 由于 <span class="math inline">\(s_{i_1}\cdots s_{i_k}=w\)</span>只有一种可能，就是 <span class="math inline">\(k=r\)</span> 并且 <span class="math inline">\((i_1,\ldots,i_r)=(1,\ldots,r)\)</span>，所以 <span class="math inline">\(R_{w,w}(q)=1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(s\in S\)</span>，<span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(sw&lt;w\)</span>，则 <span class="math display">\[R_{x,w}(q) = \begin{cases}R_{sx,sw}(q) &amp; \text{if } sx&lt;x,\\qR_{sx,sw}(q)+(q-1)R_{x,sw}(q) &amp; \text{if } x&lt;sx.\end{cases}\]</span></p></div><p><strong>证明</strong>： <span class="math display">\[\begin{aligned}&amp;\qquad\sum_{w\in W}(-1)^{l(x)+l(w)}R_{x,w}(q)T_x =q^{l(w)}\,\overline{T_w}=q^{l(s)+l(sw)}\overline{T_s}\,\overline{T_{sw}}=q\,\overline{T_s}\,q^{l(sw)}\,\overline{T_{sw}}\\&amp;=(T_s +1-q)\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x\\&amp;=\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)(T_sT_x+(1-q)T_x)\\&amp;=(1-q)\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x + \sum_{w\inW}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_sT_x\\&amp;=(1-q)\sum_{w\in W}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x +\sum_{w\inW,\,x&lt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_{sx}\\&amp;\quad +\sum_{w\inW,\,x&gt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)(qT_{sx}+(q-1)T_x)\\&amp;=(1-q)\sum_{w\inW,\,x&lt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_x+\sum_{w\inW,\,x&lt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_{sx}\\&amp;\quad+\,q\sum_{w\in W,\,x&gt;sx}(-1)^{l(sw)+l(x)}R_{x,sw}(q)T_{sx}\\&amp;\overset{y=sx}=(q-1)\sum_{w\inW,\,x&lt;sx}(-1)^{l(w)+l(x)}R_{x,sw}(q)T_x+\sum_{w\in W,\,sy&lt;y}(-1)^{l(sw)+l(sy)}R_{sy,sw}(q)T_y\\&amp;\quad +q\sum_{w\inW,\,sy&gt;y}(-1)^{l(sw)+l(sy)}R_{sy,sw}(q)T_y\\&amp;\overset{y=x}=\sum_{w\inW,\,sx&lt;x}(-1)^{l(w)+l(x)}R_{sx,sw}(q)T_x+\sum_{w\inW,\,sx&gt;x}(-1)^{l(w)+l(x)}\left(qR_{sx,sw}+(q-1)R_{x,sw}\right)T_x.\end{aligned}\]</span> 比较两边 <span class="math inline">\(T_x\)</span>的系数即可得到结论。</p><h1 id="further-properties-of-r-polynomials">7.8 Further properties of<span class="math inline">\(R\)</span>-polynomials</h1><div class="unnumbered statement proposition-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">命题</span>.</span><span class="statement-spah"></span><span class="math inline">\(R\)</span>-多项式满足如下性质：</p><ol type="1"><li><span class="math inline">\((-q)^{l(w)-l(x)}\overline{R_{x,w}(q)}=R_{x,w}\)</span>。</li><li><span class="math inline">\(\sum_{x\leq y\leqw}(-1)^{l(x)+l(y)}R_{x,y}(q) R_{y,w}(q)=\delta_{x,w}\)</span>。</li></ol></div><p>1 的证明：对 <span class="math inline">\(w\)</span> 的长度归纳。如果<span class="math inline">\(l(w)=0\)</span> 则 <span class="math inline">\(w=x=e\)</span>，<span class="math inline">\(R_{e,e}=1\)</span>，结论成立。</p><p>设结论对所有长度 <span class="math inline">\(&lt;l(w)\)</span>的元素成立，取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(l(sw)&lt;l(w)\)</span>。考虑两种情况：</p><ul><li><span class="math inline">\(sx &lt; x\)</span>。这时 <span class="math inline">\(R_{x,w}=R_{sx,sw}\)</span>，对 <span class="math inline">\(sw\)</span> 应用归纳假设 <span class="math display">\[(-q)^{l(sw)-l(sx)}\overline{R_{sx,sw}}=R_{sx,sw}=R_{x,w}.\]</span>由于 <span class="math inline">\(l(sw)-l(sx)=l(w)-l(x)\)</span>所以结论对 <span class="math inline">\(w\)</span> 也成立。</li><li><span class="math inline">\(sx&gt;x\)</span>。 <span class="math display">\[\begin{align}(-q)^{l(w) - l(x)} R_{x,w}(q) &amp;= (-1)^{l(w) + l(x)} q^{l(w) - l(x)}R_{x,w}(q^{-1}) \\&amp;= (-1)^{l(w) + l(x)} q^{l(w) - l(x)} \left( q^{-1}R_{sx,sw}(q^{-1}) + (q^{-1} - 1) R_{x,sw}(q^{-1}) \right) \\&amp;= (-1)^{l(w) + l(x)} q^{l(sw) - l(sx)} q^2\left( q^{-1}R_{sx,sw}(q^{-1}) + (q^{-1} - 1) R_{x,sw}(q^{-1}) \right) \\&amp;= q (-1)^{l(sw) + l(sx)} q^{l(sw) - l(sx)} R_{sx,sw}(q^{-1}) \\&amp;\quad - (-1)^{l(sw) + l(x)} q^{l(sw) - l(x)} (1 - q)R_{x,sw}(q^{-1}) \\&amp;= q (-q)^{l(sw) - l(sx)} R_{sx,sw}(q) + (q - 1)(-q)^{l(sw) - l(x)}R_{x,sw}(q) \\&amp;= q R_{sx,sw}(q) + (q - 1) R_{x,sw}(q) \\&amp;= R_{x,w}(q).\end{align}\]</span></li></ul><p>2 的证明：根据 <span class="math inline">\(R\)</span>-多项式的定义，<span class="math display">\[\overline{T_w}=q^{-l(w)}\sum_{y\inW}(-1)^{l(y)+l(w)}R_{y,w}T_y.\]</span> 两边取对合得到 <span class="math display">\[\begin{aligned}T_w&amp;=\overline{q^{-l(w)}\sum_{y\in W}(-1)^{l(y)+l(w)}R_{y,w}T_y}\\&amp;=q^{l(w)}\sum_{y\inW}(-1)^{l(y)+l(w)}\overline{R_{y,w}}\,\overline{T_y}\\&amp;=q^{l(w)}\sum_{y\in W}(-1)^{l(y)+l(w)}q^{l(y)-l(w)}R_{y,w}\cdotq^{-l(y)}\sum_{x\in W}(-1)^{l(x)+l(y)}R_{x,y}T_y\\&amp;=\sum_{x\in W}\left(\sum_{x\leq y\leqw}(-1)^{l(y)+l(x)}R_{x,y}R_{y,w}\right)T_x\end{aligned}\]</span> 比较两边关于 <span class="math inline">\(T_w\)</span> 项的系数即可。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Shadertoy 学习</title>
      <link href="learn-shadertoy/index.html"/>
      <url>learn-shadertoy/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>读书</title>
      <link href="reading/index.html"/>
      <url>reading/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd-Coxeter algorithm and uniform polytopes</title>
      <link href="polytopes/index.html"/>
      <url>polytopes/index.html</url>
      
        <content type="html"><![CDATA[<p>This project uses Python and POV-Ray to render 3D/4D uniformpolytopes. The code is hosted on <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/polytopes">GitHub</a>and requires the <code>numpy</code> library and the free raytracer,<code>POV-Ray</code>.</p><h1 id="examples">Examples</h1><p>All the images and videos displayed below are created using thisprogram. The polytope data is computed in Python and then exported toPOV-Ray for rendering.</p><ul><li><p>All Platonic solids and Archimedean solids, prims and antiprisms,for example the <a href="https://en.wikipedia.org/wiki/Snub_dodecahedron">snubdodecahedron</a>:</p><p><video src="/images/polytopes/snub-dodecahedron.mp4" controls=""></video></p></li><li><p>All Kepler-Poinsot solids, for example the <a href="https://en.wikipedia.org/wiki/Great_icosahedron">greaticosahedron</a>:</p><p><video src="/images/polytopes/great-icosahedron.mp4" controls=""></video></p></li><li><p>All uniform 4d polytopes (except the <a href="https://en.wikipedia.org/wiki/Grand_antiprism">grandantiprism</a>, which is non-Wythoffian), for example my github favicon,the <a href="https://en.wikipedia.org/wiki/Runcinated_120-cells">runcinated120-cell</a>:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/github-favicon.png"></p></li><li><p>5-cell:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/5-cell.png"></p></li><li><p>4d cube:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/4-cube.png"></p></li><li><p><a href="https://en.wikipedia.org/wiki/Truncated_tesseract">Truncatedtesseract</a>:</p><p><video src="/images/polytopes/truncated-tesseract.mp4" controls=""></video></p></li><li><p><a href="https://en.wikipedia.org/wiki/600-cell">600-cell</a>:(you can render the bubble faces and choose which of them are shown)</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/600-cell.png"></p></li><li><p><a href="https://en.wikipedia.org/wiki/16-cell">runcinated16-cell</a>:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/runcinated-16-cell.png"></p></li><li><p><a href="https://en.wikipedia.org/wiki/Snub_24-cell">snub24-cell</a>:</p><p><video src="/images/polytopes/snub24-cell.mp4" controls=""></video></p></li><li><p>You can also render uniform star 4d polytopes, for example the <a href="https://en.wikipedia.org/wiki/Grand_stellated_120-cell">grandstellated 120-cell</a>:</p><p><video src="/images/polytopes/grand-stellated-120-cell.mp4" controls=""></video></p><p>and its rectified version (rendered in a curved fashion):</p><p><video src="/images/polytopes/rectified-grand-stellated-120-cell.mp4" controls=""></video></p></li><li><p>And finally, uniform 5D polytopes like 5-cube:</p><p><video src="/images/polytopes/5-cube.mp4" controls=""></video></p></li></ul><h1 id="what-are-these-examples-about">What are these examplesabout?</h1><p>The polytopes showcased above are convex and non-convex uniformpolytopes in 3D or 4D Euclidean spaces. Key terms to note include“convex/non-convex”, “Euclidean”, and “uniform”.</p><p>The term “convex” refers to the property of a polytope such that anyline segment joining two points on the polytope lies entirely within theenclosure of the polytope. Examples of convex polytopes include Platonicsolids, Archimedean solids, and Catalan solids, while non-convex onesinclude Kepler-Poinsot solids and star polychora.</p><p>In 3D Euclidean space, there are 18 different convex uniformpolytopes (excluding the two infinite classes of prisms and antiprisms)and 57 different non-convex uniform polytopes. Currently, my program canonly render the convex ones and a few non-convex ones, but I’m workingon figuring out how to make it work for all of them in the future.</p><p>The term “Euclidean” is emphasized here because we also have uniformpolytopes in other metric spaces, such as the hyperbolic metric, whichbends the space and makes the polytopes look “deformed”. A famousexample of this is the logo “Spikey” of Mathematica, which is based onthe dodecahedron in hyperbolic 3-space.</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/spikey.png"></p><p>The term “uniform” requires some mathematical subtleties. Roughlyspeaking, it means that</p><ol type="1"><li>All vertices are the same.</li><li>All faces are regular polygons.</li><li>All cells are uniform polyhedra (a polyhedron that satisfiesconditions 1 and 2).</li></ol><p>To explain what “the same” means, we need to use terms from grouptheory: it means that the symmetry group <span class="math inline">\(G\)</span> of the polytope acts transitively onthe set of vertices, such that for any pair of vertices <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span>, there is some <span class="math inline">\(g\in G\)</span> that transforms <span class="math inline">\(u\)</span> to <span class="math inline">\(v\)</span>: <span class="math inline">\(g \cdot u= v\)</span>.</p><p>In the above examples, the polytopes are colored such that allvertices, edges, and faces that are in the same orbit under the actionof the symmetry group have the same color.</p><h1 id="how-to-compute-the-data-of-a-uniform-polytope">How to computethe data of a uniform polytope</h1><p>Though these polytopes appear quite different from each other, theycan all be constructed using a uniform approach called the <a href="https://en.wikipedia.org/wiki/Wythoff_construction">Wythonffconstruction</a> (also known as the kaleidoscope construction). Inprinciple, this construction works in the same way as a kaleidoscope: weplace reflection planes (mirrors) in space, passing through the originand with carefully chosen angles between them (which must be of the form<span class="math inline">\(\pi-\pi/p\)</span> for some rational <span class="math inline">\(p\)</span>). These mirrors partition space into“rooms”. We choose any room (called the fundamental domain) and aninitial vertex <span class="math inline">\(v_0\)</span> in it, and thenrepeatedly reflect <span class="math inline">\(v_0\)</span> about themirrors to obtain a set of virtual images. All virtual images togetherwith <span class="math inline">\(v_0\)</span> form the vertices of ourpolytope. If <span class="math inline">\(v_1\)</span> is the virtualimage of <span class="math inline">\(v_0\)</span> about the <span class="math inline">\(i\)</span>-th mirror, then <span class="math inline">\((v_0,v_1)\)</span> form an edge of type <span class="math inline">\(i\)</span>. We can use the symmetry group totransform it to other edges in the same orbit. Also, if <span class="math inline">\(v_0\)</span> is firstly reflected about mirror<span class="math inline">\(i\)</span> and then reflected about mirror<span class="math inline">\(j\)</span>, then since the composition oftwo reflections is a rotation, <span class="math inline">\(v_0\)</span>is rotated about the center of some face <span class="math inline">\(f\)</span> by an angle of <span class="math inline">\(2\pi/m\)</span> (assuming the angle between mirror<span class="math inline">\(i\)</span> and mirror <span class="math inline">\(j\)</span> is <span class="math inline">\(\pi-\pi/m\)</span>). We can recover <span class="math inline">\(f\)</span> by applying this rotation <span class="math inline">\(m\)</span> times and using the symmetry group toobtain other faces.</p><p>To implement the above strategy in a practical program, we need toaddress two main issues:</p><ol type="1"><li>How to position the mirrors and select the initial vertex <span class="math inline">\(v_0\)</span> for a given convex uniformpolytope?</li><li>Once the mirrors and <span class="math inline">\(v_0\)</span> aredetermined, how do we compute all the virtual images of <span class="math inline">\(v_0\)</span>?</li></ol><p>The solution to the first problem is known as the <a href="https://en.wikipedia.org/wiki/Coxeter%E2%80%93Dynkin_diagram">Coxeter-Dynkindiagram</a>, which is a labeled undirected graph that encodes all thenecessary information. Each uniform polytope has a correspondingCoxeter-Dynkin diagram that represents it, although different diagramsmay represent the same polytope.</p><p>For example, the Coxeter-Dynkin diagram of the cube is:</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="250"></p><p>Let’s delve deeper into the Coxeter-Dynkin diagram. Each node in thediagram represents a mirror in the kaleidoscope. In the diagram above,there are three nodes, and therefore three mirrors, which we label fromleft to right as <span class="math inline">\(m_0\)</span>, <span class="math inline">\(m_1\)</span>, and <span class="math inline">\(m_2\)</span>. The labelled edge between two nodesencodes the angle between their corresponding mirrors, as follows:</p><ol type="1"><li>Two nodes are connected if and only if the angle between theirmirrors is not equal to <span class="math inline">\(\pi/2\)</span>.</li><li>Two nodes are connected by an unlabelled edge if and only if theangle between their mirrors equals <span class="math inline">\(\pi-\pi/3\)</span>.</li><li>Two nodes are connected by an edge labelled with a rational number<span class="math inline">\(m&gt;2\)</span> and <span class="math inline">\(m\ne3\)</span> if and only if the angle betweentheir mirrors equals <span class="math inline">\(\pi-\pi/m\)</span>.</li></ol><p>Moreover, we use “circled” nodes to indicate which mirrors are“active”, i.e., those that do not contain the initial vertex <span class="math inline">\(v_0\)</span>. In this case, reflecting <span class="math inline">\(v_0\)</span> about an active mirror produces avirtual image.</p><p>In the above example we have <span class="math inline">\(\langlem_0,m_1\rangle=\pi-\pi/4\)</span>, <span class="math inline">\(\langlem_1,m_2\rangle=\pi-\pi/3\)</span>, <span class="math inline">\(\langlem_0,m_2\rangle=\pi/2\)</span>. <span class="math inline">\(m_0\)</span>is active, but <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> are not.</p><p>Therefore, we can place the three mirrors as follows: (<span class="math inline">\(n_i\)</span> is the normalized normal vector ofmirror <span class="math inline">\(m_i\)</span>)</p><ol type="1"><li>The normal of <span class="math inline">\(m_0\)</span> can be chosenarbitrarily, for example <span class="math inline">\(n_0=(1,0,0)\)</span>.</li><li>The angle between <span class="math inline">\(n_1\)</span> and <span class="math inline">\(n_0\)</span> is <span class="math inline">\(3\pi/4\)</span>, so we can choose <span class="math inline">\(n_1\)</span> to be <span class="math inline">\(n_1=(\cos\dfrac{3\pi}{4}, \sin\dfrac{3\pi}{4},0)\)</span>.</li><li>The normal of <span class="math inline">\(m_2\)</span> isperpendicular to <span class="math inline">\(n_0\)</span>, so <span class="math inline">\(n_2\)</span> has the form <span class="math inline">\((0,y_3,z_3)\)</span>. Using <span class="math inline">\(\langle n_1,n_2\rangle=2\pi/3\)</span>, we have<span class="math inline">\(y_3\sin\dfrac{3\pi}{4}=\cos\dfrac{2\pi}{3}\)</span>,and since <span class="math inline">\(z_3\)</span> is a unit vector,<span class="math inline">\(z_3=\sqrt{1−y_3^2}\)</span>. We can solvethese two equations to obtain <span class="math inline">\(y_3,z_3\)</span>.</li></ol><p>To choose an initial vertex <span class="math inline">\(v_0\)</span>that lies on both <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> but not on <span class="math inline">\(m_0\)</span>, we can choose <span class="math inline">\(v_0\)</span> so that its distance to <span class="math inline">\(m_0\)</span> is 1 and its distance to <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> are both 0:</p><p><span class="math display">\[\begin{align*}\langle v_0,n_0\rangle=1,\\\langle v_0, n_1\rangle=0,\\\langle v_0,n_2\rangle=0.\\\end{align*}\]</span></p><p>Then solve this linear system to get <span class="math inline">\(v_0\)</span>.</p><p>As mentioned before the angles between the mirrors must be chosencarefully to ensure <span class="math inline">\(v_0\)</span> and itsvirtual images form the vertices of an uniform polytope, this restrictsus to only finitely many choices of Coxeter diagrams, you can refer tothis <a href="https://en.wikipedia.org/wiki/Uniform_polytope">wikipage</a> for the complete list.</p><p>The answer to the second question is called the Todd-Coxeteralgorithm, I’ll discuss it in the next section.</p><h1 id="finitely-presented-groups-and-todd-coxeter-algorithm">Finitelypresented groups and Todd-Coxeter algorithm</h1><p>How can we obtain all the virtual images of the initial vertex <span class="math inline">\(v_0\)</span> with respect to all mirrors? Anobvious but crude method is to repeatedly reflect <span class="math inline">\(v_0\)</span> about the mirrors and compare theresulting images with the set of virtual images obtained so far (withina predefined rounding error bound) until no new virtual images emerge.This approach is easy to program but it’s unappealing from amathematician’s perspective, as it fails to utilize the abundantsymmetries inherent in the polytope.</p><p>This program takes a “symbolic computation” approach by solving the<a href="https://en.wikipedia.org/wiki/Coset_enumeration">cosetenumeration problem</a> in the symmetry group. It offers the advantageof providing exact information about the polytope without resorting torounding errors or approximation procedures. However, the price we payis that the math involved is somewhat complex (and hence so is thecode), and readers should have some basic knowledge of group theory tounderstand it.</p><p>Firstly, let’s recall the <a href="https://en.wikipedia.org/wiki/Group_action_(mathematics)#Orbit-stabilizer_theorem">orbit-stabilizertheorem</a> from group theory:</p><blockquote><p><strong>Theorem</strong>: Suppose a group <span class="math inline">\(G\)</span> acts transitively on a set <span class="math inline">\(S\)</span>, and let <span class="math inline">\(x\in S\)</span> have stabilizer subgroup <span class="math inline">\(H\leq G\)</span>. Then there exists a one-to-one correspondence between<span class="math inline">\(S\)</span> and the right cosets of <span class="math inline">\(G/H\)</span>: <span class="math inline">\(x \cdotg \mapsto Hg\)</span>.</p></blockquote><p>Note that the action of <span class="math inline">\(G\)</span> on<span class="math inline">\(S\)</span> is written as “applying on theright”, this is mainly for programming convenience and has nosignificant difference from applying on the left.</p><p>The theorem mentioned above tells us that if a group <span class="math inline">\(G\)</span> acts transitively on a set <span class="math inline">\(S\)</span> and we know the stabilizing subgroup ofsome <span class="math inline">\(x\in S\)</span> in <span class="math inline">\(G\)</span> is <span class="math inline">\(H\)</span>, then we can recover the entire orbit<span class="math inline">\(S\)</span> by applying a set of cosetrepresentatives of <span class="math inline">\(G/H\)</span> to <span class="math inline">\(x\)</span>.</p><p>Therefore, to compute all vertices of a given uniform polytope <span class="math inline">\(P\)</span>, we can follow these steps:</p><ol type="1"><li>Obtain a presentation of the symmetry group <span class="math inline">\(G\)</span> and the coordinates of an initialvertex <span class="math inline">\(v_0\)</span> from the Coxeter-Dynkindiagram.</li><li>Obtain a presentation of the stabilizing subgroup <span class="math inline">\(H\)</span> of <span class="math inline">\(v_0\)</span> in <span class="math inline">\(G\)</span> and calculate a set of right cosetrepresentatives of <span class="math inline">\(G/H\)</span>.</li><li>Apply these representatives to <span class="math inline">\(v_0\)</span> to obtain all vertices of <span class="math inline">\(P\)</span>.</li></ol><p>Again we use the cube as an example to show this procedure: recallthe Coxeter-Dynkin diagram of the cube is</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="250"></p><p>The mirrors of the cube are <span class="math inline">\(m_0,m_1,\)</span> and <span class="math inline">\(m_2\)</span>, with normals<span class="math inline">\(n_0, n_1,\)</span> and <span class="math inline">\(n_2\)</span>, respectively, all of which are unitvectors. The reflections about these mirrors are denoted as <span class="math inline">\(\rho_0, \rho_1,\)</span> and <span class="math inline">\(\rho_2\)</span>, and the matrix of <span class="math inline">\(\rho_i\)</span> is <span class="math inline">\(M_i= I - 2n_in_i^T\)</span> (see <a href="https://en.wikipedia.org/wiki/Householder_transformation">Householdertransformation</a>).</p><p>The symmetry group <span class="math inline">\(G\)</span> of the cubeis generated by the three aforementioned “generator reflections”: <span class="math inline">\(\rho_0, \rho_1,\)</span> and <span class="math inline">\(\rho_2\)</span>. A presentation of the groupis:</p><p><span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p>This is because a reflection always has order 2 and since <span class="math inline">\(\rho_0\)</span> and <span class="math inline">\(\rho_1\)</span> are two reflections with an angleof <span class="math inline">\(3\pi/4\)</span> between their mirrors,<span class="math inline">\(\rho_0\rho_1\)</span> is a rotation aboutthe line of intersection of their mirrors with an angle of <span class="math inline">\(3\pi/2\)</span>. Therefore, <span class="math inline">\((\rho_0\rho_1)^4=1\)</span>. Similarly, we havethe relations for <span class="math inline">\(\rho_1\rho_2\)</span> and<span class="math inline">\(\rho_0\rho_2\)</span>.</p><blockquote><p><strong>Note</strong>: It is natural to wonder if we might be missingsome “hidden” relations. For convex polytopes, the answer is no, but forcertain star polytopes, the answer is yes. In these cases, we need toadd extra relations to ensure the procedure works correctly. Asignificant difference is that, in convex cases, the symmetry groupalways maps the interior of the fundamental domain to another disjointone, whereas in star polytopes, the fundamental domain may be coveredmultiple times by other domains. For more information, refer toVinberg’s paper “Discrete linear groups generated by reflections”.</p></blockquote><p>One can employ the Todd-Coxeter algorithm (which will be explainedlater) to calculate a comprehensive list of all 48 elements in <span class="math inline">\(G\)</span>.</p><p><span class="math display">\[\begin{array}{lll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{0}&amp;\rho_{1}&amp;\rho_{0}\rho_{2}\\\rho_{2}&amp;\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\end{array}\]</span></p><p>Since the initial vertex <span class="math inline">\(v_0\)</span> ison <span class="math inline">\(m_1\)</span> and <span class="math inline">\(m_2\)</span> but not on <span class="math inline">\(m_0\)</span> in the Coxeter-Dynkin diagram, onlythe mirror <span class="math inline">\(m_0\)</span> is active. Thus,both <span class="math inline">\(\rho_1\)</span> and <span class="math inline">\(\rho_2\)</span> map <span class="math inline">\(v_0\)</span> to itself, while <span class="math inline">\(\rho_0\)</span> maps <span class="math inline">\(v_0\)</span> to its virtual image about <span class="math inline">\(m_0\)</span>. Therefore, the stabilizing subgroupof <span class="math inline">\(v_0\)</span> is given by:</p><p><span class="math display">\[H=\langle \rho_1, \rho_2\ |\\rho_1^2=\rho_2^2=(\rho_1\rho_2)^3=e\rangle.\]</span></p><blockquote><p><strong>Note</strong>: You may wonder if we can only claim that thesubgroup generated by <span class="math inline">\({\rho_0,\rho_1}\)</span> is contained in thestabilizing subgroup of <span class="math inline">\(v_0\)</span> but maynot be exactly equal to it. Indeed, this is a possibility. However, forCoxeter groups, it is a property that in the geometric realization of aCoxeter group <span class="math inline">\(W\)</span> (that is,representing <span class="math inline">\(W\)</span> as a set ofreflections about hyperplanes in <span class="math inline">\(\mathbb{R}^n\)</span>), the stabilizing subgroupof any point <span class="math inline">\(v\)</span> in the fundamentaldomain is a standard parabolic subgroup generated by those simplereflections whose hyperplanes contain <span class="math inline">\(v\)</span>. This may seem like an obviousgeometric intuition, but it requires a quite non-trivial proof, whichcan be found in Humphreys’s book “Reflection Groups and Coxeter Groups”,chapter 1.</p></blockquote><p>It is clear that <span class="math inline">\(H\)</span> is thedihedral group <span class="math inline">\(D_3\)</span>, thus <span class="math inline">\(|H|=6\)</span> and <span class="math inline">\(|G/H|=8\)</span>. Using the Todd-Coxeteralgorithm, we can obtain a complete list of coset representatives for<span class="math inline">\(G/H\)</span>:</p><p><span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span></p><p>Applying these coset representatives to <span class="math inline">\(v_0\)</span> gives us the 8 vertices of the cube.For example, the action of <span class="math inline">\(\rho_0\rho_1\)</span> on <span class="math inline">\(v_0\)</span> is as follows:</p><p><span class="math display">\[v_0(\rho_0\rho_1)=(v_0\rho_0)\rho_1=(v_0M_0)\rho_1=v_0M_0M_1.\]</span></p><p>Here, <span class="math inline">\(v_0\)</span> is represented as arow vector since all <span class="math inline">\(M_i\)</span>’s aresymmetric matrices.</p><p>We can also use the same procedure to find all edges and faces of thecube. To find all edges of type <span class="math inline">\(i\)</span>,we proceed as follows:</p><ol type="1"><li>Check if the initial vertex <span class="math inline">\(v_0\)</span>lies on the mirror <span class="math inline">\(m_i\)</span>. If it does,then the reflection <span class="math inline">\(\rho_i\)</span> fixes<span class="math inline">\(v_0\)</span>, and there are no edges of type<span class="math inline">\(i\)</span>. Otherwise, let <span class="math inline">\(v_1=\rho_i(v_0)\)</span>. Then, the segment <span class="math inline">\((v_0,v_1)\)</span> forms an edge <span class="math inline">\(e\)</span> of type <span class="math inline">\(i\)</span></li><li>To find the stabilizing subgroup of <span class="math inline">\(e\)</span>, we note that a symmetry fixes <span class="math inline">\(e\)</span> if and only if it fixes the midpoint<span class="math inline">\(p\)</span> of <span class="math inline">\(e\)</span>. Thus, the stabilizing subgroup of<span class="math inline">\(e\)</span> is the same as the stabilizingsubgroup of <span class="math inline">\(p\)</span>. From the previouscomment, we know that this subgroup is generated by those simplereflections whose mirrors contain <span class="math inline">\(p\)</span>. These mirrors are either <span class="math inline">\(m_i\)</span> (bisects <span class="math inline">\(e\)</span>), or those containing <span class="math inline">\(v_0\)</span> and orthogonal to <span class="math inline">\(m_i\)</span> (contain <span class="math inline">\(e\)</span>), so the stabilizing subgroup of <span class="math inline">\(e\)</span> is generated by <span class="math inline">\(\rho_i\)</span> and those simple reflections thatfix <span class="math inline">\(v_0\)</span> and commute with <span class="math inline">\(\rho_i\)</span>. In the case of the cube, we have<span class="math inline">\(H=\langle \rho_0,\rho_2\rangle\)</span>, so<span class="math inline">\(|H|=4\)</span> and <span class="math inline">\(|G/H|=12\)</span>, confirming that the cube has 12edges.</li><li>We then find a set of coset representatives of <span class="math inline">\(G/H\)</span> and apply them to <span class="math inline">\(e\)</span> to obtain all edges of type <span class="math inline">\(i\)</span>.</li></ol><p>To find all faces of type <span class="math inline">\((i,j)\)</span>,where <span class="math inline">\(i\neq j\)</span>, we use the sameprocedure. If at least one of <span class="math inline">\(m_i,m_j\)</span> is active, then the rotation<span class="math inline">\(r_{ij}=\rho_i\rho_j\)</span> generates aface <span class="math inline">\(f\)</span> of type <span class="math inline">\((i,j)\)</span>, which is invariant under <span class="math inline">\(\rho_i\)</span> and <span class="math inline">\(\rho_j\)</span>. However, if <span class="math inline">\(v_0\)</span> lies on exactly one of the twomirrors and they are perpendicular, we need to be careful. In this case,the stabilizing subgroup of <span class="math inline">\(f\)</span> isgenerated by <span class="math inline">\(\rho_i\)</span>, <span class="math inline">\(\rho_j\)</span>, and those generators that fix<span class="math inline">\(v_0\)</span> and commute with both <span class="math inline">\(\rho_i\)</span> and <span class="math inline">\(\rho_j\)</span>. We then find a set of cosetrepresentatives of <span class="math inline">\(G/H\)</span> and applythem to <span class="math inline">\(f\)</span> to obtain all faces oftype <span class="math inline">\((i,j)\)</span>.</p><p>Now the key step is to compute a set of coset representatives of<span class="math inline">\(G/H\)</span> for a finitely presented group<span class="math inline">\(G\)</span> and its subgroup <span class="math inline">\(H\)</span>, which is exactly what the Todd-Coxeteralgorithm does.</p><p>The Todd-Coxeter algorithm can be thought of as a Sudoku game wherethe table to complete is a dynamically growing 2D array <span class="math inline">\(T\)</span>. The rows of <span class="math inline">\(T\)</span> are labeled by the right cosets in<span class="math inline">\(G/H\)</span>, and the columns of <span class="math inline">\(T\)</span> are labeled by the generators of <span class="math inline">\(G\)</span>. Each entry <span class="math inline">\(T[i][j]\)</span> records the right coset obtainedby multiplying the <span class="math inline">\(j\)</span>-th generatoron the right of the <span class="math inline">\(i\)</span>-th coset. Thealgorithm uses the defining relations in the presentation of <span class="math inline">\(G\)</span> and <span class="math inline">\(H\)</span> as guidelines to find new cosets andfill their corresponding entries in <span class="math inline">\(T\)</span>. The game ends when all entries in<span class="math inline">\(T\)</span> are filled, and the coset in eachentry has a row in <span class="math inline">\(T\)</span> and satisfiesall relations. The resulting <span class="math inline">\(T\)</span> isthe adjacency matrix of the Schreier graph of <span class="math inline">\(G/H\)</span>, and one can easily obtain a completelist of word representations for all cosets in <span class="math inline">\(G/H\)</span>.</p><p>For a more detailed treatment of the Todd-Coxeter algorithm, pleaserefer to the Handbook of Computational Group Theory (HCGT) or otherrelated literature.</p><blockquote><p>Chapter 5, Handbook of Computational Group Theory, Holt, D., Eick,B., O’Brien, E.</p></blockquote><p>I will demonstrate below how the algorithm works using the cube as anexample:</p><blockquote><p><strong>Example</strong>: let <span class="math inline">\(G\)</span>be the symmetric group of the cube: <span class="math display">\[\begin{align*}G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2&amp;=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3\\&amp;=(\rho_0\rho_2)^2=1\rangle.\end{align*}\]</span>and subgroup <span class="math inline">\(H=\langle \rho_1,\rho_2\rangle\)</span>. Find a set of coset representatives of <span class="math inline">\(G/H\)</span>.</p></blockquote><p><strong>Our known relations</strong>:</p><ol type="1"><li>For each generator word <span class="math inline">\(w\)</span> of<span class="math inline">\(H\)</span>, it holds <span class="math inline">\(Hw=H\)</span>, i.e.&nbsp;<span class="math inline">\(H\rho_1=H\)</span> and <span class="math inline">\(H\rho_2=H\)</span>.</li><li>For any coset <span class="math inline">\(K\)</span> and anygenerator relation <span class="math inline">\(r\)</span> of <span class="math inline">\(G\)</span> it holds <span class="math inline">\(Kr=K\)</span>, i.e.&nbsp;<span class="math inline">\(K\rho_i^2=K,i=0,1,2\)</span>, and <span class="math inline">\(K(\rho_0\rho_1)^4=K(\rho_1\rho_2)^3=K(\rho_0\rho_2)^2=K.\)</span></li></ol><p>These relations can be stored in two lists, one for the relations in<span class="math inline">\(H\)</span> and one for the relations in<span class="math inline">\(G\)</span>, each relation can be furtherstored as an array of int type.</p><p>The first list stores the generator words of <span class="math inline">\(H\)</span>:</p><blockquote><ol start="0" type="1"><li>(1,) // <span class="math inline">\(\rho_1\)</span></li><li>(2,) // <span class="math inline">\(\rho_2\)</span></li></ol></blockquote><p>The second list stores the defining relations of <span class="math inline">\(G\)</span>:</p><blockquote><ol start="2" type="1"><li>(0, 0) // <span class="math inline">\(\rho_0^2=1\)</span></li><li>(1, 1) // <span class="math inline">\(\rho_1^2=1\)</span></li><li>(2, 2) // <span class="math inline">\(\rho_2^2=1\)</span></li><li>(0, 1, 0, 1, 0, 1, 0, 1) // (<span class="math inline">\(\rho_0\rho_1)^4=1\)</span></li><li>(1, 2, 1, 2, 1, 2) // (<span class="math inline">\(\rho_1\rho_2)^3=1\)</span></li><li>(0, 2, 0, 2) // (<span class="math inline">\(\rho_0\rho_2)^2=1\)</span></li></ol></blockquote><p>The relations are numbered from 0 to 7 for easy reference in thefollowing steps.</p><blockquote><p><strong>Note</strong>: When <span class="math inline">\(G\)</span> isnot represented as a Coxeter group, for example in the case of snubpolytopes, we need to consider the inverse of the generators as well,and they also occupy their own columns in <span class="math inline">\(T\)</span>. Therefore, the actual number ofcolumns in <span class="math inline">\(T\)</span> is twice the number ofgenerators. However, for Coxeter groups, all generators are involutions,so there is no need to insert columns for their inverses.</p></blockquote><p>Initially, the table <span class="math inline">\(T\)</span> has onlyone row, corresponding to the coset <span class="math inline">\(H\)</span> (which is the only coset we know atthis point).</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>Here, the algorithm initializes <span class="math inline">\(H_0\)</span> to be the subgroup <span class="math inline">\(H\)</span> and checks if it satisfies allrelations in the first list. Once this check is done, the first list canbe discarded. Then, the algorithm scans all cosets of <span class="math inline">\(T\)</span> from top to bottom and verifies if thecurrent coset satisfies all relations in the second list. During thisprocess, new cosets may be defined and their rows are appended at theend of <span class="math inline">\(T\)</span>. However, it is importantto note that some cosets in the table may actually represent the samecoset, so care must be taken.</p><hr><p>Let’s start by scanning <span class="math inline">\(H_0\)</span> andchecking whether the relations in the first list are satisfied byit:</p><ol type="1"><li>For relation 0, we have <span class="math inline">\(H_0\rho_1=H_0\)</span>, i.e., <span class="math inline">\(T[0][1]=0\)</span>.</li><li>For relation 1, we have <span class="math inline">\(H_0\rho_2=H_0\)</span>, i.e., <span class="math inline">\(T[0][2]=0\)</span>.</li></ol><p><span class="math inline">\(T\)</span> is now updated as follows:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><p><strong>Now that <span class="math inline">\(H_0\)</span> satisfiesall relations in the first list, we can discard it and focus on checkingthe relations in the second list</strong>.</p><p>We move on to check the relations in the second list for <span class="math inline">\(H_0\)</span>:</p><p>(2). Relation 2 says <span class="math inline">\(H_0\rho_0^2=H_0\)</span>. Since we do not know<span class="math inline">\(H_0\rho_0\)</span> yet, we define it to be<span class="math inline">\(H_1\)</span>, fill in 1 in its entry <span class="math inline">\(T[0][0]\)</span>, and append a new row for <span class="math inline">\(H_1\)</span>:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><strong>Note that each time we define or find <span class="math inline">\(H_i\rho_j=H_k\)</span> for some <span class="math inline">\(i,j,k\)</span>, we automatically get the “dual”relation <span class="math inline">\(H_k\rho_j=H_i\)</span>. Therefore,we always fill in a pair of entries <span class="math inline">\(T[i][j]=k\)</span> and <span class="math inline">\(T[k][j]=i\)</span> at a time</strong>.</p><p>(3). Relations 3 and 4 are already satisfied, so we continue.</p><p>(4). Relation 5 says <span class="math inline">\(H_0\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1=H_0\)</span>.We already know <span class="math inline">\(H_0\rho_0=H_1\)</span>, but<span class="math inline">\(H_1\rho_1\)</span> is unknown, so we defineit to be <span class="math inline">\(H_2\)</span>. We fill in the twoentries <span class="math inline">\(T[1][3]=2\)</span> and <span class="math inline">\(T[2][3]=1\)</span> and append a new row for <span class="math inline">\(H_2\)</span>.</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><span class="math inline">\(H_2\rho_0\)</span> is not yet defined, sowe set <span class="math inline">\(H_2\rho_0=H_3\)</span> and update thecorresponding entries in <span class="math inline">\(T\)</span>:</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>Continuing with the scan, we notice that <span class="math inline">\(H_3\rho_1\)</span> is unknown, and we might betempted to define it as a new coset <span class="math inline">\(H_4\)</span> and continue. However, this strategycan create many redundant cosets, leading to a rapid growth of <span class="math inline">\(T\)</span>. Instead, we scan the relation inreverse order, trying to fill the gaps without introducing new cosets.Recall that we scanned from left to right, and we arrived at thefollowing position: <span class="math display">\[H_0\rho_0\rho_1\rho_0(=H_3)\rho_1\rho_0\rho_1\rho_0\rho_1=H_0.\]</span>Now, scanning from right to left, we get <span class="math inline">\(H_0\rho_1\rho_0\rho_1\rho_0=H_3\)</span>, whichmeans that <span class="math display">\[H_0\rho_0\rho_1\rho_0(=H_3)\rho_1=H_0\rho_1\rho_0\rho_1\rho_0=H_3.\]</span> Thus, we have deduced that<span class="math inline">\(H_3\rho_1=H_3\)</span>, instead of definingit as a new coset. This technique is called a<strong>deduction</strong>, as described in the book HCGT. Therefore, weupdate <span class="math inline">\(T\)</span> accordingly:</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><strong>So in the actual program we always scan a relation from bothends and define new cosets if necessary until they meet</strong>.</p><p>(5). Relation 6 is already satisfied, continue.</p><p>(6). Relation 7 says <span class="math inline">\(H_0\rho_0\rho_2\rho_0\rho_2=H_0\)</span>, scanningfrom both ends gives <span class="math display">\[H_0\rho_0(=H_1)\rho_2=H_0\rho_2\rho_0=H_1,\]</span>hence <span class="math inline">\(H_1\rho_2=H_1\)</span> and we makeanother deduction. <span class="math inline">\(T\)</span> nowbecomes</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>Now, <span class="math inline">\(H_0\)</span> satisfies all relationsin the two lists and the scanning of the first row is completed. We canmove on to begin scanning of the row for <span class="math inline">\(H_1\)</span>. Note the first list is nowdiscarded, and we will only check relations 2-7.</p><p>(1). Relations 2, 3, 4, and 5 are already satisfied. We can continueto the next relation. (2). Relation 6 says <span class="math inline">\(H_1\rho_1\rho_2\rho_1\rho_2\rho_1\rho_2=H_1\)</span>.We know that <span class="math inline">\(H_1\rho_1=H_2\)</span>, but<span class="math inline">\(H_2\rho_2\)</span> is unknown. Backwardscanning also gets stuck here: <span class="math display">\[H_1\rho_1(=H_2)\rho_2\rho_1=H_1\rho_2\rho_1\rho_2=H_2\rho_2.\]</span>So we define <span class="math inline">\(H_2\rho_2=H_4\)</span>. Then wehave <span class="math inline">\(H_4\rho_1=H_4\)</span>, and <span class="math inline">\(T\)</span> becomes:</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr></tbody></table><ol start="3" type="1"><li>Relation 7 is already satisfied for <span class="math inline">\(H_1\)</span>, so we can move on to scan the rowfor <span class="math inline">\(H_2\)</span>.</li></ol><hr><p>I’ll leave it as an exercise for you to complete the scanning of<span class="math inline">\(H_2\)</span>, <span class="math inline">\(H_3\)</span>, <span class="math inline">\(H_4\)</span>, and <span class="math inline">\(H_5\)</span>. These are relatively easy tasks.Once <span class="math inline">\(H_2\)</span> has been scanned, your<span class="math inline">\(T\)</span> should look like this:</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">3</td></tr></tbody></table><p>After completing the scanning of <span class="math inline">\(H_3\)</span>, your <span class="math inline">\(T\)</span> should be:</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr></tbody></table><p>After completing the scanning for <span class="math inline">\(H_4\)</span>, your <span class="math inline">\(T\)</span> should be:</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>And when we scan <span class="math inline">\(H_6\)</span>, we findthat relations 2-6 are already satisfied. From relation 7, <span class="math inline">\(H_6\rho_0\rho_2\rho_0\rho_2=H_6\)</span>, we get adeduction <span class="math inline">\(H_7\rho_2=H_7\)</span>, and <span class="math inline">\(T\)</span> is updated as follows:</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td></tr></tbody></table><p>One can check that <span class="math inline">\(H_7\)</span> satisfiesall relations in the second list, so no more cosets can be found and thegame is over.</p><p>The multiplication relations between these cosets can be obtainedusing breadth-first search:</p><p><span class="math display">\[\begin{array}{l}H_0 = H_0\cdot e,\\H_1=H_0\cdot\rho_0,\\H_2=H_1\cdot\rho_1=H_0\cdot\rho_0\rho_1,\\H_3=H_2\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0,\\H_4=H_2\cdot\rho_2=H_0\cdot\rho_0\rho_1\rho_2,\\H_5=H_3\cdot\rho_2=H_0\cdot \rho_0\rho_1\rho_0\rho_2,\\H_6=H_5\cdot\rho_1=H_0\cdot \rho_0\rho_1\rho_0\rho_2\rho_1,\\H_7=H_6\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0\rho_2\rho_1\rho_0.\end{array}\]</span></p><p>So a set of representatives can be chosen as</p><p><span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span> This is exactly what we have seen before.</p><blockquote><p><strong>Note</strong>: This example is a bit tedious, but it is stilla simple one because we did not encounter the case where two cosets inthe table are found to be the same (in the book HCGT, this is called a<strong>coincidence</strong>). When this occurs, the scanning must bepaused, and the control flow is jumped to handle this coincidence: a newstack <span class="math inline">\(q\)</span> is opened, and this pair ofcoincidences is pushed into <span class="math inline">\(q\)</span>.Then, one pair of coincidences is popped from <span class="math inline">\(q\)</span> at a time, their rows are merged, andnew coincidences that occur in the merging process are pushed into <span class="math inline">\(q\)</span>.</p></blockquote><h1 id="snub-polytopes">Snub polytopes</h1><p>Snub polytopes can be constructed by applying rotations in the fullsymmetry group to the initial vertex <span class="math inline">\(v_0\)</span>. In the case of the cube, we haveseen the full symmetry group <span class="math inline">\(G\)</span>is</p><p><span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p><span class="math inline">\(G\)</span> consists of 48 elements, halfof which are rotations, so totaling 24 rotations. These rotationsconstitute the symmetry group <span class="math inline">\(\widetilde{G}\)</span> of the snub cube, which canbe generated by three fundamental rotations: <span class="math inline">\(r_0=\rho_0\rho_1\)</span>, <span class="math inline">\(r_1=\rho_1\rho_2\)</span>, and <span class="math inline">\(r_2=\rho_0\rho_2\)</span>. Since <span class="math inline">\(r_0r_1=r_2\)</span>, it follows that <span class="math inline">\(\widetilde{G}\)</span> can be generated by only<span class="math inline">\(r_0\)</span> and <span class="math inline">\(r_1\)</span>.</p><p>A presentation of <span class="math inline">\(\widetilde{G}\)</span>is <span class="math display">\[\widetilde{G}=\langle r_0,r_1\ |\r_0^4=r_1^3=(r_0r_1)^2=1\rangle.\]</span> Using the Todd-Coxeteralgorithm, we can obtain a complete list of word representations of<span class="math inline">\(\widetilde{G}\)</span>:</p><p><span class="math display">\[\begin{array}{lll}e&amp;r_{0}&amp;r_{0}r_{0}\\r_{0}r_{0}r_{0}&amp;r_{1}&amp;r_{1}r_{1}\\r_{0}r_{1}&amp;r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{1}\\r_{0}r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}\\r_{1}r_{0}r_{0}&amp;r_{1}r_{0}r_{0}r_{0}&amp;r_{1}r_{1}r_{0}\\r_{1}r_{1}r_{0}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}\\r_{0}r_{0}r_{1}r_{1}r_{0}&amp;r_{1}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}r_{0}r_{1}r_{1}\\r_{1}r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{1}r_{0}r_{0}r_{1}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}r_{1}\end{array}\]</span></p><p>We choose the initial vertex <span class="math inline">\(v_0\)</span>so that it’s not on any of the three mirrors, and apply the above wordrepresentations of <span class="math inline">\(\widetilde{G}\)</span> to<span class="math inline">\(v_0\)</span>. This gives the 24 vertices ofthe snub cube.</p><p>To obtain the edges of the snub cube, the following steps can betaken:</p><ol type="1"><li>Each rotation <span class="math inline">\(r_i\,(i=0,1,2)\)</span>generates a base edge <span class="math inline">\(e\)</span>. These baseedges are in different orbits under the action of <span class="math inline">\(\widetilde{G}\)</span>.</li><li>The stabilizing subgroup of <span class="math inline">\(e\)</span>is <span class="math inline">\(H=\langle 1\rangle\)</span> if the orderof <span class="math inline">\(r_i\)</span> is greater than 2, or thecyclic group <span class="math inline">\(H=\langle r_i\rangle\)</span>if the order of <span class="math inline">\(r_i\)</span> is 2. The cosetrepresentatives of <span class="math inline">\(G/H\)</span> can becomputed, and applied to <span class="math inline">\(e\)</span> toobtain all other edges of type <span class="math inline">\(i\)</span>.</li></ol><p>The case of faces is slightly more involved:</p><ol type="1"><li><p>Each rotation <span class="math inline">\(r_i\,(i=0,1)\)</span>generates a base face <span class="math inline">\(f={v_0,r_i(v_0),\ldots, r_i^{m-1}(v_0)}\)</span> for <span class="math inline">\(m&gt;2\)</span>, where <span class="math inline">\(m\)</span> is the order of <span class="math inline">\(r_i\)</span>. For <span class="math inline">\(i=2\)</span>, <span class="math inline">\(m=2\)</span>, and <span class="math inline">\(f\)</span> is degenerated to an edge. Thestabilizing subgroup of <span class="math inline">\(f\)</span> is thecyclic group <span class="math inline">\(H=\langle r_i\rangle\)</span>.The coset representatives of <span class="math inline">\(G/H\)</span>can be computed, and applied to <span class="math inline">\(f\)</span>to obtain all other faces of type <span class="math inline">\(i\)</span>. For the snub cube, there are <span class="math inline">\(6\)</span> square faces generated by <span class="math inline">\(r_0\)</span> (since <span class="math inline">\(24/|\langle r_0\rangle|=24/4=6\)</span>), and<span class="math inline">\(8\)</span> triangle faces generated by <span class="math inline">\(r_1\)</span> (since <span class="math inline">\(24/|\langle r_1\rangle|=24/3=8\)</span>).</p></li><li><p>There is another type of triangle faces which comes from therelation <span class="math inline">\(r_0r_1=r_2\)</span>. Let’s considerthe three vertices <span class="math inline">\({v_0,v_0r_1,v_0r_2}\)</span>. We see that <span class="math inline">\((v_0, v_0r_1)\)</span> is an edge of type 1 and<span class="math inline">\((v_0, v_0r_2)\)</span> is an edge of type 2.But we also have <span class="math display">\[(v_0,v_0r_0)\xrightarrow{\ r_1\ }(v_0r_1, v_0r_0r_1) = (v_0r_1,v_0r_2).\]</span> That is, <span class="math inline">\((v_0r_1,v_0r_2)\)</span> is an edge of type 0 obtained by applying <span class="math inline">\(r_1\)</span> to the base edge <span class="math inline">\((v_0, v_0r_0)\)</span>. The stabilizing subgroupof this triangle must be <span class="math inline">\(\langle1\rangle\)</span> since all its three edgesare in different orbits. Thereforre, we have <span class="math inline">\(|\widetilde{G}|/1=24\)</span> triangle faces ofthis “mixed type”, which are not generated by any of the “fundamentalrotations”.</p></li></ol><p>So the snub cube has <span class="math inline">\(6+8+24=38\)</span>faces in total.</p><h1 id="star-polytopes">Star polytopes</h1><p>Most star polytopes can be generated using the Wythoff construction,but generally, it is not enough to use the method described abovedirectly. You also need to add an additional generating relation intothe group’s presentation.</p><p>To illustrate, let’s take the great dodecahedron as an example. ItsCoxeter-Dynkin diagram is shown below:</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/coxeter552.svg" width="250"></p><p>Therefore, the angles between the mirrors are <span class="math inline">\(\pi-2\pi/5, \pi/2, \pi-\pi/5\)</span>. If wecontinue with the previous analysis, we obtain the presentation of thesymmetry group as:</p><p><span class="math display">\[K = \langle\tau_0,\tau_1,\tau_2 \|\  \tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=(\tau_0\tau_2)^2=1\rangle.\]</span></p><p>This group is infinite, and since the quotient group of thestabilizer subgroup of <span class="math inline">\(v_0\)</span> is alsoinfinite, the Todd-Coxeter algorithm will not work here.</p><p>In fact, we just need to add another generating relation to thepresentation, namely <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>. With thisaddition, the presentation of the symmetry group becomes:</p><p><span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>Note that I intentionally used <span class="math inline">\(\tau\)</span> to represent reflections and <span class="math inline">\(K\)</span> to denote the symmetry group of thegreat dodecahedron. What’s happening here? Let’s take a look at thevideo:</p><video src="/images/polytopes/great-dodecahedron.mp4" controls=""></video><p>From the video, we can observe that the great dodecahedron and theicosahedron share the exact same set of vertices. However, it seems thatthe great dodecahedron can be obtained by digging some triangular holeson the surface of the icosahedron. In general, if the hole of astar-shaped polyhedron is a polygon with <span class="math inline">\(h\)</span> sides, the corresponding extra relationis given by <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^h=1\)</span>.</p><p>Let’s take a closer look at the fundamental region of the greatdodecahedron:</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/star.png" width="600"></p><p>The figure above shows <span class="math inline">\(\DeltaABC\)</span> as the fundamental domain of the icosahedron. Its internalangles are <span class="math inline">\(\angle CAB=\pi/5\)</span>，<span class="math inline">\(\angle CBA=\pi/2\)</span>，<span class="math inline">\(\angle ACB=\pi/3\)</span>. Reflections about thearcs <span class="math inline">\(BC\)</span>, <span class="math inline">\(AC\)</span>, and <span class="math inline">\(AB\)</span> are denoted by <span class="math inline">\(\rho_0\)</span>, <span class="math inline">\(\rho_1\)</span>, and <span class="math inline">\(\rho_2\)</span>, respectively. The presentation ofthe symmetry group of icosahedron, <span class="math inline">\(G\)</span>, can be expressed as follows: <span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^3=(\rho_1\rho_2)^5=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p>The great dodecahedron can be constructed as follows: we keep thevertices and edges of the icosahedron untouched, but change its faces.To do this we start a walk from vertex <span class="math inline">\(Q\)</span> and move along edge <span class="math inline">\(QA\)</span> to reach the next vertex <span class="math inline">\(A\)</span>. At <span class="math inline">\(A\)</span>, we skip the first edge on the right(<span class="math inline">\(AO\)</span>) and choose the second one,which is <span class="math inline">\(AK\)</span>, to follow and move tovertex <span class="math inline">\(K\)</span> (sorry for abusing thenotation <span class="math inline">\(K\)</span> here). We continuemoving in this way by always choosing the second edge to the right. Ittakes five steps to return to <span class="math inline">\(Q\)</span>,forming a pentagonal face of the great dodecahedron. By performing thisoperation for all edges of the icosahedron, we can generate all thefaces of the great dodecahedron.</p><p>This operaion is called <strong>faceting</strong>, it changes thefaces of a given polyhedron while preserving its vertices and edges.This is achieved by walking along the edges of the original polyhedronand choosing the <span class="math inline">\(k\)</span>-th edge to theright of the current path, where <span class="math inline">\(k\geq2\)</span> is a fixed integer. By repeating this process until a closedloop is formed, a new face is created. In our project, we use <span class="math inline">\(k=2\)</span>.</p><p>Let’s derive the relations between the symmetry groups <span class="math inline">\(G\)</span> and <span class="math inline">\(K\)</span>:</p><p>Consider the triangle <span class="math inline">\(\DeltaOAB\)</span>, which has internal angles <span class="math inline">\(\angle OAB=2\pi/5\)</span>, <span class="math inline">\(\angle OBA=\pi/2\)</span>, and <span class="math inline">\(\angle AOB=\pi/5\)</span>, and contains threecongruent triangles with the triangle <span class="math inline">\(\DeltaABC\)</span>. The reflections about its three edges <span class="math inline">\(OA\)</span>, <span class="math inline">\(OB\)</span>, and <span class="math inline">\(AB\)</span> are denoted by <span class="math inline">\(\tau_1=\rho_1\rho_2\rho_1\)</span>, <span class="math inline">\(\tau_0=\rho_0\)</span>, and <span class="math inline">\(\tau_2=\rho_2\)</span>.</p><p>In the language of group theory, the faceting operation <span class="math inline">\(\varphi_k\)</span> can be described astransforming the group <span class="math inline">\(G\)</span> intoanother group <span class="math inline">\(K\)</span>:</p><p><span class="math display">\[G=\langle\rho_0,\rho_1,\rho_2\rangle\xrightarrow{\ \varphi_k\}\langle\rho_0,\rho_1(\rho_2\rho_1)^{k-1},\rho_2\rangle=\langle\tau_0,\tau_1,\tau_2\rangle=K.\]</span></p><p>Usually, <span class="math inline">\(K\)</span> is a subgroup of<span class="math inline">\(G\)</span>, but in many cases, including thegreat dodecahedron here, <span class="math inline">\(G\)</span> and<span class="math inline">\(K\)</span> are the same group.</p><p>To see that <span class="math inline">\(K\)</span> is indeed thesymmetry group of the great dodecaheron, we can argue as follows:</p><p>Firstly, <span class="math inline">\(\langle\tau_1,\tau_2\rangle=\langle \rho_1,\rho_2\rangle\)</span> is thestabilizer subgroup of the vertex <span class="math inline">\(A\)</span>, so the great dodecahedron has the sameset of vertices as that of the icosahedron. However, <span class="math inline">\(\tau_1\tau_2\)</span> gives a rotation of <span class="math inline">\(4\pi/5\)</span>, which differs from <span class="math inline">\(\rho_1\rho_2\)</span> that gives a rotation of<span class="math inline">\(2\pi/5\)</span>. Consequently, the vertexconfiguration of the great dodecahedron forms a pentagram, whereas thatof the icosahedron forms a pentagon.</p><p>Secondly, the subgroup <span class="math inline">\(\langle\tau_0,\tau_2\rangle=\langle \rho_0,\rho_2\rangle\)</span> is thestabilizer of the edge <span class="math inline">\(AQ\)</span>. Thus,the great dodecahedron shares its edges with those of theicosahedron.</p><p>Thirdly, <span class="math inline">\(\langle\tau_0,\tau_1\rangle\)</span> is thestabilizer subgroup of one of the faces of the great dodecahedron. Notethat <span class="math inline">\(\tau_0\tau_1\)</span> is a rotation of<span class="math inline">\(2\pi/5\)</span> arounds <span class="math inline">\(O\)</span>. It maps the edge <span class="math inline">\(QA\)</span> to the edge <span class="math inline">\(AK\)</span>, corresponding to the operation ofselecting the <span class="math inline">\(k\)</span>-th edge to walk on.Repeatedly applying <span class="math inline">\(\tau_0\tau_1\)</span> to<span class="math inline">\(QA\)</span> will give the five edges of oneface of the great dodecahedron.</p><p>Let’s find out a hidden relation among <span class="math inline">\(\tau_0,\tau_1\)</span> and <span class="math inline">\(\tau_2\)</span>:</p><p>Note that <span class="math inline">\(\tau_1\tau_2\tau_1=\tau_1\rho_2\tau_1\)</span> isa reflection about <span class="math inline">\(AP\)</span>, and itscomposition with <span class="math inline">\(\tau_0=\rho_0\)</span> is arotation around the vertex <span class="math inline">\(P\)</span> by anangle of <span class="math inline">\(2\pi/3\)</span>, so <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>. Addingthis additional generating relation to the presentation of gives thecorrect presentation of <span class="math inline">\(K\)</span>:</p><p><span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>The remaining steps of the construction are identical to the previousones.</p><p>This extra relation has a geometric explanation: By applying thefaceting operation to the great dodecahedron again, we can restore ouricosahedron. We simply walk from <span class="math inline">\(Q\)</span>to <span class="math inline">\(A\)</span>, and when we reach <span class="math inline">\(A\)</span>, instead of selecting the edge <span class="math inline">\(AK\)</span> to continue moveing, we choose itsprevious one clockwise, which is <span class="math inline">\(AO\)</span>. Continuing to walk gives us back thetriangle face <span class="math inline">\(\Delta OAB\)</span> of theicosahedron. This correspondes to the exponent 3 in the extrarelation.</p><p>In terms of group theory, this can be expressed as <span class="math display">\[K=\langle\tau_0,\tau_1,\tau_2\rangle\xrightarrow{\ \varphi_2\}\langle\tau_0,\tau_1\tau_2\tau_1,\tau_2\rangle=\langle\rho_0,\rho_2\rho_1\rho_2,\rho_2\rangle=G.\]</span></p><p>One might wonder if there are more such relationships we haveoverlooked. However, since we know that <span class="math inline">\(K\)</span> is isomorphic to <span class="math inline">\(G\)</span> (though not proved in this article),there’s no cause for concern.</p><h1 id="appendix">Appendix</h1><p>I also added a script <code>run_coset_enumeration.py</code> forshowing how to compute the coset table of <span class="math inline">\(G/H\)</span> for a given finitely presented group<span class="math inline">\(G\)</span> and its subgroup <span class="math inline">\(H\)</span> (necessarily <span class="math inline">\(|G/H|&lt;\infty\)</span>). It assumes a<code>yaml</code> file as input which describes the presentation of<span class="math inline">\(G\)</span> and <span class="math inline">\(H\)</span>. An example format is</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">G8723</span><br><span class="hljs-attr">relators:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">a^8</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">b^7</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">(ab)^2</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">(Ab)^3</span><br><span class="hljs-attr">subgroup-generators:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">aa</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">Ab</span><br></code></pre></td></tr></tbody></table></figure><p>Here we use the convention that uppercase means the inverse oflowercase, i.e.&nbsp;<span class="math inline">\(A=a^{-1},B=b^{-1}\)</span>.</p><p>So the presentation of this group is <span class="math display">\[G =\langle a, b\ |\ a^8=b^7=(ab)^2=(a^{-1}b)^3=1\rangle\]</span> and <span class="math inline">\(H=\langle a^2, a^{-1}b\rangle\)</span>.</p><p>Save this file as <code>G8723.yaml</code> and run </p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python run_coset_enumeration.py G8723.yaml<br></code></pre></td></tr></tbody></table></figure> Theoutput should be (with some output omitted)<p></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plain">           a    A    b    B<br>------------------------------<br>    1:     2    2    3    2<br>    2:     1    1    1    4<br>    3:     4    5    6    1<br>    4:     7    3    2    8<br>  ...    ...  ...  ...  ...<br>  ...    ...  ...  ...  ...<br>  ...    ...  ...  ...  ...<br>  446:   444  444  441  430<br>  447:   438  433  432  443<br>  448:   445  445  440  445<br></code></pre></td></tr></tbody></table></figure><p>so <span class="math inline">\(G/H\)</span> has 448 cosets.</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Walk the dog: winding number and Rouché theorem</title>
      <link href="rouche-theorem/index.html"/>
      <url>rouche-theorem/index.html</url>
      
        <content type="html"><![CDATA[<p>I made a Shadertoy animation that demonstrates a metaphor fromchapter 7, “Winding numbers and topology”, of Needham’s famous book“Visual Complex Analysis”:</p><p>A man and his dog walking around a tree in a park, both of theirpaths are closed curves, meaning they return to their starting pointafter some time. If the person keeps the dog leash tight enough, suchthat the dog cannot touch the tree, then after they return to theirstarting positions, the number of circles made around the tree by theperson and the dog are the same: (The tree’s location is the origin,marked with a dial)</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/fdK3RD?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><p>The math behind this animation is: If two closed curves <span class="math inline">\(\gamma_1,\gamma_2\)</span> do not pass through theorigin and <span class="math inline">\(\gamma_1\)</span> can becontinuously deformed into <span class="math inline">\(\gamma_2\)</span>without touching the origin (homotopy), then <span class="math inline">\(\gamma_1,\gamma_2\)</span> have the same <a href="https://en.wikipedia.org/wiki/Winding_number">winding number</a>around the origin.</p><p>Note that this fact only requires <span class="math inline">\(\gamma_1,\gamma_2:, [0,1]\to\mathbb{R}^2\)</span>to be two continuous curves and does not involve analyticity. As theconcepts of winding number and homotopy only require continuity.</p><p>When <span class="math inline">\(\gamma_1=f(S^1),\gamma_2=g(S^1)\)</span> are theimages of the unit circle <span class="math inline">\(S^1:\{z\in\mathbb{C}:|z|=1\}\)</span> under twoanalytic functions <span class="math inline">\(f,g\)</span>, the <a href="https://en.wikipedia.org/wiki/Argument_principle">argumentprinciple</a> tells us that the winding numbers of <span class="math inline">\(\gamma_1,\gamma_2\)</span> around the origin areequal to the number of zeros of <span class="math inline">\(f,g\)</span>inside <span class="math inline">\(S^1\)</span>, respectively. Further,Rouché’s theorem tells us that if for any <span class="math inline">\(z\in S^1\)</span> we have <span class="math inline">\(|f(z)|&gt;|f(z)-g(z)|\)</span>, then <span class="math inline">\(\gamma_1,\gamma_2\)</span> have the same windingnumber around the origin, thereby <span class="math inline">\(f,g\)</span> have the same number of zeros inside<span class="math inline">\(S^1\)</span>. The condition of Rouché’stheorem is essentially saying, if we assume the person’s position is<span class="math inline">\(f(z)\)</span>, the dog’s position is <span class="math inline">\(g(z)\)</span>, and the leash <span class="math inline">\(l(z)=f(z)-g(z)\)</span> has length <span class="math inline">\(|l(z)|\)</span> always less than the distance fromthe person to the origin <span class="math inline">\(|f(z)|\)</span>,then it can be guaranteed that the dog cannot reach the origin.</p><p>In the animation, the circle in the bottom left is <span class="math inline">\(S^1\)</span>, and the paths on the right in redand green are respectively <span class="math inline">\(f(S^1)\)</span>and <span class="math inline">\(g(S^1)\)</span>. Here, <span class="math inline">\(f\)</span> is taken as <span class="math display">\[f(z)=\frac{z-a}{1-\overline{a}z}\frac{z-b}{1-\overline{b}z}\frac{z-c}{1-\overline{c}z}(z-2-2i),\quad |a|,|b|,|c|&lt;1.\]</span> <span class="math inline">\(f(z)\)</span> has 3 roots <span class="math inline">\(a,b,c\)</span> inside <span class="math inline">\(S^1\)</span> (marked with red dots), has no rootson <span class="math inline">\(S^1\)</span>, and has a root outside<span class="math inline">\(S^1\)</span> (not shown). The first threefactors of <span class="math inline">\(f(z)\)</span> form a Blaschkeproduct, mapping the inside of <span class="math inline">\(S^1\)</span>to its inside and mapping <span class="math inline">\(S^1\)</span> to<span class="math inline">\(S^1\)</span> itself, so for any <span class="math inline">\(z\in S^1\)</span> we have <span class="math display">\[|f(z)| = |z - 2 - 2i| \geq 2\sqrt{2} - 1,\quadz\in S^1.\]</span> Thus, as long as the leash <span class="math inline">\(l(z)\)</span> satisfies <span class="math inline">\(|l(S^1)| &lt; 2\sqrt{2}-1\)</span>, the dog’s path<span class="math inline">\(g(S^1)=f(S^1)+l(S^1)\)</span> won’t touchthe origin. Here, I took <span class="math inline">\(l(z) = cz\)</span>,where <span class="math inline">\(c\)</span> is a positive real numberless than <span class="math inline">\(2\sqrt{2}-1\)</span>.</p><p>Chapter 7 of Needham’s book also discussed another fact: the windingnumber of a curve <span class="math inline">\(\gamma\)</span> isconstant on each connected component of <span class="math inline">\(\mathbb{C}\setminus\gamma\)</span>. For a point<span class="math inline">\(z\notin\gamma\)</span>, we can slightly move<span class="math inline">\(z\)</span> to another point <span class="math inline">\(z'\)</span>, as long as <span class="math inline">\(z'\)</span> remains within the same connectedcomponent as <span class="math inline">\(z\)</span>, then <span class="math inline">\(\gamma\)</span> has the same winding number around<span class="math inline">\(z\)</span> and <span class="math inline">\(z'\)</span>. Using this fact, combined withthe argument principle, it’s not difficult to derive the followingcorollary:</p><blockquote><p><strong>Corollary</strong>: Let <span class="math inline">\(\gamma\)</span> be a simple closed curve,enclosing a region <span class="math inline">\(\Omega\)</span>, and<span class="math inline">\(f(z)\)</span> be a non-constant analyticfunction that analytic in a region containing <span class="math inline">\(\gamma\)</span>. Suppose there are two trees atpoints <span class="math inline">\(w_0,,w_1\)</span>, and the humanwalking path <span class="math inline">\(f(\gamma)\)</span> alwaysmaintains a distance greater than the distance between the two treesfrom <span class="math inline">\(w_0\)</span>: i.e., <span class="math display">\[|f(z)-w_0| &gt; |w_0-w_1|\]</span> for all <span class="math inline">\(z\in\gamma\)</span>, then <span class="math inline">\(f(\gamma)\)</span> has the same winding numberaround <span class="math inline">\(w_0,w_1\)</span>, thereby the numberof preimages of <span class="math inline">\(w_0,w_1\)</span> inside<span class="math inline">\(\Omega\)</span> is the same:</p><p><span class="math display">\[\sharp\{z\in \Omega: f(z)=w_0\} =\sharp\{z\in \Omega: f(z)=w_1\}.\]</span></p></blockquote><p>This is because, under the assumption, moving from <span class="math inline">\(w_0\)</span> along the line segment <span class="math inline">\([w_0,w_1]\)</span> to <span class="math inline">\(w_1\)</span> will never touch the curve <span class="math inline">\(f(\gamma)\)</span>, so <span class="math inline">\(w_0,w_1\)</span> must be located within the sameconnected component of <span class="math inline">\(\mathbb{C}\setminusf(\gamma)\)</span>.</p><p><img style="margin:0px auto;display:block" src="/images/rouche/winding_number.svg" width="250"></p><p>Using this corollary, we can easily derive the <a href="https://en.wikipedia.org/wiki/Open_mapping_theorem_(complex_analysis)">openmapping theorem</a> of complex analysis:</p><blockquote><p><strong>Theorem</strong>: If <span class="math inline">\(U\subseteq\mathbb{C}\)</span> is an open set and<span class="math inline">\(f:U\to\mathbb{C}\)</span> is a non-constantanalytic function, then <span class="math inline">\(f(U)\)</span> isalso an open set.</p></blockquote><p>I leave the proof to you (feel free to write your answer in thecomments section).</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd Kemp 概率论课程笔记</title>
      <link href="todd-kemp/bak2.html"/>
      <url>todd-kemp/bak2.html</url>
      
        <content type="html"><![CDATA[<h1 id="banach-tarski">0 Banach Tarski</h1><p><strong>不可测集的例子</strong>：记单位圆 <span class="math inline">\(S^1=\{e^{it},\,t\in\mathbb{R}\}\)</span>，子群<span class="math inline">\(H=\{e^{iq},\,q\in\mathbb{Q}\}\)</span>，在每个左陪集<span class="math inline">\(S^1/H\)</span> 中选择一个代表元组成集合<span class="math inline">\(E\)</span>，则 <span class="math inline">\(E\)</span> 是不可测集合。这是因为 <span class="math inline">\(S^1 = \bigcup_{q\in\mathbb{Q}}Ee^{iq}\)</span>是可数多个互不相交的集合的并，这些集合两两之间只差乘以一个单位复数，即差一个旋转，所以测度均相等，于是<span class="math display">\[1 = \sum_{q\in\mathbb{Q}}\mu(E) =\infty\cdot \mu(E)\Rightarrow E\text{\ is not measuabe.}\]</span></p><h1 id="measurable-functions">6.2 Measurable Functions</h1><p>本讲介绍了测度空间上可测映射的概念。</p><blockquote><p><strong>引理</strong>：设 <span class="math inline">\(f:\Omega\to\mathcal{S}\)</span> 是一个映射，<span class="math inline">\(\mathcal{A}\subset2^\mathcal{S}\)</span> 是 <span class="math inline">\(\mathcal{S}\)</span> 中一个集合族，定义 <span class="math display">\[f^{-1}(\mathcal{A}) =\{f^{-1}(E),E\in\mathcal{A}\}.\]</span> 则 <span class="math inline">\(\sigma(f^{-1}(\mathcal{A}))=f^{-1}(\sigma(\mathcal{A}))\)</span>。</p></blockquote><p>引理的证明不难， 只要注意到一个 <span class="math inline">\(\sigma-\)</span> 域在映射下的像 (push forward)和逆映射下的原像 (push back) 都是 <span class="math inline">\(\sigma-\)</span> 域即可。</p><blockquote><p><strong>定义：</strong>若 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 和 <span class="math inline">\((\mathcal{S}, \mathcal{B})\)</span>是两个可测空间，我们称 <span class="math inline">\(f:\Omega\to\mathcal{S}\)</span>是一个可测映射，如果有 <span class="math inline">\(f^{-1}(\mathcal{B})\subseteq\mathcal{F}\)</span>。</p></blockquote><p>要检查一个映射是不是可测的，我们不必对每个 <span class="math inline">\(B\in\mathcal{B}\)</span> 都检查，只要对满足 <span class="math inline">\(\sigma(\mathcal{A})=\mathcal{B}\)</span>的一个子集合族 <span class="math inline">\(\mathcal{A}\)</span> 检查有<span class="math inline">\(f^{-1}(\mathcal{A})\subseteq\mathcal{F}\)</span>即可。这是因为由上面的引理， <span class="math display">\[f^{-1}(\mathcal{B})=f^{-1}(\sigma(\mathcal{A}))=\sigma(f^{-1}(\mathcal{A}))\subseteq\mathcal{F}.\]</span></p><blockquote><p><strong>推论</strong>：如果 <span class="math inline">\(X_1,\ldots,X_n\)</span> 都是测度空间 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 上的可测函数，<span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}\)</span>是一个连续或者 Borel 可测的多元函数，则 <span class="math inline">\(Y=f(X_1,\ldots,X_n)\)</span> 也是可测函数。</p></blockquote><p>证明：记 <span class="math inline">\(X=(X_1,\ldots,X_n)\)</span>，我们要说明复合映射<span class="math display">\[\Omega\xrightarrow{\ X\}\mathbb{R}^n\xrightarrow{\ f\ }\mathbb{R}\]</span> 是可测的。由于 <span class="math inline">\(f\)</span> 显然可测，只要再说明 <span class="math inline">\(X\)</span> 是可测的。根据上面的引理，只要验证<span class="math display">\[X^{-1}\left((-\infty, t_1], (-\infty,t_2],\ldots, (-\infty, t_n]\right)=\bigcap_{i=1}^n \{X_i\leqt_i\}.\]</span> 是可测的，这显然。</p><h1 id="robustness-of-measurability">7.1 Robustness ofMeasurability</h1><p>本讲主要介绍了可测函数集合在通常的运算，以及取极限的操作下得到的仍然是可测函数。</p><p>下面这个结论在整个课程中都会频繁用到：</p><blockquote><p><strong>推论 (Doob-Dynkin 分解)</strong>：设 <span class="math inline">\(X_1,\ldots,X_d, Y\)</span> 都是 <span class="math inline">\((\Omega,\mathcal{F})\to(\mathbb{R},\mathcal{B}(\mathbb{R}))\)</span>的可测函数，而且 <span class="math inline">\(Y\)</span> 还关于 <span class="math inline">\(\sigma(X_1,\ldots,X_d)\)</span> 可测，则存在 Borel可测函数 <span class="math inline">\(f:\mathbb{R}^d\to\mathbb{R}\)</span> 使得 <span class="math inline">\(Y=f(X_1,\ldots,X_d)\)</span>。</p></blockquote><p>记 <span class="math inline">\(X=(X_1,\ldots,X_d)\)</span>，则 <span class="math inline">\(X:\Omega\to\mathbb{R}^d\)</span> 是 <span class="math inline">\(\mathcal{F}/\mathcal{B}(\mathbb{R}^d)\)</span>可测的。</p><p>我们先来说明有 <span class="math inline">\(\sigma(X_1,\ldots,X_n)=X^{-1}(\mathcal{B}(\mathbb{R}^d))\)</span>成立。这个基本就是把之前 6.2 讲的引理证了一遍。为方便记 <span class="math display">\[I^d=\{(-\infty,t_1]\times\cdots\times(-\infty,t_d],\ t_i\in\mathbb{R}\text{ or }t_i=+\infty\}.\]</span> 首先 <span class="math inline">\(\mathcal{B}(\mathbb{R}^d)\)</span> 在 <span class="math inline">\(X^{-1}\)</span> 下的 pull back <span class="math inline">\(X^{-1}(\mathcal{B}(\mathbb{R}^d))\)</span> 是一个<span class="math inline">\(\sigma\)</span>- 域，而且包含 <span class="math inline">\(X^{-1}(I^d)\)</span>，所以包含任何形如 <span class="math inline">\(\{X_i\leq t_i\}\)</span> 的集合，从而包含所有的<span class="math inline">\(\sigma(X_i)\)</span>，即包含 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span>。</p><p>另一方面 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span>在 <span class="math inline">\(X\)</span> 下的 push forward <span class="math inline">\(X(\sigma(X_1,\ldots,X_n))\)</span> 也是一个 <span class="math inline">\(\sigma\)</span>- 域，并且包含 <span class="math inline">\(I^d\)</span>，所以也就包含 <span class="math inline">\(\mathcal{B}(\mathbb{R}^d)\)</span>。</p><p>回到推论证明。我们首先对 <span class="math inline">\(Y=\mathbb{1}_{A},\,A\in\sigma(X_1,\ldots,X_n)\)</span>是指标函数的情形证明。由于 <span class="math inline">\(\sigma(X_1,\ldots,X_n)=X^{-1}(\mathcal{B}(\mathbb{R}^d)\)</span>，所以存在<span class="math inline">\(B\in\mathcal{B}(\mathbb{R}^d)\)</span> 使得<span class="math inline">\(A=X^{-1}(B)\)</span>。于是 <span class="math display">\[\mathbb{1}_{A}=\mathbb{1}_{X^{-1}(B)} =\mathbb{1}_{B}\circ X.\]</span> <span class="math inline">\(\mathbb{1}_B\)</span> 当然是 <span class="math inline">\(\mathcal{B}(\mathbb{R}^d)/\mathcal{B}\)</span>可测函数，所以结论成立。</p><p>由此很容易得出结论对任意简单函数都成立。</p><p>对一般的可测函数 <span class="math inline">\(Y\in\sigma(X_1,\ldots,X_d)\)</span>，取简单函数列<span class="math inline">\(\phi_n\toY,\,\phi_n\in\sigma(X_1,\ldots,X_d)\)</span>。根据上面的结论，存在可测函数<span class="math inline">\(f_n:\mathbb{R}^d\to\mathbb{R}\)</span> 使得<span class="math inline">\(\phi_n=f_n(X)\)</span>。记 <span class="math inline">\(f=\varlimsup f_n\)</span>，则有 <span class="math display">\[f(X)=\varlimsup f_n(X)=\varlimsup \phi_n =\lim\phi_n = Y.\]</span> 结论得证。</p><h1 id="monotone-convergence-theorem">8.2 Monotone convergencetheorem</h1><p>本讲给出了<strong>非负可测函数积分</strong>的定义：设 <span class="math inline">\(f\in L^+\)</span> 为非负可测函数，其积分定义为<span class="math display">\[\int f\,\mathrm{d}\mu=\sup\left\{\int\varphi\,\mathrm{d}\mu:\ \varphi\leq f,\ \varphi \text{simple and measuable}\right\}.\]</span></p><p>这个定义的问题在于不容易直接得出积分的可加性： <span class="math display">\[\int (f+g) \,\mathrm{d}\mu=\int f\,\mathrm{d}\mu+\int g\,\mathrm{d}\mu.\]</span></p><p>为此先证明了单调收敛定理：</p><blockquote><p><strong>单调收敛定理 (MCT)</strong>：若 <span class="math inline">\(\{f_n\}\in L^+\)</span> 且 <span class="math inline">\(f_n\uparrow f\)</span>，则 <span class="math inline">\(\int f_n\,\mathrm{d}\mu\uparrow \intf\,\mathrm{d}\mu\)</span>。</p></blockquote><p><strong>证明概要</strong>：显然 <span class="math inline">\(\lim\limits_{n\to\infty}\intf_n\,\mathrm{d}\mu\)</span> 存在且小于等于 <span class="math inline">\(\intf\,\mathrm{d}\mu\)</span>。为了证明二者相等，只要证明对任何简单函数<span class="math inline">\(\varphi\leq f\)</span> 有 <span class="math display">\[\lim_{n\to\infty} \int f_n\,\mathrm{d}\mu\geq\int \varphi\,\mathrm{d}\mu\]</span> 即可。<strong>不要指望通过分析集合<span class="math inline">\(\{f_n\geq \varphi\}\)</span>来得出结论</strong>，这完全可能对任何 <span class="math inline">\(n\)</span> 都是空集。但是如果可以证明对任何 <span class="math inline">\(0&lt;c&lt;1\)</span> 有 <span class="math display">\[\lim_{n\to\infty} \int f_n\,\mathrm{d}\mu\geq c\int \varphi\,\mathrm{d}\mu\]</span> 成立，那么令 <span class="math inline">\(c\uparrow1\)</span>即得结论（两边都是非负的）。而集合 <span class="math inline">\(E_n=\{f_n\geq c\varphi\}\)</span> 满足 <span class="math inline">\(E_n\uparrow\Omega\)</span>。于是由 <span class="math inline">\(f_n\geq c\varphi\mathbb{1}_{E_n}\)</span>以及积分单调性有 <span class="math display">\[\intf_n\,\mathrm{d}\mu\geqc\int\varphi\mathbb{1}_{E_n}\,\mathrm{d}\mu.\]</span> 由于 <span class="math inline">\(\varphi\)</span> 是简单函数，所以可设 <span class="math inline">\(\varphi = \sum_{k} a_k\mathbb{1}_{A_k}\)</span>并代入上面右边，有 <span class="math display">\[\intf_n\,\mathrm{d}\mu\geq c\int\varphi\mathbb{1}_{E_n}\,\mathrm{d}\mu=c\sum_{k}a_k\mu(A_k\cap E_n).\]</span> 令 <span class="math inline">\(n\to\infty\)</span> 并利用测度连续性 <span class="math inline">\(\mu(A_k\cap E_n)\uparrow\mu(A_k)\)</span> 即得<span class="math display">\[\lim_{n\to\infty} \intf_n\,\mathrm{d}\mu\geq c\sum_ka_k\mu(A_k)= c \int\varphi\,\mathrm{d}\mu.\]</span> 单调收敛定理得证。</p><p><strong>MCT告诉我们总是可以用一个只取有限多个值、每个值都有限的简单函数来逼近 <span class="math inline">\(f\)</span> 的积分</strong>。</p><p>非负可测函数 <span class="math inline">\(f\)</span>可以用简单函数序列 <span class="math display">\[\varphi_n =\sum_{k=1}^{2^{2n}}\frac{k-1}{2^n}\mathbb{1}_{\{\frac{k-1}{2^n}\leqf&lt;\frac{k}{2^n}\}} + 2^n\mathbb{1}_{\{f\geq 2^n\}}\]</span>来逼近。在第 <span class="math inline">\(n\)</span>次切割中，我们将切割范围扩大为原来的 2 倍以逼近 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(\infty\)</span>的部分，同时将切割的间隔缩小为原来的 1/2 以保证逼近的误差是减小的。</p><h1 id="integrals-and-null-sets">9.1 Integrals and Null Sets</h1><p>本讲主要是论证积分的基本结论在 <span class="math inline">\(\mathrm{a.e.}\)</span>的情形下也都成立。此外介绍了非负可测函数列积分的 Fatou定理，它是上一讲中单调收敛定理的直接推论：</p><blockquote><p><strong>Fatou 定理</strong>：设 <span class="math inline">\(f_n\inL^+\)</span> 是非负可积函数列，则 <span class="math display">\[\int\liminf f_n\,\mathrm{d}\mu\leq \liminf \intf_n\,\mathrm{d}\mu.\]</span></p></blockquote><p>证明：设 <span class="math inline">\(g_n=\inf_{m\geqn}f_m\)</span>，则 <span class="math inline">\(g_n\leqf_m\)</span>，所以 <span class="math display">\[\intg_n\,\mathrm{d}\mu\leq\int f_m\,\mathrm{d}\mu,\quad n\leq m\]</span>从而 <span class="math inline">\(\int g_n\,\mathrm{d}\mu\leq\liminf\intf_m\,\mathrm{d}\mu\)</span>。 另一方面 <span class="math inline">\(g_n\uparrow\liminf f_n\)</span>，所以利用 MCT 有<span class="math display">\[\int\liminff_n\,\mathrm{d}\mu=\int\lim_{n\to\infty}g_n\,\mathrm{d}\mu=\lim_{n\to\infty}\intg_n\,\mathrm{d}\mu\leq\liminf\int f_m\,\mathrm{d}\mu.\]</span></p><hr><p>另一个重要结论是 Borel-Cantelli 引理：</p><blockquote><p><strong>Borel-Cantelli (Ⅰ)</strong>：如果 <span class="math inline">\(\sum_{n=0}^\infty\mu(A_n)&lt;\infty\)</span>，则<span class="math inline">\(\mu\{A_n,\ \mathrm{i.o.}\}=0\)</span>。</p></blockquote><p>这个用积分很容易看出来： <span class="math display">\[\sum_{n=0}^\infty\mu(A_n)=\int\sum_{n=0}^\infty\mathbb{1}_{A_n}\,\mathrm{d}\mu.\]</span>左边如果有限，那么右边的函数必须几乎处处有限，所以 <span class="math inline">\(\{A_n,\ \mathrm{i.o.}\}\)</span> 是零测集。</p><h1 id="l1-and-the-dct">9.2 L1 and the DCT</h1><p>本讲引入了一般可积函数的定义，并证明了控制收敛定理。</p><blockquote><p><strong>定义</strong>：称 <span class="math inline">\(f\inL^1(\Omega,\mathcal{F},\mathbb{P})\)</span> 为可积函数，如果 <span class="math inline">\(f^+,f^-\)</span> 都是可积的：<span class="math inline">\(\intf^{\pm}\,\mathrm{d}\mu&lt;\infty\)</span>。此时我们定义 <span class="math inline">\(\int f=\int f^+-\intf^-\)</span>。或者等价地，<span class="math inline">\(f\)</span>可积当且仅当 <span class="math inline">\(\int|f|\,\mathrm{d}\mu&lt;\infty\)</span>。</p></blockquote><p>对可积函数，积分是<strong>线性的</strong>、<strong>保持单调性的</strong>。</p><p>如果我们将几乎处处相等的函数看作是同一个函数的话，<span class="math inline">\(\|\cdot\|_{L^1}\)</span>是可积函数空间上的度量。</p><blockquote>  <meta charset="utf-8">  <meta name="generator" content="pandoc">  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">  <title>dummy</title>  <style>    html {      color: #1a1a1a;      background-color: #fdfdfd;    }    body {      margin: 0 auto;      max-width: 36em;      padding-left: 50px;      padding-right: 50px;      padding-top: 50px;      padding-bottom: 50px;      hyphens: auto;      overflow-wrap: break-word;      text-rendering: optimizeLegibility;      font-kerning: normal;    }    @media (max-width: 600px) {      body {        font-size: 0.9em;        padding: 12px;      }      h1 {        font-size: 1.8em;      }    }    @media print {      html {        background-color: white;      }      body {        background-color: transparent;        color: black;        font-size: 12pt;      }      p, h2, h3 {        orphans: 3;        widows: 3;      }      h2, h3, h4 {        page-break-after: avoid;      }    }    p {      margin: 1em 0;    }    a {      color: #1a1a1a;    }    a:visited {      color: #1a1a1a;    }    img {      max-width: 100%;    }    svg {      height: auto;      max-width: 100%;    }    h1, h2, h3, h4, h5, h6 {      margin-top: 1.4em;    }    h5, h6 {      font-size: 1em;      font-style: italic;    }    h6 {      font-weight: normal;    }    ol, ul {      padding-left: 1.7em;      margin-top: 1em;    }    li > ol, li > ul {      margin-top: 0;    }    blockquote {      margin: 1em 0 1em 1.7em;      padding-left: 1em;      border-left: 2px solid #e6e6e6;      color: #606060;    }    code {      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;      font-size: 85%;      margin: 0;      hyphens: manual;    }    pre {      margin: 1em 0;      overflow: auto;    }    pre code {      padding: 0;      overflow: visible;      overflow-wrap: normal;    }    .sourceCode {     background-color: transparent;     overflow: visible;    }    hr {      background-color: #1a1a1a;      border: none;      height: 1px;      margin: 1em 0;    }    table {      margin: 1em 0;      border-collapse: collapse;      width: 100%;      overflow-x: auto;      display: block;      font-variant-numeric: lining-nums tabular-nums;    }    table caption {      margin-bottom: 0.75em;    }    tbody {      margin-top: 0.5em;      border-top: 1px solid #1a1a1a;      border-bottom: 1px solid #1a1a1a;    }    th {      border-top: 1px solid #1a1a1a;      padding: 0.25em 0.5em 0.25em 0.5em;    }    td {      padding: 0.125em 0.5em 0.25em 0.5em;    }    header {      margin-bottom: 4em;      text-align: center;    }    #TOC li {      list-style: none;    }    #TOC ul {      padding-left: 1.3em;    }    #TOC > ul {      padding-left: 0;    }    #TOC a:not(:hover) {      text-decoration: none;    }    code{white-space: pre-wrap;}    span.smallcaps{font-variant: small-caps;}    div.columns{display: flex; gap: min(4vw, 1.5em);}    div.column{flex: auto; overflow-x: auto;}    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}    /* The extra [class] is a hack that increases specificity enough to       override a similar rule in reveal.js */    ul.task-list[class]{list-style: none;}    ul.task-list li input[type="checkbox"] {      font-size: inherit;      width: 0.8em;      margin: 0 0.8em 0.2em -1.6em;      vertical-align: middle;    }  </style>  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>  <!--[if lt IE 9]>    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>  <![endif]--><p><strong>控制收敛定理</strong>：设 <span class="math inline">\(f_n,g\)</span> 都是可积函数并且 <span class="math inline">\(|f_n|\leqg\)</span>，<span class="math inline">\(\lim\limits_{n\to\infty}f_n=f\)</span>。 则 <span class="math inline">\(f\)</span> 也是可积函数并且 <span class="math inline">\(\lim\limits_{n\to\infty}\int f_n=\intf\)</span>。</p></blockquote><p><strong>证明概要</strong>：显然 <span class="math inline">\(|f|\leqg\)</span>，所以 <span class="math inline">\(f\)</span>可积，从而由线性性质 <span class="math inline">\(g\pm f\)</span>都是可积的。对可积函数序列 <span class="math inline">\(g\pm f_n\)</span>使用 Fatou 引理，有 <span class="math display">\[\int (g\pmf)\,\mathrm{d}\mu=\int\varliminf_{n\to\infty} (g\pmf_n)\,\mathrm{d}\mu\leq \varliminf_{n\to\infty}\int (g\pmf_n)\,\mathrm{d}\mu= \int g\,\mathrm{d}\mu\pm\varliminf_{n\to\infty}\intf_n\,\mathrm{d}\mu.\]</span> 比较两边有 <span class="math display">\[\int (g\pm f)\,\mathrm{d}\mu\leq \intg\,\mathrm{d}\mu\pm \varliminf_{n\to\infty}\intf_n\,\mathrm{d}\mu.\]</span> 消去 <span class="math inline">\(g\)</span>的积分，并注意对任何实数列 <span class="math inline">\(\{a_n\}\)</span>有 <span class="math inline">\(\varliminf\limits_{n\to\infty}(-a_n)=-\varlimsup\limits_{n\to\infty}a_n\)</span>，从而 <span class="math display">\[\varlimsup\intf_n\,\mathrm{d}\mu\leq \int f\,\mathrm{d}\mu\leq \varliminf\intf_n\,\mathrm{d}\mu.\]</span> 即得结论。</p><h1 id="probability-laws-revisited">11.2 Probability Laws Revisited</h1><blockquote><p><strong>积分的变量替换定理</strong>：设 <span class="math inline">\(X:\(\Omega,\mathcal{F},\mu)\to(\mathcal{S},\mathcal{B})\)</span>是一个可测映射，<span class="math inline">\((\mathcal{S},\mathcal{B})\)</span> 上的测度 <span class="math inline">\(\nu\)</span> 由 <span class="math inline">\(\nu(E)= \mu(X^{-1}(E))\)</span> 给出，<span class="math inline">\(g:\(\mathcal{S},\mathcal{B},\nu)\to\mathbb{R}\)</span> 是一个可积函数，则<span class="math display">\[\int_{\Omega}g\circX\,\mathrm{d}\mu=\int_{\mathcal{S}}g\,\mathrm{d}\nu.\]</span></p></blockquote><p><strong>证明概要</strong>：首先考察 <span class="math inline">\(g=\mathbb{1}_B,\,B\in\mathcal{B}\)</span>是指标函数的情形。 <span class="math display">\[\int_{\mathcal{S}}g\,\mathrm{d}\nu= \nu(B) =\mu(X^{-1}(B))=\int_{\Omega}\mathbb{1}_{X^{-1}(B)}\,\mathrm{d}\mu.\]</span>由于 <span class="math inline">\(\omega\in X^{-1}(B)\LeftrightarrowX(\omega)\in B\)</span>，所以 <span class="math inline">\(\mathbb{1}_{X^{-1}(B)} = \mathbb{1}_{B}\circX\)</span>，所以上式右边的积分等于 <span class="math display">\[\int_{\Omega}\mathbb{1}_{B}\circX\,\mathrm{d}\nu.\]</span>此时结论成立。根据积分的线性性质结论对简单函数也成立，从而进一步取极限可得对任何可积函数<span class="math inline">\(g\)</span> 都成立。</p><h1 id="convergence-in-measure">13.1 Convergence in measure</h1><p>本讲介绍了可测函数的依测度收敛概念，及其与逐点收敛之间的联系。</p><blockquote>  <meta charset="utf-8">  <meta name="generator" content="pandoc">  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">  <title>dummy</title>  <style>    html {      color: #1a1a1a;      background-color: #fdfdfd;    }    body {      margin: 0 auto;      max-width: 36em;      padding-left: 50px;      padding-right: 50px;      padding-top: 50px;      padding-bottom: 50px;      hyphens: auto;      overflow-wrap: break-word;      text-rendering: optimizeLegibility;      font-kerning: normal;    }    @media (max-width: 600px) {      body {        font-size: 0.9em;        padding: 12px;      }      h1 {        font-size: 1.8em;      }    }    @media print {      html {        background-color: white;      }      body {        background-color: transparent;        color: black;        font-size: 12pt;      }      p, h2, h3 {        orphans: 3;        widows: 3;      }      h2, h3, h4 {        page-break-after: avoid;      }    }    p {      margin: 1em 0;    }    a {      color: #1a1a1a;    }    a:visited {      color: #1a1a1a;    }    img {      max-width: 100%;    }    svg {      height: auto;      max-width: 100%;    }    h1, h2, h3, h4, h5, h6 {      margin-top: 1.4em;    }    h5, h6 {      font-size: 1em;      font-style: italic;    }    h6 {      font-weight: normal;    }    ol, ul {      padding-left: 1.7em;      margin-top: 1em;    }    li > ol, li > ul {      margin-top: 0;    }    blockquote {      margin: 1em 0 1em 1.7em;      padding-left: 1em;      border-left: 2px solid #e6e6e6;      color: #606060;    }    code {      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;      font-size: 85%;      margin: 0;      hyphens: manual;    }    pre {      margin: 1em 0;      overflow: auto;    }    pre code {      padding: 0;      overflow: visible;      overflow-wrap: normal;    }    .sourceCode {     background-color: transparent;     overflow: visible;    }    hr {      background-color: #1a1a1a;      border: none;      height: 1px;      margin: 1em 0;    }    table {      margin: 1em 0;      border-collapse: collapse;      width: 100%;      overflow-x: auto;      display: block;      font-variant-numeric: lining-nums tabular-nums;    }    table caption {      margin-bottom: 0.75em;    }    tbody {      margin-top: 0.5em;      border-top: 1px solid #1a1a1a;      border-bottom: 1px solid #1a1a1a;    }    th {      border-top: 1px solid #1a1a1a;      padding: 0.25em 0.5em 0.25em 0.5em;    }    td {      padding: 0.125em 0.5em 0.25em 0.5em;    }    header {      margin-bottom: 4em;      text-align: center;    }    #TOC li {      list-style: none;    }    #TOC ul {      padding-left: 1.3em;    }    #TOC > ul {      padding-left: 0;    }    #TOC a:not(:hover) {      text-decoration: none;    }    code{white-space: pre-wrap;}    span.smallcaps{font-variant: small-caps;}    div.columns{display: flex; gap: min(4vw, 1.5em);}    div.column{flex: auto; overflow-x: auto;}    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}    /* The extra [class] is a hack that increases specificity enough to       override a similar rule in reveal.js */    ul.task-list[class]{list-style: none;}    ul.task-list li input[type="checkbox"] {      font-size: inherit;      width: 0.8em;      margin: 0 0.8em 0.2em -1.6em;      vertical-align: middle;    }  </style>  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>  <!--[if lt IE 9]>    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>  <![endif]--><p><strong>定义</strong>：称 <span class="math inline">\(f_n\to_{\mu}f\)</span> 为依测度收敛，如果对任意 <span class="math inline">\(\epsilon&gt;0\)</span> 有 <span class="math display">\[\lim_{n\to\infty}\mu\{|f_n-f|\geq0\}=0.\]</span></p></blockquote><p><strong>依测度收敛但不处处收敛的例子</strong>：将区间 <span class="math inline">\([0, 1]\)</span> 等分为 <span class="math inline">\(2^n\)</span>份，将它们的指标函数排成一排，再对所有 <span class="math inline">\(n\)</span> 将这些片段排列起来得到序列 <span class="math inline">\(f_n\)</span>，则 <span class="math inline">\(f_n\)</span> 依测度收敛到 0 但不逐点收敛。</p><p><strong>接下来是一个将测度和逐点收敛联系起来的重要技巧</strong>：根据几乎处处收敛的定义，<span class="math inline">\(f_n\to f,\mathrm{a.e.}\)</span> 收敛即要求对任何<span class="math inline">\(\epsilon&gt;0\)</span> 有 <span class="math display">\[\mu\{|f_n-f|\geq\epsilon,\ \mathrm{i.o.}\} =0.\]</span>这样就可以把逐点收敛和测度联系起来。有时候我们还可以使用更强的条件：<span class="math display">\[\mu\{|f_n-f|\geq 2^{-n},\ \mathrm{i.o.}\} =0.\]</span> 这是因为对任何 <span class="math inline">\(\epsilon\)</span>，<span class="math inline">\(n\)</span> 足够大时 <span class="math inline">\(2^{-n}&lt;\epsilon\)</span>, 从而 <span class="math inline">\(\{|f_n-f|\geq\epsilon\}\subseteq\{|f_n-f|\geq2^{-n}\}\)</span>，前者发生无穷多次自然意味着后者也发生无穷多次。这样就可以和Borel-Cantelli 引理结合起来使用，只要 <span class="math display">\[\sum_{n}\mu\{|f_n - f|\geq 2^{-n}\} &lt;\infty,\]</span> 就可以保证 <span class="math inline">\(\{f_n\}\)</span>是几乎处处收敛的。</p><blockquote>  <meta charset="utf-8">  <meta name="generator" content="pandoc">  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">  <title>dummy</title>  <style>    html {      color: #1a1a1a;      background-color: #fdfdfd;    }    body {      margin: 0 auto;      max-width: 36em;      padding-left: 50px;      padding-right: 50px;      padding-top: 50px;      padding-bottom: 50px;      hyphens: auto;      overflow-wrap: break-word;      text-rendering: optimizeLegibility;      font-kerning: normal;    }    @media (max-width: 600px) {      body {        font-size: 0.9em;        padding: 12px;      }      h1 {        font-size: 1.8em;      }    }    @media print {      html {        background-color: white;      }      body {        background-color: transparent;        color: black;        font-size: 12pt;      }      p, h2, h3 {        orphans: 3;        widows: 3;      }      h2, h3, h4 {        page-break-after: avoid;      }    }    p {      margin: 1em 0;    }    a {      color: #1a1a1a;    }    a:visited {      color: #1a1a1a;    }    img {      max-width: 100%;    }    svg {      height: auto;      max-width: 100%;    }    h1, h2, h3, h4, h5, h6 {      margin-top: 1.4em;    }    h5, h6 {      font-size: 1em;      font-style: italic;    }    h6 {      font-weight: normal;    }    ol, ul {      padding-left: 1.7em;      margin-top: 1em;    }    li > ol, li > ul {      margin-top: 0;    }    blockquote {      margin: 1em 0 1em 1.7em;      padding-left: 1em;      border-left: 2px solid #e6e6e6;      color: #606060;    }    code {      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;      font-size: 85%;      margin: 0;      hyphens: manual;    }    pre {      margin: 1em 0;      overflow: auto;    }    pre code {      padding: 0;      overflow: visible;      overflow-wrap: normal;    }    .sourceCode {     background-color: transparent;     overflow: visible;    }    hr {      background-color: #1a1a1a;      border: none;      height: 1px;      margin: 1em 0;    }    table {      margin: 1em 0;      border-collapse: collapse;      width: 100%;      overflow-x: auto;      display: block;      font-variant-numeric: lining-nums tabular-nums;    }    table caption {      margin-bottom: 0.75em;    }    tbody {      margin-top: 0.5em;      border-top: 1px solid #1a1a1a;      border-bottom: 1px solid #1a1a1a;    }    th {      border-top: 1px solid #1a1a1a;      padding: 0.25em 0.5em 0.25em 0.5em;    }    td {      padding: 0.125em 0.5em 0.25em 0.5em;    }    header {      margin-bottom: 4em;      text-align: center;    }    #TOC li {      list-style: none;    }    #TOC ul {      padding-left: 1.3em;    }    #TOC > ul {      padding-left: 0;    }    #TOC a:not(:hover) {      text-decoration: none;    }    code{white-space: pre-wrap;}    span.smallcaps{font-variant: small-caps;}    div.columns{display: flex; gap: min(4vw, 1.5em);}    div.column{flex: auto; overflow-x: auto;}    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}    /* The extra [class] is a hack that increases specificity enough to       override a similar rule in reveal.js */    ul.task-list[class]{list-style: none;}    ul.task-list li input[type="checkbox"] {      font-size: inherit;      width: 0.8em;      margin: 0 0.8em 0.2em -1.6em;      vertical-align: middle;    }  </style>  <!--[if lt IE 9]>    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>  <![endif]--><p><strong>定理</strong>：逐点收敛可以推出依测度收敛。</p></blockquote><p><strong>简要证明</strong>：对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，记 <span class="math inline">\(A_n=\{|f_n-f|\geq\epsilon\}\)</span>，则 <span class="math display">\[\mu\{A_n,\ \mathrm{i.o.}\} =\lim_{n\to\infty}\mu(\bigcup_{k\geq n}A_k)\geq\lim_{n\to\infty}\mu(A_n).\]</span></p><blockquote>  <meta charset="utf-8">  <meta name="generator" content="pandoc">  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">  <title>dummy</title>  <style>    html {      color: #1a1a1a;      background-color: #fdfdfd;    }    body {      margin: 0 auto;      max-width: 36em;      padding-left: 50px;      padding-right: 50px;      padding-top: 50px;      padding-bottom: 50px;      hyphens: auto;      overflow-wrap: break-word;      text-rendering: optimizeLegibility;      font-kerning: normal;    }    @media (max-width: 600px) {      body {        font-size: 0.9em;        padding: 12px;      }      h1 {        font-size: 1.8em;      }    }    @media print {      html {        background-color: white;      }      body {        background-color: transparent;        color: black;        font-size: 12pt;      }      p, h2, h3 {        orphans: 3;        widows: 3;      }      h2, h3, h4 {        page-break-after: avoid;      }    }    p {      margin: 1em 0;    }    a {      color: #1a1a1a;    }    a:visited {      color: #1a1a1a;    }    img {      max-width: 100%;    }    svg {      height: auto;      max-width: 100%;    }    h1, h2, h3, h4, h5, h6 {      margin-top: 1.4em;    }    h5, h6 {      font-size: 1em;      font-style: italic;    }    h6 {      font-weight: normal;    }    ol, ul {      padding-left: 1.7em;      margin-top: 1em;    }    li > ol, li > ul {      margin-top: 0;    }    blockquote {      margin: 1em 0 1em 1.7em;      padding-left: 1em;      border-left: 2px solid #e6e6e6;      color: #606060;    }    code {      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;      font-size: 85%;      margin: 0;      hyphens: manual;    }    pre {      margin: 1em 0;      overflow: auto;    }    pre code {      padding: 0;      overflow: visible;      overflow-wrap: normal;    }    .sourceCode {     background-color: transparent;     overflow: visible;    }    hr {      background-color: #1a1a1a;      border: none;      height: 1px;      margin: 1em 0;    }    table {      margin: 1em 0;      border-collapse: collapse;      width: 100%;      overflow-x: auto;      display: block;      font-variant-numeric: lining-nums tabular-nums;    }    table caption {      margin-bottom: 0.75em;    }    tbody {      margin-top: 0.5em;      border-top: 1px solid #1a1a1a;      border-bottom: 1px solid #1a1a1a;    }    th {      border-top: 1px solid #1a1a1a;      padding: 0.25em 0.5em 0.25em 0.5em;    }    td {      padding: 0.125em 0.5em 0.25em 0.5em;    }    header {      margin-bottom: 4em;      text-align: center;    }    #TOC li {      list-style: none;    }    #TOC ul {      padding-left: 1.3em;    }    #TOC > ul {      padding-left: 0;    }    #TOC a:not(:hover) {      text-decoration: none;    }    code{white-space: pre-wrap;}    span.smallcaps{font-variant: small-caps;}    div.columns{display: flex; gap: min(4vw, 1.5em);}    div.column{flex: auto; overflow-x: auto;}    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}    /* The extra [class] is a hack that increases specificity enough to       override a similar rule in reveal.js */    ul.task-list[class]{list-style: none;}    ul.task-list li input[type="checkbox"] {      font-size: inherit;      width: 0.8em;      margin: 0 0.8em 0.2em -1.6em;      vertical-align: middle;    }  </style>  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>  <!--[if lt IE 9]>    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>  <![endif]--><p><strong>定理</strong>：设 <span class="math inline">\(\{f_n\}\)</span> 为依测度收敛的 Cauchy 序列：<span class="math display">\[\lim_{n,m\to\infty}\mu\{|f_n-f_m|\geq\epsilon\} =0.\]</span> 则 <span class="math inline">\(f_n\)</span>必有逐点收敛的子序列 <span class="math inline">\(f_{n_k}\to f\\mathrm{a.e.}\)</span>，并且 <span class="math inline">\(f_n\)</span>依测度收敛到 <span class="math inline">\(f\)</span>。</p></blockquote><p><strong>简要证明必有逐点收敛的子序列</strong>：利用上面介绍的技巧，归结为抽取子序列<span class="math inline">\(\{f_{n_k}\}\)</span> 满足 <span class="math display">\[\mu\{|f_{n_{k+1}} - f_{n_k}|\geq2^{-k},\\mathrm{i.o.}\} = 0.\]</span> 利用 Borel-Cantelli 引理这只要让 <span class="math inline">\(\sum_{k=1}^\infty\mu\{|f_{n_{k+1}} - f_{n_k}|\geq2^{-k}\}&lt;\infty\)</span> 即可。为此又只要让 <span class="math inline">\(\mu\{|f_{n_{k+1}} - f_{n_k}|\geq 2^{-k}\}\leq2^{-k}\)</span> 即可。根据 Cauchy 条件这是可以做到的。</p><p><strong>简要证明这个子序列的逐点极限是原序列的依测度极限</strong>：对任何<span class="math inline">\(n\)</span>，取 <span class="math inline">\(n_{k}&gt;n\)</span> 则有 <span class="math display">\[\{|f_n-f|\geq\epsilon\}\subseteq\{|f_n-f_{n_k}|\geq\epsilon/2\}\cup\{|f_{n_k}-f|\geq\epsilon/2\}.\]</span> 显然 <span class="math inline">\(n\)</span> 足够大时右边两个集合测度都趋于 0。</p><h1 id="lp-is-complete">13.2 <span class="math inline">\(L^p\)</span> isComplete</h1><p>首先我们来证明 <span class="math inline">\(L^p\)</span>收敛可以推出依测度收敛。</p><blockquote><p><strong>定理</strong>：<span class="math inline">\(L^p\)</span>度量是完备的，任何 Cauchy 序列必有极限。</p></blockquote><p><strong>证明概要</strong>：<span class="math inline">\(L^p\)</span>Cauchy 列也都是依测度 Cauchy 列，从而有几乎处处收敛的子序列 <span class="math inline">\(f_{n_k}\to f\)</span>。对固定的 <span class="math inline">\(k\)</span>，当 <span class="math inline">\(j&gt;k\)</span> 时有 <span class="math display">\[\begin{align*}\int\|f_{n_k}-f\|^p\,\mathrm{d}\mu&amp;=\int\lim_{j\to\infty}\|f_{n_k}-f_{n_j}\|^p\,\mathrm{d}\mu\leq\liminf_{j\to\infty}\int\|f_{n_k}-f_{n_j}\|^p\,\mathrm{d}\mu\\&amp;\leq\limsup_{j\to\infty}\int\|f_{n_k}-f_{n_j}\|^p\,\mathrm{d}\mu.\end{align*}\]</span>两边令 <span class="math inline">\(k\to\infty\)</span> 并利用 Cauchy条件即得子序列 <span class="math inline">\(f_{n_k}\xrightarrow{L^p}f\)</span>。再利用 Cauchy条件可得原序列 <span class="math inline">\(f_n\xrightarrow{L^p}f\)</span>。</p><blockquote><p><strong>依测度控制收敛定理</strong>：设 <span class="math inline">\(f_n\)</span> 依测度收敛到 <span class="math inline">\(f\)</span>，且 <span class="math inline">\(|f_n|\leq f,\, f\in L^1\)</span>。则 <span class="math inline">\(f_n\xrightarrow{L^1} f\)</span>。</p></blockquote><p><strong>证明概要</strong>：假设 <span class="math inline">\(f_n\)</span> 不 <span class="math inline">\(L^1\)</span> 收敛到 <span class="math inline">\(f\)</span>，则对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，存在子序列 <span class="math inline">\(f_{n_k}\)</span> 满足：</p><ul><li><span class="math inline">\(\|f_{n_k} -f\|_{L^1}\geq\epsilon\)</span>。</li><li><span class="math inline">\(f_{n_k}\)</span> 几乎处处收敛到 <span class="math inline">\(f\)</span>。</li></ul><p>这与控制收敛定理矛盾。</p><h1 id="independence">15.1 Independence</h1><p>本讲介绍了事件和 <span class="math inline">\(\sigma\)</span>-域之间的独立性概念。</p><p>要点总结：</p><ol type="1"><li>若干个事件 <span class="math inline">\(\{A_n\}\)</span>独立不是指它们两两独立，而是其中任何有限多个子事件都独立。</li><li>验证若干 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\{\mathcal{F}_i\}\)</span>独立只需要验证生成它们的 <span class="math inline">\(\pi\)</span>- 系<span class="math inline">\(\{C_i:\ \mathcal{F}_i=\sigma(C_i)\}\)</span>独立。</li></ol><blockquote><p><strong>Borel-Cantelli 引理 II</strong>：设 <span class="math inline">\(\{A_n\}\)</span> 是独立的事件列，则若 <span class="math inline">\(\sum_{n=1}^\infty\mathbb{P}(A_n)=\infty\)</span>，则<span class="math inline">\(\mathbb{P}(\{A_n,\mathrm{i.o.}\})=1\)</span>。</p></blockquote><p>想法还是要用独立性，转到事件的交上去。</p><p><span class="math display">\[\mathbb{P}(\{A_n,\\mathrm{i.o.}\})=\mathbb{P}(\bigcap_{n=1}^\infty\bigcup_{k\geqn}A_k)=\lim_{n\to\infty}\mathbb{P}(\bigcup_{k\geq n}A_k).\]</span>观察两边，要想用上独立性，就得取补： <span class="math display">\[1-\mathbb{P}(\bigcup_{k\geqn}A_k)=\mathbb{P}(\bigcap_{k\geqn}A_k^c)=\lim_{M\to\infty}\prod_{k=n}^M\mathbb{P}(A_k^c)=\lim_{M\to\inftyy}\prod_{k=n}^M(1-\mathbb{P}(A_k)).\]</span> 利用 <span class="math inline">\(1-x\leq e^{-x}\)</span> 有 <span class="math display">\[\lim_{M\to\infty}\prod_{k=n}^M(1-\mathbb{P}(A_k))\leq\lim_{M\to\infty}\prod_{k=n}^Me^{-\mathbb{P}(A_k)}=\lim_{M\to\infty}e^{-\sum_{k=n}^M\mathbb{P}(A_k)}.\]</span>上式右边对任何固定的 <span class="math inline">\(n\)</span> 其极限都是0，从而 <span class="math inline">\(\mathbb{P}(\bigcup_{k\geqn}A_k)\to1\)</span>，结论得证。</p><h1 id="independent-random-variables">15.2 Independent RandomVariables</h1><p>上一讲介绍了独立事件和独立事件域的概念，这一讲介绍了独立随机变量的概念。</p><blockquote><p><strong>定义</strong>：一族随机变量 <span class="math inline">\(\{X_i\}_{i\in I}\)</span> 称作是独立的，如果它们的<span class="math inline">\(\sigma-\)</span> 域 <span class="math inline">\(\{\sigma(X_i)\}_{i\in I}\)</span> 是独立的。</p></blockquote><p>由于 <span class="math inline">\(\sigma(X_i)\)</span> 可以由 <span class="math inline">\(\pi-\)</span> 系 <span class="math inline">\(\{X_i\in(-\infty, t_i]\}\)</span>生成，所以只要验证这个 <span class="math inline">\(\pi-\)</span>系的独立性即可。</p><blockquote><p><strong>定理</strong>：设 <span class="math inline">\(X=(X_1,\ldots,X_n)\)</span>，其中每个 <span class="math inline">\(X_i:(\Omega,\mathcal{F},\mathbb{P})\to(\mathcal{S}_i,\mathcal{B}_i)\)</span>是随机变量，<span class="math inline">\(\mu_X\)</span> 是 <span class="math inline">\(\mathcal{B}_1\otimes\cdots\otimes\mathcal{B}_n\)</span>上的测度: <span class="math inline">\(\mu_X(B)=\mathbb{P}(X\inB)\)</span>。则 <span class="math inline">\(X_1,X_2,\ldots,X_n\)</span>独立当且仅当 <span class="math inline">\(\mu_X=\mu_{X_1}\otimes\cdots\otimes\mu_{X_n}\)</span>。</p></blockquote><p>证明：<span class="math inline">\(\Leftarrow\)</span>:</p><p><span class="math display">\[\begin{align*}\mathbb{P}(X_1\inB_1,\ldots,X_n\in B_n)&amp;=\mu_X(B_1\times \cdots\times B_n)\\&amp;=\mu_{X_1}(B_1)\cdots\mu_{X_n}(B_n)\\&amp;=\mathbb{P}(X_1\in B_1)\cdots\mathbb{P}(X_n\inB_n).\end{align*}\]</span></p><p><span class="math inline">\(\Rightarrow\)</span>: 简单。</p><blockquote><p><strong>推论</strong>：如果 <span class="math inline">\(X_1,X_2,\ldots,X_n\)</span> 都是 <span class="math inline">\(L^1\)</span> 可积的随机变量，则 <span class="math inline">\(X_1X_2\cdots X_n\in L^1\)</span> 且 <span class="math inline">\(\mathbb{E}[X_1\cdotsX_n]=\mathbb{E}[X_1]\cdots\mathbb{E}[X_n]\)</span>。</p></blockquote><p>首先对 <span class="math inline">\(|X_1X_2\cdots X_n|\)</span> 用Tonelli 定理得出 <span class="math inline">\(|X_1X_2\cdots X_n|\)</span>可积，然后再对 <span class="math inline">\(X_1X_2\cdots X_n\)</span> 用Fubini 定理。</p><blockquote><p><strong>推论</strong>：如果 <span class="math inline">\(X_1,\ldots,X_n,Y_1,\ldots,Y_m\)</span>是一组独立的随机变量，则 <span class="math inline">\(f(X_1,\ldots,X_n)\)</span> 和 <span class="math inline">\(g(Y_1,\ldots,Y_m)\)</span> 也是独立的。</p></blockquote><p>这是因为 <span class="math inline">\(\sigma(f(X_1,\ldots,X_n))\subseteq\sigma(X_1,\ldots,X_n)\)</span>，<span class="math inline">\(\sigma(g(Y_1,\ldots,Y_m))\subseteq\sigma(Y_1,\ldots,Y_m)\)</span>，所以也是独立的。</p><h1 id="kolmogorovs-extension-theorem">16.1/16.2 Kolmogorov’s ExtensionTheorem</h1><p>这两讲的目的是介绍 Kolmogorov扩张定理，即构造无穷乘积可测空间使得其有限维分布为给定的、满足相容性条件的有限维分布。</p><p>Kolmogorov扩张定理看起来是一个纯测度论定理，但它本质与空间的拓扑性质有关。</p><p>设 <span class="math inline">\(I\)</span> 是指标集，<span class="math inline">\(\{\mathcal{A}_i,\, i\in I\}\)</span>是某个样本空间 <span class="math inline">\(\Omega\)</span> 的一族子<span class="math inline">\(\sigma-\)</span> 代数（每个 <span class="math inline">\(\mathcal{A}_i\)</span> 都是一个 <span class="math inline">\(\sigma-\)</span> 代数），满足条件：对任何两个<span class="math inline">\(\sigma-\)</span> 代数 <span class="math inline">\(\mathcal{A}_\alpha,\mathcal{A}_\beta\)</span>，都存在<span class="math inline">\(\mathcal{A}_\gamma\)</span> （<span class="math inline">\(\mathcal{A}_\gamma\)</span> 未必唯一）使得 <span class="math inline">\(\mathcal{A}_\alpha\subset\mathcal{A}_\gamma,\,\mathcal{A}_\beta\subset\mathcal{A}_\gamma\)</span>。</p><p>设 <span class="math inline">\(\mathbb{P}_i\)</span> 是 <span class="math inline">\(\mathcal{A}_i\)</span> 上的概率测度，如果对任何<span class="math inline">\(\mathcal{A}_\alpha\subset\mathcal{A}_\gamma\)</span>还有 <span class="math display">\[\mathbb{P}_\gamma \big|_{A_\alpha} =\mathbb{P}_\alpha.\]</span> 这时我们就称概率空间 <span class="math inline">\(\{(\mathcal{A}_i,\mathbb{P}_i)\}\)</span><strong>满足 Kolmogorov 相容性条件</strong>。</p><p>这就自然地引出一个问题：是否存在代数 <span class="math inline">\(\mathcal{A}=\cup_{i\in I}\mathcal{A}_i\)</span>上存在一个可数可加的概率测度 <span class="math inline">\(\mathbb{P}\)</span>，使得它是所有 <span class="math inline">\(\mathbb{P}_i\)</span> 的扩张？即对任何 <span class="math inline">\(\mathcal{A}_i\)</span> 都有 <span class="math inline">\(\mathbb{P}\big|_{\mathcal{A}_i}=\mathbb{P}_i\)</span>？如果有这样的 <span class="math inline">\(\mathbb{P}\)</span>，我们就可以用 Carathéodory定理将 <span class="math inline">\(\mathbb{P}\)</span> 扩张为 <span class="math inline">\(\sigma(\mathcal{A})\)</span>上的可数可加测度。</p><p>基本逻辑是：</p><ol type="1"><li>根据 Carathéodory 测度扩张定，我们只要证明代数 <span class="math inline">\(\mathcal{A}=\cup_{n=1}^\infty\mathcal{B}_n\)</span>上的有限可加测度是可数可加的。这里 <span class="math display">\[\mathcal{B}_n=\mathcal{B}([0,1])^n\times Q,\quadQ=[0,1]^{\infty}.\]</span> 而这只要证明测度的连续性：若 <span class="math inline">\(B_n\in\mathcal{A}, B_n\downarrow\)</span> 且 <span class="math inline">\(\inf_n\mathbb{P}(B_n)=\epsilon&gt;0\)</span>，则<span class="math inline">\(\cap B_n\ne\emptyset\)</span>。</li><li>我们可以不妨假设 <span class="math inline">\(B_n\in\mathcal{B}_n\)</span>。这可以通过拉伸整个序列，在缝隙中塞上<span class="math inline">\(\Omega_k\)</span> 或者 <span class="math inline">\(B_k\)</span> 来得到。</li><li>我们可以取紧集 <span class="math inline">\(K_n\in B_n\)</span> 使得<span class="math inline">\(\mu(B_n\backslashK_n)&lt;\epsilon/2^n\)</span>，然后证明对任何 <span class="math inline">\(N\)</span>，<span class="math inline">\(\cap_{n=1}^NK_n\)</span> 非空，然后利用 <span class="math inline">\(Q\)</span> 的紧性，和紧集的有限交性质，证明 <span class="math inline">\(\cap_{n=1}^\infty K_n\)</span> 非空，从而 <span class="math inline">\(\cap_{n=1}^\infty B_n\)</span> 非空。</li><li>在上一步中，可以取这样的紧集 <span class="math inline">\(K_n\)</span> 要用到 <span class="math inline">\(R^d\)</span> 上的概率测度是 Radon测度这一性质：它们同时被开集从外部逼近和紧集从内部逼近。<span class="math inline">\(Q\)</span> 的紧性是用了 Tychonoff 定理。</li></ol><blockquote><p><strong>引理</strong>：<span class="math inline">\(K\)</span></p></blockquote><h1 id="kolmogorovs-0-1-law">17.1 Kolmogorov’s 0-1 Law</h1><p>本讲介绍了独立随机变量序列的尾事件，以及 Kolmogrov 0-1 律。</p><p>设 <span class="math inline">\(\{X_n\}\)</span> 是独立的随机变量序列(不是两两独立，而是任何有限多个都独立)称 <span class="math inline">\(\mathcal{T}=\cap_{n=1}^\infty\sigma(X_n,X_{n+1},\ldots)\)</span>为尾事件域。</p><blockquote><p><strong>Kolmogrov 0-1 律</strong>：对任何 <span class="math inline">\(A\in\mathcal{T}\)</span> 有 <span class="math inline">\(\mathbb{P}(A)\in\{0,1\}\)</span>。</p></blockquote><p><strong>证明概要</strong>：</p><ul><li><span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span> 和 <span class="math inline">\(\sigma(X_{n+1},X_{n+2},\ldots)\)</span>是独立的。因为考虑如下两个集合族： <span class="math display">\[\{\text{all finite intersections like }\cap A_i,A_i\in\sigma(X_i),i=1,2,\ldots,n\}.\]</span> <span class="math display">\[\{\text{all finite intersections like }\cap A_j,A_j\in\sigma(X_j),j=n+1,n+2,\ldots\}.\]</span> 这俩都是 <span class="math inline">\(\pi\)</span>- 系且互相独立，所以它们生成的 <span class="math inline">\(\sigma\)</span>- 域也独立。前者可以生成 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span>，后者可以生成<span class="math inline">\(\sigma(X_{n+1},X_{n+2},\ldots)\)</span>。</li><li>于是 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span> 和<span class="math inline">\(\mathcal{T}\)</span> 是独立的。</li><li>于是 <span class="math inline">\(\pi\)</span>- 系 <span class="math inline">\(\cup_{n=1}^\infty\sigma(X_1,\ldots,X_n)\)</span>和 <span class="math inline">\(\mathcal{T}\)</span> 是独立的。</li><li>于是 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\sigma(X_1,\ldots,X_n,\ldots)\)</span> 和 <span class="math inline">\(\mathcal{T}\)</span> 独立，从而 <span class="math inline">\(\mathcal{T}\)</span> 和 <span class="math inline">\(\mathcal{T}\)</span> 独立，从而得证。</li></ul><h1 id="uniform-integrability">48.1 Uniform Integrability</h1><p>这一讲介绍了随机变量集合的一致可积性，要点非常多。</p><p>对任何 <span class="math inline">\(L^1\)</span> 的随机变量 <span class="math inline">\(X\)</span>，总是可以找一个紧集 <span class="math inline">\(K\)</span>，使得 <span class="math inline">\(|X|\)</span> 在 <span class="math inline">\(K^c\)</span> 上的积分任意小：对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，存在 <span class="math inline">\(a&gt;0\)</span> 使得 <span class="math inline">\(\mathbb{E}[|X|:\ |X|\geqa]&lt;\epsilon\)</span>。但是如果是一族可积的随机变量的话，这个统一的<span class="math inline">\(a\)</span> 就未必存在了。</p><p>如果这样的 <span class="math inline">\(a\)</span>总是存在的话，我们就称这族随机变量是一致可积的。</p><blockquote><p><strong>定义</strong>：随机变量列 <span class="math inline">\(\{X_n\}\)</span> 称作是一致可积的 (UI)的，如果它们满足以下条件：</p><ol type="1"><li>每个 <span class="math inline">\(X_i\)</span> 都是 <span class="math inline">\(L^1\)</span> 的。</li><li>对任何 <span class="math inline">\(\epsilon&gt;0\)</span>，存在<span class="math inline">\(a&gt;0\)</span> 使得 <span class="math inline">\(\sup_n\mathbb{E}[X_n:\ |X_n|\geq a]&lt;\epsilon\)</span>。</li></ol></blockquote><p>不难验证如果 <span class="math inline">\(\{X_n\}\)</span>被一个可积随机变量控制，则它们是一致可积的：</p><blockquote><p><strong>例子 1</strong>：如果 <span class="math inline">\(|X_n|\leqY,\ Y\in L^1\)</span>，则 <span class="math inline">\(\{X_n\}\)</span>是一致可积的。</p></blockquote><p>这是因为被积函数和积分区域都可以放大：<span class="math inline">\(\mathbb{E}[|X_n|:\ |X_n|\geqa]\leq\mathbb{E}[|Y|:\ |Y|\geq a]\)</span>。</p><blockquote><p><strong>例子 2</strong>：如果 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(L^p,\,p&gt;1\)</span> 一致有界的：<span class="math inline">\(\sup_n\mathbb{E}|X_n|^p&lt;\infty\)</span>，则<span class="math inline">\(\{X_n\}\)</span> 是一致可积的。</p></blockquote><p>这是因为被积函数可以放大： <span class="math display">\[\mathbb{E}[|X|: |X|\geq a]\leq\mathbb{E}[|X|\cdot\frac{|X|^{p-1}}{a^{p-1}}: |X|\geq a] =\frac{1}{a^{p-1}}\mathbb{E}[|X|^p: |X|\geq a]\leq\frac{M}{a^{p-1}}.\]</span></p><p>这个例子中的 <span class="math inline">\(p&gt;1\)</span> 是不能减弱为<span class="math inline">\(p\geq1\)</span> 的。不过我们可以证明 UI的变量族必然是 <span class="math inline">\(L^1\)</span> 一致有界的：</p><blockquote><p><strong>定理</strong>：若 <span class="math inline">\(\{X_n\}\)</span> 一致可积，则 <span class="math inline">\(\sup_n E|X_n| &lt;\infty\)</span>。</p></blockquote><p>取 <span class="math inline">\(a\)</span> 使得 <span class="math inline">\(\sup_n \mathbb{E}[|X_n|: |X_n|\geq a] &lt;1\)</span>，则不难证明 <span class="math inline">\(\mathbb{E}|X_n| &lt;a+1\)</span>。</p><p>现在我们来给出一致绝对连续的概念，并将说明<strong>一致可积 = <span class="math inline">\(L^1\)</span> 一致有界 +一致绝对连续</strong>。</p><blockquote><p><strong>定义</strong>：随机变量序列 <span class="math inline">\(\{X_n\}\)</span> 是一致绝对连续的，如果对任何<span class="math inline">\(\epsilon&gt;0\)</span>，都存在 <span class="math inline">\(\delta&gt;0\)</span>，使得只要集合 <span class="math inline">\(B\)</span> 满足 <span class="math inline">\(\mu(B)&lt;\delta\)</span>，就有 <span class="math inline">\(\sup_n\mathbb{E}[|X_n|:B]&lt;\epsilon\)</span>。</p></blockquote><blockquote><p><strong>定理</strong>：<span class="math inline">\(\{X_n\}\)</span>一致可积当且仅当它们 <span class="math inline">\(L^1\)</span>一致有界且一致绝对连续。</p></blockquote><p><span class="math inline">\(\Rightarrow\)</span>: <span class="math inline">\(L^1\)</span>一致有界已经有了。下证一致绝对连续性质。对任何可测集 <span class="math inline">\(B\)</span>，我们考虑用一个待定的 <span class="math inline">\(a&gt;0\)</span> 把积分 <span class="math inline">\(\mathbb{E}[|X_n|: B]\)</span> 变成 <span class="math display">\[\mathbb{E}[|X_n|: B,\ |X_n|\geq a] +\mathbb{E}[|X_n|: B,\ |X_n|&lt;a].\]</span> 第一项小于等于 <span class="math inline">\(\mathbb{E}[|X_n|: |X_n|\geqa]\)</span>，由一致可积性我们可以取 <span class="math inline">\(a\)</span> 使得它小于 <span class="math inline">\(\epsilon/2\)</span>。第二项小于等于 <span class="math inline">\(a\mu(B)\)</span>。所以只要 <span class="math inline">\(\mu(B)&lt;\delta=\frac{\epsilon}{2a}\)</span>即可。</p><p><span class="math inline">\(\Leftarrow\)</span>: 我们可以料想 <span class="math inline">\(\{|X_n|\geq a\}\)</span>的测度是会一致地越来越小的：</p><p><span class="math display">\[\mathbb{P}(\{|X_n|\geqa\})=\mathbb{E}[1: |X_n|\geq a]\leq \mathbb{E}[\frac{|X_n|}{a}:|X_n|\geq a]\leq \frac{\mathbb{E}|X_n|}{a}=\frac{K}{a}.\]</span> 其中<span class="math inline">\(K\)</span> 是 <span class="math inline">\(\{X_n\}\)</span> 的 <span class="math inline">\(L^1\)</span> 上界。所以确实可以取 <span class="math inline">\(a\)</span> 适当大使得 <span class="math inline">\(\{|X_n|\geq a\}\)</span>的测度一致地小于一致绝对连续性中所需要的那个 <span class="math inline">\(\delta\)</span>。</p><blockquote><p><strong>定理</strong>：一致可积性是平移不变的： <span class="math inline">\(\{X_n\}\)</span> 一致可积且 <span class="math inline">\(Y\in L^1\)</span>，则 <span class="math inline">\(\{X_n+Y\}\)</span> 也是一致可积的。</p></blockquote><p>为此只要证明它们一致 <span class="math inline">\(L^1\)</span>有界且一致绝对连续。其中一致 <span class="math inline">\(L^1\)</span>有界是显然的。</p><p>对于一致绝对连续，我们有 <span class="math display">\[\mathbb{E}[|X_n+Y|: B]\leq\mathbb{E}[|X_n|:B] +\mathbb{E}[|Y|: B].\]</span> 取 <span class="math inline">\(\delta_1\)</span> 使得只要 <span class="math inline">\(\mu(B)&lt;\delta_1\)</span> 就有 <span class="math inline">\(\mathbb{E}[|X_n|:B]&lt;\frac{\epsilon}{2}\)</span>，再取<span class="math inline">\(\delta_2\)</span> 使得只要 <span class="math inline">\(\mu(B)&lt;\delta_2\)</span> 就有 <span class="math inline">\(\mathbb{E}[|Y|:B]&lt;\frac{\epsilon}{2}\)</span>，则<span class="math inline">\(\delta=\min\{\delta_1,\delta_2\}\)</span>符合要求。</p><p>最后一个重要定理是：<strong>依 <span class="math inline">\(L^1\)</span> 范数收敛 = 一致可积 +依测度收敛</strong>。</p><blockquote><p><strong>定理</strong>：随机变量序列 <span class="math inline">\(X_n\xrightarrow{L^1} X\)</span> 当且仅当 <span class="math inline">\(X_n\xrightarrow{\mathbb{P}}X\)</span> 且 <span class="math inline">\(\{X_n\}\)</span> 一致可积。</p></blockquote><p><span class="math inline">\(\Rightarrow\)</span>: <span class="math inline">\(L^1\)</span> 收敛当然可以得出依测度收敛 (Markov不等式一步即得)。要证明一致可积，我们只要根据平移不变性，证明 <span class="math inline">\(Y_n=X_n-X\)</span> 是一致可积的即可。</p><p>考虑取一个待定的正整数 <span class="math inline">\(N\)</span>，则<span class="math display">\[\sup_n\mathbb{E}[|Y_n|: |Y_n|\geq a] \leq\sup_{n&lt; N}\mathbb{E}[|Y_n|: |Y_n|\geq a] \vee \sup_{n\geqN}\mathbb{E}[|Y_n|: |Y_n|\geq a]\]</span>上面右边第一项是有限多个可积随机变量组成的集合，是一致可积的，所以只要<span class="math inline">\(a\)</span>足够大第一项是可以任意小的。第二项小于等于 <span class="math inline">\(\mathbb{E}|Y_n|\)</span> 并且由于 <span class="math inline">\(\mathbb{E}|Y_n|\to 0\)</span> 所以只要 <span class="math inline">\(N\)</span> 足够大也是可以任意小的。所以我们先取<span class="math inline">\(N\)</span> 足够大使得 <span class="math inline">\(\mathbb{E}|Y_n|&lt;\epsilon/2\)</span>，再取 <span class="math inline">\(a\)</span> 足够大使得 <span class="math inline">\(n&lt;N\)</span> 时 <span class="math inline">\(\sup_{n&lt; N}\mathbb{E}[|Y_n|: |Y_n|\geqa]&lt;\epsilon/2\)</span>，就得到了一致可积性。</p><p><span class="math inline">\(\Leftarrow\)</span>: 记 <span class="math inline">\(Y_n = X_n - X\)</span>，则 <span class="math inline">\(Y_n\mathbb{1}_{|Y_n|&lt;a}\)</span> 是一个不大于<span class="math inline">\(a\)</span> 的函数序列，且依测度收敛到0，从而由<strong>依测度的控制收敛定理</strong>有 <span class="math inline">\(Y_n\mathbb{1}_{|Y_n|&lt;a}\xrightarrow{L^1}0\)</span>。从而 <span class="math display">\[\|X_n-X\|_{L^1} =\mathbb{E}[Y_n\mathbb{1}_{\{|Y_n|&lt;a\}}] +\mathbb{E}[Y_n\mathbb{1}_{\{|Y_n|\geq a\}}].\]</span> 第一项取 <span class="math inline">\(n\)</span> 足够大就可以任意小，第二项取 <span class="math inline">\(a\)</span> 足够大也可以任意小，得证。</p><blockquote><p><strong>推论</strong>：正则鞅 <span class="math inline">\(X_n =\mathbb{E}[X|\mathcal{F}_n]\)</span> 是一致可积的。</p></blockquote><p>反过来也是对的：鞅序列如果是一致可积的，则一定是正则鞅。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd Kemp 概率论课程笔记</title>
      <link href="todd-kemp/index.html"/>
      <url>todd-kemp/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="probability-motivation">1.1 Probability Motivation</h1><p>无要点</p><h1 id="sigma--fields">1.2 <span class="math inline">\(\sigma\)</span>-Fields</h1><p>介绍了 <span class="math inline">\(\sigma\)</span>-域的概念，以及最重要的 <span class="math inline">\(\sigma\)</span>-域的例子：拓扑空间中开集生成的 Borel 域。</p><h1 id="measures-definition-and-examples">2.1 Measures Definition andExamples</h1><p>介绍了可测空间，以及测度的定义和基本性质。</p><blockquote><p><strong>定义</strong>：设 <span class="math inline">\(\mathcal{F}\)</span> 是一个 <span class="math inline">\(\sigma\)</span>- 域，称 <span class="math inline">\(\mu:\ \mathcal{F}\to[0,\infty]\)</span>是测度，如果对任何可数多个不交并有 <span class="math inline">\(\mu(\uplus_{n=1}^\inftyE_n)=\sum_{n=1}^\infty\mu(E_n)\)</span> 成立。</p></blockquote><p>测度的三个基本性质：</p><ul><li>单调性：<span class="math inline">\(A\subseteq B\Rightarrow\mu(A)\leq\mu(B)\)</span>。</li><li>加法等式 <span class="math inline">\(\mu(A\cup B) + \mu(A\cap B) =\mu(A) + \mu(B)\)</span>。</li><li>次可数可加：<span class="math inline">\(\mu(\cup_{n=1}^\inftyE_n)\leq\sum_{n=1}^\infty\mu(E_n)\)</span>。</li></ul><p>此外如果 <span class="math inline">\(\{\mu_n\}_{n=1}^\infty\)</span>是一列测度，则它们的和 <span class="math inline">\(\mu=\sum\limits_{n=1}^\infty\mu_n\)</span>也是测度。</p><p>预告了接下来构造测度的过程：有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 预测度 <span class="math inline">\(\Rightarrow\)</span> ·测度。</p><h1 id="finitely-additive-measures">2.2 Finitely Additive Measures</h1><p>这一讲介绍了<strong>有限可加测度</strong>，<strong>预测度(pre-measure，即域上的可数可加测度)</strong>，<strong>半代数(semi-algebra)</strong> 等概念。</p><blockquote><p><strong>定义 1</strong>：</p><ol type="1"><li>域上的可数可加测度叫做 <strong>预测度</strong>。</li><li>域上的有限可加测度叫做 <strong>有限可加测度</strong>。</li></ol></blockquote><blockquote><p><strong>核心思想</strong>：半代数 <span class="math inline">\(\mathcal{S}\)</span> 上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数 <span class="math inline">\(\mathcal{A}\)</span> 上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数 <span class="math inline">\(\mathcal{A}\)</span> 上的可数可加测度 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\sigma\)</span>- 域上的可数可加测度。</p></blockquote><p>域 <span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度的基本性质：</p><ul><li>单调性、加法等式同可数可加的情形。</li><li><strong>超可数可加</strong>：如果 <span class="math inline">\(\{E_n\}_{n=1}^{\infty}\)</span>是一列不相交的集合，则 <span class="math inline">\(\mu(\uplus_{n=1}^\inftyE_n)\geq\sum_{n=1}^\infty\mu(E_n)\)</span>。这是由于单调性左边始终是右边部分和的上界。注意这里要求每个<span class="math inline">\(E_n\in\mathcal{A}\)</span> 以及 <span class="math inline">\(\mu(\uplus_{n=1}^\inftyE_n)\in\mathcal{A}\)</span>。</li></ul><blockquote><p><strong>定义</strong>：一个半代数 <span class="math inline">\(\mathcal{S}\)</span>是指满足如下条件的集合族：</p><ol type="1"><li><span class="math inline">\(\emptyset\in\mathcal{S}\)</span>。</li><li>若 <span class="math inline">\(A,\,B\in\mathcal{S}\)</span> 则 <span class="math inline">\(A\cap B\in\mathcal{S}\)</span>。</li><li>若 <span class="math inline">\(A\in\mathcal{S}\)</span> 则 <span class="math inline">\(A^c\)</span> 可以表示为 <span class="math inline">\(\mathcal{S}\)</span> 中有限多个成员的不交并。</li></ol></blockquote><p>半代数 <span class="math inline">\(\mathcal{S}\)</span> 生成一个代数<span class="math inline">\(\mathcal{A}\)</span>： <span class="math display">\[\mathcal{A}=\{\text{all finite disjoint unions ofsets from }\mathcal{S} \}.\]</span></p><p>第一步<strong>半代数 <span class="math inline">\(\mathcal{S}\)</span>上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数<span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度</strong>：这一步是显然的，只需要验证定义不依赖于 <span class="math inline">\(\mathcal{A}\)</span> 作为 <span class="math inline">\(\mathcal{S}\)</span>中集合不交并的表示方式即可。</p><p>第三步<strong>代数 <span class="math inline">\(\mathcal{A}\)</span>上的可数可加测度 <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\sigma\)</span>-域上的可数可加测度</strong>：这一步总是可以做到的，由后面的测度扩张定理给出。</p><p>第二步<strong>代数 <span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度 <span class="math inline">\(\Rightarrow\)</span> 代数<span class="math inline">\(\mathcal{A}\)</span>上的可数可加测度</strong>：这一步并不总是可以做到。举个例子，在是整数集<span class="math inline">\(\mathbb{Z}\)</span> 的所有子集上定义如下测度<span class="math inline">\(\mu\)</span>：若子集 <span class="math inline">\(E\)</span> 或者 <span class="math inline">\(E^c\)</span> 之一是有限集，则规定 <span class="math inline">\(\mu(E)=0\)</span>，否则 <span class="math inline">\(\mu(E)=1\)</span>。此测度有限可加但不是可数可加，所以也不会有可数可加的扩张。</p><p>最重要的半代数 <span class="math inline">\(\mathcal{S}\)</span>的例子：所有形如 <span class="math inline">\(\{(a, b],-\infty\leqa&lt;b\leq \infty\}\)</span> 的半开区间。</p><p>任何单调函数 <span class="math inline">\(F\)</span>都可以给出其上的一个有限可加测度：<span class="math inline">\(F((a, b]))= F(b) - F(a)\)</span>，从而可以扩张为代数 <span class="math inline">\(\mathcal{A}\)</span>上的有限可加测度。<strong>但是要使得这个测度是可数可加的，我们必须限制<span class="math inline">\(F\)</span>是右连续的</strong>，这样的测度叫做 Stieltjes 测度，会在下一讲介绍。</p><h1 id="stieltjes-premeasures">3.1 Stieltjes Premeasures</h1><p>本讲接着上一讲的内容，证明了当 <span class="math inline">\(F\)</span>单调且右连续时，<span class="math inline">\(\mu((a,b])=F(b)-F(a)\)</span> 确实给出 Borel 域<span class="math inline">\(\mathcal{A}\)</span>上的一个可数可加测度。当然 Borel 域还是太复杂了(虽然它们都是有限多个半开区间的不交并)，无法用可数可加的定义来验证。我们还是要回到由半开区间构成的半代数<span class="math inline">\(\mathcal{S}\)</span> 上。</p><p>我们要从有限可加推出可数可加，而有限可加蕴涵了可数<strong>超</strong>可加，所以我们还缺少可数<strong>次</strong>可加。而<span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>上的可数次可加实际上可以由 <span class="math inline">\(\mathcal{S}\)</span> 上的可数次可加给出：</p><blockquote><p><strong>引理</strong>：代数 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span> 上的有限可加测度<span class="math inline">\(\mu\)</span>是可数可加的，<strong>当且仅当它限制在 <span class="math inline">\(\mathcal{S}\)</span>上是次可数可加的</strong>。这个话需要仔细解释清楚：<span class="math inline">\(\mu\)</span> 在 <span class="math inline">\(\mathcal{S}\)</span> 上次可数可加是指如果 <span class="math inline">\(\{E_n\}\)</span> 是半代数 <span class="math inline">\(\mathcal{S}\)</span>中互不相交的集合，并且它们的可数并 <span class="math inline">\(\uplus_{n} E_n\)</span> 也在半代数 <span class="math inline">\(\mathcal{S}\)</span> 中，则 <span class="math inline">\(\mu(\uplus_nE_n)\leq\sum_n\mu(E_n)\)</span>。</p></blockquote><p><strong>证明概要</strong>：<span class="math inline">\(\Rightarrow\)</span>是显然的，可数可加必然蕴含次可数可加。</p><p><span class="math inline">\(\Leftarrow\)</span>：<span class="math inline">\(\mu\)</span> 作为 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>上的有限可加测度自然是超可数可加的，要证明它可数可加，只要再证明它次可数可加：即若<span class="math inline">\(\uplus_n A_n\)</span> 是 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>中的可数不交并，则 <span class="math inline">\(\mu(\uplus_nA_n)\leq\sum_n\mu(A_n)\)</span>。记住 <span class="math inline">\(\uplus_n A_n\)</span> 以及所有 <span class="math inline">\(A_n\)</span> 现在都是 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span> 中的元素，所以<span class="math inline">\(\uplus_n A_n = \uplus_{j=1}^NE_j\)</span>，其中 <span class="math inline">\(E_j\in\mathcal{S}\)</span>。于是 <span class="math display">\[E_j = \uplus_n (A_n\capE_j)=\uplus_n\uplus_{i=1}^{N_n}E_i^n\cap E_j.\]</span> 利用 <span class="math inline">\(\mu\)</span> 在 <span class="math inline">\(\mathcal{S}\)</span> 上的次可数可加性有 <span class="math display">\[\mu(E_j)\leq \sum_n\sum_{i=1}^{N_n}\mu(E_i^n\capE_j).\]</span> 再利用 <span class="math inline">\(\mu\)</span> 在 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span> 上的有限可加性有<span class="math display">\[\sum_{i=1}^{N_n}\mu(E_i^n\capE_j)=\mu(A_n\cap E_j).\]</span> 于是 <span class="math display">\[\mu(\uplus_jE_j)=\sum_{j=1}^N\mu(E_j)\leq\sum_{j=1}^N\sum_{n=1}^\infty\mu(A_n\capE_j)=\sum_{n=1}^\infty\sum_{j=1}^N\mu(A_n\capE_j)=\sum_{n=1}^\infty\mu(A_n).\]</span> 即为所证。</p><blockquote><p><strong>定理</strong>：由单调右连续的函数 <span class="math inline">\(F\)</span> 给出的半代数 <span class="math inline">\(\mathcal{S}=\{(a,b]\ -\infty\leqa&lt;b\leq\infty\}\)</span> 上的 Stieltjes测度是次可数可加的，因而由上面引理它给出 <span class="math inline">\(\mathcal{A}(\mathcal{S})\)</span>上的可数可加测度。</p></blockquote><p><strong>Todd-Kemp 的精彩证明讲解</strong>：设 <span class="math inline">\((a,b]=\uplus_{i=1}^\infty (a_i,b_i]\)</span>，我们要证明 <span class="math display">\[F(b)-F(a)=\mu((a,b])\leq\sum_{i=1}^\infty\mu((a_i,b_i])=\sum_{i=1}^\infty(F(b_i)-F(a_i)).\]</span> 我们可以先假设 <span class="math inline">\(a,b\)</span> 都是有限的。</p><p><strong>不要幻想可以给区间 <span class="math inline">\((a_i,b_i]\)</span>之间按照大小排顺序，它们可能有无穷多个聚点</strong>。</p><p><strong>想法是把 <span class="math inline">\((a, b]\)</span>缩小一点变成 <span class="math inline">\([a+\delta, b]\)</span>，把<span class="math inline">\((a_i,b_i]\)</span> 放大一点变成 <span class="math inline">\((a_i,b_i+\delta_i)\)</span>，这样可以使用紧集的有限开覆盖性质</strong>。从而存在<span class="math inline">\(N\)</span> 使得前 <span class="math inline">\(N\)</span> 个开区间就足以覆盖 <span class="math inline">\([a+\delta,b]\)</span>： <span class="math display">\[[a+\delta,b] \subseteq \cup_{j=1}^N (a_j,b_j+\delta_j).\]</span> 现在 <span class="math inline">\(\mu\)</span>作为一个有限可加测度，由于 <span class="math inline">\((a+\delta,b]\)</span> 被 <span class="math inline">\(\cup_{j=1}^N (a_j,b_j+\delta_j]\)</span> 覆盖，因而必然有 <span class="math display">\[\mu((a+\delta, b])\leq \sum_{j=1}^N \mu((a_j,b_j+\delta_j])\leq\sum_{j=1}^\infty \mu((a_j, b_j+\delta_j]).\]</span>上式左边等于 <span class="math inline">\(F(b)-F(a+\delta)\)</span>，<span class="math inline">\(\delta\)</span> 是任意正数，所以令其趋于 0 并利用<span class="math inline">\(F\)</span> 的右连续有 <span class="math inline">\(F(a+\delta)\downarrow F(a)\)</span>，所以上式变为<span class="math display">\[\mu((a, b])\leq\sum_{j=1}^\infty\mu((a_j,b_j+\delta_j])=\sum_{j=1}^\infty \mu((a_j, b_j]) + \sum_{j=1}^\infty\mu((b_j, b_j+\delta_j]).\]</span> 注意到 <span class="math inline">\(\delta_j\)</span> 也是任意的，并且 <span class="math inline">\(F\)</span> 右连续，所以对任何 <span class="math inline">\(\epsilon&gt;0\)</span> 我们可以取 <span class="math inline">\(\delta_j\)</span> 足够小，使得 <span class="math inline">\(F(b_j+\delta_j)- F(b_j) &lt;\epsilon/2^j\)</span>。于是 <span class="math display">\[\mu((a,b])\leq\sum_{j=1}^\infty\mu((a_j, b_j+\delta_j])=\sum_{j=1}^\infty\mu((a_j, b_j]) + \epsilon.\]</span> 由 <span class="math inline">\(\epsilon\)</span> 任意性定理得证。</p><h1 id="outer-measure">3.2 Outer Measure</h1><p>这一节介绍了外测度的概念。</p><p>如果我们有一个集合族 <span class="math inline">\(\mathcal{A}\)</span>(<span class="math inline">\(\mathcal{A}\)</span>一般是个代数)，以及其上的函数 <span class="math inline">\(\mu:\\mathcal{A}\to[0,+\infty]\)</span>，则我们可以定义 <span class="math inline">\(2^{\Omega}\)</span> 上的外测度 <span class="math inline">\(\mu^\ast\)</span> 为 <span class="math display">\[\mu^\ast(E) =\inf\left\{\sum_{n=1}^\infty\mu(E_n),\ E_n\in\mathcal{A},E\subset\bigcup_{n=1}^\infty E_n\right\}.\]</span> 外测度 <span class="math inline">\(\mu^\ast\)</span> 满足：</p><blockquote><ol type="1"><li><span class="math inline">\(\mu^\ast(\emptyset)=0\)</span>。</li><li>单调性。</li><li>次可数可加性。</li></ol></blockquote><p>Todd Kemp 视频里面提到 <span class="math inline">\(\mu^\ast\)</span>可以用来区别有限可加测度和预测度：</p><blockquote><ol type="1"><li>如果 <span class="math inline">\((\mu, \mathcal{A})\)</span>是预测度，则<strong>在 <span class="math inline">\(\sigma(\mathcal{A})\)</span> 上有 <span class="math inline">\(\mu(E)\leq\mu^\ast(E)\)</span>，并且在 <span class="math inline">\(\mathcal{A}\)</span> 上有 <span class="math inline">\(\mu=\mu^\ast\)</span></strong>。</li><li>如果 <span class="math inline">\((\mu, \mathcal{A})\)</span>是有限可加测度，则<strong>在 <span class="math inline">\(\mathcal{A}\)</span> 上有 <span class="math inline">\(\mu(E)\geq\mu^\ast(E)\)</span></strong>。</li></ol></blockquote><h1 id="radon-measures">5.1 Radon Measures</h1><p>本讲介绍了实直线上的 Radon 测度等价于 Stieltjes 测度。</p><p>Radon 测度是指对任何紧集 <span class="math inline">\(K\)</span> 有<span class="math inline">\(\mu(K)&lt;\infty\)</span>的测度。这种测度的分布函数必然是单调、右连续的，从而根据之前介绍的预测度和测度扩张定理给出了实直线上的一个可数可加测度。</p><h1 id="random-variables-motivation">6.1 Random VariablesMotivation</h1><p>本节介绍了随机变量，分布函数的概念。样本空间 <span class="math inline">\(\Omega\)</span> (modelling space)是难以接触到的，我们对其的观测是通过随机变量来进行的。</p><p>随机变量 <span class="math inline">\(X\)</span> 的分布函数为 <span class="math inline">\(F(t) = \mathbb{P}(X\leq t),\,t\in\overline{\mathbb{R}}\)</span>。<span class="math inline">\(F(t)\)</span> 是单调递增且右连续的。</p><h1 id="riemann-stieltjes-integration">7.2 Riemann-StieltjesIntegration</h1><p>无要点。</p><h1 id="the-radon-nikodym-theorem">11.1 The Radon-Nikodym Theorem</h1><p>本讲介绍了 Radon-Nikodym 定理，不过没有给出证明。</p><p><strong>Motivation</strong>: 设 <span class="math inline">\(\mu,\nu\)</span> 是两个测度，是否存在非负可测函数<span class="math inline">\(\rho\)</span> 使得 <span class="math inline">\(\nu(A)=\int_A\rho\,\mathrm{d}\mu\)</span>对任何可测集 <span class="math inline">\(A\)</span> 成立？</p><p><strong>必要条件</strong>：<span class="math inline">\(\mu(A)=0\Rightarrow\nu(A)=0\)</span>。这时我们称<span class="math inline">\(\nu\)</span> 关于 <span class="math inline">\(\mu\)</span> <strong>绝对连续</strong>，记作 <span class="math inline">\(\nu\ll\mu\)</span>。</p><p>此条件同样也是充分的：若 <span class="math inline">\(\nu\)</span>关于 <span class="math inline">\(\mu\)</span> 绝对连续，则存在 <span class="math inline">\(\rho\)</span> 使得 <span class="math inline">\(\rho=\dfrac{\mathrm{d}\nu}{\mathrm{d}\mu}\)</span>。</p><p><strong>奇异连续测度的例子</strong>：Cantor 函数 (devilstaircase)。<a href="https://www.youtube.com/watch?v=dQXVn7pFsVI">YouTube科普</a>。此函数没有点质量，也没有密度函数，但是确实给出一个全质量为 1的概率测度。</p><ul><li>此函数是连续递增的，所以是一个分布函数。</li><li>此函数是连续的，所以没有点质量，即单个点的测度是 0。</li><li>此函数是奇异的，因为它在除去 Cantor集对应的点之外几乎处处是常数。</li></ul><h1 id="dynkins-multiplicative-systems-theorem">14.1 Dynkin’sMultiplicative Systems Theorem</h1><p>本讲介绍了 Dynkin <span class="math inline">\(\pi-\lambda\)</span>定理的函数形式的版本。</p><blockquote><p><strong>定义</strong>：设 <span class="math inline">\((\Omega,\mathcal{F})\)</span> 是一个可测空间，称<span class="math inline">\(f\)</span> 是一个关于 <span class="math inline">\(\mathcal{F}\)</span> 可测的有界函数，如果存在<span class="math inline">\(M&gt;0\)</span> 使得 <span class="math inline">\(|f|\leq M\mathrm{a.e.}\)</span> 成立。记 <span class="math inline">\(\mathbb{B}(\Omega,\mathcal{F})\)</span>为全体这样的有界函数构成的向量空间。若 <span class="math inline">\(\{f_n\}\in\mathbb{B}(M,\mathcal{F})\)</span> 满足<span class="math inline">\(|f_n|\leq M\mathrm{a.e.}\)</span> 并且 <span class="math inline">\(f_n\to f\mathrm{a.e.}\)</span>，就称 <span class="math inline">\(f_n\)</span> <strong>一致有界收敛到 <span class="math inline">\(f\)</span></strong>。</p></blockquote><blockquote><p><strong>定理</strong>：设 <span class="math inline">\(\mathcal{I}\subseteq\mathcal{F}\)</span> 是一个<span class="math inline">\(\pi\)</span>- 系，设 <span class="math inline">\(\mathbb{H}(\mathcal{I})\subseteq\mathbb{B}(\Omega,\mathcal{F})\)</span>满足如下条件：</p><ol type="1"><li><span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span>是一个向量空间。</li><li><span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span> 包含<span class="math inline">\(\Omega\)</span> 上的常函数 <span class="math inline">\(\mathbb{1}\)</span>。</li><li>若 <span class="math inline">\(\{f_n\}\)</span> 是 <span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span>中的可测函数序列，且 <span class="math inline">\(f_n\)</span>一致有界收敛到 <span class="math inline">\(f\)</span>，则 <span class="math inline">\(f\in\mathbb{H}(\mathcal{I})\)</span>。</li><li><span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span> 包含<span class="math inline">\(\mathcal{I}\)</span> 中的所有指标函数 <span class="math inline">\(\mathbb{1}_{A},\,A\in\mathcal{I}\)</span>。</li></ol><p><strong>结论</strong>：<span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span> 包含所有关于<span class="math inline">\(\sigma(\mathcal{I})\)</span>-可测的有界函数。</p></blockquote><p><strong>证明概要</strong>：设 <span class="math display">\[\mathcal{A}=\{A\in\mathcal{F}:\\mathbb{1}_A\in\mathbb{H}(\mathcal{I})\}.\]</span></p><ul><li>由 2 <span class="math inline">\(\Omega\in\mathcal{A}\)</span>。</li><li>由 1, 2 结合有若 <span class="math inline">\(A\in\mathcal{A}\)</span> 则 <span class="math inline">\(A^c\in\mathcal{A}\)</span>。</li><li>由 3 有若 <span class="math inline">\(\{A_n\}\in\mathcal{A}\)</span>，<span class="math inline">\(A_n\uparrow\)</span> 则 <span class="math inline">\(\cup_{n}A_n\in\mathcal{A}\)</span>。</li></ul><p>于是 <span class="math inline">\(\mathcal{A}\)</span> 是一个 <span class="math inline">\(\lambda\)</span>- 系，并且由 4 有 <span class="math inline">\(\mathcal{A}\supseteq\mathcal{I}\)</span>，从而<span class="math inline">\(\mathcal{A}\supseteq\sigma(\mathcal{I})\)</span>。于是<span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span>包含所有形如 <span class="math inline">\(\mathbb{1}_A,\,A\in\sigma(\mathcal{I})\)</span>的指标函数，也就包含所有 <span class="math inline">\(\sigma(\mathcal{I})\)</span>上的简单可测函数，从而包含它们的所有一致有界极限，即全体 <span class="math inline">\(\sigma(\mathcal{I})\)</span>- 可测的有界函数。</p><p><strong>补充</strong>：条件 3 其实可以减弱为 <span class="math inline">\(\{f_n\}\)</span> 是非负可测函数序列，且 <span class="math inline">\(f_n\uparrow f\)</span>，<span class="math inline">\(f\)</span> 有界。这样我们首先得到 <span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span> 包含所有 <span class="math inline">\(\sigma(\mathcal{I})\)</span>上的非负简单函数，因而包含所有的非负有界可测函数，而对任何一般的 <span class="math inline">\(\sigma(\mathcal{I})\)</span> 有界可测函数 <span class="math inline">\(f\)</span>，<span class="math inline">\(f^{\pm}\)</span> 都是 <span class="math inline">\(\sigma(\mathcal{I})\)</span>上的非负有界可测函数，因而 <span class="math inline">\(f^{\pm}\)</span>和它们的差 <span class="math inline">\(f=f^+-f^-\)</span> 都属于 <span class="math inline">\(\mathbb{H}(\mathcal{I})\)</span>。</p><h1 id="product-measure">14.2 Product Measure</h1><p>本讲介绍了乘积测度的构造。<strong>记住乘积测度的构造是用到重积分的</strong>。</p><p><strong>可测空间的乘积</strong>：设 <span class="math inline">\((\Omega_1,\mathcal{F_1}),\,(\Omega_2,\mathcal{F_2})\)</span>是两个可测空间，其乘积空间定义为 <span class="math inline">\((\Omega_1\times\Omega_2,\,\sigma(\mathcal{F}_1\times\mathcal{F}_2))\)</span>。其中<span class="math inline">\(\mathcal{F}_1\otimes\mathcal{F}_2=\sigma(\mathcal{F}_1\times\mathcal{F}_2)\)</span>是由所有形如 <span class="math inline">\(\{A_1\times A_2,A_i\in\mathcal{F}_i\}\)</span> 的集合生成的 <span class="math inline">\(\sigma\)</span>- 域。</p><p><span class="math inline">\(\mathcal{F}_1\otimes\mathcal{F}_2\)</span>还有一种等价的刻画：它是使得投影映射 <span class="math inline">\(\pi_i(\omega_1,\omega_2)=\omega_i\)</span>均可测的最小 <span class="math inline">\(\sigma\)</span>- 域。</p><blockquote><p><strong>引理</strong>：随机向量 <span class="math inline">\(f:(\Omega,\mathcal{F})\to(\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>是可测的，当且仅当其每个分量 <span class="math inline">\(f_i\)</span>是可测的。</p></blockquote><p><span class="math inline">\(\Rightarrow\)</span>: 每个 <span class="math inline">\(f_i=\pi_i\circ f\)</span>作为两个可测映射的复合当然是可测的。</p><p><span class="math inline">\(\Leftarrow\)</span>: 本质是证明如果每个<span class="math inline">\(X_i\)</span> 都是随机变量，则 <span class="math inline">\(X=(X_1,\ldots,X_n)\)</span> 是随机向量。对任何形如<span class="math inline">\(E=E_i\times_{j\nei}\mathcal{B}_i(\mathbb{R})\)</span> 的集合，<span class="math inline">\(X^{-1}(E) =\{\omega\in\Omega: X_i(\omega)\inE_i\}\)</span> 是可测集，而这样的 <span class="math inline">\(E\)</span>生成了 <span class="math inline">\(\mathcal{B}(\mathbb{R}^d)\)</span>，所以 <span class="math inline">\(X^{-1}(E)\)</span> 对任何 <span class="math inline">\(E\subset\mathcal{B}(\mathbb{R}^d)\)</span>都可测。结论得证。</p><p>如果每个 <span class="math inline">\((\Omega_i,\mathcal{F}_i)\)</span>还是测度空间，其上的测度为 <span class="math inline">\(\mu_i\)</span>，则我们可以在 <span class="math inline">\((\Omega_1\times\Omega_2,\mathcal{F}_1\otimes\mathcal{F}_2)\)</span>上定义测度 <span class="math inline">\(\mu_1\otimes\mu_2\)</span> 使得<span class="math inline">\((\mu_1\otimes\mu_2)(E_1\timesE_2)=\mu_1(E_1)\mu_2(E_2)\)</span> 对任何 <span class="math inline">\(E_i\in\mathcal{F}_i,\, i=1,2\)</span> 成立。</p><p>实际上我们可以让这个乘积测度满足</p><p><span class="math display">\[\int_{\Omega_1\times\Omega_2}f_1\otimesf_2\mathrm{d}(\mu_1\otimes\mu_2) =\int_{\Omega_1}f_1\mathrm{d}\mu_1\cdot\int_{\Omega_2}f_2\mathrm{d}\mu_2.\]</span></p><p>考虑满足如下条件的乘积空间 <span class="math inline">\(\Omega_1\times\Omega_2\)</span> 上的可测函数 <span class="math inline">\(f\)</span>:</p><blockquote><ol type="1"><li><span class="math inline">\(\omega_1\tof(\omega_1,\omega_2)\)</span> 对任何 <span class="math inline">\(\omega_2\)</span> 都是可测函数。</li><li><span class="math inline">\(\omega_2\tof(\omega_1,\omega_2)\)</span> 对任何 <span class="math inline">\(\omega_1\)</span> 都是可测函数。</li><li><span class="math inline">\(\omega_1\to\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2(\mathrm{d}\omega_2)\)</span> 是<span class="math inline">\(\mathcal{F}_1/\mathcal{B}(\overline{\mathbb{R}})\)</span>可测函数。注意这个积分值可能是无穷。</li><li><span class="math inline">\(\omega_2\to\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1(\mathrm{d}\omega_1)\)</span> 是<span class="math inline">\(\mathcal{F}_2/\mathcal{B}(\overline{\mathbb{R}})\)</span>可测函数。</li><li><span class="math display">\[\int_{\Omega_1}\left(\int_{\Omega_2}f(\omega_1,\omega_2)\mu_2(\mathrm{d}\omega_2)\right)\mu_1(\mathrm{d}\omega_1)=\int_{\Omega_2}\left(\int_{\Omega_1}f(\omega_1,\omega_2)\mu_1(\mathrm{d}\omega_1)\right)\mu_2(\mathrm{d}\omega_2).\]</span></li></ol></blockquote><p>容易验证对所有形如 <span class="math inline">\(f_1\otimesf_2\)</span> 的函数它们满足上面的性质。它们构成一个乘法系，包含所有形如<span class="math inline">\(\mathbb{1}_{E_1}\otimes\mathbb{1}_{E_2}\)</span>的函数，然后上面的条件对函数列的有界极限仍然成立。根据函数版本的 Dynkin定理，上面的条件对所有有界可测函数，或者非负可测函数都成立。</p><p>由此我们可以定义乘积空间中的测度为</p><p><span class="math display">\[\mu(E)=\int_{\Omega_1}\left(\int_{\Omega_2}\mathbb{1}_{E}\mu_2(\mathrm{d}\omega_2)\right)\mu_1(\mathrm{d}\omega_1)=\int_{\Omega_2}\left(\int_{\Omega_1}\mathbb{1}_{E}\mu_1(\mathrm{d}\omega_1)\right)\mu_2(\mathrm{d}\omega_2).\]</span>不难验证这样定义的积分是有限可加的(积分的线性性质)，可以取单调上升的极限，所以是可数可加的，并且当 <span class="math inline">\(E\)</span> 形如 <span class="math inline">\(E_1\times E_2\)</span> 时有 <span class="math inline">\(\mu(E)=\mu_1(E_1)\mu_2(E_2)\)</span>，从而确实给出符合要求的乘积测度。</p><h1 id="kolmogorovs-0-1-law">17.1 Kolmogorov’s 0-1 Law</h1><p>本讲介绍了独立随机变量序列的尾事件，以及 Kolmogrov 0-1 律。</p><p>设 <span class="math inline">\(\{X_n\}\)</span> 是独立的随机变量序列(不是两两独立，而是任何有限多个都独立)称 <span class="math inline">\(\mathcal{T}=\cap_{n=1}^\infty\sigma(X_n,X_{n+1},\ldots)\)</span>为尾事件域。</p><blockquote><p><strong>Kolmogrov 0-1 律</strong>：对任何 <span class="math inline">\(A\in\mathcal{T}\)</span> 有 <span class="math inline">\(\mathbb{P}(A)\in\{0,1\}\)</span>。</p></blockquote><p><strong>证明概要</strong>：</p><ul><li><span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span> 和 <span class="math inline">\(\sigma(X_{n+1},X_{n+2},\ldots)\)</span>是独立的。因为考虑如下两个集合族： <span class="math display">\[\{\text{all finite intersections like }\cap A_i,A_i\in\sigma(X_i),i=1,2,\ldots,n\}.\]</span> <span class="math display">\[\{\text{all finite intersections like }\cap A_j,A_j\in\sigma(X_j),j=n+1,n+2,\ldots\}.\]</span> 这俩都是 <span class="math inline">\(\pi\)</span>- 系且互相独立，所以它们生成的 <span class="math inline">\(\sigma\)</span>- 域也独立。前者可以生成 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span>，后者可以生成<span class="math inline">\(\sigma(X_{n+1},X_{n+2},\ldots)\)</span>。</li><li>于是 <span class="math inline">\(\sigma(X_1,\ldots,X_n)\)</span> 和<span class="math inline">\(\mathcal{T}\)</span> 是独立的。</li><li>于是 <span class="math inline">\(\pi\)</span>- 系 <span class="math inline">\(\cup_{n=1}^\infty\sigma(X_1,\ldots,X_n)\)</span>和 <span class="math inline">\(\mathcal{T}\)</span> 是独立的。</li><li>于是 <span class="math inline">\(\sigma\)</span>- 域 <span class="math inline">\(\sigma(X_1,\ldots,X_n,\ldots)\)</span> 和 <span class="math inline">\(\mathcal{T}\)</span> 独立，从而 <span class="math inline">\(\mathcal{T}\)</span> 和 <span class="math inline">\(\mathcal{T}\)</span> 独立，从而得证。</li></ul><h1 id="convolution">17.2 Convolution</h1><p>本讲介绍了概率测度之间的卷积。</p><blockquote><p><strong>定义</strong>：两个概率测度 <span class="math inline">\(\mu,\nu\)</span> 之间的卷积定义为 <span class="math display">\[\mu\ast \nu(B) =\int_{\mathbb{R}^d\times\mathbb{R}^d}\mathbb{1}_B(x+y)\mu\otimes\nu(\,\mathrm{d}x\,\mathrm{d}y)=\int_{\mathbb{R}^d}\mu(B-y)\vdx{y}.\]</span></p></blockquote><h1 id="strong-law-of-large-numbers-part-1">18.1 Strong Law of LargeNumbers, Part 1</h1><p>本讲介绍了 Kolmogrov 强大数定理的表述，以及证明思想。</p><p>基本思想是利用截断的序列与原序列是尾等价的，先对截断的序列证明结论，再回到原序列。</p><blockquote><p><strong>强大数定理</strong>：设 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span> 的 <span class="math inline">\(L^1\)</span> 序列且 <span class="math inline">\(\mathbb{E}[X_n]=a\)</span>，则 <span class="math inline">\(\dfrac{S_n}{n}\to a, \mathrm{a.e.}\)</span>。</p></blockquote><p><strong>重要技巧</strong>：同一个概率空间上的两个序列 <span class="math inline">\(\{X_n\},\,\{Y_n\}\)</span> 称作是尾等价的，如果<span class="math inline">\(\sum_{n=1}^\infty\mathbb{P}(X_n\neY_n)&lt;\infty\)</span>。</p><p>这样根据 Borel-Cantelli 引理，<span class="math inline">\(\{X_n\neY_n,\mathrm{i.o.}\}\)</span> 是零测集，从而 <span class="math inline">\(X_n=Y_n\)</span>最终会几乎处处成立，从而二者的极限行为一致。即如果 <span class="math inline">\(b_n\uparrow\infty\)</span>，则 <span class="math display">\[\lim\limits_{n\to\infty}\dfrac{1}{b_n}\sum_{j=1}^nX_n = X \Leftrightarrow\lim\limits_{n\to\infty}\dfrac{1}{b_n}\sum_{j=1}^n Y_n = X.\]</span></p><p><strong>截断的序列和原序列是尾等价的</strong></p><blockquote><p><strong>引理</strong>：若 <span class="math inline">\(X\inL^1,\,\epsilon&gt;0\)</span>，则 <span class="math display">\[\sum_{n=1}^\infty\mathbb{P}(X\geq n\epsilon)\leq\frac{1}{\epsilon}\mathbb{E}|X|.\]</span></p></blockquote><p>值得与 Markov 不等式比较一下，这个不等式更强。</p><p><strong>证明概要</strong>：只要证明结论对 <span class="math inline">\(\epsilon=1\)</span> 成立即可。而这非常显然：</p><p><span class="math display">\[X\geq\lfloor X\rfloor =\sum_{n=1}^\infty \mathbb{1}_{\{n\leq X\}}.\]</span></p><blockquote><p><strong>推论</strong>：若 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span> 的 <span class="math inline">\(L^1\)</span> 序列，令 <span class="math inline">\(Y_n = X_n\mathbb{1}_{\{|X_n|\leq n\}}\)</span>，则<span class="math inline">\(\{Y_n\}\)</span> 与 <span class="math inline">\(\{X_n\}\)</span> 是尾等价的。</p></blockquote><p>于是接下来的任务就是证明 <span class="math inline">\(S_n^Y =\dfrac{Y_1+\cdots+Y_n}{n}\to a,\,\mathrm{a.e.}\)</span>。</p><h1 id="kolmogorovs-convergence-criterion">18.2 Kolmogorov’s ConvergenceCriterion</h1><p>本讲介绍了 Kolmogrov 收敛判定：独立随机变量序列如果是 <span class="math inline">\(L^2\)</span> 意义下的 Cauchy序列，则也是逐点收敛意义下的 Cauchy 序列。</p><p>在上一讲中，我们通过把 <span class="math inline">\(L^1\)</span>的序列 <span class="math inline">\(\{X_n\}\)</span> 取截断得到 <span class="math inline">\(Y_n=X_n\mathbb{1}_{\{|X_n|\leqn\}}\)</span>，这是一个与 <span class="math inline">\(\{X_n\}\)</span>尾等价的序列。从而只要证明 <span class="math inline">\(\frac{\sum_{k=1}^n Y_k}{n}\toa\)</span>。为此我们分两步：</p><ol type="1"><li>证明 <span class="math inline">\(\frac{\sum_{k=1}^n(Y_k-\mathbb{E}Y_k)}{n}\to 0\)</span>。</li><li>证明 <span class="math inline">\(\mathbb{E}Y_n\to a\)</span>，从而<span class="math inline">\(\frac{\sum_{k=1}^n\mathbb{E}Y_k}{n}\toa\)</span>。结合上一点就证明了强大数定理。</li></ol><p>2 用控制收敛定理很容易得出，所以关键是证明 1。</p><p>我们首先证明 <span class="math inline">\(\sum_{k=1}^n\frac{Y_k-\mathbb{E}Y_k}{n}\)</span> 是个收敛的序列，然后用下一讲介绍的Kronecker 引理来得出 <span class="math inline">\(\frac{\sum_{k=1}^n(Y_k-\mathbb{E}Y_k)}{n}\to 0\)</span>。</p><blockquote><p><strong>Kolmogrov 收敛判定</strong>：若 <span class="math inline">\(\mathrm{i.i.d}\)</span> 序列 <span class="math inline">\(Z_n\)</span> 满足 <span class="math inline">\(\sum\mathrm{Var}(Z_n)&lt;\infty\)</span> 则 <span class="math inline">\(\sum(Z_n-\mathbb{E}Z_n)\)</span>几乎处处收敛。</p></blockquote><p><strong>证明概要</strong>：我们可以不妨假设 <span class="math inline">\(\mathbb{E}Z_n=0\)</span>，则问题变为若 <span class="math inline">\(\mathrm{i.i.d}\)</span> 序列 <span class="math inline">\(\sum\mathbb{E}|Z_n|^2\)</span> 收敛，则 <span class="math inline">\(\sum Z_n\)</span> 几乎处处收敛。</p><p>记 <span class="math inline">\(S_n=\sum_{k=1}^nZ_k\)</span>，利用Markov 不等式不难有 <span class="math display">\[\mathbb{P}(|S_n|\geq\epsilon)\leq\frac{1}{\epsilon^2}\mathbb{E}[S_n^2].\]</span>有意思的是，上面的不等式中在左边把 <span class="math inline">\(S_n\)</span> 换成 <span class="math inline">\(S_n^\ast=\max_{1\leq i\leq n}|S_n|\)</span>仍然成立：</p><blockquote><p><strong>Kolmogrov 极大不等式</strong>：对任何正数 <span class="math inline">\(\epsilon&gt;0\)</span> 有 <span class="math display">\[\mathbb{P}(S_n^\ast\geq\epsilon)\leq\frac{1}{\epsilon^2}\mathbb{E}[S_n]^2.\]</span></p></blockquote><p>证明：记 <span class="math inline">\(\tau=\inf\{j\in\mathbb{Z}_{\geq1}:\|S_j|\geq\epsilon\}\)</span>。则 <span class="math inline">\(\mathbb{P}(S_n^\ast\geq\epsilon)=\mathbb{P}(\tau\leqn)\)</span>。 <span class="math display">\[\mathbb{E}[S_n^2:\S_n^\ast\geq\epsilon]=\mathbb{E}[S_n^2:\ \tau\leqn]=\sum_{k=1}^n\mathbb{E}[S_n^2:\ \tau=k].\]</span> 使用技巧 <span class="math inline">\(S_n^2=(S_k + S_n - S_k)^2\)</span> 我们有 <span class="math display">\[\mathbb{E}[S_n^2:\ \tau=k] = \mathbb{E}[S_k^2 +(S_n-S_k)^2:\ \tau=k] + \mathbb{E}[2S_k(S_n-S_k):\ \tau=k].\]</span>注意到第二项 <span class="math display">\[\mathbb{E}[2S_k(S_n-S_k):\\tau=k] =\mathbb{E}[2S_k\mathbb{1}_{\{\tau=k\}}(S_n-S_k)]=2\mathbb{E}[S_k\mathbb{1}_{\{\tau=k\}}]\cdot\mathbb{E}[S_n-S_k]=0.\]</span>所以 <span class="math display">\[\mathbb{E}[S_n^2]\geq\sum_{k=1}^n\mathbb{E}[S_n^2:\\tau=k] \geq \sum_{k=1}^n\mathbb{E}[S_k^2:\\tau=k]\geq\epsilon^2\sum_{k=1}^n\mathbb{E}\mathbb{1}_{\{\tau=k\}}=\epsilon^2\mathbb{P}(\tau\leqn)=\epsilon^2 \mathbb{P}(S_n^\ast\geq\epsilon).\]</span></p><p>回到 Kolmogrov 收敛定理的证明。</p><p>Kolmogrov 极大不等式告诉我们</p><p><span class="math display">\[\mathbb{P}(\max_{n\leq k \leq m}|S_k -S_n|\geq\epsilon)\leq\frac{1}{\epsilon^2}\mathbb{E}|S_m-S_n|^2=\frac{1}{\epsilon^2}\sum_{k=n}^m\mathbb{E}Z_k^2.\]</span> 令 <span class="math inline">\(m\to\infty\)</span> 我们有 <span class="math display">\[\mathbb{P}(\sup_{k\geq n}|S_k -S_n|\geq\epsilon)\leq\frac{1}{\epsilon^2}\sum_{k=n}^\infty\mathbb{E}Z_k^2.\]</span> 于是 <span class="math display">\[\mathbb{P}(\sup_{k,j\geq n}|S_k -S_j|\geq\epsilon)\leq\frac{2}{\epsilon^2}\sum_{k=n}^\infty\mathbb{E}Z_k^2.\]</span> 所以随机变量序列 <span class="math inline">\(\delta_n = \sup_{k,j\geq n}|S_k - S_j|\)</span>依测度收敛到 0。但是 <span class="math inline">\(\delta_n\)</span>是一个单调下降的非负序列，它必然有一个几乎处处收敛的极限 <span class="math inline">\(\delta\)</span>，<span class="math inline">\(\delta\)</span> 也非负。<span class="math inline">\(\delta\)</span> 依测度收敛到 0，又几乎处处收敛到<span class="math inline">\(\delta\)</span>，那必须 <span class="math inline">\(\delta\)</span> 几乎处处为 0，即 <span class="math inline">\(\{S_n\}\)</span> 是 Cauchy 序列。</p><h1 id="strong-law-of-large-numbers-part-2">19.1 Strong Law of LargeNumbers, Part 2</h1><p>介绍了证明强大数定理的第二个工具：Kronecker 引理。</p><blockquote><p><strong>Kronecker 引理</strong>：若 <span class="math inline">\(\{b_k\}\uparrow\infty\)</span> 且 <span class="math inline">\(\lim\limits_{n\to\infty}\sum\limits_{k=1}^n\dfrac{x_k}{b_k}\)</span>存在，则 <span class="math inline">\(\lim\limits_{n\to\infty}\dfrac{1}{b_n}\sum\limits_{k=1}^nx_k=0\)</span>。</p></blockquote><p><strong>证明概要</strong>：记 <span class="math inline">\(u_n=\sum\limits_{k=1}^n\dfrac{x_k}{b_k},\,u_0=0\)</span>，则<span class="math inline">\(\lim\limits_{n\to\infty}u_n=s\)</span>存在。 <span class="math display">\[\begin{align*}\frac{1}{b_n}\sum_{k=1}^nx_k&amp;=\frac{1}{b_n}\sum_{k=1}^n(u_k-u_{k-1})b_k=\frac{1}{b_n}\sum_{k=1}^nu_kb_k-\frac{1}{b_n}\sum_{k=0}^{n-1}u_kb_{k+1}\\&amp;=u_n-\frac{b_n-b_1}{b_n}s-\sum_{k=1}^{n-1}\frac{b_{k+1}-b_k}{b_n}(u_k-s).\end{align*}\]</span>而最后一个余项的绝对值小于等于 <span class="math display">\[\begin{align*}\sum_{k=1}^{n-1}\frac{b_{k+1}-b_k}{b_n}|u_k-s|=\left(\sum_{k=1}^{N}+\sum_{k=N+1}^{n-1}\right)\frac{b_{k+1}-b_k}{b_n}|u_k-s|\end{align*}\]</span>这里对 <span class="math inline">\(n&gt;N\)</span> 有 <span class="math inline">\(|u_n-s|&lt;\epsilon\)</span> 成立。</p><p>当 <span class="math inline">\(n\to\infty\)</span>时第一个和项是一个有界的值除以 <span class="math inline">\(b_n\)</span>从而趋于 0。第二个和项显然不大于 <span class="math inline">\(\dfrac{b_n}{b_n}\epsilon\)</span>，所以这个余项可以任意小。</p><blockquote><p><strong>引理</strong>：<span class="math inline">\(Y_n' =Y_n/n\)</span> 满足 Kolmogrov 收敛判定。</p></blockquote><p><strong>证明概要</strong>： <span class="math display">\[\begin{align*}\sum_{n=1}^\infty\mathrm{Var}(Y_n')&amp;=\sum_{n=1}^\infty\frac{\mathbb{E}Y_n^2- (\mathbb{E}Y_n)^2}{n^2}\leq\sum_{n=1}^\infty\frac{\mathbb{E}Y_n^2}{n^2}\\&amp;=\sum_{n=1}^\infty\frac{\mathbb{E}X_n^2\mathbb{1}_{\{|X_n|\leqn\}}}{n^2}\\&amp;=\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}}\right]\\&amp;\leq\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2},\|X_1|\leq 2\right] +\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}},\|X_1|&gt;2\right]\\&amp;\leq4\sum_{n=1}^\infty\frac{1}{n^2}+\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}},\ |X_1|&gt;2\right] .\end{align*}\]</span> 为什么要用 <span class="math inline">\(|X_1|\)</span> 是否大于 2把它分成两部分？这里其实可以用任何大于等于 2 的数，不过 2已经足够了，这样做的原因下面就会看到。</p><p>现在第一项是有限的，我们只要说明第二项也有限即可。你可能想把 <span class="math inline">\(\mathbb{1}_{\{|X_1|\leq n\}}\)</span>扔掉，但是注意强大数定律中 <span class="math inline">\(|X_1|\)</span> 是<span class="math inline">\(L^1\)</span> 可积的，未必是 <span class="math inline">\(L^2\)</span> 可积的，所以扔掉是不行的。我们得把<span class="math inline">\(\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}}\)</span> 这个东西估计一下。注意到对任何正整数 <span class="math inline">\(k\)</span>，<span class="math inline">\(\sum_{n=k}^\infty\frac{1}{n^2}\)</span> 就是 <span class="math inline">\(\frac{1}{\lfloor t\rfloor^2}\)</span> 在 <span class="math inline">\([k,\infty)\)</span> 上的积分， 所以当 <span class="math inline">\(x&gt;2\)</span> 时 <span class="math display">\[\begin{align*}\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{x\leq n\}}&amp;=\sum_{n\geqx}^\infty\frac{1}{n^2}=\sum_{n= \lceilx\rceil}^\infty\frac{1}{n^2}\\&amp;=\int_{\lceilx\rceil}^\infty\frac{1}{\lfloor t\rfloor^2}\,\mathrm{d}t\\&amp;\leq\int_{\lceilx\rceil}^\infty\frac{1}{(t-1)^2}\,\mathrm{d}t\\&amp;=\frac{1}{\lceilx\rceil -1}\\&amp;\leq\frac{1}{x-1}&lt;\frac{2}{x}.\end{align*}\]</span> 所以取<span class="math inline">\(x&gt;2\)</span> 主要是为了最后一步的 <span class="math inline">\(\frac{1}{x-1}&lt;\frac{2}{x}\)</span>。</p><p>于是我们就证明了在 <span class="math inline">\(|X_1|&gt;2\)</span>上有 <span class="math display">\[\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}}&lt;\frac{2}{|X_1|}.\]</span> 两边乘以 <span class="math inline">\(|X_1|^2\)</span> 并积分，则 <span class="math display">\[\mathbb{E}\left[|X_1|^2\sum_{n=1}^\infty\frac{1}{n^2}\mathbb{1}_{\{|X_1|\leqn\}},\ |X_1|&gt;2\right] &lt; 2\mathbb{E}|X_1|.\]</span>这就证明了结论。</p><h1 id="renewal-theory">19.2 Renewal Theory</h1><p>本讲以灯泡寿命为例子，介绍了强大数定理在更新理论中的应用。</p><p>设灯泡的寿命互相独立，且服从某个共同的非负随机变量 <span class="math inline">\(X,\ \mathbb{E}X&lt;\infty\)</span>。设长度为 <span class="math inline">\(t\)</span> 的时刻内需要报废的灯泡数最多为 <span class="math inline">\(N_t\)</span>，即 <span class="math inline">\(S_{N_t}\leq t &lt; S_{N_t+1}\)</span>。则 <span class="math display">\[\lim_{t\to\infty}\frac{N_t}{t}\to\frac{1}{\mathbb{E}X},\quad\mathrm{a.e.}\]</span> 实际上由定义有 <span class="math display">\[\frac{S_{N_t}}{N_t}\leq \frac{t}{N_t} &lt;\frac{S_{N_t+1}}{N_t}.\]</span> 如果我们能证明 <span class="math inline">\(t\to\infty\)</span> 时同样有 <span class="math inline">\(N_t\to\infty,\mathrm{a.e.}\)</span>，则利用强大数定理就有<span class="math inline">\(S_{N_t}/N_t\to\mathbb{E}X\)</span>，从而结论得证。</p><p>我们考虑 <span class="math inline">\(\Omega_1=\{\omega\in\Omega\midS_n(\omega)&lt;\infty,\ \forall n\geq1\}\)</span>。<span class="math inline">\(\Omega_1\)</span> 作为一列递减的测度均为 1的集合列的极限，测度显然也是 1。我们只要证明在 <span class="math inline">\(\Omega_1\)</span> 上有 <span class="math inline">\(S_{N_t}/N_t\to\mathbb{E}X\)</span> 成立。</p><p>首先 <span class="math inline">\(N_t\)</span> 随着 <span class="math inline">\(t\)</span> 递增是没有问题的，如果它对某个 <span class="math inline">\(\omega\)</span> 是有界的，则 <span class="math inline">\(N_t(\omega)\leq M\)</span> 对所有 <span class="math inline">\(t\)</span> 成立。即不管 <span class="math inline">\(t\)</span> 是多少都有 <span class="math inline">\(S_M\leq t &lt; S_{M+1}\)</span>，这只能要求 <span class="math inline">\(S_{M+1}(\omega)=\infty\)</span>，从而 <span class="math inline">\(\omega\)</span> 不属于 <span class="math inline">\(\Omega_1\)</span>。</p><p>一个有意思的引理：</p><blockquote><p><strong>引理</strong>：设 <span class="math inline">\(X\inL^1\)</span>，如果 <span class="math inline">\(\{X_n\}\)</span> 是一列<span class="math inline">\(\mathrm{i.i.d}\)</span> 且服从和 <span class="math inline">\(X\)</span> 同样的分布，则 <span class="math inline">\(\dfrac{X_n}{n}\to0,\mathrm{a.e.}\)</span>。</p></blockquote><p>老技巧，只要证明 <span class="math inline">\(\mathbb{P}(\{|X_n|\geqn\epsilon,\ \mathrm{i.o.}\})=0\)</span> 即可。根据 Borel-Cantelli引理，只要证明 <span class="math inline">\(\sum_{n=1}^\infty\mathbb{P}(|X_n|\geqn\epsilon)&lt;\infty\)</span> 即可，而这在 18.1 中已经证明过了。</p><h1 id="complex-integration-and-dynkins-theorem">24.1 ComplexIntegration and Dynkin’s Theorem</h1><p>无要点</p><h1 id="characteristic-function">24.2 Characteristic Function</h1><p>本讲介绍了随机变量的特征函数及其基本性质。整体内容比较基础。</p><h1 id="the-continuity-theorem">25.3 The Continuity Theorem</h1><p>本讲介绍了测度弱收敛的连续性定理。</p><blockquote><p><strong>定理</strong>：如果 <span class="math inline">\(\{\mu_n\}_{n=1}^\infty\)</span> 是一列 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>上的概率测度。假设极限 <span class="math inline">\(\varphi(t) =\lim\limits_{n\to\infty}\hat{\mu_n}\)</span> 存在，并且 <span class="math inline">\(\varphi(t)\)</span> 在 <span class="math inline">\(t=0\)</span> 处连续，则存在概率测度 <span class="math inline">\(\mu\)</span> 使得 <span class="math inline">\(\hat{\mu}=\varphi\)</span>，并且 <span class="math inline">\(\mu_n\rightarrow_{w}\mu\)</span>。</p></blockquote><blockquote><p><strong>引理</strong>：对两个概率测度 <span class="math inline">\(\mu,\nu\)</span> 有 <span class="math display">\[\int_{\mathbb{R}^d}\hat{\mu}(x)\vdx{x}=\int_{\mathbb{R}^d}\hat{\nu}(y)\udx{y}.\]</span></p></blockquote><p>直接 Fubini 即可。</p><blockquote><p><strong>引理</strong>： <span class="math display">\[\int_{\mathbb{R}^d}[1-\mathrm{Re}\,\hat{\mu}(x)]\vdx{x}=\int_{\mathbb{R}^d}[1-\mathrm{Re}\,\hat{\nu}(y)]\udx{x}.\]</span></p></blockquote><p>在前一个引理中两边取实部，然后被 1 减去即可。</p><blockquote><p><strong>推论</strong>：假设 <span class="math inline">\(\rho\)</span>是一个 <span class="math inline">\(\mathbb{R}^d\)</span>上的概率测度，其支集位于闭的单位球 <span class="math inline">\(\bar{B}_1\)</span> 内。设 <span class="math inline">\(M&gt;0\)</span> 使得 <span class="math inline">\(|\hat{\rho}(t)|\leq1/2\)</span> 对任何 <span class="math inline">\(|t|\geq M\)</span> 成立，则对任何 <span class="math inline">\((\mathbb{R}^d,\mathcal{B}(\mathbb{R}^d))\)</span>上的概率测度 <span class="math inline">\(\mu\)</span> 和正数 <span class="math inline">\(\alpha&gt;0\)</span> 有 <span class="math display">\[\mu\{x\in\mathbb{R}^d:\ |x|\geq\alpha\}\leq2\int_{\bar{B}_1}[1-\mathrm{Re}\,\hat{\mu}(\frac{M}{\alpha}x)]\rho(x)\,\mathrm{d}x.\]</span></p></blockquote><h1 id="orthogonal-projections">31.1 Orthogonal Projections</h1><p>无要点</p><h1 id="probability-kernels-part-1">33.1 Probability Kernels, Part1</h1><p>本讲引入了概率核的概念。</p><p>设 <span class="math inline">\((S_i,\mathcal{B}_i), i=1,2\)</span>是两个可测空间，一个概率核 <span class="math inline">\(Q(x,B):(S_1,\mathcal{B}_2)\to[0,1]\)</span> 是一个二元函数，满足：</p><ol type="1"><li>对任何 <span class="math inline">\(x\in S_1\)</span>，<span class="math inline">\(Q(x,\cdot):\mathcal{B}_2\to[0,1]\)</span> 是 <span class="math inline">\((S_2,\mathcal{B}_2)\)</span> 上的概率测度。</li><li>对任何 <span class="math inline">\(B\in\mathcal{B}_2\)</span>，<span class="math inline">\(Q(\cdot,B):S_1\to[0,1]\)</span> 是 <span class="math inline">\((S_1,\mathcal{B}_1)\)</span> 上的可测函数。</li></ol><blockquote><p><strong>引理</strong>：假设 <span class="math inline">\(f(x,y)\in(S_1\times S_2, \mathcal{B}_1\otimes\mathcal{B}_2)\)</span>是乘积空间上的可测函数，并且是有界的或者非负的，则积分 <span class="math display">\[x\to\int_{S_2}f(x,y)Q(x,\pd{y})\]</span> 是关于<span class="math inline">\(x\)</span> 的可测函数。</p></blockquote><p>此引理不难从简单函数 <span class="math inline">\(\mathbb{1}_{B_1\timesB_2}(x,y)=\mathbb{1}_{B_1}(x)\mathbb{1}_{B_2}(y)\)</span>出发，使用函数形式的 Dynkin 引理得到。</p><p>由此对任何 <span class="math inline">\((S_1,\mathcal{B}_1)\)</span>上的测度 <span class="math inline">\(\mu\)</span>，我们可以定义乘积空间<span class="math inline">\((S_1\times S_2,\mathcal{B}_1\otimes\mathcal{B}_2)\)</span> 上的乘积测度 <span class="math inline">\(\mu\otimes Q\)</span>，这个乘积测度是随 <span class="math inline">\(x\)</span> 变化而变化的： <span class="math display">\[\mu\otimesQ(E)=\int_{S_1}\mu(\pd{x})\int_{S_2}\mathbb{1}_{C}(x,y)Q(x,\pd{y}).\]</span>不过这真的是一个概率测度吗？你可以用积分的线性性质立刻看出它是有限可加的，并且利用积分项有界和控制收敛定理立刻看出它是可数可加的，所以确实是个概率测度。</p><p>有了概率核的乘积测度，我们自然要研究对这种测度的积分。由于这个测度本身就是通过对示性函数积分来定义的，所以其上的积分也具有类似的性质：</p><blockquote><p><strong>引理</strong>：假设 <span class="math inline">\(f(x,y)\)</span>是乘积空间的可测函数，并且是有界或者非负的，则 <span class="math display">\[\int_{S_1\times S_2}f\pd{(\mu\otimes Q)} =\int_{S_1}\mu(\pd{x})\int_{S_2}f(x,y)Q(x,\pd{y}).\]</span></p></blockquote><p>后面花了很大力气证明当 <span class="math inline">\(Q(x,\cdot)=\widetilde{Q}(x,\cdot)\)</span> 对几乎处处的 <span class="math inline">\(x\)</span> 成立时有 <span class="math inline">\(\mu\otimesQ=\mu\otimes\widetilde{Q}\)</span>。没仔细看。</p><h1 id="regular-conditional-distributions">33.2 Regular ConditionalDistributions</h1><p>本讲使用概率核给出了 <span class="math inline">\(\mathbb{E}[f(X,Y)\mid X=x]\)</span> 这种条件期望的严格定义。</p><blockquote><p><strong>定理</strong>：设 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\)</span>是一个概率空间，<span class="math inline">\((S_i,\mathcal{B}_i),\,i=1,2\)</span>是两个可测空间，<span class="math inline">\(X:(\Omega,\mathcal{F})\to(S_1,\mathcal{B}_1),\,Y:(\Omega,\mathcal{F})\to(S_2,\mathcal{B}_2)\)</span>是两个随机变量。于是 <span class="math inline">\((X,Y):(\Omega,\mathcal{F})\to(S_1\timesS_2,\,\mathcal{B}1\otimes\mathcal{B}_2)\)</span> 是随机向量。记 <span class="math inline">\(\mu_{X,Y}\)</span> 为此随机向量在 <span class="math inline">\((S_1\timesS_2,\,\mathcal{B}1\otimes\mathcal{B}_2)\)</span> 上 push forward给出的测度，<span class="math inline">\(\mu_X\)</span> 是 <span class="math inline">\(X\)</span> 在 <span class="math inline">\((S_1,\mathcal{B}_1)\)</span> 上 push forward给出的测度。如果存在概率核 <span class="math inline">\(Q(x,B)\)</span>使得 <span class="math display">\[\mu_{X,Y}=\mu_X\otimes Q.\]</span></p><p>则对任何 <span class="math inline">\(f\in L^1(S_1\timesS_2,\mathcal{B}1\otimes\mathcal{B}_2)\)</span> 有 <span class="math display">\[\mathbb{E}[f(X,Y)\mid X = x] =\int_{S_2}f(x,y)Q(x, \pd{y}).\]</span></p></blockquote><p>这里需要解释 <span class="math inline">\(\mathbb{E}[f(X,Y)\mid X =x]\)</span> 这个记号的含义。这里其实引用了条件期望 (后面才会讲到)的性质：<span class="math inline">\(\mathbb{E}[f(X,Y)\mid X]\)</span>是一个关于 <span class="math inline">\(\sigma(X)\)</span>可测的随机变量，从而由 Doob-Dynkin 表示定理，存在可测函数 <span class="math inline">\(g\)</span> 使得 <span class="math inline">\(\mathbb{E}[f(X,Y)\mid X] = g(X)\)</span>，所以<span class="math inline">\(\mathbb{E}[f(X,Y)\mid X = x] =g(x)\)</span>。这个定理说的就是 <span class="math display">\[\mathbb{E}[f(X,Y)\mid X = x] = g(x) =\int_{S_2}f(x,y)Q(x, \pd{y}).\]</span></p><p><strong>证明</strong>：怎么证明两个关于 <span class="math inline">\(\sigma(X)\)</span> 可测的函数 (几乎处处)相等呢？我们可以给它们同时乘以 <span class="math inline">\(h(x)\)</span>，这里 <span class="math inline">\(h(x)\)</span> 是任何一个关于 <span class="math inline">\(\sigma(X)\)</span> 可测的有界函数，然后证明它们对<span class="math inline">\(\mu_X\)</span>积分以后的值相等，则这两个可测函数必相等。</p><p><span class="math inline">\(g(x)h(x)\)</span> 这个函数对 <span class="math inline">\(\mu_X\)</span> 积分，根据积分变量替换定理，正是<span class="math inline">\(\mathbb{E}[g(X)h(X)]\)</span>。而根据 <span class="math inline">\(g(x)\)</span> 的定义和条件期望的性质， <span class="math display">\[\mathbb{E}[g(X)h(X)]=\mathbb{E}[\mathbb{E}[f(X,Y)|X]h(X)]= \mathbb{E}[\mathbb{E}[f(X,Y)h(X)|X]] = \mathbb{E}[f(X,Y)h(X)].\]</span> 注意右边的期望悄悄地变成了关于 <span class="math inline">\(\mu_X\otimes Q\)</span>的积分。这是因为上式最后的等号使用了条件期望的 telescoping 性质，而<span class="math inline">\(f(X,Y)g(X)\)</span> 是关于 <span class="math inline">\(\mathcal{B}_1\otimes\mathcal{B}_2\)</span>可测的函数。</p><p>另一方面，<span class="math inline">\(h(x)\int_{S_2}f(x,y)Q(x,\pd{y})\)</span>这个函数对 <span class="math inline">\(\mu_X\)</span> 积分，正是 <span class="math display">\[\int_{S_1}\mu(\pd{x})\int_{S_2}f(x,y)h(x)Q(x,\pd{y}).\]</span>所以 <span class="math display">\[\begin{align*}\mathbb{E}[f(X,Y)h(X)] &amp;= \int_{S_1\timesS_2}f(x,y)h(x)\mu_{X,Y}(\pd{x}\pd{y}) \\&amp;= \int_{S_1\times S_2}f(x,y)h(x)\mu_X\otimes Q \\&amp;= \int_{S_1}\mu_X \int_{S_2}f(x,y)h(x)Q(x,\pd{y}) \\&amp;= \int_{S_1}\mu_X h(x)\int_{S_2}f(x,y)Q(x,\pd{y}).\end{align*}\]</span> 正是所要证明的。</p><p>不过在上面的证明中我们都假定了所有的可积性的前提，我们实际上需要假定<span class="math inline">\(f(x,y)\)</span>有界才能确保推导成立。对一般的 <span class="math inline">\(f(x,y)\inL^1(S_1\times S_2,\mathcal{B}_1\otimes\mathcal{B}_2)\)</span>，我们需要用有界函数列 <span class="math inline">\(f_n\to f\)</span> 且此收敛是在 <span class="math inline">\(L^1(\mu_{X,Y})\)</span> 意义下的。由于条件期望是contraction，所以 <span class="math display">\[\mathbb{E}[f_n(X, Y)| X]\xrightarrow{L^1} \mathbb{E}[f(X,Y)|X].\]</span> 此外我们已经证明了<span class="math display">\[\mathbb{E}[f_n(X, Y)| X] =\left.\int_{S_2}f_n(x,y)Q(x,\pd{y})\right|_{x=X}.\]</span> 所以只要证明<span class="math display">\[\left.\int_{S_2}f_n(x,y)Q(x,\pd{y})\right|_{x=X}\xrightarrow{L^1}\left.\int_{S_2}f(x,y)Q(x,\pd{y})\right|_{x=X}.\]</span> 即可。这个<span class="math inline">\(L^1\)</span> 收敛的意思是对 <span class="math inline">\(\mu_X\)</span> 取积分，因此我们要估计 <span class="math display">\[\int_{S_1}\mu(\pd{x})\int_{S_2}|f_n(x,y)-f(x,y)|Q(x,\pd{y}).\]</span>这不正是 <span class="math inline">\(|fn-f|\)</span>对乘积测度的积分嘛，而我们已经知道了它是 <span class="math inline">\(L^1\)</span> 收敛的了。</p><p>所以如果我们能把一个联合分布分解为边际分布和一个概率核的乘积，则我们就得到了条件概率的一个表示。</p><blockquote><p><strong>问题</strong>：<span class="math inline">\(\mu_{X,Y}\)</span>总可以表示为 <span class="math inline">\(\mu_X\otimes Q\)</span>的形式吗？</p></blockquote><blockquote><p><strong>定理</strong>：如果概率核 <span class="math inline">\(Q(x,B)\)</span> 满足 <span class="math display">\[\mathbb{P}(Y\in B | X=x) =Q(x, B)\]</span> (这个条件等价于 <span class="math display">\[\mathbb{E}[h(Y) | X] = \left.\int h(y)Q(x,\pd{y})\right|_{x=X}.\]</span> 对任何有界的可测函数 <span class="math inline">\(h(y)\)</span> 成立) 则对 <span class="math inline">\(f(x,y)\)</span> 同样有 <span class="math display">\[\mathbb{E}[f(X,Y) | X] = \left.\int f(x,y)Q(x,\pd{y})\right|_{x=X}.\]</span> 成立。</p></blockquote><p>这个定理可以先从 <span class="math inline">\(f(x,y)=f(x)\otimesg(y)\)</span> 形式的函数出发，然后用 Dynkin 函数系引理得到。</p><p>总结一下，至此我们讨论了：</p><ol type="1"><li>如果 <span class="math inline">\(\mu_{X,Y}=\mu_X\otimesQ\)</span>，那我们就有了 <span class="math inline">\(\mathbb{E}[f(X,Y)|X]\)</span> 的计算方法：积分<span class="math inline">\(\int_{S_2}f(X,y)Q(X,\pd{y})\)</span>。特别地我们可以算条件概率了。</li><li>反之如果我们有一个概率核给出条件概率：<span class="math inline">\(\mathbb{P}(Y\in B | X=x) = Q(x,B)\)</span>，那么它就给出 <span class="math inline">\(\mu_{X,Y}\)</span>的一个分解：<span class="math inline">\(\mu_{X,Y}=\mu_X\otimesQ\)</span>。</li></ol><p>本讲后面讨论了离散和连续情形概率核是什么样子的。</p><h1 id="probability-kernels-part-2">34.1 Probability Kernels, Part2</h1><p>本讲介绍了概率核的本质是 Markov生成元，即可测函数空间上的非负线性泛函。</p><p>当有一个概率核 <span class="math inline">\(Q: S_1\times\mathcal{B}_2\to[0, 1]\)</span> 时， <span class="math display">\[f\to\int_{S_2}f(y)Q(x,\pd{y}),\quadf\in\mathbb{B}(S_2,\mathcal{B}_2)\]</span> 给出了从 <span class="math inline">\(L^\infty(S_2,\mathcal{B}_2)\)</span> 到 <span class="math inline">\(L^\infty(S_1,\mathcal{B}_1)\)</span> 的线性映射<span class="math inline">\(L_Q\)</span>，<span class="math inline">\(L_Q\)</span> 满足</p><ol type="1"><li><span class="math inline">\(L_Q(1)=1\)</span>。</li><li>若 <span class="math inline">\(f\geq 0\)</span> 非负可测，则 <span class="math inline">\(L_Q(f)\geq 0\)</span> 也非负可测。</li><li>若 <span class="math inline">\(f_n\uparrow f\)</span> 则 <span class="math inline">\(L_Q(f_n)\uparrow L_Q(f)\)</span>。</li><li><span class="math inline">\(\|L_Q(f)\|_{\infty} \leq\|f\|_{\infty}\)</span>。</li></ol><p>所以 <span class="math inline">\(L_Q\)</span>是一个连续的正线性泛函？</p><p>反过来，如果有这样的一个泛函 <span class="math inline">\(L\)</span>，<span class="math inline">\(L\)</span>是否给出一个概率核 <span class="math inline">\(Q\)</span> 呢？</p><p>答案是否定的，一般来说这不成立。但是在 <span class="math inline">\((S_1,\mathcal{B}_1)=(S_2,\mathcal{B}_2)\)</span>的情形，这确实是对的。</p><blockquote><p><strong>定理</strong>：如果 <span class="math inline">\(L:\mathbb{B}(S,\mathcal{B})\to\mathbb{B}(S,B)\)</span>满足以上四个条件，则 <span class="math display">\[Q(x, B) =L(\mathbb{1}_B)(x)\]</span> 给出一个概率核。并且 <span class="math inline">\(L_Q=L\)</span>，即此概率核给出的线性泛函正是 <span class="math inline">\(L\)</span>。</p></blockquote><p>证明：由于 <span class="math inline">\(0\leq \mathbb{1}_B\leq1\)</span> 总是成立的，所以 <span class="math inline">\(L(0)\leqL(\mathbb{1}_B)\leq L(1)=1\)</span>，即 <span class="math inline">\(L(\mathbb{1}_B)(x)\)</span> 对任何 <span class="math inline">\(x\)</span> 都在 <span class="math inline">\([0,1]\)</span> 中，这符合概率的定义约束。</p><p>固定 <span class="math inline">\(x\)</span>，我们需要证明 <span class="math inline">\(L(\mathbb{1}_B)(x) = \sum_{k=1}^\inftyL(\mathbb{1}_{B_k})(x)\)</span> 对可数不交并 <span class="math inline">\(B = \uplus_{k=1}^\infty B_k\)</span> 成立。记<span class="math inline">\(f_n=\sum_{k=1}^n B_k\)</span>，则 <span class="math inline">\(f_n\uparrow \mathbb{1}_B\)</span>，于是 <span class="math inline">\(L(f_n)\uparrow L(f)=L(\mathbb{1}_B)\)</span>，即<span class="math inline">\(\sum_{k=1}^\inftyL(\mathbb{1}_{B_k})\uparrow L(\mathbb{1}_B)\)</span>，成立！</p><p>要证明 <span class="math inline">\(L = L_Q\)</span>，即对任何 <span class="math inline">\(f\in\mathbb{B}(S,\mathcal{B})\)</span> 有 <span class="math display">\[L(f) = \int_S f(y)Q(x,\pd{y})\]</span>成立。这个很容易从示性函数出发取极限得到。</p><p>如果 <span class="math inline">\(Q_1,Q_2\)</span> 是两个 <span class="math inline">\((S,\mathcal{B})\)</span> 到自身的概率核，则 <span class="math inline">\(L_{Q_1}L_{Q_2}\)</span> 也满足性质1-4，因而也是由一个概率核给出：存在概率核 <span class="math inline">\(Q\)</span> 使得 <span class="math inline">\(L_Q =L_{Q_1}L_{Q_2}\)</span>。我们可以把 <span class="math inline">\(Q\)</span> 明确的写出来： <span class="math display">\[L_Q(f) =L_{Q_1}L_{Q_2}(f)=\int_{S}Q_1(x,\pd{y})\left(\int_Sf(z)Q_2(y,\pd{z})\right).\]</span>这看起来很像乘积测度，实际上我们后面会讨论 <span class="math display">\[Q_1(x,dy)Q_2(d, dz)= Q_1\otimes Q_2(x,dz)\]</span> 的具体含义。</p><h1 id="random-dynamics">34.2 Random Dynamics</h1><p>什么是随机动力系统：</p><p>有一个概率空间 <span class="math inline">\((\Omega,\mathcal{F},\mathbb{P})\)</span>，一个可测空间<span class="math inline">\((R,\mathcal{G})\)</span>，以及一些 i.i.d随机变量 <span class="math inline">\(\xi_n:(\Omega,\mathcal{F},\mathbb{P})\to(R,\mathcal{G})\)</span>。此外设 <span class="math inline">\((S,\mathbb{R})\)</span> 是一个可测空间。</p><p>如果 <span class="math inline">\(f\)</span> 是一个 <span class="math inline">\((S, R)\to S\)</span> 的可测函数映射满足</p><p><span class="math display">\[X_{n+1} = f(X_n, \xi_{n+1}) =F_n(X_0,\xi_1,\xi_2,\ldots,\xi_n),\quad F_n:S\times R^n\to S.\]</span>即 <span class="math inline">\(f(\cdot,\xi_n)\)</span> 是一个由随机序列<span class="math inline">\(\{\xi_n\}\)</span>驱动的映射，则我们就称这是一个随机动力系统。</p><p>注意 <span class="math inline">\(X_n\)</span> 由 <span class="math inline">\(\xi_1\sim\xi_n\)</span> 决定，所以 <span class="math inline">\(\mathcal{F}_n=\sigma(X_0,X_1,\ldots,X_n)=\sigma(X_0,\xi_1,\ldots,\xi_n)\)</span>。</p><p>记 <span class="math inline">\(Q_n(x,\cdot)=\mathrm{Law}f(x,\xi_n)\)</span>，则 <span class="math inline">\(Q_n\)</span>是一个概率核。设 <span class="math inline">\(L_n\)</span> 是其 Markov生成元。则</p><p><span class="math display">\[\begin{align*}\mathbb{E}[g(X_{n+1})|\mathcal{F}_n]&amp;= \mathbb{E}[g(f(X_n,\xi_{n+1}))|\mathcal{F}_n]\\&amp;=\left.\mathbb{E}[g\circ f(x,\xi_{n+1})]\right|_{x=X_n} \\&amp;=\left.\int g(y)Q_{n+1}(x,\pd{y})\right|_{x=X_n}\\&amp;=L_{n+1}(g)(X_n).\end{align*}\]</span> 但是 <span class="math inline">\(L_{n+1}(g)(X_n)\)</span> 是 <span class="math inline">\(X_n\)</span> 的函数，所以它关于 <span class="math inline">\(\sigma(X_n)\)</span>是可测的，而且是有界可测，从而两边对 <span class="math inline">\(\sigma(X_n)\)</span> 这个子 <span class="math inline">\(\sigma\)</span>- 域取条件期望，并注意到 <span class="math inline">\(\sigma(X_n)\subset\mathcal{F}_n\)</span> 有 <span class="math display">\[\mathbb{E}[g(X_{n+1})|\mathcal{F}_n] =\mathbb{E}[g(X_{n+1})|X_n].\]</span> 这正是 Markov 性质。</p><h1 id="stochastic-processes">35.1 Stochastic Processes</h1><p>本讲介绍了随机过程的定义，以及它们的有限维分布、滤过(filtration)、适应 (adapted) 等概念。</p><h1 id="the-markov-property">36.1 The Markov property</h1><p>我们称随机过程 <span class="math inline">\(X_t:(\Omega,\mathcal{F}_t)\to(S_,\mathcal{B})\)</span>Markov 性质，如果对任何有界可测函数 <span class="math inline">\(f\in\mathbb{B}(S,\mathcal{B})\)</span> 有</p><p><span class="math display">\[\mathbb{E}[f(X_t)|\mathcal{F}_s] =\mathbb{E}[f(X_t)|X_s],\quad \mathrm{a.e.},\ \forall s &lt;t.\]</span></p><p>Markov过程貌似是关于过去和当前的，但实际上它也告诉了我们关于未来的信息：</p><blockquote><p><strong>推论</strong>：<span class="math inline">\(\mathbb{E}[Y|\mathcal{F}_s] = E[Y|X_s],\quad\forall Y\in\mathbb{B}(\Omega, \mathcal{F}_{\geq s})\)</span>。</p></blockquote><p>这个推论的证明很有意思，要用到 Dynkin multiplicative system。</p><p>考虑形如 <span class="math inline">\(Y =g_0(X_{t_0})g_1(X_{t_1})\cdots g_n(X_{t_n})\)</span> 的函数，这里 <span class="math inline">\(s =t_0&lt;t_1&lt;\cdots &lt;t_n\)</span>，且每个<span class="math inline">\(g_i\)</span> 都是有界可测的，从而 <span class="math inline">\(Y\)</span> 也是有界可测的，并且 <span class="math inline">\(Y\in\mathcal{F}_{\geq s}\)</span>。</p><blockquote><p><strong>引理</strong>：设 <span class="math display">\[\mathcal{M} =\{g_0(X_{t_0})g_1(X_{t_1})\cdots g_n(X_{t_n}): n\in\mathbb{Z}_{\geq0},s=t_0&lt;t_1&lt;\cdots&lt;t_n,g_j\in\mathbb{B}(S,\mathcal{B})\},\]</span> 则 <span class="math inline">\(\mathcal{M}\)</span> 是乘法系，且 <span class="math inline">\(\sigma(M) = \mathcal{F}_{\geq s}\)</span>。</p></blockquote><p>回到推论的证明。</p><p>设 <span class="math inline">\(\mathcal{H}\)</span>是所有满足推论要求的函数构成的空间。我们只要证明 <span class="math inline">\(\mathcal{H} \supset\mathcal{M}\)</span>。这样由于<span class="math inline">\(\mathcal{H}\)</span> 是向量空间，包含常数1，在有界收敛下封闭，并且包含乘法系 <span class="math inline">\(\mathcal{M}\)</span>，从而根据 Dynkin函数系引理包含所有关于 <span class="math inline">\(\sigma(\mathcal{M})=\mathcal{F}_{\geq s}\)</span>可测的有界可测函数，这正是所要证明的。</p><p><span class="math display">\[\begin{align*}\mathbb{E}_{\mathcal{F}_s}[Y]&amp;=\mathbb{E}_{\mathcal{F}_s}[E_{\mathcal{F}_{t_{n-1}}}[Y]]\\&amp;=\mathbb{E}_{\mathcal{F}_s}[g_0(X_{t_0})\cdotsg_{n-1}(X_{t_{n-1}})h(X_{t_{n-1}})]\\&amp;=\mathbb{E}_{\mathcal{F}_s}[g_0(X_{t_0})\cdots\widetilde{g_{n-1}}(X_{t_{n-1}})]\\&amp;=\cdots\\&amp;=\mathbb{E}_{\mathcal{F}_s}[F(X_{s})]\\&amp;=F(X_s)\end{align*}\]</span> 再利用 <span class="math inline">\(\mathbb{E}_{X_s}[Y]=\mathbb{E}_{X_s}[\mathbb{E}_{\mathcal{F}_s}[Y]]=\mathbb{E}_{X_s}[F(X_s)]=F(X_s)\)</span>即得所证。</p><p>上面是 Markov性质的第一种刻画：将对未来可测的函数对当前和过去取条件期望，相当于只对当前取条件期望。</p><p>本讲接下来用条件独立给出了 Markov 性质的第二种刻画：</p><blockquote><p><strong>定理</strong>：随机过程 <span class="math inline">\(\{X_t\}\)</span> 满足 Markov 性质当且仅当 <span class="math inline">\(\mathcal{F}_s\)</span> 和 <span class="math inline">\(\mathcal{F}_{\geq s}\)</span> 关于 <span class="math inline">\(\sigma(X_s)\)</span>是条件独立的，即对任何有界可测函数 <span class="math inline">\(Z\in\mathbb{B}(\Omega,\mathcal{F}_s)\)</span>，<span class="math inline">\(Y\in\mathbb{B}(\Omega,\mathcal{F}_{\geqs})\)</span> 有 <span class="math display">\[\mathbb{E}[ZY|X_s] =\mathbb{E}[Z|X_s]\cdot \mathbb{E}[Y|X_s].\]</span></p></blockquote><p>注意到 <span class="math inline">\(\mathcal{F}_s=\sigma(X_t: t\leqs)\)</span> 以及 <span class="math inline">\(\mathcal{F}_{\geqs}=\sigma(X_T:t\geq s)\)</span>，所以这个结论可以概括为：对 Markov过程，给定当下，过去与未来独立。</p><p>这个结论的证明主要使用了 Tower 性质，不算困难。</p><h1 id="probability-kernels-revisited">36.2 Probability KernelsRevisited</h1><p>回顾了之前概率核的概念。没啥新的。</p><h1 id="kolmogorovs-extended-extension-theorem">37.2 Kolmogorov’s(Extended) Extension Theorem</h1><p>本讲介绍了连续情形的 Kolmogrov扩张定理：可以构造一般的有限维分布，只要它们满足相容性条件。</p><h1 id="walds-identity">46.3 Wald’s Identity</h1><p>本讲介绍了 Wald 引理。</p><blockquote><p><strong>Wald 引理</strong>：设 <span class="math inline">\(\{X_n\}\)</span> 是 <span class="math inline">\(\mathrm{i.i.d}\)</span> 的随机变量序列，<span class="math inline">\(\tau\)</span> 是一个停时，则在 <span class="math inline">\(\mathbb{E}|X_1|&lt;\infty\)</span> 且 <span class="math inline">\(\mathbb{E}\tau&lt;\infty\)</span> 的条件下有 <span class="math inline">\(\mathbb{E}\sum\limits_{n=1}^\tauX_n=\mathbb{E}X_1\cdot \mathbb{E}\tau\)</span>。</p></blockquote><p>这里的关键在于将上面的求和变成一个二重级数求和，然后交换求和次序。</p><p><span class="math display">\[\begin{align*}\sum_{n=1}^\tau\mathbb{E}X_n&amp;=\sum_{n=1}^\infty\mathbb{E}X_n\cdot\mathbb{1}_{\tau\geqn}=\sum_{n=1}^\infty\mathbb{E}X_n\cdot\sum_{k=n}^\infty\mathbb{1}_{\tau=k}\\&amp;=\sum_{k=1}^\infty\mathbb{1}_{\tau=k}\sum_{n=1}^k\mathbb{E}X_n\\&amp;=\mathbb{E}X_1\sum_{k=1}^\inftyk\cdot\mathbb{1}_{\tau=k}\\&amp;=\mathbb{E}X_1\cdot\mathbb{E}\tau.\end{align*}\]</span></p><p>我们为什么可以在第一行的第二个等号处交换求和次序？这是因为上面的推导对<span class="math inline">\(|X_n|\)</span> 是成立的，并且离散积分值<span class="math inline">\(\mathbb{E}|X_1|\cdot\mathbb{E}\tau&lt;\infty\)</span>，所以由控制收敛定理对原序列<span class="math inline">\(X_n\)</span> 交换求和也是 OK 的。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Todd Kemp 概率论课程笔记</title>
      <link href="todd-kemp/new.html"/>
      <url>todd-kemp/new.html</url>
      
        <content type="html"><![CDATA[<h1 id="optional-stopping-and-sampling">49.1 Optional Stopping andSampling</h1><p>这一节介绍了停时，以及停时鞅序列 <span class="math inline">\(\{X_{n\wedge \tau}\}\)</span> 的性质。</p><p>一个简单的股票市场模型：设 <span class="math inline">\(\{X_n\}_{n=0}^\infty\)</span> 是股票价格，<span class="math inline">\(\{U_n\}_{n=1}^\infty\)</span>是你的投资策略，即在时刻 <span class="math inline">\(n-1\)</span> 买入<span class="math inline">\(U_n\)</span> 并在时刻 <span class="math inline">\(n\)</span> 抛出。或者说，<span class="math inline">\(U_n\)</span> 是你在 <span class="math inline">\((n-1,n]\)</span>这个时间区间内的股票交易数量，那么到时刻 <span class="math inline">\(n\)</span> 时，你的净收益为 <span class="math display">\[I_n(U,X) = \sum_{j=1}^nU_j(X_j-X_{j-1}).\]</span> 这里 <span class="math inline">\(U_n\)</span>必须是关于 <span class="math inline">\(\mathcal{F}_{n-1}=\sigma(X_0,X_1,\ldots,X_{n-1})\)</span>可测。</p><p>第一个重要观察是：</p><div id="martingale-discrete-integration" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.1</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\{X_n\}\)</span> 是鞅/下鞅/上鞅，并且 <span class="math inline">\(U_n\geq0\)</span>，则 <span class="math inline">\(I_n(U,X)\)</span> 也是鞅/下鞅/上鞅。</p></div><p>证明：对下面的恒等式两边关于 <span class="math inline">\(\mathcal{F}_n\)</span> 取条件期望即可。 <span class="math display">\[I_{n+1}(U,X) =\underbrace{I_{n}(U,X)}_{\in\mathcal{F}_n} +\underbrace{U_{n+1}}_{\in\mathcal{F}_n}\underbrace{(X_{n+1}-X_{n})}_{\rm(sub/sup)martingale}.\]</span></p><p>我们可以设定两个随机时间，比如 <span class="math inline">\(\sigma\)</span> 是股票首次低于 1 美元的时刻,这时立刻买入；<span class="math inline">\(\tau\)</span> 是股票首次高于10 美元的时刻，这时立刻抛出；在区间 <span class="math inline">\((\sigma,\tau]\)</span> 中保持持有股票，即 <span class="math inline">\(U_j=\mathbb{1}_{\sigma&lt;j\leq\tau}\)</span>。于是 <span class="math inline">\(U_j\mathbb{1}_{n\geqj}=\mathbb{1}_{(\sigma\wedge n, \tau\wedge n]}(j)\)</span>。</p><p>那么净收益 <span class="math display">\[I_n(U,X) = \sum_{j=1}^n\mathbb{1}_{\sigma\wedge n&lt;j\leq \tau\wedge n}(X_j-X_{j-1})=X_{\tau\wedge n} - X_{\sigma\wedge n}.\]</span></p><p>特别地，取 <span class="math inline">\(\sigma=0\)</span>，则 <span class="math inline">\(U_j=\mathbb{1}_{j\leq\tau}\)</span>，则我们有如下结论：</p><div id="stopping-time-also-martingale" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\{X_n\}\)</span> 是鞅，那么 <span class="math inline">\(\{X_{n\wedge \tau}\}\)</span> 也是鞅。</p></div><p>证明：首先每一项 <span class="math inline">\(X_{n\wedge\tau}\)</span> 可以看成是一个关于 <span class="math inline">\(X_1,\ldots,X_n\)</span> 的部分和：</p><p><span class="math display">\[X_{n\wedge \tau} =\sum_{k=0}^n\mathbb{1}_{\tau=k}X_k.\]</span></p><p>显然 <span class="math inline">\(X_{n\wedge \tau}\)</span>是可积的。</p><p>另一方面在 <a href="#martingale-discrete-integration" title="定理 1.1">定理 1.1</a> 中取 <span class="math inline">\(U_n=\mathbb{1}_{n\leq\tau}\)</span>，则 <span class="math inline">\(X_{n\wedge \tau} - X_0 = I_n(U,X)\)</span>仍然是鞅，那么加上一个 <span class="math inline">\(X_0\)</span> 得到的<span class="math inline">\(X_{n\wedge\tau}\)</span> 当然还是鞅。</p><h1 id="holders-inequality">49.2 Holder’s Inequality</h1><p>无特别内容</p><h1 id="submartingale-maximal-inequalities-未完成">49.3 (Sub)martingaleMaximal Inequalities （未完成）</h1><p>开篇第一句话就是，鞅在一个有限区间上的极大值，可以以多种方式被它在区间终点的值所控制。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>TODO List</title>
      <link href="todo/index.html"/>
      <url>todo/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="写作">写作</h1><ul><li>关于 SO3 的表示的文章，与球谐函数、有限群的不变量、Shephard-Todd定理的关系。配一个 shadertoy demo。</li><li>S_n 和 GL(n) 的表示论，Schur-Weyl 对偶。</li><li>六顶点模型，Yang-Baxter 方程和 ASM 的证明。</li><li>对称平面分拆的 Macdonald 猜想，Hall 多项式，SL(n)表示在计数中的应用。</li><li>永不回到原点的二维随机游动，介绍 Doob h-变换、调和测度。</li><li>扭结与动力系统</li><li>Lie 代数的 Minuscule 表示与对称平面分拆</li><li>GTM A course in enumeration 中剩余的 highlight 问题。</li><li>二维码与 Reed-Solomon 编码算法介绍</li><li>图的环空间与割空间，顶点膨胀技巧</li><li>Hilbert 曲线算法与 Golay 码</li><li>Aztec diamond arctic circle 现象的解释</li><li>Random walk, circle packing and conformal mapping.</li><li>Billiard ball，测度论，Poncelet 定理</li><li>Durrett 概率论 Brownian 运动部分改写</li><li>Indra’s pearls 部分内容介绍，附 shadertoy 动画</li><li>Raymarching 中 sdf 函数与各种变换的数学证明</li><li>正的 Hausdoff 维数意味常返性http://www.cmat.edu.uy/~lessa/resource/randomwalknotes.pdf</li><li>准晶，Faraday 驻波。</li><li>连分数，圆堆，Fary。</li><li>Fulton algebraic curves, Poncelet porism 的代数几何证明和 Jacobi椭圆函数证明</li><li>G2 and the rolling ball 是啥回事。</li><li>Mobius gear 和 Quaternion 是啥关系，flockaroo 的 shadertoy</li><li>蜂巢和 Gauss整数的关系：https://twitter.com/roice713/status/1497252225785204738?s=20&amp;t=WN0vB5s3eU_riCbC37nWiA</li><li>stable diffusion 学习</li><li>互锁的折纸 origami 正十二面体 | Interlock 多面体</li><li>hyperbolic billiards and modular group</li><li>局部中心极限定理 | 电流与同调 | 改写随机游动</li><li>手臂旋转翻面、旋转到底能不能给出反射？</li><li>quaternions and polytopes</li><li>测度扩张</li><li>概率论常用结论？单调类、Dynkin…</li></ul><h1 id="编程">编程</h1><ul><li>Python + cairo 实现 hyperbolic tiling 矢量绘图库。</li><li>shadertoy 实现 sphere gears，并解释与 SO3 的表示的关系</li><li>shaderoty 演示相对论</li><li>shadertoy 演示 Schottky 变换和 Droste 效应</li><li>shadertoy 实现自动微分和 implicit surface 渲染</li><li>surface evovler C++ 改写</li><li>用这个 https://www.shadertoy.com/view/NlKXWt 写一个 doyle spiral的例子</li><li>shadertoy 版本的 Jigsaw Penrose tiling</li><li>Python 实现 Voronoi + LLoyd 算法，理解 mapbox 的那个实现原理</li><li>Stange + sl2c 的 shader 研究实现</li><li>missing mirror，用正方体万花筒内部反射实现 pseudo kleinian</li><li>把 gifmaze 中 hilbert 曲线的例子改成对输入图像生成 hilbert曲线图</li><li>二维随机游动常返，如双曲、Penrose 等的判断。</li><li>继续可视化项目系列，可视化复分析 + indra’s pearls，可视化 circlepackings，可视化双曲空间 (Hee Oh)。</li><li>把 creative blocks 改改，渲染 mobius 变换</li><li>Shadertoy 实现双曲 dodecaheron space</li><li>Shadertoy 实现 hyperbolic weave</li><li>相对论 + 机器猫</li><li>Faraday 驻波模拟</li><li>Thurston 的圆堆算法</li><li>Shadertoy 实现 3D 准晶</li><li>Conway’s Topograph</li><li>delaunator</li><li>magicavoxel and magicaCSG</li><li>matsuba</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Coxeter groups, automata and uniform tilings</title>
      <link href="uniform-tilings/index.html"/>
      <url>uniform-tilings/index.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>Since using POV-Ray to render 3D hyperbolic honeycombs was incrediblyslow, I’ve decided to abandon this approach and have removed the codefrom the main branch on GitHub. You can find the code used in thisarticle in the <a href="https://github.com/neozhaoliang/pywonderland/releases/tag/0.1.0">oldrelease version</a>. For how to render hyperbolic honeycombs, readerscan refer to <a href="https://github.com/neozhaoliang/Hyperbolic-Honeycombs/">anotherproject</a>.</p></blockquote><p>This article introduces a <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/uniform-tilings">Pythonprogram</a> I just finished. Although it’s freshly completed, it took upmost of my free time over the last six months. It was quite thechallenge, requiring a lot of effort and dedication. The main reason isthat it involves a few complicated theories, specifically the deepproperties of Coxeter groups, known as the automatic property. Asignificant portion of these months was spent learning from articles byCasselman, Brink &amp; Howlett, and others, which helped me understandthe mathematicas of this project (see references at the end).</p><p>Although finishing this program is a great achievement for me, Idon’t mean to boast about any superiority of this program: thecomputational method it uses for Coxeter groups is not advanced andmight not impress the experts. Moreover, its code is somewhat ugly, andlikely difficult for other people to use.</p><p>The purpose of this program is to use group theory to draw varioustwo-dimensional and three-dimensional <a href="https://en.wikipedia.org/wiki/Uniform_tiling">uniform tilings</a>.You can think of uniform tiling as using some regular polygons to tilethe space so that the vertices of the tiles are transitive under theaction of a symmetry group (forming a single orbit).</p><p>I will first show some examples of what this program can do, and thenexplain how it works.</p><h1 id="examples">Examples</h1><ul><li><p>Below is the 2d Euclidean tiling omnitruncated (4, 2, 4):</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-4-2-4.png" width="600"></p></li><li><p>Below is the 2d hyperbolic tiling regular (2, 3, 13) inPoincaré’s disk model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/2-3-13.png" width="600"></p></li><li><p>Below is the 2d hyperbolic tiling omnitruncated (4, 3, 3) inupper half plane model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/uhp-4-3-3.png" width="600"></p></li><li><p>A hyperbolic weave pattern:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/weave_pattern.png" width="500"></p></li><li><p>Below is the 3d hyperbolic tiling regular (3, 5, 3) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/3-5-3.png" width="600"></p></li><li><p>Below is the 3d hyperbolic tiling regular (5, 3, 5) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/5-3-5.png" width="600"></p></li><li><p>Below is the 3d hyperbolic tiling regular (5, 3, 4) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/5-3-4.png" width="600"></p></li><li><p>Below is the 3d hyperbolic tiling regular (4, 3, 5) in Poincaré’sball model:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/4-3-5.png" width="600"></p></li><li><p>The above four regular tilings are the only regular ones withcompact cells. If we drop the restriction on compactness and requiresthe cells must have finite volume, then we have ten more regulartilings, with each has a Euclidean vertex configure. For example (6, 3,3)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/6-3-3.png" width="600"></p><p>You can see the cells have ideal vertices, i.e.&nbsp;vertices at theinfinity. These tilings are called “paracompact”.</p></li><li><p>If we drop the restriction on being “regular” then we have lotsmore examples, like rectified (3, 5, 3) and rectified (5, 3, 4)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/rectified-3-5-3.png" width="600"></p><p><img style="margin:0px auto;display:block" src="/images/coxeter/rectified-5-3-4.png" width="600"></p><p>and the <a href="https://en.wikipedia.org/wiki/Uniform_honeycombs_in_hyperbolic_space#%5B5,31,1%5D_family">canticorder-5 cubic</a> tiling from the [5, 3<sup>1,1</sup>] family:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/cantic-order-5-cubic.png" width="600"></p></li><li><p>Below is a 2d spherical tiling rendered in 3d:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-5-2-3.png" width="600"></p></li><li><p>Finally a shader program exported from Matt Zucker’s excellentwork on <a href="https://www.shadertoy.com/view/3tsSzM">shadertoy</a>:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/wythoff_shader.png" width="600"></p></li></ul><h1 id="wythoff-construction">Wythoff construction</h1><p>The main theoretical tool for drawing uniform tilings is theso-called <a href="https://en.wikipedia.org/wiki/Wythoff_construction">Wythoffconstruction</a>, also known as the kaleidoscope method. This involvesplacing several reflecting planes (mirrors) in space, then starting froman initial point, and repeatedly applying reflection transformationsabout these mirrors to obtain all the virtual images, which gives allthe vertices of the tiling.</p><p>The following video demonstrates the effect of the Wythoffconstruction: in the 2D Poincaré hyperbolic disk, the walls around theroom are all mirrors. The scene in the room is repeatedly reflected inthe mirrors, creating infinitely many virtual image rooms, filling theentire hyperbolic space. Note that, there is only one ‘real’ room,namely the room where the observer is standing in; all other rooms arevirtual images of the real one.</p><video src="/images/hyperbolic-honeycombs/lego-hyperbolic-kaleido.mp4" width="600" controls=""></video><p>There are two different approaches to implemente the Wythoffconstruction in a program:</p><ol type="1"><li><p>Inverse Pixel Method. This method involves calculating, for eachpixel in the image, its corresponding point <span class="math inline">\(p\)</span> in the world space. Then, <span class="math inline">\(p\)</span> is repeatedly reflected off mirrorsuntil it falls within the fundamental region, say the final location is<span class="math inline">\(q\)</span>. Essentially, we find thepre-image <span class="math inline">\(q\)</span> of <span class="math inline">\(p\)</span> in the real room (called thefundamental domain). Then, based on <span class="math inline">\(q\)</span>’s position within the fundamentaldomain, the pixel corresponding to <span class="math inline">\(p\)</span> is colored. This method allows forparallel computation on all pixels, and when combined with shaderprogramming, it can produce very stunning effects. Here are two examplesfrom shadertoy:</p><p><iframe width="480" height="270" frameborder="0" src="https://www.shadertoy.com/embed/mlGfzV?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe></p><p><iframe width="480" height="270" frameborder="0" src="https://www.shadertoy.com/embed/Nd3cR2?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe></p><p>The inverse pixel method cares solely about the final pixel color. Itdoesn’t care about the actual coordinates. It produces raster images andcannot output vector graphics. Moreover, exporting data for use inmodeling software is not very convenient with this method.</p></li><li><p>Coordinate Method. This approach starts from a given initialpoint <span class="math inline">\(v_0\)</span> and calculates all itsvirtual images (within some maximum number of vertices) as well as theconnections between edges and faces, then draws them one by one. Thismethod allows for the acquisition of specific vertex coordinateinformation and outputs vector graphics and model files, making it moresuitable for usage in academic papers. However, it cannot beparallelized and is quite slow in computing hyperbolic tilings, as thestructures grows exponentially.</p></li></ol><p>My program uses the coordinate method. It first performs symboliccalculations within the symmetry group of the tiling to determine theword representation corresponding to each vertex in the shortestlexicographical order (a word is a tuple where each element is aninteger), as well as the connections between edges and faces (alsotuples of integers), and then applies the word corresponding to eachvertex to the initial vertex to obtain the floating-point coordinates ofthat vertex. In other words, before computing the final coordinates ofeach vertex, it has already pre-calculated how many vertices there are,how each vertex is obtained through reflections from the initial vertex,which vertices form edges, which form faces, which form cells, etc.These calculations involve only integer operations, completely avoidingissues with floating-point precision loss.</p><p>Sounds amazing? Let me demonstrate the specific steps with anexample.</p><h1 id="example-omnitruncated-7-2-3-tiling">Example: omnitruncated (7,2, 3) tiling</h1><p>The Coxeter-Dynkin diagram for the omnitruncated (7, 2, 3) tilingis:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/coxeter723.svg" width="250"></p><p>This is a hyperbolic tiling, its symmetry group <span class="math inline">\(G\)</span> is the Coxeter group determined byCoxeter matrix</p><p><span class="math display">\[M=\begin{pmatrix} 1 &amp; 7 &amp; 2 \\ 7&amp;1 &amp;3\\ 2 &amp; 3 &amp;1\end{pmatrix}\]</span></p><p>and has presentation</p><p><span class="math display">\[W = \langle s_0,s_1, s_2\ |\s_0^2=s_1^2=s_2^2=(s_0s_1)^7=(s_1s_2)^3=(s_0s_2)^2=1\rangle.\]</span></p><p>The initial vertex <span class="math inline">\(v_0\)</span> is not onany of the three mirrors, so its stabilizing subgroup is <span class="math inline">\(\langle 1\rangle\)</span>, by <a href="https://en.wikipedia.org/wiki/Group_action_(mathematics)#Orbit-stabilizer_theorem">orbit-stabilizertheorem</a> each element <span class="math inline">\(w\)</span> of <span class="math inline">\(W\)</span> maps <span class="math inline">\(v_0\)</span> to a distinct vertex in thetiling.</p><p>Every element <span class="math inline">\(w\)</span> in <span class="math inline">\(W\)</span> can be expressed as a product of thegenerators <span class="math inline">\(s_0,s_1,s_2\)</span>. We call anysuch expression a word representation of <span class="math inline">\(w\)</span>. If <span class="math inline">\(w=s_{i_1}s_{i_2}\cdots s_{i_k}\)</span> is a wordexpression, and there are no other expressions of <span class="math inline">\(w\)</span> with length less than <span class="math inline">\(k\)</span>, we call <span class="math inline">\(s_{i_1}s_{i_2}\cdots s_{i_k}\)</span> a reducedexpression, and define <span class="math inline">\(l(w)=k\)</span> to bethe length of <span class="math inline">\(w\)</span>. The reducedexpression of <span class="math inline">\(w\)</span> is generally notunique. For example, from the defining relations of <span class="math inline">\(W\)</span>, we can see that <span class="math inline">\(s_0s_2=s_2s_0\)</span> and <span class="math inline">\(s_1s_2s_1=s_2s_1s_2\)</span>, etc. However, allreduced expressions of <span class="math inline">\(w\)</span> must havethe same length, so the definition of <span class="math inline">\(l(w)\)</span> is reasonable.</p><p>We can choose a smallest one among all reduced expressions <span class="math inline">\(w\)</span> as the normal form of <span class="math inline">\(w\)</span>. This sorting is called shortlex order.As the name implies, shortlex order is the order used by dictionaries toarrange words.</p><p>First, define the alphabetical order of the generators <span class="math inline">\(s_0,s_1,s_2\)</span> as <span class="math inline">\(s_0&lt;s_1&lt;s_2\)</span>​, then extend this orderto any two reduced expression <span class="math inline">\(w_1\)</span>and <span class="math inline">\(w_2\)</span>:</p><blockquote><p><strong>Shortlex Order</strong>: Let <span class="math inline">\(w_1= s_{i_1}s_{i_2}\ldots s_{i_n}\)</span> and <span class="math inline">\(w_2=s_{j_1}s_{j_2}\cdots s_{j_m}\)</span> be twodifferent reduced expressions, where <span class="math inline">\(w_1,w_2\)</span> can be different group elements. The relationship betweenthem in shortlex order is determined as follows:</p><ol type="1"><li>First, compare the lengths. If the lengths are different, the onewith the shorter length is considered smaller, that is, if <span class="math inline">\(n &lt; m\)</span> then <span class="math inline">\(w_1 &lt; w_2\)</span>, conversely if <span class="math inline">\(n &gt; m\)</span> then <span class="math inline">\(w_1 &gt; w_2\)</span>.</li><li>If the lengths are the same, then compare the alphabetical orderfrom left to right. Let <span class="math inline">\(k\)</span> be thefirst index such that for any <span class="math inline">\(l &lt;k\)</span>, <span class="math inline">\(s_{i_l} = s_{j_l}\)</span> but<span class="math inline">\(s_{i_k} \ne s_{j_k}\)</span>, then therelationship between <span class="math inline">\(w_1, w_2\)</span> isthe same as the relationship between <span class="math inline">\(s_{i_k}\)</span> and <span class="math inline">\(s_{j_k}\)</span>.</li></ol></blockquote><p>Thus, every <span class="math inline">\(w\in W\)</span> has a uniquenormal form under shortlex order.</p><p>Define <span class="math inline">\(\mathcal{SL}(W)\)</span> as theset consisting of the normal forms of all elements in <span class="math inline">\(W\)</span>. Below is a list of all elements in<span class="math inline">\(\mathcal{SL}(W)\)</span> with lengths up to5, totaling 37: (arranged in rows from smallest to largest)</p><p><span class="math display">\[\begin{array}{lllll}e&amp;s_{0}&amp;s_{1}&amp;s_{2}&amp;s_{0}s_{1}\\s_{0}s_{2}&amp;s_{1}s_{0}&amp;s_{1}s_{2}&amp;s_{2}s_{1}&amp;s_{0}s_{1}s_{0}\\s_{0}s_{1}s_{2}&amp;s_{0}s_{2}s_{1}&amp;s_{1}s_{0}s_{1}&amp;s_{1}s_{0}s_{2}&amp;s_{1}s_{2}s_{1}\\s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{1}&amp;s_{0}s_{1}s_{0}s_{2}&amp;s_{0}s_{1}s_{2}s_{1}&amp;s_{0}s_{2}s_{1}s_{0}\\s_{1}s_{0}s_{1}s_{0}&amp;s_{1}s_{0}s_{1}s_{2}&amp;s_{1}s_{0}s_{2}s_{1}&amp;s_{1}s_{2}s_{1}s_{0}&amp;s_{2}s_{1}s_{0}s_{1}\\s_{0}s_{1}s_{0}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{1}s_{2}&amp;s_{0}s_{1}s_{0}s_{2}s_{1}&amp;s_{0}s_{1}s_{2}s_{1}s_{0}&amp;s_{0}s_{2}s_{1}s_{0}s_{1}\\s_{1}s_{0}s_{1}s_{0}s_{1}&amp;s_{1}s_{0}s_{1}s_{0}s_{2}&amp;s_{1}s_{0}s_{1}s_{2}s_{1}&amp;s_{1}s_{0}s_{2}s_{1}s_{0}&amp;s_{1}s_{2}s_{1}s_{0}s_{1}\\s_{2}s_{1}s_{0}s_{1}s_{0}&amp;s_{2}s_{1}s_{0}s_{1}s_{2}&amp;\end{array}\]</span></p><p>Note the number of all words in <span class="math inline">\(s_0,s_1,s_2\)</span> with length less or equalthan five is <span class="math inline">\(1+3+\cdots+3^5=364\)</span>,the list above tells us that they indeed contain only 37 different ones,the remaining 364 - 37 = 327 ones are duplicates. A further computationshows that the number of all words with length no more than six is 1093but they contain only 53 different elements. So we can gain a greatimprovement in efficiency if we only use words in <span class="math inline">\(\mathcal{SL}(W)\)</span> instead of traversing allpossible combinations of the generators.</p><p>How can we generate those words that are precisely in <span class="math inline">\(\mathcal{SL}(W)\)</span>? This leads us to a veryimportant theorem on Coxeter groups:</p><blockquote><p><strong>Theorem [Brigitte Brink &amp; Robert B. Howlett,1993]</strong>: If <span class="math inline">\(G\)</span> is a finitelygenerated Coxeter group then <span class="math inline">\(\mathcal{SL}(W)\)</span> is a regularlanguage.</p></blockquote><p>The term “regular language” comes from computer science, a basic factabout a regular language over a finite alphabetical set is that thislanguage can always be recognized by a definite finite automaton (DFA),such DFA may not be unique but there is a “minimal one” with the leastnumber of states and this minimal one is unique if we don’t distinctrelabellings of the states.</p><p>Below is the automaton recognizes <span class="math inline">\(\mathcal{SL}(W)\)</span> for the (7, 2, 3)group:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/dfa_723.svg" width="600"></p><p>You can see there are 19 nodes (i.e.&nbsp;states) in the automaton. Thelabels of the states are irrevalent because renumbering the states of anautomaton does not change the language it recognizes.</p><p>The red node is the initial state.</p><p>The directed edges in the graph tell us the transition rule betweenthe states. The edges are labelled by the generators of the group,i.e.&nbsp;<span class="math inline">\(i\)</span> for <span class="math inline">\(s_i\)</span>. If we start from the initial stateand keep on moving to a next state along an edge up to a finite numberof steps, then the path we travelled gives a word in <span class="math inline">\(\mathcal{SL}(W)\)</span>. All words in <span class="math inline">\(\mathcal{SL}(W)\)</span> can be generated in thisway.</p><p>For example:</p><ol type="1"><li>The only path of length 0 correspondes to the identidy 1.</li><li>The three paths of length 1 <span class="math display">\[\begin{align*}0&amp;\xrightarrow{\ s_0\ }1,\\0&amp;\xrightarrow{\ s_1\ }2,\\0&amp;\xrightarrow{\ s_2\ }8.\end{align*}\]</span> corresponde to the three generators <span class="math inline">\(s_0,s_1,s_2\)</span> in <span class="math inline">\(\mathcal{SL}(W)\)</span>.</li><li>The five paths <span class="math display">\[\begin{align*}0&amp;\xrightarrow{\ s_0\}1\xrightarrow{\ s_1\ }2\\0&amp;\xrightarrow{\ s_0\ }1\xrightarrow{\ s_2\ }8\\0&amp;\xrightarrow{\ s_1\ }2\xrightarrow{\ s_0\ }3\\0&amp;\xrightarrow{\ s_1\ }2\xrightarrow{\ s_2\ }8\\0&amp;\xrightarrow{\ s_2\ }8\xrightarrow{\ s_1\ }9\end{align*}\]</span> corresponde to the five elements of length 2 in <span class="math inline">\(\mathcal{SL}(W)\)</span>: <span class="math inline">\(s_0s_1,s_0s_2,s_1s_0,s_1s_2,s_2s_1\)</span>.</li></ol><p>Using breadth-first search we can easily generate all words in <span class="math inline">\(\mathcal{SL}(W)\)</span> up to any givendepth.</p><p>Note for an infinite Coxeter group the automaton must have cycles,but for a finite Coxeter group the automaton must be a directed tree,for example the symmetry group <span class="math inline">\(S_4\)</span>of tetrahedron:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/tetrahedron.svg" width="600"></p><p>The 24 different paths corresponde to the 24 group elements of <span class="math inline">\(S_4\)</span>:</p><p><span class="math display">\[\begin{array}{llll}e&amp;s_{0}&amp;s_{1}&amp;s_{2}\\s_{0}s_{1}&amp;s_{0}s_{2}&amp;s_{1}s_{0}&amp;s_{1}s_{2}\\s_{2}s_{1}&amp;s_{0}s_{1}s_{0}&amp;s_{0}s_{1}s_{2}&amp;s_{0}s_{2}s_{1}\\s_{1}s_{0}s_{2}&amp;s_{1}s_{2}s_{1}&amp;s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{2}\\s_{0}s_{1}s_{2}s_{1}&amp;s_{0}s_{2}s_{1}s_{0}&amp;s_{1}s_{0}s_{2}s_{1}&amp;s_{1}s_{2}s_{1}s_{0}\\s_{0}s_{1}s_{0}s_{2}s_{1}&amp;s_{0}s_{1}s_{2}s_{1}s_{0}&amp;s_{1}s_{0}s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{2}s_{1}s_{0}\end{array}\]</span></p><p>Now the big question:</p><blockquote><p><strong>Question 1</strong>: How to compute <span class="math inline">\(\mathcal{SL}(W)\)</span>?</p></blockquote><p>The answer to this question is too complicated to be covered in thisarticle, a simple sketch of the main thread is appended at the end. WhenI was developing this program I mainly referred to Casselman’s notes <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> andthe textbook by Humphreys <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>. These should be enoughfor a reader with a solid background in undergradute abstractalgebra.</p><p>Once we have the normal forms of the group elements, we can easilyuse them to map the initial vertex <span class="math inline">\(v_0\)</span> to other vertices in the tiling:</p><p>Let <span class="math inline">\(w=s_{i_0}s_{i_1}\cdotss_{i_n}\)</span>, we adopt the convention that the action of <span class="math inline">\(w\)</span> on <span class="math inline">\(v_0\)</span> is to successively apply eachgenerator in <span class="math inline">\(w\)</span> from right to left:<span class="math display">\[w\cdot v_0 = s_{i_0}(s_{i_1}(\cdotss_{i_n}(v_0))).\]</span> Since <span class="math inline">\(W\)</span> isinfinite we can only generate words up to a given depth. Suppose we havethe 37 words listed above stored in a list <span class="math inline">\(L\)</span>, they map <span class="math inline">\(v_0\)</span> to 37 different vertices in thetiling. To draw the edges between them we need to compute which of themare adjacent. How can we do this?</p><p>Firstly we need a multiplicaiton table <span class="math inline">\(T\)</span> for the words in <span class="math inline">\(L\)</span>. <span class="math inline">\(T\)</span>is a 2d array with its <span class="math inline">\(i\)</span>-th rowcorrespondes to the <span class="math inline">\(i\)</span>-th word <span class="math inline">\(w_i\)</span> in <span class="math inline">\(L\)</span> and its <span class="math inline">\(j\)</span>-th column correspondes to the <span class="math inline">\(j\)</span>-th generator <span class="math inline">\(s_j\)</span>. The entry <span class="math inline">\(T[i][j]\)</span> records the index of <span class="math inline">\(s_jw_j\)</span> in <span class="math inline">\(L\)</span> (note this multiplication may not be anormal form). If <span class="math inline">\(s_jw_i\)</span> does notexist in <span class="math inline">\(L\)</span> we simply return<code>None</code>. The usage of <span class="math inline">\(T\)</span>is, for any given word <span class="math inline">\(w\)</span>, we canquickly find the index of <span class="math inline">\(w\)</span> in<span class="math inline">\(L\)</span> by using <span class="math inline">\(T\)</span> as a lookup table.</p><p>In our example <span class="math inline">\(T\)</span> is listedbelow, the words in <span class="math inline">\(L\)</span> are put intothe second column:</p><details><summary><font color="#D00"><strong>Click to expand <span class="math inline">\(T\)</span></strong></font></summary><div><table><thead><tr class="header"><th style="text-align: center;">V</th><th style="text-align: center;">word</th><th style="text-align: center;"><span class="math inline">\(s_0\)</span></th><th style="text-align: center;"><span class="math inline">\(s_1\)</span></th><th style="text-align: center;"><span class="math inline">\(s_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(e\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(s_{0}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">6</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(s_{1}\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">0</td><td style="text-align: center;">8</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(s_{2}\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">7</td><td style="text-align: center;">0</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">12</td><td style="text-align: center;">11</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">13</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}\)</span></td><td style="text-align: center;">9</td><td style="text-align: center;">1</td><td style="text-align: center;">15</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}\)</span></td><td style="text-align: center;">10</td><td style="text-align: center;">3</td><td style="text-align: center;">14</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}\)</span></td><td style="text-align: center;">11</td><td style="text-align: center;">14</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;">9</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">20</td><td style="text-align: center;">19</td></tr><tr class="odd"><td style="text-align: center;">10</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">21</td><td style="text-align: center;">18</td></tr><tr class="even"><td style="text-align: center;">11</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">8</td><td style="text-align: center;">22</td><td style="text-align: center;">4</td></tr><tr class="odd"><td style="text-align: center;">12</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">16</td><td style="text-align: center;">4</td><td style="text-align: center;">24</td></tr><tr class="even"><td style="text-align: center;">13</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">17</td><td style="text-align: center;">5</td><td style="text-align: center;">23</td></tr><tr class="odd"><td style="text-align: center;">14</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">18</td><td style="text-align: center;">8</td><td style="text-align: center;">7</td></tr><tr class="even"><td style="text-align: center;">15</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">19</td><td style="text-align: center;">23</td><td style="text-align: center;">6</td></tr><tr class="odd"><td style="text-align: center;">16</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">12</td><td style="text-align: center;">30</td><td style="text-align: center;">29</td></tr><tr class="even"><td style="text-align: center;">17</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">13</td><td style="text-align: center;">31</td><td style="text-align: center;">28</td></tr><tr class="odd"><td style="text-align: center;">18</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">14</td><td style="text-align: center;">32</td><td style="text-align: center;">10</td></tr><tr class="even"><td style="text-align: center;">19</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">15</td><td style="text-align: center;">33</td><td style="text-align: center;">9</td></tr><tr class="odd"><td style="text-align: center;">20</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">25</td><td style="text-align: center;">9</td><td style="text-align: center;">35</td></tr><tr class="even"><td style="text-align: center;">21</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">26</td><td style="text-align: center;">10</td><td style="text-align: center;">36</td></tr><tr class="odd"><td style="text-align: center;">22</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">27</td><td style="text-align: center;">11</td><td style="text-align: center;">34</td></tr><tr class="even"><td style="text-align: center;">23</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">28</td><td style="text-align: center;">15</td><td style="text-align: center;">13</td></tr><tr class="odd"><td style="text-align: center;">24</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">29</td><td style="text-align: center;">34</td><td style="text-align: center;">12</td></tr><tr class="even"><td style="text-align: center;">25</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">20</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr class="odd"><td style="text-align: center;">26</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">21</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">27</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">22</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr class="odd"><td style="text-align: center;">28</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">23</td><td style="text-align: center;">None</td><td style="text-align: center;">17</td></tr><tr class="even"><td style="text-align: center;">29</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">24</td><td style="text-align: center;">None</td><td style="text-align: center;">16</td></tr><tr class="odd"><td style="text-align: center;">30</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">16</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">31</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">17</td><td style="text-align: center;">None</td></tr><tr class="odd"><td style="text-align: center;">32</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">18</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">33</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">19</td><td style="text-align: center;">None</td></tr><tr class="odd"><td style="text-align: center;">34</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">24</td><td style="text-align: center;">22</td></tr><tr class="even"><td style="text-align: center;">35</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">None</td><td style="text-align: center;">20</td></tr><tr class="odd"><td style="text-align: center;">36</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">None</td><td style="text-align: center;">21</td></tr></tbody></table></div></details><p>Hence for any word <span class="math inline">\(w=s_{i_0}s_{i_1}\cdotss_{i_n}\)</span>, we can start from the first row of <span class="math inline">\(T\)</span>, find the index of <span class="math inline">\(s_{i_n}\)</span> in <span class="math inline">\(L\)</span>, say <span class="math inline">\(k\)</span>, then jump to the <span class="math inline">\(k\)</span>-th row and find the index of <span class="math inline">\(s_{i_{n-1}}s_{i_n}\)</span> in <span class="math inline">\(L\)</span>, …, and finally get the index of <span class="math inline">\(w\)</span> (or <code>None</code>).</p><p>Suppose the reflection of the initial vertex <span class="math inline">\(v_0\)</span> about the <span class="math inline">\(i\)</span>-th mirror gives a virtual image <span class="math inline">\(v_1=s_i(v_0)\)</span>, then <span class="math inline">\(e=(v_0,v_1)\)</span> is an edge of type <span class="math inline">\(i\)</span>. By the orbit-stabilizer theorem alledges of type <span class="math inline">\(i\)</span> can be obtained byapplying the coset representatives in <span class="math inline">\(G/H\)</span> to <span class="math inline">\(e\)</span>, where <span class="math inline">\(H=\langle i\rangle\)</span> is the stabilizingsubgroup of <span class="math inline">\(e\)</span> (<span class="math inline">\(H\)</span> is called a standard parabolicsubgroup). It’s easy to see the words of the two ends of <span class="math inline">\(e\)</span> are <span class="math inline">\(1\)</span> and <span class="math inline">\(s_i\)</span> respectively. We then compute thecoset representatives of the words in <span class="math inline">\(L\)</span> for the subgroup <span class="math inline">\(H\)</span>, use a set to remove duplicates, applyeach resulting coset representative <span class="math inline">\(w\)</span> to the two ends of <span class="math inline">\(e\)</span>. The words of the two ends of <span class="math inline">\(w\cdot e\)</span> are <span class="math inline">\(w\)</span> and <span class="math inline">\(ws_i\)</span> respectively. We can find theindices of <span class="math inline">\(w\)</span> and <span class="math inline">\(ws_i\)</span> as shown above to get <span class="math inline">\(w\cdot e\)</span>.</p><p>The edges between the 37 vertices in <span class="math inline">\(L\)</span> are drawn below:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/723_edges.png" width="500"></p><p>0 is the initial vertex, the number of white strips in an edgeindices the type of it (no white strips for <span class="math inline">\(s_0\)</span>, one for <span class="math inline">\(s_1\)</span> and two for <span class="math inline">\(s_2\)</span>).</p><p>It’s worth noting that one can easily read the shortlex wordrepresentation of any vertex <span class="math inline">\(v\)</span> fromthe above image, just start from vertex 0, trace a shortest path from 0to <span class="math inline">\(v\)</span> (if there are more than oneshortest path then always choose the smaller vertex at bifurcatonpoints) and record the edges along the way. For example there are twopaths with shortest length from vetex 0 to vertex 33: <span class="math display">\[\begin{align*}&amp;0\xrightarrow{\ s_1\ }2\xrightarrow{\ s_0\}6\xrightarrow{\ s_2\ }13\xrightarrow{\ s_1\ }22\xrightarrow{\ s_0\}33.\\&amp;0\xrightarrow{\ s_1\ }2\xrightarrow{\ s_2\ }7\xrightarrow{\ s_0\}13\xrightarrow{\ s_1\ }22\xrightarrow{\ s_0\ }33.\end{align*}\]</span> By concatenating edge labels from left to right wehave two words that both map vertex 0 to vertex 33: <span class="math inline">\(s_1s_0s_2s_1s_0\)</span> and <span class="math inline">\(s_1s_2s_0s_1s_0\)</span>. The first is theshortlex one.</p><blockquote><p><strong>Question 2</strong>: How to compute the normal form of themultiplicaiton of two words? How to compute the coset representative ofa word for a standard parabolic subgroup?</p></blockquote><p>Again the answer is too long to be included here. A short sketch ofthe procedure is attached below.</p><p>The procedure for computing faces is very similar with the case ofedges. The reflections about the <span class="math inline">\(i\)</span>-th and <span class="math inline">\(j\)</span>-th mirrors generate a polygon <span class="math inline">\(f_0\)</span> centered at a vertex of thefundamental triangle. The stabilizing subgroup of <span class="math inline">\(f_0\)</span> is the standard parabolic subgroup<span class="math inline">\(\langle i,j\rangle\)</span>. Again we find aword representation for each vertex in <span class="math inline">\(f_0\)</span>, apply the words in <span class="math inline">\(L\)</span> to <span class="math inline">\(f_0\)</span>, and use <span class="math inline">\(T\)</span> to get the indices of the transformedface.</p><p>The final image is shown below, it contains 30517 vertices, 42057edges and 11541 polygons.</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-7-2-3.png" width="500"></p><h1 id="about-the-code">About the code</h1><p>The entire code mainly includes the following functionalities:</p><ol type="1"><li>Computation of Coxeter groups. This part is implemented by the<code>CoxeterGroup</code> class in the <code>coxeter</code> module. Thecomputation of Coxeter groups includes the following aspects:<ul><li>Compute the minimal root reflection table of the Coxeter group.</li><li>Compute the multiplication of two words in the Coxeter group, andreturning the result in its normal form.</li><li>Compute the coset representatives of group elements with respect toa given standard parabolic subgroup, and returning the result in itsnormal form.</li><li>Compute of the finite state machine that recognizes <span class="math inline">\(\mathcal{SL}(W)\)</span>, minimizing it, anddrawing the state machine.</li></ul></li><li>Tiling drawing. Mainly implemented in the <code>tiling.py</code>file. It includes the following steps:<ul><li>For a given Coxeter group and specified initial vertex position,calculate the reflection mirrors and fundamental domain.</li><li>Compute the normal forms of all vertices, as well as the connectionsof edges and faces.</li><li>Apply the words of vertices obtained in the previous step to theinitial vertex to obtain the floating-point coordinates of all vertices.These calculations are all performed in one higher dimension, because inthe higher dimension all reflections are linear transformations, whichavoids the use of affine transformations and inversion. Then project totwo dimensions.</li><li>Call the drawing library to draw the tiling.</li></ul></li></ol><p>The drawing of the finite state machine of <span class="math inline">\(\mathcal{SL}(W)\)</span> requires the use of the<code>pygraphviz</code> module, which depends on the<code>graphviz</code> software and <code>libgraphviz-dev</code>.</p><p>The minimization of the finite state machine was referenced from <a href="https://link.springer.com/article/10.1007/BF00264025">Gries’spaper</a>. Gries’s article is excellent, but I think he did not clarifythe property of the list that storing the <span class="math inline">\((B,a)\)</span> pairs.</p><p>The drawing of the hyperbolic case uses a third-party library <a href="https://github.com/cduck/hyperbolic/">hyperbolic</a>. I’m actuallynot very satisfied with this library, but I don’t have the energy towrite another one at the moment, so I’ll make do for now. The biggestadvantage of this library is that it can draw edges with a constanthyperbolic width, namely the so-called <a href="https://en.wikipedia.org/wiki/Hypercycle_(hyperbolic_geometry)">hypercycle</a>.</p><p>The algorithm for calculating minimal roots is the biggestperformance bottleneck in this code. In determining whether a minimalroot <span class="math inline">\(\gamma\)</span> remains a minimal rootafter a single reflection <span class="math inline">\(s_\alpha\)</span>,the method used is to determine whether <span class="math inline">\(s_\gamma\)</span> and <span class="math inline">\(s_\alpha\)</span> generate a finite dihedralgroup, that is, whether the matrix corresponding to <span class="math inline">\(s_\gamma s_\alpha\)</span> under the basis <span class="math inline">\(\Delta\)</span> of simple roots becomes theidentity matrix after a certain power. The elements of the matrix arealgebraic integers in the cyclotomic field, in the form of <span class="math inline">\(p(\xi)\)</span>, where <span class="math inline">\(p(x)\)</span> is an irreducible polynomial withinteger coefficients, and <span class="math inline">\(\xi\)</span> is aprimitive <span class="math inline">\(m\)</span>-th root of unity, where<span class="math inline">\(m\)</span> is twice the least commonmultiple of all elements in the Coxeter matrix. <span class="math inline">\(\xi\)</span> can be described by the cyclotomicpolynomial <span class="math inline">\(\Phi_m(x)\)</span>. Thus, thecomputation of the matrix is reduced to polynomial operations in <span class="math inline">\(\mathbb{Z}[x]/(\Phi_m(x))\)</span>. Thiscomputational complexity heavily depends on the value of <span class="math inline">\(m\)</span>: for example, for a triangle group like(19, 20, 21), the expression of <span class="math inline">\(\Phi_m(x)\)</span> is very complicated, and thecomputation speed is very slow. This is different from the inverse pixelreflection method, whose computational complexity hardly changes withthe group.</p><p>A more reasonable implementation method can be seen <a href="https://github.com/ulthiel/CoxeterGroups.jl">here</a>.</p><h1 id="more-explainations-on-the-math-stuff">More explainations on themath stuff</h1><p>In this section I’ll give a short sketch of the core part of the mathstuff. This requires you know some basic concepts like geometricrealizations of Coxeter groups, Tit’s cone, root systems. These arefairly standard materials and can be found in Humphreys’s book.</p><p>Almost everything relies upon a 2d table called <strong>reflectiontable of minimal roots</strong>. Again we use group (7, 2, 3) asexample:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/roots.png" width="800"></p><p>This image is the same with the last one except that it has 12labelled mirrors, these mirror have particular importance among allroots in the root system: they are the set of minimal roots in the rootsystem.</p><p>You can think the root system of <span class="math inline">\(W\)</span> as all the circular arcs in thediagram, each of which is a reflection mirror. These mirrors are theresult of the action of the group <span class="math inline">\(W\)</span>on the initial mirrors <span class="math inline">\(AB, AC, BC\)</span>that are the edges of <span class="math inline">\(\Delta ABC\)</span>.Each mirror has two sides, where the side where the fundamental domain<span class="math inline">\(\Delta ABC\)</span> is located is consideredthe positive side of the mirror, and the other side is the negativeside. The normal vector of the mirror’s positive side gives a positiveroot, while the normal vector corresponding to the other side is thenegative of that positive root (negative root).</p><p>We always use a mirror’s positive normal vector (positive root) torepresent that mirror.</p><p>Intuitively, a minimal root <span class="math inline">\(\gamma\)</span> is characterized by the followingcondition: suppose a person stands inside <span class="math inline">\(\Delta ABC\)</span> looking outward, there existsno mirror <span class="math inline">\(\beta \neq \gamma\)</span>completely blocking the view of <span class="math inline">\(\gamma\)</span>, preventing the person from seeingany part of <span class="math inline">\(\gamma\)</span>. In other words,this means that if the person wants to walk from the inside of <span class="math inline">\(\Delta ABC\)</span> to the negatve side of <span class="math inline">\(\gamma\)</span>, and he must cross another mirror<span class="math inline">\(\beta \neq \gamma\)</span> first, regardlessof the path he chooses, then <span class="math inline">\(\gamma\)</span>is <strong>not</strong> a minimal root.</p><p>Simple roots are necessarily minimal roots, as they are theboundaries of the fundamental domain <span class="math inline">\(\DeltaABC\)</span>, and it is impossible for there to be another mirrorblocking between them and the basic region.</p><p>The most important fact about minimal root is:</p><blockquote><p><strong>Theorem</strong>: The set of minimal roots is finite.</p></blockquote><p>This theorem is the key step in Brink and Howlett’s proof thatCoxeter groups are automatic groups.</p><p>The reflection table of minimal roots <code>reftable</code> isdefined as follows: it’s a 2d array with its <span class="math inline">\(i\)</span>-th row correspondes to the <span class="math inline">\(i\)</span>-th minimal root <span class="math inline">\(\alpha_i\)</span> and <span class="math inline">\(j\)</span>-th column correspondes to the <span class="math inline">\(j\)</span>-th generator <span class="math inline">\(s_j\)</span>. The <span class="math inline">\((i,j)\)</span>-entry records the action of <span class="math inline">\(s_j\)</span> on <span class="math inline">\(\alpha_i\)</span>. Let <span class="math inline">\(\beta=s_j(\alpha_i)\)</span>:</p><ol type="1"><li>If <span class="math inline">\(\beta=\alpha_k\)</span> is the <span class="math inline">\(k\)</span>-th minimal root then set this entry to<span class="math inline">\(k\)</span>.</li><li>If <span class="math inline">\(\beta\)</span> is a negative rootthen set this entry to <span class="math inline">\(-1\)</span>.</li><li>Else <span class="math inline">\(\beta\)</span> is a positive rootbut not minimal, set this entry to <code>None</code>.</li></ol><p>The <code>reftable</code> of the (7, 2, 3) group is listed below:</p><table><thead><tr class="header"><th style="text-align: center;">root</th><th style="text-align: center;"><span class="math inline">\(s_0\)</span></th><th style="text-align: center;"><span class="math inline">\(s_1\)</span></th><th style="text-align: center;"><span class="math inline">\(s_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">-1</td><td style="text-align: center;">3</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">4</td><td style="text-align: center;">-1</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">5</td><td style="text-align: center;">-1</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">6</td><td style="text-align: center;">0</td><td style="text-align: center;">7</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">1</td><td style="text-align: center;">8</td><td style="text-align: center;">9</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">9</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;">3</td><td style="text-align: center;">10</td><td style="text-align: center;">11</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;">11</td><td style="text-align: center;">7</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;">10</td><td style="text-align: center;">4</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">9</td><td style="text-align: center;">5</td><td style="text-align: center;">None</td><td style="text-align: center;">4</td></tr><tr class="odd"><td style="text-align: center;">10</td><td style="text-align: center;">8</td><td style="text-align: center;">6</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">11</td><td style="text-align: center;">7</td><td style="text-align: center;">None</td><td style="text-align: center;">6</td></tr></tbody></table><p>Let <span class="math inline">\(\Sigma\)</span> be the set of minimalroots of <span class="math inline">\(G\)</span>, all states in theautomaton are subsets of <span class="math inline">\(\Sigma\)</span>,the transition rule between the subsets is:</p><p><span class="math display">\[S\xrightarrow{\ s_i\ } \{s_i\} \cup(s_i(S)\cup\{ s_i(\alpha_j),j&lt;i\})\cap\Sigma.\]</span></p><p>One can use breadth-first search to build this automaton and use <a href="https://en.wikipedia.org/wiki/DFA_minimization#Hopcroft's_algorithm">Hopcroft’salgorithm</a> to get a minimized version of it.</p><p>The image below shows the subsets of minimal roots for each state inthe automaton:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/723_dfa_subsets.png" width="800"></p><p>The code for computing the multiplication of a generator and a wordis given below:</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">left_mul_invshortlex</span>(<span class="hljs-params">reftable, s, w</span>):</span><br>    w = <span class="hljs-built_in">tuple</span>(w)<br>    t = s<br>    k = -<span class="hljs-number">1</span><br>    mu = s<br>    <span class="hljs-keyword">for</span> i, s_i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(w):<br>        <span class="hljs-keyword">if</span> mu <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> w[:k+<span class="hljs-number">1</span>] + (t,) + w[k+<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">elif</span> mu &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> w[:i] + w[i+<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">elif</span> mu &lt; s_i:<br>            t = mu<br>            k = i<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">return</span> w[:k+<span class="hljs-number">1</span>] + (t,) + w[k+<span class="hljs-number">1</span>:]<br></code></pre></td></tr></tbody></table></figure><p>Here <span class="math inline">\(s\)</span> is a generator and <span class="math inline">\(w\)</span> is a word in the normal form of the<em>inverse shortlex ordering</em> (invshortlex). The function returnsthe normal form of <span class="math inline">\(s\cdot w\)</span> also inthe invshortlex ordering. The computations in shortlex can be obtainedby doing computations in invshortlex first and then reverse the resultback.</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>The intermedian step of doing computations in invshortlexordering is mainly for keeping consistent with Casselman’s paper.</p></div><p>Finding the coset representative of a given word for a standardparabolic subgroup is quite straight-forward: let <span class="math inline">\(T\)</span> be the set of generators of thisstandard parabolic subgroup, the pseudocode for the procedure is givenbelow:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">x := w<br>u := 1<br>while l(xt) &lt; l(x) for some t in T<br>    x := xt<br>    u := t<br>end<br><br>return x<br></code></pre></td></tr></tbody></table></figure><p>Where <span class="math inline">\(l(\cdot)\)</span> is the lengthfunction.</p><p>For finite Coxeter groups all positive roots are minimal. For affineCoxeter groups the root system consists of families of parallel affinehyperplanes. In each family there is a pair of minimal roots such thatthe fundamental domain lies between them and all other mirrors in thisfamily are completely screened off by them hence are not minimal. Seethe image for (6, 2, 3) (affine <span class="math inline">\(\widetilde{G}_2\)</span>) for an example:</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/roots_623.png" width="600"></p><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p><a href="https://www.math.ubc.ca/~cass/research/pdf/banff.pdf">Automata toperform basic calculations in Coxeter groups, by Bill Casselman</a>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p><a href="https://www.math.ubc.ca/~cass/research/pdf/cm.pdf">Computation inCoxeter groups I. Multiplication, by Bill Casselman</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p><a href="https://www.math.ubc.ca/~cass/research/pdf/roots.pdf">Computationin Coxeter groups II. Constructing minimal roots, by BillCasselman</a>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>Reflection Groups and Coxeter Groups, by James E.Humphreys.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
    </entry>
    
    
  
</search>
