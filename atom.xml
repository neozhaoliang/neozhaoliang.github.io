<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朝花夕拾</title>
  
  <subtitle>朝花夕拾</subtitle>
  <link href="https://pywonderland.com/atom.xml" rel="self"/>
  
  <link href="https://pywonderland.com/"/>
  <updated>2025-03-14T14:26:03.654Z</updated>
  <id>https://pywonderland.com/</id>
  
  <author>
    <name>Zhao Liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IFS 分形揭秘</title>
    <link href="https://pywonderland.com/ifs-demystified/"/>
    <id>https://pywonderland.com/ifs-demystified/</id>
    <published>2024-06-16T00:00:00.000Z</published>
    <updated>2025-03-14T14:26:03.654Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理自我 2024/06/14 在上海科技大学数学所的一个小报告，标题是「GPU涂鸦与数学可视化」。我保留了报告的技术内容，略去了关于 demoscene和分形文化的部分。</p><span id="more"></span><hr><p>在 Shadertoy上有很多效果酷炫，但是代码非常短的分形作品。我挑选了其中三个优秀的例子展示如下：</p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr class="odd"><td style="text-align: center;"><a href="https://www.shadertoy.com/view/ltB3DG">Ethereal</a> by Kali</td><td style="text-align: center;"><a href="https://www.shadertoy.com/view/NsVyRz">Apollonian fractal</a> byXor</td><td style="text-align: center;"><a href="https://www.shadertoy.com/view/mdG3Wy">Radiosity</a> by Xor</td></tr><tr class="even"><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/ltB3DG.jpg"></td><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/NsVyRz.jpg"></td><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/mdG3Wy.jpg"></td></tr></tbody></table><p>然而代码短可不代表它们容易看懂。尤其是很多作者还喜欢故弄玄虚，把代码作了混淆处理以增加神秘感。对我来说，这种被人秀了一脸却没搞明白对面是怎么装的逼的感觉让人很不爽。当然我不是在抱怨，这种炫技的行为本身就是黑客文化的一部分，可以理解。后来分形玩的多了，我也慢慢明白了其中的奥妙，这次上科大之行是一次很好的机会，促使我把这些理解完整的写下来。</p><p>在这篇文章中，我将为大家揭示这些作品背后的奥秘。这些分形作品别看场景千变万化，其实都是用同一个套路制作出来的。这个套路可以简述为三步：</p><ol type="1"><li>首先将像素的 2D 坐标映射为空间中的某个 3D 点 <code>p</code>；</li><li>然后用一个 <code>fold</code> 函数，即所谓的 <a href="https://en.wikipedia.org/wiki/Iterated_function_system">迭代函数系统</a>（iteratedfunction system，简称 IFS）反复作用在<code>p</code>上。每次迭代结束后，生成一个颜色并将其添加到当前的颜色<code>color</code> 上。</li><li>当达到一定的迭代次数后，终止迭代，返回 <code>color</code>的值作为像素最终的颜色。</li></ol><p>下面是具体步骤的解释。</p><h1 id="ifs-方法">IFS 方法</h1><div id="------------" class="unnumbered statement sta_____ plain"><p><span class="statement-heading"><span class="statement-label">压缩映射</span>.</span><span class="statement-spah"> </span><br></p><p>设 <span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}^n\)</span>是一个映射，如果存在 <span class="math inline">\(0&lt;r&lt;1\)</span>使得对任何 <span class="math inline">\(x,y\in\mathbb{R}^n\)</span> 有<span class="math display">\[d(f(x),f(y))\leq r\cdot d(x,y)\]</span>成立，我们就称 <span class="math inline">\(f\)</span>是一个压缩映射，<span class="math inline">\(r\)</span> 是压缩比例。这里<span class="math inline">\(d\)</span> 是通常的 Euclidean 距离。</p></div><p>记 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span>中所有紧集组成的集合，可以证明 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 在 <a href="https://en.wikipedia.org/wiki/Hausdorff_distance">Hausdorff度量</a> 下构成一个完备度量空间。读者不必关心 Hausdoff度量的具体细节，只要知道它是一个度量，可以衡量两个紧集的接近程度。</p><p>设 <span class="math inline">\(f_1,\ldots,f_N\)</span> 是 <span class="math inline">\(N\)</span> 个压缩映射，<span class="math inline">\(f_i\)</span> 的压缩比例是 <span class="math inline">\(r_i\)</span>。定义映射 <span class="math inline">\(F:K(\mathbb{R}^n)\to K(\mathbb{R}^n)\)</span>如下： <span class="math display">\[F(X) = f_1(X)\cupf_2(X)\cup\cdots\cup f_N(X),\quad X\in K(\mathbb{R}^n).\]</span> 即<span class="math inline">\(F\)</span> 把 <span class="math inline">\(X\)</span> 变成 <span class="math inline">\(N\)</span> 个更小的集合。</p><p>可以证明 <span class="math inline">\(F\)</span> 是空间 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 上的压缩映射，其压缩比例<span class="math inline">\(r=\max\{r_1,\ldots,r_N\}\)</span>。于是根据<a href="https://en.wikipedia.org/wiki/Banach_fixed-point_theorem">Banach不动点定理</a>，存在唯一的紧集 <span class="math inline">\(A\subset\mathbb{R}^n\)</span> 使得 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(F\)</span> 的不动点： <span class="math display">\[F(A) = A.\]</span> 不仅如此，对 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 中的任何一点（注意 <span class="math inline">\(K(\mathbb{R}^n)\)</span>是紧集组成的度量空间，里面的点都是紧集）<span class="math inline">\(B\subset\mathbb{R}^n\)</span>，都有 <span class="math display">\[\lim_{n\to\infty} F^n(B) =A.\]</span> 紧集 <span class="math inline">\(A\)</span> 叫做 <span class="math inline">\(F\)</span> 的极限集，<span class="math inline">\(A\)</span> 是一个分形，它具有自相似的特征。</p><p>我们以著名的 <a href="https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle">Sierpiński三角形</a> 为例来说明这个过程。我们选择的三个压缩映射分别是</p><p><span class="math display">\[\begin{align}f_1(x,y) &amp;= (x/2, y/2),\\f_2(x,y) &amp;= (x/2, y/2) + (0, 1/2),\\f_3(x,y) &amp;= (x/2, y/2) + (1/2, 0).\\\end{align}\]</span></p><p>这三个压缩映射的压缩比都是 1/2。初始的紧集 <span class="math inline">\(K_0\)</span> 可以随便选，比如就取为一个圆：</p><p><span class="math display">\[K_0 =\img{/images/ifs/dot0.svg}{-1.75em}{}{4em}.\]</span></p><p>在第 1 次迭代后，它变成</p><p><span class="math display">\[K_1 = f_1(K_0)\cup f_2(K_0)\cup f_3(K_0)= \img{/images/ifs/dot1.svg}{-1.75em}{}{4em}.\]</span></p><p>在第 2 次迭代后，结果是</p><p><span class="math display">\[K_2 = f_1(K_1)\cup f_2(K_1)\cup f_3(K_1)= \img{/images/ifs/dot2.svg}{-1.75em}{}{4em}.\]</span></p><p>第 3 次迭代：</p><p><span class="math display">\[K_3 = f_1(K_2)\cup f_2(K_2)\cup f_3(K_2)= \img{/images/ifs/dot3.svg}{-1.75em}{}{4em}.\]</span></p><p>当迭代次数趋于无穷，就得到了 Sierpiński 分形：</p><p><span class="math display">\[\lim_{n\to\infty} K_n = K = f_1(K)\cupf_2(K)\cup f_3(K) =\img{/images/ifs/dot6.svg}{-1.75em}{}{4em}.\]</span></p><p>你可以很容易看出来为什么初始紧集的选择是不重要的：因为在压缩的过程中，任何紧集都会逐渐缩小到一个单点，所以<span class="math inline">\(K_0\)</span> 甚至取成一个点也是可以的。</p><p>压缩映射是无穷无尽的，所以 IFS分形也是无穷无尽的。为了避免选择困难，我们一般只使用平移、旋转、反射、缩放、球反演这几种变换，通过组合它们来实现空间压缩。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这里的球反演变换是指将单位球的外部反演到内部，单位球内部保持不动的变换。虽然在单位球内部它并不压缩距离，但是只要和其它变换适当结合（必须有缩放），使得最终的复合变换是压缩的，就仍然可以得到分形。</p></div><p>你可能想问，那应该怎样具体选择 <span class="math inline">\(f_1,\ldots,f_N\)</span>？我们后面会介绍，在着色器中绘制IFS 是通过应用 <span class="math inline">\(F\)</span> 的逆映射 <span class="math inline">\(F^{-1}\)</span> 来实现的，<span class="math inline">\(F^{-1}\)</span> 就是本文开头提到的<code>fold</code>函数，它是一种「空间折叠」操作，可以通过组合若干“折叠”函数来实现，所以无需显示地单独指定每个<span class="math inline">\(f_i\)</span>！</p><h1 id="轨道着色">轨道着色</h1><p>我们希望给分形染上漂亮的颜色，这个染色应该满足如下的条件：</p><ol type="1"><li>在分形上颜色是连续变化的；</li><li>在分形和非分形的交界处（即 <span class="math inline">\(A\)</span> 和<span class="math inline">\(A^c\)</span>的边界上）颜色应该是不连续的，从而产生泾渭分明的效果。</li></ol><p>做到这一点并不难，但是需要在每一次迭代时考虑当前点的位置信息。</p><p>我们首先取一个底色，比如说<code>color=vec3(0)</code>，在每一次迭代中，根据当前位置 <code>p</code>生成一个颜色，并以一定的权重与 <code>color</code> 混合。理论上颜色的 rgb的取值范围应该是 <span class="math inline">\([0,1]\)</span>，但是多数情况下我们要放宽到 <span class="math inline">\([-1,1]\)</span>之间，即颜色可以增加也可以减少。否则如果颜色只增不减的话，那么多次迭代以后rgb值很可能会溢出，变成白色。此外，随着迭代次数的增加，后面加入的颜色的权重应该单调下降，以保证突出分形的细节。这也符合我们的生活直觉：想象一下，当一位画家作画时，在开始的时候他可以浓墨重彩地画一个轮廓，但是越到后面描绘更加精细的部分时，他就会换用更细的画笔，小心地蘸一点颜料。</p><p>根据 <code>p</code>生成颜色的着色方案无穷无尽，请随便发挥你的创造力。一般来说你需要反复试验各种不同的方案才能找到最合适的。下面的例子使用了一种非常流行的染色方案，它以<code>cos(vec3(0,1,2))</code> 作为底色，并根据当前时间<code>iTime</code> 以及坐标 <code>uv</code> 进行调整：</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 uv = fragCoord / iResolution.xy;    vec3 col = 0.5 + 0.45 * cos(vec3(0, 1, 2) + iTime + uv.yxy);    fragColor = vec4(col, 1.0);}"></div><h1 id="着色器编程基础">着色器编程基础</h1><p>我简单介绍一下着色器编程的基本概念。打开 shadertoy网站，点击右上角的<code>新建</code>按钮，你会看到一个 <a href="https://www.shadertoy.com/new">最简单的动画</a>：</p><p><img src="/images/ifs/shadertoy.png" class="fig" width="600"></p><p>左边的窗口是画布，显示渲染的结果；右边窗口是代码编辑器，你在这里书写着色器代码。</p><p>画布是由若干像素组成的，你需要根据每个像素的位置，即它的<code>fragCoord</code> 值指定一个颜色。这个过程是在<code>mainImage</code> 函数中实现的：</p><figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> mainImage(<span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> fragColor, <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> fragCoord);<br></code></pre></td></tr></tbody></table></figure><p>其中 <code>fragCoord</code> 是像素的位置，<code>fragColor</code>是需要设置的像素颜色。</p><p>现实生活中有一个很形象的例子可以帮你理解着色器编程：假设你是一场方阵表演的导演，所有演员排成一个<span class="math inline">\(W\times H\)</span>的方阵，每个演员可以改变自己衣服的颜色。你的任务是发出合适的指令让每个演员根据自己的位置计算出正确的颜色，使得整个方阵呈现出漂亮的图案。</p><p><img src="/images/ifs/array.png" class="fig" width="600"></p><p>如果你一个一个地对每个演员下指令，张三你应该显示红色，李四你应该显示蓝色，等等…对成千上万个演员，这么挨个下指令还不得把人累死？正确的做法是，你应该同时对所有演员发出相同的指令，比如：“每个人，计算自己和方阵中心的距离，小于10 米的显示红色，大于等于 10 米的显示黑色”。由于每个演员都是一个单独的GPU计算单元，他们可以根据你发出的同一条指令，在极短的时间内（毫秒级）分别计算出各自的颜色。计算完毕后，观众应该会看到一个红色的圆。这种基于相同指令并行计算的工作方式就是GPU 流水线的机制。</p><p>我们来试试在着色器中实际编程绘制这个圆的例子。为了方便起见，我们假设方阵的中心是原点，并尝试绘制一个以原点为中心，半径是0.5 的圆。这只需要三行代码：</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;    float d = length(p) - 0.5;    fragColor = d > 0.0 ? vec4(0, 0, 0, 1) : vec4(1, 0, 0, 1);}"></div><ul><li>首先，每个演员会根据自己在方阵中的位置<code>fragCoord</code>，计算自己的归一化坐标 <code>p</code>，使得<code>p</code> 的纵坐标 <code>p.y</code> 位于 <span class="math inline">\([-1,1]\)</span> 中；</li><li>然后，每个演员计算自己到以原点为中心、半径为 0.5 的圆的距离<code>d</code>。位于圆内部的演员得出的 <code>d</code>是负数，圆外部的演员得出的 <code>d</code> 是正数；</li><li>最终每个人根据 <code>d</code> 的符号来确定自己的颜色。</li></ul><p>你可以修改上面代码中的半径，颜色等参数，观察左边画布的变化来体会效果。</p><p>这个例子其实蕴含了 shader编程的一个非常核心的概念，即<strong>距离场</strong> (distancefield)。当我们想绘制某个图案时，我们通过计算像素到这个图案的距离来对像素进行着色。在绘制IFS分形时，我们同样需要计算像素到分形的距离，并根据距离值来确定像素的颜色。这一点在下节会详细介绍。</p><h1 id="空间折叠">空间折叠</h1><p>上面刚刚讲到，在着色器里面画 IFS就是给每个像素指定一个颜色，这个颜色应该由这个像素对应的空间中的点到分形的距离来决定。假设像素对应的空间中的点是<span class="math inline">\(p\)</span>，初始紧集是 <span class="math inline">\(K\)</span>，我们用迭代 <span class="math inline">\(n\)</span> 次的结果 <span class="math inline">\(F^n(K)\)</span> 作为分形的近似，这里 <span class="math inline">\(n\)</span> 是某个常数，在绝大多数场景下 <span class="math inline">\(n=30\)</span> 就足够了。于是我们需要计算距离 <span class="math inline">\(d(p,F^n(K))\)</span>并根据这个距离值对像素染色。然而，直接计算 <span class="math inline">\(d(p,F^n(K))\)</span> 是不可行的，因为如果有 <span class="math inline">\(N\)</span> 个不同的压缩映射 <span class="math inline">\(f_1,\ldots,f_N\)</span>，那么每次迭代后集合的数目会乘以<span class="math inline">\(N\)</span>，这是指数增长的，10次迭代后就会产生多达 <span class="math inline">\(10^N\)</span>个不同的集合。维护如此数量的集合会轻易耗尽计算机内/显存。这该怎么办呢？</p><p>有个巧妙的做法可以绕过这个困难：我们把 <span class="math inline">\(d(p,F^n(K))\)</span> 中的 <span class="math inline">\(F^n\)</span> 挪到另一侧并取逆，转而计算 <span class="math inline">\(d(F^{-n}(p), K)\)</span>！实际上，如果 <span class="math inline">\(F\)</span>只包含旋转、平移、反射、缩放、球反演这些变换的话，<span class="math inline">\(d(p,F^n(K))\)</span> 和 <span class="math inline">\(d(F^{-n}(p), K)\)</span>之间存在非常简单的关系，我们可以通过计算后者来得到前者！这个关系的推导我放在后面介绍。</p><p>于是，在着色器编程时，我们需要将压缩迭代映射的步骤倒过来，采取相反的操作：即将逆映射<span class="math inline">\(F^{-1}\)</span> 迭代作用在 <span class="math inline">\(p\)</span> 上，执行足够的迭代次数后，通过计算距离<span class="math inline">\(d(F^{-n}(p), K)\)</span> 来给 <span class="math inline">\(p\)</span> 对应的像素上色。由于 <span class="math inline">\(F\)</span> 是“一对多” 的映射，所以 <span class="math inline">\(F^{-1}\)</span> 是 “多对一”的，反复迭代应用 <span class="math inline">\(F^{-1}\)</span>会把空间“折叠”。我们实际上是在这个折叠后的空间上作画。</p><p>总而言之，在着色器编程中我们真正需要的函数不是 <span class="math inline">\(F\)</span>，而是 <span class="math inline">\(F^{-1}\)</span>！</p><p>这个先折叠后画图的操作，也可以用一个生活中的例子来形象地解释，即剪纸艺术：</p><figure><img src="/images/ifs/papercut.jpg" width="480" alt="在剪纸过程中，首先把纸张反复折叠，然后在折叠后的纸张上画出某个特定的图形，沿着这个图形裁剪，再将纸张展开得到的就是美丽的图案。展开纸张的操作对应迭代映射 F，它把一个初始的紧集铺开到空间中变成分形；折叠纸张的操作对应 F^{-1}，它把分形折叠回最初的紧集。"><figcaption aria-hidden="true">在剪纸过程中，首先把纸张反复折叠，然后在折叠后的纸张上画出某个特定的图形，沿着这个图形裁剪，再将纸张展开得到的就是美丽的图案。<strong>展开</strong>纸张的操作对应迭代映射<span class="math inline">\(F\)</span>，它把一个初始的紧集铺开到空间中变成分形；<strong>折叠</strong>纸张的操作对应<span class="math inline">\(F^{-1}\)</span>，它把分形折叠回最初的紧集。</figcaption></figure><p>在设置 <span class="math inline">\(F^{-1}\)</span>的时候，我们完全不必关心每个 <span class="math inline">\(f_i\)</span>是什么，我们需要的只是准备一些折叠函数，然后将它们组合起来得到 <span class="math inline">\(F^{-1}\)</span>。</p><p>如果你去看那些分形作品的代码的话，会发现它们几乎都在 <span class="math inline">\(F^{-1}\)</span> 中使用了 <code>abs</code>函数。这个函数是最简单的空间折叠函数，它会把整个空间折叠到第一象限。进一步，再叠加关于平面/球面的反射可以产生出更复杂的折叠。</p><p>在下面的例子中，我们首先用 <code>p = abs(p)</code>将整个空间折叠到第一象限，然后只要在第一象限中画一个圆，就可以同时在其它象限自动得到另外三个圆：</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;    p = abs(p); //折叠    float d = length(p - vec2(0.5)) - 0.3; // 中心在 (0.5, 0.5), 半径为 0.3 的圆    d = smoothstep(-0.005, 0.005, d); // 平滑一下边缘    vec3 col = mix(vec3(0), vec3(0.9), d); //染色    fragColor = vec4(col, 1);}"></div><hr><p>最后我们来推导 <span class="math inline">\(d(p,F^n(K))\)</span> 和<span class="math inline">\(d(F^{-n}(p), K)\)</span> 之间的关系。</p><p>如果 <span class="math inline">\(F\)</span>是平移、旋转、反射这样的保持 Euclidean 距离不变的刚体运动，那么自然有<span class="math display">\[d(p, F(K)) = d(F^{-1}(p), K).\]</span></p><p>但如果 <span class="math inline">\(F\)</span> 是一个缩放变换，比如<span class="math inline">\(F(x) = x/s\,(s&gt;1)\)</span>，那么 <span class="math display">\[d(p, F(K)) = d(p, 1/s\cdot K) = 1/s\cdot d(s\cdotp, K) = 1/s\cdot d(F^{-1}(p), K).\]</span>即我们要对折叠以后算出来的距离值再除以 <span class="math inline">\(s\)</span>。</p><p>既然每次迭代 <span class="math inline">\(F\)</span> 以比例 <span class="math inline">\(1/s\)</span> 缩小，所以用 <span class="math inline">\(F^{-1}\)</span> 迭代 <span class="math inline">\(n\)</span> 次以后累积放大的比例就是 <span class="math inline">\(s^n\)</span>，我们要将 <span class="math inline">\(d(F^{-n}(p), K)\)</span> 再除以 <span class="math inline">\(s^n\)</span> 才是最终正确的距离值。</p><p>对球的反演变换，甚至更一般的变换，我们可以通过计算 <span class="math inline">\(F^{-1}\)</span> 在 <span class="math inline">\(p\)</span> 处 Jacobian 矩阵的行列式的绝对值，作为<span class="math inline">\(p\)</span>处缩放的近似。把迭代过程中所有这些行列式的绝对值相乘，并对最后得到的<span class="math inline">\(d(F^{-n}(p), K)\)</span>再除以这个乘积，就可以作为 <span class="math inline">\(d(p,F(K))\)</span> 的近似。</p><h1 id="实战演示">实战演示</h1><p>我以 Shadertoy 上一个混淆过的 <a href="https://www.shadertoy.com/view/WlGyWK">作品</a>为例子来完整展示上面的理论。下面是重新改写后的可读版本，我在注释中解释了每一步的含义：</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/l3cXR7?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe>]]></content>
    
    
    <summary type="html">
&lt;p&gt;本文整理自我 2024/06/14 在上海科技大学数学所的一个小报告，标题是「GPU
涂鸦与数学可视化」。我保留了报告的技术内容，略去了关于 demoscene
和分形文化的部分。&lt;/p&gt;</summary>
    
    
    
    <category term="Shadertoy" scheme="https://pywonderland.com/categories/Shadertoy/"/>
    
    
  </entry>
  
  <entry>
    <title>咖啡杯中的焦散线</title>
    <link href="https://pywonderland.com/envelope-and-caustics/"/>
    <id>https://pywonderland.com/envelope-and-caustics/</id>
    <published>2024-02-08T16:00:00.000Z</published>
    <updated>2025-03-14T15:45:19.690Z</updated>
    
    <content type="html"><![CDATA[<p>春节的晚上，外面鞭炮喧天，家人在看电视，我躲在屋里看数学，还是挺惬意的。</p><p>我看的是 <a href="https://johncarlosbaez.wordpress.com">John Baez</a>和 <a href="https://www.gregegan.net">Greg Egan</a> 的博客。John Baez是一位在科普方面非常高产的数学家，写过不计其数的科普文章。读他的文章非常让人享受，因为他总是从直观的例子入手，一步步启发读者，展开到更高级的数学。GregEgan是澳大利亚的一位非常高产的科幻小说作家，有不少作品已经被国内引入。他的小说属于硬科幻风格，而且是非常硬的那种。他也有不少有趣的<a href="https://www.gregegan.net/SCIENCE/Science.html">博客文章</a>。不过与John Baez 不同的是，Greg Egan的文章不太会去兼顾不同水平的读者，对我来说，要看懂他在说什么经常不是一件容易的事情。</p><p>John Baez 博客上有一个系列 <a href="https://johncarlosbaez.wordpress.com/2012/08/31/rolling-circles-and-balls-part-1/">Rollingcircles and balls</a> 讨论了圆的外摆线和焦散，Greg Egan 也有一篇 <a href="https://www.gregegan.net/SCIENCE/Catacaustics/Catacaustics.html">文章</a>更深入的讨论了曲线的焦散。这个话题非常有意思，我也一时手痒写代码实验了一番并记录在此。</p><span id="more"></span><h1 id="pov-ray-光学实验">POV-Ray 光学实验</h1><p>有一个有趣的物理现象，我想你已经知道了：当光线照在咖啡杯的内壁上时，光线反射以后会形成一个亮斑，术语叫做焦散(caustic)。</p><p><img src="/images/caustics/cup.jpg" class="fig" width="400"></p><p>形成焦散的原因是，光线在杯子内壁反射以后，光子的分布是不均匀的，某些区域经过的光子特别密集，所以亮度就更高。</p><p>焦散是一条曲线，它和所有的反射光线相切。用数学的术语说就是，焦散是所有反射光线的<a href="https://en.wikipedia.org/wiki/Envelope_(mathematics)">包络</a>(envelope)。焦散的具体形状和杯子的形状、光源的位置都有关。如果杯子是圆形的，则当光源是点光源且恰好位于杯子边缘上某一点时，焦散是<a href="https://en.wikipedia.org/wiki/Cardioid">心脏线</a>(cardioid)；当光源位于无穷远时（这时可以视作平行光源），焦散是 <a href="https://en.wikipedia.org/wiki/Nephroid">肾形线</a>(nephroid)。一般情况下焦散的形状介于心脏线和肾形线之间。</p><p>更有意思的是，如果杯子的外形是心脏线，而且光源正好位于心脏线的尖点时，得到的焦散正好是肾形线。我写了一个<a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/catacaustic">POV-Ray脚本</a>，模拟了这一现象：</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr class="odd"><td style="text-align: center;">圆形杯子给出心脏线</td><td style="text-align: center;">心脏线杯子给出肾形线</td></tr><tr class="even"><td style="text-align: center;"><img src="/images/caustics/caustics_cardioid.png" class="fig" width="400"></td><td style="text-align: center;"><img src="/images/caustics/caustics_nephroid.png" class="fig" width="400"></td></tr></tbody></table><p>心脏线和肾形线都是所谓的 <a href="https://en.wikipedia.org/wiki/Epicycloid">外摆线</a>，只是两圆的半径之比不同：</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr class="odd"><td style="text-align: center;">心脏线</td><td style="text-align: center;">肾形线</td></tr><tr class="even"><td style="text-align: center;"><video src="/images/caustics/cardioid.mp4" controls=""></video></td><td style="text-align: center;"><video src="/images/caustics/nephroid.mp4" controls=""></video></td></tr></tbody></table><p>所以我们很容易作出如下的猜想：如果在肾形线的内部或者尖点放一个光源，是不是又会得到下一个外摆线？然而根据Greg Egan 在他博客中的实验，这个应该是不成立的。</p><h1 id="求解参数曲线的焦散">求解参数曲线的焦散</h1><p>这一节我们来介绍怎样计算一般的参数曲线 <span class="math inline">\(\mathbf{c}(t)=(x(t),y(t))\)</span> 的焦散。</p><p>设点光源的位置是 <span class="math inline">\((a,b)\)</span>，则在曲线上点 <span class="math inline">\((x,y)\)</span> 处，入射光线的方向是 <span class="math display">\[\mathbf{l}=(x-a,y-b).\]</span> 这里不需要把 <span class="math inline">\(\mathbf{l}\)</span>单位化，因为我们列方程的时候只需要光线的方向，并不在乎长度。</p><p>同样是在 <span class="math inline">\((x,y)\)</span>处，曲线的法向量是 <span class="math display">\[\mathbf{n}=\frac{(-y',x')}{\sqrt{(x')^2+(y')^2}}=\frac{(-y',x')}{|\mathbf{c}'|}.\]</span> 这里我们用 <span class="math inline">\(x',y'\)</span> 表示 <span class="math inline">\(x,y\)</span> 关于 <span class="math inline">\(t\)</span> 的导数。</p><p>于是 <span class="math inline">\((x,y)\)</span> 处的反射光线的方向<span class="math inline">\(\mathbf{r}\)</span> 由如下反射公式给出：<span class="math display">\[\mathbf{r}= \mathbf{l}- 2(\mathbf{l}\cdot\mathbf{n})\mathbf{n}.\]</span> 设 <span class="math inline">\((X,Y)\)</span> 是反射光线上的任一点，由于 <span class="math inline">\((x,y)\)</span> 是反射光线的起点，所以 <span class="math inline">\((X-x,Y-y)\)</span> 与 <span class="math inline">\(\mathbf{r}\)</span> 平行。记 <span class="math inline">\(\mathbf{r}=(r_x,r_y)\)</span>，则 <span class="math inline">\((X-x,Y-y)\)</span> 与 <span class="math inline">\((-r_y, r_x)\)</span> 垂直，即 <span class="math display">\[(X-x, Y-y)\cdot(-r_y, r_x)=0.\]</span>不要急着把这个式子展开：记 <span class="math display">\[F(X,Y,t)=(X-x,Y-y)\cdot(-r_y, r_x),\]</span> 则我们得到了反射光线 <span class="math inline">\((X(t), Y(t))\)</span> 满足的曲线族方程 <span class="math inline">\(F(X,Y,t)=0\)</span>。于是焦散曲线作为反射曲线的包络，可以通过联立方程组<span class="math display">\[\begin{align}F(X,Y,t)=0,\\\frac{\partialF}{\partial t}F(X,Y,t)=0.\end{align}\]</span> 也就是 <span class="math display">\[\begin{align}(X-x, Y-y)\cdot(-r_y,r_x)&amp;=0,\\-(x',y')\cdot(-r_y, r_x) +(X-x,Y-y)\cdot(-r_y', r_x') &amp;=0.\end{align}\]</span>然后解出 <span class="math inline">\(X,Y\)</span> 得到。</p><p>如果你还记得 2x2矩阵的逆公式的话，这个方程组其实可以目视写出解来。我们把它写成</p><p><span class="math display">\[\begin{pmatrix}-r_y &amp; r_x\\-r_y'&amp;r_x'\end{pmatrix}\cdot\begin{pmatrix}X-x\\Y-y\end{pmatrix}=\begin{pmatrix}0\\r_xy'-r_yx'\end{pmatrix}.\]</span> 于是 <span class="math display">\[\begin{pmatrix}X-x\\Y-y\end{pmatrix}=\begin{pmatrix}-r_y&amp; r_x\\ -r_y'&amp;r_x'\end{pmatrix}^{-1}\begin{pmatrix}0\\r_xy'-r_yx'\end{pmatrix}=\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span> 即 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix} +\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span></p><p>按照上面的理论，我写了一个小脚本，用 <code>sympy</code>(version=1.12) 来计算圆的焦散线。代码中假定圆心是原点，半径为 1，光源在<span class="math inline">\((1,0)\)</span> 处。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>t, X, Y = symbols(<span class="hljs-string">"t X Y"</span>)<br>C = Matrix([cos(t), sin(t)]) <span class="hljs-comment"># curve</span><br>light = Matrix([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]) <span class="hljs-comment"># light source</span><br>l = C - light <span class="hljs-comment"># incident ray</span><br>dx, dy = diff(C, t)<br>n = Matrix([dy, -dx]) <span class="hljs-comment"># normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n)) <span class="hljs-comment"># reflected ray</span><br>F = (Y - y) * r[<span class="hljs-number">0</span>] - (X - x) * r[<span class="hljs-number">1</span>]<br>dF = diff(F, t)<br>result = solve((F, dF), X, Y) <span class="hljs-comment"># solve the envelope</span><br>print(<span class="hljs-string">f"X(t)=<span class="hljs-subst">{trigsimp(result[X], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br>print(<span class="hljs-string">f"Y(t)=<span class="hljs-subst">{trigsimp(result[Y], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 给出的结果是：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X(t)=<span class="hljs-number">2</span>*cos(t)/<span class="hljs-number">3</span> + cos(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span><br>Y(t)=<span class="hljs-number">2</span>*sin(t)/<span class="hljs-number">3</span> + sin(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>这正是喜闻乐见的心脏线的参数表示： <span class="math display">\[\left\{\begin{align}x(t)&amp;=\frac{\cos(2t) +2\cos(t)}{3},\\ y(t)&amp;=\frac{\sin(2t) +2\sin(t)}{3}.\end{align}\right.\]</span></p><p>使用这个参数表示，我们继续计算当光源放在心脏线的尖点，即 <span class="math inline">\(t=\pi\)</span> 对应的点 <span class="math inline">\((-\frac{1}{3},0)\)</span> 时得到的焦散：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>t, X, Y = symbols(<span class="hljs-string">"t X Y"</span>)<br>C = Matrix([(<span class="hljs-number">2</span>*cos(t) + cos(<span class="hljs-number">2</span>*t)) / <span class="hljs-number">3</span>, (<span class="hljs-number">2</span>*sin(t) + sin(<span class="hljs-number">2</span>*t)) / <span class="hljs-number">3</span>])<br>light = Matrix([S(<span class="hljs-string">'-1/3'</span>, evaluate=<span class="hljs-literal">False</span>), <span class="hljs-number">0</span>])<br>l = C - light <span class="hljs-comment"># incident ray</span><br>dx, dy = diff(C, t)<br>n = Matrix([dy, -dx]) <span class="hljs-comment"># normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n)) <span class="hljs-comment"># reflected ray</span><br>F = (Y - y) * r[<span class="hljs-number">0</span>] - (X - x) * r[<span class="hljs-number">1</span>]<br>dF = diff(F, t)<br>result = solve((F, dF), X, Y) <span class="hljs-comment"># solve the envelope</span><br>print(<span class="hljs-string">f"X(t)=<span class="hljs-subst">{trigsimp(result[X], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br>print(<span class="hljs-string">f"Y(t)=<span class="hljs-subst">{trigsimp(result[Y], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 很快算出了正确的结果：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X(t)=sin(t)*sin(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span> + cos(t)/<span class="hljs-number">3</span><br>Y(t)=-sin(t)*cos(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span> + sin(t)/<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>不难验证</p><p><span class="math display">\[\begin{align}\frac{\sin(t)\sin(2t) +\cos(t)}{3}&amp;=\frac{3\cos(t) - \cos(3t)}{6},\\ \frac{-\sin(t)\cos(2t)+ \sin(t)}{3}&amp;=\frac{3\sin(t) -\sin(3t)}{6}.\end{align}\]</span></p><p>这正是 <a href="https://en.wikipedia.org/wiki/Nephroid#Parametric">维基百科</a>中所列的肾形线的参数方程中取 <span class="math inline">\(a=1/6\)</span>的结果。</p><p>把上面的曲线画出来是这样的：</p><p><img src="/images/caustics/caustics_matplotlib.svg" class="fig" width="400"></p><h1 id="求解多项式曲线的焦散">求解多项式曲线的焦散</h1><p>很多时候曲线的方程是通过隐函数 <span class="math inline">\(P(x,y)=0\)</span> 的形式给出的，其中 <span class="math inline">\(P(x,y)\)</span> 是关于两个变元 <span class="math inline">\(x,y\)</span>的多项式。这样的曲线叫做平面代数曲线。这时求解焦散要用到 Gröbner基的工具。</p><p>让我们回到参数方程的情形，我们已经看到，这时焦散 <span class="math inline">\((X,Y)\)</span> 有显式解</p><p><span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix} +\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span></p><p>其中 <span class="math inline">\(x,y,r_x,r_y\)</span> 都是关于 <span class="math inline">\(t\)</span>的函数，它们的导数也是可计算的，所以可以算出 <span class="math inline">\((X,Y)\)</span> 来。</p><p>但是在隐函数的情形，我们没有 <span class="math inline">\(x,y\)</span>的某种关于 <span class="math inline">\(t\)</span>的表达式。不过没关系，我们先假设有这样的参数表达式，看看能得到什么结论。设<span class="math inline">\(x=x(t),y=y(t)\)</span> 是某个参变元 <span class="math inline">\(t\)</span> 的函数，在 <span class="math inline">\(P(x,y)=0\)</span> 两边对 <span class="math inline">\(t\)</span> 求导可得 <span class="math display">\[\frac{\partial P}{\partial t}=\frac{\partialP}{\partial x}x'(t) + \frac{\partial P}{\partialy}y'(t)=0.\]</span> 记 <span class="math inline">\(k=-\frac{\partialP}{\partial x}/\frac{\partial P}{\partial y}\)</span>，则 <span class="math inline">\(y'(t)=kx'(t)\)</span>。</p><p>对反射光线 <span class="math inline">\(\mathbf{r}\)</span> 的两个分量<span class="math inline">\(r_x,r_y\)</span> 也分别使用链式求导，我们有<span class="math display">\[\begin{align}\frac{\partial r_x}{\partialt}&amp;=\frac{\partial r_x}{\partial x}x'(t) + \frac{\partialr_x}{\partial y}y'(t),\\\frac{\partial r_y}{\partial t}&amp;=\frac{\partial r_y}{\partialx}x'(t) + \frac{\partial r_y}{\partialy}y'(t).\end{align}\]</span> 于是我们发现比值 <span class="math display">\[\begin{align}\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}&amp;=\frac{r_xk-r_y}{r_y(\frac{\partialr_x}{\partial x}+\frac{\partial r_x}{\partial y}k)-r_x(\frac{\partialr_y}{\partial x} + \frac{\partial r_y}{\partial y}k)}\\&amp;=-\frac{r_x\frac{\partial P}{\partial x}+r_y\frac{\partialP}{\partial y}}{r_y(\frac{\partial r_x}{\partial x}\frac{\partialP}{\partial y}-\frac{\partial r_x}{\partial y}\frac{\partial P}{\partialx})-r_x(\frac{\partial r_y}{\partial x}\frac{\partial P}{\partial y} -\frac{\partial r_y}{\partial y}\frac{\partial P}{\partial x})}.\end{align}\]</span> 变成了一个不需要显式用到 <span class="math inline">\(t\)</span> 的量，即变量 <span class="math inline">\(t\)</span> “消掉”了。代入上面焦散的表达式中，我们得到 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix}-\frac{r_x\frac{\partialP}{\partial x}+r_y\frac{\partial P}{\partial y}}{r_y(\frac{\partialr_x}{\partial x}\frac{\partial P}{\partial y}-\frac{\partialr_x}{\partial y}\frac{\partial P}{\partial x})-r_x(\frac{\partialr_y}{\partial x}\frac{\partial P}{\partial y} - \frac{\partialr_y}{\partial y}\frac{\partial P}{\partial x})}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span> 这个式子还可以再简化一点：注意到曲线在 <span class="math inline">\((x,y)\)</span> 处的法向量由 <span class="math inline">\(\mathbf{n}=\frac{\nabla P}{|\nabla P|}\)</span>给出，其中 <span class="math inline">\(\nabla P=(\frac{\partialP}{\partial x},\frac{\partial P}{\partial y})\)</span>。于是由 <span class="math display">\[\mathbf{r}= \mathbf{l}- 2(\mathbf{l}\cdot\mathbf{n})\mathbf{n}\]</span> 可得 <span class="math display">\[\mathbf{r}\cdot \nabla P=-\mathbf{l}\cdot \nablaP.\]</span> 从而 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix}+\frac{\mathbf{l}\cdot\nablaP}{r_y(\frac{\partial r_x}{\partial x}\frac{\partial P}{\partialy}-\frac{\partial r_x}{\partial y}\frac{\partial P}{\partialx})-r_x(\frac{\partial r_y}{\partial x}\frac{\partial P}{\partial y} -\frac{\partial r_y}{\partial y}\frac{\partial P}{\partialx})}\begin{pmatrix}r_x\\ r_y\end{pmatrix}.\]</span></p><p>这是四个变量 <span class="math inline">\(x,y,X,Y\)</span>满足的两个方程，形如 <span class="math inline">\(F(X,x,y)=0\)</span> 和<span class="math inline">\(G(Y,x,y)=0\)</span>。记住我们还有已知的方程<span class="math inline">\(P(x,y)=0\)</span>。为了从这三个方程中消掉<span class="math inline">\(x,y\)</span>，得到一个仅包含 <span class="math inline">\((X,Y)\)</span> 的表达式，我们可以尝试用 <a href="https://en.wikipedia.org/wiki/Gr%C3%B6bner_basis">Gröbnerbasis</a> 方法。Gröbner 基方法会把多项式方程组 <span class="math display">\[F=G=P=0\]</span> 转化为一组等价的新方程组 <span class="math display">\[g_1=g_2=\cdots=g_m=0.\]</span>即它们有完全相同的解集。</p><p><span class="math inline">\(\{g_1,\ldots,g_m\}\)</span> 是 <span class="math inline">\(F,G,P\)</span> 在多项式环 <span class="math inline">\(\mathbb{R}[x,y,X,Y]\)</span> 中生成的理想 <span class="math inline">\(I=\langle F,G,P\rangle\)</span>的一组生成元，<span class="math inline">\(\{g_1,\ldots,g_m\}\)</span>叫做 <span class="math inline">\(I\)</span> 的约化的 Gröbner基。在字典序 <span class="math inline">\(x\succ y\succ X\succ Y\)</span>下，约化的 Gröbner 基会有一个好的属性，即从 <span class="math inline">\(g_1\)</span> 到 <span class="math inline">\(g_m\)</span>，其中的变元会按照从 <span class="math inline">\(x\to y\to X\to Y\)</span>的先后顺序被消除掉。注意这是个不太严格的说法，我们并不是总能消掉顺序靠前的变元，但是如果消除发生的话，它就会按照这个顺序来。这样我们就可以执行类似高斯消元法中的回代操作，从而新方程组的求解会更加简单。</p><p>我们来用 <code>sympy</code> 实验一下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>x, y, X, Y = symbols(<span class="hljs-string">"x y X Y"</span>)<br>P = x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>dx = diff(P, x)  <span class="hljs-comment"># gradient of P</span><br>dy = diff(P, y)<br>curve = Matrix([x, y])<br>light_source = Matrix([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>l = curve - light_source  <span class="hljs-comment"># the incident ray</span><br>n = Matrix([dx, dy])  <span class="hljs-comment"># the normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n))  <span class="hljs-comment"># the reflected ray</span><br>rx, ry = r<br>dxrx = diff(rx, x)<br>dyrx = diff(rx, y)<br>dxry = diff(ry, x)<br>dyry = diff(ry, y)<br>denominator = ry * (dxrx * dy - dyrx * dx) - rx * (dxry * dy - dyry * dx)<br>nominator = dx * l[<span class="hljs-number">0</span>] + dy * l[<span class="hljs-number">1</span>]<br>F = (X - x) * denominator - nominator * rx<br>G = (Y - y) * denominator - nominator * ry<br>eqs = [eq.as_numer_denom()[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> eq <span class="hljs-keyword">in</span> [F, G, P]]<br>gb = groebner(eqs, [x, y, X, Y])<br>print(gb)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 给出的结果的最后一项是</p><p><span class="math display">\[27 X^{4} y^{2} + 54 X^{2} Y^{2} y^{2} -18 X^{2} y^{2} - 8 X y^{2} + 27 Y^{4} y^{2} - 18 Y^{2} y^{2} -y^{2}.\]</span></p><p><span class="math inline">\(x\)</span> 被消掉了！原方程组 <span class="math inline">\(F=G=P\)</span>的解必然是上面这个方程的解的子集。观察它的每一项都带有一个 <span class="math inline">\(y^2\)</span>，这显然不是我们要的解。把 <span class="math inline">\(y^2\)</span> 去掉，剩下的因子</p><p><span class="math display">\[27X^{4}+54X^{2}Y^{2}-18X^{2} -8X +27Y^{4}-18Y^{2}-1=0.\]</span></p><p>就是心脏线的隐函数表示。不信？在 <a href="https://www.desmos.com/geometry/vtjbq3ete1">Desmos</a>里面画出来看看！</p><p><img src="/images/caustics/desmos_cardioid.png" class="fig" width="300"></p><h1 id="后记">后记</h1><p>这篇文章主要覆盖了 Greg Egan博文的前半部分，他的后半部分内容我觉得有点放飞自我，也没怎么仔细看。</p><p>虽然我们用 <code>sympy</code>的实验很成功，但注意并不是所有情况下都能得到焦散曲线（比如光源位于抛物线的焦点时，反射光线都是平行的），而且对复杂的曲线<code>sympy</code> 算起来非常慢。</p><p>我研究生的时候上过计算机代数的课程，当时用的教学软件是 Maple。Maple编程是很不方便的，所以我其实没有多少计算机代数的编程经验。我之前一直觉得<code>sympy</code>运行又慢，输出的表达式也不够简化，所以不太愿意用它。这次实验有点刷新我对<code>sympy</code>的认知。我还记得当时课程要求每人提交一份读书报告，我写的是 <a href="https://link.springer.com/book/10.1007/978-3-319-16721-3">Ideals,Varieties, and Algorithms</a> 的笔记，但毕业多年以来这还是我第一次用到Gröbner 基！</p><p>我写这篇文章的时候正好临近情人节，所以我在想有没有什么曲线的焦散能给出<a href="https://www.desmos.com/geometry/ngdpq0zrei">爱心曲线</a>：</p><p><img src="/images/caustics/heart.png" class="fig" width="300"></p><p>于是我找到了 <a href="https://www.tandfonline.com/doi/full/10.1080/00029890.2020.1722019">这篇文章</a>。不过看起来里面给出的结论计算量很大，很难用在爱心线上（也许是我错了）。</p>]]></content>
    
    
    <summary type="html">
&lt;p&gt;春节的晚上，外面鞭炮喧天，家人在看电视，我躲在屋里看数学，还是挺惬意的。&lt;/p&gt;
&lt;p&gt;我看的是 &lt;a href=&quot;https://johncarlosbaez.wordpress.com&quot;&gt;John Baez&lt;/a&gt;
和 &lt;a href=&quot;https://www.gregegan.net&quot;&gt;Greg Egan&lt;/a&gt; 的博客。John Baez
是一位在科普方面非常高产的数学家，写过不计其数的科普文章。读他的文章非常让人享受，因为他总是从直观的例子入手，一步步启发读者，展开到更高级的数学。Greg
Egan
是澳大利亚的一位非常高产的科幻小说作家，有不少作品已经被国内引入。他的小说属于硬科幻风格，而且是非常硬的那种。他也有不少有趣的
&lt;a href=&quot;https://www.gregegan.net/SCIENCE/Science.html&quot;&gt;博客文章&lt;/a&gt;。不过与
John Baez 不同的是，Greg Egan
的文章不太会去兼顾不同水平的读者，对我来说，要看懂他在说什么经常不是一件容易的事情。&lt;/p&gt;
&lt;p&gt;John Baez 博客上有一个系列 &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2012/08/31/rolling-circles-and-balls-part-1/&quot;&gt;Rolling
circles and balls&lt;/a&gt; 讨论了圆的外摆线和焦散，Greg Egan 也有一篇 &lt;a href=&quot;https://www.gregegan.net/SCIENCE/Catacaustics/Catacaustics.html&quot;&gt;文章&lt;/a&gt;
更深入的讨论了曲线的焦散。这个话题非常有意思，我也一时手痒写代码实验了一番并记录在此。&lt;/p&gt;</summary>
    
    
    
    <category term="pywonderland 项目" scheme="https://pywonderland.com/categories/pywonderland-%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>Möbius 变换与球的刚体运动</title>
    <link href="https://pywonderland.com/mobius-ball-rigid-motion/"/>
    <id>https://pywonderland.com/mobius-ball-rigid-motion/</id>
    <published>2022-05-07T16:00:00.000Z</published>
    <updated>2024-08-10T10:22:21.061Z</updated>
    
    <content type="html"><![CDATA[<p>五一期间我写了一个 shadertoy 小动画，演示 Möbius变换与球的刚体运动之间的关系：</p><span id="more"></span><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/fljfRm?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><p>这个动画的名字叫做 Möbius transformation revealed，想法源自 DouglasN. Arnold 和 Jonathan Rogness 于 2007 年发布的 <a href="https://www-users.cse.umn.edu/~arnold/moebius/">同名视频</a>。这是一个很有名的视频，它表达的核心思想是，扩充复平面<span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的 Möbius变换可以由球在三维空间中的刚体运动给出：</p><ol type="1"><li>我们称一个球 <span class="math inline">\(S\)</span>是<strong>容许</strong>的，如果 <span class="math inline">\(S\)</span>的最高点，也就是北极点位于半空间 <span class="math inline">\(\{z&gt;0\}\)</span> 中。</li><li>取任何一个可容许的球 <span class="math inline">\(S\)</span>，将<span class="math inline">\(\overline{\mathbb{C}}\)</span>在逆球极投影下对应到 <span class="math inline">\(S\)</span>的球面上。</li><li>对 <span class="math inline">\(S\)</span> 作刚体变换 （平移和旋转）<span class="math inline">\(S\to T(S)\)</span>，使得 <span class="math inline">\(T(S)\)</span> 也是一个容许的球，即 <span class="math inline">\(T(S)\)</span> 的最高点也在半空间 <span class="math inline">\(\{z&gt;0\}\)</span> 中。</li><li>将 <span class="math inline">\(T(S)\)</span>的表面通过球极投影再映射回 <span class="math inline">\(\overline{\mathbb{C}}\)</span>，我们就得到了一个<span class="math inline">\(\overline{\mathbb{C}}\to\overline{\mathbb{C}}\)</span>的变换，此变换是一个 Möbius 变换，且所有 Möbius变换都可以通过此种方式得到。</li></ol><p>整个过程如下所示：</p><p><span class="math display">\[\underbrace{\overline{\mathbb{C}}\xrightarrow{\text{inversestereographic projection}} S\xrightarrow{\text{rigid motion}}T(S)\xrightarrow{\text{stereographicprojection}}\overline{\mathbb{C}}}_{\text{Möbiustransformation}}.\]</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>球极投影使用的北极点始终是球面的最高点。</p></div><p>详细的解释可以见原视频的解释 <a href="https://www-users.cse.umn.edu/~arnold/papers/moebius.pdf">文章</a>。但是从直观上理解也不难：</p><ul><li><p><span class="math inline">\(S\)</span> 在 <span class="math inline">\(xy\)</span> 平面内的平移给出的是 <span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的平移。<video src="/images/mobius/translation.mp4" height="300" controls=""></video></p></li><li><p><span class="math inline">\(S\)</span> 在 <span class="math inline">\(z\)</span> 方向上的平移给出的是 <span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的缩放。<video src="/images/mobius/scale.mp4" height="300" controls=""></video></p></li><li><p>保持 <span class="math inline">\(S\)</span>的北极点不动的旋转给出的是 <span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的旋转。<video src="/images/mobius/rotation.mp4" height="300" controls=""></video></p></li><li><p>绕 <span class="math inline">\(x\)</span> 轴旋转 180 度给出的是<span class="math inline">\(\overline{\mathbb{C}}\)</span> 上的逆变换<span class="math inline">\(z\to 1/z\)</span>。<video src="/images/mobius/inversion.mp4" height="300" controls=""></video></p></li></ul><p>以上几种运动方式的复合可以给出可容许球的任何刚体运动，而任何 Möbius变换都是平移、缩放、旋转、逆变换的复合，所以 Möbius变换确实与可容许球体的刚体运动是对应的。</p><p>反过来对给定的 Möbius 变换 <span class="math inline">\(M\)</span>和容许的球 <span class="math inline">\(S\)</span>，当 <span class="math inline">\(S\)</span> 的初始位置确定以后，给出 <span class="math inline">\(M\)</span> 的刚体运动 <span class="math inline">\(T\)</span> 也是唯一确定的。证明见 <a href="https://scholar.rose-hulman.edu/cgi/viewcontent.cgi?article=1218&amp;context=rhumj">这个论文</a>。</p>]]></content>
    
    
    <summary type="html">
&lt;p&gt;五一期间我写了一个 shadertoy 小动画，演示 Möbius
变换与球的刚体运动之间的关系：&lt;/p&gt;</summary>
    
    
    
    <category term="可视化复分析" scheme="https://pywonderland.com/categories/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%8D%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Möbius 变换与二维 Poincaré 双曲空间的等距</title>
    <link href="https://pywonderland.com/mobius-poincare/"/>
    <id>https://pywonderland.com/mobius-poincare/</id>
    <published>2022-03-21T16:00:00.000Z</published>
    <updated>2024-11-23T04:55:27.885Z</updated>
    
    <content type="html"><![CDATA[<p>这几天因为疫情居家观察难得多出点时间（不用健步挤地铁），可以写点小文章。我之前写过一篇介绍<a href="/mobius-h3space">Möbius变换分类的文章</a>，今天继续那里的讨论，介绍一个 Möbius 变换 <span class="math inline">\(M\)</span> 作为二维 Poincaré 双曲圆盘 <span class="math inline">\(\mathbb{D}\)</span> 中等距的两种构造方法：</p><ol type="1"><li>指定 <span class="math inline">\(M\)</span>的不动点的个数和位置，不动点的个数和位置可以决定变换的类型。</li><li>指定两个反射镜面的位置：取两条测地线作为镜面，则关于这两个镜面的反演变换的复合变换就是一个Möbius 变换。两个镜面的相对位置可以决定变换的类型。</li></ol><p>这两种方法分别对应在 <span class="math inline">\(M\)</span>作用下保持不变的两个圆族。</p><p>本文的插图使用 <a href="https://matplotlib.org/">matplotlib</a>绘制，代码在 <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/mobius">Github</a>上。</p><span id="more"></span><p>记号约定：</p><ul><li><span class="math inline">\(\mathbb{D}\)</span> 为二维 Poincaré双曲圆盘。</li><li><span class="math inline">\(M\)</span> 为一个 Möbius 变换。</li><li><span class="math inline">\(S^1\)</span> 为单位圆周 <span class="math inline">\(|z|=1\)</span>。</li></ul><h1 id="用不动点构造双曲等距">用不动点构造双曲等距</h1><p>在复分析课程中，我们学过 <span class="math inline">\(\mathbb{D}\)</span> 的保持定向的等距同构是 Möbius群 <span class="math inline">\({\rm PSL}_2(\mathbb{C})\)</span>的一个子群，其元素具有如下的形式： <span class="math display">\[M(z) =\mathrm{e}^{i\theta}\frac{z - a}{1-\overline{a}z},\quad\theta\in\mathbb{R},\, |a|&lt;1.\]</span> 可见 <span class="math inline">\(M\)</span> 的迹 <span class="math inline">\(\mathrm{tr}(M)=\mathrm{e}^{i\theta}+1\)</span>总是满足 <span class="math inline">\(0\leq|\mathrm{tr}(M)|\leq2\)</span>，所以 <span class="math inline">\(M\)</span> 不可能是斜航型的 (loxodromic)，从而<span class="math inline">\(\mathbb{D}\)</span>的保持等向的等距只能是椭圆、抛物、双曲三种。</p><p>也可以这样解释：<span class="math inline">\(\mathbb{D}\)</span>的任何等距变换必然将 <span class="math inline">\(S^1\)</span> 仍然映射为<span class="math inline">\(S^1\)</span>，但斜航型的变换没有不变圆，所以不可能是<span class="math inline">\(\mathbb{D}\)</span> 上的等距变换。</p><p>下面分别介绍这三种情形。</p><h2 id="椭圆型">椭圆型</h2><p>椭圆型变换共轭于旋转 <span class="math inline">\(z\to\mathrm{e}^{i\theta}z\)</span>，它们总是有两个不动点。如果<span class="math inline">\(M\)</span> 是 <span class="math inline">\(\mathbb{D}\)</span> 上的椭圆型等距，则其两个不动点<span class="math inline">\(p_1,\,p_2\)</span> 必然一个在 <span class="math inline">\(\mathbb{D}\)</span> 内，一个在 <span class="math inline">\(\mathbb{D}\)</span>外，且它们关于单位圆互为反演点。设 <span class="math inline">\(p_1\in\mathbb{D}\)</span>，则 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\mathbb{D}\)</span> 上的作用是一个绕着 <span class="math inline">\(p_1\)</span> 的旋转：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/mobius/elliptic.svg"></p><p>图中画出了两族圆：</p><ol type="1"><li>第一族圆是彩色的，它们在双曲度量下的中心都是 <span class="math inline">\(p_1\)</span>，<span class="math inline">\(M\)</span> 保持每个圆不变，同时将圆上的每个点绕着<span class="math inline">\(p_1\)</span> 旋转。</li><li>第二族圆用虚线标注，这些圆都和第一族圆正交、同时经过 <span class="math inline">\(p_1\)</span> 和 <span class="math inline">\(p_2\)</span>，并且都与单位圆正交。<span class="math inline">\(M\)</span>作用在这些圆上会把一个圆变成同族中的另一个。</li></ol><p>双曲空间中的圆也是欧氏空间中的圆，但是它们的圆心未必重合。一个 <span class="math inline">\(\mathbb{D}\)</span>中的圆越靠近边界，它的双曲度量下的圆心也会被「吸引」到靠近边界的位置。</p><h2 id="抛物型">抛物型</h2><p>抛物型变换共轭于平移 <span class="math inline">\(z\toz+1\)</span>，它们总是只有一个不动点。如果 <span class="math inline">\(M\)</span> 是 <span class="math inline">\(\mathbb{D}\)</span>上的抛物型等距，则其唯一的不动点 <span class="math inline">\(p\)</span>必然位于单位圆周 <span class="math inline">\(S^1\)</span> 上，<span class="math inline">\(M\)</span> 在 <span class="math inline">\(\mathbb{D}\)</span>上的作用是一个双曲空间中的平移：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/mobius/parabolic.svg"></p><p>图中也画出了两族圆：</p><ol type="1"><li>第一族圆是彩色的，它们都和 <span class="math inline">\(S^1\)</span>在 <span class="math inline">\(p\)</span> 点处相切。<span class="math inline">\(M\)</span>作用在它们上面保持每个圆不变，同时将圆上的每个点沿着测地线向着 <span class="math inline">\(p\)</span> 移动。这些圆叫做horocycle，它们在双曲度量下的圆心是 <span class="math inline">\(p\)</span>。</li><li>第二族圆用虚线标注，这些圆都和第一族圆正交、互相之间也在 <span class="math inline">\(p\)</span> 点相切，并且都与单位圆正交。<span class="math inline">\(M\)</span>作用在这些圆上会把一个圆变成同族中的另一个。</li></ol><h2 id="双曲型">双曲型</h2><p>双曲型变换共轭于缩放 <span class="math inline">\(z\tocz,\,c\in\mathbb{R}^+\)</span>，它们总是有两个不动点。如果 <span class="math inline">\(M\)</span> 是 <span class="math inline">\(\mathbb{D}\)</span> 上的双曲型等距，则其两个不动点<span class="math inline">\(p_1,p_2\)</span> 必然都位于单位圆周 <span class="math inline">\(S^1\)</span> 上。<span class="math inline">\(M\)</span> 在 <span class="math inline">\(\mathbb{D}\)</span>上的作用以其中一个为源点，另一个为汇点：</p><p><img style="margin:0px auto;display:block" width="400" src="/images/mobius/hyperbolic.svg"></p><p>图中的两族圆中，</p><ol type="1"><li>第一族圆是彩色的，它们同时经过 <span class="math inline">\(p_1\)</span> 和 <span class="math inline">\(p_2\)</span>，<span class="math inline">\(M\)</span>作用在它们上面保持每个圆不变，同时将圆上的每个点沿着圆给出的测地线从源点移动到汇点。</li><li>第二族圆用虚线标注，这些圆都和第一族圆正交、<span class="math inline">\(p_1\)</span> 和 <span class="math inline">\(p_2\)</span>关于它们中的每一个都互为反演点，并且都与单位圆正交。<span class="math inline">\(M\)</span>作用在这些圆上会把一个圆变成同族中的另一个。</li></ol><h1 id="用反演变换的复合构造双曲等距">用反演变换的复合构造双曲等距</h1><p>在上面的三张图中，彩色的圆对应的是 <span class="math inline">\(\mathbb{D}\)</span> 中的点在 <span class="math inline">\(M\)</span>作用下的轨迹，它们都是测地线。我似乎有意冷落了虚线的圆族，把它们画的很不起眼。其实通过它们的反演变换也可以给出<span class="math inline">\(M\)</span> 的构造：</p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr class="odd"><td style="text-align: center;">椭圆型</td><td style="text-align: center;">抛物型</td><td style="text-align: center;">双曲型</td></tr><tr class="even"><td style="text-align: center;"><img src="/images/mobius/elliptic2.svg" width="180"></td><td style="text-align: center;"><img src="/images/mobius/parabolic2.svg" width="180"></td><td style="text-align: center;"><img src="/images/mobius/hyperbolic2.svg" width="180"></td></tr></tbody></table><div class="statement simple plain unnumbered"><ul><li><span class="math inline">\(M\)</span>是椭圆型的，当且仅当它是两个在 <span class="math inline">\(\mathbb{D}\)</span>中<strong>相交</strong>的圆的反演变换的复合。</li><li><span class="math inline">\(M\)</span>是抛物型的，当且仅当它是两个在 <span class="math inline">\(\mathbb{D}\)</span>中<strong>平行</strong>的圆的反演变换的复合。这里平行的意思是两圆相切，且切点位于无穷远边界上。</li><li><span class="math inline">\(M\)</span>是双曲型的，当且仅当它是两个在 <span class="math inline">\(\mathbb{D}\)</span>中<strong>超平行</strong>的圆的反演变换的复合。这里超平行的意思是它们要么不相交，要么一个完全位于另一个的内部。</li></ul></div><p>放到上半空间模型中，这些就都不难理解了：</p><ul><li>椭圆型变换共轭于绕原点的角度为 <span class="math inline">\(\theta\)</span> 的旋转，此旋转是关于两个夹角为<span class="math inline">\(\theta/2\)</span> 的直线反射的复合。</li><li>抛物型变换共轭于平移 <span class="math inline">\(T:z\to z +1\)</span>，<span class="math inline">\(T\)</span>是上半双曲空间模型中的等距，它可以表示为关于两平行直线 <span class="math inline">\(x=0\)</span> 和 <span class="math inline">\(x=1/2\)</span>的反射的复合。我们可以用一个上半空间到 <span class="math inline">\(\mathbb{D}\)</span>的等距变换把实轴变成单位圆周，并把 <span class="math inline">\(\infty\)</span> 点变到边界上的指定点 <span class="math inline">\(p\)</span>。这时所有形如 <span class="math inline">\(x=k\)</span> 的直线，由于它们都经过 <span class="math inline">\(\infty\)</span>、互相平行、与实轴正交，所以都会变成过<span class="math inline">\(p\)</span> 点、两两相切于 <span class="math inline">\(p\)</span>、且与单位圆正交的圆。在这些圆中任取两个圆，作它们反演变换的复合，给出的就是一个抛物型变换。</li><li>双曲型变换共轭于缩放 <span class="math inline">\(S:z\tocz,\,c&gt;0\)</span>，<span class="math inline">\(S\)</span>是上半空间模型中两个同心圆 <span class="math inline">\(|z|=1\)</span> 和<span class="math inline">\(|z|=\sqrt{c}\)</span>的反演变换的复合。<span class="math inline">\(S\)</span>的两个不动点是原点和无穷远点，它们关于这两个同心圆互为反演点。同理我们可以用一个从上半空间到<span class="math inline">\(\mathbb{D}\)</span>的等距变换把实轴变成单位圆，并把原点和无穷远点分别映射到单位圆周上指定的两个不动点。这两个同心圆会被映射为<span class="math inline">\(\mathbb{D}\)</span>中的两条测地线。关于这两条测地线的反演的复合就共轭于上半空间模型中的缩放。</li></ul><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>为什么两个圆的反演变换的复合是一个 Möbius 变换？你可以用一个Möbius 变换 <span class="math inline">\(T\)</span> 将任意给定的圆 <span class="math inline">\(C\)</span> 变为实直线 <span class="math inline">\(\mathbb{R}^1\)</span>，关于 <span class="math inline">\(\mathbb{R}^1\)</span> 的反演就是复共轭 <span class="math inline">\(\mathrm{conj}(z)=\overline{z}\)</span>，所以关于<span class="math inline">\(C\)</span> 的反演为 <span class="math inline">\(S=T^{-1}\cdot\mathrm{conj}\cdot T\)</span>，从而<span class="math inline">\(S\)</span> 形如 <span class="math display">\[S(z) = \frac{a\overline{z} +b}{c\overline{z}+d},\quada,b,c,d\in\mathbb{C},\,z\in\mathbb{C}_{\infty}.\]</span>里面包含了复共轭，所以 <span class="math inline">\(S\)</span> 不是Möbius 变换，但两个反演变换的复合就是 Möbius 变换。</p></div>]]></content>
    
    
    <summary type="html">
&lt;p&gt;这几天因为疫情居家观察难得多出点时间（不用健步挤地铁），可以写点小文章。我之前写过一篇介绍
&lt;a href=&quot;/mobius-h3space&quot;&gt;Möbius
变换分类的文章&lt;/a&gt;，今天继续那里的讨论，介绍一个 Möbius 变换 &lt;span class=&quot;math inline&quot;&gt;&#92;(M&#92;)&lt;/span&gt; 作为二维 Poincaré 双曲圆盘 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathbb{D}&#92;)&lt;/span&gt; 中等距的两种构造方法：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;指定 &lt;span class=&quot;math inline&quot;&gt;&#92;(M&#92;)&lt;/span&gt;
的不动点的个数和位置，不动点的个数和位置可以决定变换的类型。&lt;/li&gt;
&lt;li&gt;指定两个反射镜面的位置：取两条测地线作为镜面，则关于这两个镜面的反演变换的复合变换就是一个
Möbius 变换。两个镜面的相对位置可以决定变换的类型。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两种方法分别对应在 &lt;span class=&quot;math inline&quot;&gt;&#92;(M&#92;)&lt;/span&gt;
作用下保持不变的两个圆族。&lt;/p&gt;
&lt;p&gt;本文的插图使用 &lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt;
绘制，代码在 &lt;a href=&quot;https://github.com/neozhaoliang/pywonderland/tree/master/src/mobius&quot;&gt;Github&lt;/a&gt;
上。&lt;/p&gt;</summary>
    
    
    
    <category term="可视化复分析" scheme="https://pywonderland.com/categories/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%8D%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>DIY 多面体镜面万花筒</title>
    <link href="https://pywonderland.com/polyhedron-mirrors/"/>
    <id>https://pywonderland.com/polyhedron-mirrors/</id>
    <published>2022-01-10T16:00:00.000Z</published>
    <updated>2024-06-16T06:10:55.182Z</updated>
    
    <content type="html"><![CDATA[<p>前几天在网上看到了一位艺术家 <a href="https://www.operagallery.com/artist/anthony-james">AnthonyJames</a>的展览作品，使用多面体和镜子生成万花筒的效果，觉得很有意思：</p><span id="more"></span><video src="/images/polyhedra-mirrors/anthony-james.mp4" width="600" controls=""></video><p>这个作品的大致原理是：</p><ol type="1"><li>多面体的外壳是半透明的玻璃，有一定的透光率。</li><li>多面体的每条边的内侧安装了 LED 光源。</li><li>光源发出的光线在多面体内部反复反射，每次反射时由于玻璃是半透明的，一部分光线会被反射回内部，另一部分光线穿过外壳被外部观察到。镜子的透光率越低，光线在穿过外壳之前被反射的次数就越多，看到的图案就显得越“深邃”。</li></ol><p>YouTube 上有个博主手把手地展示了怎样从头 DIY 一个这样的模型：<a href="https://youtu.be/65r_1TzJXaQ">视频地址</a>。我表示这顿操作虽然看着不算难，但对我这种懒人来说还是有点过于折腾了。</p><p>不过没关系，咱可以编程实现呀。我写了一个 shadertoy 演示：</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/ctVGRR?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><p>这个动画支持除了 snub 和 antiprism之外各种类型的均匀凸多面体及其对偶。下面的动画演示的是菱形十二面体 (<a href="https://en.wikipedia.org/wiki/Rhombic_dodecahedron">rhombicdodecahedron</a>)，它有个独特之处是自身在镜子反射下成的像可以密铺整个空间(space filling)。</p><object data="/code/rhombic-dodecahedron.svg"></object><p>石榴籽的形状就近似于菱形十二面体，这使得它们可以紧紧的挨在一起构成密铺的结构：</p><p><img style="margin:0px auto;display:block" src="/images/polyhedra-mirrors/pomegranate.jpeg" width="400"></p><p>这种可以密铺整个空间的多面体非常少，正方体当然是其中之一，但是其它的正多面体（正四面体、正八面体、正十二面体、正二十面体） 都不行。</p><p>值得注意的是，身处多面体内部和外部的观察者，看到的景象可能是不同的。</p><p>例如上面的菱形十二面体从内部看起来，有些胞腔从中间被劈开了：</p><p><img style="margin:0px auto;display:block" src="/images/polyhedra-mirrors/error1.png" width="500"></p><p>甚至即便只从外部观察，从不同类型的镜面看到的景象也是不同的。例如截顶的正方体，从八边形的镜面看进去，内部是密铺了整个空间的：</p><object data="/code/trunc-cube.svg"></object><p>但是如果从三角形的面往里看，会发现镜子中的四面体由近到远方向是交错改变的：</p><p><img style="margin:0px auto;display:block" src="/images/polyhedra-mirrors/error2.png" width="500"></p><p>请你思考一下，这些背后的原因是什么？</p>]]></content>
    
    
    <summary type="html">
&lt;p&gt;前几天在网上看到了一位艺术家 &lt;a href=&quot;https://www.operagallery.com/artist/anthony-james&quot;&gt;Anthony
James&lt;/a&gt;
的展览作品，使用多面体和镜子生成万花筒的效果，觉得很有意思：&lt;/p&gt;</summary>
    
    
    
    <category term="Shadertoy" scheme="https://pywonderland.com/categories/Shadertoy/"/>
    
    
    <category term="shadertoy" scheme="https://pywonderland.com/tags/shadertoy/"/>
    
    <category term="polyhedra" scheme="https://pywonderland.com/tags/polyhedra/"/>
    
    <category term="raymarching" scheme="https://pywonderland.com/tags/raymarching/"/>
    
    <category term="kaleidoscope" scheme="https://pywonderland.com/tags/kaleidoscope/"/>
    
  </entry>
  
  <entry>
    <title>Coxeter 群笔记（六）：Boyd-Maxwell 球堆</title>
    <link href="https://pywonderland.com/coxeter-groups-boyd-maxwell/"/>
    <id>https://pywonderland.com/coxeter-groups-boyd-maxwell/</id>
    <published>2021-12-08T16:00:00.000Z</published>
    <updated>2025-03-13T13:40:24.547Z</updated>
    
    <content type="html"><![CDATA[<p>本文的内容主要来自 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>)</span> 和<span class="citation" data-cites="Maxwell89">(<a href="#ref-Maxwell89" role="doc-biblioref">Maxwell 1989</a>)</span>，并修复了一些错误。Maxwell在 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>, pp81)</span> 中写到：</p><div class="statement simple plain unnumbered"><p>When <span class="math inline">\(\Gamma\)</span> is hyperbolic, thecone</p><p><span class="math display">\[\{v\in V\mid (v,v)\leq0\}\]</span></p><p>has two connected components (after deleting 0), which are also theequivalent classes for the relation <span class="math display">\[u\simv\Leftrightarrow (u,v)\leq0.\]</span></p></div><p>这显然是错误的，因为如果 <span class="math inline">\(u\)</span> 是light-like 的向量，<span class="math inline">\(u\)</span> 和 <span class="math inline">\(-u\)</span> 属于不同的分支。这个错误导致后面 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>, prop 3.1)</span>的证明需要作一些修改。详情见下面的 <a href="#thm-sphere-packing" title="定理 5.5">定理 5.5</a>。</p><span id="more"></span><h1 id="射影模型">射影模型</h1><p>在本节中，我们记 <span class="math inline">\(V=\mathbb{R}^{n+1,1}\)</span> 是 <span class="math inline">\(n+2\)</span> 维的 Lorentzian 空间，<span class="math inline">\(\{e_1,e_2,\ldots,e_{n+2}\}\)</span> 是 <span class="math inline">\(V\)</span> 的一组标准正交基，于是内积在这组基下的Gram 矩阵为 <span class="math inline">\(\left(\begin{smallmatrix}I_{n+1}&amp;\\ &amp; -1\end{smallmatrix}\right)\)</span>。令 <span class="math display">\[e_0=\frac{e_{n+2}-e_{n+1}}{2},\quade_\infty=\frac{e_{n+2}+e_{n+1}}{2}.\]</span> 则 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span> 也构成<span class="math inline">\(V\)</span> 的一组基，内积在这组新基下的 Gram矩阵为 <span class="math display">\[\begin{pmatrix}0&amp;&amp;&amp;-\frac{1}{2}\\&amp;I_n&amp;&amp;\\-\frac{1}{2}&amp;&amp;&amp;0\end{pmatrix}.\]</span>任何两个向量 <span class="math inline">\(v,w\in V\)</span>可以写成如下的形式： <span class="math display">\[\begin{aligned}v&amp;=ae_0 + \mathbf{x}+ be_\infty,\\w&amp;=ce_0 + \mathbf{y}+ de_\infty.\end{aligned}\]</span> 其中 <span class="math inline">\(\mathbf{x},\mathbf{y}\in\mathrm{span}\{e_1,\ldots,e_n\},\,a,b\in\mathbb{R}\)</span>。则<span class="math inline">\(v,w\)</span> 之间的内积为 <span class="math display">\[(v,w) = (\mathbf{x}, \mathbf{y}) -\frac{ad+bc}{2}.\]</span> 使用 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span>这组基在处理 <span class="math inline">\(\mathbb{R}^n\)</span>中的球时更方便一些。</p><p>设 <span class="math inline">\(v\in\mathbb{R}^{n+1,1}\)</span>，用<span class="math inline">\([v]\)</span> 表示 <span class="math inline">\(v\)</span> 在射影空间 <span class="math inline">\(\mathrm{P}(\mathbb{R}^{n+1,1})\)</span>中的等价类。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>定义光锥 (lightcone/null cone) 为 <span class="math display">\[\mathbb{L}^{n+1}= \{v\in\mathbb{R}^{n+1,1}\mid(v,v)=0\}.\]</span> 以及 <span class="math display">\[\mathrm{P}(\mathbb{L}^{n+1})=\{[v]\midv\in\mathbb{L}^{n+1}\setminus\{0\}\}.\]</span> <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span> 是 <span class="math inline">\(\mathbb{L}^{n+1}\)</span>中所有直线组成的集合。</p></div><p>熟知 <span class="math inline">\(\overline{\mathbb{R}^n}=\mathbb{R}^n\cup\{\infty\}\)</span>和 <span class="math inline">\(\mathbb{R}^{n+1}\)</span> 中的单位球<span class="math inline">\(S^n=\{x_1^2+x_2^2+\cdots+x_{n+1}^2=1\}\)</span>在球极投影下是一一对应的（北极点为 <span class="math inline">\(e_{n+1}\)</span>）。</p><figure><img src="/images/coxeter/stereo-projection.svg" width="400" alt="S^2 到 \overline{\mathbb{R}^2} 的球极投影，by Keenan Crane"><figcaption aria-hidden="true"><span class="math inline">\(S^2\)</span>到 <span class="math inline">\(\overline{\mathbb{R}^2}\)</span>的球极投影，by Keenan Crane</figcaption></figure><p>我们来说明它们分别和 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>是一一对应的，并且当 <span class="math inline">\(\mathbf{x}\in\overline{\mathbb{R}^n}\)</span> 和<span class="math inline">\(\mathbf{y}\in S^n\)</span>在球极投影下对应时，它们在 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>中是同一个点。</p><div id="-mathrm-p---mathbb-l---n-1------------------------------" class="statement sta__mathrm_p___mathbb_l___n_1____________ plain unnumbered"><p><span class="statement-heading"><span class="statement-label"><span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>的第一种参数化表示</span>.</span><span class="statement-spah"></span><br></p><p>我们在 <span class="math inline">\(\{e_1,\ldots,e_{n+2}\}\)</span>这组基下计算。</p><p>设 <span class="math inline">\(\mathbf{y}=y_1e_1+\cdots+y_{n+1}e_{n+1}\in\mathbb{R}^{n+1}\)</span>，则<span class="math display">\[\mathbf{y}\in S_n\Leftrightarrow|\mathbf{y}|=1\Leftrightarrow\mathbf{y}+e_{n+2}\in\mathbb{L}^{n+1}.\]</span> 即我们有一一映射： <span class="math display">\[\begin{aligned}S^n&amp;\mapsto S^n_1\\\mathbf{y}&amp;\mapsto \mathbf{y}+e_{n+2}.\end{aligned}\]</span> 其中 <span class="math inline">\(S^n_1\)</span>是平面 <span class="math inline">\(y_{n+2}=1\)</span> 与 <span class="math inline">\(\mathbb{L}^{n+1}\)</span> 相交给出的截线。由于<span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>中每个元素在 <span class="math inline">\(S^n_1\)</span>中有唯一代表元，所以 <span class="math display">\[\jmath\colon\S^n\to\mathrm{P}(\mathbb{L}^{n+1}): \mathbf{y}\to[\mathbf{y}+e_{n+2}],\]</span> 是一一对应，此即为 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>的第一种参数化表示。</p></div><div id="-mathrm-p---mathbb-l---n-1-------------------------------1" class="statement sta__mathrm_p___mathbb_l___n_1____________-1 plain unnumbered"><p><span class="statement-heading"><span class="statement-label"><span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>的第二种参数化表示</span>.</span><span class="statement-spah"></span><br></p><p>我们在 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span>这组基下计算。对 <span class="math inline">\([v]\in\mathrm{P}(\mathbb{L}^{n+1})\)</span>：</p><ul><li>如果 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(e_0\)</span> 分量不为 0，则 <span class="math inline">\(v\)</span> 形如 <span class="math display">\[v=e_0+ \mathbf{x}+ be_\infty,\quad\mathbf{x}\in\mathrm{span}\{e_1,\ldots,e_n\}.\]</span> 由于 <span class="math inline">\(v\in\mathbb{L}^{n+1}\)</span> 所以 <span class="math inline">\(b=|\mathbf{x}|^2\)</span>，即 <span class="math inline">\(v=e_0 + \mathbf{x}+|\mathbf{x}|^2e_\infty\)</span>。</li><li>如果 <span class="math inline">\(v\)</span> 的 <span class="math inline">\(e_0\)</span> 分量等于 0，则 <span class="math inline">\(v\)</span> 形如 <span class="math display">\[v=\mathbf{x}+be_\infty,\quad\mathbf{x}\in\mathrm{span}\{e_1,\ldots,e_n\}.\]</span> <span class="math inline">\(v\in\mathbb{L}^{n+1}\)</span> 说明 <span class="math inline">\(\mathbf{x}=0\)</span>，从而 <span class="math inline">\([v] = [(0,0,b)]=[e_\infty]\)</span>。</li></ul><p>于是我们可以定义如下从 <span class="math inline">\(\overline{\mathbb{R}^n}\)</span> 到 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span> 的一一对应:<span class="math display">\[\imath(\mathbf{x})=\begin{cases}[e_0 + \mathbf{x}+|\mathbf{x}|^2e_\infty] &amp; \mathbf{x}\in\mathbb{R}^n,\\[e_\infty] &amp; \mathbf{x}= \infty.\end{cases}\]</span> 此即为 <span class="math inline">\(\mathrm{P}(\mathbb{L}^{n+1})\)</span>的第二种参数化表示。</p></div><figure><img src="/images/coxeter/Horosphere.svg" width="500" alt="红色的圆是超平面 (\cdot, e_{n+2})=1 与光锥的截线，可以通过将 S^n 沿着 e_{n+2} 平移一个单位得到；\overline{\mathbb{R}^n} 对应蓝色的 horosphere，它是超平面 (\cdot, e_0)=\frac{1}{2} 与光锥的截线。e_\infty 不在 horosphere 上"><figcaption aria-hidden="true">红色的圆是超平面 <span class="math inline">\((\cdot, e_{n+2})=1\)</span>与光锥的截线，可以通过将 <span class="math inline">\(S^n\)</span> 沿着<span class="math inline">\(e_{n+2}\)</span> 平移一个单位得到；<span class="math inline">\(\overline{\mathbb{R}^n}\)</span> 对应蓝色的horosphere，它是超平面 <span class="math inline">\((\cdot,e_0)=\frac{1}{2}\)</span> 与光锥的截线。<span class="math inline">\(e_\infty\)</span> 不在 horosphere 上</figcaption></figure><p>设 <span class="math inline">\(\mathbf{y}=y_1e_1+\cdots+y_{n+1}e_{n+1}\inS^n\)</span>，<span class="math inline">\(\mathbf{y}\)</span> 在以 <span class="math inline">\(e_{n+1}\)</span> 为北极的球极投影下对应的点是<span class="math display">\[\mathbf{x}=\begin{cases}\sum\limits_{i=1}^n\dfrac{y_i}{1-y_{n+1}}e_i &amp; y_{n+1}\ne1,\\\infty &amp; y_{n+1}=1.\end{cases}\]</span> 我们来验证 <span class="math inline">\(\jmath(\mathbf{y})=\imath(\mathbf{x})\)</span>，即<span class="math display">\[[\mathbf{y}+ e_{n+2}] = \begin{cases}[e_0 +\mathbf{x}+ |\mathbf{x}|^2e_\infty] &amp; y_{n+1}\ne1\\[e_\infty] &amp; y_{n+1}=1.\end{cases}.\]</span></p><ul><li><p><span class="math inline">\(y_{n+1}=1\)</span> 时 <span class="math inline">\(\mathbf{y}=e_{n+1}\)</span> 从而 <span class="math inline">\(\mathbf{y}+e_{n+2}=e_{n+1}+e_{n+2}=2e_\infty\)</span>，显然与 <span class="math inline">\(e_\infty\)</span> 射影等价。</p></li><li><p><span class="math inline">\(y_{n+1}\ne 1\)</span> 时，由 <span class="math inline">\(\mathbf{y}\in S^n\)</span> 可得 <span class="math inline">\(\sum_{i=1}^ny_i^2=1-y_{n+1}^2\)</span>，从而 <span class="math display">\[|\mathbf{x}|^2=\frac{\sum_{i=1}^ny_i^2}{(1-y_{n+1})^2}= \frac{1+y_{n+1}}{1-y_{n+1}}.\]</span> 把 <span class="math inline">\(\mathbf{y}+e_{n+2}\)</span> 转化为 <span class="math inline">\(\{e_0,e_1,\ldots,e_n,e_\infty\}\)</span>这组基下的表示： <span class="math display">\[\mathbf{y}+e_{n+2} =(1-y_{n+1})e_0+\sum_{i=1}^ny_ie_i + (1+y_{n+1})e_\infty.\]</span> 从而<span class="math display">\[[\mathbf{y}+e_{n+2}] =\left[e_0+\sum_{i=1}^n\frac{y_i}{1-y_{n+1}}e_i+\frac{1+y_{n+1}}{1-y_{n+1}}e_\infty\right] = [e_0 + \mathbf{x}+|\mathbf{x}|^2e_\infty].\]</span></p></li></ul><h1 id="球面">球面</h1><p>记 <span class="math inline">\(\mathcal{S}=\{v\in\mathbb{R}^{n+1,1}\mid(v,v)=1\}\)</span> 是所有 space-like 单位向量组成的集合。我们来建立 <span class="math inline">\(\mathbb{R}^n\)</span> 中的球（包括超平面）和 <span class="math inline">\(\mathcal{S}\)</span> 之间的一一对应。</p><p>设 <span class="math inline">\(B(\mathbf{a},r)=\{\mathbf{x}\in\mathbb{R}^n\mid|x-\mathbf{a}|=|r|\}\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span> 中以 <span class="math inline">\(\mathbf{a}\)</span> 为中心，半径为 <span class="math inline">\(r\ne 0\)</span> 的球，它将 <span class="math inline">\(\mathbb{R}^n\)</span>分成两个连通分支，一个有界，另一个无界。我们允许 <span class="math inline">\(r\)</span> 是负数以区分 <span class="math inline">\(B\)</span> 的内部和外部：<span class="math inline">\(r&gt;0\)</span> 时 <span class="math inline">\(B\)</span> 的内部是满足 <span class="math inline">\(|\mathbf{x}-\mathbf{a}|&lt; r\)</span>的有界分支；<span class="math inline">\(r&lt;0\)</span> 时 <span class="math inline">\(B\)</span> 的内部是满足 <span class="math inline">\(|\mathbf{x}-\mathbf{a}|&gt;|r|\)</span>的无界分支。</p><p>把 <span class="math inline">\(\mathbf{a}\)</span> 看作 <span class="math inline">\(\mathrm{span}\{e_1,\ldots,e_n\}\cong\mathbb{R}^n\)</span>中的点，记 <span class="math display">\[k = \frac{e_0 + \mathbf{a}+(|\mathbf{a}|^2 - r^2)e_\infty}{r}.\]</span> 不难验证 <span class="math inline">\((k,k)=1\)</span>，所以 <span class="math inline">\(k\in\mathcal{S}\)</span>。</p><p>对 <span class="math inline">\(\mathbf{x}\in\mathbb{R}^n\)</span>，<span class="math inline">\(\imath(\mathbf{x})=e_0+\mathbf{x}+|\mathbf{x}|^2e_\infty\in\mathbb{L}^{n+1}\)</span>，则<span class="math display">\[(\imath(\mathbf{x}),k)=\frac{r^2-|\mathbf{x}-\mathbf{a}|^2}{2r}.\]</span></p><p>于是 <span class="math inline">\(\mathbf{x}\in B\)</span> 当且仅当<span class="math inline">\((\imath(\mathbf{x}),k)=0\)</span>，以及<span class="math inline">\(\mathbf{x}\)</span> 落在 <span class="math inline">\(B\)</span> 的内部当且仅当 <span class="math inline">\((\imath(\mathbf{x}),k)&gt;0\)</span>。鉴于此，我们也把<span class="math inline">\(B\)</span> 的内部叫做 <span class="math inline">\(B\)</span> 的<strong>正半空间</strong>，<span class="math inline">\(k\)</span> 是指向 <span class="math inline">\(B\)</span> 的正半空间的单位法向量。</p><p>注意到 <span class="math inline">\(\imath(\mathbf{x})\)</span> 和<span class="math inline">\(\jmath(\mathbf{x})\)</span>只差一个正的倍数，所以 <span class="math inline">\(\mathbf{x}\inB\)</span> 等价于 <span class="math inline">\((\jmath(\mathbf{x}),k)=0\)</span>。<span class="math inline">\(V\)</span> 中所有形如 <span class="math inline">\((\jmath(\mathbf{x}),k)=0\,(\mathbf{x}\in\mathbb{R}^n)\)</span>的点构成 <span class="math inline">\(S^n_1\)</span> 与超平面 <span class="math inline">\(k^\bot\)</span> 的截线。</p><p>设 <span class="math inline">\(H(\mathbf{n},d)=\{\mathbf{x}\in\mathbb{R}^n\mid(\mathbf{x},\mathbf{n})=d\}\)</span> 是超平面，<span class="math inline">\(\mathbf{n}\)</span> 是 <span class="math inline">\(B\)</span> 的单位法向量。我们将 <span class="math inline">\(H(\mathbf{n},d)\)</span> 对应到 <span class="math display">\[k=\mathbf{n}+ 2d e_\infty.\]</span>不难验证同样有 <span class="math inline">\(k\in\mathcal{S}\)</span>，并且对 <span class="math inline">\(\mathbf{x}\in\mathbb{R}^n\)</span> 有 <span class="math display">\[(\imath(\mathbf{x}),k)=(\mathbf{x},\mathbf{n})-d.\]</span>于是 <span class="math inline">\(\mathbf{x}\in B\)</span> 当且仅当 <span class="math inline">\((\imath(\mathbf{x}),k)=0\)</span>，<span class="math inline">\(\mathbf{x}\)</span> 属于 <span class="math inline">\(B\)</span> 的正半空间当且仅当 <span class="math inline">\((\imath(\mathbf{x}),k)&gt;0\)</span>。</p><p>反之任何 <span class="math inline">\(k\in\mathcal{S}\)</span>也都唯一确定了 <span class="math inline">\(\mathbb{R}^n\)</span>中的某个球或者超平面。为此只要将 <span class="math inline">\(k\)</span>表示为 <span class="math display">\[k=be_\infty+\mathbf{a}+ce_\infty\in\mathcal{S},\quadb,c\in\mathbb{R}.\]</span> 并根据 <span class="math inline">\(b\)</span>是否等于 0 将 <span class="math inline">\(k\)</span> 对应为球 <span class="math inline">\(B(\mathbf{a}/b ,1/b)\)</span> 或者超平面 <span class="math inline">\(H(\mathbf{a}, c/2)\)</span> 即可。</p><h1 id="球面的-seperation">球面的 seperation</h1><p>设 <span class="math inline">\(B_1(\mathbf{a}_1,r_1),\,B_2(\mathbf{a}_2,r_2)\)</span>是两个球，它们对应的 <span class="math inline">\(\mathcal{S}\)</span>中向量分别是 <span class="math display">\[\begin{aligned}k_1&amp;=\frac{1}{r_1}e_0 + \frac{\mathbf{a}_1}{r_1} +\frac{|\mathbf{a}_1|^2-r_1^2}{r_1}e_\infty,\\k_2&amp;=\frac{1}{r_2}e_0 + \frac{\mathbf{a}_2}{r_2} +\frac{|\mathbf{a}_2|^2-r_2^2}{r_2}e_\infty.\\\end{aligned}.\]</span> 不难验证有 <span class="math display">\[(k_1,k_2)=\frac{r_1^2+r_2^2 -|\mathbf{a}_1-\mathbf{a}_2|^2}{2r_1r_2}.\]</span> 我们称内积 <span class="math inline">\((k_1,k_2)\)</span> 为 <span class="math inline">\(B_1\)</span> 和 <span class="math inline">\(B_2\)</span> 的 <strong>seperation</strong>。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span> <span class="statement-info">(<span class="citation" data-cites="ratcliffe">(见 <a href="#ref-ratcliffe" role="doc-biblioref">Ratcliffe 2006, vol. 149, sec.3.2</a>)</span>)</span>：</span><span class="statement-spah"> </span>在Lorentzinian 内积下，两个 space-like 的单位向量 <span class="math inline">\(k_1,k_2\)</span> 之间的内积有两种含义：</p><ol type="1"><li>如果 <span class="math inline">\(|(k_1,k_2)|\leq1\)</span>，则 <span class="math inline">\((k_1,k_2)=\cos\theta\)</span>，<span class="math inline">\(\theta\)</span> 是分别以 <span class="math inline">\(x,y\)</span> 为切向量的两条测地线之间的夹角；</li><li>如果 <span class="math inline">\(|(k_1,k_2)|&gt;1\)</span>，则 <span class="math inline">\((k_1,k_2)=\pm\cosh\eta\)</span>，<span class="math inline">\(\eta\)</span> 是分别以 <span class="math inline">\(x,y\)</span>为法向量的两个超平面之间的双曲距离。</li></ol></div><ol type="1"><li><span class="math inline">\(B_1\)</span> 和 <span class="math inline">\(B_2\)</span> 相交或者相切当且仅当 <span class="math inline">\(|(k_1,k_2)|\leq1\)</span>，这时 <span class="math inline">\((k_1,k_2)=\cos\theta\)</span>，<span class="math inline">\(\theta\)</span>是两个球面交点处的内法向量夹角（用外法向量也可以，因为同时将内法向量变成外法向量，夹角的余弦不变）。当<span class="math inline">\((k_1,k_2)=-1\)</span> 时两球外切，<span class="math inline">\((k_1,k_2)=1\)</span> 时两球内切。</li><li><span class="math inline">\(B_1\)</span> 和 <span class="math inline">\(B_2\)</span> 不相交也不相切当且仅当 <span class="math inline">\(|(k_1,k_2)|&gt;1\)</span>，这时 <span class="math inline">\(|(k_1,k_2)|=\cosh\eta\)</span>，<span class="math inline">\(\eta\)</span> 是 <span class="math inline">\(k_1,k_2\)</span>对应的双曲空间中测地线的双曲距离。两球在 <span class="math inline">\((k_1,k_2)&lt;-1\)</span> 时没有公共的内部，在<span class="math inline">\((k_1,k_2)&gt;1\)</span>时一个完全包含另一个。</li></ol><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=\cos\theta(\ell_1,\ell_2)\)</span></td><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=\cosh d(\ell_1,\ell_2)\)</span></td></tr><tr class="even"><td style="text-align: center;"><img src="/images/coxeter/image0.jpg" width="150"></td><td style="text-align: center;"><img src="/images/coxeter/image1.jpg" width="150"></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=-\cosh d(\ell_1,\ell_2)\)</span></td><td style="text-align: center;"><span class="math inline">\((k_1,k_2)=-\cosh d(\ell_1,\ell_2)\)</span></td></tr><tr class="even"><td style="text-align: center;"><img src="/images/coxeter/image2.jpg" width="150"></td><td style="text-align: center;"><img src="/images/coxeter/image3.jpg" width="150"></td></tr></tbody></table><p>上面的结论同样适用于 <span class="math inline">\(B_1\)</span> 和<span class="math inline">\(B_2\)</span>一个是球面，另一个是超平面的情形。例如设 <span class="math inline">\(B_1\)</span> 是球面，<span class="math inline">\(B_2\)</span> 是超平面，<span class="math inline">\(k_2=\mathbf{n}+2de_\infty\)</span>，则 <span class="math display">\[(k_1,k_2)=\frac{(\mathbf{a}_1,\mathbf{n})-d}{r_1}.\]</span>如果 <span class="math inline">\(B_1,B_2\)</span> 相交，则 <span class="math inline">\((k_1,k_2)\)</span> 等于 <span class="math inline">\(B_1\)</span> 在交点处的内法向量和 <span class="math inline">\(B_2\)</span> 的法向量 <span class="math inline">\(\mathbf{n}\)</span> 夹角的余弦；否则它是 <span class="math inline">\(B_1\)</span> 的球心到 <span class="math inline">\(B_2\)</span> 的有向距离除以 <span class="math inline">\(r_1\)</span>。</p><p>类似地当 <span class="math inline">\(B_1,B_2\)</span>都是超平面时，<span class="math inline">\((k_1,k_2)=(\mathbf{n}_1,\mathbf{n}_2)\)</span>是它们法向量夹角的余弦。</p><div id="suff-for-disjoint" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(B_1,B_2\)</span> 是两个球，且 <span class="math inline">\(B_1,B_2\)</span> 的内部不相交。设 <span class="math inline">\(k_1,k_2\)</span> 分别是它们对应的 space-like的单位向量，则 <span class="math inline">\((k_1,k_2)\leq-1\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个命题反过来是不对的。</p></div><p><strong>证明</strong>：<span class="math inline">\(B_1\)</span> 和<span class="math inline">\(B_2\)</span> 内部不相交有如下几种可能：</p><ol type="1"><li><span class="math inline">\(B_1,B_2\)</span> 都是球，半径 <span class="math inline">\(r_1,r_2\)</span> 都大于 0，并且 <span class="math inline">\(r_1+r_2 \geq|\mathbf{a}_1-\mathbf{a}_2|\)</span>。</li><li><span class="math inline">\(B_1,B_2\)</span> 都是球，半径 <span class="math inline">\(r_1&gt;0,\, r_2&lt;0\)</span>，且 <span class="math inline">\(B_1\)</span> 位于 <span class="math inline">\(B_2\)</span> 另一侧的有界区域，即 <span class="math inline">\(-r_2-r_1\geq|\mathbf{a}_1-\mathbf{a}_2|\)</span>。</li><li><span class="math inline">\(B_1\)</span> 是球，其半径 <span class="math inline">\(r_1&gt;0\)</span>；<span class="math inline">\(B_2\)</span> 是超平面，且 <span class="math inline">\(B_1\)</span> 位于 <span class="math inline">\(B_2\)</span> 的负半空间，从而其球心 <span class="math inline">\(\mathbf{a}_1\)</span> 到 <span class="math inline">\((\mathbf{n},\mathbf{x})=d\)</span> 的有向距离<span class="math inline">\(\leq-r_1\)</span>，即 <span class="math inline">\((\mathbf{a}_1,\mathbf{n})-d\leq-r_1\)</span>。</li><li><span class="math inline">\(B_1,B_2\)</span>是互相平行的超平面，且法向量相反的，即 <span class="math inline">\((\mathbf{n}_1,\mathbf{n}_2)=-1\)</span>。</li></ol><p>不难验证这些都可以推出 <span class="math inline">\((k_1,k_2)\leq-1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><h1 id="球的反演">球的反演</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义4.1</span>.</span><span class="statement-spah"> </span>关于球 <span class="math inline">\(B(\mathbf{a}, r)\)</span> 的反演定义为 <span class="math display">\[\begin{aligned}\tau\colon\ \overline{\mathbb{R}^n}&amp;\mapsto\overline{\mathbb{R}^n}\\\tau(\mathbf{x})&amp;=\frac{r^2}{|\mathbf{x}-\mathbf{a}|^2}(\mathbf{x}-\mathbf{a})+\mathbf{a}.\end{aligned}\]</span></p></div><p><span class="math inline">\(\tau\)</span> 是 <span class="math inline">\(\overline{\mathbb{R}^n}\)</span> 中关于球面镜<span class="math inline">\(B\)</span> 的反射，它保持 <span class="math inline">\(B\)</span> 的表面不动，将 <span class="math inline">\(B\)</span> 的内部映射为外部（反之亦然），并且<span class="math inline">\(\tau^2=1\)</span>。</p><p><img src="/images/coxeter/sphere-inversion.svg" class="fig" width="400"></p><p>我们来说明 <span class="math inline">\(\tau\)</span> 可以实现为 <span class="math inline">\(\mathrm{P}(\mathbb{R}^{n+1,1})\)</span>中的射影正交变换。</p><p>设 <span class="math inline">\(B(\mathbf{a},r)\)</span> 对应 <span class="math inline">\(k\in\mathcal{S}\)</span>，考察以 <span class="math inline">\(k\)</span> 为法向量的镜面反射 <span class="math display">\[\begin{aligned}\rho\colon\ \mathbb{R}^{n+1,1}&amp;\mapsto\mathbb{R}^{n+1,1}\\\rho(v) &amp;= v - 2(v,k)k.\end{aligned}\]</span> 则 <span class="math inline">\(\rho\)</span> 是<span class="math inline">\(\mathbb{R}^{n+1,1}\)</span>上的正交变换，从而也给出 <span class="math inline">\(\mathrm{P}(\mathbb{R}^{n+1,1})\)</span>上的射影变换。</p><p>我们来计算 <span class="math inline">\(\rho\)</span> 作用在 <span class="math inline">\(\imath(\mathbf{x})\,(\mathbf{x}\in\mathbb{R}^n)\)</span>上的效果：（注意 <span class="math inline">\((\imath(\mathbf{x}),k)=\frac{r^2-|\mathbf{x}-\mathbf{a}|^2}{r}\)</span>）<span class="math display">\[\begin{align*}\begin{pmatrix}1\\\mathbf{x}\\ |\mathbf{x}|^2\end{pmatrix}&amp;\xrightarrow{\rho}\begin{pmatrix}1\\\mathbf{x}\\ |\mathbf{x}|^2\end{pmatrix}-\frac{r^2-|\mathbf{x}-\mathbf{a}|^2}{r}\begin{pmatrix}\frac{1}{r}\\\frac{\mathbf{a}}{r}\\\frac{|\mathbf{a}|-r^2}{r}\end{pmatrix}\\&amp;=\begin{pmatrix}\frac{|\mathbf{x}-\mathbf{a}|^2}{r^2}\\\mathbf{x}+\left(\frac{|\mathbf{x}-\mathbf{a}|^2-r^2}{r^2}\right)\mathbf{a}\\\ast \end{pmatrix}\\&amp;\sim\begin{pmatrix}1\\\mathbf{a}+\frac{r^2}{|\mathbf{x}-\mathbf{a}|^2}(\mathbf{x}-\mathbf{a})\\\ast \end{pmatrix}\\&amp;=\begin{pmatrix}1\\\tau(\mathbf{x})\\ |\tau(\mathbf{x})|^2\end{pmatrix}.\end{align*}\]</span> 这里我们不用关心 <span class="math inline">\(\ast\)</span> 是什么，中间的 <span class="math inline">\(\sim\)</span>表示两个向量射影等价。即我们有如下的交换图：</p><p><span class="math display">\[\require{amsCd}\begin{CD}\overline{\mathbb{R}^n}@&gt;{\imath}&gt;&gt;\mathrm{P}(\mathbb{L}^{n+1})\\@V{\tau}VV  @VV{\rho}V \\\overline{\mathbb{R}^n}@&gt;{\imath}&gt;&gt;\mathrm{P}(\mathbb{L}^{n+1})\end{CD}\]</span></p><p>进一步，将任意球 <span class="math inline">\(B'\)</span> 关于<span class="math inline">\(B\)</span> 作反演也可以通过 <span class="math inline">\(\rho\)</span> 来计算。设 <span class="math inline">\(k'\)</span> 是 <span class="math inline">\(B'\)</span> 对应的 space-like 的单位向量，则<span class="math inline">\(\rho(k')\)</span> 也是 space-like的单位向量，从而 <span class="math inline">\(\rho(k')\)</span>对应某个球 <span class="math inline">\(B''\)</span>。根据上面的交换图有 <span class="math inline">\(\rho\imath=\imath\tau\)</span>，于是 <span class="math display">\[\mathbf{x}\in B'\Leftrightarrow(\imath(\mathbf{x}), k')=0\Leftrightarrow(\rho\imath(\mathbf{x}), \rho(k'))=0\Leftrightarrow(\imath\tau(\mathbf{x}), \rho(k'))=0\Leftrightarrow \tau(\mathbf{x})\in B''.\]</span> 即关于 <span class="math inline">\(B\)</span> 的反演 <span class="math inline">\(\tau\)</span> 将 <span class="math inline">\(B'\)</span> 映射为 <span class="math inline">\(B''\)</span>。</p><h1 id="双曲球堆">双曲球堆</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.1</span>.</span><span class="statement-spah"> </span>如果非空集合<span class="math inline">\(\mathcal{P}\subset \mathcal{S}\)</span>满足对 <span class="math inline">\(\mathcal{P}\)</span> 中任何 <span class="math inline">\(k\ne k'\)</span> 有 <span class="math inline">\((k,k')\leq -1\)</span>，我们就称 <span class="math inline">\(\mathcal{P}\)</span>是一个<strong>球堆</strong></p></div><p>形如 <span class="math inline">\(\mathcal{P}=\{k,-k\}\)</span>的球堆是平凡的，因为它由一个球的内部和外部组成。否则就称 <span class="math inline">\(\mathcal{P}\)</span> 是非平凡的。<span class="math inline">\(-\mathcal{P}=\{-k\mid k\in\mathcal{P}\}\)</span>也是球堆，它是通过翻转 <span class="math inline">\(\mathcal{P}\)</span>中每个球的内部和外部得到的。</p><p>记 <span class="math inline">\(\mathcal{H}\)</span> 是超平面 <span class="math inline">\((\cdot, e_{n+2})=1\)</span> 与 <span class="math inline">\(\mathcal{Q}_+\)</span> 的截面，对给定的 <span class="math inline">\(k\in S\)</span>，定义球帽 <span class="math display">\[C_k = \{v\in\mathcal{H}\mid(v,k)\geq0\}.\]</span></p><div id="disjoint-pair" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span> 是球堆且 <span class="math inline">\(k_1\ne k_2\in\mathcal{P}\)</span>，则集合 <span class="math inline">\(C_{k_1}\cap C_{k_2}\)</span> 和 <span class="math inline">\(C_{-k_1}\cap C_{-k_2}\)</span>中必有一个至多只包含一个点。并且当这两个集合中的某个恰好只含一个点时，此点与<span class="math inline">\(k_1+k_2\)</span> 共线，并且有 <span class="math inline">\((k_1,k_2)=-1\)</span> 成立。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(u\inC_{k_1}\cap C_{k_2}\)</span>，<span class="math inline">\(v\inC_{-k_1}\cap C_{-k_2}\)</span>，则 <span class="math display">\[(u,k_1+k_2)\geq0\text{ and }(v,k_1+k_2)\leq0.\]</span> 由于 <span class="math inline">\((k_1+k_2,k_1+k_2)=2+2(k_1,k_2)\leq0\)</span>，所以<span class="math inline">\(k_1+k_2\)</span> 是 time/light-like 的。如果上面两个不等号都是严格成立的，则 <span class="math inline">\(v\simk_1+k_2\)</span> 且 <span class="math inline">\(u\not\simk_1+k_2\)</span>，这与 <span class="math inline">\(u\sim v\)</span>矛盾。所以两个不等式至少有一个等号是成立的，即 <span class="math inline">\(u,v\)</span> 之中必有一个与 <span class="math inline">\(k_1+k_2\)</span> 共线，并且 <span class="math inline">\(k_1+k_2\)</span> 是 light-like 的向量，由此可得<span class="math inline">\((k_1,k_2)=-1\)</span>。</p><p>然而 <span class="math inline">\(\mathcal{H}\)</span> 中与 <span class="math inline">\(k_1+k_2\)</span> 共线的点是唯一确定的，所以 <span class="math inline">\(C_{k_1}\cap C_{k_2}\)</span> 和 <span class="math inline">\(C_{-k_1}\cap C_{-k_2}\)</span>中必有一个至多包含一个点，且此点与 <span class="math inline">\(k_1+k_2\)</span> 共线。<span class="math inline">\(\blacksquare\)</span></p><div id="contain-time-like" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span> 是球堆且 <span class="math inline">\(k_1\ne k_2\in\mathcal{P}\)</span>。如果 <span class="math inline">\(|C_{k_1}\cap C_{k_2}|&gt;1\)</span>，则 <span class="math inline">\(C_{k_1}\cap C_{k_2}\)</span> 中必然包含某个time-like 的向量。</p></div><p><strong>证明</strong>： 设 <span class="math inline">\(u,v\inC_{k_1}\cap C_{k_2}\)</span> 是两个不同点，则 <span class="math inline">\(u\sim v\)</span> 且 <span class="math inline">\(u,v\)</span> 线性无关，从而 <span class="math inline">\((u,v)&lt;0\)</span>。<span class="math inline">\(z=u+v\)</span> 满足 <span class="math inline">\(z\sim u\)</span> 和 <span class="math inline">\((z,z)&lt;0\)</span>，从而 <span class="math inline">\(z\)</span> 的某个正倍数 <span class="math inline">\(z'\)</span> 属于 <span class="math inline">\(\mathcal{H}\)</span>。<span class="math inline">\(z'\)</span> 即为所求。 <span class="math inline">\(\blacksquare\)</span></p><div id="intersect-pair" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span> 是球堆且 <span class="math inline">\(k_1\ne k_2\in\mathcal{P}\)</span>。如果 <span class="math inline">\(v\in\mathcal{H}\)</span> 满足 <span class="math display">\[(v,k_1)\geq0\text{ and } (v,k_2)&gt;0.\]</span>则 <span class="math inline">\(|C_{k_1}\cap C_{k_2}|&gt;1\)</span>。</p></div><p><strong>证明</strong>：记 <span class="math inline">\(a=(v,k_2)&gt;0\)</span>，考虑向量 <span class="math inline">\(u=v-tk_2\)</span>，其中 <span class="math inline">\(t\in(0, a)\)</span> 是实数。</p><p>由于 <span class="math inline">\((u,u)=(v,v)+t^2-2at&lt;0\)</span> 是time-like 的，以及 <span class="math inline">\((u,v)=(v,v)-at&lt;0\)</span>，所以 <span class="math inline">\(u\sim v\)</span>。从而 <span class="math inline">\(u\)</span> 的某个正倍数 <span class="math inline">\(u'=cu\,(c&gt;0)\)</span> 属于 <span class="math inline">\(\mathcal{H}\)</span>。由于</p><p><span class="math display">\[\begin{aligned}(u,k_1)&amp;=\overbrace{(v,k_1)}^{\geq0} -\overbrace{t}^{&gt;0}\cdot\overbrace{(k_1,k_2)}^{\leq-1}&gt;0,\\(u,k_2)&amp;=a-t&gt;0.\end{aligned}\]</span> 所以 <span class="math inline">\((u',k_1)&gt;0,\,(u',k_2)&gt;0\)</span>，从而<span class="math inline">\(u'\in C_{k_1}\cap C_{k_2}\)</span>。由于<span class="math inline">\(t\in(0,a)\)</span>有无穷多个取值，并且不难验证不同的 <span class="math inline">\(t\)</span> 给出的 <span class="math inline">\(u'\)</span> 互不相同，所以 <span class="math inline">\(|C_{k_1}\cap C_{k_2}|=\infty&gt;1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="thm-sphere-packing" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.5</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{P}\)</span>是非空集合，则下面两点是等价的：</p><ol type="1"><li><span class="math inline">\(\mathcal{P}\)</span>是一个非平凡的球堆。</li><li>对 <span class="math inline">\(\mathcal{P}\)</span> 或者 <span class="math inline">\(-\mathcal{P}\)</span> 之一，其包含的任何两个球帽<span class="math inline">\(C_k\)</span> 和 <span class="math inline">\(C_{k'}\)</span> 至多有一个公共点。</li></ol></div><p><strong>证明</strong>：</p><p>1 <span class="math inline">\(\Rightarrow\)</span> 2：根据 <a href="#disjoint-pair" title="引理 5.2">引理 5.2</a>，不妨设 <span class="math inline">\(k_1,k_2\in\mathcal{P}\)</span> 使得 <span class="math inline">\(C_{k_1}\cap C_{k_2}\)</span>至多包含一个点。我们来证明任何两个球帽 <span class="math inline">\(k\nek'\in\mathcal{P}\)</span> 之间至多只有一个公共点。不妨设 <span class="math inline">\(k\notin\{k_1,k_2\}\)</span>。用反证法，若 <span class="math inline">\(|C_k\capC_{k'}|&gt;1\)</span>，我们来说明这时同样也有 <span class="math inline">\(|C_{-k}\cap C_{-k'}|&gt;1\)</span>，从而与 <a href="#disjoint-pair" title="引理 5.2">引理 5.2</a> 矛盾。</p><p>根据 <a href="#contain-time-like" title="引理 5.3">引理 5.3</a>，存在time-like 的向量 <span class="math inline">\(v\in C_k\capC_{k'}\)</span>。我们来找 <span class="math inline">\(w\simv\)</span> 满足 <span class="math inline">\((w, k)&lt;0\)</span> 和<span class="math inline">\((w,k')\leq0\)</span>，这样的话 <span class="math inline">\(w\)</span> 的某个正倍数 <span class="math inline">\(w'\in\mathcal{H}\)</span> 并且 <span class="math inline">\((w',-k)&gt;0,\,(w',-k')\geq0\)</span>，根据<a href="#intersect-pair" title="引理 5.4">引理 5.4</a> 即得 <span class="math inline">\(|C_{-k}\cap C_{-k'}|&gt;1\)</span>。</p><p><span class="math inline">\(w\)</span> 的构造很容易，<span class="math inline">\(w=k_1-(k_1,k_2)k_2\)</span> 就满足要求。不难验证<span class="math inline">\((w, k)&lt;0\)</span> 和 <span class="math inline">\((w,k')\leq0\)</span>。麻烦的地方在于证明 <span class="math inline">\(w\sim v\)</span>。由于 <span class="math inline">\(v\)</span> 是 time-like 的，所以只要 <span class="math inline">\((v,w)\leq0\)</span> 即可保证 <span class="math inline">\(w\sim v\)</span>（实际上严格的不等号成立）。我们有<span class="math display">\[(v,w)=(v,k_1)-(k_1,k_2)(v,k_2)=(v-(v,k_2)k_2,k_1).\]</span> 记 <span class="math inline">\(u=v-(v,k_2)k_2\)</span>，则目标变为证明 <span class="math inline">\((u,k_1)\leq0\)</span>。注意到</p><p><span class="math display">\[\begin{aligned}(u,k_2) &amp;= (v,k_2) - (v,k_2)(k_2,k_2)=0,\\(u,u)&amp;=(u,v),\\(u,u)&amp;=\underbrace{(v,v)}_{&lt;0}-\underbrace{(v,k_2)^2}_{\leq0}&lt;0.\end{aligned}\]</span> 即 <span class="math inline">\((u,u)=(u,v)&lt;0\)</span>，从而<span class="math inline">\(u\sim v\)</span>。于是 <span class="math inline">\(u\)</span> 的某个正倍数 <span class="math inline">\(u'\)</span> 属于 <span class="math inline">\(\mathcal{H}\)</span>。如果 <span class="math inline">\((u,k_1)&gt;0\)</span> 的话由 <a href="#intersect-pair" title="引理 5.4">引理 5.4</a> 可得 <span class="math inline">\(|C_{k_1}\cap C_{k_2}|&gt;1\)</span>，矛盾。从而<span class="math inline">\((v,w)\leq0\)</span>。这就证明了 <span class="math inline">\(w\sim v\)</span>。</p><p>2 <span class="math inline">\(\Rightarrow\)</span> 1: 不妨设 <span class="math inline">\(\mathcal{P}\)</span>中任何两个球帽至多只有一个交点。则对任何 <span class="math inline">\(k_1,k_2\in\mathcal{P}\)</span>，内积 <span class="math inline">\((\cdot,\cdot)\)</span> 限制在二维子空间 <span class="math inline">\(U=\mathrm{span}\{k_1,k_2\}\)</span>上肯定不是正定的，否则的话 <span class="math inline">\(U^\bot=k_1^\bot\cap k_2^\bot\)</span> 是 time-like的，从而 <span class="math inline">\(C_{k_1}\)</span> 和 <span class="math inline">\(C_{k_2}\)</span> 会在 <span class="math inline">\(\mathcal{H}\)</span> 的内部有交点，所以 <span class="math inline">\(|(k_1,k_2)|\geq1\)</span>。如果 <span class="math inline">\((k_1,k_2)\geq1\)</span>，则 <span class="math inline">\(C_{k_1}\cap C_{-k_2}\)</span> 和 <span class="math inline">\(C_{-k_1}\cap C_{k_2}\)</span>中必有一个至多只包含一个点，不妨设 <span class="math inline">\(|C_{k_1}\cap C_{-k_2}|\leq1\)</span>。但是根据已知<span class="math inline">\(C_{k_1}\cap C_{k_2}\)</span>也至多只包含一个点，从而 <span class="math inline">\(C_{k_1}\)</span>作为二者的并至多只有一个点，矛盾。<span class="math inline">\(\blacksquare\)</span></p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.6</span>.</span><span class="statement-spah"> </span>记 <span class="math inline">\(\Omega_r=\{\omega\in\Omega\mid(\omega,\omega)&gt;0\}\)</span> 是所有实权组成的集合，<span class="math inline">\(\mathcal{C}_r=\mathrm{cone}(\Omega_r)\)</span>是由所有实权生成的凸锥。</p></div><div id="real-cone-closure" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.7</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(W\)</span> 是不可约、双曲的，且 level 大于等于2，则 <span class="math inline">\(\overline{\mathcal{C}_r}= \overline{\mathcal{C} }\)</span>。</p></div><p><strong>证明</strong>：只要证明 <span class="math inline">\(\overline{\mathcal{C}_r}\)</span>包含那些非实的基本权 <span class="math inline">\((\omega_s,\omega_s)\leq 0\)</span> 即可。若如此，则 <span class="math inline">\(\overline{\mathcal{C}_r}\)</span> 包含全部基本权<span class="math inline">\(\Delta^\ast\)</span>，从而也包含 <span class="math inline">\(\mathrm{cone}(\Delta^\ast)=\overline{\mathcal{D}}\)</span>，再结合<span class="math inline">\(\overline{\mathcal{C}_r}\)</span> 是 <span class="math inline">\(W\)</span>- 不变的，即得 <span class="math inline">\(\overline{\mathcal{C}_r}\)</span> 包含 <span class="math inline">\(\bigcup\limits_{w\inW}w\overline{\mathcal{D}}=\mathcal{C}\)</span>，从而包含 <span class="math inline">\(\overline{ \mathcal{C} }\)</span>。</p><p>设 <span class="math inline">\(\omega_s\)</span>是任一非实的基本权，记 <span class="math inline">\(I=S-\{s\}\)</span>，<span class="math inline">\(W_I\)</span> 为标准椭圆子群。</p><p><span class="math inline">\((\omega_s,\omega_s)&lt;0\)</span>的情形比较容易，这时 <span class="math inline">\(\omega_s\)</span> 是time-like 的，其正交补 <span class="math inline">\(V_I=\mathrm{span}\{\alpha_t\mid t\ne s\}\)</span>是 space-like 的，从而 <span class="math inline">\(W_I\)</span>是有限群。任取一个实的基本权 <span class="math inline">\((\omega_t,\omega_t)&gt;0\,(t\in I)\)</span> 并考虑<span class="math display">\[v = \sum_{w\in W_I}w(\omega_t),\]</span>显然 <span class="math inline">\(v\in\overline{\mathcal{C}_r}\)</span>，并且 <span class="math inline">\(W_I\)</span> 保持 <span class="math inline">\(v\)</span> 不动。特别地对任何 <span class="math inline">\(t\in I\)</span> 都有 <span class="math inline">\(t(v)=v\)</span>。这是 <span class="math inline">\(n-1\)</span>个独立的线性约束，其解空间是一维的，所以 <span class="math inline">\(v\)</span> 和 <span class="math inline">\(\omega_s\)</span> 共线：存在 <span class="math inline">\(a\in\mathbb{R}\)</span> 使得 <span class="math inline">\(v=a\omega_k\)</span>。两边同时与 <span class="math inline">\(\alpha_s\)</span> 作内积得到 <span class="math display">\[a = (\alpha_s,v)=\sum_{w\inW_I}(\alpha_s,w(\omega_t))=\sum_{w\in W_I}(w^{-1}(\alpha_s),\omega_t)=\sum_{w\in W_I}(w(\alpha_s), \omega_t).\]</span> 对任何 <span class="math inline">\(w\in W_I\)</span>，<span class="math inline">\(w\alpha_s=\alpha_s+\sum_{i\inI}c_i\alpha_i\)</span> 仍然是正根，所有的系数 <span class="math inline">\(c_i\)</span> 都非负。所以上式右边的每一项 <span class="math display">\[(w(\alpha_s), \omega_t)=\sum_{i\inI}c_i(\alpha_i, w_t) = c_t\geq0.\]</span> 我们来选择一个特殊的 <span class="math inline">\(w\in W_I\)</span> 使得 <span class="math inline">\(c_t&gt;0\)</span>：由于 <span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(\Gamma\)</span> 中存在一条从 <span class="math inline">\(s\)</span> 到 <span class="math inline">\(t\)</span> 的路径 <span class="math inline">\(s\sim s_1\sim\cdots\sim s_m=t\)</span>，其中每个<span class="math inline">\(s_i\,(i\geq1)\in I\)</span>且互不相同。不难验证对 <span class="math inline">\(w=s_m\cdots s_1\inW_I\)</span>，<span class="math inline">\(w\alpha_s\)</span> 的系数<span class="math inline">\(c_t&gt;0\)</span>，所以 <span class="math inline">\(a\)</span> 严格大于 0，所以 <span class="math inline">\(\omega_s=v/a\in\overline{\mathcal{C}_r}\)</span>。</p><p><span class="math inline">\((\omega_s, \omega_s)=0\)</span>的情形稍微麻烦一些：这时 <span class="math inline">\(\omega_s\)</span>的正交补 <span class="math inline">\(\omega_s^\bot\)</span> 是light-like 的，即子图 <span class="math inline">\(\Gamma\setminus\{s\}\)</span>是仿射的。特别地，<span class="math inline">\(\Gamma\setminus\{s\}\)</span>由一些仿射或者有限的连通成分组成，并且有且恰有一个连通成分是仿射的（否则两个线性无关的light-like 的向量的组合会给出 time-like 的向量）。任取一个实的基本权<span class="math inline">\((\omega_t,\omega_t)&gt;0\)</span>，我们需要讨论两种情况：</p><ol type="1"><li><p>如果 <span class="math inline">\(\omega_t\)</span>属于某个有限型的连通成分 <span class="math inline">\(Y\)</span>，类似上面的讨论，<span class="math inline">\(v = \sum_{w\inW_Y}w(\omega_t)\in\overline{\mathcal{C}_r}\)</span> 满足对任何 <span class="math inline">\(t\ne s\)</span> 都有 <span class="math inline">\(t(v)=v\)</span>，从而 <span class="math inline">\(v\)</span> 等于 <span class="math inline">\(\omega_s\)</span> 乘以一个正实数，从而 <span class="math inline">\(\omega_s\in\overline{\mathcal{C}_r}\)</span>。</p></li><li><p>如果 <span class="math inline">\(\omega_t\)</span>属于某个仿射型的连通成分 <span class="math inline">\(X\)</span>，设<span class="math inline">\(Y=\Gamma\setminus(X\cup\{s\})\)</span> 是<span class="math inline">\(\Gamma\setminus\{s\}\)</span> 除去 <span class="math inline">\(X\)</span> 以外其它连通成分的并，则 <span class="math inline">\(X\)</span> 和 <span class="math inline">\(Y\)</span> 互不连通，从而 <span class="math display">\[\omega_s = \underbrace{(\omega_s,\omega_s)}_{=0}\alpha_s + \sum_{t\ne s} (\omega_s,\omega_t)\alpha_t=\sum_{t\in X} (\omega_s,\omega_t)\alpha_t + \sum_{t\inY} (\omega_s,\omega_t)\alpha_t=v_1+v_2.\]</span> 这里 <span class="math inline">\(v_1\)</span> 和 <span class="math inline">\(v_2\)</span> 是正交的。于是 <span class="math display">\[(\omega_s, \omega_s)=0\Rightarrow(v_1+v_2,v_1+v_2)=0\Rightarrow (v_1,v_1) + (v_2,v_2) = 0.\]</span> 由于<span class="math inline">\(v_1\in V_X\)</span> 来自不可约仿射型，<span class="math inline">\(v_2\in V_Y\)</span> 来自有限型，所以 <span class="math inline">\(\mathbb{R}v_1=\mathrm{rad}(V_X)\)</span> 并且<span class="math inline">\(v_2=0\)</span>，从而 <span class="math inline">\(\omega_s=v_1\)</span>。于是 <span class="math inline">\(\mathbb{R}\omega_s=\mathrm{rad}(V_X)\)</span>。从而<span class="math inline">\(\omega_s\)</span> 表示为 <span class="math inline">\(\{\alpha_i\mid i\in X\}\)</span>的线性组合时，所有的系数 <span class="math inline">\((\omega_s,\omega_i)\)</span>系数都是非零且同号的。我们断言它们都小于 0。实际上在 <span class="math display">\[\omega_s=\sum_{i\in X}(\omega_s,\omega_i)\alpha_i\]</span> 两边同时用 <span class="math inline">\(\alpha_s\)</span> 作内积有 <span class="math display">\[1=(\omega_s,\alpha_s)=\sum_{i\in X} (\omega_s,\omega_i)\underbrace{(\alpha_s,\alpha_i)}_{\leq0}.\]</span> 所以必须所有<span class="math inline">\((\omega_s, \omega_i)&lt;0\)</span>。所以<span class="math inline">\(X\cup \{s\}\)</span> 构成的子图满足 <a href="/coxeter-groups-level/#ideal-vertex">这个结论</a>的条件，于是我们得到 <span class="math display">\[\omega_s\in\overline{\mathrm{cone}(\bigcup_{w\in W_I}w(\omega_t))}\subset\overline{\mathcal{C}_r}.\]</span></p></li></ol><p><span class="math inline">\(\blacksquare\)</span></p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义5.8</span>.</span><span class="statement-spah"> </span>规定 <span class="math inline">\(\hat{\Omega}_r=\{\hat{\omega}\mid\omega\in\Omega_r\}\)</span>，其中 <span class="math inline">\(\hat{\omega}=\omega/\sqrt{(\omega,\omega)}\)</span>是将 <span class="math inline">\(\omega\)</span>归一化得到的单位向量。</p></div><div id="max-packing" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.9</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(W\)</span> 是双曲的，则 <span class="math inline">\(\hat{\Omega}_r\)</span> 是非平凡的球堆当且仅当<span class="math inline">\(\Gamma\)</span> 的 level 是 2，这时 <span class="math inline">\(\hat{\Omega}_r\)</span> 还是极大球堆。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(\Gamma\)</span>的 level 是 2，则 <a href="/coxeter-groups-level#level-12"><span class="math inline">\(\Omega_r\)</span>中的元素两两分离</a>，将其归一化后得到的 <span class="math inline">\(\hat{\Omega}_r\)</span> 仍然两两分离，所以 <span class="math inline">\(\hat{\Omega}_r\)</span> 的元素两两之间的内积 <span class="math inline">\(\leq -1\)</span>，从而 <span class="math inline">\(\hat{\Omega}_r\)</span>给出一个球堆。由于基本权是线性无关的，<span class="math inline">\(\hat{\Omega}_r\)</span>显然是非平凡的球堆。如果存在某个 space-like 的向量 <span class="math inline">\(k\)</span> 满足 <span class="math inline">\((k,k)=1\)</span> 且 <span class="math inline">\(k\)</span> 对应的 <span class="math inline">\(C_k\)</span> 与 <span class="math inline">\(\hat{\Omega}_r\)</span>中的任何球都没有公共内部的话，则有 <span class="math inline">\((k,\hat{\omega})\leq -1\)</span> 对任何 <span class="math inline">\(\hat{\omega}\in\hat{\Omega}_r\)</span>成立，自然就有 <span class="math inline">\((k,\omega)&lt;0\)</span>对任何 <span class="math inline">\(\omega\in\Omega_r\)</span> 成立，从而<span class="math inline">\((k,y)\leq0\)</span> 对任何 <span class="math inline">\(y\in\overline{\mathcal{C}_r}=\mathrm{cone}(\Omega_r)\)</span>成立。根据 <a href="#real-cone-closure" title="定理 5.7">定理5.7</a>，<span class="math inline">\(\overline{\mathcal{C}_r}=\overline{\mathcal{C} }\)</span>，这意味着 <span class="math inline">\((k,y)\leq0\)</span> 对任何 <span class="math inline">\(y\in\mathcal{C}\)</span> 成立，即 <span class="math inline">\(-k\in\mathcal{C}^\ast\)</span>。由于 <a href="/coxeter-groups-tits-cone/#dual-cone-nonspace">对偶锥 <span class="math inline">\(\mathcal{C}^\ast\)</span> 中的向量范数 <span class="math inline">\(\leq0\)</span></a>，<span class="math inline">\((k,k)=(-k,-k)\leq0\)</span>，矛盾。这就证明了level 2 时 <span class="math inline">\(\Omega_r\)</span>是极大球堆。</p><p>反之若 <span class="math inline">\(\hat{\Omega}_r\)</span>是一个非平凡球堆，则 <span class="math inline">\(W\)</span> 的 level必然大于 1，且所有的实权之间两两分离。于是任何两个基本权生成的二维子空间<span class="math inline">\(\mathrm{span}\{\omega_i,\omega_j\}\)</span>都是 time-like 或者 light-like 的。又由于 <span class="math inline">\(W\)</span> 是双曲的，从而 <span class="math inline">\(\Gamma\setminus\{i,j\}\)</span> 是 space-like 或者light-like 的，所以 <span class="math inline">\(\Gamma\)</span> 的 level只能是 2。<span class="math inline">\(\blacksquare\)</span></p><h1 id="计算例子">计算例子</h1><p>本节我们来介绍怎样用程序实际绘制一个二维的 Boyd-Maxwell 球堆。</p><p>以 <span class="math inline">\(K_4\)</span>完全图为例，每条边的标号是 4：</p><p><img src="/images/coxeter/K4.svg" id="K4" class="fig" width="150"></p><p>这个群的 rank 是 4，level 是 2，所以给出的是 <span class="math inline">\(\mathbb{R}^2\)</span> 上的二维极大球堆。</p><p>单根系 <span class="math inline">\(\Delta=\{\alpha_i\}_{i=1}^4\)</span> 满足 <span class="math inline">\((\alpha_i,\alpha_i)=1\)</span>，它们对应 4个虚球。前面已经介绍了，以 <span class="math inline">\(\alpha_i\)</span>为法向量的单反射 <span class="math inline">\(s_i\)</span> 对应关于 <span class="math inline">\(B_i\)</span> 的反演变换，它们生成了 <span class="math inline">\((W,S)\)</span>。</p><p>由于删掉 <span class="math inline">\(K_4\)</span>的任何顶点后，剩下的是双曲三角群 <span class="math inline">\(\Delta(4,4,4)\)</span>，所以基本权 <span class="math inline">\(\Delta^\ast = \{\omega_i\}_{i=1}^4\)</span>都是实的。归一化以后 <span class="math inline">\(\{\hat{\omega}_i\}_{i=1}^4\)</span> 给出 4个互相分离的实球。由于 <span class="math inline">\(i\ne j\)</span> 时<span class="math inline">\((\alpha_i,\omega_j)=0\)</span>，所以 <span class="math inline">\(\alpha_i\)</span> 和 <span class="math inline">\(\hat{\omega}_j\)</span> 正交。又因为 <span class="math inline">\((\alpha_i,\omega_i)=1\)</span>，以及 <span class="math inline">\(\omega_i\)</span> 满足 <span class="math inline">\(0&lt;(\omega_i,\omega_i)\leq1\)</span>，所以归一化以后<span class="math inline">\((\alpha_i,\hat{\omega}_i)\geq1\)</span>，即球<span class="math inline">\(\alpha_i\)</span> 和 <span class="math inline">\(\hat{\omega}_i\)</span> 有包含关系。我们要求对每个<span class="math inline">\(i\)</span>，实球 <span class="math inline">\(\hat{\omega}_i\)</span> 包含在虚球 <span class="math inline">\(\alpha_i\)</span>的内部（即正半空间）。这是因为在计算时，我们要反复将平面上的点关于 <span class="math inline">\(\{\alpha_i\}\)</span> 作反演，直到它落入基本区域<span class="math inline">\(\overline{\mathcal{D}}\)</span>为止，然后判断这个最终位置属于哪个实球。所以我们一定要让虚球 <span class="math inline">\(\alpha_i\)</span> 包含实球 <span class="math inline">\(\hat{\omega_i}\)</span>。</p><p>将 <span class="math inline">\(W\)</span> 作用在实球 <span class="math inline">\(\{C_i\}\)</span>上，得到的所有球即为所要绘制的球堆 <span class="math inline">\(\mathcal{P}=\bigcup_{w\in W,\,1\leq i\leq4}w(\hat{\omega}_i)\)</span>。</p><p>我们按照如下步骤来分别计算 <span class="math inline">\(\{\alpha_i\}\)</span> 和 <span class="math inline">\(\{\hat{\omega}_j\}\)</span>：</p><ol type="1"><li>第一个实球 <span class="math inline">\(\hat{\omega}_1\)</span>总是可以取为单位球 <span class="math inline">\(B(\mathbf{0},1)\)</span>。<strong>并且 <span class="math inline">\(\hat{\omega}_1\)</span>是无界球</strong>。由于实球之间互不相交，所以 <span class="math inline">\(\hat{\omega}_2,\hat{\omega}_3,\hat{\omega}_4\)</span>都落在单位球内。</li><li>两个虚球 <span class="math inline">\(\alpha_3,\alpha_4\)</span>可以取为过原点的两条直线，法向量分别为 <span class="math display">\[\begin{aligned}\mathbf{n}_3&amp;=(1, 0),\\\mathbf{n}_4&amp;=(-\cos\frac{\pi}{m_{3,4}},\sin\frac{\pi}{m_{3,4}})=(-\cos\frac{\pi}{4},\sin\frac{\pi}{4}).\end{aligned}\]</span></li><li>第二个虚球 <strong><span class="math inline">\(\alpha_2=B(\mathbf{a}_2,r_2)\)</span>是一个无界球</strong>，即 <span class="math inline">\(r_2&lt;0\)</span>。我们可以认为 <span class="math inline">\(r_2&gt;0\)</span>，但是在列方程时将 <span class="math inline">\(B\)</span> 与其它球的内积取负：<ul><li>由 <span class="math inline">\(\alpha_2\)</span> 与 <span class="math inline">\(\hat{\omega}_1\)</span> 正交可得 <span class="math inline">\(|\mathbf{a}_2|^2=r_2^2+1\)</span>；</li><li>计算 <span class="math inline">\(\alpha_2\)</span> 与 <span class="math inline">\(\alpha_3,\alpha_4\)</span> 的夹角可得（注意 <span class="math inline">\(\cos\)</span> 前面没有负号了） <span class="math display">\[\begin{aligned}\frac{(\mathbf{a}_2,\mathbf{n}_3)}{r_2}&amp;=\cos\frac{\pi}{m_{23}}=\cos\frac{\pi}{4},\\\frac{(\mathbf{a}_2,\mathbf{n}_4)}{r_2}&amp;=\cos\frac{\pi}{m_{24}}=\cos\frac{\pi}{4}.\end{aligned}\]</span></li></ul>由这三个方程可以解出 <span class="math inline">\(\mathbf{a}_2\)</span>和 <span class="math inline">\(r_2\)</span>。</li><li>第一个虚球 <strong><span class="math inline">\(\alpha_1=B(\mathbf{a}_1,r_1)\)</span>也是一个无界球</strong>，即 <span class="math inline">\(r_1&lt;0\)</span>。我们同样认为 <span class="math inline">\(r_1&gt;0\)</span>，并在列方程时将它与其它球的内积取负：<ul><li>计算 <span class="math inline">\(\alpha_1\)</span> 与 <span class="math inline">\(\alpha_3,\alpha_4\)</span> 夹角可得 <span class="math display">\[\begin{aligned}\frac{(\mathbf{a}_1,\mathbf{n}_3)}{r_1}&amp;=\cos\frac{\pi}{m_{13}}=\cos\frac{\pi}{4},\\\frac{(\mathbf{a}_1,\mathbf{n}_4)}{r_1}&amp;=\cos\frac{\pi}{m_{14}}=\cos\frac{\pi}{4}.\end{aligned}\]</span></li><li>计算 <span class="math inline">\(\alpha_1\)</span> 与 <span class="math inline">\(\alpha_2\)</span> 夹角可得 <span class="math display">\[\frac{r_1^2+r_2^2-|\mathbf{a}_1-\mathbf{a}_2|^2}{2r_1r_2}=-\cos\frac{\pi}{m_{12}}=-\cos\frac{\pi}{4}.\]</span>注意由于 <span class="math inline">\(\alpha_1,\alpha_2\)</span>都是无界球，所以负号又回来了。</li></ul>由这三个方程可以得到一个二次方程，解出的 <span class="math inline">\(r_1\)</span>有两个值，我们取较小的那一个。（原因在后面解释）</li><li>我们还剩下三个实球 <span class="math inline">\(\hat{\omega}_2,\hat{\omega}_3,\hat{\omega}_4\)</span>需要解出。<span class="math inline">\(\hat{\omega}_2\)</span> 需要和<span class="math inline">\(\alpha_3,\alpha_4\)</span>正交，所以它是一个以原点为中心的球，而它又要和 <span class="math inline">\(\alpha_1\)</span> 正交，所以 <span class="math inline">\(\hat{\omega}_2\)</span> 的半径为 <span class="math inline">\(\sqrt{|\mathbf{a}_1|^2-r_1^2}\)</span>。</li><li><span class="math inline">\(\hat{\omega}_3\)</span> 与 <span class="math inline">\(\alpha_1,\alpha_2,\alpha_4\)</span>正交，这可以得到三个方程。联立解出 <span class="math inline">\(\hat{\omega}_3\)</span>。</li><li><span class="math inline">\(\hat{\omega}_4\)</span> 与 <span class="math inline">\(\alpha_1,\alpha_2,\alpha_3\)</span>正交，也可以得到三个方程，联立解出 <span class="math inline">\(\hat{\omega}_4\)</span>。</li></ol><p>结果如下图所示，单根 <span class="math inline">\(\alpha_i\)</span>对应的虚球用虚线绘制，<span class="math inline">\(\hat{\omega}_i\)</span>对应的实球用实线绘制，同样的 <span class="math inline">\(i\)</span>使用同样的颜色。上标 <span class="math inline">\(\ast\)</span>表示该球以无界区域为内部。所以我们有三个无界的球 <span class="math inline">\(\alpha_1,\alpha_2,\omega_1\)</span>。</p><p><img src="/images/coxeter/compute_example_K4.svg" class="fig" width="500"></p><p>注意到关于 <span class="math inline">\(\hat{\omega}_1\)</span>的反演保持虚球 <span class="math inline">\(\alpha_2,\alpha_3,\alpha_4\)</span>不变，因为它们都与 <span class="math inline">\(\hat{\omega}_1\)</span>正交；同时将 <span class="math inline">\(\alpha_1\)</span>变成另一个关于 <span class="math inline">\(\hat{\omega}_1\)</span>对称的球 <span class="math inline">\(\gamma_1\)</span>。反演变换是保角的，所以 <span class="math inline">\(\{\gamma_1,\alpha_2,\alpha_3,\alpha_4\}\)</span>也是一组夹角符合要求的镜面球，但是包含关系发生了改变，变成了 <span class="math inline">\(\gamma_1\)</span> 包含在 <span class="math inline">\(\hat{\omega}_1\)</span>的内部。这是错误的。这就是为什么前面求解 <span class="math inline">\(\alpha_1\)</span>的半径时我们要取那个较小的解（这两个解给出的球心形如 <span class="math inline">\(r_1\mathbf{x}\)</span> 和 <span class="math inline">\(r_2\mathbf{x}\,(\mathbf{x}\in\mathbb{R}^2)\)</span>，所以半径较小者一定在单位球内部）。</p><p>我们再举一个只有一个实权的例子：</p><p><img src="/images/coxeter/337.svg" id="337" class="fig" width="250"></p><p>这个群只有第一个顶点是实的，所以整个球堆完全由一个实球 <span class="math inline">\(\hat{\omega}_1\)</span> 生成：</p><p><img src="/images/coxeter/compute_example_337.svg" class="fig" width="500"></p><p>具体的计算步骤可以参考 shadertoy 动画代码中的注释：</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/WdGBz3?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><p>可以看到，每个实球都呈现一个二维的 Poincaré密铺图案。这很好理解，因为如果 <span class="math inline">\(\omega_i\)</span> 是实权，记 <span class="math inline">\(I=S\setminus\{i\}\)</span>，则实球 <span class="math inline">\(\hat{\omega}_i\)</span> 与虚球 <span class="math inline">\(\{\alpha_j\mid j\in I \}\)</span>都正交，这些虚球在 <span class="math inline">\(\hat{\omega}_1\)</span>中围成一个测地三角形，关于这个三角形三条边的反射生成的群是标准椭圆子群<span class="math inline">\(W_I\)</span>。<span class="math inline">\(W_I\)</span> 保持 <span class="math inline">\(\hat{\omega}_i\)</span>不动，同时将测地三角形映射为 <span class="math inline">\(\hat{\omega}_i\)</span> 中的双曲密铺。在前面 <a href="#K4"><span class="math inline">\(K_4\)</span> 的例子</a> 中，有 4个初始实球，它们每一个都呈现 <span class="math inline">\(\Delta(4,4,4)\)</span> 的双曲密铺；在 <a href="#337"><span class="math inline">\({\rm\color{red}o\color{red}}-{\rm o}-{\rmo}\overset{7}{-}{\rm o}\)</span> 的例子</a> 中，只有一个初始实球，它呈现<span class="math inline">\(\Delta(2,3,7)\)</span> 的双曲密铺。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Maxwell82" class="csl-entry" role="listitem">Maxwell, George. 1982. <span>“Sphere Packings and Hyperbolic ReflectionGroups.”</span> <em>Journal of Algebra</em> 79 (1): 78–97. <a href="https://doi.org/10.1016/0021-8693(82)90318-0">https://doi.org/10.1016/0021-8693(82)90318-0</a>.</div><div id="ref-Maxwell89" class="csl-entry" role="listitem">———. 1989. <span>“Wythoff’s Construction for Coxeter Groups.”</span><em>Journal of Algebra</em> 123 (2): 351–77. <a href="https://doi.org/10.1016/0021-8693(89)90051-3">https://doi.org/10.1016/0021-8693(89)90051-3</a>.</div><div id="ref-ratcliffe" class="csl-entry" role="listitem">Ratcliffe, John G. 2006. <em>Foundations of Hyperbolic Manifolds</em>.Second. Vol. 149. Graduate Texts in Mathematics. Springer.</div></div>]]></content>
    
    
    <summary type="html">
&lt;p&gt;本文的内容主要来自 &lt;span class=&quot;citation&quot; data-cites=&quot;Maxwell82&quot;&gt;(&lt;a href=&quot;#ref-Maxwell82&quot; role=&quot;doc-biblioref&quot;&gt;Maxwell 1982&lt;/a&gt;)&lt;/span&gt; 和
&lt;span class=&quot;citation&quot; data-cites=&quot;Maxwell89&quot;&gt;(&lt;a href=&quot;#ref-Maxwell89&quot; role=&quot;doc-biblioref&quot;&gt;Maxwell 1989&lt;/a&gt;)&lt;/span&gt;，并修复了一些错误。Maxwell
在 &lt;span class=&quot;citation&quot; data-cites=&quot;Maxwell82&quot;&gt;(&lt;a href=&quot;#ref-Maxwell82&quot; role=&quot;doc-biblioref&quot;&gt;Maxwell 1982&lt;/a&gt;, pp
81)&lt;/span&gt; 中写到：&lt;/p&gt;
&lt;div class=&quot;statement simple plain unnumbered&quot;&gt;
&lt;p&gt;When &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;Gamma&#92;)&lt;/span&gt; is hyperbolic, the
cone&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;&#92;[&#92;{v&#92;in V&#92;mid (v,v)&#92;leq0&#92;}&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;has two connected components (after deleting 0), which are also the
equivalent classes for the relation &lt;span class=&quot;math display&quot;&gt;&#92;[u&#92;sim
v&#92;Leftrightarrow (u,v)&#92;leq0.&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这显然是错误的，因为如果 &lt;span class=&quot;math inline&quot;&gt;&#92;(u&#92;)&lt;/span&gt; 是
light-like 的向量，&lt;span class=&quot;math inline&quot;&gt;&#92;(u&#92;)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;&#92;(-u&#92;)&lt;/span&gt; 属于不同的分支。这个错误导致后面 &lt;span class=&quot;citation&quot; data-cites=&quot;Maxwell82&quot;&gt;(&lt;a href=&quot;#ref-Maxwell82&quot; role=&quot;doc-biblioref&quot;&gt;Maxwell 1982&lt;/a&gt;, prop 3.1)&lt;/span&gt;
的证明需要作一些修改。详情见下面的 &lt;a href=&quot;#thm-sphere-packing&quot; title=&quot;定理 5.5&quot;&gt;定理 5.5&lt;/a&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Coxeter Groups" scheme="https://pywonderland.com/categories/Coxeter-Groups/"/>
    
    
  </entry>
  
  <entry>
    <title>Coxeter 群笔记（五）：Coxeter 群的 level</title>
    <link href="https://pywonderland.com/coxeter-groups-level/"/>
    <id>https://pywonderland.com/coxeter-groups-level/</id>
    <published>2021-12-07T16:00:00.000Z</published>
    <updated>2025-03-05T12:32:07.567Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要改写自 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>)</span>和<span class="citation" data-cites="Maxwell89">(<a href="#ref-Maxwell89" role="doc-biblioref">Maxwell1989</a>)</span>。</p><p>我们来介绍 Coxeter 群的 level 的概念，并证明 level 等于 1 或 2的群都是双曲的。</p><h1 id="level-的定义">level 的定义</h1><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span> <span class="statement-info">(<span class="citation" data-cites="Maxwell82">Maxwell (<a href="#ref-Maxwell82" role="doc-biblioref">1982</a>)</span>)</span>.</span><span class="statement-spah"> </span><span class="math inline">\((W,S)\)</span> 的 level 定义为最小的非负整数 <span class="math inline">\(l\)</span>，使得在 <span class="math inline">\(\Gamma\)</span> 中删去任何 <span class="math inline">\(l\)</span>个顶点后，剩下的部分每个连通分支都是仿射或者有限的。</p></div><span id="more"></span><p>根据定义有限和仿射 Coxeter 群的 level 都是0（因为不需要删去任何顶点）。</p><p>我们来看几个 level 大于 0 的例子：</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span></p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr class="odd"><td style="text-align: center;">level=1</td><td style="text-align: center;">level=2</td><td style="text-align: center;">level=3</td></tr><tr class="even"><td style="text-align: center;"><img src="/images/coxeter/level1.svg" class="fig" width="120"></td><td style="text-align: center;"><img src="/images/coxeter/level2.svg" class="fig" width="120"></td><td style="text-align: center;"><img src="/images/coxeter/level3.svg" class="fig" width="120"></td></tr></tbody></table><ul><li>左图的三条边标号分别是 <span class="math inline">\((3,3,7)\)</span>，它是双曲的；但是删去任何一个顶点后剩下的两个顶点给出一个有限二面体群，所以其level 等于 1。</li><li>中间图的三条边标号（采用了 Vinberg 记号）分别是 <span class="math inline">\((3, 4,-1.1)\)</span>，它删去红色顶点以后剩下的两个顶点仍然构成一个双曲群，所以level 大于 1；删去任何两个顶点的话只剩一个顶点当然是有限的，所以这个群的level 就是 2。</li><li>右图删去两个红色顶点以后剩下的两个顶点仍然构成一个 Vinberg记号下的双曲群，所以 level 大于2；删去任何三个顶点以后只剩一个顶点当然是有限的，所以这个群的 level 等于3。</li></ul></div><div id="level-l" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(\Gamma\)</span> 是连通的，且 level 等于 <span class="math inline">\(l\)</span>，则在 <span class="math inline">\(\Gamma\)</span> 中删去任何 <span class="math inline">\(l+1\)</span>个顶点后，剩下的每个连通成分都是有限的。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(l\)</span>归纳。当 <span class="math inline">\(l=0\)</span>时，由于在一个有限或者仿射的连通图中删去任何一个顶点后剩下的一定是有限子图<span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.2.6</a>)</span>，所以结论成立。</p><p>假设结论对所有小于 <span class="math inline">\(l\)</span>的正整数成立，考虑 <span class="math inline">\(l\)</span>的情形。用反证法。</p><p>假设从 <span class="math inline">\(\Gamma\)</span> 中删去 <span class="math inline">\(\{i_1,\ldots,i_{l+1}\}\)</span> 这 <span class="math inline">\(l+1\)</span>个顶点后，剩下的部分中某个连通分支是仿射的。不妨设 <span class="math inline">\(\Gamma\setminus\{i_1,\ldots,i_{l+1}\}=\Gamma'\cup\Gamma''\)</span>，其中<span class="math inline">\(\Gamma'\)</span>是一个仿射的连通分支，<span class="math inline">\(\Gamma''\)</span>（可能为空集）和 <span class="math inline">\(\Gamma'\)</span> 之间没有边相连。</p><p><img src="/images/coxeter/lemma.svg" class="fig" width="400"></p><p>由于 <span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(\Gamma'\)</span> 必然和 <span class="math inline">\(\{i_1,\ldots,i_{l+1}\}\)</span>中某个顶点有边连接，不妨设为 <span class="math inline">\(i_{l+1}\)</span>。</p><p>由于 <span class="math inline">\(\Gamma\)</span> 的 level 是 <span class="math inline">\(l\)</span>，所以 <span class="math inline">\(\{i_{l+1}\}\cup\Gamma'\subseteq\Gamma\setminus\{i_1,\ldots,i_l\}\)</span>是一个仿射的连通子图，这个仿射子图删除 <span class="math inline">\(i_{l+1}\)</span> 后得到的 <span class="math inline">\(\Gamma'\)</span> 仍然是仿射的，这与 <span class="math inline">\(l=0\)</span> 的情形矛盾，所以结论得证。<span class="math inline">\(\blacksquare\)</span></p><h1 id="两个恒等式">两个恒等式</h1><p>这一节是纯技术性的，我会介绍两个关于 <span class="math inline">\(\Delta=\{\alpha_s\mid s\in S\}\)</span> 和对偶基<span class="math inline">\(\Delta^\ast=\{\omega_s\mid s\in S\}\)</span>之间关系的显然等式，这样下文用到它们时就不必再重复说明。</p><p>在本节中我们都假定内积 <span class="math inline">\((\cdot,\cdot)\)</span>是非退化的，于是我们可以通过 <span class="math inline">\((\cdot,\cdot)\)</span> 将 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 等同起来：对任何 <span class="math inline">\(\alpha_s\in\Delta\)</span> 和 <span class="math inline">\(\omega_t\in\Delta^\ast\)</span> 有 <span class="math inline">\((\alpha_s,\omega_t)=\delta_{st}\)</span>。</p><p>内积 <span class="math inline">\((\cdot,\cdot)\)</span> 在 <span class="math inline">\(\Delta\)</span> 这组基下的 Gram 矩阵记作 <span class="math display">\[A=\big((\alpha_s,\alpha_t)\big)_{s,t\in S}\.\]</span> 则 <span class="math inline">\((\cdot,\cdot)\)</span> 在<span class="math inline">\(\Delta^\ast\)</span> 这组基下的 Gram矩阵就是 <span class="math display">\[A^{-1}=\big((\omega_s,\omega_t)\big)_{s,t\in S}\.\]</span> <span class="math inline">\(A\)</span> 的第 <span class="math inline">\(s\)</span> 行与 <span class="math inline">\(A^{-1}\)</span> 的第 <span class="math inline">\(s\)</span> 列的点积是 1，所以 <span class="math display">\[1=\sum_{t\in S}(\alpha_s,\alpha_t)\cdot(\omega_t,\omega_s)=(\omega_s,\omega_s)+\sum_{t\nes}(\omega_t,\omega_s)\cdot(\alpha_s,\alpha_t).\tag{I}\label{eq:idI}\]</span>这是我们的第一个恒等式。</p><p>设 <span class="math inline">\(\mathbf{A}\)</span> 是 <span class="math inline">\(V\)</span> 上的线性变换，满足对每个 <span class="math inline">\(s\in S\)</span> 有 <span class="math inline">\(\mathbf{A}(\omega_s)=\alpha_s\)</span>，则 <span class="math inline">\(\mathbf{A}\)</span> 在 <span class="math inline">\(\{\omega_s\}\)</span> 这组基下的矩阵就是 <span class="math inline">\(A\)</span>： <span class="math display">\[(\alpha_1,\ldots,\alpha_n)=(\omega_1,\ldots,\omega_n)A.\]</span> 于是 <span class="math display">\[(\omega_1,\ldots,\omega_n)=(\alpha_1,\ldots,\alpha_n)A^{-1}.\]</span>在两边取下标为 <span class="math inline">\(s\)</span> 的列，得到 <span class="math display">\[\omega_s = \sum_{t\in S}\alpha_t \cdot(\omega_t,\omega_s)=(\omega_s,\omega_s)\alpha_s + \sum_{t\ne s}(\omega_s,\omega_t)\alpha_t.\tag{II}\label{eq:idII}\]</span>这是我们的第二个恒等式。</p><h1 id="level-1-是双曲的">Level 1 是双曲的</h1><p>本节来证明 level 等于 1 的群都是双曲的。</p><p>首先是一个定义：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义3.1</span>.</span></p><ul><li>如果 <span class="math inline">\(v\in V\)</span> 满足 <span class="math inline">\((v, v)&gt;0\)</span>，我们就称 <span class="math inline">\(v\)</span> 是<strong>实的</strong>。</li><li>如果 <span class="math inline">\(u,v\in V\)</span> 满足 <span class="math inline">\((u,v)\leq 0\)</span> 且 <span class="math inline">\(u,v\)</span> 张成的二维子空间 <span class="math inline">\(\mathrm{span}\{u,v\}\)</span><strong>不是正定</strong>的，就称 <span class="math inline">\(u,v\)</span> 是<strong>分离</strong>的(disjoint)。</li></ul></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在 <span class="math inline">\((\cdot,\cdot)\)</span> 是Lorentzian 内积时，<span class="math inline">\(v\)</span> 是实的等价于<span class="math inline">\(v\)</span> 是 space-like 的。</p></div><div id="lemma-uv" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\Gamma\)</span> 的 level 大于等于1，并且不是双曲的，则 <span class="math inline">\(V\)</span>中存在两个互相正交的向量 <span class="math inline">\(u,v\)</span> 满足<span class="math inline">\((u,u)&lt;0\)</span> 和 <span class="math inline">\((v,v)=0\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(\Gamma\)</span> 的 level 大于等于 1，所以 <span class="math inline">\((\cdot,\cdot)\)</span>不可能是正定或者半正定的，显然也不可能是负定/半负定的（因为所有根 <span class="math inline">\(\alpha\)</span> 的范数都是 1），所以 <span class="math inline">\((\cdot,\cdot)\)</span> 的正负惯性指数都非 0。如果<span class="math inline">\(W\)</span> 不是双曲的，那么有两种可能：</p><ol type="1"><li><span class="math inline">\((\cdot,\cdot)\)</span> 的负惯性指数是 1且 <span class="math inline">\(\mathrm{rad}(V)\ne\{0\}\)</span>。</li><li><span class="math inline">\((\cdot,\cdot)\)</span>的负惯性指数至少是 2。</li></ol><p>情形 1 可以取 <span class="math inline">\(V\)</span>的一组正交基包含两个向量 <span class="math inline">\(u,v\)</span> 满足<span class="math inline">\((u, u)=-1\)</span> 和 <span class="math inline">\((v,v)=0\)</span>。情形 2 可以取 <span class="math inline">\(V\)</span> 的一组正交基包含三个向量 <span class="math inline">\(x,y,z\)</span> 满足 <span class="math inline">\((x,x)=1\)</span> 和 <span class="math inline">\((y, y)=(z,z)=-1\)</span>，然后取 <span class="math inline">\(u=z\)</span> 和 <span class="math inline">\(v=x+y\)</span>，则 <span class="math inline">\(u,v\)</span> 正交且 <span class="math inline">\((u,u)=-1,\,(v,v)=0\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="level-1" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.3</span> <span class="statement-info">(<span class="citation" data-cites="Maxwell82">Maxwell (<a href="#ref-Maxwell82" role="doc-biblioref">1982</a>)</span>)</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(\Gamma\)</span> 的 level 是 1，则 <span class="math inline">\(\Gamma\)</span> 是双曲的。所有的 <a href="/coxeter-groups-tits-cone#fundamental-weights">基本权</a>都不是实的并且两两分离。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>当 <span class="math inline">\(|S|=4\)</span> 时，level 1 的Coxeter 群给出了三维双曲空间中的<strong>紧</strong> (compact)和<strong>仿紧</strong> (paracompact)的蜂巢结构。基本权不是实的意味着所有的权都不是实的，即蜂巢的顶点全部位于双曲空间的内部或者边界上。维基百科的<a href="https://en.wikipedia.org/wiki/Uniform_honeycombs_in_hyperbolic_space">这个页面</a>上列出了所有紧和仿紧的蜂巢。</p></div><p><strong>证明</strong>：首先注意到 <span class="math inline">\(\Gamma\)</span> 的 level 是 1 蕴含了 <span class="math inline">\(\Gamma\)</span> 是连通的，若不然，设 <span class="math inline">\(\Gamma=\Gamma_1\cup\cdots\cup\Gamma_k\)</span>是多于一个连通分支的并，则每个分支 <span class="math inline">\(\Gamma_i\)</span>作为删去其它分支后剩下的子图必须都是有限或者仿射的，但这导致 <span class="math inline">\(\Gamma\)</span> 的 level 是 0，矛盾。</p><p>我们需要证明三件事情：</p><ol type="1"><li>内积 <span class="math inline">\((\cdot,\cdot)\)</span>的正负惯性指数是 <span class="math inline">\((n-1, 1)\)</span>；</li><li>任何基本权 <span class="math inline">\(\omega_s\)</span> 满足 <span class="math inline">\((\omega_s,\omega_s)\leq0\)</span>；</li><li>任何两个基本权 <span class="math inline">\(\omega_s,\omega_t\)</span> 满足 <span class="math inline">\((\omega_s,\omega_t)\leq0\)</span>并且它们生成的二维子空间 <span class="math inline">\(\mathrm{span}\{\omega_i,\omega_j\}\)</span>不是正定的。</li></ol><p>先证明 1。用反证法，如果 <span class="math inline">\(\Gamma\)</span>的 level 是 1 但不是双曲的，则根据 <a href="#lemma-uv" title="引理 3.2">引理 3.2</a> 我们可以取两个正交的非零向量 <span class="math inline">\(u,v\)</span> 满足 <span class="math inline">\((u,u)&lt;0,\, (v,v)=0\)</span>。</p><p>我们有如下两个断言：</p><div id="assetA" class="statement sta___ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">断言</span>.</span><span class="statement-spah"></span><br></p><ol type="1"><li>任何满足 <span class="math inline">\((u,u)&lt;0\)</span> 的向量<span class="math inline">\(u=\sum_{s\in S}u_s\alpha_s\)</span> 其系数<span class="math inline">\(u_s\)</span> 都非零且同号。</li><li>任何满足 <span class="math inline">\((v,v)=0\)</span> 的向量 <span class="math inline">\(v=\sum_{s\in S}v_s\alpha_s\)</span> 其系数 <span class="math inline">\(v_s\)</span> 至多只有一个为 0，其余都同号。</li></ol></div><p>我把这两个断言的证明放在 <a href="#appendixA">附录</a>中，先承认它们是正确的，用它们来导出矛盾：</p><p>取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(v_s\ne 0\)</span>，则 <span class="math inline">\(u'=v_su-u_sv\)</span> 满足 <span class="math inline">\((u',u')=v_s^2(u,u)&lt;0\)</span>，且 <span class="math inline">\(u'\)</span> 的 <span class="math inline">\(\alpha_s\)</span> 项系数 <span class="math inline">\(u'_s=0\)</span>，这与断言 1 矛盾。所以 <span class="math inline">\(\Gamma\)</span> 是双曲的。</p><p>再来证明 2。</p><p>由于 <span class="math inline">\(\Gamma\)</span> 的 level 是1，对任何 <span class="math inline">\(s\in S\)</span>，子空间 <span class="math inline">\(\omega_s^\bot=\mathrm{span}\{\alpha_t\mid t\nes\}\)</span> 是有限或者仿射的，从而 <a href="/coxeter-groups-three-cases/#orth-complement-lorentzian"><span class="math inline">\(\omega_s\)</span> 不是 space-like 的</a>，即 <span class="math inline">\((\omega_s,\omega_s)\leq 0\)</span>。于是任何 <span class="math inline">\(\omega_s\,(s\in S)\)</span> 都不是实的。</p><p>再来证明 3。</p><p>观察恒等式 <span class="math inline">\((\ref{eq:idII})\)</span>：<span class="math display">\[\omega_s = (\omega_s,\omega_s)\alpha_s +\sum_{t\ne s} (\omega_s,\omega_t)\alpha_t.\]</span></p><p>结论 2 中已经证明了必然有 <span class="math inline">\((\omega_s,\omega_s)\leq0\)</span>。根据 <a href="#assetA" title="断言">断言</a> 我们有：</p><ol type="1"><li>如果 <span class="math inline">\((\omega_s,\omega_s)&lt;0\)</span>，则后面所有的系数<span class="math inline">\((\omega_s,\omega_t)\)</span> 都小于 0。</li><li>如果 <span class="math inline">\((\omega_s,\omega_s)=0\)</span>，则后面所有的系数<span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span>都不为 0 且同号。我们来确定它们的符号：根据恒等式 <span class="math inline">\((\ref{eq:idI})\)</span> <span class="math display">\[1 = (\omega_s,\omega_s) + \sum_{t\ne s}(\omega_s,\omega_t)(\alpha_t,\alpha_s)=\sum_{t\ne s}(\omega_s,\omega_t)\underbrace{(\alpha_t,\alpha_s)}_{\leq0},\]</span>显然只能是 <span class="math inline">\((\omega_s,\omega_t)&lt;0\)</span>。</li></ol><p>总之我们说明了对任何 <span class="math inline">\(s\ne t\)</span> 都有<span class="math inline">\((\omega_s,\omega_t)&lt;0\)</span>。此外二维子空间<span class="math inline">\(U_{s,t}={\rmspan}\{\omega_s,\omega_t\}\)</span> 的正交补是 <span class="math inline">\(U_{s,t}^\bot=\mathrm{span}\{\alpha_{k}\mid k\nes,t\}\)</span>，根据 <a href="#level-l" title="定理 1.2">定理 1.2</a><span class="math inline">\(U_{s,t}^\bot\)</span> 是 space-like 的，从而<span class="math inline">\(U_{s,t}\)</span> 是 time-like 的，从而 <span class="math inline">\(\{\omega_s,\omega_t\}\)</span> 是分离的。</p><p>至此定理得证。<span class="math inline">\(\blacksquare\)</span></p><div id="level-1-tits" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论3.4</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(W\)</span> 的 level 为 1，则 Tits 锥的闭包 <span class="math inline">\(\overline{ \mathcal{C} }\)</span> 等于 <span class="math inline">\(\mathcal{Q}_+\)</span> 或者 <span class="math inline">\(\mathcal{Q}_-\)</span> 之一。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个结论告诉我们在 level 1 时空间的边界上没有球堆。</p></div><p><strong>证明</strong>：由于 level 1 的群是双曲的，根据 <a href="/coxeter-groups-three-cases#tits-closure">双曲情形 Tits锥的结论</a>，<span class="math inline">\(\mathcal{C}\)</span> 包含<span class="math inline">\(\mathcal{N}_+,\mathcal{N}_-\)</span>之一，不妨设为 <span class="math inline">\(\mathcal{C}\supset\mathcal{N}_+\)</span>，则 <span class="math inline">\(\overline{ \mathcal{C} }\supset\overline{\mathcal{N}_+}=\mathcal{Q}_+\)</span>。还要再证明反向的包含关系。为此只要证明 <span class="math inline">\(\overline{ \mathcal{C}}\subset\mathcal{Q}\)</span> 和 <span class="math inline">\(\overline{\mathcal{C} }\cap\mathcal{Q}_-=\{0\}\)</span>。</p><p>根据 <a href="#level-1" title="定理 3.3">定理 3.3</a>，所有的基本权<span class="math inline">\(\{\omega_s\}\)</span>都不是实的且两两分离。设 <span class="math inline">\(x=\sum_{s\inS}c_s\omega_s\,(c_s\geq0)\)</span> 是 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 中任意一点，则<span class="math display">\[(x,x)=\sum_{s,t\inS}c_sc_t\underbrace{(\omega_s,\omega_t)}_{\leq0}\leq0.\]</span> 即 <span class="math inline">\(\overline{\mathcal{D}}\subset\mathcal{Q}\)</span>。<span class="math inline">\(W\)</span> 作为正交变换群保持 <span class="math inline">\(\mathcal{Q}\)</span> 不变，所以 <span class="math inline">\(\mathcal{C}=\bigcup\limits_{w\inW}w\overline{\mathcal{D}}\subset\mathcal{Q}\)</span>，从而 <span class="math inline">\(\overline{ \mathcal{C}}\subset\mathcal{Q}\)</span>。</p><p>再来说明 <span class="math inline">\(\overline{ \mathcal{C}}\cap\mathcal{Q}_-=\{0\}\)</span>。我们知道 <a href="/coxeter-groups-three-cases/#dual-cone-non-trivial"><span class="math inline">\(\mathcal{C}^\ast\ne\{0\}\)</span></a>。我们断言<span class="math inline">\(\mathcal{C}^\ast\)</span> 必然包含某个time-like 的向量 <span class="math inline">\((z,z)&lt;0\)</span>。否则<a href="/coxeter-groups-tits-cone#dual-cone-nonspace"><span class="math inline">\(\mathcal{C}^\ast\)</span> 中的非零向量都是light-like 的</a>。但是 <span class="math inline">\(\mathcal{C}^\ast\)</span> 不能包含两个线性无关的light-like 的向量（否则由于 <a href="/coxeter-groups-three-cases/#dual-cone-belongs-branch">它们属于<span class="math inline">\(\mathcal{Q}\)</span> 的同一个分支</a> 从而<a href="/coxeter-groups-three-cases/#connected-component-dot">内积小于0</a>，从而它们的任何正线性组合是属于 <span class="math inline">\(\mathcal{C}^\ast\)</span> 的 time-like的向量），再结合 <span class="math inline">\(\mathcal{C}^\ast\)</span>是 <a href="/coxeter-groups-tits-cone/#tits-cone-dual-pointed">点锥</a>，所以<span class="math inline">\(\mathcal{C}^\ast=\mathbb{R}_{\geq0}\delta\)</span>，其中<span class="math inline">\(\delta\)</span> 是一个 light-like的向量。取对偶得到 <span class="math display">\[\overline{ \mathcal{C}}=\mathcal{C}^{\ast\ast}=\{v\in V\mid (v,\delta)\geq0\}.\]</span>这是一个半空间，显然包含 space-like 的向量，这与 <span class="math inline">\(\overline{ \mathcal{C}}\subset\mathcal{Q}\)</span> 矛盾。所以确实存在 <span class="math inline">\(z\in\mathcal{C}^\ast\)</span> 满足 <span class="math inline">\((z,z)&lt;0\)</span>。又因为 <span class="math inline">\(\mathcal{Q}_+\subset\overline{ \mathcal{C}}\)</span>，所以 <span class="math inline">\(z\in\mathcal{Q}_-\)</span>。</p><p>设 <span class="math inline">\(x\ne0\in\overline{ \mathcal{C}}\cap\mathcal{Q}_-\)</span>，则 <span class="math inline">\((x,z)&lt;0\)</span>，这与 <span class="math inline">\(z\in\mathcal{C}^\ast\)</span> 和 <span class="math inline">\(x\in\overline{ \mathcal{C} }\)</span> 矛盾。所以<span class="math inline">\(\overline{ \mathcal{C}}\cap\mathcal{Q}_-=\{0\}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="ideal-vertex" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.5</span> <span class="statement-info">(<span class="citation" data-cites="Maxwell89">(<a href="#ref-Maxwell89" role="doc-biblioref">Maxwell 1989</a>, proposition5.15)</span>)</span>.</span><span class="statement-spah"> </span>设<span class="math inline">\(s\in S\)</span> 使得如下条件成立：</p><ol type="1"><li><span class="math inline">\((\omega_s,\omega_s)=0\)</span>。</li><li>子图 <span class="math inline">\(\Gamma\setminus\{s\}\)</span>是不可约、仿射的。</li><li>对任何 <span class="math inline">\(t\ne s\)</span> 有 <span class="math inline">\((\omega_s,\omega_t)&lt;0\)</span>。</li></ol><p>记 <span class="math inline">\(I=S\setminus\{s\}\)</span>，则对任意点<span class="math inline">\(p\in\overline{\mathcal{D}}\)</span> 都有<span class="math inline">\(\omega_s\in\overline{\mathrm{cone}(\bigcup_{w\in W_I}wp) }\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这里没有限制 <span class="math inline">\(W\)</span> 的level。</p><p>此外 <span class="math inline">\(\bigcup_{w\in W_I}wp\)</span>是无限集，<span class="math inline">\(\mathrm{cone}(\bigcup_{w\inW_I})\)</span> 未必是闭集，因此闭包记号不可少。</p><p>当 <span class="math inline">\(W\)</span> 的 level 是 1 时，若 <span class="math inline">\(\omega_s\)</span>是一个位于双曲空间边界上的理想顶点，则命题的条件都满足。这时经过 <span class="math inline">\(\omega_s\)</span>的那些镜面生成的椭圆子群会把基本区域无限压缩到 <span class="math inline">\(\omega_s\)</span> 附近，如下图所示：</p><p><img src="/images/coxeter/ideal-vertex.jpg" class="fig" width="350"></p></div><p><strong>证明</strong>：由已知子空间 <span class="math inline">\(V_I=\mathrm{span}\{\alpha_t\mid t\ne s\}\)</span>是仿射的，并且 <span class="math inline">\(\mathrm{rad}(V_I)\)</span>是一维的。根据恒等式 <span class="math inline">\((\ref{eq:idII})\)</span> <span class="math display">\[\omega_s =\underbrace{(\omega_s,\omega_s)}_{=0}\alpha_s +  \sum_{t\ne s}(\omega_s,\omega_t)\alpha_t = \sum_{t\ne s}(\omega_s, \omega_t)\alpha_t\inV_I\]</span> 可得 <span class="math inline">\(\mathrm{rad}(V_I)=\mathbb{R}\omega_s\)</span>。于是<span class="math inline">\(W_I\)</span> 保持 <span class="math inline">\(\omega_s\)</span> 不动，即 <span class="math display">\[\mathbb{R}\omega_s\xrightarrow{\ W_I\, -\, 1\ }0.\]</span> <span class="math inline">\(W_I\)</span> 同样作用在商空间<span class="math inline">\(V_I/\mathbb{R}\omega_s\)</span>上，此作用给出了一个同态 <span class="math inline">\(W_I\to\mathrm{GL}(V_I/\mathbb{R}\omega_s)\)</span>。令<span class="math inline">\(K\)</span> 为此同态的核，则对任何 <span class="math inline">\(w\in K\)</span>， <span class="math display">\[w(v+ \mathbb{R}\omega_s) = v + \mathbb{R}\omega_s,\quad v\in V_I.\]</span>即 <span class="math inline">\(wv-v\in\mathbb{R}\omega_s\)</span>，从而<span class="math display">\[V_I\xrightarrow{\ K - 1\}\mathbb{R}\omega_s\xrightarrow{\ W_I\, -\, 1\ } 0.\]</span> 由于 <span class="math inline">\(K\leqslant W_I\)</span>，所以 <span class="math display">\[V_I\xrightarrow{\ K - 1\}\mathbb{R}\omega_s\xrightarrow{\ K-1\ }0.\]</span> 即 <span class="math inline">\((K-1)^2\)</span> 在整个 <span class="math inline">\(V_I\)</span> 上恒为 0。</p><p>更进一步，对任何 <span class="math inline">\(w\in K\)</span>，<span class="math inline">\(w\alpha_s\)</span> 形如 <span class="math inline">\(w\alpha_s=\alpha_s+\sum\limits_{t\nes}c_t\alpha_t\)</span>，所以 <span class="math inline">\((w-1)\alpha_s\in V_I\)</span>，从而 <span class="math inline">\(w-1\)</span> 将整个 <span class="math inline">\(V\)</span> 也映入 <span class="math inline">\(V_I\)</span>，于是 <span class="math display">\[V\xrightarrow{\ K-1\ } V_I\xrightarrow{\ K - 1\}\mathbb{R}\omega_s\xrightarrow{\ K-1\ }0.\]</span> 即 <span class="math inline">\((K-1)^2V\subset\mathbb{R}\omega_s\)</span>，<span class="math inline">\((K-1)^3V\equiv0\)</span>。</p><p>取 <span class="math inline">\(w\in K\)</span> 且 <span class="math inline">\(w\ne 1\)</span> <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，由于 <span class="math inline">\(w\)</span> 在 <span class="math inline">\(V_I\)</span> 上不是恒等变换，所以存在 <span class="math inline">\(t\in I\)</span> 使得 <span class="math inline">\(w\alpha_t\ne\alpha_t\)</span>。设 <span class="math display">\[\beta = w\alpha_t=\alpha_t+a\omega_s\,(a\ne0).\]</span> 则 <span class="math inline">\(s_\beta=wtw^{-1}\)</span>，从而对任何 <span class="math inline">\(p\in V\)</span>， <span class="math display">\[\begin{align*}s_\beta(p)&amp;=p - 2(p,\beta)\beta\\&amp;=p-2(p,\alpha_t+a\omega_s)(\alpha_t+a\omega_s)\\&amp;=p-2(p,\alpha_t)\alpha_t- 2a(p, \omega_s)\alpha_t - c\omega_s\\&amp;=t(p) - 2a(p, \omega_s)\alpha_t - c\omega_s.\end{align*}\]</span> 其中 <span class="math inline">\(c=2(p,\alpha_t+a\omega_s)a\)</span> 是实数。<span class="math inline">\(c\)</span> 具体是多少不用关心。</p><p>构造换位子 <span class="math inline">\(w_1=twtw^{-1}\inK\)</span>，则由 <span class="math inline">\((K-1)^2V\subset\mathbb{R}\omega_s\)</span> 有<span class="math inline">\((w_1-1)^2p=b\omega_s\,(b\in\mathbb{R})\)</span>。我们来计算<span class="math inline">\(b\)</span>。首先，</p><p><span class="math display">\[(w_1-1)p=ts_\beta(p)-p=-2a(p,\omega_s)\alpha_t -c\omega_s.\label{eq:wp1}\tag{1}\]</span> 其中我们利用了 <span class="math inline">\(t(\alpha_t)=-\alpha_t\)</span> 和 <span class="math inline">\(t(\omega_s)=\omega_s\)</span>。</p><p>到目前为止，我们的计算对任何 <span class="math inline">\(p\inV\)</span> 都是成立的。我们可以在 <span class="math inline">\((\ref{eq:wp1})\)</span> 式中取 <span class="math inline">\(p=\alpha_t\)</span>，得到 <span class="math display">\[(w_1-1)\alpha_t=2a\underbrace{(\alpha_t,\omega_s)}_{=0}\alpha_t-c\omega_s=-c\omega_s=-2(\alpha_t,\alpha_t+a\omega_s)a\omega_s=-2a\omega_s.\label{eq:wp2}\tag{2}\]</span></p><p>继续，将 <span class="math inline">\(w_1-1\)</span> 作用在 <span class="math inline">\((\ref{eq:wp1})\)</span> 两端，由于 <span class="math inline">\((w_1-1)\omega_s=0\)</span>，所以 <span class="math display">\[(w_1-1)^2p =2a(p,\omega_s)(w_1-1)\alpha_t.\label{eq:wp3}\tag{3}\]</span></p><p>将 <span class="math inline">\((\ref{eq:wp2})\)</span> 代入 <span class="math inline">\((\ref{eq:wp3})\)</span> 的右边，我们得到 <span class="math display">\[(w_1-1)^2p=-4a^2(p,\omega_s)\omega_s.\]</span> 即<span class="math inline">\(b=-4a^2(\omega_s,p)\)</span>。</p><p>我们来判断 <span class="math inline">\(b\)</span> 的符号。这里要用到<span class="math inline">\(p\in\overline{\mathcal{D}}=\mathrm{cone}(\Delta^\ast)\)</span>的条件。如果 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(\omega_s\)</span> 的正倍数，显然 <span class="math inline">\(\omega_s\in\overline{ \mathrm{cone}(\bigcup_{w\inW_I}wp) }\)</span>，命题自然成立。所以我们可以假设 <span class="math inline">\(p\)</span> 与 <span class="math inline">\(\omega_s\)</span> 不共线。</p><p>设 <span class="math inline">\(p=\sum_{t\in S}c_t\omega_t\,(c_t\geq0)\)</span>，则至少有一个 <span class="math inline">\(t\ne s\)</span> 满足 <span class="math inline">\(c_t&gt;0\)</span>。于是 <span class="math display">\[(\omega_s,p)=\sum_{t\ne s}\underbrace{c_t}_{\geq0\text{ 且至少有一个 } &gt;0}\ \cdot\\underbrace{(\omega_s,\omega_t)}_{\text{已知 }&lt;0}&lt;0.\]</span> 从而<span class="math inline">\(b&gt;0\)</span>。</p><p>最后利用 <span class="math inline">\((w_1-1)^3=0\)</span> 和 <span class="math inline">\((w_1-1)^2p=b\omega_s\)</span> 我们得到对任何 <span class="math inline">\(N\geq 1\)</span> 有 <span class="math display">\[w_1^N(p)=(1 + w_1-1)^N(p)= p +\binom{N}{1}(w_1-1)(p) + \binom{N}{2}b\omega_s,\]</span> 可见 <span class="math inline">\(\lim\limits_{N\to\infty}\dfrac{w_1^Np}{\binom{N}{2}b}= \omega_s\)</span>，即得所证。<span class="math inline">\(\blacksquare\)</span></p><h1 id="处理-level-2-的基本技巧">处理 level 2 的基本技巧</h1><p>本节我们在上一小节的结论中再进一步，证明 level 2的群也是双曲的。由于接下来的证明篇幅更长，包含更多的细节，读者难免在阅读时感到吃力。我这里借鉴编程中的模块化思想，先解释接下来的证明中会用到的主要思想。</p><p>处理 level 2 的情形的基本思路是转化为 level 1 的情形。具体讲，设<span class="math inline">\(\Gamma\)</span> 是 level 为 2 的 Coxeter图，取一个实的基本权 <span class="math inline">\((\omega_s,\omega_s)&gt;0\)</span>，则子图 <span class="math inline">\(\Gamma\setminus\{s\}\)</span> 的 level 就是 1。记<span class="math inline">\(I = S\setminus\{s\}\)</span>，<span class="math inline">\(W_I\)</span> 是标准椭圆子群， <span class="math display">\[V_I=\omega_s^\bot=\mathrm{span}\{\alpha_t\midt\ne s\}.\]</span> <span class="math inline">\(W_I\)</span> 在 <span class="math inline">\(V_I\)</span> 上作用的基本区域的闭包就是 <span class="math display">\[\overline{\mathcal{D}}_I= \{v\in V_I\mid (v,\alpha_t)&gt;0,\, \forall t\in I\}=\mathrm{cone}(\{\omega_t\mid t\inI\}).\]</span></p><p>根据 <a href="#level-1-tits" title="推论 3.4">推论 3.4</a>，<span class="math inline">\(\overline{\mathcal{D}}_I\)</span> 包含在 <span class="math inline">\(\mathcal{Q}_I=\{v\in V_I\mid (v,v)\leq0\}\)</span>的上下两个分支之一中，所以任何 <span class="math inline">\(x,y\in\overline{\mathcal{D}}_I\)</span>之间的内积小于等于 0： <span class="math display">\[(x,y)\leq0, \quad\forall x,y\in \overline{\mathcal{D}}_I.\]</span> 特别地，对任何 <span class="math inline">\(x\in\overline{\mathcal{D}}_I\)</span> 有 <span class="math display">\[(x,x)\leq0 \text{ and } (x,\omega_t)\leq0\text{for all }t\in I.\]</span> 于是对 <span class="math inline">\(v\inV\)</span>，如果它在 <span class="math inline">\(V_I\)</span> 上的投影<span class="math inline">\(v_I\)</span> 满足 <span class="math inline">\(v_I\in\overline{\mathcal{D}}_I\)</span>，那么我们就可以利用上面的关系得出关于<span class="math inline">\(v\)</span> 的信息来。</p><div id="observeA" class="statement sta____a definition unnumbered"><p><span class="statement-heading"><span class="statement-label">观察A</span>：</span><span class="statement-spah"> </span>取 <span class="math inline">\(v=\alpha_s\)</span>，<span class="math inline">\(\alpha_s'=\alpha_s-\omega_s/(\omega_s,\omega_s)\)</span>是 <span class="math inline">\(\alpha_s\)</span> 在 <span class="math inline">\(\omega_s^\bot=V_I\)</span> 上的投影，则对任何<span class="math inline">\(t\in I\)</span> 有 <span class="math display">\[(\alpha_s',\alpha_t)=(\alpha_s,\alpha_t)\leq0.\]</span> 这说明 <span class="math inline">\(-\alpha_s'\in\overline{\mathcal{D}}_I\)</span>，于是我们有<span class="math display">\[\begin{aligned}&amp;(\alpha_s',\alpha_s')=1-\frac{1}{(\omega_s,\omega_s)}\leq0,\\&amp;(-\alpha_s',\omega_t)=\frac{(\omega_s,\omega_t)}{(\omega_s,\omega_s)}\leq0\text{ for all }t\in I.\end{aligned}\]</span> 整理即得 <span class="math inline">\(0&lt;(\omega_s,\omega_s)\leq1\)</span>，以及 <span class="math inline">\((\omega_s,\omega_t)\leq0\)</span> 对任何 <span class="math inline">\(t\in I\)</span> 成立。</p></div><p>真不错！我们轻松得到了一个关于 level 2 情形实的基本权 <span class="math inline">\(\omega_s\)</span> 的重要结论。</p><div id="observeB" class="statement sta____b definition unnumbered"><p><span class="statement-heading"><span class="statement-label">观察B</span>：</span><span class="statement-spah"> </span>这次我们取 <span class="math inline">\(v\in\mathcal{C}\)</span> 是 Tits 锥中的一点，则<span class="math inline">\(v\)</span> 形如 <span class="math inline">\(v=wx\,(w\inW,x\in\overline{\mathcal{D}})\)</span>。并且 <span class="math display">\[v_I = v -\frac{(v,\omega_s)}{(\omega_s,\omega_s)}\omega_s.\]</span> 由于 <span class="math inline">\((v-v_I)\bot V_I\)</span>，所以对任何 <span class="math inline">\(\alpha_k\,(k\ne i)\)</span> 有 <span class="math display">\[(v_I,\alpha_k)=(v,\alpha_k)=(wx,\alpha_k)=(x,w^{-1}\alpha_k).\]</span> 为了保证让 <span class="math inline">\(v_I\)</span> 落在 <span class="math inline">\(\overline{\mathcal{D}}_I\)</span>中，我们需要让这些 <span class="math inline">\((x,w^{-1}\alpha_k)\geq0\)</span>。但是 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，所以只要让每个<span class="math inline">\(w^{-1}\alpha_k\,(k\in I)\)</span>都是负根，也就是让 <span class="math inline">\(l(s_kw)&lt;l(w)\)</span>即可。</p><p>总结起来就是，如果对任何 <span class="math inline">\(k\in I\)</span>有 <span class="math inline">\(l(s_kw)&lt;l(w)\)</span>，那么就有 <span class="math inline">\(v_I\in\overline{\mathcal{D}}_I\)</span> 成立。</p></div><p>这个例子看起来附加了比较强的条件，但是它确实会在后面用到。</p><h1 id="level-2-也是双曲的">Level 2 也是双曲的</h1><div id="level-2" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.1</span>.</span><span class="statement-spah"> </span>level 等于 2的群都是双曲的，所有的基本权 <span class="math inline">\(\{\omega_s\mids\in S\}\)</span> 两两分离。<span class="math inline">\(\omega_s\)</span> 是实的当且仅当 <span class="math inline">\(T\setminus\{s\}\)</span> 的 level 等于1，且对这样的 <span class="math inline">\(\omega_s\)</span> 有 <span class="math inline">\(0&lt;(\omega_s,\omega_s)\leq 1\)</span>。</p></div><p><strong>证明</strong>：我们先来证明 <span class="math inline">\(\Gamma\)</span> 是双曲的。</p><p>如果 <span class="math inline">\(\Gamma\)</span> 是不连通的，则 <span class="math inline">\(\Gamma\)</span> 必须是一个 level 为 1的子图和一个孤立顶点的并，由于 <a href="#level-1" title="定理 3.3">定理3.3</a> 已经证明了 level 1的群是双曲的，再加上一个孤立顶点仍然是双曲的，所以 <span class="math inline">\(\Gamma\)</span> 是双曲的。于是我们不妨假设 <span class="math inline">\(\Gamma\)</span> 是连通的。</p><p>如果 <span class="math inline">\(|\Gamma|=3\)</span>，<span class="math inline">\(\Gamma\)</span> 的 level 是 2 说明其必然有一条边的Vinberg 标号小于 -1。不妨设 <span class="math inline">\((\cdot,\cdot)\)</span> 的 Gram 矩阵形如 <span class="math display">\[\begin{pmatrix}1&amp;a&amp;b\\a&amp;1&amp;c\\b&amp;c&amp;1\end{pmatrix}.\]</span>其中 <span class="math inline">\(a,\,b,\,c\leq0\)</span> 且 <span class="math inline">\(a &lt; -1\)</span>。这个矩阵的行列式是 <span class="math display">\[1-a^2 + 2bc(a+1)-(b+c)^2&lt;0.\]</span>由于矩阵的迹等于 3，所以其符号必然是 <span class="math inline">\((2,1)\)</span>，从而是双曲的。</p><p>再处理 <span class="math inline">\(|\Gamma|\geq4\)</span>的情形。仍然根据 <a href="#lemma-uv" title="引理 3.2">引理 3.2</a>，如果<span class="math inline">\(\Gamma\)</span>不是双曲的，则可以取两个非零且正交的向量 <span class="math inline">\(u,v\)</span> 满足 <span class="math inline">\((u,u)&lt;0,\,(v, v)=0\)</span>。</p><p>我们也有如下两个断言：</p><div id="assetB" class="statement sta___-1 plain unnumbered"><p><span class="statement-heading"><span class="statement-label">断言</span>.</span><span class="statement-spah"></span><br></p><ol type="1"><li>任何满足 <span class="math inline">\((u,u)&lt;0\)</span> 的向量<span class="math inline">\(u=\sum_{s\in S}u_s\alpha_s\)</span>除去至多一个系数 <span class="math inline">\(u_j\)</span> 之外，其它的<span class="math inline">\(u_s\)</span> 都非零且同号。</li><li>任何满足 <span class="math inline">\((v,v)=0\)</span> 的向量 <span class="math inline">\(v=\sum_{s\in S}v_s\alpha_s\)</span> 除了满足断言 1的情形之外，还有一种情形是 <span class="math inline">\(\{v_s\}\)</span>中有两个是 0，其余的非零且同号。</li></ol></div><p>我仍然把断言的证明放在 <a href="#appendixB">附录</a>中，先承认它们是正确的并完成证明。</p><p>由于 <span class="math inline">\(u\)</span> 的系数 <span class="math inline">\(\{u_s\}\)</span> 中至多只有一个是 0，<span class="math inline">\(v\)</span> 的系数 <span class="math inline">\(\{v_s\}\)</span> 中至多只有两个是 0，而 <span class="math inline">\(|\Gamma|\geq4\)</span>，所以存在下标 <span class="math inline">\(i\)</span> 使得 <span class="math inline">\(u_i,\,v_i\)</span> 均不为 0。于是 <span class="math inline">\(u'=v_iu-u_iv\)</span> 仍然满足 <span class="math inline">\(u'\)</span> 与 <span class="math inline">\(v\)</span> 正交和 <span class="math inline">\((u',u')&lt;0\)</span>，但是它的下标 <span class="math inline">\(i\)</span> 的系数 <span class="math inline">\(u'_i=0\)</span>，所以我们不妨一开始就取 <span class="math inline">\(u\)</span> 为 <span class="math inline">\(u'\)</span>，于是 <span class="math inline">\(u\)</span> 有一个系数 <span class="math inline">\(u_i=0\)</span>，其它系数都非 0且同号，不妨假设这些非零系数都大于 0。</p><p>现在我们已经有了 <span class="math inline">\(v_i\ne0\)</span>，由于<span class="math inline">\(\{v_s\}\)</span> 中至多只有两个为 0，而<span class="math inline">\(|\Gamma|\geq4\)</span>，所以 <span class="math inline">\(\{v_j,\,j\ne i\}\)</span> 中至少还有一个非零。</p><ul><li><p>如果 <span class="math inline">\(\{v_j,\,j\ne i\}\)</span>中仅有一个非零，则这时必有 <span class="math inline">\(|\Gamma|=4\)</span> 且 <span class="math inline">\(v\)</span> 形如 <span class="math inline">\(v=v_i\alpha_i + v_j\alpha_j\)</span>。根据 <a href="#level-l" title="定理 1.2">定理 1.2</a> <span class="math inline">\({\rm span}\{\alpha_i,\alpha_j\}\)</span>是有限/或者仿射的，但是由于此平面包含 <span class="math inline">\((v,v)=0\)</span>，所以是仿射的，从而 <span class="math inline">\((\alpha_i,\alpha_j)=-1\)</span>。我们可以不妨把<span class="math inline">\(v\)</span> 取为 <span class="math inline">\(v=\alpha_i+\alpha_j\)</span>。</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(i\)</span></th><th style="text-align: center;"><span class="math inline">\(j\)</span></th><th style="text-align: center;"><span class="math inline">\(k\)</span></th><th style="text-align: center;"><span class="math inline">\(m\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(u\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(\ne0\)</span></td><td style="text-align: center;"><span class="math inline">\(\ne0\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><p><span class="math inline">\(u_i=0\)</span> 说明 <span class="math inline">\(u\)</span> 形如 <span class="math inline">\(u=u_j\alpha_j+u_k\alpha_k+u_m\alpha_m\)</span>。由 <span class="math inline">\((u,v)=0\)</span> 有 <span class="math display">\[(u, v)=(u_j\alpha_j+u_k\alpha_k+u_m\alpha_m,v)=(u_k\alpha_k+u_m\alpha_m, \alpha_i+\alpha_j)=0,\]</span> 由于 <span class="math inline">\(\{\alpha_k,\alpha_m\}\)</span> 和 <span class="math inline">\(\{\alpha_i,\alpha_j\}\)</span>之间的内积都小于等于 0，而 <span class="math inline">\(u_k,u_m\)</span>大于 0，这说明 <span class="math display">\[(\alpha_k,\alpha_i) =(\alpha_k,\alpha_j) =(\alpha_m, \alpha_i)=(\alpha_m,\alpha_j)=0.\]</span> 即顶点 <span class="math inline">\(\{i,j\}\)</span> 与 <span class="math inline">\(\{k,m\}=\Gamma\setminus\{i,j\}\)</span>是不连通的，与 <span class="math inline">\(\Gamma\)</span>连通矛盾。</p></li><li><p>如果 <span class="math inline">\(\{v_j,\,j\ne i\}\)</span>至少有两个非零，则可以取下标 <span class="math inline">\(j,k\)</span>使得 <span class="math inline">\(v_j/u_j\ne0,\,v_k/u_k\ne0\)</span>。</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(i\)</span></th><th style="text-align: center;"><span class="math inline">\(j\)</span></th><th style="text-align: center;"><span class="math inline">\(k\)</span></th><th style="text-align: center;"><span class="math inline">\(\cdots\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(u\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(&gt;0\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(v\)</span></td><td style="text-align: center;"><span class="math inline">\(&lt;0\)</span></td><td style="text-align: center;"><span class="math inline">\(\ne0\)</span></td><td style="text-align: center;"><span class="math inline">\(\ne0\)</span></td><td style="text-align: center;"><span class="math inline">\(\cdots\)</span></td></tr></tbody></table><p>由于 <span class="math inline">\(v_i\ne0\)</span>，通过选择 <span class="math inline">\(v\)</span> 或者 <span class="math inline">\(-v\)</span> 可以不妨设 <span class="math inline">\(v_i&lt;0\)</span>，并不妨设 <span class="math inline">\(v_j/u_j\leq v_k/u_k\)</span>。记 <span class="math inline">\(a=v_j/u_j\)</span>，则 <span class="math inline">\(u'=au-v\)</span> 满足 <span class="math inline">\((u',u')&lt;0\)</span>，但是 <span class="math inline">\(u'_i=-v_i&gt;0\)</span>，<span class="math inline">\(u'_j=0\)</span>，<span class="math inline">\(u'_k\leq 0\)</span>，这与上面断言中 <span class="math inline">\(u'\)</span>的系数除去至多一个例外，剩下的均非零且同号矛盾。</p></li></ul><p>至此我们证明了当 <span class="math inline">\(\Gamma\)</span> 的 level等于 2 时是双曲的。</p><p>我们接下来证明所有的基本权 <span class="math inline">\(\{\omega_s\}\)</span>是两两分离的。我们先来说明不论 <span class="math inline">\((\omega_s,\omega_s)\)</span>的符号如何，它与其它的基本权 <span class="math inline">\(\omega_t\,(t\nes)\)</span> 的内积满足 <span class="math inline">\((\omega_s,\omega_t)\leq0\)</span>。</p><p>分情况讨论：</p><ul><li><p>如果 <span class="math inline">\((\omega_s,\omega_s)&gt;0\)</span>，由 <a href="#observeA" title="观察 A">观察 A</a> 的讨论即得。</p></li><li><p>如果 <span class="math inline">\((\omega_s,\omega_s)\leq0\)</span>，则根据 <span class="math inline">\((\ref{eq:idI})\)</span>，<span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span>中必须至少有一个严格小于 0，从而根据 <a href="#assetB" title="断言">断言</a>，在 <span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span>中至多有一个为正。但我们将证明这不可能。否则不妨设 <span class="math inline">\(k\ne s\)</span> 使得 <span class="math inline">\((\omega_s,\omega_k)&gt;0\)</span>。在 <span class="math inline">\((\ref{eq:idII})\)</span> 两边用 <span class="math inline">\(\alpha_k\)</span> 内积得到 <span class="math display">\[0=(\omega_s,\omega_s)(\alpha_s,\alpha_k)+\sum_{t\ne s,k} (\omega_s,\omega_t)(\alpha_t,\alpha_k) +(\omega_s,\omega_k).\]</span> 上面的和项前两个都非负，最后一个大于0，矛盾。所以所有的 <span class="math inline">\(\{(\omega_s,\omega_t)\}_{t\ne s}\)</span>都非正。</p></li></ul><p>又因为对任何 <span class="math inline">\(s,t\)</span>，<span class="math inline">\(\Gamma\setminus\{s,t\}\)</span>是有限或者仿射的，所以其正交补，即 <span class="math inline">\(\{\omega_s,\omega_t\}\)</span>张成的二维子空间不是正定的，从而 <span class="math inline">\(\{\omega_s\}\)</span> 之间是两两分离的。</p><h1 id="level-1-2-等价于双曲和分离">level = 1, 2 等价于双曲和分离</h1><div id="level-12" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理6.1</span>.</span><span class="statement-spah"></span>下面两点是等价的：</p><ol type="1"><li><span class="math inline">\(\Gamma\)</span> 的 level 等于 1 或2；</li><li><span class="math inline">\(\Gamma\)</span>是双曲的，且任何两个权都互相分离。</li></ol></div><p><strong>证明</strong>：</p><p><span class="math inline">\(1\Rightarrow 2\)</span>：只要再证明对任何<span class="math inline">\(w\in W\)</span>，以及两个基本权 <span class="math inline">\(\omega_i,\,\omega_j\)</span>，如果有 <span class="math inline">\(\omega_i\ne w(\omega_j)\)</span>，则 <span class="math inline">\((\omega_i,w(\omega_j))\leq0\)</span>，并且二维子空间<span class="math inline">\(\{\omega_i,w(\omega_j)\}\)</span>不是正定的。</p><p>对 <span class="math inline">\(l(w)\)</span> 归纳：<span class="math inline">\(l(w)=0\)</span> 的情形在 <a href="#level-1" title="定理 3.3">定理 3.3</a> 和 <a href="#level-2" title="定理 5.1">定理 5.1</a> 中已经证明。下面假设 <span class="math inline">\(l(w)&gt;0\)</span>，且结论对所有长度 <span class="math inline">\(&lt;l(w)\)</span> 的元素成立。</p><ol type="1"><li><p>如果存在 <span class="math inline">\(k\ne i\)</span> 使得 <span class="math inline">\(l(s_kw)&lt;l(w)\)</span>，则由于反射 <span class="math inline">\(s_k\)</span> 是正交变换，并且保持 <span class="math inline">\(\omega_i\)</span> 不动，有 <span class="math display">\[(\omega_i,s_kw(\omega_j))\xrightarrow{\ s_k\ }(\omega_i,w(\omega_j)).\]</span>由归纳假设左边是分离的，从而右边也是分离的。</p></li><li><p>如果对任何 <span class="math inline">\(k\ne i\)</span> 都有 <span class="math inline">\(l(s_kw)&gt;l(w)\)</span>，则 <span class="math inline">\(w\)</span> 的任一既约表示必然以 <span class="math inline">\(s_i\)</span> 开头，即 <span class="math inline">\(w\)</span> 形如 <span class="math inline">\(w=s_iw'\)</span> 且 <span class="math inline">\(l(w)&gt;l(w')\)</span>。从而 <span class="math display">\[(\omega_i,w(\omega_j))\xrightarrow{\ s_i\}(\omega_i-2\alpha_i, w'(\omega_j)) =(\omega_i,w'(\omega_j))-2(\alpha_i,w'(\omega_j)).\]</span></p><ul><li>如果 <span class="math inline">\(\omega_i\new'(\omega_j)\)</span>，则由归纳假设上面第一项 <span class="math inline">\((\omega_i,w'(\omega_j))\leq0\)</span>。第二项由于 <span class="math display">\[l(s_iw')&gt;l(w')\Rightarroww'^{-1}\alpha_i\in\Phi^+\Rightarrow (w'^{-1}\alpha_i,\omega_j)\geq0 \Rightarrow (\alpha_i, w'(\omega_j))\geq0.\]</span>所以 <span class="math inline">\((\omega_i,w(\omega_j))\leq0\)</span>成立。</li><li>如果 <span class="math inline">\(\omega_i=w'(\omega_j)\)</span>，则 <span class="math inline">\(w(\omega_j)=s_iw'(\omega_j)=s_i(\omega_i)\)</span>，于是<span class="math display">\[(\omega_i, w(\omega_j))=(\omega_i,s_i(\omega_i))\xrightarrow{\ s_i\}(\omega_i-2\alpha_i,\omega_i)=(\omega_i, \omega_i)-2 &lt;0.\]</span>其中最后一个不等号是利用了 <a href="#level-1" title="定理 3.3">定理3.3</a> 和 <a href="#level-2" title="定理 5.1">定理 5.1</a> 的结论：若<span class="math inline">\(\Gamma\)</span> 的 level 是 1 则 <span class="math inline">\((\omega_i, \omega_i)\leq0\)</span>，若 <span class="math inline">\(\Gamma\)</span> 的 level 是 2 则 <span class="math inline">\((\omega_i,\omega_i)\leq 1\)</span>。</li></ul><p>我们已经证明了 <span class="math inline">\((\omega_i,w(\omega_j))\)</span> 总是 <span class="math inline">\(\leq0\)</span> 的。还需要说明 <span class="math inline">\(\mathrm{span}\{\omega_i,w(\omega_j)\}\)</span>不是正定的。记 <span class="math inline">\(U=\mathrm{span}\{\omega_i,w(\omega_j)\}\)</span>。用反证法，如果<span class="math inline">\(U\)</span> 是正定的，则 <span class="math inline">\((\omega_i,\omega_i)&gt;0\)</span> 是实的。记 <span class="math display">\[v_I = w(\omega_j) -\frac{(\omega_i,w(\omega_j))}{(\omega_i,\omega_i)} \omega_i\]</span> 是<span class="math inline">\(w(\omega_j)\)</span> 在 <span class="math inline">\(\omega_i^\bot\)</span> 上的投影，则 <span class="math inline">\(v_I\in U\)</span> 是 space-like 的向量。但是根据<a href="#observeB" title="观察 B">观察 B</a> 中的讨论，<span class="math inline">\(v_I\in\overline{\mathcal{D}}_I\)</span>，从而<span class="math inline">\((v_I, v_I)\leq0\)</span>，矛盾。</p></li></ol><p><span class="math inline">\(2\Rightarrow 1\)</span>：由于内积 <span class="math inline">\((\cdot,\cdot)\)</span> 是双曲的，而子空间 <span class="math inline">\(\mathrm{span}\{\omega_i,\omega_j\}\)</span>不是正定的，所以其正交补是正定或者半正定的。于是 <span class="math inline">\(\Gamma\setminus\{i,j\}\)</span>是有限或者仿射的，从而 <span class="math inline">\(\Gamma\)</span> 的level 等于 1 或 2。</p><h1 id="附录">附录</h1><h2 id="appendixA">level 1 情形断言的证明</h2><p>首先是断言 1 的证明。记</p><p><span class="math display">\[I_+=\{s\in S\mid u_s&gt;0\},\quadI_-=\{s\in S\mid u_s&lt;0\},\quad I_0=\{s\in S\mid u_s=0\}.\]</span>并记 <span class="math inline">\(u_+=\sum_{s\inI_+}u_s\alpha_s\)</span>，<span class="math inline">\(u_-=\sum_{t\inI_-}u_t\alpha_t\)</span>，则 <span class="math inline">\(u=u_++u_-\)</span> 且 <span class="math display">\[(u,u)=(u_+,u_+) + (u_-,u_-) +2(u_+,u_-)&lt;0.\]</span> 但是注意到 <span class="math display">\[(u_+,u_-)=\sum_{s\in I_+}\sum_{t\inI_-}\underbrace{u_s}_{&gt;0}\underbrace{u_t}_{&lt;0}\underbrace{(\alpha_s,\alpha_t)}_{\leq0}\geq0.\]</span> 所以 <span class="math inline">\((u_+, u_+) &lt; 0\)</span>和 <span class="math inline">\((u_-, u_-)&lt;0\)</span>至少有一个成立，不妨设 <span class="math inline">\((u_+,u_+)&lt;0\)</span>。如果 <span class="math inline">\(I_-\cupI_0\ne\emptyset\)</span>，那么 <span class="math inline">\(I_+\)</span>作为从 <span class="math inline">\(\Gamma\)</span> 中删去 <span class="math inline">\(I_-\cup I_0\)</span> 后得到的真子图包含 time-like的向量 <span class="math inline">\(u_+\)</span>，这与 <span class="math inline">\(\Gamma\)</span> 的 level 等于 1 矛盾。所以 <span class="math inline">\(I=I_+\)</span>，即所有系数 <span class="math inline">\(u_s\)</span> 都大于 0。相应地如果是 <span class="math inline">\((u_-,u_-)&lt;0\)</span> 的话则所有 <span class="math inline">\(u_s\)</span> 都小于 0。</p><p>对断言 2 我们仍然采用类似的记号，记 <span class="math inline">\(v_+=\sum_{s\in I_+}v_s\alpha_s\)</span>，<span class="math inline">\(v_-=\sum_{t\in I_-}v_t\alpha_t\)</span>，则同样有<span class="math inline">\((v_+,v_-)\geq0\)</span>。</p><p>我们想证明 <span class="math inline">\(|I_0|\leq1\)</span>，并且<span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 中必有一个是空集。</p><p>如果 <span class="math inline">\(|I_0|\geq2\)</span>，那么 <span class="math inline">\((v, v)=0\)</span> 说明删除 <span class="math inline">\(I_0\)</span> 以后得到的子图不是有限的，这与 <span class="math inline">\(\Gamma\)</span> 的 level 是 1 和 <a href="#level-l" title="定理 1.2">定理 1.2</a> 矛盾。所以 <span class="math inline">\(|I_0|\leq 1\)</span>。</p><p>如果 <span class="math inline">\(I_+,\,I_-\)</span>都不是空集的话，则 <span class="math inline">\(v_+,v_-\)</span>都非零，并且必然有 <span class="math inline">\((v_+, v_+)\geq0\)</span>和 <span class="math inline">\((v_-, v_-)\geq0\)</span> 成立，否则删掉<span class="math inline">\(I_+\)</span> 或者 <span class="math inline">\(I_-\)</span> 以后剩下的子图不是有限或者仿射的，与<span class="math inline">\(\Gamma\)</span> 的 level 是 1 矛盾。然而<span class="math display">\[0=(v, v) = (v_+,v_+) + (v_-,v_-) +2(v_+,v_-).\]</span> 三个非负数的和等于 0，只能是 <span class="math inline">\((v_+,v_+) = (v_-,v_-) =(v_+,v_-)=0\)</span>。现在分情况讨论：</p><ol type="1"><li>如果 <span class="math inline">\(|I_0|=1\)</span>，那么删掉 <span class="math inline">\(I_-\cup I_0\)</span> 会至少删掉两个顶点，但 <span class="math inline">\((v_+,v_+)=0\)</span> 说明 <span class="math inline">\(I_+\)</span> 不是有限的，与 <span class="math inline">\(\Gamma\)</span> 的 level 是 1 和 <a href="#level-l" title="定理 1.2">定理 1.2</a> 矛盾。</li><li>如果 <span class="math inline">\(I_0=\emptyset\)</span>，则 <span class="math inline">\(S=I_+\cup I_-\)</span>。然而 <span class="math inline">\((v_+,v_-)=\sum_{s\in I_+,\,t\inI_-}v_sv_t(\alpha_s,\alpha_t)=0\)</span> 说明对任何 <span class="math inline">\(s\in I_+,\,t\in I_-\)</span> 有 <span class="math inline">\((\alpha_s,\alpha_t)=0\)</span>，从而 <span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 互不连通，这与 <span class="math inline">\(\Gamma\)</span> 连通矛盾。</li></ol><p>总之 <span class="math inline">\(I_+\)</span> 和 <span class="math inline">\(I_-\)</span> 必有一个是空集，断言 2 得证。</p><h2 id="appendixB">level 2 情形断言的证明</h2><p>首先是断言 1 的证明。记 <span class="math inline">\(I_+,I_-,I_0\)</span> 如前，并记 <span class="math inline">\(u_+=\sum_{s\in I_+}u_s\alpha_s\)</span>，<span class="math inline">\(u_-=\sum_{t\in I_-}u_t\alpha_t\)</span>。则 <span class="math inline">\((u,u)&lt;0\)</span> 和 <span class="math inline">\((u_+,u_-)\geq0\)</span> 说明 <span class="math inline">\((u_+, u_+) &lt; 0\)</span> 和 <span class="math inline">\((u_-, u_-)&lt;0\)</span> 中至少有一个成立。</p><p>如果 <span class="math inline">\(|I_0|\geq2\)</span>，则 <span class="math inline">\((u,u)&lt;0\)</span> 与 <span class="math inline">\(\Gamma\)</span> 的 level 是 2 矛盾。所以 <span class="math inline">\(|I_0|\leq 1\)</span>。</p><ol type="1"><li>如果 <span class="math inline">\(I_+,I_-\)</span> 都不是空集，则<span class="math inline">\(u_+,\,u_-\)</span> 均不为 0。由于 <span class="math inline">\((u_+, u_+) &lt; 0\)</span> 和 <span class="math inline">\((u_-, u_-)&lt;0\)</span> 中至少有一个成立，不妨设<span class="math inline">\((u_+,u_+)&lt;0\)</span>，结合 <span class="math inline">\(\Gamma\)</span> 的 level 是 2，这要求 <span class="math inline">\(|I_-\cup I_0|\leq 1\)</span>，从而只能是 <span class="math inline">\(|I_-|=1,\, I_0=\emptyset\)</span>。即系数全部非 0且恰好有一个异号。</li><li>如果 <span class="math inline">\(I_+,I_-\)</span>中有一个是空集，不妨设 <span class="math inline">\(I_-=\emptyset\)</span>，我们仍然有 <span class="math inline">\(|I_-\cupI_0|=|I_0|\leq1\)</span>。即系数至多有一个为 0 且其它的均同号。</li></ol><p>总之我们证明了除去至多一个系数之外，其它的系数均非 0 且同号。断言 1得证。</p><p>对断言 2，类似地，我们记 <span class="math inline">\(v_+=\sum_{s\inI_+}v_s\alpha_s\)</span>，<span class="math inline">\(v_-=\sum_{t\inI_-}v_t\alpha_t\)</span>。</p><p>首先 <span class="math inline">\(|I_0|\leq2\)</span> 是显然的，否则<span class="math inline">\((v,v)=0\)</span> 与 <span class="math inline">\(\Gamma\)</span> 的 level 是 2 和 <a href="#level-l" title="定理 1.2">定理 1.2</a> 矛盾。</p><ol type="1"><li>如果 <span class="math inline">\(I_0\ne\emptyset\)</span>，则 <span class="math inline">\(I_+,I_-\)</span> 中必有一个为空。否则 <span class="math inline">\(|I_+\cup I_0|\geq2,\,|I_-\cupI_0|\geq2\)</span>。level 2 要求 <span class="math inline">\((v_+,v_+)\geq0,\,(v_-,v_-)\geq0\)</span>，从而<span class="math inline">\((v,v)=0\)</span> 和 <span class="math inline">\((v_+,v_-)\geq0\)</span> 导致 <span class="math inline">\((v_+,v_+)=(v_-, v_-)=(v_+,v_-)=0\)</span>。由于<span class="math inline">\(\Gamma\)</span> 至少包含 4 个顶点，所以<span class="math inline">\(I_+,\,I_-\)</span>中必有一个包含两个或者更多的顶点。不妨设 <span class="math inline">\(|I_+|\geq2\)</span>，则删除 <span class="math inline">\(I_+\cup I_0\)</span> 会至少删掉 3个顶点，但得到的子图不是正定的，与 <span class="math inline">\(\Gamma\)</span> 的 level 等于 2 矛盾。所以系数<span class="math inline">\(\{v_s\}\)</span> 中如果有 0的话，则至多只有两个 0，且剩下的都同号。</li><li>如果 <span class="math inline">\(I_0=\emptyset\)</span>是空集，则要么 <span class="math inline">\(I_+,I_-\)</span>中有一个也是空集，从而所有的系数都非 0 且同号；要么 <span class="math inline">\(v_+,\,v_-\)</span> 均不为 0。这时 <span class="math inline">\(\Gamma\)</span> 连通说明 <span class="math inline">\((v_+,v_-)&gt;0\)</span>，结合 <span class="math inline">\((v,v)=0\)</span> 可以得出 <span class="math inline">\((v_+,v_+) &lt; 0\)</span> 和 <span class="math inline">\((v_-, v_-)&lt;0\)</span> 中至少有一个成立。不妨设<span class="math inline">\((v_+,v_+)&lt;0\)</span>，则 level 2 要求<span class="math inline">\(|I_-|\leq1\)</span>，即 <span class="math inline">\(\{v_s\}\)</span>均非零且恰有一个元素与其它元素异号。</li></ol><p>至此断言 2 得证，从而定理得证。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div><div id="ref-Maxwell82" class="csl-entry" role="listitem">Maxwell, George. 1982. <span>“Sphere Packings and Hyperbolic ReflectionGroups.”</span> <em>Journal of Algebra</em> 79 (1): 78–97. <a href="https://doi.org/10.1016/0021-8693(82)90318-0">https://doi.org/10.1016/0021-8693(82)90318-0</a>.</div><div id="ref-Maxwell89" class="csl-entry" role="listitem">———. 1989. <span>“Wythoff’s Construction for Coxeter Groups.”</span><em>Journal of Algebra</em> 123 (2): 351–77. <a href="https://doi.org/10.1016/0021-8693(89)90051-3">https://doi.org/10.1016/0021-8693(89)90051-3</a>.</div></div><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>这里解释下为什么在 <span class="math inline">\(K\)</span> 中一定可以找到一个非平凡的元素。由于<span class="math inline">\(\Gamma\setminus\{s\}\)</span>是不可约仿射的，<span class="math inline">\(\mathrm{rad}(V_I)=\mathbb{R}\omega_s\)</span>，所以<span class="math inline">\((\cdot,\cdot)\)</span> 在 <span class="math inline">\(V_I/\mathbb{R}\omega_s\)</span>上诱导了一个正定内积。商群 <span class="math inline">\(W_I/K\)</span> 是<span class="math inline">\(V_I/\mathbb{R}\omega_s\)</span>中的反射群，并且保持这个正定内积不变，所以根据 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec. 6.4</a>)</span> 的结论，<span class="math inline">\(W_I/K\)</span> 是有限群。于是 <span class="math inline">\(W_I\)</span> 作为仿射 Coxeter 群是无限群，对 <span class="math inline">\(K\)</span> 取商群是有限群，所以 <span class="math inline">\(K\)</span> 必然是无限群。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
    
    
    <summary type="html">
&lt;p&gt;本文主要改写自 &lt;span class=&quot;citation&quot; data-cites=&quot;Maxwell82&quot;&gt;(&lt;a href=&quot;#ref-Maxwell82&quot; role=&quot;doc-biblioref&quot;&gt;Maxwell 1982&lt;/a&gt;)&lt;/span&gt;
和&lt;span class=&quot;citation&quot; data-cites=&quot;Maxwell89&quot;&gt;(&lt;a href=&quot;#ref-Maxwell89&quot; role=&quot;doc-biblioref&quot;&gt;Maxwell
1989&lt;/a&gt;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;我们来介绍 Coxeter 群的 level 的概念，并证明 level 等于 1 或 2
的群都是双曲的。&lt;/p&gt;
&lt;h1 id=&quot;level-的定义&quot;&gt;level 的定义&lt;/h1&gt;
&lt;div class=&quot;statement definition plain&quot;&gt;
&lt;p&gt;&lt;span class=&quot;statement-heading&quot;&gt;&lt;span class=&quot;statement-label&quot;&gt;定义
1.1&lt;/span&gt; &lt;span class=&quot;statement-info&quot;&gt;(&lt;span class=&quot;citation&quot; data-cites=&quot;Maxwell82&quot;&gt;Maxwell (&lt;a href=&quot;#ref-Maxwell82&quot; role=&quot;doc-biblioref&quot;&gt;1982&lt;/a&gt;)&lt;/span&gt;)&lt;/span&gt;.&lt;/span&gt;&lt;span class=&quot;statement-spah&quot;&gt; &lt;/span&gt;&lt;span class=&quot;math inline&quot;&gt;&#92;((W,S)&#92;)&lt;/span&gt; 的 level 定义为最小的非负整数 &lt;span class=&quot;math inline&quot;&gt;&#92;(l&#92;)&lt;/span&gt;，使得在 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;Gamma&#92;)&lt;/span&gt; 中删去任何 &lt;span class=&quot;math inline&quot;&gt;&#92;(l&#92;)&lt;/span&gt;
个顶点后，剩下的部分每个连通分支都是仿射或者有限的。&lt;/p&gt;
&lt;/div&gt;</summary>
    
    
    
    <category term="Coxeter Groups" scheme="https://pywonderland.com/categories/Coxeter-Groups/"/>
    
    
  </entry>
  
  <entry>
    <title>Coxeter 群笔记（四）：有限、仿射、双曲三种情形的 Tits 锥</title>
    <link href="https://pywonderland.com/coxeter-groups-three-cases/"/>
    <id>https://pywonderland.com/coxeter-groups-three-cases/</id>
    <published>2021-12-06T16:00:00.000Z</published>
    <updated>2025-03-03T15:36:51.222Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要参考了 <span class="citation" data-cites="Howlett1997">(<a href="#ref-Howlett1997" role="doc-biblioref">Howlett, Rowley, and Taylor1997</a>)</span>。</p><p>书接 <a href="coxeter-groups-tits-cone">上回</a>，我们来研究内积<span class="math inline">\((\cdot,\cdot)\)</span>分别是有限、仿射和双曲三种情形时，其 Tits 锥 <span class="math inline">\(\mathcal{C}\)</span> 和对偶锥 <span class="math inline">\(\mathcal{C}^\ast\)</span> 的结构。</p><span id="more"></span><h1 id="有限">有限</h1><p>一个熟知的结论是，内积 <span class="math inline">\((\cdot,\cdot)\)</span> 是正定的当且仅当 <span class="math inline">\((W,S)\)</span> 是有限群 <span class="citation" data-cites="Humphreys90">(见 <a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.6.4</a>)</span>。我这里略过对此结论的证明（否则篇幅会拉的太长）。我们来证明这还等价于：</p><div id="finite-tits-V" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\(W\)</span> 是有限群当且仅当 Tits 锥 <span class="math inline">\(\mathcal{C}=V^\ast\)</span>。</p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>: 由 <span class="math inline">\(\mathcal{C}=V^\ast\)</span> 可得 <span class="math inline">\(-\mathcal{D}\in\mathcal{C}\)</span>（<span class="math inline">\(\mathcal{D}\)</span> 是基本区域），而对任何 <span class="math inline">\(x\in-\mathcal{D}\)</span> 都有 <span class="math inline">\(\Phi^+\subseteq \mathrm{Neg}(x)\)</span>，根据 <a href="/coxeter-groups-tits-cone/#tits-neg-finite">Tits锥的刻画</a>，<span class="math inline">\(|\Phi^+|=|\mathrm{Neg}(x)|&lt;\infty\)</span>，<a href="/coxeter-groups-root-system/#w-phi-both-finite-infinite">从而<span class="math inline">\(W\)</span> 是有限群</a>。</p><p><span class="math inline">\(\Leftarrow\)</span>: <span class="math inline">\(W\)</span> 是有限群说明 <span class="math inline">\(\Phi\)</span> 也是有限的，从而对任何 <span class="math inline">\(x\in V^\ast\)</span> 都有 <span class="math inline">\(|\mathrm{Neg}(x)|\leq|\Phi^+|&lt;\infty\)</span>，从而 <span class="math inline">\(x\in\mathcal{C}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>在下图中，<span class="math inline">\(W\)</span> 是正二十面体群<span class="math inline">\(H_3\)</span>，红色的锥是基本区域，它在 <span class="math inline">\(W\)</span> 的作用下铺满了整个空间，所以 <span class="math inline">\(\mathcal{C}=\mathbb{R}^3\)</span>。<span class="math inline">\(\mathcal{C}\)</span>与球面的交给出球面上的密铺。如果用直线而不是球面上的弧连接顶点的话，得到的是正二十面体。</p><p><img src="/images/coxeter/Tits_finite.png" class="fig" width="350"></p></div><h1 id="无限群的-tits-锥">无限群的 Tits 锥</h1><p>在仿射和双曲的情形，Coxeter 群都是无限群。我们来介绍一点关于无限Coxeter 群 Tits 锥的一般结论。</p><div id="phi-J-finite" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题2.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(W\)</span> 是不可约 Coxeter 群。如果存在 <span class="math inline">\(J\subsetneqq S\)</span> 使得 <span class="math inline">\(\Phi\setminus\Phi_J\)</span> 是有限集，则 <span class="math inline">\(W\)</span> 必然是有限群。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(J\subsetneqqS\)</span>，所以可以设 <span class="math inline">\(S\setminusJ=\{s_1,\ldots,s_r\}\,(r\geq1)\)</span>。由于 <span class="math inline">\(W\)</span> 不可约，<span class="math inline">\(W\)</span> 的 Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是连通的，<span class="math inline">\(J\)</span> 中的任何顶点都可以通过某条路径与 <span class="math inline">\(S\setminus J\)</span> 中的顶点相连。记 <span class="math inline">\(d(s)\)</span> 是顶点 <span class="math inline">\(s\)</span> 与 <span class="math inline">\(S\setminus J\)</span> 之间的最短距离，将 <span class="math inline">\(S\)</span> 按如下方式重新排序为 <span class="math inline">\(S=\{s_1,\ldots,s_n\}\)</span>： <span class="math display">\[S =\underbrace{\overbrace{\{s_1,\ldots,s_r\}}^{d(s)=0}}_{S\setminusJ}\cup\underbrace{\overbrace{\{s_{r+1},\ldots,s_{r+k}\}}^{d(s)=1},\overbrace{\{s_{r+k+1},\ldots\}}^{d(s)=2},\cdots}_{J}\,.\]</span></p><p>即 <span class="math inline">\(S\setminus J\)</span>中的顶点排在最前面，接下来是那些与 <span class="math inline">\(S\setminus J\)</span> 距离为 1 的顶点，然后是与<span class="math inline">\(S\setminus J\)</span> 距离为 2的顶点，等等。</p><p>记 <span class="math inline">\(\Phi_i^+\)</span> 是所有可以由 <span class="math inline">\(\{\alpha_i,\ldots,\alpha_n\}\)</span> 张成，且<span class="math inline">\(\alpha_i\)</span> 项系数不为 0的正根组成的集合： <span class="math display">\[\Phi_i^+=\{\lambda\mid\lambda\in\Phi^+,\ \lambda=\sum_{j=i}^nc_j\alpha_j,\ c_i\ne0\}.\]</span> 则不难看出有 <span class="math inline">\(\Phi^+=\Phi_1^+\sqcup\cdots\sqcup\Phi^+_n\)</span>，以及<span class="math inline">\(\Phi^+\setminus\Phi_J^+=\Phi_1^+\cup\cdots\cup\Phi^+_r\)</span>。由于假设了<span class="math inline">\(\Phi\setminus\Phi_J\)</span> 是有限的，所以<span class="math inline">\(\Phi_1^+,\ldots,\Phi^+_r\)</span>都是有限的。</p><p>我们用归纳法依次论证 <span class="math inline">\(\Phi^+_{r+1},\ldots,\Phi^+_{n}\)</span>也都是有限集：设 <span class="math inline">\(r+1\leq i\leq n\)</span>且已知对所有 <span class="math inline">\(j&lt;i\)</span>，<span class="math inline">\(\Phi_1^+,\ldots,\Phi^+_j\)</span> 都是有限集，现在考察 <span class="math inline">\(\Phi^+_i\)</span>，注意必然有 <span class="math inline">\(d(s_i)\geq1\)</span>，所以存在 <span class="math inline">\(j&lt;i\)</span> 使得 <span class="math inline">\(d(s_j)&lt;d(s_i)\)</span> 且 <span class="math inline">\(s_j\sim s_i\)</span>。</p><p>我们发现：</p><ol type="1"><li><span class="math inline">\(s_j\Phi_i^+\)</span>的元素都是正根。这是因为用 <span class="math inline">\(s_j\)</span>作用不改变 <span class="math inline">\(\Phi^+_i\)</span> 中元素的 <span class="math inline">\(\alpha_i\)</span> 项系数；</li><li><span class="math inline">\(s_j\Phi_i^+\subset\Phi^+_j\)</span>。这是因为若<span class="math inline">\(\lambda=\sum_{k\geqi}c_k\alpha_k\in\Phi^+_i\)</span>，则 <span class="math display">\[s_j\lambda=\lambda-2\left(\sum_{k\geqi}c_k(\alpha_k,\alpha_j)\right)\alpha_j.\]</span> 上面每一项 <span class="math inline">\(c_k(\alpha_k,\alpha_j)\)</span> 都非正，且由于顶点<span class="math inline">\(s_i,s_j\)</span> 相邻所以 <span class="math inline">\(c_i(\alpha_i,\alpha_j)&lt;0\)</span>。所以 <span class="math inline">\(s_j\lambda\)</span> 的 <span class="math inline">\(\alpha_j\)</span> 项系数严格大于 0。</li></ol><p>于是 <span class="math inline">\(|\Phi_i^+|\leq |\Phi^+_j|\)</span>也是有限集。从而所有 <span class="math inline">\(\Phi^+_1,\ldots,\Phi^+_n\)</span> 都是有限集，从而<span class="math inline">\(\Phi\)</span> 也是有限的。所以 <span class="math inline">\(W\)</span> 是有限群，命题得证。<span class="math inline">\(\blacksquare\)</span></p><p><a href="#phi-J-finite" title="命题 2.1">命题 2.1</a>有如下的推论：</p><div id="tits-cone-pointed" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.2</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(W\)</span> 不可约且是无限群，则 Tits 锥 <span class="math inline">\(\mathcal{C}\)</span> 满足 <span class="math inline">\(\mathcal{C}\cap-\mathcal{C}=\{0\}\)</span>，从而<span class="math inline">\(\mathcal{C}\)</span> 是一个点锥 (pointedcone)。</p></div><p><strong>证明</strong>：由于 <span class="math display">\[\mathcal{C}\cap-\mathcal{C}=\bigcup_{w_1,w_2\inW}w_1\overline{\mathcal{D}}\cap w_2(-\overline{\mathcal{D}}),\]</span>所以若 <span class="math inline">\(\mathcal{C}\cap-\mathcal{C}\ne\{0\}\)</span>则存在 <span class="math inline">\(x\ne0\in\overline{\mathcal{D}}\)</span> 和 <span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(-wx\in\overline{\mathcal{D}}\)</span>。令 <span class="math display">\[J=\{s\in S\mid \langle\alpha_s,\,x\rangle=0\}\]</span> 是经过 <span class="math inline">\(x\)</span> 的那些镜子。<span class="math inline">\(x\ne 0\)</span> 说明 <span class="math inline">\(J\subsetneqq S\)</span> 是真子集。</p><p>对任何 <span class="math inline">\(\lambda\in\Phi^+\setminus\Phi^+_J\)</span>，显然<span class="math inline">\(\langle\lambda,\,x\rangle&gt;0\)</span>，并且对这样的 <span class="math inline">\(\lambda\)</span> 有 <span class="math display">\[\langle w\lambda,\,-wx\rangle = \langle\lambda,\,-x\rangle&lt;0.\]</span> 而 <span class="math inline">\(-wx\in\overline{\mathcal{D}}\)</span>，所以 <span class="math inline">\(w\lambda\)</span> 是负根，从而 <span class="math inline">\(\Phi^+\setminus\Phi^+_J\subset\mathrm{Neg}(w)\)</span>，从而<span class="math display">\[|\Phi^+\setminus\Phi^+_J|\leq|\mathrm{Neg}(w)|=l(w)&lt;\infty.\]</span> 由 <a href="#phi-J-finite" title="命题 2.1">命题 2.1</a> <span class="math inline">\(W\)</span>是有限群，这与已知矛盾。<span class="math inline">\(\blacksquare\)</span></p><div id="dual-cone-non-trivial" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(W\)</span> 不可约且是无限群，则对偶锥 <span class="math inline">\(\mathcal{C}^\ast\ne\{0\}\)</span>。</p></div><p><strong>证明</strong>：用反证法，若不然，则 <span class="math inline">\(\overline{\mathcal{C}}=\mathcal{C}^{\ast\ast}=V^\ast\)</span>是全空间。由于一个凸集的内点和它的闭包的内点集相同（证明见这个 <a href="/papers/sCONVs.pdf">附件</a>），所以 <span class="math inline">\(\mathcal{C}=V\)</span>，这与 <a href="#tits-cone-pointed" title="推论 2.2">推论 2.2</a> 的结论 <span class="math inline">\(\mathcal{C}\)</span> 是点锥矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 id="仿射">仿射</h1><p>在本节中，我们需要如下关于不可约仿射 Coxeter 群的事实 <span class="citation" data-cites="Humphreys90">(见 <a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, secs. 2.6, 6.5</a>)</span>。</p><div id="affine-facts" class="statement simple plain unnumbered"><p>设 <span class="math inline">\(W\)</span> 是不可约、仿射 Coxeter群，则：</p><ol type="1"><li><span class="math inline">\(\mathrm{rad}(V)\)</span> 的维数是1，它由一个向量 <span class="math inline">\(\delta=\sum_{s\inS}z_s\alpha_s\)</span> 生成，其中每个 <span class="math inline">\(z_s&gt;0\)</span>。</li><li><span class="math inline">\(\delta\)</span> 的坐标 <span class="math inline">\(z=(z_1,\ldots,z_s)^T\)</span> 满足 <span class="math inline">\(Az=z^TAz=0\)</span>，其中 <span class="math inline">\(A=((\alpha_s, \alpha_t))_{s,t\in S}\)</span>是内积 <span class="math inline">\((\cdot,\cdot)\)</span> 的 Gram矩阵。</li><li><span class="math inline">\(w\delta=\delta\)</span> 对所有 <span class="math inline">\(w\in W\)</span> 成立。</li><li><span class="math inline">\(A\)</span> 的任何 <span class="math inline">\(\leq n-1\)</span> 阶主子式都是正定的。</li></ol></div><p>我们花点笔墨解释一下这几个事实的含义。回忆 <span class="math inline">\(W\)</span> 称作仿射是指内积 <span class="math inline">\((\cdot,\cdot)\)</span>是半正定但不是正定的。这个定义中没有要求 <span class="math inline">\((\cdot,\cdot)\)</span> 的 Sylvester 符号中有几个0，但是上面的 1, 2 告诉我们，在 <span class="math inline">\(W\)</span>不可约的前提下，<span class="math inline">\((\cdot,\cdot)\)</span>的符号中有且只有一个 0，并且 <span class="math inline">\(\mathrm{rad}(V)\)</span> 由一个向量 <span class="math inline">\(\delta\)</span> 生成。<span class="math inline">\(\delta\)</span> 的所有系数都非零并且同号，并且<span class="math inline">\(W\)</span> 保持 <span class="math inline">\(\delta\)</span> 不动。</p><p>3 是因为 <span class="math inline">\(W\)</span> 限制在 <span class="math inline">\(\mathrm{rad}(V)\)</span> 上是恒等变换，自然保持<span class="math inline">\(\delta\)</span> 不动。</p><p>4 说的是对任何 <span class="math inline">\(I\subsetneqqS\)</span>，标准椭圆子群 <span class="math inline">\(W_I\)</span>都是有限群；或者等价地，从 <span class="math inline">\(W\)</span> 的Coxeter 图 <span class="math inline">\(\Gamma\)</span>中删去至少一个顶点以后，剩下的子图是有限的。</p><div id="tits-cone-affine" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.1</span>.</span><span class="statement-spah"> </span>在仿射的情形<span class="math inline">\(\mathcal{C}^\ast\)</span> 是一条射线：<span class="math inline">\(\mathcal{C}^\ast=\mathbb{R}_{\geq0}\delta\)</span>，Tits锥 <span class="math inline">\(\mathcal{C}\)</span> 是以 <span class="math inline">\(\delta\)</span> 为法向量的半空间加上原点：<span class="math inline">\(\mathcal{C}=\{0\}\cup\{\delta &gt;0\}\)</span>。</p></div><p><strong>证明</strong>：根据 <a href="#dual-cone-non-trivial" title="推论 2.3">推论 2.3</a> 可知 <span class="math inline">\(\mathcal{C}^\ast\ne\{0\}\)</span>。结合 <a href="/coxeter-groups-tits-cone/#dual-cone-nonspace">对偶锥中的向量范数非正</a>以及 <span class="math inline">\((\cdot,\cdot)\)</span> 半正定可得 <span class="math inline">\(\mathcal{C}^\ast\subseteq\mathbb{R}\delta\)</span>。又因为<a href="/coxeter-groups-tits-cone/#tits-cone-dual-pointed"><span class="math inline">\(\mathcal{C}^\ast\)</span> 是点锥</a>，所以 <span class="math inline">\(\mathcal{C}^\ast\)</span> 等于 <span class="math inline">\(\mathbb{R}_{\geq0}\delta\)</span> 或者 <span class="math inline">\(\mathbb{R}_{\leq0}\delta\)</span> 之一。由于 <a href="/coxeter-groups-tits-cone/#tits-cone-dual"><span class="math inline">\(\mathcal{C}^\ast\subset\mathrm{cone}(\Delta)\)</span></a>，以及<span class="math inline">\(\delta\)</span> 是 <span class="math inline">\(\Delta\)</span> 的正线性组合，所以 <span class="math inline">\(\mathcal{C}^\ast=\mathbb{R}_{\geq0}\delta\)</span>。这就给出了对偶锥<span class="math inline">\(\mathcal{C}^\ast\)</span> 的刻画。</p><p>再来分析 Tits 锥 <span class="math inline">\(\mathcal{C}\)</span>。取对偶得到 <span class="math inline">\(\overline{\mathcal{C}}=\mathcal{C}^{\ast\ast}=\{\delta\geq0\}\)</span>。由于一个凸集的内点和它的闭包的内点集相同，所以<span class="math inline">\(\mathcal{C}^\circ=\{\delta&gt;0\}\)</span>，于是<span class="math display">\[\{\delta&gt;0\}\subset\mathcal{C}\subset\overline{\mathcal{C} }=\{\delta\geq0\}.\]</span></p><p>对任何 <span class="math inline">\(x\in\{\delta=0\}\)</span>，若<span class="math inline">\(x\in\mathcal{C}\)</span>，则存在 <span class="math inline">\(w\in W\)</span> 和 <span class="math inline">\(y\in\overline{\mathcal{D}}\)</span> 使得 <span class="math inline">\(x=wy\)</span>。于是 <span class="math display">\[0= \langle \delta,\,x\rangle=\langle \delta,\,wy\rangle=\langlew^{-1}\delta,\,y\rangle=\langle \delta,\,y\rangle=\sum_{s\inS}z_s\langle \alpha_s,\,y\rangle.\]</span> 然而每个 <span class="math inline">\(z_s&gt;0\)</span>，并且由于 <span class="math inline">\(y\in\overline{\mathcal{D}}\)</span> 所以每个 <span class="math inline">\(\langle\alpha_s,\,y\rangle\geq0\)</span>，这只能是 <span class="math inline">\(\langle \alpha_s,\,y\rangle=0\)</span> 对所有<span class="math inline">\(\alpha_s\in\Delta\)</span> 成立，这导致<span class="math inline">\(y=0\)</span>，从而 <span class="math inline">\(x=0\)</span>，所以超平面 <span class="math inline">\(\{\delta=0\}\)</span> 中属于 <span class="math inline">\(\mathcal{C}\)</span> 的只有 0。这就证明了 <span class="math inline">\(\mathcal{C}=\{0\}\cup\{\delta&gt;0\}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>在下图中，<span class="math inline">\(W\)</span> 是仿射 <span class="math inline">\(\widetilde{A}_2\)</span>，红色的锥是基本区域，它在<span class="math inline">\(W\)</span> 的作用下铺满了整个上半空间，所以<span class="math inline">\(\mathcal{C}=\{z&gt;0\}\cup\{0\}\)</span>。<span class="math inline">\(\mathcal{C}\)</span> 与平面 <span class="math inline">\(z=1\)</span> 的交给出二维的 Euclidean 密铺。</p><p><img src="/images/coxeter/Tits_affine.png" class="fig" width="350"></p></div><h1 id="双曲">双曲</h1><p>双曲的情形 Tits 锥的结构要复杂许多，一般来说没有完整的刻画。</p><p>我们首先来介绍一些关于 Lorentzian 内积的基本知识。这些内容在 <span class="citation" data-cites="ratcliffe">(<a href="#ref-ratcliffe" role="doc-biblioref">Ratcliffe 2006, vol. 149, chap. 3</a>)</span>中都可以找到。</p><p>设 <span class="math inline">\(V\)</span> 是一个 Lorentzian空间。我们称 <span class="math inline">\(v\in V\)</span> 是</p><ol type="1"><li>space-like 的，如果 <span class="math inline">\((v,v)&gt;0\)</span>；</li><li>light-like 的，如果 <span class="math inline">\((v,v)=0\)</span>；</li><li>time-like 的，如果 <span class="math inline">\((v,v)&lt;0\)</span>。</li></ol><p>这个定义也可以推广到 <span class="math inline">\(V\)</span>的子空间中：如果 <span class="math inline">\(U\subset V\)</span>是一个子空间，我们称 <span class="math inline">\(U\)</span> 是</p><ol type="1"><li>space-like 的，如果 <span class="math inline">\((\cdot,\cdot)\mid_U\)</span> 是正定的；</li><li>light-like 的，如果 <span class="math inline">\((\cdot,\cdot)\mid_U\)</span>是半正定的，但不是正定的；</li><li>time-like 的，如果 <span class="math inline">\(U\)</span> 包含time-like 的向量。</li></ol><p>由于 Lorentzian 内积是非退化的，所以对任何子空间 <span class="math inline">\(U\)</span> 都有 <span class="math inline">\(\dim U+ \dim U^\bot=n\)</span> 成立。</p><p>下面的命题是关于二次型知识的简单练习，我省略它们的证明。</p><div id="orth-complement-lorentzian" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.1</span>.</span></p><ol type="1"><li><span class="math inline">\(U\)</span> 是 space-like 的当且仅当<span class="math inline">\(U^\bot\)</span> 是 time-like 的；</li><li><span class="math inline">\(U\)</span> 是 light-like 的当且仅当<span class="math inline">\(U^\bot\)</span> 是 light-like 的。</li></ol></div><div id="lorentzinian-decomposition"></div><p>取 <span class="math inline">\(z\)</span> 是任一满足 <span class="math inline">\((z,z)=-1\)</span> 的 time-like 的向量，则 <span class="math inline">\((\mathbb{R}z)^\bot\)</span> 是 space-like的子空间并且有 <span class="math inline">\(V=\mathbb{R}z\oplus(\mathbb{R}z)^\bot\)</span> 成立。任何 <span class="math inline">\(v\inV\)</span> 可以写成 <span class="math inline">\(v = x + cz\,(x\in(\mathbb{R}z)^\bot,c\in\mathbb{R})\)</span> 的形式。记 <span class="math display">\[\mathcal{Q}=\{v\in V\mid (v,v)\leq 0\}\]</span>是所有非 space-like 的向量组成的集合，则 <span class="math display">\[v=x+cz\in\mathcal{Q}\Leftrightarrow(x,x)-c^2\leq0.\]</span></p><p><span class="math inline">\(\mathcal{Q}\)</span> 由上、下两个分支<span class="math inline">\(\mathcal{Q}_+,\,\mathcal{Q}_-\)</span>组成，它们分别由 <span class="math inline">\(\mathcal{Q}\)</span> 中满足<span class="math inline">\(c\geq0\)</span> 和 <span class="math inline">\(c\leq0\)</span> 的点组成。<span class="math inline">\(\mathcal{Q}_+=-\mathcal{Q}_-\)</span> 并且 <span class="math inline">\(\mathcal{Q}_+\cap\mathcal{Q}_-=\{0\}\)</span>。</p><p><img src="/images/coxeter/hyperboloid.svg" class="fig" width="350"></p><p>设 <span class="math inline">\(u,v\)</span>是两个非零向量，我们用记号 <span class="math inline">\(u\sim v\)</span>表示 <span class="math inline">\(u,v\)</span> 属于同一个分支，即 <span class="math inline">\(u,v\)</span> 同时属于 <span class="math inline">\(\mathcal{Q}_+\)</span> 或者同时属于 <span class="math inline">\(\mathcal{Q}_-\)</span>；用记号 <span class="math inline">\(u\not\sim v\)</span> 表示 <span class="math inline">\(u,v\)</span> 属于不同的分支，即 <span class="math inline">\(u,v\)</span> 一个属于 <span class="math inline">\(\mathcal{Q}_+\)</span>，另一个属于 <span class="math inline">\(\mathcal{Q}_-\)</span>。</p><div id="connected-component-dot" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.2</span> <span class="statement-info">(<span class="citation" data-cites="ratcliffe">(<a href="#ref-ratcliffe" role="doc-biblioref">Ratcliffe 2006</a>, thm.3.1.1)</span>)</span>.</span><span class="statement-spah"> </span><br></p><p>设 <span class="math inline">\(u,v\in\mathcal{Q}-\{0\}\)</span>。</p><ol type="1"><li>如果 <span class="math inline">\(u\sim v\)</span> 则 <span class="math inline">\((u,v)\leq0\)</span>。</li><li><span class="math inline">\((u,v)=0\)</span> 当且仅当 <span class="math inline">\(u,v\)</span> 是共线的 light-like 的向量。</li><li>如果 <span class="math inline">\(u,v\)</span> 中至少有一个是time-like 的向量，则 <span class="math inline">\(u\sim v\)</span>当且仅当 <span class="math inline">\((u,v)&lt;0\)</span>。</li></ol></div><p><strong>证明</strong>：</p><p>设 <span class="math inline">\(u=x+cz,\, v=y+dz\)</span>，则 <span class="math inline">\((x,x)\leq c^2\)</span>，<span class="math inline">\((y,y)\leq d^2\)</span>。</p><ol type="1"><li>若 <span class="math inline">\(u\sim v\)</span>，则 <span class="math inline">\(c,d\)</span> 同为正或者同为负。由于 <span class="math inline">\(z^\bot\)</span> 是正定子空间，<span class="math inline">\(x,y\in z^\bot\)</span>，由 Cauchy-Schwartz不等式有 <span class="math display">\[(u,v)=(x,y)-cd\leq\sqrt{(x,x)\cdot (y,y)}-cd \leq\sqrt{c^2d^2}-cd=|cd|-cd=0.\]</span></li><li>如果 <span class="math inline">\(u,v\)</span> 不共线，则 <span class="math inline">\(U=\mathrm{span}\{u,v\}\)</span> 是二维子空间，设<span class="math inline">\(w=au+bv\,(a,b\in\mathbb{R})\)</span> 是<span class="math inline">\(U\)</span> 中任一向量，由 <span class="math inline">\((u,v)=0\)</span> 可得 <span class="math display">\[(w,w)=a^2(u,u) + b^2(v,v)\leq0.\]</span> 即 <span class="math inline">\(U\)</span> 不包含 space-like 的向量。这与 <span class="math inline">\(\dim U=2\)</span> 和 <span class="math inline">\(V\)</span> 的 Sylvester 符号是 <span class="math inline">\((n-1,1)\)</span> 矛盾，所以 <span class="math inline">\(u,v\)</span> 必须共线。进一步显然 <span class="math inline">\(u,v\)</span> 都是 light-like的。反方向是显然的。</li><li>不妨设 <span class="math inline">\(u\)</span> 是 time-like的向量。<span class="math inline">\(\Rightarrow\)</span>：如果 <span class="math inline">\(u\sim v\)</span>，1 证明了 <span class="math inline">\((u,v)\leq0\)</span>。结合 <span class="math inline">\(u\)</span> 是 time-like 的和 2的结论，严格的不等号成立。<span class="math inline">\(\Leftarrow\)</span>：如果 <span class="math inline">\(u\not\sim v\)</span> 则 <span class="math inline">\(u\sim -v\)</span>，根据 1 的结论，<span class="math inline">\((u,-v)\leq0\)</span>，从而 <span class="math inline">\((u,v)\geq0\)</span>，矛盾。</li></ol><p><span class="math inline">\(\blacksquare\)</span></p><p>记 <span class="math inline">\(\mathcal{Q}_+\)</span> 和 <span class="math inline">\(\mathcal{Q}_-\)</span> 的内点分别为 <span class="math inline">\(\mathcal{N}_+\)</span> 和 <span class="math inline">\(\mathcal{N}_-\)</span>，<span class="math inline">\(\mathcal{N}_+\)</span> 和 <span class="math inline">\(\mathcal{N}_-\)</span> 分别是 <span class="math inline">\(\mathcal{N}=\{v\in V\mid (v,v)&lt;0\}\)</span>的两个连通分支。</p><p>由于 Lorentzinian 内积是非退化的，所以我们可以把 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 等同起来，这样 <span class="math inline">\(\mathcal{C}\)</span> 和 <span class="math inline">\(\mathcal{C}^\ast\)</span> 都在 <span class="math inline">\(V\)</span> 中。我们将证明这时 Tits 锥的闭包 <span class="math inline">\(\overline{ \mathcal{C} }\)</span> 必然包含 <span class="math inline">\(\mathcal{Q}_+,\,\mathcal{Q}_-\)</span>中的一个，同时与另一个的交只有 <span class="math inline">\(\{0\}\)</span>。</p><p>首先由 <a href="/coxeter-groups-tits-cone/#dual-cone-nonspace">前文中证明的结论</a>，<span class="math inline">\(\mathcal{C}^\ast\)</span>中的向量相互之间的内积非正，特别地对任何 <span class="math inline">\(v\in\mathcal{C}^\ast\)</span> 有 <span class="math inline">\((v,v)\leq0\)</span>，所以 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}\)</span>。</p><div id="dual-cone-trivial-intersection" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题4.3</span>.</span><span class="statement-spah"> </span>在 <span class="math inline">\(W\)</span> 不可约且双曲的情形，<span class="math inline">\(\mathcal{C}^\ast\cap\mathcal{Q}_+,\,\mathcal{C}^\ast\cap\mathcal{Q}_-\)</span> 中必有一个是<span class="math inline">\(\{0\}\)</span>。</p></div><p>这个结论应该是很直观的，如果 <span class="math inline">\(\mathcal{C}^\ast\)</span> 同时包含 <span class="math inline">\(\mathcal{Q}_+,\mathcal{Q}_-\)</span>中的非零向量的话，由于 <span class="math inline">\(\mathcal{C}^\ast\)</span>是点锥，这两个向量必然不共线，从而它们的非负线性组合可以给出 space-like的向量，这与 <span class="math inline">\(\mathcal{C}^\ast\)</span> 不含space-like 的向量矛盾。</p><p><strong>证明</strong>：若不然，设 <span class="math inline">\(u\in\mathcal{C}^\ast\cap\mathcal{Q}_+,\,u'\in\mathcal{C}^\ast\cap\mathcal{Q}_-\)</span> 是非零向量，<span class="math inline">\(u=x+cz,\,u'=y+dz\)</span> 是 <a href="#lorentzinian-decomposition">如前所述的分解</a>，则 <span class="math inline">\(c&gt;0,\,d&lt;0\)</span>。考察 <span class="math display">\[v=cu'-du=cy-dx\in(\mathbb{R}z)^\bot.\]</span><span class="math inline">\(v\)</span> 是 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(u'\)</span> 的非负线性组合，所以 <span class="math inline">\(v\)</span> 也属于 <span class="math inline">\(\mathcal{C}^\ast\)</span>，从而 <a href="/coxeter-groups-tits-cone/#dual-cone-nonspace"><span class="math inline">\((v,v)\leq0\)</span></a>。结合 <span class="math inline">\((\mathbb{R}z)^\bot\)</span> 是 space-like 的可得<span class="math inline">\(v=0\)</span>，于是 <span class="math inline">\(cu'=du\)</span>。由于 <span class="math inline">\(c,d\)</span> 异号所以 <span class="math inline">\(u\)</span> 和 <span class="math inline">\(-u\)</span> 同时属于 <span class="math inline">\(\mathcal{C}^\ast\)</span>，但 <span class="math inline">\(\mathcal{C}^\ast\)</span> 是点锥，所以 <span class="math inline">\(u=0\)</span>。从而 <span class="math inline">\(\mathcal{C}^\ast\cap\mathcal{Q}_+\)</span> 和<span class="math inline">\(\mathcal{C}^\ast\cap\mathcal{Q}_-\)</span>中必有一个等于 <span class="math inline">\(\{0\}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="dual-cone-belongs-branch" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论4.4</span>.</span><span class="statement-spah"></span>在双曲的情形，必有 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_+\)</span> 或者<span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_-\)</span>之一成立。</p></div><p><strong>证明</strong>：结合 <a href="#dual-cone-trivial-intersection" title="命题 4.3">命题 4.3</a> 和 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}=\mathcal{Q}_+\cup\mathcal{Q}_-\)</span>即得。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-closure" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论4.5</span>.</span><span class="statement-spah"></span>在双曲的情形，如果 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_+\)</span> 则<span class="math inline">\(\mathcal{C}\supset\mathcal{N}_-\)</span>。反之若 <span class="math inline">\(\mathcal{C}^\ast\subset\mathcal{Q}_-\)</span> 则<span class="math inline">\(\mathcal{C}\supset\mathcal{N}_+\)</span>。</p></div><p><strong>证明</strong>：首先注意到对任何 <span class="math inline">\(x\in\mathcal{Q}_+\)</span> 和 <span class="math inline">\(y\in\mathcal{Q}_-\)</span> 有 <span class="math inline">\((x,y)\geq0\)</span>，所以 <span class="math inline">\(\mathcal{Q}_+\)</span> 和 <span class="math inline">\(\mathcal{Q}_-\)</span>互相包含在对方的对偶锥中。</p><p>由 <a href="#dual-cone-belongs-branch" title="推论 4.4">推论4.4</a>，不妨设 <span class="math inline">\(\mathcal{C}^\ast\subseteq\mathcal{Q}_+\)</span>，<a href="/coxeter-groups-tits-cone/#dual-dual-cone">取对偶以后有</a> <span class="math inline">\(\overline{\mathcal{C}}=\mathcal{C}^{\ast\ast}\supseteq\mathcal{Q}_+^\ast\supseteq\mathcal{Q}_-\)</span>，即 <span class="math inline">\(\overline{\mathcal{C}}\supset\mathcal{Q}_-\)</span>。由于凸集的内点等于其闭包的内点，所以<span class="math display">\[\mathcal{C}^\circ=(\overline{ \mathcal{C}})^\circ\supset\mathcal{Q}_-^\circ=\mathcal{N}_-.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>以双曲群 <span class="math inline">\((7,3)\)</span>为例，红色的锥是 <span class="math inline">\(\overline{\mathcal{D}}\)</span>，Tits 锥 <span class="math inline">\(\mathcal{C}=\mathcal{N}_+\)</span>。取 <span class="math inline">\(\mathcal{C}\)</span> 与 hyperboloid的交给出双曲密铺。</p><p><img src="/images/coxeter/Tits_hyperbolic.png" class="fig" width="350"></p><p>注意这里光锥是理想边界，光锥上的点（除 <span class="math inline">\(0\)</span>以外）无法经过有限次反射变换到基本区域中，所以理想边界不属于 <span class="math inline">\(\mathcal{C}\)</span>。即 <span class="math inline">\(\mathcal{C}\subsetneqq\mathcal{Q}_+\)</span>。</p></div><h1 id="总结">总结</h1><p>下面的表格总结了有限、仿射、双曲三种情形 <span class="math inline">\(\mathcal{C}\)</span> 和 <span class="math inline">\(\mathcal{C}^\ast\)</span> 的结论：</p><table><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\mathcal{C}\)</span></td><td style="text-align: center;"><span class="math inline">\(\mathcal{C}^\ast\)</span></td></tr><tr class="even"><td style="text-align: center;">有限</td><td style="text-align: center;"><span class="math inline">\(V^\ast\)</span></td><td style="text-align: center;"><span class="math inline">\(\{0\}\)</span></td></tr><tr class="odd"><td style="text-align: center;">仿射</td><td style="text-align: center;"><span class="math inline">\(\{\delta&gt;0\}\cup\{0\}\)</span></td><td style="text-align: center;"><span class="math inline">\(\mathbb{R}_{\geq0}\delta\)</span></td></tr><tr class="even"><td style="text-align: center;">双曲</td><td style="text-align: center;">点锥且包含 <span class="math inline">\(\mathcal{N}_+,\mathcal{N}_-\)</span> 之一</td><td style="text-align: center;">属于 <span class="math inline">\(\mathcal{Q}_+,\mathcal{Q}_-\)</span> 之一</td></tr></tbody></table><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Howlett1997" class="csl-entry" role="listitem">Howlett, Robert B., Peter Rowley, and D. E. Taylor. 1997. <span>“OnOuter Automorphism Groups of Coxeter Groups.”</span> <em>ManuscriptaMathematica</em> 93: 499–513. <a href="https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/HowRowTay/1996-26.html">https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/HowRowTay/1996-26.html</a>.</div><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div><div id="ref-ratcliffe" class="csl-entry" role="listitem">Ratcliffe, John G. 2006. <em>Foundations of Hyperbolic Manifolds</em>.Second. Vol. 149. Graduate Texts in Mathematics. Springer.</div></div>]]></content>
    
    
    <summary type="html">
&lt;p&gt;本文主要参考了 &lt;span class=&quot;citation&quot; data-cites=&quot;Howlett1997&quot;&gt;(&lt;a href=&quot;#ref-Howlett1997&quot; role=&quot;doc-biblioref&quot;&gt;Howlett, Rowley, and Taylor
1997&lt;/a&gt;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;书接 &lt;a href=&quot;coxeter-groups-tits-cone&quot;&gt;上回&lt;/a&gt;，我们来研究内积
&lt;span class=&quot;math inline&quot;&gt;&#92;((&#92;cdot,&#92;cdot)&#92;)&lt;/span&gt;
分别是有限、仿射和双曲三种情形时，其 Tits 锥 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathcal{C}&#92;)&lt;/span&gt; 和对偶锥 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;mathcal{C}^&#92;ast&#92;)&lt;/span&gt; 的结构。&lt;/p&gt;</summary>
    
    
    
    <category term="Coxeter Groups" scheme="https://pywonderland.com/categories/Coxeter-Groups/"/>
    
    
  </entry>
  
  <entry>
    <title>Coxeter 群笔记（三）：Tits 锥</title>
    <link href="https://pywonderland.com/coxeter-groups-tits-cone/"/>
    <id>https://pywonderland.com/coxeter-groups-tits-cone/</id>
    <published>2021-12-05T16:00:00.000Z</published>
    <updated>2025-03-03T15:08:58.048Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要参考了 Bob Howlett 教授的讲义 <span class="citation" data-cites="Howlett-note">(<a href="#ref-Howlett-note" role="doc-biblioref">Howlett 1996</a>)</span>。</p><h1 id="tits-锥">Tits 锥</h1><p>在获得了 <span class="math inline">\(V\)</span>中关于根系的一些知识后，我们下面转移到 <span class="math inline">\(V\)</span> 的对偶空间 <span class="math inline">\(V^\ast\)</span> 中讨论万花筒的结构。</p><span id="more"></span><p>设 <span class="math inline">\(V^\ast\)</span> 是 <span class="math inline">\(V\)</span> 的对偶空间，<span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 之间有一个自然的双线性映射 <span class="math display">\[V\times V^\ast\to\mathbb{R}: \langlev,\,f\rangle= f(v).\]</span> 注意 <span class="math inline">\(\langle\,,\,\rangle\)</span> 和内积 <span class="math inline">\((\cdot,\cdot)\)</span> 的区别：<span class="math inline">\(\langle \,,\,\rangle\)</span> 是 <span class="math inline">\(V\times V^\ast\)</span>的自然配对，用尖括号表示；<span class="math inline">\((\cdot,\cdot)\)</span> 是 <span class="math inline">\(V\)</span> 上的内积。</p><p><span class="math inline">\(V\)</span> 上的可逆线性变换 <span class="math inline">\(g\in\mathrm{GL}(V)\)</span> 同样作用在 <span class="math inline">\(V^\ast\)</span> 上：对 <span class="math inline">\(f\in V^\ast\)</span>，线性泛函 <span class="math inline">\(g\cdot f\)</span> 定义为 <span class="math display">\[(g\cdot f)(v) = f(g^{-1} v).\]</span>为了简便我们省略 <span class="math inline">\(g\cdot f\)</span> 中的<span class="math inline">\(\cdot\)</span>，把它写作 <span class="math inline">\(gf\)</span>。</p><p>这样定义的目的是为了让 <span class="math inline">\(g\)</span>保持双线性映射 <span class="math inline">\(\langle \,,\,\rangle\)</span>不变： <span class="math display">\[\langle gv,\,gf\rangle = \langlev,\,f\rangle.\]</span> 用 <span class="math inline">\(g^{-1}f\)</span>代替 <span class="math inline">\(f\)</span>，我们得到 <span class="math display">\[\langle gv,\,f\rangle = \langlev,\,g^{-1}f\rangle.\]</span> 特别当 <span class="math inline">\(g=s\)</span> 是一个反射时，由于 <span class="math inline">\(s=s^{-1}\)</span> 所以 <span class="math display">\[\langle sv,\,f\rangle = \langlev,\,sf\rangle.\]</span> 这种将单个反射在 <span class="math inline">\((\cdot,\cdot){\,}{}\)</span>两边「跳来跳去」的技巧后面会经常用到。</p><p>由于 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 互为对偶空间，所以 <span class="math inline">\(\Delta=\{\alpha_s\}\)</span> 是 <span class="math inline">\(V^\ast\)</span>上的一组线性无关的泛函，定义它们的正半空间的交为 <span class="math display">\[\mathcal{D}= \bigcap_{s\in S}\{x\in V^\ast\mid\langle \alpha_s,\,x\rangle &gt; 0\}.\]</span> <span class="math inline">\(\mathcal{D}\)</span> 总是 <span class="math inline">\(V^\ast\)</span> 中的非空开集，其闭包记作 <span class="math inline">\(\overline{\mathcal{D}}\)</span>。你可以把 <span class="math inline">\(\mathcal{D}\)</span>理解为万花筒中原像所在的房间，超平面的集合 <span class="math inline">\(\{\alpha_s=0\}\)</span> 是房间的墙壁。<span class="math inline">\(\overline{\mathcal{D}}\)</span> 就是 <span class="math inline">\(\mathcal{D}\)</span> 加上了房间四周的墙壁。</p><p><span class="math inline">\(W\)</span> 同样作用在 <span class="math inline">\(V^\ast\)</span> 上： <span class="math display">\[\langle v,\,w f\rangle = \langlew^{-1}v,\,f\rangle.\quad v\in V,\,f\in V^\ast.\]</span> 在 <a href="/coxeter-groups-root-system/#faithful">上文</a> 中我们已经证明了<span class="math inline">\(W\)</span> 忠实地作用在 <span class="math inline">\(V\)</span> 上。不难验证在此定义下，<span class="math inline">\(W\)</span> 也忠实地作用在 <span class="math inline">\(V^\ast\)</span> 上，即如果 <span class="math inline">\(wf=f\)</span> 对任何 <span class="math inline">\(f\in V^\ast\)</span> 成立，则 <span class="math inline">\(w=1\)</span>。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>定义 <strong>Tits锥</strong>为 <span class="math display">\[\mathcal{C}= \bigcup_{w\in W}w\overline{\mathcal{D}}.\]</span></p></div><p>Tits 锥 <span class="math inline">\(\mathcal{C}\)</span>可以理解为万花筒，它是由原像房间 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 在 <span class="math inline">\(W\)</span> 下的所有虚像构成的。容易看到 <span class="math inline">\(\mathcal{C}\)</span> 是 <span class="math inline">\(W\)</span>- 不变的。</p><p>读者可能有疑问为什么 Tits 锥位于对偶空间 <span class="math inline">\(V^\ast\)</span> 中。看起来更自然的做法是，直接取以<span class="math inline">\(\Delta\)</span>为法向量的正半空间之交作为基本区域： <span class="math display">\[\mathcal{D}=\bigcap_{s\in S}\{v\inV\mid(\alpha_s, v)&gt;0\}\]</span> 在内积 <span class="math inline">\((\cdot,\cdot)\)</span>非退化时，这样做是可以的，但是在 <span class="math inline">\((\cdot,\cdot)\)</span> 退化时，可能会出现 <span class="math inline">\(\mathcal{D}\)</span> 是空集的问题。以仿射 <span class="math inline">\(\widetilde{A_1}\)</span> 为例，它的 Coxeter 矩阵是<span class="math display">\[\begin{pmatrix}1 &amp;\infty\\\infty&amp;1\end{pmatrix}.\]</span> 在 <span class="math inline">\(a_{s,t}=1\)</span> 时它给出的内积的 Gram 矩阵是<span class="math display">\[\begin{pmatrix}(\alpha_s,\alpha_s) &amp;(\alpha_s,\alpha_t)\\(\alpha_t,\alpha_t)&amp;(\alpha_t,\alpha_t)\end{pmatrix}=\begin{pmatrix}1&amp;-1\\-1&amp;1\end{pmatrix}.\]</span> 假设 <span class="math inline">\(v=a\alpha_s+b\alpha_t\in\mathcal{D}\)</span> 满足<span class="math inline">\((v,\alpha_s)&gt;0\)</span> 且 <span class="math inline">\((v,\alpha_t)&gt;0\)</span>，你会发现这要求 <span class="math inline">\(a&gt;b\)</span> 且 <span class="math inline">\(b&gt;a\)</span>，不存在这样的 <span class="math inline">\(v\)</span>！但是通过区分 <span class="math inline">\(W\)</span> 在 <span class="math inline">\(V\)</span> 和 <span class="math inline">\(V^\ast\)</span> 上的作用就可以避免这个问题。因为<span class="math inline">\(\Delta\)</span> 作为 <span class="math inline">\(V\)</span> 的一组基构成 <span class="math inline">\(V^\ast\)</span> 上一组线性无关的泛函，它们在 <span class="math inline">\(V^\ast\)</span>中正半空间的交是非空的拓扑开集。</p><p>读者可能注意到了：我们使用了 Tits 锥这个称呼，但 <span class="math inline">\(\mathcal{C}\)</span>真的是一个锥吗？这可不显然。要证明 Tits锥确实是锥，我们需要它的另一种等价刻画。</p><p>我们先回顾一下锥的概念：</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(C\)</span> 是某实向量空间的子集。如果对任何实数<span class="math inline">\(\alpha\geq0\)</span> 都有 <span class="math inline">\(\alpha C\subset C\)</span>，就称 <span class="math inline">\(C\)</span> 是一个<strong>锥</strong>。如果 <span class="math inline">\(C\)</span> 还是凸集，就称 <span class="math inline">\(C\)</span> 是<strong>凸锥</strong>。凸锥满足对任何<span class="math inline">\(x,y\in C\)</span> 和非负实数 <span class="math inline">\(\alpha,\beta\geq0\)</span>，<span class="math inline">\(\alpha x + \beta y\)</span> 仍然属于 <span class="math inline">\(C\)</span>。</p></div><p>设 <span class="math inline">\(X\)</span>是某实向量空间的子集，我们用记号 <span class="math inline">\(\mathrm{cone}(X)\)</span> 表示 <span class="math inline">\(X\)</span> 中元素的所有有限非负线性组合： <span class="math display">\[\mathrm{cone}(X) = \left\{\sum_{i=1}^n c_ix_i,\,x_1,\ldots,x_n\in X,\, c_i\geq0.\right\}.\]</span> 显然 <span class="math inline">\(\mathrm{cone}(X)\)</span> 总是凸锥，并且它还是包含<span class="math inline">\(X\)</span> 的最小凸锥。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>当 <span class="math inline">\(X\)</span> 是有限集时，<span class="math inline">\(\mathrm{cone}(X)\)</span> 总是闭集；但是当 <span class="math inline">\(X\)</span> 是无限集时则未必。例如当 <span class="math inline">\(X\)</span> 是 <span class="math inline">\(\mathbb{R}^2\)</span> 中直线 <span class="math inline">\(y=1\)</span> 上的全体整点时，<span class="math inline">\(\mathrm{cone}(X)=\{y&gt;0\}\cup\{0\}\)</span>不是闭集。</p></div><div id="fundamental-weights" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\Delta^\ast=\{\omega_t\}\subset V^\ast\)</span> 是<span class="math inline">\(\Delta\)</span> 的一组对偶基，满足 <span class="math inline">\(\langle\alpha_s,\,\omega_t\rangle=\delta_{st}\)</span>，<span class="math inline">\(\Delta^\ast\)</span>叫做<strong>基本权</strong>。记 <span class="math display">\[\Omega=\bigcup_{w\in W}w\Delta^\ast.\]</span><span class="math inline">\(\Omega\)</span>中的元素叫做<strong>权</strong>。</p></div><div id="fund-cone" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题1.4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\overline{\mathcal{D}}=\mathrm{cone}(\Delta^\ast)\)</span>。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(x\inV^\ast\)</span>，设 <span class="math inline">\(x=\sum_{s\inS}c_s\omega_s\)</span>，注意到 <span class="math inline">\(c_s=\langle\alpha_s,\,x\rangle\)</span>，所以 <span class="math display">\[x\in\mathrm{cone}(\Delta^\ast)\Leftrightarrowc_s\geq0 \text{ for all } s \in S \Leftrightarrow \langle\alpha_s,\,x\rangle\geq 0 \text{ for all } s\in S \Leftrightarrowx\in\overline{\mathcal{D}}.\]</span> <span class="math inline">\(\blacksquare\)</span></p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.5</span>.</span><span class="statement-spah"> </span>对任一 <span class="math inline">\(x\in V^\ast\)</span>，定义 <span class="math display">\[\mathrm{Neg}(x)= \{\lambda\in \Phi^+\mid \langle\lambda,\,x\rangle&lt;0\}.\]</span> <span class="math inline">\(\mathrm{Neg}(x)\)</span> 是正根 <span class="math inline">\(\Phi^+\)</span> 的子集，表示 <span class="math inline">\(x\)</span> 位于哪些镜子的「背面」。即这些镜子挡在<span class="math inline">\(x\)</span> 和基本区域 <span class="math inline">\(\mathcal{D}\)</span> 之间。</p></div><p>显然 <span class="math inline">\(\overline{\mathcal{D}}=\{x\inV^\ast\mid\mathrm{Neg}(x)=\emptyset\}\)</span>。房间 <span class="math inline">\(\overline{\mathcal{D}}\)</span>和它在镜子中的所有虚像构成了 Tits 锥 <span class="math inline">\(\mathcal{C}\)</span>。<span class="math inline">\(\mathcal{C}\)</span> 中每个点都是 <span class="math inline">\(\overline{\mathcal{D}}\)</span>中某个点经过有限次反射后得到的。这启发我们给出 <span class="math inline">\(\mathcal{C}\)</span> 的另一种刻画：</p><div id="tits-neg-finite" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.6</span>.</span><span class="statement-spah"> </span>Tits 锥 <span class="math inline">\(\mathcal{C}= \{x\in V^\ast \mid |\mathrm{Neg}(x)|&lt; \infty\}\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个定理的几何意义是，Tits 锥恰好由那些和基本区域 <span class="math inline">\(\overline{\mathcal{D}}\)</span>之间只隔着有限多个镜子的点组成，这样的点一定可以通过有限次单反射变换到<span class="math inline">\(\overline{\mathcal{D}}\)</span>中。换言之，Tits 锥中的点使得下面的 <code>while</code>循环可以在有限次后结束：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> dot(x, alpha_s) &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> some s <span class="hljs-keyword">in</span> S:<br>    x = reflect(x, alpha_s)<br></code></pre></td></tr></tbody></table></figure><p>下面的动画展示了双曲 Coxeter 群 <span class="math inline">\(\Delta(3,3,7)\)</span> 的 Tits 锥中那些反射次数<span class="math inline">\(\leq10\)</span> 的点：</p><p><img src="/images/coxeter/337-anim.gif" class="fig" width="400"></p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>：设 <span class="math inline">\(x\in\mathcal{C}\)</span>，则 <span class="math inline">\(x\)</span> 可以表示为 <span class="math inline">\(x=wv\)</span>，其中 <span class="math inline">\(w\in W,v\in\overline{\mathcal{D}}\)</span>。设<span class="math inline">\(\lambda\in\mathrm{Neg}(x)\)</span>，则 <span class="math display">\[0&gt;\langle \lambda,\,x\rangle=\langle\lambda,\,wv\rangle=\langle w^{-1}\lambda,\,v\rangle.\]</span> 然而<span class="math inline">\(v\in\overline{\mathcal{D}}\)</span>，这说明<span class="math inline">\(w^{-1}\lambda\in\Phi^-\)</span>，从而 <span class="math inline">\(\mathrm{Neg}(x)\subseteq N(w^{-1})\)</span>，从而<span class="math display">\[|\mathrm{Neg}(x)|\leq|N(w^{-1})|=l(w)&lt;\infty.\]</span></p><p><span class="math inline">\(\Leftarrow\)</span>：反之若 <span class="math inline">\(|\mathrm{Neg}(x)|&lt;\infty\)</span>，我们来论证存在<span class="math inline">\(w\in W\)</span> 使得 <span class="math inline">\(wx\in\overline{\mathcal{D}}\)</span>。这里的想法是，每次选择一个单根<span class="math inline">\(\alpha_s\)</span> 对应的镜面，使得 <span class="math inline">\(x\)</span> 落在这个镜子的背面，然后将 <span class="math inline">\(x\)</span> 关于 <span class="math inline">\(\alpha_s\)</span> 反射过去变到 <span class="math inline">\(\alpha_s\)</span> 的正面，这个操作会将遮挡在 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(\overline{\mathcal{D}}\)</span>之间的镜子个数严格减少 1。如此这般直到 <span class="math inline">\(x\)</span> 落入 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 为止。</p><p>严格的论证如下：</p><p>若 <span class="math inline">\(\mathrm{Neg}(x)=\emptyset\)</span>这显然成立，因为这时 <span class="math inline">\(x\)</span> 本身就落在<span class="math inline">\(\overline{\mathcal{D}}\)</span> 中。当 <span class="math inline">\(\mathrm{Neg}(x)\ne\emptyset\)</span> 时，<span class="math inline">\(\mathrm{Neg}(x)\)</span> 中一定包含一个单根 <span class="math inline">\(\alpha_s\in\Delta\)</span>，于是 <span class="math inline">\(\langle \alpha_s,\,x\rangle&lt; 0\)</span>。考虑<span class="math inline">\(x\)</span> 关于 <span class="math inline">\(\alpha_s\)</span> 的镜像点 <span class="math inline">\(sx\)</span>，<span class="math inline">\(sx\)</span> 位于 <span class="math inline">\(\alpha_s\)</span> 的正面，所以 <span class="math inline">\(\alpha_s\notin\mathrm{Neg}(sx)\)</span>，从而对任何<span class="math inline">\(\lambda\in\mathrm{Neg}(sx)\)</span>，<a href="/coxeter-groups-root-system/#simple-ref"><span class="math inline">\(s\lambda\)</span> 仍然是正根</a>。于是 <span class="math display">\[\lambda\in\mathrm{Neg}(sx)\Rightarrow\langle\lambda,\,sx\rangle&lt;0\Rightarrow\langles\lambda,\,x\rangle&lt;0\Rightarrow s\lambda\in\mathrm{Neg}(x).\]</span>当然 <span class="math inline">\(s\lambda\ne\alpha_s\)</span>，否则<span class="math inline">\(\lambda=-\alpha_s\)</span> 与 <span class="math inline">\(\lambda\)</span> 是正根矛盾，所以上式说明<span class="math display">\[s\cdot\mathrm{Neg}(sx)\subseteq\mathrm{Neg}(x)\setminus\{\alpha_s\}.\]</span>从而 <span class="math inline">\(\mathrm{Neg}(sx)\)</span>的元素个数严格小于 <span class="math inline">\(\mathrm{Neg}(x)\)</span>。</p><p>重复此过程我们可以取一组 <span class="math inline">\(s_1,\ldots,s_k\)</span> 使得 <span class="math inline">\(y=s_1\cdots s_k\cdot x\)</span> 满足 <span class="math inline">\(\mathrm{Neg}(y)=\emptyset\)</span>，从而 <span class="math inline">\(y\in\overline{\mathcal{D}}\)</span>，这就证明了结论。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-convex" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.7</span>.</span><span class="statement-spah"> </span>Tits 锥 <span class="math inline">\(\mathcal{C}\)</span> 是凸锥。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(x,y\in\mathcal{C}\)</span> 和 <span class="math inline">\(\alpha,\beta\geq0\)</span>，我们需要证明 <span class="math inline">\(z=\alpha x+\beta y\)</span> 也属于 <span class="math inline">\(\mathcal{C}\)</span>。但是 <span class="math display">\[\mathrm{Neg}(z)\subseteq\mathrm{Neg}(x)\cup\mathrm{Neg}(y),\]</span>根据 <a href="#tits-neg-finite" title="定理 1.6">定理 1.6</a> <span class="math inline">\(\mathrm{Neg}(x),\,\mathrm{Neg}(y)\)</span>都有限，所以 <span class="math inline">\(\mathrm{Neg}(z)\)</span>也有限，从而 <span class="math inline">\(z\in\mathcal{C}\)</span>，即<span class="math inline">\(\mathcal{C}\)</span> 是凸锥。<span class="math inline">\(\blacksquare\)</span></p><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.8</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathcal{C}=\mathrm{cone}(\Omega)\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(\Omega\supset\Delta^\ast\)</span>，以及根据 <a href="#fund-cone" title="命题 1.4">命题 1.4</a> 有 <span class="math inline">\(\mathrm{cone}(\Delta^\ast)=\overline{\mathcal{D}}\)</span>，所以<span class="math display">\[\mathrm{cone}(\Omega)\supset\mathrm{cone}(\Delta^\ast)=\overline{\mathcal{D}}.\]</span>再结合 <span class="math inline">\(\mathrm{cone}(\Omega)\)</span> 是<span class="math inline">\(W\)</span>- 不变的，所以它包含 <span class="math inline">\(\bigcup_{w\inW}w\overline{\mathcal{D}}=\mathcal{C}\)</span>。</p><p>另一方面 <span class="math inline">\(\mathcal{C}\supset\overline{\mathcal{D}}\supset\Delta^\ast\)</span>，并且<span class="math inline">\(\mathcal{C}\)</span> 也是 <span class="math inline">\(W\)</span>- 不变的，所以 <span class="math display">\[\mathcal{C}\supset\bigcup_{w\inW}w\Delta^\ast=\Omega.\]</span> 而 <a href="#tits-convex" title="推论 1.7">推论 1.7</a> 证明了 <span class="math inline">\(\mathcal{C}\)</span> 是凸锥，所以 <span class="math inline">\(\mathcal{C}\supset\mathrm{cone}(\Omega)\)</span>。<span class="math inline">\(\blacksquare\)</span></p><h1 id="tits-锥的内点">Tits 锥的内点</h1><p>接下来我们来讨论 <span class="math inline">\(\mathcal{C}\)</span>的内点集 <span class="math inline">\(\mathcal{C}^\circ\)</span>。我们将证明 <span class="math inline">\(\mathcal{C}^\circ\)</span>由那些稳定化子群是有限群的点组成： <span class="math display">\[\mathcal{C}^\circ = \{x\in V^\ast \mid|\mathrm{Stab}(x)| &lt; \infty\}.\]</span></p><div id="stabilizer-parabolic-subgroup" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.1</span>.</span><span class="statement-spah"> </span>对任何 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，记 <span class="math inline">\(J=\{s\in S \mid \langle\alpha_s,\,x\rangle=0\}\)</span>，则 <span class="math inline">\(\mathrm{Stab}(x) = W_J\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个定理的含义是，对原像房间 <span class="math inline">\(\overline{\mathcal{D}}\)</span> 中的一点 <span class="math inline">\(x\)</span>，其稳定化子群 <span class="math inline">\(\mathrm{Stab}(x)\)</span>是一个标准椭圆子群，由那些包含 <span class="math inline">\(x\)</span>的镜子 <span class="math inline">\(\{\alpha_s\in\Delta \mid \langle\alpha_s,\,x\rangle=0\}\)</span> 对应的反射生成。</p></div><p><strong>证明</strong>：</p><p>对任何 <span class="math inline">\(s\in J\)</span> 和 <span class="math inline">\(v\in V\)</span> 我们有 <span class="math display">\[\langle v,\,sx\rangle = \langlesv,\,x\rangle=\langle v-2(v,\alpha_s)\alpha_s,\,x\rangle=\langlev,\,x\rangle-2(v,\alpha_s)\langle \alpha_s,\,x\rangle=\langlev,\,x\rangle.\]</span> 由 <span class="math inline">\(v\)</span>的任意性可得 <span class="math inline">\(sx=x\)</span>，从而 <span class="math inline">\(W_J\subseteq\mathrm{Stab}(x)\)</span>。</p><p>为了证明反向的包含关系，设 <span class="math inline">\(w=s_1\cdotss_k\in\mathrm{Stab}(x)\)</span> 是一个既约表示，我们从最末一个元素 <span class="math inline">\(s_k\)</span> 开始，向左逐个验证它们属于 <span class="math inline">\(J\)</span>。</p><p>记 <span class="math inline">\(w'=s_1\cdots s_{k-1}\)</span>，则<span class="math inline">\(l(ws_k)=l(w')&lt;l(w)\)</span>，于是<span class="math inline">\(w\alpha_k\in\Phi^-\)</span>。我们有 <span class="math display">\[0\geq \langle w\alpha_k,\,x\rangle = \langle\alpha_k,\,wx\rangle = \langle \alpha_k,\,x\rangle\geq0.\]</span>其中第一个不等号是因为 <span class="math inline">\(w\alpha_k\)</span>是负根和 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>。于是上面的不等式中等号都成立，从而<span class="math inline">\(\langle \alpha_k,\,x\rangle=0\)</span>，即<span class="math inline">\(s_k\in J\)</span> 且 <span class="math inline">\(s_kx=x\)</span>。进一步 <span class="math inline">\(w'\)</span> 也满足 <span class="math inline">\(w'x=x\)</span>。对 <span class="math inline">\(w'\)</span> 重复此论证，便得到 <span class="math inline">\(s_1,\ldots,s_k\)</span> 都属于 <span class="math inline">\(J\)</span>，从而定理得证。<span class="math inline">\(\blacksquare\)</span></p><div id="fd-finite-stabilizer" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题2.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(x\in\overline{\mathcal{D}}\)</span>，<span class="math inline">\(J\)</span> 的定义如 <a href="#stabilizer-parabolic-subgroup" title="定理 2.1">定理 2.1</a>，则<span class="math inline">\(x\in\mathcal{C}^\circ\)</span> 当且仅当<span class="math inline">\(W_J\)</span> 是有限群。</p></div><p><strong>证明</strong>：</p><p><span class="math inline">\(\Rightarrow\)</span>：思路：如果 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(\mathcal{C}\)</span> 的内点，并且经过 <span class="math inline">\(x\)</span> 的镜面有无穷多个，那么可以在 <span class="math inline">\(x\)</span> 的附近取一点 <span class="math inline">\(z\)</span>，<span class="math inline">\(z\)</span>仍然是 <span class="math inline">\(\mathcal{C}\)</span>的内点，使得这无穷多个镜子都挡在基本区域和 <span class="math inline">\(z\)</span> 之间，从而 <span class="math inline">\(\mathrm{Neg}(z)\)</span> 是无限集，从而 <span class="math inline">\(z\notin\mathcal{C}\)</span>，导致矛盾。</p><p>严格的论证如下：</p><figure><img src="/images/coxeter/WJ.svg" width="300" alt="一个示意图，z 落在所有 \Phi_J 中镜子的背面"><figcaption aria-hidden="true">一个示意图，<span class="math inline">\(z\)</span> 落在所有 <span class="math inline">\(\Phi_J\)</span> 中镜子的背面</figcaption></figure><p>任取 <span class="math inline">\(y\in\mathcal{D}\)</span>。由于 <span class="math inline">\(x\in\mathcal{C}^\circ\)</span>，所以在线段 <span class="math inline">\(\overline{[y, x]}\)</span> 上我们可以朝着 <span class="math inline">\(x\)</span> 的方向延伸一点点，得到点 <span class="math inline">\(z\)</span>，使得 <span class="math inline">\(z\)</span> 仍然位于 <span class="math inline">\(\mathcal{C}^\circ\)</span> 中。<span class="math inline">\(z\)</span> 可以表示为 <span class="math display">\[z=(1-t)x+ty,\quad t&lt;0.\]</span> 于是对所有<span class="math inline">\(s\in J\)</span> 都有 <span class="math inline">\(\langle \alpha_s,\,z\rangle=t\langle\alpha_s,\,y\rangle &lt; 0\)</span>，从而 <span class="math inline">\(\Phi_J^+\subset\mathrm{Neg}(z)\)</span>。如果<span class="math inline">\(W_J\)</span> 是无限群那么 <span class="math inline">\(\Phi_J^+\)</span> 也是无限的，从而 <span class="math inline">\(\mathrm{Neg}(z)\)</span> 是无限集，从而 <span class="math inline">\(z\notin\mathcal{C}^\circ\)</span>，矛盾！</p><p><span class="math inline">\(\Leftarrow\)</span>：反之若 <span class="math inline">\(W_J\)</span> 是有限群，仍然任取 <span class="math inline">\(y\in\mathcal{D}\)</span>。</p><figure><img src="/images/coxeter/WJ2.svg" width="300" alt="y 在 W_J 下的像全部位于镜面 \alpha_s=0 的正侧，故 \langle \alpha_s,\,wy\rangle 对 w\in W_J 总为正"><figcaption aria-hidden="true"><span class="math inline">\(y\)</span> 在<span class="math inline">\(W_J\)</span> 下的像全部位于镜面 <span class="math inline">\(\alpha_s=0\)</span> 的正侧，故 <span class="math inline">\(\langle \alpha_s,\,wy\rangle\)</span> 对 <span class="math inline">\(w\in W_J\)</span> 总为正</figcaption></figure><p>对任何镜面 <span class="math inline">\(s\in S\setminusJ\)</span>，由于 <span class="math inline">\(x\)</span>不属于此镜面，所以 <span class="math inline">\(\langle\alpha_s,\,x\rangle&gt;0\)</span>。</p><p>另一方面对任何 <span class="math inline">\(w\in W_J\)</span>，<a href="/coxeter-groups-root-system#remain-positive-root"><span class="math inline">\(w^{-1}\alpha_s\)</span> 仍然是正根</a>，所以 <span class="math display">\[\langle \alpha_s,\,wy\rangle=\langlew^{-1}\alpha_s,\,y\rangle&gt;0.\]</span> 于是 <span class="math display">\[\delta = \min\left\{\frac{\langle\alpha_s,\,x\rangle}{\langle \alpha_s,\,wy\rangle}\,\middle|\,\alpha_s\in S\setminus J,\, w\in W_J\right\}&gt;0.\]</span>将上面的分母乘到左边然后对 <span class="math inline">\(w\in W_J\)</span>求和，我们有 <span class="math display">\[\delta\cdot\langle\alpha_s,\,\sum_{w\in W_J}wy\rangle\leq \langle \alpha_s,\,x\rangle\cdot|W_J| &lt; 2\langle \alpha_s,\,x\rangle\cdot |W_J|,\quad s\in S\setminusJ.\tag{1}\label{eq:strict}\]</span> 注意这个不等式两边关于 <span class="math inline">\(\alpha_s\)</span> 都是线性的。</p><p>既然对 <span class="math inline">\(s\in S\setminus J\)</span>上面的不等式是严格的，那么对 <span class="math inline">\(s\in J\)</span>又如何呢？这时右边 <span class="math inline">\(\langle\alpha_s,\,x\rangle=0\)</span>。又因为 <span class="math inline">\(\sum_{w\in W_J}wy\)</span> 在 <span class="math inline">\(W_J\)</span> 下保持不变，所以根据 <a href="#stabilizer-parabolic-subgroup" title="定理 2.1">定理 2.1</a> 可得<span class="math inline">\(\langle \alpha_{s},\,\sum_{w\inW_J}wy\rangle=0\)</span>，从而上面的不等式变成了等式（两边都是 0）：<span class="math display">\[0=\delta\cdot\langle \alpha_s,\,\sum_{w\inW_J}wy\rangle= 2\langle \alpha_s,\,x\rangle\cdot |W_J|,\quad s\inJ.\tag{2}\label{eq:equal}\]</span> 对任何 <span class="math inline">\(\lambda\in\Phi^+\setminus\Phi_J^+\)</span>，设<span class="math display">\[\lambda=\sum_{s\in S\setminus J}c_s\alpha_s+ \sum_{t\in J}d_t\alpha_t,\quad c_s,d_t\geq0.\]</span> 其中至少有一项<span class="math inline">\(c_s\)</span> 严格大于 0。将 <span class="math inline">\(\lambda\)</span> 代入 <span class="math inline">\((\ref{eq:strict})\)</span> 中 <span class="math inline">\(\alpha_s\)</span> 的位置，严格不等式仍然成立。即<span class="math display">\[\delta\cdot\langle \lambda,\,\sum_{w\inW_J}wy\rangle&lt; 2\langle \lambda,\,x\rangle\cdot |W_J|.\]</span>注意对 <span class="math inline">\(w\in W_J\)</span>，<span class="math inline">\(w^{-1}\lambda\)</span> 作为 <span class="math inline">\(\lambda\)</span> 和 <span class="math inline">\(\{\alpha_s\mid s\in J\}\)</span>的线性组合仍然是正根，并且不在 <span class="math inline">\(\Phi_J^+\)</span> 中，所以上面的求和中每一项 <span class="math inline">\(\langle \lambda,\,wy\rangle=\langlew^{-1}\lambda,\,y\rangle&gt;0\)</span>，我们可以只取 <span class="math inline">\(w=1\)</span> 的一项，其余全扔掉，得到 <span class="math display">\[\delta\cdot\langle \lambda,\,y\rangle&lt;2\langle \lambda,\,x\rangle\cdot |W_J|.\]</span> 记 <span class="math inline">\(z = 2|W_J|x - \delta y\)</span>，我们得到 <span class="math inline">\(\langle \lambda,\,z\rangle&gt;0\)</span> 对任何<span class="math inline">\(\lambda\in\Phi^+\setminus\Phi_J^+\)</span>成立。</p><p>另一方面对任何 <span class="math inline">\(\mu\in\Phi_J^+\)</span>，由于 <span class="math inline">\(\langle \mu,\,x\rangle=0\)</span>，所以 <span class="math inline">\(\langle \mu,\,z\rangle=-\delta\langle\mu,\,y\rangle&lt;0\)</span>，于是 <span class="math inline">\(\mathrm{Neg}(z)=\Phi_J^+\)</span> 是有限集，从而<span class="math inline">\(z\in\mathcal{C}\)</span>。</p><p>实际上我们有 <span class="math inline">\(z\in\mathcal{C}^\circ\)</span>，这是因为对任何<span class="math inline">\(\lambda\in\Phi\)</span>，<span class="math inline">\(\lambda\)</span> 必然属于 <span class="math inline">\(\pm\Phi^+_J,\pm(\Phi^+\setminus\Phi^+_J)\)</span>之一，而我们已经看到 <span class="math inline">\(\langle\lambda,\,z\rangle\)</span> 总不是 0，所以 <span class="math inline">\(z\)</span> 不落在任何镜面上。设 <span class="math inline">\(z=wv,\,v\in\overline{\mathcal{D}}\)</span>，那么<span class="math display">\[\langle \alpha_s,\,v\rangle=\langlew\alpha_s,\,wv\rangle=\langle w\alpha_s,\,z\rangle\ne0\]</span> 对任何<span class="math inline">\(\alpha_s\in\Delta\)</span> 成立，所以 <span class="math inline">\(v\in\mathcal{D}\subset\mathcal{C}^\circ\)</span>，从而<span class="math inline">\(z=wv\inw\mathcal{D}\subset\mathcal{C}^\circ\)</span>。</p><figure><img src="/images/coxeter/WJ3.svg" width="300" alt="我们证明 z 只落在 \Phi_J 中镜面的背面，从而 z\in\mathcal{C}；并证明 z 不属于任何镜面，从而 z\in\mathcal{C}^\circ"><figcaption aria-hidden="true">我们证明 <span class="math inline">\(z\)</span> 只落在 <span class="math inline">\(\Phi_J\)</span> 中镜面的背面，从而 <span class="math inline">\(z\in\mathcal{C}\)</span>；并证明 <span class="math inline">\(z\)</span> 不属于任何镜面，从而 <span class="math inline">\(z\in\mathcal{C}^\circ\)</span></figcaption></figure><p>现在 <span class="math inline">\(x\)</span> 是 <span class="math inline">\(z\)</span> 和 <span class="math inline">\(y\)</span> 的线性组合 <span class="math inline">\(x = \frac{1}{2|W_J|}(z + \deltay)\)</span>。我们来说明 <span class="math inline">\(x\)</span> 也属于<span class="math inline">\(\mathcal{C}^\circ\)</span>。由于 <span class="math inline">\(z,y\in\mathcal{C}^\circ\)</span>，所以 <span class="math inline">\(\frac{1}{2|W_J|}z,\frac{\delta}{2|W_J|}y\in\mathcal{C}^\circ\)</span>，即存在开集 <span class="math inline">\(A,B\)</span> 满足 <span class="math inline">\(\frac{1}{2|W_J|}z\inA\subset\mathcal{C}^\circ\)</span>，<span class="math inline">\(\frac{\delta}{2|W_J|}y\in B\subset\mathcal{C}^\circ\)</span>，于是 <span class="math inline">\(x\inA+B=\cup_{p\in B}(A+p)\)</span>，这是一组开集的并，所以 <span class="math inline">\(x\in\mathcal{C}^\circ\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-int-finite-stabilizer" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理2.3</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(y\in\mathcal{C}\)</span>，则 <span class="math inline">\(y\in\mathcal{C}^\circ\)</span> 当且仅当 <span class="math inline">\(\mathrm{Stab}(y)\)</span> 是有限群。</p></div><p><strong>证明</strong>：<span class="math inline">\(y\)</span>可以写成 <span class="math inline">\(y=wx\,(w\inW,\,x\in\overline{\mathcal{D}})\)</span> 的形式，从而 <span class="math inline">\({\rm Stab}(y)=w{\rmStab}(x)w^{-1}\)</span>，二者同为有限群或者无限群；而且 <span class="math inline">\(x,y\)</span> 同时属于或者同时不属于 <span class="math inline">\(\mathcal{C}^\circ\)</span>。由 <a href="#fd-finite-stabilizer" title="命题 2.2">命题 2.2</a>即得结论。<span class="math inline">\(\blacksquare\)</span></p><h1 id="tits-锥的对偶锥">Tits 锥的对偶锥</h1><p>这一节来讨论 Tits 锥的对偶锥。研究对偶锥对理解 Tits锥本身的结构也很有帮助。</p><div id="dual-cone" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义3.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(C\)</span> 是 <span class="math inline">\(V\)</span> 中的一个锥，定义 <span class="math inline">\(C\)</span> 的对偶锥 <span class="math inline">\(C^\ast\in V^\ast\)</span> 为 <span class="math display">\[C^\ast = \{f\in V^\ast\mid f(v)\geq0,\ \forallv\in C\}.\]</span> 即 <span class="math inline">\(C^\ast\)</span>是对偶空间中那些在 <span class="math inline">\(C\)</span>上取值均非负的线性泛函组成的集合。</p></div><p>不难看出 <span class="math inline">\(C^\ast\)</span> 也构成 <span class="math inline">\(V^\ast\)</span>中的一个锥，所以我们又可以取其对偶锥 <span class="math inline">\(C^{\ast\ast}\subset V\)</span>。</p><div id="dual-dual-cone" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.2</span>.</span><span class="statement-spah"> </span><span class="math inline">\(C^{\ast\ast} = \overline{C}\)</span>。其中 <span class="math inline">\(\overline{C}\)</span> 是 <span class="math inline">\(C\)</span> 的拓扑闭包。</p></div><p><strong>证明</strong>：显然 <span class="math inline">\(\overline{C}\subseteqC^{\ast\ast}\)</span>，只要论证 <span class="math inline">\(C^{\ast\ast}\subseteq \overline{C}\)</span> 即可。</p><p>对任何 <span class="math inline">\(x\notin\overline{C}\)</span>，根据凸集分离定理，存在超平面<span class="math inline">\(H\)</span>，其法向量 <span class="math inline">\(n\)</span> 满足 <span class="math inline">\((n,C)\geq 0\)</span> 但是 <span class="math inline">\((n,x) &lt; 0\)</span>。于是线性泛函 <span class="math inline">\((n,\cdot)\in C^\ast\)</span> 且由于 <span class="math inline">\((n,x)&lt;0\)</span> 从而 <span class="math inline">\(x\notin C^{\ast\ast}\)</span>。反向包含得证。<span class="math inline">\(\blacksquare\)</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>对不熟悉凸集分离定理的读者，下面是一点细节补充：设 <span class="math inline">\(u\in\overline{C}\)</span> 是 <span class="math inline">\(\overline{C}\)</span> 中与 <span class="math inline">\(x\)</span> 距离最近的点：<span class="math inline">\(|x-u|=\inf_{z\in\overline{C}}|x-z|\)</span>。对任何 <span class="math inline">\(z\in\overline{C}\)</span>，考虑线段 <span class="math inline">\([u,z]\)</span> 上的点与 <span class="math inline">\(x\)</span> 的距离 <span class="math display">\[f(t) = |u + t(z-u) - x|,\quad 0\leqt\leq1.\]</span> <span class="math inline">\(f\)</span> 在 <span class="math inline">\(t=0\)</span> 时取得最小值： <span class="math display">\[ |u-x|^2 \leq |u-x|^2 + 2t(u-x, z-u) +t^2|z-u|^2.\]</span> 即 <span class="math display">\[0\leqt\cdot\left(2(u-x,z-u) + t|z-u|^2\right)\leq 2(u-x,z-u) +t|z-u|^2.\]</span> 令 <span class="math inline">\(t\to0^+\)</span> 可得<span class="math inline">\((u-x,z-u)\geq 0\)</span>。 这个式子对任何<span class="math inline">\(z\in\overline{C}\)</span> 成立，特别地取<span class="math inline">\(z=tu\)</span> 代入有 <span class="math display">\[(1-t)\cdot(u-x, u)\geq0.\]</span> 上式对任何<span class="math inline">\(t\geq0\)</span> 成立必须只能是 <span class="math inline">\((u-x, u)=0\)</span>。于是不等式 <span class="math display">\[(u-x,z-u)\geq 0\]</span> 可以改写为 <span class="math display">\[(u-x,z)\geq0\]</span> 对任何 <span class="math inline">\(z\in\overline{C}\)</span> 成立。而 <span class="math inline">\((u-x,x)=-(u-x,u-x)&lt;0\)</span>。所以 <span class="math inline">\(u-x\)</span> 即为所求的法向量 <span class="math inline">\(n\)</span>。</p></div><p>回到 Tits 锥 <span class="math inline">\(\mathcal{C}\)</span>的讨论上来。由于 <span class="math inline">\(\mathcal{C}\inV^\ast\)</span> 所以 <span class="math inline">\(\mathcal{C}^\ast\inV\)</span>。我们有如下定理：</p><div id="tits-cone-dual" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.3</span>.</span><span class="statement-spah"> </span>Tits 锥 <span class="math inline">\(\mathcal{C}\)</span> 的对偶锥为 <span class="math inline">\(\mathcal{C}^\ast=\bigcap\limits_{w\inW}w(\mathrm{cone}(\Delta))\)</span>。</p></div><p>显然 <span class="math inline">\(\mathrm{cone}(\Delta)\)</span> 是<span class="math inline">\(V\)</span> 中的一个闭凸锥，它在 <span class="math inline">\(V^\ast\)</span> 中的对偶锥正是基本区域的闭包 <span class="math inline">\(\overline{\mathcal{D}}\)</span>： <span class="math display">\[\overline{\mathcal{D}}= \{x\in V^\ast\mid \langle\lambda,\,x\rangle\geq0,\ \forall\lambda\in\mathrm{cone}(\Delta)\}.\]</span></p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>由定理结论可见 Tits 锥的对偶锥同样是 <span class="math inline">\(W\)</span>- 不变的。</p></div><p><strong>证明</strong>：</p><p><span class="math display">\[\begin{align}\mathcal{C}^\ast &amp;=\{v\in V \mid \langle v,\,x\rangle\geq 0 \text{for all } x \in \mathcal{C}\}\\&amp;= \{v\in V \mid \langle v,\,wz\rangle\geq0 \text{ for all }z\in\overline{\mathcal{D}}\text{ and } w \in W\}\\&amp;= \{v\in V \mid \langle w^{-1}v,\,z\rangle\geq0 \text{ for all }v\in\overline{\mathcal{D}}\text{ and } w \in W\}\\&amp;= \{v\in V \mid w^{-1}v\in (\overline{\mathcal{D}})^\ast \text{ forall } w \in W\}\\&amp;\stackrel{(\ast)}{=} \{v\in V \mid w^{-1}v\in \mathrm{cone}(\Delta)\text{ for all } w \in W\}\\&amp;= \{v\in V \mid v\in w(\mathrm{cone}(\Delta)) \text{ for all } w\in W\}.\end{align}\]</span></p><p>其中 <span class="math inline">\((\ast)\)</span> 一步正是将 <a href="#dual-dual-cone" title="定理 3.2">定理 3.2</a> 应用在 <span class="math inline">\(C=\mathrm{cone}(\Delta),\,C^\ast=\overline{\mathcal{D}}\)</span>上得到的。注意我们使用了 <span class="math inline">\(\mathrm{cone}(\Delta)\)</span> 是闭集这一点：<span class="math inline">\(\mathrm{cone}(\Delta)=\overline{\mathrm{cone}(\Delta)}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="tits-cone-dual-pointed" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论3.4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\mathcal{C}^\ast\)</span> 是点锥：<span class="math inline">\(\mathcal{C}^\ast\cap-\mathcal{C}^\ast=\{0\}\)</span>。</p></div><p><strong>证明</strong>：根据 <a href="#tits-cone-dual" title="定理 3.3">定理 3.3</a> 有 <span class="math inline">\(\mathcal{C}^\ast\subset\mathrm{cone}(\Delta)\)</span>，但显然<span class="math inline">\(\mathrm{cone}(\Delta)\cap-\mathrm{cone}(\Delta)=\{0\}\)</span>。<span class="math inline">\(\blacksquare\)</span></p><p>虽然我们得到了上面关于 <span class="math inline">\(\mathcal{C}^\ast\)</span>的刻画，但是它并不好用。我们下面用内积的形式给出 <span class="math inline">\(\mathcal{C}^\ast\)</span> 的一个更好的刻画。</p><div id="dual-cone-dot-neg" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.5</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(v\in\mathrm{cone}(\Delta)\)</span> 满足对任何<span class="math inline">\(\alpha_s\in\Delta\)</span> 有 <span class="math inline">\((v,\alpha_s)\leq0\)</span>，则 <span class="math inline">\(v\in\mathcal{C}^\ast\)</span>。</p></div><p><strong>证明</strong>：只要证明对任何 <span class="math inline">\(w\)</span> 都有 <span class="math inline">\(wv\in\mathrm{cone}(\Delta)\)</span> 即可。对 <span class="math inline">\(l(w)\)</span> 归纳：<span class="math inline">\(l(w)=0\)</span> 的情形是已知，假设结论对小于 <span class="math inline">\(l(w)\)</span> 都成立，对 <span class="math inline">\(l(w)\)</span> 的情形设 <span class="math inline">\(w=w's\)</span>，其中 <span class="math inline">\(l(w')&lt;l(w)\)</span>，则 <span class="math inline">\(w'\alpha_s\in\Phi^+\)</span>。于是</p><p><span class="math display">\[\begin{align}wv &amp;= w'sv\\&amp;=w'(v - 2(v,\alpha_s)\alpha_s)\\&amp;=w'v - 2(v,\alpha_s)w'\alpha_s.\end{align}\]</span></p><p>根据归纳假设 <span class="math inline">\(w'v\in\mathrm{cone}(\Delta)\)</span>，再结合<span class="math inline">\(w'\alpha_s\in\Phi^+\subset\mathrm{cone}(\Delta)\)</span>，所以结论成立。<span class="math inline">\(\blacksquare\)</span></p><div id="dual-cone-nonspace" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.6</span>.</span><span class="statement-spah"> </span>对任何 <span class="math inline">\(u,v\in\mathcal{C}^\ast\)</span> 有 <span class="math inline">\((u,v)\leq 0\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>我是在与 <a href="https://www.maths.usyd.edu.au/u/bobh/">BobHowlett</a> 教授的邮件交流中学到这个结论的。这个证明我相信改进自 <span class="citation" data-cites="Maxwell82">(<a href="#ref-Maxwell82" role="doc-biblioref">Maxwell 1982</a>)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(\Delta\)</span> 构成 <span class="math inline">\(V\)</span> 的一组基，所以任何 <span class="math inline">\(v\in V\)</span> 可以表示为 <span class="math inline">\(\Delta\)</span> 的线性组合：<span class="math inline">\(v = \sum_{s\in S}c_s\alpha_s\)</span>。定义 <span class="math inline">\(S(v)=\sum_{s\in S}c_s\)</span>为所有系数的和。特别地，当 <span class="math inline">\(v\in\mathcal{C}^\ast\subset\mathrm{cone}(\Delta)\)</span>时，每个 <span class="math inline">\(c_s\)</span> 都是非负的，所以 <span class="math inline">\(S(v)\geq0\)</span>。</p><p>用反证法，设 <span class="math inline">\(u,v\in\mathcal{C}^\ast\)</span> 满足 <span class="math inline">\((u,v)&gt;0\)</span>，不妨设 <span class="math inline">\((u,v)=1\)</span>。记 <span class="math inline">\(n=|S|\)</span> 和 <span class="math inline">\(M=S(u)\)</span>。定义</p><p><span class="math display">\[X=\{x\in\mathcal{C}^\ast\mid S(x)\leqS(v) \text{ and $(z,x)\geq1$ for some $z\in\mathcal{C}^\ast$ with$S(z)\leq M$}\}.\]</span></p><p>显然 <span class="math inline">\(v\in X\)</span>。</p><p>记 <span class="math inline">\(\epsilon=2/(nM)\)</span>，我们将证明对任何 <span class="math inline">\(x\in X\)</span>，都存在 <span class="math inline">\(y\in X\)</span> 使得 <span class="math inline">\(S(y)\leq S(x)-\epsilon\)</span>。</p><p>对 <span class="math inline">\(x\in X\)</span>，设 <span class="math inline">\(z=\sum_{s\inS}z_s\alpha_s\in\mathcal{C}^\ast\)</span> 满足 <span class="math inline">\(S(z)\leq M\)</span> 和 <span class="math inline">\((z,x)\geq1\)</span>，则 <span class="math display">\[(z,x)=\sum_{s\in S}z_s(\alpha_s,x)\geq1.\]</span> 所以必有某个 <span class="math inline">\(\alpha_s\)</span> 使得 <span class="math inline">\(z_s(\alpha_s,x)\geq 1/n\)</span>。由于 <span class="math inline">\(z_s\leq S(z)\leq M\)</span>，我们有 <span class="math inline">\((\alpha_s,x)\geq 1/(nz_s)\geq1/(nM)=\epsilon/2\)</span>。</p><p>考察 <span class="math display">\[y=sx=x-2(x,\alpha_s)\alpha_s.\]</span> 由于 <span class="math inline">\(x\in\mathcal{C}^\ast\)</span>以及 <span class="math inline">\(\mathcal{C}^\ast\)</span> 是 <span class="math inline">\(W-\)</span> 不变的所以 <span class="math inline">\(y\in\mathcal{C}^\ast\)</span>。又注意到 <span class="math inline">\(S(y)=S(x)-2(x,\alpha_s)\leqS(x)-\epsilon\)</span>，所以要证明 <span class="math inline">\(y\)</span> 符合要求，只要再找到某个 <span class="math inline">\(z'\in\mathcal{C}^\ast\)</span> 满足 <span class="math inline">\(S(z')\leq M\)</span> 和 <span class="math inline">\((z',y)\geq1\)</span> 即可。</p><p>如果 <span class="math inline">\((z,\alpha_s)&lt;0\)</span>，那么<span class="math inline">\(z'=z\)</span> 就满足要求，因为这时 <span class="math display">\[(z,y)=(z,x-2(x,\alpha_s)\alpha_s)=(z,x)-2\underbrace{(x,\alpha_s)}_{\geq\epsilon/2}\underbrace{(z,\alpha_s)}_{&lt;0}&gt;(z,x)\geq1.\]</span></p><p>反之如果 <span class="math inline">\((z,\alpha_s)&gt;0\)</span>，我们来验证 <span class="math inline">\(z'=sz=z-2(z,\alpha_s)\alpha_s\)</span>满足要求：由于 <span class="math inline">\(z\in\mathcal{C}^\ast\)</span>所以 <span class="math inline">\(z'\in\mathcal{C}^\ast\)</span>，并且 <span class="math inline">\(S(z')=S(z)-2(z,\alpha_s)&lt;S(z)\)</span>，以及<span class="math display">\[(z', y)=(sz,sx)=(z,x)\geq1.\]</span></p><p>所以从 <span class="math inline">\(v=x\)</span>开始出发，我们经过有限次后取到 <span class="math inline">\(y\inX\)</span> 使得 <span class="math inline">\(S(y)\)</span> 是负数，这与<span class="math inline">\(y\in\mathcal{C}^\ast\)</span> 矛盾。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Howlett-note" class="csl-entry" role="listitem">Howlett, Robert B. 1996. <span>“Introduction to Coxeter Groups.”</span><a href="https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html">https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html</a>.</div><div id="ref-Maxwell82" class="csl-entry" role="listitem">Maxwell, George. 1982. <span>“Sphere Packings and Hyperbolic ReflectionGroups.”</span> <em>Journal of Algebra</em> 79 (1): 78–97. <a href="https://doi.org/10.1016/0021-8693(82)90318-0">https://doi.org/10.1016/0021-8693(82)90318-0</a>.</div></div>]]></content>
    
    
    <summary type="html">
&lt;p&gt;本文主要参考了 Bob Howlett 教授的讲义 &lt;span class=&quot;citation&quot; data-cites=&quot;Howlett-note&quot;&gt;(&lt;a href=&quot;#ref-Howlett-note&quot; role=&quot;doc-biblioref&quot;&gt;Howlett 1996&lt;/a&gt;)&lt;/span&gt;。&lt;/p&gt;
&lt;h1 id=&quot;tits-锥&quot;&gt;Tits 锥&lt;/h1&gt;
&lt;p&gt;在获得了 &lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt;
中关于根系的一些知识后，我们下面转移到 &lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt; 的对偶空间 &lt;span class=&quot;math inline&quot;&gt;&#92;(V^&#92;ast&#92;)&lt;/span&gt; 中讨论万花筒的结构。&lt;/p&gt;</summary>
    
    
    
    <category term="Coxeter Groups" scheme="https://pywonderland.com/categories/Coxeter-Groups/"/>
    
    
  </entry>
  
  <entry>
    <title>Coxeter 群笔记（二）：根系</title>
    <link href="https://pywonderland.com/coxeter-groups-root-system/"/>
    <id>https://pywonderland.com/coxeter-groups-root-system/</id>
    <published>2021-12-04T16:00:00.000Z</published>
    <updated>2025-02-28T13:25:46.924Z</updated>
    
    <content type="html"><![CDATA[<p>我们先回顾 <a href="/coxeter-groups-geometric-realization/">第一篇笔记</a>的主要内容。</p><p>设 <span class="math inline">\((W,S)\)</span> 是一个 Coxeter 系。在<a href="/coxeter-groups-geometric-realization/">上文</a>中，我们按照如下方式，将 <span class="math inline">\((W,S)\)</span>表示为一个实向量空间 <span class="math inline">\(V\)</span>上的正交反射群：</p><ol type="1"><li>取一个 <span class="math inline">\(n=|S|\)</span> 维实向量空间 <span class="math inline">\(V\)</span>，<span class="math inline">\(V\)</span>的一组基为 <span class="math inline">\(\{\alpha_s\mid s\inS\}\)</span>；</li><li>规定了 <span class="math inline">\(V\)</span> 上的内积 <span class="math inline">\((\cdot,\cdot)\)</span>；</li><li>对每个生成元 <span class="math inline">\(s\in S\)</span>，规定 <span class="math inline">\(s\)</span> 在 <span class="math inline">\(V\)</span> 上的作用为关于 <span class="math inline">\(\alpha_s\)</span> 的反射 <span class="math inline">\(\rho_s\)</span>；</li><li>我们证明了 <span class="math inline">\(\rho\)</span> 是从 <span class="math inline">\(W\to\mathrm{O}(V)\)</span> 的群同态。</li></ol><p>但是我们还有一个未完成的工作：证明 <span class="math inline">\(\rho\)</span>是同构。本文会完成它。此外我还会介绍关于根系的一些知识。如果你直接翻到本文后面，会发现我罗列了很多关于根系的推论。这并不是我在故故意掉书袋，这些推论每一条后面都会用到。不过读者初次阅读时只要大致浏览它们即可，等后面用到时再跳转过来查看细节。</p><span id="more"></span><h1 id="根系">根系</h1><p>记 <span class="math inline">\(\Delta=\{\alpha_s\mid s\inS\}\)</span> 是如前所取的 <span class="math inline">\(V\)</span>的一组基。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span><span class="statement-spah"> </span>我们称集合 <span class="math display">\[\Phi=W\cdot\Delta=\{w\alpha_s\mid w\in W, \,\alpha_s\in\Delta\}\]</span> 为 <span class="math inline">\((W,S)\)</span> 的<strong>根系</strong>，任何 <span class="math inline">\(\lambda\in\Phi\)</span>叫做根向量，简称为<strong>根</strong>。<span class="math inline">\(\Delta\)</span> 叫做<strong>单根系</strong>，<span class="math inline">\(\Delta\)</span>中的元素叫做<strong>单根</strong>。</p></div><p>一个简单观察是，任何 <span class="math inline">\(\lambda\in\Phi\)</span> 都是内积 <span class="math inline">\((\cdot,\cdot)\)</span> 下的单位向量：设 <span class="math inline">\(\lambda=w\alpha_s,\,w\inW,\alpha_s\in\Delta\)</span>。由于 <span class="math inline">\(w\)</span> 保持 <span class="math inline">\((\cdot,\cdot)\)</span>，所以 <span class="math display">\[(\lambda,\lambda) =(w\alpha_s,w\alpha_s)=(\alpha_s,\alpha_s)=1.\]</span></p><p>紧跟着的另一个简单观察是，如果两个根 <span class="math inline">\(\alpha,\beta\in\Phi\)</span> 共线则必有 <span class="math inline">\(\alpha=\pm\beta\)</span>。这是因为设 <span class="math inline">\(\alpha=k\beta,\,k\in\mathbb{R}\)</span>，利用<span class="math inline">\(\alpha,\beta\)</span> 都是单位向量可得 <span class="math display">\[1=(\alpha,\alpha)=k^2(\beta,\beta)=k^2.\]</span>所以 <span class="math inline">\(k\in\pm1\)</span>。</p><p>由于 <span class="math inline">\(\Delta\)</span> 构成 <span class="math inline">\(V\)</span> 的一组基，所以 <span class="math inline">\(\Phi\)</span> 中任何根 <span class="math inline">\(\lambda\)</span> 都是单根的线性组合： <span class="math display">\[\lambda = \sum_{s\in S}c_s\alpha_s,\quadc_s\in\mathbb{R}.\]</span> 如果上面的所有系数 <span class="math inline">\(c_s\)</span> 都非负，就称 <span class="math inline">\(\lambda\)</span>是<strong>正根</strong>；若所有系数 <span class="math inline">\(c_s\)</span> 都非正，就称 <span class="math inline">\(\lambda\)</span>是<strong>负根</strong>。正根和负根组成的集合分别记作 <span class="math inline">\(\Phi^+\)</span> 和 <span class="math inline">\(\Phi^-\)</span>。显然 <span class="math inline">\(\Phi^+\cap\Phi^-=\emptyset\)</span>。</p><p>这就引出了一个问题：每个根都必然是正根或者负根吗？即是否有 <span class="math inline">\(\Phi=\Phi^+\cup\Phi^-\)</span>成立？虽然答案是肯定的，但这并不显然。为此我们需要一个关键引理。这个引理的证明有点长，但是它非常重要，Coxeter群的几乎所有性质的证明多少都会用到它。在引入它之前，我们需要做一点小小的准备。</p><p>设 <span class="math inline">\(I\subseteq S\)</span> 是 <span class="math inline">\(S\)</span> 的子集，<span class="math inline">\(I\)</span> 中的生成元在 <span class="math inline">\((W,S)\)</span> 中生成一个子群 <span class="math inline">\(W_I \leqslant (W,S)\)</span>，<span class="math inline">\(W_I\)</span> 叫做<strong>标准椭圆子群</strong>。记<span class="math inline">\(l_I(\cdot)\)</span> 是 <span class="math inline">\(W_I\)</span> 上的长度函数，则显然对任何 <span class="math inline">\(w\in W_I\)</span> 有 <span class="math inline">\(l(w)\leq l_I(w)\)</span> 成立（因为 <span class="math inline">\(W_I\)</span> 中的既约表示放到 <span class="math inline">\(W\)</span> 里可能进一步缩短）。我们后面会看到<span class="math inline">\(l_I=l\mid_{W_I}\)</span>，但现在我们暂时还证明不了它。</p><p>现在请出我们的重要引理：</p><div id="key-lemma" class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理1.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(s\in S,\, w\in W\)</span>，则</p><ol type="1"><li><span class="math inline">\(l(ws) &gt; l(w)\)</span> 当且仅当 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>。</li><li><span class="math inline">\(l(ws) &lt; l(w)\)</span> 当且仅当 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>。</li></ol></div><p><strong>证明</strong>：这里 1 和 2 是等价的：如果 1 成立，则</p><p><span class="math display">\[\begin{align*}l(ws)&lt;l(w)&amp;\Leftrightarrow l((ws)s) &gt; l(ws)\\&amp;\Leftrightarrow ws(\alpha_s)\in\Phi^+\\&amp;\Leftrightarrow w(-\alpha_s)\in\Phi^+\\&amp;\Leftrightarrow w\alpha_s\in\Phi^-.\end{align*}\]</span></p><p>所以只需要证明 1 即可。</p><p>我们先证明充分性：若 <span class="math inline">\(l(ws)&gt;l(w)\)</span> 则 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>。</p><p>对 <span class="math inline">\(l(w)\)</span> 归纳：<span class="math inline">\(l(w)=0\)</span> 时 <span class="math inline">\(w=1\)</span>，结论显然成立。下面设结论对所有长度小于<span class="math inline">\(l(w)\)</span> 的元素成立。</p><p>我们总是可以取 <span class="math inline">\(t\in S\)</span> 使得 <span class="math inline">\(l(wt)&lt;l(w)\)</span>，比如 <span class="math inline">\(t\)</span> 取为 <span class="math inline">\(w\)</span> 的某个既约表达式的最后一项。显然 <span class="math inline">\(t\ne s\)</span>，因为 <span class="math inline">\(l(ws)&gt;l(w)\)</span>。令 <span class="math inline">\(I=\{s,t\}\)</span>，定义 <span class="math display">\[A = \{(x,x_I)\in W\times W_I\midw=xx_I,\,l(w)=l(x)+l_I(x_I)\}.\]</span> 由于 <span class="math inline">\((wt,t)\in A\)</span> 所以 <span class="math inline">\(A\)</span> 非空。取 <span class="math inline">\((v,v_I)\in A\)</span> 使得 <span class="math inline">\(l(v)\)</span> 是最小的，则 <span class="math display">\[l(v)\leq l(wt)=l(w)-1.\]</span> 我们断言对任何<span class="math inline">\(u\in I\)</span> 都有 <span class="math inline">\(l(vu)&gt;l(v)\)</span>。若不然，则 <span class="math inline">\(l(vu)=l(v)-1\)</span>，于是 <span class="math display">\[\begin{align*}l(w)&amp;=l(vu\cdot uv_I)\leq l(vu) + l(uv_I) = (l(v) -1) + l(uv_I)\\&amp;\leq (l(v) -1) + l_I(uv_I)\\&amp;\leq (l(v) -1) + (l_I(v_I) + 1)\\&amp; = l(v) + l_I(v_I)=l(w).\end{align*}\]</span> 于是所有的不等号都是等式，从而 <span class="math inline">\((vu,uv_I)\in A\)</span>，但这与 <span class="math inline">\((v,v_I)\)</span> 的选择矛盾。所以不论 <span class="math inline">\(u=s\)</span> 或是 <span class="math inline">\(u=t\)</span> 都有 <span class="math inline">\(l(vu)&gt;l(v)\)</span>。</p><p>由于 <span class="math inline">\(l(v)\leq l(w)-1\)</span>所以根据归纳假设 <span class="math inline">\(v\alpha_s,\,v\alpha_t\)</span>都是正根。如果我们能够证明 <span class="math inline">\(v_I\alpha_s\)</span> 是 <span class="math inline">\(\alpha_s\)</span> 和 <span class="math inline">\(\alpha_t\)</span> 的非负线性组合：<span class="math display">\[v_I\alpha_s = a\alpha_s + b\alpha_t,\quada,\,b\geq0.\]</span> 则 <span class="math display">\[w\alpha_s=vv_I\alpha_s=v(a\alpha_s +b\alpha_t)=av\alpha_s + bv\alpha_t\in\Phi^+.\]</span>这就证明了结论。</p><p>首先注意到 <span class="math inline">\(v_I\in W_I\)</span>的任何既约表示都是 <span class="math inline">\(s,t\)</span>的交错乘积，而且不能以 <span class="math inline">\(s\)</span> 结尾，否则<span class="math inline">\(l_I(v_Is)=l_I(v_I)-1\)</span>，从而 <span class="math display">\[l(ws)=l(vv_Is)\leq l(v) + l(v_Is)\leql(v)+l_I(v_Is)=l(v)+l_I(v_I)-1=l(w)-1.\]</span> 这与 <span class="math inline">\(l(ws) &gt; l(w)\)</span> 矛盾！</p><p>于是 <span class="math inline">\(v_I\)</span> 形如 <span class="math inline">\(v_I=st\cdots t\)</span> 或者 <span class="math inline">\(v_I=ts\cdots t\)</span>，问题归结为分析这样的<span class="math inline">\(v_I\)</span> 在 <span class="math inline">\(\alpha_s\)</span> 上的作用。这个我们已经在 <a href="/coxeter-groups-geometric-realization#rank2-roots">前一篇文章中计算过了</a>：</p><ol type="1"><li><p><span class="math inline">\(m=m_{s,t}&lt;\infty\)</span>时，<span class="math display">\[\alpha_s\xrightarrow{\ t\ }\dfrac{\sin\theta}{\sin\theta}\alpha_s+\dfrac{\sin2\theta}{\sin\theta}\alpha_t\xrightarrow{\ s\ }\dfrac{\sin3\theta}{\sin\theta}\alpha_s+\dfrac{\sin2\theta}{\sin\theta}\alpha_t\xrightarrow{\ t\ }\cdots\]</span> 其中<span class="math inline">\(\theta=\pi/m\)</span>。这个链的第 <span class="math inline">\(k\)</span> 项形如 <span class="math display">\[\begin{cases}\dfrac{\sin k\theta}{\sin\theta}\alpha_s + \dfrac{\sin(k-1)\theta}{\sin\theta}\alpha_t, &amp; \text{$k$ odd},\\\newline\dfrac{\sin (k-1)\theta}{\sin\theta}\alpha_s + \dfrac{\sink\theta}{\sin\theta}\alpha_t, &amp; \text{$k$ even}.\end{cases}\]</span> 看起来并不是每一项都是 <span class="math inline">\(\alpha_s,\alpha_t\)</span>的非负线性组合，但是它的前 <span class="math inline">\(m\)</span>项确实都是 <span class="math inline">\(\alpha_s,\alpha_t\)</span>的非负线性组合，这就足够了：由于 <span class="math inline">\(v_I\)</span> 的任何既约表示不能以 <span class="math inline">\(s\)</span> 结尾，所以 <span class="math inline">\(v_I\)</span> 可能的取值是二面体群 <span class="math inline">\(D_m\)</span> 中所有长度小于 <span class="math inline">\(m\)</span> 且以 <span class="math inline">\(t\)</span> 结尾的那些元素： <span class="math display">\[1,\ t,\ st,\ \ldots,\ \overbrace{\ast\cdotsst}^{m-1},\]</span> 这些元素作用在 <span class="math inline">\(\alpha_s\)</span> 上正好给出序列的前 <span class="math inline">\(m\)</span> 项。</p><p>为什么 <span class="math inline">\(v_I\)</span> 的长度不能等于 <span class="math inline">\(m\)</span>？因为根据辫关系 <span class="math display">\[\overbrace{sts\cdots}^{m_{s,t}}=\overbrace{tst\cdots}^{m_{s,t}}.\]</span>即 <span class="math inline">\(v_I\)</span> 会等于以 <span class="math inline">\(s\)</span> 结尾的另一个既约表示，与 <span class="math inline">\(v_I\)</span> 的任何既约表示不能以 <span class="math inline">\(s\)</span> 结尾矛盾。</p></li></ol><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>以 <span class="math inline">\(m=5\)</span> 为例，所有 <span class="math inline">\(m\)</span> 个正根都位于 <span class="math inline">\(\alpha_s,\alpha_t\)</span> 张成的楔形区域内：</p><figure><img src="/images/coxeter/finite2d.svg" width="400" alt="m=5 的例子"><figcaption aria-hidden="true"><span class="math inline">\(m=5\)</span>的例子</figcaption></figure><p>从 <span class="math inline">\(\alpha_s\)</span>一侧开始，这些正根形如 <span class="math display">\[\dfrac{\sink\theta}{\sin\theta}\alpha_s+\dfrac{\sin(k-1)\theta}{\sin\theta}\alpha_t,\quad k=1,2,\ldots,m.\]</span> 从 <span class="math inline">\(\alpha_t\)</span> 一侧开始，它们形如 <span class="math display">\[\dfrac{\sin(k-1)\theta}{\sin\theta}\alpha_s+\dfrac{\sink\theta}{\sin\theta}\alpha_t,\quad k=1,2,\ldots,m.\]</span> 当 <span class="math inline">\(k\)</span> 跑遍 <span class="math inline">\(1,\ldots,m\)</span> 时，第一个序列从 <span class="math inline">\(\alpha_s\)</span> 开始过渡到 <span class="math inline">\(\alpha_t\)</span>，第二个序列从 <span class="math inline">\(\alpha_t\)</span> 开始过渡到 <span class="math inline">\(\alpha_s\)</span>。它们最接近的位置是在 <span class="math inline">\(k=\lfloor(m+1)/2\rfloor\)</span> 处（<span class="math inline">\(m\)</span> 为奇数时重合）。这两个序列的前 <span class="math inline">\(\lfloor(m+1)/2\rfloor\)</span>项合起来正好给出全部 <span class="math inline">\(m\)</span> 个正根。这<span class="math inline">\(m\)</span> 个正根可以通过将 <span class="math inline">\(1,t,st,\ldots,\overbrace{\ast\cdotsst}^{m-1}\)</span> 这 <span class="math inline">\(m\)</span>个元素作用在 <span class="math inline">\(\alpha_s\)</span> 上得到。</p></div><ol start="2" type="1"><li><span class="math inline">\(m=m_{s,t}=\infty\)</span> 时，仍然记<span class="math inline">\(\cosh\theta=a_{s,t},\,\theta\geq0\)</span>，则<span class="math display">\[\alpha_s\xrightarrow{\ t\ }\dfrac{\sinh\theta}{\sinh\theta}\alpha_s+\dfrac{\sinh2\theta}{\sinh\theta}\alpha_t\xrightarrow{\ s\ }\dfrac{\sinh3\theta}{\sinh\theta}\alpha_s+\dfrac{\sinh2\theta}{\sinh\theta}\alpha_t\xrightarrow{\ t\ }\cdots\]</span>每一项都是 <span class="math inline">\(\alpha_s,\alpha_t\)</span>的非负线性组合。</li></ol><p>当 <span class="math inline">\(\theta=0\)</span> 时，<span class="math inline">\(W_{s,t}\)</span>是一维直线上两个平行镜面生成的（仿射）反射群（包含了平移），它可以处理成二维平面上的线性反射群：</p><p><img src="/images/coxeter/affine2d.svg" class="fig" width="500"></p><p>当 <span class="math inline">\(\theta&gt;0\)</span> 时，<span class="math inline">\(W_{s,t}\)</span>是双曲空间中两个超平行的镜面生成的双曲反射群，它也可以处理成二维平面上的线性反射群：</p><p><img src="/images/coxeter/hyperbolic2d.svg" class="fig" width="400"></p><p>必要性的证明：</p><p>我们要证明若 <span class="math inline">\(w\alpha_s\in\Phi^+\)</span>则 <span class="math inline">\(l(ws)&gt;l(w)\)</span>。若不然，则 <span class="math inline">\(l(w)=l(wss)&gt;l(ws)\)</span>，从而由充分性的证明知道<span class="math inline">\(ws\alpha_s\in\Phi^+\)</span>，即 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>，矛盾！至此关键引理得证。<span class="math inline">\(\blacksquare\)</span></p><p>从 <a href="#key-lemma" title="引理 1.2">引理 1.2</a>出发我们可以得到许多重要推论：</p><div id="faithful" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.3</span>.</span><span class="statement-spah"> </span>如果 <span class="math inline">\(w\in W\)</span> 满足对任何 <span class="math inline">\(v\in V\)</span> 有 <span class="math inline">\(wv=v\)</span> 则 <span class="math inline">\(w=1\)</span>。即表示 <span class="math inline">\(\rho: W\to{\rm GL}(V)\)</span> 是忠实的。</p></div><p><strong>证明</strong>：若 <span class="math inline">\(w\ne1\)</span>，则存在 <span class="math inline">\(s\in S\)</span> 使得<span class="math inline">\(l(ws)&lt;l(w)\)</span>，从而 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>，这与 <span class="math inline">\(w\alpha_s=\alpha_s\)</span> 矛盾。<span class="math inline">\(\blacksquare\)</span></p><div id="pos-neg" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.4</span>.</span><span class="statement-spah"></span>每个根不是正根就是负根，即 <span class="math inline">\(\Phi=\Phi^+\cup\Phi^-\)</span>。</p></div><p><strong>证明</strong>：由 <span class="math inline">\(\Phi\)</span>的定义任何 <span class="math inline">\(\lambda\in\Phi\)</span>可以表示为 <span class="math inline">\(\lambda=w\alpha_s\)</span>。若<span class="math inline">\(l(ws)&gt;l(w)\)</span> 则 <span class="math inline">\(\lambda\in\Phi^+\)</span>，否则 <span class="math inline">\(\lambda\in\Phi^-\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="simple-ref" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.5</span>.</span><span class="statement-spah"> </span>任何单反射 <span class="math inline">\(s\)</span> 置换 <span class="math inline">\(\Phi^+\setminus\{\alpha_s\}\)</span>中的正根，同时将 <span class="math inline">\(\alpha_s\)</span> 变为<span class="math inline">\(-\alpha_s\)</span>。</p></div><p><strong>证明</strong>：这是因为对任何正根 <span class="math inline">\(\lambda\ne\alpha_s\in\Phi^+\)</span>，<span class="math inline">\(\lambda\)</span> 不可能与 <span class="math inline">\(\alpha_s\)</span> 共线，所以其作为单根的线性组合<span class="math inline">\(\lambda=\sum_{t\in S}c_t\alpha_t\)</span>中必有某个 <span class="math inline">\(t\ne s\)</span> 使得 <span class="math inline">\(c_t&gt;0\)</span>，于是 <span class="math inline">\(s\lambda=\lambda-2(\lambda,\alpha_s)\alpha_s\)</span>的 <span class="math inline">\(\alpha_t\)</span>分量保持不动仍然为正，从而根据 <a href="#pos-neg" title="推论 1.4">推论1.4</a> <span class="math inline">\(s\lambda\)</span>必须仍然是正根。<span class="math inline">\(\blacksquare\)</span></p><div id="lw-nw" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.6</span>.</span><span class="statement-spah"> </span>对 <span class="math inline">\(w\in W\)</span>，定义 <span class="math inline">\(N(w)\)</span> 为被 <span class="math inline">\(w\)</span> 变成负根的那些正根组成的集合： <span class="math display">\[N(w)=\{\lambda\in\Phi^+\midw\lambda\in\Phi^-\}.\]</span> 则 <span class="math inline">\(|N(w)|=l(w)\)</span>。</p></div><p><strong>证明</strong>：对 <span class="math inline">\(l(w)\)</span>归纳。<span class="math inline">\(l(w)=0\)</span> 时 <span class="math inline">\(w=1\)</span>，结论成立。下设 <span class="math inline">\(l(w)&gt;0\)</span> 且结论对长度小于 <span class="math inline">\(l(w)\)</span> 的元素成立。取 <span class="math inline">\(s\in S\)</span> 使得 <span class="math inline">\(w=w's\)</span> 且 <span class="math inline">\(l(w')&lt;l(w)\)</span>。由 <a href="#key-lemma" title="引理 1.2">引理 1.2</a>，<span class="math inline">\(\alpha_s\in N(w)\)</span> 但是 <span class="math inline">\(\alpha_s\notin N(w')\)</span>。对任何正根<span class="math inline">\(\lambda\ne\alpha_s\)</span>，<span class="math inline">\(s\lambda\)</span> 仍然是正根。由恒等式 <span class="math display">\[w'\lambda\in\Phi^- \Leftrightarroww(s\lambda)\in\Phi^-\]</span> 可得 <span class="math inline">\(\lambda\leftrightarrow s\lambda\)</span> 给出了<span class="math inline">\(N(w')\)</span> 和 <span class="math inline">\(N(w)\setminus\{\alpha_s\}\)</span>之间的一一对应，即 <span class="math display">\[N(w)=s\cdotN(w')\cup\{\alpha_s\}.\]</span> 从而由归纳假设 <span class="math display">\[|N(w)|=|N(w')|+1=l(w')+1=l(w).\]</span><span class="math inline">\(\blacksquare\)</span></p><div id="nw-zero-means-identity" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.7</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(w\in W\)</span> 满足 <span class="math inline">\(w(\Phi^+)\subseteq\Phi^+\)</span>，则 <span class="math inline">\(w=1\)</span>。</p></div><p><strong>证明</strong>：根据 <a href="#lw-nw" title="推论 1.6">推论1.6</a> 有 <span class="math inline">\(l(w)=|N(w)|=0\)</span>，从而<span class="math inline">\(w=1\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="w-phi-both-finite-infinite" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.8</span>.</span><span class="statement-spah"> </span><span class="math inline">\(|W|&lt;\infty\)</span> 当且仅当 <span class="math inline">\(|\Phi|&lt;\infty\)</span>。</p></div><p><strong>证明</strong>：如果 <span class="math inline">\(W\)</span>是有限群，由于 <span class="math inline">\(\Phi=W\cdot\Delta\)</span>，<span class="math inline">\(|\Phi|\leq |W|\cdot|\Delta|\)</span> 也是有限的。</p><p>反之若 <span class="math inline">\(|\Phi|&lt;\infty\)</span>，由于<span class="math inline">\(W\)</span> 保持 <span class="math inline">\(\Phi\)</span> 不变，所以 <span class="math inline">\(W\)</span> 置换地作用在 <span class="math inline">\(\Phi\)</span> 上，即有 <span class="math inline">\(W\)</span> 到置换群 <span class="math inline">\(S_{|\Phi|}\)</span> 的同态 <span class="math inline">\(W\xrightarrow{\varphi} S_{|\Phi|}\)</span>。<a href="#nw-zero-means-identity" title="推论 1.7">推论 1.7</a> 说明 <span class="math inline">\(\varphi\)</span> 是嵌入，从而 <span class="math inline">\(W\)</span> 也是有限的。<span class="math inline">\(\blacksquare\)</span></p><div id="longest" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.9</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(W\)</span> 是一个有限群，则存在唯一的元素 <span class="math inline">\(w_0\)</span>，<span class="math inline">\(w_0\)</span> 是 <span class="math inline">\(W\)</span> 中长度最大者，它交换 <span class="math inline">\(\Phi^+\)</span> 和 <span class="math inline">\(\Phi^-\)</span>：<span class="math inline">\(w_0(\Phi^+)=\Phi^-\)</span>，且 <span class="math inline">\(w_0\)</span> 是一个对合：<span class="math inline">\(w_0^2=1\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(W\)</span>有限所以存在一个长度最大的元素 <span class="math inline">\(w_0\)</span>，对任何 <span class="math inline">\(s\in S\)</span> 只能有 <span class="math inline">\(l(w_0s)&lt;l(w)\)</span>，从而 <span class="math inline">\(w_0\alpha_s\in\Phi^-\)</span>，从而 <span class="math inline">\(w_0\)</span> 把 <span class="math inline">\(\Phi^+\)</span> 变为 <span class="math inline">\(\Phi^-\)</span>。</p><p>进一步 <span class="math inline">\(w_0^2\)</span> 仍然把 <span class="math inline">\(\Phi^+\)</span> 映射为 <span class="math inline">\(\Phi^+\)</span>，所以由 <a href="#nw-zero-means-identity" title="推论 1.7">推论 1.7</a> <span class="math inline">\(w_0^2=1\)</span>，因此 <span class="math inline">\(w_0\)</span> 是一个对合。</p><p>如果存在 <span class="math inline">\(w_1\ne w_0\)</span> 使得 <span class="math inline">\(l(w_1)=l(w_0)\)</span> 的话，则 <span class="math inline">\(w_1\)</span> 也满足 <span class="math inline">\(w_1(\Phi^+)=\Phi^-\)</span>，从而 <span class="math inline">\(w_0^{-1}w_1\)</span> 保持 <span class="math inline">\(\Phi^+\)</span> 不变，根据 <a href="#nw-zero-means-identity" title="推论 1.7">推论 1.7</a> 有 <span class="math inline">\(w_0^{-1}w_1=1\)</span>，即 <span class="math inline">\(w_0=w_1\)</span>。所以这样的 <span class="math inline">\(w_0\)</span> 是唯一的。<span class="math inline">\(\blacksquare\)</span></p><div id="remain-positive-root" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.10</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(I\subsetneqq S\)</span> 是真子集，<span class="math inline">\(\lambda\in \Phi^+\setminus\Phi^+_I\)</span>是正根，则对任何 <span class="math inline">\(w\in W_I\)</span>，<span class="math inline">\(w\lambda\)</span> 仍然是正根。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(w\)</span> 是<span class="math inline">\(I\)</span> 中生成元的乘积，所以 <span class="math inline">\(w\lambda\)</span> 是 <span class="math inline">\(\lambda\)</span> 和 <span class="math inline">\(\{\alpha_t\mid t\in I\}\)</span>中向量的线性组合： <span class="math display">\[w\lambda=\lambda +\sum_{t\in I}c_t\alpha_t.\]</span> <span class="math inline">\(\lambda\in\Phi^+\setminus\Phi^+_I\)</span> 说明将<span class="math inline">\(\lambda\)</span>表示为单根的线性组合时，其至少有一项 <span class="math inline">\(\alpha_s\,(s\notin I)\)</span> 的系数大于 0，从而<span class="math inline">\(w\lambda\)</span> 的 <span class="math inline">\(\alpha_s\)</span> 项的系数也大于 0，所以 <span class="math inline">\(w\lambda\)</span> 必然是正根。<span class="math inline">\(\blacksquare\)</span></p><div id="lI-equals-l" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论1.11</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(w\in W_I\)</span>，则对 <span class="math inline">\(w\)</span> 的任何既约表示 <span class="math inline">\(w=s_1\cdots s_k\)</span> 都有 <span class="math inline">\(s_1,\ldots,s_k\in I\)</span>，特别地 <span class="math inline">\(l_I(w)=l(w)\)</span>。</p></div><p><strong>证明</strong>：我们从右到左依次验证 <span class="math inline">\(s_k,\ldots,s_1\in I\)</span>。记 <span class="math inline">\(s=s_k\)</span>，由于 <span class="math inline">\(l(ws)&lt;l(w)\)</span> 所以 <span class="math inline">\(w\alpha_s\in\Phi^-\)</span>。又由于 <span class="math inline">\(w\in W_I\)</span> 所以 <span class="math inline">\(w\alpha_s\)</span> 是 <span class="math inline">\(\alpha_s\)</span> 和一些 <span class="math inline">\(\{\alpha_t\mid t\in I\}\)</span> 的线性组合：<span class="math display">\[w\alpha_s=\alpha_s+\sum_{t\in I}c_t\alpha_t.\]</span> 由于 <span class="math inline">\(w\alpha_s&lt;0\)</span> 所以必然有某个 <span class="math inline">\(t\in I\)</span> 使得 <span class="math inline">\(s=t\)</span>，即 <span class="math inline">\(s\inI\)</span>。对 <span class="math inline">\(ws=s_1\cdots s_{k-1}\inW_I\)</span> 重复此论证即得每个 <span class="math inline">\(s_i\inI\)</span>。<span class="math inline">\(\blacksquare\)</span></p>]]></content>
    
    
    <summary type="html">
&lt;p&gt;我们先回顾 &lt;a href=&quot;/coxeter-groups-geometric-realization/&quot;&gt;第一篇笔记&lt;/a&gt;
的主要内容。&lt;/p&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;&#92;((W,S)&#92;)&lt;/span&gt; 是一个 Coxeter 系。在
&lt;a href=&quot;/coxeter-groups-geometric-realization/&quot;&gt;上文&lt;/a&gt;
中，我们按照如下方式，将 &lt;span class=&quot;math inline&quot;&gt;&#92;((W,S)&#92;)&lt;/span&gt;
表示为一个实向量空间 &lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt;
上的正交反射群：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;取一个 &lt;span class=&quot;math inline&quot;&gt;&#92;(n=|S|&#92;)&lt;/span&gt; 维实向量空间 &lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt;
的一组基为 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{&#92;alpha_s&#92;mid s&#92;in
S&#92;}&#92;)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;规定了 &lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt; 上的内积 &lt;span class=&quot;math inline&quot;&gt;&#92;((&#92;cdot,&#92;cdot)&#92;)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;对每个生成元 &lt;span class=&quot;math inline&quot;&gt;&#92;(s&#92;in S&#92;)&lt;/span&gt;，规定 &lt;span class=&quot;math inline&quot;&gt;&#92;(s&#92;)&lt;/span&gt; 在 &lt;span class=&quot;math inline&quot;&gt;&#92;(V&#92;)&lt;/span&gt; 上的作用为关于 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;alpha_s&#92;)&lt;/span&gt; 的反射 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;rho_s&#92;)&lt;/span&gt;；&lt;/li&gt;
&lt;li&gt;我们证明了 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;rho&#92;)&lt;/span&gt; 是从 &lt;span class=&quot;math inline&quot;&gt;&#92;(W&#92;to&#92;mathrm{O}(V)&#92;)&lt;/span&gt; 的群同态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是我们还有一个未完成的工作：证明 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;rho&#92;)&lt;/span&gt;
是同构。本文会完成它。此外我还会介绍关于根系的一些知识。如果你直接翻到本文后面，会发现我罗列了很多关于根系的推论。这并不是我在故故意掉书袋，这些推论每一条后面都会用到。不过读者初次阅读时只要大致浏览它们即可，等后面用到时再跳转过来查看细节。&lt;/p&gt;</summary>
    
    
    
    <category term="Coxeter Groups" scheme="https://pywonderland.com/categories/Coxeter-Groups/"/>
    
    
  </entry>
  
  <entry>
    <title>Coxeter 群笔记（一）：抽象 Coxeter 群与几何实现</title>
    <link href="https://pywonderland.com/coxeter-groups-geometric-realization/"/>
    <id>https://pywonderland.com/coxeter-groups-geometric-realization/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2025-03-03T14:09:49.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抽象-coxeter-群">抽象 Coxeter 群</h1><p>设 <span class="math inline">\(S\)</span> 是一个集合，一个基于 <span class="math inline">\(S\)</span> 的 Coxeter 矩阵 <span class="math inline">\(M=(m_{s,t})_{s,t\in S}\)</span>是一个对称矩阵，其对角线上都是 1，非对角线元素取值范围为 <span class="math inline">\(\{2,3,\ldots,\infty\}\)</span>。<span class="math inline">\(|S|\)</span> 叫做 <span class="math inline">\(M\)</span> 的秩 (rank)。在这个系列中我们只考虑<span class="math inline">\(|S|&lt;\infty\)</span> 的情形。</p><p>矩阵 <span class="math inline">\(M\)</span> 确定了一个有限表现群<span class="math inline">\(W\)</span>，其生成元为集合 <span class="math inline">\(S\)</span>，群表现如下： <span class="math display">\[W = \langle s\in S\ |\ (st)^{m_{s,t}}=1\ {\rmif}\ m_{s,t}&lt;\infty\rangle.\]</span></p><p>即 <span class="math inline">\(S\)</span> 满足的生成关系是：</p><ol type="1"><li>对任何 <span class="math inline">\(s\in S\)</span> 有 <span class="math inline">\(s^2=1\)</span>。</li><li>对任何 <span class="math inline">\(s\ne t\)</span> 且 <span class="math inline">\(m_{s,t}&lt;\infty\)</span>有<strong>辫关系</strong> (braid relation) <span class="math display">\[\overbrace{sts\cdots}^{m_{s,t}}=\overbrace{tst\cdots}^{m_{s,t}}\]</span>成立。（当 <span class="math inline">\(m_{s,t}=\infty\)</span>时的关系是无用的）</li></ol><p>我们称 <span class="math inline">\((W, S)\)</span> 是一个<strong>Coxeter 系</strong>，<span class="math inline">\(W\)</span>是一个<strong>有限生成 Coxeter 群</strong>。</p><span id="more"></span><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>我们总是用 <span class="math inline">\((W,S)\)</span> 来表示一个Coxeter 群。即我们在提到一个 Coxeter 群 <span class="math inline">\(W\)</span> 时需要同时指明 <span class="math inline">\(W\)</span> 的生成元集合 <span class="math inline">\(S\)</span>。这是因为，可能存在不同的生成元集合<span class="math inline">\(S\)</span> 和 <span class="math inline">\(S'\)</span>，它们给出同一个群 <span class="math inline">\(W\)</span>。但是像长度函数 <span class="math inline">\(l(w)\)</span>、Bruhat序这些重要的概念，只有在指定生成元集 <span class="math inline">\(S\)</span> 的前提下才有意义。</p></div><p>用 Coxeter 矩阵或者群表现来描述 Coxeter群还是太不方便了。我们可以用一个有限图 <span class="math inline">\(\Gamma\)</span> 更直观地表示 <span class="math inline">\((W,S)\)</span>，<span class="math inline">\(\Gamma\)</span> 叫做 <span class="math inline">\((W,S)\)</span> 的 <strong>Coxeter图</strong>：</p><ul><li><span class="math inline">\(\Gamma\)</span> 的顶点集是 <span class="math inline">\(S\)</span>。</li><li>如果 <span class="math inline">\(m_{s,t}\ne 2\)</span>，就在顶点<span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span> 之间连一条边，并且给这条边标上记号<span class="math inline">\(m_{s,t}\)</span>。</li><li>但是如果 <span class="math inline">\(m_{s,t}=3\)</span>的话，就省略这个记号不写。</li></ul><p>此外如果 <span class="math inline">\(\Gamma\)</span> 是连通的，就称<span class="math inline">\((W,S)\)</span>是<strong>不可约的</strong>。</p><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>Coxeter 矩阵 <span class="math display">\[\begin{pmatrix}1 &amp;4 &amp; 2\\4&amp;1&amp;3\\2&amp;3&amp;1\end{pmatrix}\]</span> 对应的Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是</p><figure><img src="/images/coxeter/cube43.svg" class="fig" width="120" alt="正方体对称群 (4,3) 的 Coxeter 图，注意标号 3 省略了"><figcaption aria-hidden="true">正方体对称群 <span class="math inline">\((4,3)\)</span> 的 Coxeter 图，注意标号 3省略了</figcaption></figure><p><span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(W\)</span>是不可约的。这个群是三维正方体的对称群：</p><video src="/images/coxeter/cube.mp4" width="300" controls=""></video><p>去掉最后一个顶点，前两个顶点构成二面体群 <span class="math inline">\(D_4\)</span>，对应正方体的每个面是正四边形；去掉第一个顶点，后两个顶点构成二面体群<span class="math inline">\(D_3\)</span>，对应每个顶点处有 3个面相遇。</p></div><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>设 <span class="math inline">\(m\geq4\)</span> 是正整数，Coxeter矩阵 <span class="math display">\[\begin{pmatrix}1 &amp; m &amp;2\\m&amp;1&amp;2\\2&amp;2&amp;1\end{pmatrix}\]</span> 对应的 Coxeter 图<span class="math inline">\(\Gamma\)</span> 是</p><p><img src="/images/coxeter/prism.svg" class="fig" width="120"></p><p><span class="math inline">\(\Gamma\)</span> 有两个连通分支，所以<span class="math inline">\(W\)</span>是可约的。这个群是三维空间中棱柱的对称群，前两个相邻的顶点给出二面体群<span class="math inline">\(D_m\)</span>，它负责在 <span class="math inline">\(xy\)</span> 平面内生成正 <span class="math inline">\(m\)</span> 边形；最后的孤立顶点在 <span class="math inline">\(z\)</span>轴方向上将多边形作反射形成棱柱结构：</p><video src="/images/coxeter/prism-6.mp4" width="300" controls=""></video></div><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>Coxeter 矩阵 <span class="math display">\[\begin{pmatrix}1 &amp;3 &amp; 4\\3&amp;1&amp;\infty\\4&amp;\infty&amp;1\end{pmatrix}\]</span>对应的 Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是</p><figure id="3-4-inf"><img src="/images/coxeter/3-4-inf.svg" width="120" alt="三角形群 \Delta(3,4,\infty) 的 Coxeter 图 \Gamma，注意标号 3 被省略了"><figcaption aria-hidden="true">三角形群 <span class="math inline">\(\Delta(3,4,\infty)\)</span> 的 Coxeter 图 <span class="math inline">\(\Gamma\)</span>，注意标号 <span class="math inline">\(3\)</span> 被省略了</figcaption></figure><p><span class="math inline">\(\Gamma\)</span> 是连通的，所以 <span class="math inline">\(W\)</span>是不可约的。这个群给出的是双曲空间中的密铺：</p><p><img src="/images/coxeter/parallel.png" class="fig" width="250"></p></div><div class="statement example definition unnumbered"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>Coxeter 矩阵 <span class="math display">\[\begin{pmatrix}1 &amp;5 &amp; 2 &amp;2\\5&amp;1&amp;3&amp;2\\2&amp;3&amp;1&amp;4\\2&amp;2&amp;4&amp;1\end{pmatrix}\]</span>对应的 Coxeter 图 <span class="math inline">\(\Gamma\)</span> 是</p><p><img src="/images/coxeter/534.svg" id="534" class="fig" width="180"></p><p><span class="math inline">\(W\)</span>是不可约的。这个群给出的是三维双曲空间中的密铺：</p><p><img src="/images/coxeter/534-1000.jpg" class="fig" width="500"></p><p>去掉最后一个顶点，前三个顶点给出正十二面体的对称群 <span class="math inline">\((5,3)\)</span>，说明这个密铺由正十二面体组成；去掉第一个顶点，剩下三个顶点给出正方体的对称群<span class="math inline">\((3,4)\cong(4,3)\)</span>，说明每个顶点处有 8个正十二面体相遇。</p></div><p>我们主要关心 <span class="math inline">\(\Gamma\)</span>不可约的情形。因为如果 <span class="math inline">\(\Gamma=\Gamma_1\cup\cdots\cup\Gamma_k\,(k&gt;1)\)</span>是多个连通分支的并的话，则对任何 <span class="math inline">\(s\in\Gamma_i\)</span> 和 <span class="math inline">\(t\in\Gamma_j\)</span> 有 <span class="math inline">\(m_{s,t}=2\)</span>，从而 <span class="math inline">\(st=ts\)</span>，于是 <span class="math inline">\(\Gamma_i\)</span> 中的生成元与 <span class="math inline">\(\Gamma_j\)</span> 中的生成元两两交换，这时 <span class="math inline">\(W\)</span> 有直积分解 <span class="math display">\[W=W_1\times\cdots\times W_k.\]</span> 其中 <span class="math inline">\(W_1,\ldots,W_k\)</span> 分别是 <span class="math inline">\(\Gamma_1,\ldots,\Gamma_k\)</span> 对应的 Coxeter群。所以我们只要研究 <span class="math inline">\(\Gamma\)</span>不可约的情形即可。</p><p>还有一种给 <span class="math inline">\(\Gamma\)</span>的边标号的方式，叫做 Vinberg 记号，允许给 <span class="math inline">\(m_{s,t}=\infty\)</span> 的边用 <span class="math inline">\(\leq-1\)</span>的实数作为标号。比如像下面这样：</p><p><img src="/images/coxeter/level2.svg" id="level2" class="fig" width="120"></p><p>作为抽象 Coxeter 群，它和前面的 <a href="#3-4-inf"><span class="math inline">\(\Delta(3,4,\infty)\)</span></a>是同一个群，但是这里 <span class="math inline">\(\infty\)</span>边的标号变成了 <span class="math inline">\(-1.1\)</span>。我后面会解释，Vinberg记号相当于指定了这条边的两个顶点在几何实现中对应的两个镜面的「双曲距离」。在后文介绍Boyd-Maxwell 球堆时，我们也会采用这种记号。</p><p>Coxeter 图除了直观上的好处外，它还能告诉我们一些关于 <span class="math inline">\((W,S)\)</span> 的结构信息。比如当 <span class="math inline">\(\Gamma\)</span> 包含回路，或者有某个顶点的度数<span class="math inline">\(\geq4\)</span> 时，你可以立刻知道 <span class="math inline">\((W,S)\)</span> 一定是无限群 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.2.7</a>)</span>。还有一些更微妙的信息也可以从 <span class="math inline">\(\Gamma\)</span> 中读出来。</p><h1 id="长度函数">长度函数</h1><p>对 <span class="math inline">\(W\)</span> 中的任一元素 <span class="math inline">\(w\)</span>，存在许多种不同的方式将 <span class="math inline">\(w\)</span> 表示为 <span class="math inline">\(S\)</span>中生成元的乘积。在所有这些表示中，长度最短者叫做 <span class="math inline">\(w\)</span> 的<strong>既约表示</strong>：即，如果<span class="math inline">\(w=s_1s_2\cdots s_k\)</span> 是一个长度为<span class="math inline">\(k\)</span> 的表示，且 <span class="math inline">\(w\)</span> 不存在任何长度小于 <span class="math inline">\(k\)</span> 的表示，就称 <span class="math inline">\(s_1s_2\cdots s_k\)</span> 是 <span class="math inline">\(w\)</span> 的既约表示。<span class="math inline">\(w\)</span>的既约表示可能不唯一，但它们都具有相同的长度。定义 <span class="math inline">\(l(w)\)</span> 为 <span class="math inline">\(w\)</span> 的任意一个既约表示的长度。</p><p><span class="math inline">\(l(w)\)</span> 具有如下的性质：</p><ol type="1"><li><span class="math inline">\(l(xy)\leq l(x) + l(y)\)</span>。</li><li><span class="math inline">\(l(w) = l(w^{-1})\)</span>。</li><li><span class="math inline">\(l(w)=0\)</span> 当且仅当 <span class="math inline">\(w=1\)</span>。</li><li><span class="math inline">\(l(ws)=l(w)\pm 1\)</span>，其中 <span class="math inline">\(w\in W, s\in S\)</span>。</li></ol><p>前三点都是显然的，只有 4 需要证明。显然 <span class="math inline">\(|l(ws)-l(w)|\leq 1\)</span>，所以只要说明 <span class="math inline">\(l(ws)\)</span> 和 <span class="math inline">\(l(s)\)</span>不相等即可。这一步需要用到自由群的泛性质：</p><p>设 <span class="math inline">\(F\)</span> 是由集合 <span class="math inline">\(S\)</span> 生成的 <a href="https://en.wikipedia.org/wiki/Free_group">自由群</a>，定义群同态<span class="math inline">\({\rm sgn}: F\to{\pm1}\)</span> 如下：对<span class="math inline">\(F\)</span> 的每个生成元 <span class="math inline">\(s\in S\)</span> 规定 <span class="math inline">\({\rm sgn}(s)=-1\)</span>，然后将此映射扩充为 <span class="math inline">\(F\)</span> 到 <span class="math inline">\({\pm1}\)</span> 的群同态。容易验证 <span class="math inline">\((W,S)\)</span>的所有生成关系都属于这个同态的核，因此根据 <a href="https://en.wikipedia.org/wiki/Free_group#Universal_property">自由群的泛性质</a>，<span class="math inline">\({\rm sgn}\)</span> 诱导了一个从 <span class="math inline">\((W,S)\)</span> 到 <span class="math inline">\({\pm1}\)</span> 的群同态。在此同态下，若 <span class="math inline">\(w=s_1s_2\cdots s_k\)</span> 是 <span class="math inline">\(w\)</span> 的任一既约表示，则 <span class="math display">\[{\rm sgn}(w)={\rm sgn}(s_1){\rmsgn}(s_2)\cdots{\rm sgn}(s_k)=(-1)^k=(-1)^{l(w)}.\]</span> 从而 <span class="math inline">\({\rm sgn}(ws)={\rm sgn}(w){\rm sgn}(s)=-{\rmsgn}(w)\)</span> 说明 <span class="math inline">\(l(ws)\nel(w)\)</span>。</p><h1 id="几何实现">几何实现</h1><p>抽象 Coxeter群是用生成元和生成关系定义的，直接从这种定义出发研究群结构是非常困难的。在这一节中，我们介绍如何将抽象的Coxeter群实现为一个内积空间中的正交反射群，从而可以使用几何、线性代数等多种工具来研究它。</p><p>设 <span class="math inline">\((W,S)\)</span> 是一个 Coxeter系，<span class="math inline">\(M=(m_{s,t})_{s,t\in S}\)</span> 是Coxeter 矩阵，<span class="math inline">\(V\)</span> 是一个维数为 <span class="math inline">\(n=|S|\)</span> 的实向量空间，其一组基为 <span class="math inline">\(\{\alpha_s \mid s\in S\}\)</span>。我们规定 <span class="math inline">\(V\)</span> 上的内积 <span class="math inline">\((\cdot,\cdot)\)</span> 如下：</p><p><span class="math display">\[(\alpha_s,\alpha_t)=\begin{cases}1 &amp; s=t,\\-\cos(\pi/m_{s,t}) &amp; m_{s,t}&lt;\infty,\\-a_{s,t} &amp; m_{s,t}=\infty.\end{cases}\]</span> 这里 <span class="math inline">\(a_{s,t}=a_{t,s}\geq1\)</span> 是实数，它对应的是<span class="math inline">\(\infty\)</span> 边的 Vinberg 记号。不同的<span class="math inline">\(s,t\)</span> 对可以使用不同的 <span class="math inline">\(a_{s,t}\)</span>。</p><p>根据定义 <span class="math inline">\((\alpha_s,\alpha_s)=1\)</span>，即每个 <span class="math inline">\(\alpha_s\)</span> 都是单位向量。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span><span class="math inline">\(a_{s,t}=1\)</span> 表示 Euclidean空间中两个平行的镜面（或者双曲空间中两个平行的镜面）；<span class="math inline">\(a_{s,t}&gt;1\)</span>表示双曲空间中两个超平行的镜面；<span class="math inline">\(2\leqm_{s,t}&lt;\infty\)</span> 表示两个相交的镜面。</p><p>下图显示了对前面的 <a href="#3-4-inf"><span class="math inline">\(\Delta(3,4,\infty)\)</span></a> 群，对标号为 <span class="math inline">\(\infty\)</span> 的边取 <span class="math inline">\(a_{s,t}=1.15\)</span> 时给出的效果：</p><p><img src="/images/coxeter/hypparallel.png" class="fig" width="250"></p><p>你可以看到每个三角形都不再是封闭的，它们的墙壁中有两条「超平行」的测地线，这两条测地线交点落在双曲空间的外面。</p></div><p>内积 <span class="math inline">\((\cdot,\cdot)\)</span> 未必是通常的Euclidean 内积，即它未必是正定的。但我们最关心的情形有三种：</p><ol type="1"><li>如果 <span class="math inline">\((\cdot,\cdot)\)</span>是正定的，就称 <span class="math inline">\((\cdot,\cdot)\)</span>是<strong>有限</strong>型的；</li><li>如果 <span class="math inline">\((\cdot,\cdot)\)</span>是半正定的，但不是正定的，就称 <span class="math inline">\((\cdot,\cdot)\)</span>是<strong>仿射</strong>型的；</li><li>如果 <span class="math inline">\((\cdot,\cdot)\)</span> 的符号是<span class="math inline">\((n-1, 1)\)</span>，就称 <span class="math inline">\((\cdot,\cdot)\)</span>是<strong>双曲</strong>型的。</li></ol><p>不属于以上三种类型的一律称为<strong>不定</strong>的。</p><p>正如名字所暗示的那样，<span class="math inline">\((\cdot,\cdot)\)</span> 是有限型的当且仅当 <span class="math inline">\(W\)</span> 是有限反射群，这时 <span class="math inline">\(W\)</span> 给出的万花筒是球面上的密铺；<span class="math inline">\((\cdot,\cdot)\)</span> 是仿射型的当且仅当 <span class="math inline">\(W\)</span> 可以实现为 Euclidean 空间上的仿射 Weyl群，这时 <span class="math inline">\(W\)</span> 给出的万花筒是 Euclidean空间中的密铺；<span class="math inline">\((\cdot,\cdot)\)</span>是双曲型的意味着 <span class="math inline">\(W\)</span>给出的是双曲空间中的密铺。这些我们会在后面作更详细的讨论。</p><p>给定 <span class="math inline">\(s\in S\)</span>，定义 <span class="math inline">\(V\)</span> 上的反射 <span class="math inline">\(\rho_s\)</span> 为 <span class="math display">\[\rho_s(v) = v -2(v,\alpha_s)\alpha_s ,\quad v\inV.\]</span> 容易验证 <span class="math inline">\(\rho_s\)</span>满足以下几点：</p><ol type="1"><li><span class="math inline">\(\rho_s(\alpha_s)=-\alpha_s\)</span>；</li><li><span class="math inline">\(\rho_s\)</span> 保持超平面 <span class="math inline">\(\{v\in V\mid (v,\alpha_s)=0\}\)</span>上的点不动；</li><li><span class="math inline">\(\rho_s\)</span> 保持 <span class="math inline">\((\cdot,\cdot)\)</span> 不变：<span class="math inline">\((\rho_s(u),\rho_s(v)) = (u,v),\,\forall u,v\inV\)</span>。</li></ol><p>即 <span class="math inline">\(\rho_s\in \mathrm{O}(V)\)</span> 是以<span class="math inline">\(\alpha\)</span> 为法向量的镜面反射。</p><p>我们来证明 <span class="math inline">\(s\to\rho_s\)</span>实际上给出了 <span class="math inline">\((W,S)\)</span> 到 <span class="math inline">\(\mathrm{O}(V)\)</span> 的群同态，从而 <span class="math display">\[\rho: W\to\rho(W)\leqslant\mathrm{O}(V)\]</span>是一个线性表示。为此只要证明 <span class="math inline">\(\{\rho_s\mids\in S\}\)</span> 满足与 <span class="math inline">\((W,S)\)</span>相同的生成关系即可，这样根据商群的泛性质，即得存在群同态 <span class="math inline">\(W\to \langle\,\rho_s\mid s\in S\,\rangle\)</span>将每个 <span class="math inline">\(s\)</span> 被映射到 <span class="math inline">\(\rho_s\)</span>。即我们只要证明：</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题3.1</span>.</span><span class="statement-spah"> </span><span class="math inline">\((\rho_s\rho_t)^{m_{s,t}}=1\)</span> 对任何 <span class="math inline">\(s,t\in S\)</span> 成立。</p></div><p>这个结论的证明在 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, sec.5.3</a>)</span> 和 <span class="citation" data-cites="Howlett-note">Howlett (<a href="#ref-Howlett-note" role="doc-biblioref">1996</a>)</span> 中都可以找到，但我更喜欢 Howlett的做法，把 rank 2情形的根系具体的算出来。这是最简单，但又非平凡的根系的例子，熟悉它的重要性怎么强调也不为过。</p><p><strong>证明</strong>：当 <span class="math inline">\(s=t\)</span>时所证即为 <span class="math inline">\(\rho_s^2=1\)</span>，由于 <span class="math inline">\(\rho_s\)</span> 是反射这当然是成立的。</p><p>下设 <span class="math inline">\(s\ne t\)</span>，令 <span class="math inline">\(V_{s,t}={\rm span}\{\alpha_s,\alpha_t\}\)</span>是 <span class="math inline">\(\alpha_s,\alpha_t\)</span>张成的二维子空间，并记 <span class="math inline">\(V_{s,t}^\bot\)</span>是 <span class="math inline">\(V_{s,t}\)</span> 在 <span class="math inline">\((\cdot,\cdot)\)</span> 下的正交补空间。不难验证<span class="math inline">\(\rho_s\)</span> 和 <span class="math inline">\(\rho_t\)</span> 限制在 <span class="math inline">\(V_{s,t}^\bot\)</span> 上都是恒等变换。</p><p>注意不一定有 <span class="math inline">\(V=V_{s,t}\oplusV_{s,t}^\bot\)</span> 成立，因为 <span class="math inline">\((\cdot,\cdot)\)</span> 有可能是退化的。但是如果<span class="math inline">\((\cdot,\cdot)\)</span> 限制在 <span class="math inline">\(\mid_{V_{s,t}}\)</span> 是非退化的，就有 <span class="math inline">\(V=V_{s,t}\oplus V_{s,t}^\bot\)</span>就成立。这是双线性型的一个基本结论。</p><p>我们来计算 <span class="math inline">\(\sigma=\rho_s\rho_t\)</span>的阶。记 <span class="math inline">\(m=m_{s,t}\)</span>，分情况讨论：</p><div id="rank2-roots" class="plain"></div><ol type="1"><li><p><span class="math inline">\(m&lt;\infty\)</span>。这时 <span class="math inline">\((\cdot,\cdot)\)</span> 限制在 <span class="math inline">\(V_{s,t}\)</span> 上的 Gram 矩阵是 <span class="math display">\[\begin{pmatrix}1&amp;-\cos\theta\\-\cos\theta&amp;1\end{pmatrix},\quad\theta=\frac{\pi}{m}.\]</span> 这个矩阵是正定的，从而 <span class="math inline">\((\cdot,\cdot)\mid_{V_{s,t}}\)</span> 非退化，这时<span class="math inline">\(V=V_{s,t}\oplus V_{s,t}^\bot\)</span>是成立的，而 <span class="math inline">\(\sigma\)</span> 限制在正交补<span class="math inline">\(V_{s,t}^\bot\)</span> 上是恒等变换，所以<span class="math inline">\(\sigma\)</span> 在 <span class="math inline">\(V\)</span> 上的阶就等于它在 <span class="math inline">\(V_{s,t}\)</span>上的阶。为了简化记号（否则我们的表达式会超出页面），令 <span class="math inline">\(a_k=\sin(k\theta)/\sin\theta\)</span>，直接计算不难得到 <span class="math display">\[\begin{align*}&amp;\alpha_s\xrightarrow{\ \rho_t\}a_1\alpha_s+a_2\alpha_t\xrightarrow{\ \rho_s\}a_3\alpha_s+a_2\alpha_t\xrightarrow{\ \rho_t\}a_3\alpha_s+a_4\alpha_t\xrightarrow{\ \rho_s\ }\cdots\\&amp;\alpha_t\xrightarrow{\ \rho_s\}a_2\alpha_s+a_1\alpha_t\xrightarrow{\ \rho_t\}a_2\alpha_s+a_3\alpha_t\xrightarrow{\ \rho_s\}a_4\alpha_s+a_3\alpha_t\xrightarrow{\ \rho_t\ }\cdots\end{align*}\]</span> 这两个链的周期都是 <span class="math inline">\(2m\)</span>，因为它们的第 <span class="math inline">\(2m+1\)</span> 项分别是 <span class="math display">\[a_{2m+1}\alpha_s+a_{2m}\alpha_t=\dfrac{\sin(2m+1)\theta}{\sin\theta}\alpha_s+\dfrac{\sin(2m)\theta}{\sin\theta}\alpha_t=\alpha_s.\]</span> 和 <span class="math display">\[a_{2m}\alpha_s+a_{2m+1}\alpha_t=\dfrac{\sin(2m)\theta}{\sin\theta}\alpha_s+\dfrac{\sin(2m+1)\theta}{\sin\theta}\alpha_t=\alpha_t.\]</span>又回到了各自的第一项。所以 <span class="math inline">\(\sigma\)</span>的阶等于 <span class="math inline">\(m\)</span>。</p></li><li><p><span class="math inline">\(m=\infty\)</span>。这时未必有 <span class="math inline">\(V=V_{s,t}\oplusV_{s,t}^\bot\)</span>。但我们可以证明 <span class="math inline">\(\sigma\)</span> 在 <span class="math inline">\(V_{s,t}\)</span> 上的阶是无穷，那么自然它在 <span class="math inline">\(V\)</span> 上的阶也是无穷。 设 <span class="math inline">\(\theta\geq0\)</span> 使得 <span class="math inline">\(a_{s,t}=\cosh\theta\)</span>。同样为了简化记号，令<span class="math inline">\(b_k=\sinh(k\theta)/\sinh\theta\)</span>，不难验证有<span class="math display">\[\begin{align*}&amp;\alpha_s\xrightarrow{\\rho_t\ }b_1\alpha_s+b_2\alpha_t\xrightarrow{\ \rho_s\}b_3\alpha_s+b_2\alpha_t\xrightarrow{\ \rho_t\}b_3\alpha_s+b_4\alpha_t\xrightarrow{\ \rho_s\ }\cdots\\&amp;\alpha_t\xrightarrow{\ \rho_s\}b_2\alpha_s+b_1\alpha_t\xrightarrow{\ \rho_t\}b_2\alpha_s+b_3\alpha_t\xrightarrow{\ \rho_s\}b_4\alpha_s+b_3\alpha_t\xrightarrow{\ \rho_t\ }\cdots\end{align*}\]</span>（当 <span class="math inline">\(a_{s,t}=1\)</span> 时 <span class="math inline">\(\theta=0\)</span>，<span class="math inline">\(b_k\)</span> 应当理解为 <span class="math inline">\(\lim_{\theta\to0}\sinh(k\theta)/\sinh(\theta)=k\)</span>）</p><p>这两个链条都是永不重复的，所以 <span class="math inline">\(\sigma\)</span> 的阶是无穷。</p></li></ol><p>至此命题得证。<span class="math inline">\(\blacksquare\)</span></p><p>后面我们会看到 <span class="math inline">\(\rho\)</span>实际是一个同构，这样就把抽象的 Coxeter 群 <span class="math inline">\(W\)</span> 实现为具体的反射群 <span class="math inline">\(\rho(W)\)</span>。由于 <span class="math inline">\(\rho\)</span> 是同构，研究 <span class="math inline">\(\rho(W)\)</span> 并不会丢失 <span class="math inline">\(W\)</span> 的信息。</p><p>最后是一个记号的简化：我们把 <span class="math inline">\(w\inW\)</span> 在 <span class="math inline">\(V\)</span> 上的作用简写为<span class="math inline">\(wv=\rho(w)(v)\)</span>。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Howlett-note" class="csl-entry" role="listitem">Howlett, Robert B. 1996. <span>“Introduction to Coxeter Groups.”</span><a href="https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html">https://www.maths.usyd.edu.au/u/ResearchReports/Algebra/How/1997-6.html</a>.</div><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div></div>]]></content>
    
    
    <summary type="html">
&lt;h1 id=&quot;抽象-coxeter-群&quot;&gt;抽象 Coxeter 群&lt;/h1&gt;
&lt;p&gt;设 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt; 是一个集合，一个基于 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt; 的 Coxeter 矩阵 &lt;span class=&quot;math inline&quot;&gt;&#92;(M=(m_{s,t})_{s,t&#92;in S}&#92;)&lt;/span&gt;
是一个对称矩阵，其对角线上都是 1，非对角线元素取值范围为 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;{2,3,&#92;ldots,&#92;infty&#92;}&#92;)&lt;/span&gt;。&lt;span class=&quot;math inline&quot;&gt;&#92;(|S|&#92;)&lt;/span&gt; 叫做 &lt;span class=&quot;math inline&quot;&gt;&#92;(M&#92;)&lt;/span&gt; 的秩 (rank)。在这个系列中我们只考虑
&lt;span class=&quot;math inline&quot;&gt;&#92;(|S|&amp;lt;&#92;infty&#92;)&lt;/span&gt; 的情形。&lt;/p&gt;
&lt;p&gt;矩阵 &lt;span class=&quot;math inline&quot;&gt;&#92;(M&#92;)&lt;/span&gt; 确定了一个有限表现群
&lt;span class=&quot;math inline&quot;&gt;&#92;(W&#92;)&lt;/span&gt;，其生成元为集合 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt;，群表现如下： &lt;span class=&quot;math display&quot;&gt;&#92;[W = &#92;langle s&#92;in S&#92; |&#92; (st)^{m_{s,t}}=1&#92; {&#92;rm
if}&#92; m_{s,t}&amp;lt;&#92;infty&#92;rangle.&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;即 &lt;span class=&quot;math inline&quot;&gt;&#92;(S&#92;)&lt;/span&gt; 满足的生成关系是：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;对任何 &lt;span class=&quot;math inline&quot;&gt;&#92;(s&#92;in S&#92;)&lt;/span&gt; 有 &lt;span class=&quot;math inline&quot;&gt;&#92;(s^2=1&#92;)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;对任何 &lt;span class=&quot;math inline&quot;&gt;&#92;(s&#92;ne t&#92;)&lt;/span&gt; 且 &lt;span class=&quot;math inline&quot;&gt;&#92;(m_{s,t}&amp;lt;&#92;infty&#92;)&lt;/span&gt;
有&lt;strong&gt;辫关系&lt;/strong&gt; (braid relation) &lt;span class=&quot;math display&quot;&gt;&#92;[&#92;overbrace{sts&#92;cdots}^{m_{s,t}}=&#92;overbrace{tst&#92;cdots}^{m_{s,t}}&#92;]&lt;/span&gt;
成立。（当 &lt;span class=&quot;math inline&quot;&gt;&#92;(m_{s,t}=&#92;infty&#92;)&lt;/span&gt;
时的关系是无用的）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们称 &lt;span class=&quot;math inline&quot;&gt;&#92;((W, S)&#92;)&lt;/span&gt; 是一个
&lt;strong&gt;Coxeter 系&lt;/strong&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(W&#92;)&lt;/span&gt;
是一个&lt;strong&gt;有限生成 Coxeter 群&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Coxeter Groups" scheme="https://pywonderland.com/categories/Coxeter-Groups/"/>
    
    
  </entry>
  
  <entry>
    <title>遛狗中的数学：曲线的环绕数、Rouché 定理和开映射定理</title>
    <link href="https://pywonderland.com/Rouche-theorem-winding-number/"/>
    <id>https://pywonderland.com/Rouche-theorem-winding-number/</id>
    <published>2021-08-31T16:00:00.000Z</published>
    <updated>2025-03-13T13:47:23.691Z</updated>
    
    <content type="html"><![CDATA[<p>我写了一个 <a href="https://www.shadertoy.com/view/fdK3RD">shadertoy小动画</a>，演示 <span class="citation" data-cites="Needham1997">(<a href="#ref-Needham1997" role="doc-biblioref">Needham 1997</a>)</span>书中第 7 章 “Winding numbers and topology” 中的结论：</p><span id="more"></span><div class="statement simple plain unnumbered"><p>一个人和他的狗在公园里绕着一棵树散步，人和狗各自走的路径都是闭曲线，即经过一段时间后都会回到起点。如果人把狗绳抓的紧一些，使得整个过程中狗<strong>无法接触</strong>到树，则结束后人和狗绕着树走的圈数是一样的，这就是下面这个动画演示的：（树的位置是原点，用一个表盘标记）</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/fdK3RD?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe></div><p>对应的数学结论是：如果两条闭曲线 <span class="math inline">\(\gamma_1,\gamma_2\)</span> 都不经过原点，且 <span class="math inline">\(\gamma_1\)</span>可以在不碰触到原点的前提下通过连续的形变变为 <span class="math inline">\(\gamma_2\)</span>（同伦），则 <span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点的环绕数相等。</p><p>注意这个结论只要求 <span class="math inline">\(\gamma_1,\gamma_2\colon\[0,1]\to\mathbb{R}^2\)</span>是两条连续曲线，并不涉及解析性。因为环绕数和同伦都是拓扑概念，只涉及连续性。</p><p>当 <span class="math inline">\(\gamma_1=f(S^1),\gamma_2=g(S^1)\)</span>分别是单位圆 <span class="math inline">\(S^1\colon\\{z\in\mathbb{C}:|z|=1\}\)</span> 在两个解析函数 <span class="math inline">\(f,g\)</span> 下的像时，<a href="https://en.wikipedia.org/wiki/Argument_principle">幅角原理</a>告诉我们 <span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点的环绕数分别等于 <span class="math inline">\(f,g\)</span> 在<span class="math inline">\(S^1\)</span> 内部的零点个数。进一步 <a href="https://en.wikipedia.org/wiki/Rouch%C3%A9%27s_theorem">Rouché定理</a> 告诉我们，如果对任何 <span class="math inline">\(z\inS^1\)</span> 都有 <span class="math inline">\(|f(z)|&gt;|f(z)-g(z)|\)</span> 成立，即可保证<span class="math inline">\(\gamma_1,\gamma_2\)</span>关于原点有相同的环绕数，从而 <span class="math inline">\(f,g\)</span> 在<span class="math inline">\(S^1\)</span>内部的零点个数也是相同的。Rouché 定理的条件说的就是，假设人的位置是<span class="math inline">\(f(z)\)</span>，狗的位置是 <span class="math inline">\(g(z)\)</span>，绳子 <span class="math inline">\(l(z)=f(z)-g(z)\)</span> 的长度 <span class="math inline">\(|l(z)|\)</span> 始终小于人到原点的距离 <span class="math inline">\(|f(z)|\)</span>，就可以保证狗始终够不到原点。</p><p>动画中左下角的圆周是 <span class="math inline">\(S^1\)</span>，动画右边红、绿两条路径分别是 <span class="math inline">\(f(S^1)\)</span> 和 <span class="math inline">\(g(S^1)\)</span>。这里的 <span class="math inline">\(f\)</span> 我取的形如 <span class="math display">\[f(z)=\frac{z-a}{1-\overline{a}z}\frac{z-b}{1-\overline{b}z}\frac{z-c}{1-\overline{c}z}(z-2-2i),\quad |a|,|b|,|c|&lt;1.\]</span> <span class="math inline">\(f(z)\)</span> 在 <span class="math inline">\(S^1\)</span> 的内部有 3 个根（我用红点标出来了），在 <span class="math inline">\(S^1\)</span> 上不为0，在 <span class="math inline">\(S^1\)</span>外部有一个根（图中没有画）。<span class="math inline">\(f(z)\)</span>的前三个因子构成一个 Blaschke 乘积，它把 <span class="math inline">\(S^1\)</span> 的内部仍然映射为内部，把 <span class="math inline">\(S^1\)</span> 仍然映射为 <span class="math inline">\(S^1\)</span>，于是对任何 <span class="math inline">\(z\in S^1\)</span> 有 <span class="math display">\[|f(z)| = |z - 2 - 2i| \geq 2\sqrt{2} - 1,\quadz\in S^1.\]</span> 所以只要绳子 <span class="math inline">\(l(z)\)</span> 满足 <span class="math inline">\(|l(S^1)| &lt; 2\sqrt{2}-1\)</span>，则狗走的路径<span class="math inline">\(g(S^1)=f(S^1)+l(S^1)\)</span>就不可能接触到原点。我这里取了 <span class="math inline">\(l(z) =cz\)</span>，其中 <span class="math inline">\(c\)</span> 是一个小于<span class="math inline">\(2\sqrt{2}-1\)</span> 的正实数。</p><p>Needham 的书中还介绍了 <span class="math inline">\(\gamma\)</span>的环绕数在 <span class="math inline">\(\mathbb{C}\setminus\gamma\)</span>的每个连通分支上都是常数。对不在 <span class="math inline">\(\gamma\)</span> 上的一点 <span class="math inline">\(z\)</span>，我们可以稍稍移动 <span class="math inline">\(z\)</span> 到另一个点 <span class="math inline">\(z'\)</span>，只要保持 <span class="math inline">\(z'\)</span> 仍然位于 <span class="math inline">\(z\)</span> 所在的连通分支内，<span class="math inline">\(\gamma\)</span> 关于 <span class="math inline">\(z\)</span> 和 <span class="math inline">\(z'\)</span>的环绕数就一定相同。利用这个事实并结合幅角原理不难得出下面的结论：</p><div id="connected-component" class="unnumbered statement sta___ plain"><p><span class="statement-heading"><span class="statement-label">推论</span>.</span><span class="statement-spah"></span>设 <span class="math inline">\(\gamma\)</span>是一条简单闭曲线，内部围的区域为 <span class="math inline">\(\Omega\)</span>，<span class="math inline">\(f(z)\)</span> 是一个非常数的解析函数，<span class="math inline">\(f\)</span> 在包含 <span class="math inline">\(\gamma\)</span>的某个区域内解析。假设有两棵树分别位于 <span class="math inline">\(w_0,\,w_1\)</span> 两点，且人行走的路线 <span class="math inline">\(f(\gamma)\)</span> 到 <span class="math inline">\(w_0\)</span> 的距离始终大于两棵树之间的距离：<span class="math display">\[|f(z)-w_0| &gt; |w_0-w_1|,\quad\forallz\in\gamma.\]</span></p><figure><img src="/images/rouche/winding_number.svg" width="250" alt="注意两棵树位于 \mathbb{C}\backslash f(\gamma) 的同一个连通分支中"><figcaption aria-hidden="true">注意两棵树位于 <span class="math inline">\(\mathbb{C}\backslash f(\gamma)\)</span>的同一个连通分支中</figcaption></figure><p>则 <span class="math inline">\(f(\gamma)\)</span> 关于 <span class="math inline">\(w_0,w_1\)</span> 的环绕数相等，从而 <span class="math inline">\(w_0,w_1\)</span> 在 <span class="math inline">\(\gamma\)</span> 内部的原像个数相同： <span class="math display">\[\sharp\{z\in \Omega: f(z)=w_0\} = \sharp\{z\in\Omega: f(z)=w_1\}.\]</span></p></div><p><strong>证明</strong>：这是因为根据条件，从 <span class="math inline">\(w_0\)</span> 沿着线段 <span class="math inline">\([w_0,w_1]\)</span> 移动到 <span class="math inline">\(w_1\)</span> 的过程中始终不会碰触到曲线 <span class="math inline">\(f(\gamma)\)</span>，所以 <span class="math inline">\(w_0,w_1\)</span> 必然位于同一连通分支内。<span class="math inline">\(\blacksquare\)</span></p><p>利用此推论我们不难得出复分析中的 <a href="https://en.wikipedia.org/wiki/Open_mapping_theorem_(complex_analysis)">开映射定理</a>：</p><div class="unnumbered statement theorem-unnumbered plain"><p><span class="statement-heading"><span class="statement-label">定理</span>.</span><span class="statement-spah"></span>如果 <span class="math inline">\(U\subseteq\mathbb{C}\)</span>是开集，<span class="math inline">\(f\colon\ U\to\mathbb{C}\)</span>是非常数的解析函数，则 <span class="math inline">\(f(U)\)</span>也是开集。</p></div><p><strong>证明</strong>：任取 <span class="math inline">\(z_0\inU\)</span>，记 <span class="math inline">\(w_0=f(z_0)\)</span>。由于<span class="math inline">\(f\)</span> 不是常数，所以 <span class="math inline">\(f(z)-w_0\)</span> 的零点都是孤立的。我们可以取<span class="math inline">\(z_0\)</span> 的一个充分小的闭圆盘 <span class="math inline">\(B_\delta=\{z\in U\mid |z-z_0|\leq\delta\}\)</span>使得 <span class="math inline">\(f(z)-w_0\)</span> 在 <span class="math inline">\(B_\delta\)</span> 中除了 <span class="math inline">\(z_0\)</span> 以外没有其它零点。特别地，<span class="math inline">\(f(z)-w_0\)</span> 在 <span class="math inline">\(B_\delta\)</span> 的边界 <span class="math inline">\(\gamma =\{|z-z_0|=\delta\}\)</span> 上恒不为0，从而 <span class="math inline">\(|f(z)-w_0|\)</span> 在 <span class="math inline">\(\gamma\)</span> 上有正的极小值 <span class="math inline">\(e\)</span>，即对任何 <span class="math inline">\(z\in\gamma\)</span> 有 <span class="math inline">\(|f(z)-w_0|\geq e\)</span>。</p><p>现在我们考虑 <span class="math inline">\(w_0\)</span> 的邻域 <span class="math inline">\(V_e=\{|w-w_0|&lt;e\}\)</span>。则任何 <span class="math inline">\(w_1\in V_e\)</span> 都满足 <a href="#connected-component" title="推论">推论</a> 中的条件：</p><p><span class="math display">\[|f(z)- w_0| \geq e &gt; |w_1-w_0|,\quadz\in \gamma.\]</span></p><p>所以 <span class="math inline">\(w_1\)</span> 在 <span class="math inline">\(\gamma\)</span> 内部至少有一个原像。由 <span class="math inline">\(w_1\)</span> 的任意性可得 <span class="math inline">\(V_e\subset f(U)\)</span> 是 <span class="math inline">\(w_0\)</span> 在 <span class="math inline">\(f(U)\)</span> 中的开邻域，从而 <span class="math inline">\(f(U)\)</span> 是开集。<span class="math inline">\(\blacksquare\)</span></p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Needham1997" class="csl-entry" role="listitem">Needham, Tristan. 1997. <em>Visual Complex Analysis</em>. The ClarendonPress, Oxford University Press, New York.</div></div>]]></content>
    
    
    <summary type="html">
&lt;p&gt;我写了一个 &lt;a href=&quot;https://www.shadertoy.com/view/fdK3RD&quot;&gt;shadertoy
小动画&lt;/a&gt;，演示 &lt;span class=&quot;citation&quot; data-cites=&quot;Needham1997&quot;&gt;(&lt;a href=&quot;#ref-Needham1997&quot; role=&quot;doc-biblioref&quot;&gt;Needham 1997&lt;/a&gt;)&lt;/span&gt;
书中第 7 章 “Winding numbers and topology” 中的结论：&lt;/p&gt;</summary>
    
    
    
    <category term="可视化复分析" scheme="https://pywonderland.com/categories/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%8D%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Poncelet 定理与 Blaschke 乘积</title>
    <link href="https://pywonderland.com/poncelet-blaschke/"/>
    <id>https://pywonderland.com/poncelet-blaschke/</id>
    <published>2021-08-26T16:00:00.000Z</published>
    <updated>2024-06-20T22:06:27.162Z</updated>
    
    <content type="html"><![CDATA[<p>下面这个动画是受到 <a href="https://bookstore.ams.org/car-34">FindingEllipses: What Blaschke Products, Poncelet’s Theorem, and the NumericalRange Know about Each Other</a> 这本书启发所作：</p><span id="more"></span><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/fst3Rl?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><p>这个动画看起来似乎一目了然：我们有一个圆 <span class="math inline">\(C\)</span>，一个椭圆 <span class="math inline">\(E\)</span>，还有一个三角形 <span class="math inline">\(\Delta\)</span>。<span class="math inline">\(\Delta\)</span> 内接于圆 <span class="math inline">\(C\)</span> 同时外切于椭圆 <span class="math inline">\(E\)</span>。椭圆和三角形同时都在变动，但它们始终保持内切的关系。</p><p>但我打包票保证你绝难猜到它说的是什么事情。</p><p>下面是动画的制作过程：</p><ol type="1"><li>首先在单位圆 <span class="math inline">\(C\)</span> 内任取两个点<span class="math inline">\(a,b\)</span>，它们将作为椭圆 <span class="math inline">\(E\)</span> 的两个焦点。</li><li>构造 Blaschke 乘积 <span class="math display">\[B(z)=z\frac{z-a}{1-\overline{a}z}\frac{z-b}{1-\overline{b}z}.\]</span><span class="math inline">\(B(z)\)</span>是一个解析函数，它的三个因子每一个都保持单位圆的内部不变，将圆周 <span class="math inline">\(C\)</span> 仍然映射为 <span class="math inline">\(C\)</span>，所以 <span class="math inline">\(B(z)\)</span> 也是如此。而且 <span class="math inline">\(B(z)\)</span> 是一个 3 对 1 的映射：对任何 <span class="math inline">\(|\lambda|\leq 1\)</span> 有三个原像 <span class="math inline">\(z_1,z_2,z_3\)</span> 使得 <span class="math inline">\(B(z_i)=w,\,i=1,2,3\)</span>。这一点不难从方程<span class="math inline">\(B(z)=\lambda\)</span> 是一个关于 <span class="math inline">\(z\)</span> 的严格三次多项式看出来。</li><li>更进一步，对圆周 <span class="math inline">\(C\)</span> 上的任何一点<span class="math inline">\(|\lambda|=1\)</span>，<span class="math inline">\(B(z)=\lambda\)</span>的三个根必然是互不相同的，这三个根构成 <span class="math inline">\(C\)</span> 的一个内接三角形 <span class="math inline">\(\Delta ABC\)</span>。<span class="math inline">\(\Delta ABC\)</span>有一个特殊的性质：它必然外切于以 <span class="math inline">\(a,b\)</span> 为焦点的椭圆 <span class="math display">\[|z-a|+|z-b|=|1-\overline{a}b|.\]</span></li><li>当 <span class="math inline">\(\lambda\)</span> 变动时，<span class="math inline">\(\Delta ABC\)</span>也随之变动，得到的就是上面的动画。</li></ol><p>动画中我取了 <span class="math inline">\(a\)</span> 为原点，<span class="math inline">\(b\in(0,1)\)</span>为实数。采用这两个特殊点的原因是，一般情形下用 Mathematica求解得到的三次方程 <span class="math inline">\(B(z)=\lambda\)</span>的表达式实在是太太太让人头大了。<span class="emoji" data-alias="grin" style="" data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f601.png?v8">😁</span></p><p>正如开头书名所提示的，这个故事同时与 Poncelet 定理和 Blaschke乘积有关。</p><hr><p>假设有两个椭圆 <span class="math inline">\(E_1,\,E_2\)</span>，<span class="math inline">\(E_2\)</span> 位于 <span class="math inline">\(E_1\)</span> 的内部。在 <span class="math inline">\(E_1\)</span> 上选定一点 <span class="math inline">\(A_1\)</span>，从 <span class="math inline">\(A_1\)</span> 出发作 <span class="math inline">\(E_2\)</span> 的切线与 <span class="math inline">\(E_1\)</span> 交于 <span class="math inline">\(A_2\)</span>，然后从 <span class="math inline">\(A_2\)</span> 出发引另一条关于 <span class="math inline">\(E_2\)</span> 的切线交 <span class="math inline">\(E_1\)</span> 于 <span class="math inline">\(A_3\)</span>，…，如此一直进行下去。则有两种可能：</p><ol type="1"><li>经过 <span class="math inline">\(N\)</span> 次操作以后 <span class="math inline">\(A_{N+1}=A_1\)</span>，这时路径围成一个闭合的 <span class="math inline">\(N\)</span> 边形 <span class="math inline">\(P\)</span>，<span class="math inline">\(P\)</span>内接于 <span class="math inline">\(E_1\)</span> 同时外切于 <span class="math inline">\(E_2\)</span>。</li><li>所有的切点 <span class="math inline">\(\{A_n\}_{n=1}^\infty\)</span>全部互不相同。</li></ol><p>下面的动画显示了 <span class="math inline">\(N=3\)</span>的情形，并且外面的椭圆 <span class="math inline">\(E_1\)</span> 是个圆<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>：</p><object data="/images/blaschke/poncelet_billiard.svg"></object><p>Poncelet 定理说的是，如果情形 1 对 <span class="math inline">\(E_1\)</span> 上的某个点 <span class="math inline">\(A_1\)</span> 成立，则它对 <span class="math inline">\(E_1\)</span>上所有点都成立，并且所有得到的多边形都是 <span class="math inline">\(N\)</span> 边形。同样地如果情形 2对某个点成立，则对椭圆上所有点 <span class="math inline">\(A_1\)</span>，序列 <span class="math inline">\(\{A_n\}_{n=1}^\infty\)</span>也都互不相同，并且在边界 <span class="math inline">\(E_1\)</span>上是稠密的。</p><p>可以料见，“作 <span class="math inline">\(N\)</span>次切线后回到起点”这种好事不是那么容易发生的。<span class="math inline">\(E_1,E_2\)</span> 必须满足一些条件才行。对一般的<span class="math inline">\(N\)</span> 这个条件可以用 Jacobi椭圆函数来描述，有点高深。不过在 <span class="math inline">\(N=3\)</span> 且 <span class="math inline">\(E_1\)</span>为单位圆时，这个条件是非常简单的：这当且仅当椭圆 <span class="math inline">\(E_2\)</span> 形如 <span class="math display">\[|z-a| + |z-b|=|1-\overline{a}b|,\quad|a|&lt;1,\,|b|&lt;1.\]</span> 不仅如此，从单位圆上任意一点 <span class="math inline">\(x\)</span> 出发，按照上述方法连续作 <span class="math inline">\(E_2\)</span>的切线，得到的闭合三角形的另外两个顶点是方程 <span class="math inline">\(B(z)=B(x)\)</span> 的另外两个根。</p><p>这个故事还与矩阵的 <a href="https://en.wikipedia.org/wiki/Numerical_range">numeric range</a>（数值域） 有关，我不想假装成我很懂的样子，所以就不再叨叨了。</p><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>取其中一个椭圆为圆并不损失一般性，因为我们总是可以用一个仿射变换把其中一个椭圆变成圆，而仿射变换保持相切关系不变。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
    
    
    <summary type="html">
&lt;p&gt;下面这个动画是受到 &lt;a href=&quot;https://bookstore.ams.org/car-34&quot;&gt;Finding
Ellipses: What Blaschke Products, Poncelet’s Theorem, and the Numerical
Range Know about Each Other&lt;/a&gt; 这本书启发所作：&lt;/p&gt;</summary>
    
    
    
    <category term="可视化复分析" scheme="https://pywonderland.com/categories/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%8D%E5%88%86%E6%9E%90/"/>
    
    
    <category term="shadertoy" scheme="https://pywonderland.com/tags/shadertoy/"/>
    
    <category term="Visual Complex analysis" scheme="https://pywonderland.com/tags/Visual-Complex-analysis/"/>
    
    <category term="Poncelet porism" scheme="https://pywonderland.com/tags/Poncelet-porism/"/>
    
    <category term="Blaschke product" scheme="https://pywonderland.com/tags/Blaschke-product/"/>
    
    <category term="Caustics" scheme="https://pywonderland.com/tags/Caustics/"/>
    
  </entry>
  
  <entry>
    <title>静电场与 Marden 定理</title>
    <link href="https://pywonderland.com/Marden-theorem/"/>
    <id>https://pywonderland.com/Marden-theorem/</id>
    <published>2021-05-23T16:00:00.000Z</published>
    <updated>2025-03-13T13:48:44.596Z</updated>
    
    <content type="html"><![CDATA[<p>我昨晚刚完成了一个 <a href="https://www.shadertoy.com/view/7lf3Wn">shadertoy小动画</a>，演示平面几何中的 <a href="https://en.wikipedia.org/wiki/Marden%27s_theorem">Marden定理</a>、复分析中的 <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Lucas_theorem">Gauss-Lucas定理</a> 和静电场之间的关系：</p><span id="more"></span><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/7lf3Wn?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><p>这个动画的含义如下：</p><ol type="1"><li><p>在复平面上三角形 <span class="math inline">\(\Delta ABC\)</span>的三个顶点处各自放置一个单位正电荷，则平面上电场强度为 0的点有两个（这两个点可能重合），它们位于 <span class="math inline">\(\Delta ABC\)</span> 的内部，并且是三次复多项式<span class="math inline">\(P(z) = (z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span> 的零点。</p></li><li><p>不仅如此，这两个零点还是一个内切于 <span class="math inline">\(\Delta ABC\)</span>的椭圆的两个焦点，此椭圆是所有内切于 <span class="math inline">\(\DeltaABC\)</span> 的椭圆中面积最大者，其与 <span class="math inline">\(\DeltaABC\)</span> 三边的切点均为各边中点。这个椭圆叫做 <a href="https://en.wikipedia.org/wiki/Steiner_inellipse">Steiner内切椭圆</a>。</p></li></ol><p>这个动画是受几天前 Albert Chern 的 <a href="https://twitter.com/theAlbertChern/status/1395468792788967428?s=20">一篇推文</a>启发所作，John Baez 也写了一篇关于这个话题的 <a href="https://johncarlosbaez.wordpress.com/2021/05/24/electrostatics-and-the-gauss-lucas-theorem/">文章</a>。我是由此才了解到Marden 定理还有如此有趣的物理学解释，的确大开眼界！</p><hr><p>在平面上不全共线的 <span class="math inline">\(n\)</span> 个点 <span class="math inline">\(a_1,\ldots,a_n\)</span>处放置若干单位正电荷，这规定了一个平面上的电势函数 <span class="math inline">\(V(z)\)</span> （标量） 和一个电场 <span class="math inline">\(\mathbf{E}(z)\)</span>（二维向量场）。电学知识告诉我们，在忽略物理常数意义下有 <span class="math display">\[V(z)=\sum_{i=1}^n\ln|z-a_i|=\ln\prod_{i=1}^n|z-a_i|=\ln|P(z)|.\]</span> 其中<span class="math inline">\(P(z)=(z-a_1)(z-a_2)\cdots(z-a_n)\)</span>是以 <span class="math inline">\(a_1,\ldots,a_n\)</span>为根的多项式。</p><p>此外 <span class="math inline">\(\mathbf{E}(z) = -\nablaV(z)\)</span> 为电势的梯度向量取负。</p><blockquote><p><strong>问题</strong>：怎样确定平面上场强为 0 的点呢？</p></blockquote><p>场强为 0的点也叫做<strong>平衡点</strong>、<strong>鞍点</strong>，因为在这一点处的电荷不受电场的库仑力。</p><p>答案有点出人意料：平衡点必然是 <span class="math inline">\(P'(z)\)</span> 的零点，而且这些点都属于 <span class="math inline">\(a_1,\ldots,a_n\)</span> 的凸包！</p><p>注意 <span class="math inline">\(V(z)\)</span> 是 <span class="math inline">\(\ln P(z) = \ln |P(z)| + i\arg{P(z)}\)</span>的实部，由 Cauchy-Riemann 方程不难看出使得亚纯函数实部梯度为 0的点一定是其导数的零点，即满足 <span class="math inline">\(\nablaV=0\)</span> 的点都是 <span class="math inline">\((\lnP(z))'=P'(z)/P(z)\)</span> 的零点，所以平衡点都是 <span class="math inline">\(P'(z)\)</span> 的零点。平衡点属于 <span class="math inline">\(\{a_1,\ldots,a_n\}\)</span> 的凸包是根据 <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Lucas_theorem">Gauss-Lucas定理</a>：任何复多项式 <span class="math inline">\(f\)</span>的导数的零点都属于 <span class="math inline">\(f\)</span>的零点构成的凸包！</p><p>John Baez 的文章中利用凸集分离定理给出了 Gauss-Lucas定理的一个简洁证明。</p><p>需要注意的是，反过来 <span class="math inline">\(P'(z)\)</span>的零点未必都是电场的平衡点，当 <span class="math inline">\(P(z)\)</span>有重根时，重根也是 <span class="math inline">\(P'(z)\)</span>的零点，但不是 <span class="math inline">\(P'(z)/P(z)\)</span>的零点，所以不是平衡点。</p><p>此外平衡点是鞍点 (saddle point) 是由于 <span class="math inline">\(V(z)\)</span>的调和性质，其不存在局部的极大极小值，所以使得 <span class="math inline">\(\nabla V=0\)</span> 的点都是鞍点。</p><p>在三个点电荷 <span class="math inline">\(A,B,C\)</span>的情形，平衡点有两个，它们位于 <span class="math inline">\(\DeltaABC\)</span> 的内部，且是多项式 <span class="math inline">\(P(z) =(z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span>的零点。那关于这两个点的具体位置我们可以说什么吗？这就是优美的 Marden定理，要表述这个定理，我们需要先介绍 Steiner 内切椭圆的概念：</p><div id="steiner-inellipse" class="unnumbered statement sta_steiner_inellipse plain"><p><span class="statement-heading"><span class="statement-label">Steinerinellipse</span>.</span><span class="statement-spah"></span>在所有内切于 <span class="math inline">\(\Delta ABC\)</span>的椭圆中，存在唯一的一个面积最大者，叫做 Steiner inellipse，此椭圆与<span class="math inline">\(\Delta ABC\)</span>三边的切点为各边的中点。</p></div><p>Marden 定理断言 <span class="math inline">\(P'(z)\)</span>的两个根正是 Steiner 内切椭圆的两个焦点：</p><div id="marden-------" class="unnumbered statement sta_marden___ plain"><p><span class="statement-heading"><span class="statement-label">Marden定理</span>.</span><span class="statement-spah"> </span>复多项式 <span class="math inline">\(P(z)=(z-A)(z-B)(z-C)\)</span> 的导数 <span class="math inline">\(P'(z)\)</span> 的两个零点正是 <span class="math inline">\(\Delta ABC\)</span> 的 Steiner inellipse的两个焦点。</p></div><p>Steiner inellipse 和 Marden定理的证明并不复杂，美国数学月刊上出现过两篇介绍其证明的文章，都非常值得一读：</p><ol type="1"><li><p><a href="https://www.researchgate.net/publication/228698127_Triangles_Ellipses_and_Cubic_Polynomials">Triangles,Ellipses, and Cubic Polynomials</a>.</p></li><li><p><a href="https://www.researchgate.net/publication/263136028_An_Elementary_Proof_of_Marden%27s_Theorem">AnElementary Proof of Marden’s Theorem</a>.</p></li></ol><p>其中第一篇文章采用了复数和仿射变换的途径，第二篇使用了椭圆的光学性质。</p>]]></content>
    
    
    <summary type="html">
&lt;p&gt;我昨晚刚完成了一个 &lt;a href=&quot;https://www.shadertoy.com/view/7lf3Wn&quot;&gt;shadertoy
小动画&lt;/a&gt;，演示平面几何中的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Marden%27s_theorem&quot;&gt;Marden
定理&lt;/a&gt;、复分析中的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Gauss%E2%80%93Lucas_theorem&quot;&gt;Gauss-Lucas
定理&lt;/a&gt; 和静电场之间的关系：&lt;/p&gt;</summary>
    
    
    
    <category term="可视化复分析" scheme="https://pywonderland.com/categories/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%8D%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Escher 风格的非周期密铺</title>
    <link href="https://pywonderland.com/debruijn-rhombus-tiling/"/>
    <id>https://pywonderland.com/debruijn-rhombus-tiling/</id>
    <published>2020-12-05T16:00:00.000Z</published>
    <updated>2024-06-20T22:05:43.169Z</updated>
    
    <content type="html"><![CDATA[<p>周末刚完成了一个有点烧脑的 Shadertoy 项目，Escher 风格的 <a href="https://en.wikipedia.org/wiki/Aperiodic_tiling">非周期密铺</a>：</p><span id="more"></span><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/wsKBW1?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe><p>你能看出这个动画的奥妙之处在哪里吗？</p><p>直观上看，这个动画由一些错落有致，但又无缝拼接在一起的房间（立方体）组成，每个房间的外面绘制了一些“窗户”，窗户的开闭、朝向是变化的。但是仔细一看，诶，好像一些房间的窗口的朝向是“矛盾”的哎？这种整体布局和谐但是局部细节与真实世界矛盾的艺术风格由<a href="https://en.wikipedia.org/wiki/M._C._Escher">Escher</a>(1898-1972) 所创立，所以这个作品也可以叫做 Escher 风格的不可能密铺。</p><p>这个动画里面使用的几何元素只有菱形，这些菱形分为两种：胖菱形和瘦菱形。在代码中我是对每一个像素，首先确定其所属的菱形，然后计算它到各个装饰元素（菱形边界、窗户、窗台） 的 signed distance field 函数 <span class="math inline">\(d\)</span>，根据 <span class="math inline">\(d\)</span>的值来混合颜色，特别还根据菱形的类型和方向加上了阴影的效果，使得整个画面看起来有立体感。</p><p>计算菱形位置的算法非常奇妙，它来自 de Bruijn 1981年的发现，是构造准晶的网格法 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>(multigrid)；添加窗户的点缀是受 Greg Egan 的 <a href="http://gregegan.net/APPLETS/02/02.html">Javascript 动画</a>启发。我很久之前就知道 de Bruijn 的方法，但是看到 Greg Egan的动画以后还是萌发了在 shader 里面做出一个更漂亮的 3D效果来的想法。这个念头憋了好久，终于前几天利用晚上业余时间动手折腾了一番，捣鼓出了上面的效果。当然只是一个伪3D 的效果。我的动画与 Greg Egan 不同的地方在于，Greg Egan 的 Javascript动画可以直接计算出菱形的坐标然后绘制，思路比较直接；但是在 shader里面则需要把这个过程逆过来，需要对每一个像素，通过搜索确定它所在的菱形，所以实现起来要麻烦一些。此外Greg Egan是精心选择了每一个窗户的开口方向，使得所有的房间的窗户看起来都是矛盾的；我这里为了简单起见只随机设置了开口的方向，所以只有部分房间的窗户是矛盾的。</p><p>代码中窗户的绘制方法参考了 Greg Egan 的代码和注释，特别致谢。</p><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>N.G. de Bruijn. Algebraic theory of Penrose’snon-periodic tilings of the plane.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
    
    
    <summary type="html">
&lt;p&gt;周末刚完成了一个有点烧脑的 Shadertoy 项目，Escher 风格的 &lt;a href=&quot;https://en.wikipedia.org/wiki/Aperiodic_tiling&quot;&gt;非周期密铺&lt;/a&gt;：&lt;/p&gt;</summary>
    
    
    
    <category term="Shadertoy" scheme="https://pywonderland.com/categories/Shadertoy/"/>
    
    
    <category term="shadertoy" scheme="https://pywonderland.com/tags/shadertoy/"/>
    
    <category term="de Bruijn" scheme="https://pywonderland.com/tags/de-Bruijn/"/>
    
    <category term="Penrose tiling" scheme="https://pywonderland.com/tags/Penrose-tiling/"/>
    
    <category term="Aperiodic tiling" scheme="https://pywonderland.com/tags/Aperiodic-tiling/"/>
    
    <category term="Escher" scheme="https://pywonderland.com/tags/Escher/"/>
    
    <category term="Rhombus" scheme="https://pywonderland.com/tags/Rhombus/"/>
    
  </entry>
  
  <entry>
    <title>二维随机游动 （二）：一个随机的完美迷宫分别有多少死角、直路、拐角、岔路和十字路口？</title>
    <link href="https://pywonderland.com/transfer-current-theorem/"/>
    <id>https://pywonderland.com/transfer-current-theorem/</id>
    <published>2020-10-05T16:00:00.000Z</published>
    <updated>2024-06-22T11:00:39.913Z</updated>
    
    <content type="html"><![CDATA[<p>和之前一样，我们还是通过一个有趣的问题来引入主题。</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>在 <span class="math inline">\(n\timesn\)</span> 的正方形网格图 <span class="math inline">\(G_n\)</span>的所有生成树中等概率地随机任选一个，记这个随机生成树为 <span class="math inline">\(T\)</span>，<span class="math inline">\(T\)</span>叫做 <span class="math inline">\(G_n\)</span> 的一个均匀生成树。对 <span class="math inline">\(G_n\)</span> 中任一顶点 <span class="math inline">\(v\)</span>，<span class="math inline">\(v\)</span>是 <span class="math inline">\(T\)</span> 的叶节点的概率是多少？</p></div><p>这个问题可以换一种更通俗的描述：</p><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"> </span>对一个完全随机的 <span class="math inline">\(n\times n\)</span>的完美迷宫，它包含的“死角”的比例是多少？</p></div><p>为什么这两个问题是一回事？</p><p>一个迷宫称作是完美的，如果迷宫中的任何两个房间之间都有且仅有唯一的道路相连，这正是生成树的等价描述！迷宫中的一个房间称作是“死角”，当且仅当它只有一条道路与其它房间相通，没有其它出路，这正是叶节点的等价描述！</p><p>下图显示了三个不同的均匀生成树，它们分别来自大小为 <span class="math inline">\(80\times 80\)</span>，<span class="math inline">\(120\times120\)</span> 和 <span class="math inline">\(200\times200\)</span>的三个网格图，这三个生成树的叶节点（用蓝色标出）占全体顶点的比例分别为<span class="math inline">\(1884/6400=0.294375\)</span>，<span class="math inline">\(4234/14400\approx0.294028\)</span>，<span class="math inline">\(11776/40000=0.2944\)</span>。咦？看起来好像是在围着一个固定的值波动喔？</p><span id="more"></span><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><thead><tr class="header"><th style="text-align: center;">80x80, 0.294375</th><th style="text-align: center;">120x120, 0.294028</th><th style="text-align: center;">200x200, 0.2944</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><img src="/images/electric-network/ust-leaves-1884-6400.png" width="200"></td><td style="text-align: center;"><img src="/images/electric-network/ust-leaves-4234-14400.png" width="200"></td><td style="text-align: center;"><img src="/images/electric-network/ust-leaves-11776-40000.png" width="200"></td></tr></tbody></table><p>本文的主题就是证明对 <span class="math inline">\(G_n\)</span>的一个均匀生成树 <span class="math inline">\(T\)</span>，<span class="math inline">\(T\)</span> 包含的叶节点的比例随着 <span class="math inline">\(n\)</span> 趋于无穷收敛到常数 <span class="math inline">\(8(\pi-2)/\pi^3\approx 0.2945449\)</span> （想不到<span class="math inline">\(\pi\)</span>会出现在这里吧？）。可见上面三个模拟的数值与真实的极限值已经非常接近。</p><p>实际上对于度数是 <span class="math inline">\(2,3,4\)</span>的顶点，它们的比例也随着 <span class="math inline">\(n\to\infty\)</span>趋于固定的值，详细结果见下表：</p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><thead><tr class="header"><th style="text-align: center;">度数</th><th style="text-align: center;">极限概率</th><th style="text-align: center;">近似值</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1：死角</td><td style="text-align: center;"><span class="math display">\[\dfrac{8}{\pi^2}\left(1-\dfrac{2}{\pi}\right)\]</span></td><td style="text-align: center;">0.294</td></tr><tr class="even"><td style="text-align: center;">2：拐角 + 直路</td><td style="text-align: center;"><span class="math display">\[\dfrac{4}{\pi}\left(2-\dfrac{9}{\pi}+\dfrac{12}{\pi^2}\right)\]</span></td><td style="text-align: center;">0.447</td></tr><tr class="odd"><td style="text-align: center;">3：岔路</td><td style="text-align: center;"><span class="math display">\[2\left(1-\dfrac{2}{\pi}\right)\left(1-\dfrac{6}{\pi}+\dfrac{12}{\pi^2}\right)\]</span></td><td style="text-align: center;">0.222</td></tr><tr class="even"><td style="text-align: center;">4：十字路口</td><td style="text-align: center;"><span class="math display">\[\left(\dfrac{4}{\pi}-1\right)\left(1-\dfrac{2}{\pi}\right)^2\]</span></td><td style="text-align: center;">0.036</td></tr></tbody></table><p>所以在一个随机的完美迷宫中，最多的其实是“拐角” 和“直路”(45%)，其次是“死角” (30%)，再次是“丁字岔路”(22%)，而“十字路口”是非常少的(3.6%)。进一步也不难算出拐角和直路的极限概率分别为 <span class="math inline">\((32-20\pi+4\pi^2)/\pi^3\approx 0.279\)</span> 和<span class="math inline">\((16-16\pi+4\pi^2)/\pi^3\approx0.168\)</span>。</p><p>这些概率是怎样计算出来的呢？它和我们这个系列的主题二维随机游动又有何关系呢？这里面的故事相当精彩。粗略地说，上面这些关于随机生成树的概率量，都可以翻译为图上随机游动的概率量，把整个图看做一个电网络，它们又可以翻译为这个电网络的物理量，而这些物理量是可以用各种方法（主要是线性代数）来算的。上面提到的这些概率值都可以从一个矩阵出发通过求其主子式得到（或者稍微加点变化），这个矩阵叫做<strong>转移电流矩阵</strong>(transfer current matrix)，其定义为：对给定的图 <span class="math inline">\(G\)</span>，将 <span class="math inline">\(G\)</span> 看作一个电网络，每条边的电阻都是单位1。在其中一条边 <span class="math inline">\(e\)</span>的两端加上电极，使得流入整个网络的电流总量为 1 个单位，记此时流过边<span class="math inline">\(e'\)</span> 的电流总量为 <span class="math inline">\(Y(e,e')\)</span>，则矩阵 <span class="math inline">\(Y=Y(e,e')_{e,e'\in E}\)</span> 叫做网络<span class="math inline">\(G\)</span> 的转移电流矩阵。</p><p>对 <span class="math inline">\(G\)</span> 的任何 <span class="math inline">\(k\)</span> 条边 <span class="math inline">\(e_1,\ldots,e_k\)</span>，定义 <span class="math inline">\(k\times k\)</span> 矩阵 <span class="math inline">\(Y^{(k)}\)</span> 为 <span class="math inline">\(Y^{(k)}(i,j)=Y(e_i,e_j)\)</span>，则我们有如下结论（转移电流矩阵定理）：设 <span class="math inline">\(T\)</span>是一个随机生成树，则边 <span class="math inline">\(e_1,\ldots,e_k\)</span> 都属于 <span class="math inline">\(T\)</span> 的概率 <span class="math display">\[\mathbb{P}(e_1,\ldots,e_k \in T)=\detY^{(k)}.\]</span> 举个例子，<span class="math inline">\(\mathbb{Z}^2\)</span> 中与原点 <span class="math inline">\((0, 0)\)</span> 相邻的四条边为 <span class="math inline">\(e_1=(1,0)\)</span>，<span class="math inline">\(e_2=(0, 1)\)</span>，<span class="math inline">\(e_3=(-1,0)\)</span>，<span class="math inline">\(e_4=(0,-1)\)</span>，我们后面会计算出这四条边对应的转移电流矩阵为</p><p><span class="math display">\[Y^{(4)}=\begin{pmatrix}\frac{1}{2} &amp; \frac{1}{2}-\frac{1}{\pi} &amp;\frac{2}{\pi}-\frac{1}{2} &amp; \frac{1}{2}-\frac{1}{\pi}\\\frac{1}{2}-\frac{1}{\pi} &amp; \frac{1}{2} &amp;\frac{1}{2}-\frac{1}{\pi} &amp; \frac{2}{\pi}-\frac{1}{2}\\\frac{2}{\pi}-\frac{1}{2} &amp; \frac{1}{2}-\frac{1}{\pi} &amp;\frac{1}{2} &amp; \frac{1}{2}-\frac{1}{\pi}\\\frac{1}{2}-\frac{1}{\pi} &amp; \frac{2}{\pi}-\frac{1}{2} &amp;\frac{1}{2}-\frac{1}{\pi} &amp; \frac{1}{2}\end{pmatrix}.\]</span></p><p>于是原点的度数等于 4 的概率是 <span class="math display">\[\mathbb{P}(e_1,e_2,e_3,e_4\in\mathbb{T})=\detY^{(4)}=\left(\frac{4}{\pi}-1\right)\left(1-\frac{2}{\pi}\right)^2\approx0.0361.\]</span> 这正是上面列出的十字路口的概率！</p><p>如果是计算概率 <span class="math inline">\(\mathbb{P}(e_1,e_2,e_3\notin T, e_4\in T)\)</span>呢？方法如下，把要排除掉的 <span class="math inline">\(e_1,e_2,e_3\)</span> 对应的 <span class="math inline">\(Y^{(4)}\)</span>的前三行全部取负值，并且给前三个对角元加上 1，保持第 4 行不变，得到</p><p><span class="math display">\[Y^{(4)}_{\overline{123}4}=\begin{pmatrix}\frac{1}{2} &amp; \frac{1}{\pi}-\frac{1}{2} &amp;-\frac{2}{\pi}+\frac{1}{2} &amp; \frac{1}{\pi}-\frac{1}{2}\\\frac{1}{\pi}-\frac{1}{2} &amp; \frac{1}{2} &amp;\frac{1}{\pi}-\frac{1}{2} &amp; -\frac{2}{\pi}+\frac{1}{2}\\-\frac{2}{\pi}+\frac{1}{2} &amp; \frac{1}{\pi}-\frac{1}{2} &amp;\frac{1}{2} &amp; \frac{1}{\pi}-\frac{1}{2}\\\frac{1}{2}-\frac{1}{\pi} &amp; \frac{2}{\pi}-\frac{1}{2} &amp;\frac{1}{2}-\frac{1}{\pi} &amp; \frac{1}{2}\end{pmatrix}.\]</span></p><p>则 <span class="math display">\[\mathbb{P}(e_1,e_2,e_3\notin T,e_4\in T)=\detY^{(4)}_{\overline{123}4}=\frac{2}{\pi^2}-\frac{4}{\pi^3}.\]</span>于是原点是叶节点的概率是 <span class="math inline">\(4\times\detY^{(4)}_{\overline{123}4}\approx0.2945\)</span>，这正是之前看到的死角的比例。</p><p>所以解决问题的关键就是求解 <span class="math inline">\(\mathbb{Z}^2\)</span>上的转移电流矩阵，本文接下来就来介绍具体的理论。这个故事并无特别的难点，但确实比较长。我主要参考了Lyons 等人关于图随机游动的专著 <a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，Stanley的代数组合学教材 <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> 以及网上一些公开的讲义。</p><h1 id="图上的线性代数">1 图上的线性代数</h1><p>一个<strong>网络</strong> <span class="math inline">\(\mathcal{N}=(G,c)\)</span> 由一个有限图 <span class="math inline">\(G=(V,E)\)</span>和一个权值函数 <span class="math inline">\(c:E\to\mathbb{R}_{\geq0}\)</span> 组成。这里 <span class="math inline">\(G\)</span> 是连通的无向图，其每条边 <span class="math inline">\(e\in E\)</span> 有一个权值 <span class="math inline">\(c(e)\in[0, +\infty)\)</span>，叫做 <span class="math inline">\(e\)</span> 的<strong>电导</strong>，其倒数 <span class="math inline">\(r(e)=1/c(e)\)</span> 叫做 <span class="math inline">\(e\)</span> 的<strong>电阻</strong>。</p><p>设 <span class="math inline">\(x,\,y\in V\)</span> 是两个顶点，我们用<span class="math inline">\(x\sim y\)</span> 表示 <span class="math inline">\(x,y\)</span>是相邻的。由于本文主要考察边上的流函数，而流函数是有方向的，<strong>所以我们约定边集<span class="math inline">\(E\)</span> 同时包含有序对 <span class="math inline">\((x,y)\)</span> 和 <span class="math inline">\((y,x)\)</span>，即一条边作为有序对在 <span class="math inline">\(E\)</span> 中出现两次</strong>。当 <span class="math inline">\(e=(x,y)\)</span> 时，我们记 <span class="math inline">\(-e=(y,x)\)</span> 为 <span class="math inline">\(e\)</span> 的<strong>反向边</strong>。并用记号<span class="math inline">\(E_{1/2}\)</span> 表示对每个 <span class="math inline">\(e\)</span>，在 <span class="math inline">\(e\)</span> 和 <span class="math inline">\(-e\)</span> 中任选一个组成的集合。<span class="math inline">\(E_{1/2}\)</span> 的一个选取方式对应 <span class="math inline">\(E\)</span>的一个定向，不过我们一般不必明确写出这个选取方式。此外当 <span class="math inline">\(e=(x,y)\)</span> 时，我们称 <span class="math inline">\(e^-=x\)</span> 为 <span class="math inline">\(e\)</span> 的<strong>尾部</strong>，<span class="math inline">\(e^+=y\)</span> 为 <span class="math inline">\(e\)</span>的<strong>头部</strong>。为了记住这一点，你可以把 <span class="math inline">\(e\)</span> 想象成一个从 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的箭头：<span class="math inline">\(x\xrightarrow{e}y\)</span>。注意在反向边 <span class="math inline">\(-e\)</span> 中 <span class="math inline">\(x\)</span> 变为头部，<span class="math inline">\(y\)</span> 变为尾部。</p><p>对每个 <span class="math inline">\(e\in E\)</span>，当 <span class="math inline">\(e=(x,y)\)</span> 时我们也记 <span class="math inline">\(c(x,y)=c(e)\)</span>。<strong>我们要求电导函数<span class="math inline">\(c(x,y)\)</span> 关于 <span class="math inline">\(x,y\)</span> 是对称的：<span class="math inline">\(c(x,y)=c(y,x)\)</span></strong>。所以当写 <span class="math inline">\(c(e)\)</span> 的时候我们不用关心 <span class="math inline">\(e\)</span> 的定向。对每个顶点 <span class="math inline">\(x\in V\)</span>，记 <span class="math inline">\(c(x)=\sum_{y\sim x}c(x,y)\)</span>。</p><p>所有 <span class="math inline">\(V\)</span> 上的实值函数 <span class="math inline">\(f:V\to\mathbb{R}\)</span> 构成一个内积空间 <span class="math inline">\(\ell^2(V)\)</span>： <span class="math display">\[(f,\, g)_V = \sum_{x\inV}c(x)f(x)g(x).\]</span></p><p>所有 <span class="math inline">\(E\)</span>上的<strong>反对称</strong>实值函数 <span class="math inline">\(\theta:E\to\mathbb{R}\)</span> 也构成一个内积空间 <span class="math inline">\(\ell^2_{-}(E)\)</span>： <span class="math display">\[(\theta,\,\theta')_E = \frac{1}{2}\sum_{e\inE}r(e)\theta(e)\theta'(e)=\sum_{e\inE_{1/2}}r(e)\theta(e)\theta'(e).\]</span> 这里反对称的意思是对任何<span class="math inline">\(e=\{x,y\}\)</span> 有 <span class="math inline">\(\theta(x,y)=-\theta(y,x)\)</span>。注意上式右边的求和与边的定向是无关的，如果换成<span class="math inline">\(-e\)</span> 的话乘积 <span class="math inline">\(\theta(e)\theta'(e)\)</span>还是不变的，即内积的定义与 <span class="math inline">\(E_{1/2}\)</span>的选取方式无关。</p><p>以上定义基本上与 Lyons等人的书保持一致，但是接下来的叙述会有比较大的差别。</p><h2 id="梯度和散度">梯度和散度</h2><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.1</span>.</span></p><ol type="1"><li><p>定义<strong>梯度</strong>算子 <span class="math inline">\(\nabla:\ell^2(V)\to\ell^{2}_{-}(E)\)</span> 为 <span class="math display">\[(\nabla f)(x,y) = c(x,y)\big[f(x)-f(y)\big]=c(e)\big[f(e^-)-f(e^+)\big].\]</span> 如果把 <span class="math inline">\(f\)</span>理解为每个顶点处的电压的话，梯度算子给出的是电压之差除以电阻值，即经过边<span class="math inline">\(e\)</span> 的有向电流。</p></li><li><p>定义<strong>散度</strong>算子 <span class="math inline">\(\mathrm{div}:\ell^{2}_{-}(E)\to\ell^2(V)\)</span>为 <span class="math display">\[(\mathrm{div}\,\theta)(x) =\frac{1}{c(x)}\sum_{y\sim x}\theta(x,y)=\frac{1}{c(x)}\sum_{e^-=x}\theta(e).\]</span>上式右边可能有的求和项大于 0，有的小于 0。如果把 <span class="math inline">\(\theta\)</span>理解为每条边上的有向电流的话，散度算子给出的是每个顶点处的净流出量。</p></li><li><p>定义<strong>拉普拉斯</strong>算子 <span class="math inline">\(\Delta:\ell^2(V)\to\ell^{2}(V)\)</span> 为 <span class="math display">\[(\Delta f)(x) = (\mathrm{div}\,\nabla f)(x) = f(x)-\sum_{y\simx}\frac{c(x,y)}{c(x)}f(y).\]</span> 如果 <span class="math inline">\((\Delta f)(x)=0\)</span> 对<span class="math inline">\(x\in V\)</span> 成立，我们就称 <span class="math inline">\(f\)</span> 在 <span class="math inline">\(x\)</span> 处是<strong>调和</strong>的。</p></li></ol></div><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.2</span>.</span><span class="statement-spah"></span>梯度算子和散度算子是一对共轭算子：对任何 <span class="math inline">\(f\in\ell^2(V)\)</span> 和 <span class="math inline">\(\theta\in\ell_{-}^2(E)\)</span> 有 <span class="math display">\[(f,\,\mathrm{div}\,\theta)_V = (\nablaf,\,\theta)_E.\]</span></p></div><p><strong>证明</strong>：上式对 <span class="math inline">\(f\)</span>是线性的，所以我们只要对形如 <span class="math inline">\(\mathbb{1}_{\{x \}},x\in V\)</span> 的元素验证即可。这时左边是 <span class="math inline">\(c(x)\cdot(\mathrm{div}\,\theta)(x)\)</span>，右边是<span class="math inline">\(\sum_{y\simx}\theta(x,y)\)</span>，二者当然相等。<span class="math inline">\(\blacksquare\)</span></p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义1.3</span>.</span><span class="statement-spah"> </span>我们称映射 <span class="math inline">\(\mathrm{div}\)</span> 的核 <span class="math inline">\(\mathrm{Ker\,div}\)</span> 为环空间 (cyclespace)，记作 <span class="math inline">\(\lozenge\)</span>。称映射 <span class="math inline">\(\nabla\)</span> 的像 <span class="math inline">\(\mathrm{Im}\nabla\)</span> 为星空间 (starspace)，记作 <span class="math inline">\(\bigstar\)</span>。环空间和星空间都是 <span class="math inline">\(\ell_{-}^2(E)\)</span> 的子空间。</p></div><div class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理1.4</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\ell_{-}^2(E)\)</span>是环空间和星空间的正交直和：<span class="math inline">\(\ell_{-}^2(E)=\lozenge\oplus\bigstar\)</span>。</p></div><p><strong>证明</strong>：由于 <span class="math inline">\(\{\mathbb{1}_{\{ x \}},x\in V\}\)</span> 构成<span class="math inline">\(\ell^2(V)\)</span> 的一组基，所以它们在<span class="math inline">\(\nabla\)</span> 下的像构成 <span class="math inline">\(\bigstar\)</span> 的一组基。从定理 1.1的证明中我们已经看到对任何 <span class="math inline">\(\theta\in\ell^2_{-}(E)\)</span> 有 <span class="math display">\[(\nabla \mathbb{1}_{\{ x\}},\,\theta)_E=c(x)(\mathrm{div}\,\theta)(x).\]</span> 于是 <span class="math inline">\(\theta\)</span> 与任何 <span class="math inline">\(\nabla \mathbb{1}_{\{ x \}}\)</span> 正交当且仅当<span class="math inline">\((\mathrm{div}\,\theta)(x)=0\)</span> 对任何<span class="math inline">\(x\in V\)</span> 成立，即当且仅当 <span class="math inline">\(\theta\in\lozenge\)</span>，从而 <span class="math inline">\(\lozenge\)</span> 和 <span class="math inline">\(\bigstar\)</span> 互为正交补空间，证毕。</p><h2 id="环空间和星空间的解释">环空间和星空间的解释</h2><p>我们来解释一下为什么这两个子空间叫做“环空间”和“星空间”。</p><p>首先是环空间。对任一 <span class="math inline">\(e\in E\)</span>，记<span class="math display">\[\chi^e=\mathbb{1}_{\{ e \}} -\mathbb{1}_{\{ -e \}}\in\ell^2_{-}(E)\]</span> 为边 <span class="math inline">\(e\)</span> 的示性函数，即 <span class="math inline">\(\chi^e\)</span> 在 <span class="math inline">\(e\)</span> 和 <span class="math inline">\(-e\)</span> 上取值分别为 <span class="math inline">\(\pm1\)</span>，在其它边上都是 0。</p><p>显然 <span class="math inline">\(\chi^{e}=-\chi^{-e}\)</span>。</p><p>设 <span class="math inline">\(e_1=(v_1,v_2),e_2=(v_2,v_3),\ldots,e_k=(v_k,v_1)\)</span> 首尾相接构成一条回路 <span class="math inline">\(C\)</span>，即 <span class="math display">\[v_1\xrightarrow{\quad e_1\quad}v_2\xrightarrow{\quad e_2 \quad}\cdots\xrightarrow{\quad e_{k-1}\quad}v_k\xrightarrow{\quad e_k \quad}v_1.\]</span></p><p><img style="margin:0px auto;display:block" src="/images/electric-network/cycle.svg" width="150"></p><p>定义 <span class="math inline">\(C\)</span> 对应的环函数 <span class="math inline">\(f^C = \sum_{i=1}^k\chi^{e_i}\)</span>，则从 <span class="math inline">\(v_1\)</span> 出发绕 <span class="math inline">\(C\)</span> 一圈一路上经过的所有边 <span class="math inline">\(f\)</span> 的值都是 <span class="math inline">\(+1\)</span> （沿着反方向绕都是 <span class="math inline">\(-1\)</span>），于是 <span class="math inline">\(f^C\)</span> 在 <span class="math inline">\(C\)</span> 包含的每个顶点上 1 进 1 出，在 <span class="math inline">\(C\)</span> 之外的顶点上 0 进 0 出，从而 <span class="math inline">\(f^C\in\lozenge\)</span>。反之，我们断言 <span class="math inline">\(\lozenge\)</span> 可以由所有的环函数 <span class="math inline">\(f^C\)</span> 张成，这就是为什么 <span class="math inline">\(\lozenge\)</span> 叫做环空间。</p><p>设 <span class="math inline">\(\theta\in\lozenge\)</span>，定义 <span class="math inline">\(\theta\)</span> 的支集为 <span class="math display">\[\mathrm{supp}(\theta)=\{e\inE\mid\theta(e)\ne0\}.\]</span> 如果 <span class="math inline">\(\mathrm{supp}(\theta)\)</span>非空，则它必然包含一个回路，否则 <span class="math inline">\(\mathrm{supp}(\theta)\)</span>构成的子图中必然有一个叶顶点 （度数恰好为1），从而这一点处的散度不可能为 0，矛盾！于是 <span class="math inline">\(\mathrm{supp}(\theta)\)</span> 包含一个回路 <span class="math inline">\(C\)</span>，我们可以选择合适的常数 <span class="math inline">\(\alpha\)</span> 使得 <span class="math inline">\(\widetilde{\theta}=\theta-\alpha f^C\)</span>在某个 <span class="math inline">\(e\in C\)</span> 上为 0，则 <span class="math inline">\(\widetilde{\theta}\)</span> 的支集严格小于 <span class="math inline">\(\theta\)</span>。对 <span class="math inline">\(\widetilde{\theta}\)</span>重复此操作一直下去必然可以在有限次后将支集变为空集，这就证明了 <span class="math inline">\(\theta\)</span> 可以表示为形如 <span class="math inline">\(f^C\)</span> 的线性组合。</p><p>星空间也有一个类似的形象描述。对每个顶点 <span class="math inline">\(x\)</span>，我们也有一个 <span class="math inline">\(\ell^2_{-}(E)\)</span> 上的函数与之对应：<span class="math inline">\(\sum_{e^-=x}c(e)\chi^e\)</span>。这个函数很直观，它的支集是从<span class="math inline">\(x\)</span> 出发伸出去的星状结构。</p><p><img style="margin:0px auto;display:block" src="/images/electric-network/div.svg" width="150"></p><p>对任何 <span class="math inline">\(\theta\in\ell^2_{-}(E)\)</span>，我们有 <span class="math display">\[(\mathrm{div}\,\theta)(x)=\sum_{e^-=x}\theta(e)=\sum_{e^-=x}\left(c(e)\chi^e,\theta\right)_E=\left(\sum_{e^-=x}c(e)\chi^e,\theta\right)_E.\]</span>由于 <span class="math inline">\(\theta\in\lozenge\)</span> 当且仅当<span class="math inline">\((\mathrm{div}\,\theta)(x)=0\)</span> 对所有<span class="math inline">\(\in V\)</span> 成立，也就是 <span class="math inline">\(\theta\)</span> 与所有 <span class="math inline">\(\sum_{e^-=x}c(e)\chi^e\)</span>正交，所以我们证明了 <span class="math inline">\(\left\{\sum_{e^-=x}c(e)\chi^e\mid x\inV\right\}\)</span> 可以生成 <span class="math inline">\(\bigstar\)</span>。</p><h2 id="补充阅读">补充阅读</h2><p>这一节一下出现了好几个算子，以及环空间和星空间的概念，对初次接触的人来说有点名词爆炸，所以这里补充一段阅读材料：</p><p>我们在高中物理所学的基尔霍夫定律（电流、电压）是基尔霍夫于 1845年发表的，那时他只有 21 岁。两年后的 1847年基尔霍夫发表了另一篇文章，系统阐述了怎样用求解线性方程组的方法计算电路中的电流。第二篇文章很有意思，基尔霍夫证明了在一个有<span class="math inline">\(v\)</span> 个中间节点和 <span class="math inline">\(e\)</span>条边的电路中，我们可以对每个中间节点列出一个方程（流入=流出），这样得到的<span class="math inline">\(v\)</span>个方程是线性相关的，但是删掉任何一个方程以后剩下的 <span class="math inline">\(v-1\)</span>个方程都是线性无关的；此外我们还可以对每个“基本回路”列出一个方程（电压绕回路一圈改变为0），得到 <span class="math inline">\(\mu\)</span> 个线性方程，其中<span class="math inline">\(\mu\)</span>是电路包含的“基本回路”的个数。这 <span class="math inline">\(\mu\)</span> 个方程和前面 <span class="math inline">\(v-1\)</span>个方程合起来仍然是线性无关的，于是我们就有了 <span class="math inline">\(\mu+v-1\)</span>个独立的方程，这些方程就足以解出所有边上的电流！</p><p>什么是基本回路？直观上理解很容易：下图标注了 <span class="math inline">\(\alpha,\beta,\gamma\)</span>三个基本回路，它们不能拆解为更小回路的组合：</p><p><img style="margin:0px auto;display:block" src="/images/electric-network/basic_cycles.svg" width="350"></p><p>基本回路的准确定义是，取 <span class="math inline">\(G\)</span>的一个生成树 <span class="math inline">\(T\)</span>，则对任何 <span class="math inline">\(e\in G\backslash T\)</span>，将 <span class="math inline">\(e\)</span> 加入 <span class="math inline">\(T\)</span> 以后都会形成某个回路 <span class="math inline">\(\chi^e\)</span>，<span class="math inline">\(\chi^e\)</span> 就是一个基本回路。</p><ol type="1"><li>由于 <span class="math inline">\(T\)</span> 包含 <span class="math inline">\(v-1\)</span> 条边，所以 <span class="math inline">\(G\backslash T\)</span> 有 <span class="math inline">\(e-v+1\)</span> 条边，所以这样的回路有 <span class="math inline">\(e-v+1\)</span> 个。</li><li>这 <span class="math inline">\(e-v+1\)</span>个回路是线性无关的，因为它们当中任何一个都不能表示为其它回路的线性组合。这是因为，假设基本回路<span class="math inline">\(\chi^e\)</span> 是由 <span class="math inline">\(T\cup\{e\}\)</span>得到的，由于其它回路的支集都不含 <span class="math inline">\(e\)</span>，所以它们的组合的支集也不会包含 <span class="math inline">\(e\)</span>。</li><li>于是环空间 <span class="math inline">\(\lozenge\)</span> 中包含<span class="math inline">\(e-v+1\)</span> 个线性无关的回路，从而 <span class="math inline">\(\dim\lozenge\geq e-v+1\)</span>。</li><li>我们来证明 <span class="math inline">\(\dim\bigstar=v-1\)</span>，于是由 <span class="math inline">\(\dim\ell^2_{-}(E)=e\)</span> 即得 <span class="math inline">\(\dim\lozenge= e-v+1\)</span>。这是因为 <span class="math inline">\(\mathrm{Ker}\,\nabla\)</span> 显然是 1维的：它由所有 <span class="math inline">\(V\)</span>上的常函数构成，所以 <span class="math display">\[\dim\bigstar=\dim\ell^2(E)-\dim\mathrm{Ker}\,\nabla=v-1.\]</span></li></ol><p>总结一下：</p><ol type="1"><li>环空间的维数是 <span class="math inline">\(\dim\bigstar=e-v+1\)</span>，由基本回路张成，对每一个基本回路可以利用电压定律列一个独立方程。</li><li>星空间的维数是 <span class="math inline">\(v-1\)</span>，由任何<span class="math inline">\(v-1\)</span> 个中间节点张成，对这 <span class="math inline">\(v-1\)</span>个顶点中的每一个都可以用电流定律列一个独立方程。</li></ol><p>1, 2 合起来正好可以解出全部 <span class="math inline">\(e\)</span>条边上的电流！</p><h1 id="网络中的流">2 网络中的流</h1><h2 id="流和电流">流和电流</h2><p>仍然设 <span class="math inline">\(\mathcal{N}=(G,c)\)</span>是一个网络，<span class="math inline">\(Z\)</span> 是 <span class="math inline">\(V\)</span> 的一个子集，<span class="math inline">\(a\notin Z\)</span> 是一个顶点。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.1</span>.</span><span class="statement-spah"> </span>我们称 <span class="math inline">\(\theta\in\ell_{-}^2(E)\)</span> 是一个从 <span class="math inline">\(a\)</span> 到 <span class="math inline">\(Z\)</span> 的流，如果以下两个条件成立：</p><ol type="1"><li><span class="math inline">\((\mathrm{div}\,\theta)(a)\geq0\)</span>。</li><li>对任何 <span class="math inline">\(x\notin \{a\}\cup Z\)</span> 有<span class="math inline">\((\mathrm{div}\,\theta)(x)=0\)</span>。</li></ol><p><span class="math inline">\(a\)</span> 叫做 <span class="math inline">\(\theta\)</span> 的源点，<span class="math inline">\(Z\)</span> 叫做 <span class="math inline">\(\theta\)</span> 的汇点。</p><p>定义流 <span class="math inline">\(\theta\)</span> 的强度为从源点<span class="math inline">\(a\)</span> 流入网络的量： <span class="math display">\[\mathrm{strength}(\theta)=\sum_{x\sim a}\theta(a,x).\]</span> 我们也把 <span class="math inline">\(\mathrm{strength}(\theta)\)</span> 记作 <span class="math inline">\(\|\theta\|\)</span>，如果有 <span class="math inline">\(\|\theta\|=1\)</span> 成立，就称 <span class="math inline">\(\theta\)</span>是一个<strong>单位流</strong>。</p><p>此外定义 <span class="math inline">\(\theta\)</span> 的能量为 <span class="math display">\[\mathcal{E}(\theta)=(\theta,\,\theta)_E.\]</span></p></div><p>此定义自动蕴含了 <span class="math inline">\(\sum_{z\inZ}(\mathrm{div}\,\theta)(z)=-(\mathrm{div}\,\theta)(a)\leq0\)</span>：考虑<span class="math inline">\(V\)</span> 上的常函数 <span class="math inline">\(1\)</span>，则 <span class="math inline">\(\nabla1=0\)</span>，于是 <span class="math display">\[0=(\nabla1,\,\theta)_E=(1,\,\mathrm{div}\,\theta)_V=(\mathrm{div}\,\theta)(a)+\sum_{z\inZ}(\mathrm{div}\,\theta)(z).\]</span> 即对整个网络来说，从 <span class="math inline">\(a\)</span> 流出的量等于流入 <span class="math inline">\(Z\)</span> 的量，中间没有任何“淤积”。</p><div class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\theta\)</span> 是一个从 <span class="math inline">\(a\)</span> 到 <span class="math inline">\(Z\)</span> 的流，如果还有 <span class="math inline">\(\theta=\nabla g\in\bigstar\)</span> 成立，就称<span class="math inline">\(\theta\)</span>是一个<strong>电流</strong>，<span class="math inline">\(g\)</span> 叫做<span class="math inline">\(\theta\)</span> 的电势。</p></div><p>我们总结一下流和电流的特点：</p><ol type="1"><li>你可以把 <span class="math inline">\(a\)</span>理解为电源正极，<span class="math inline">\(Z\)</span>理解为网络接地的部分。</li><li>流函数要求对任何 <span class="math inline">\(x\notin \{a\}\cupZ\)</span> 有 <span class="math inline">\((\mathrm{div}\,\theta)(x)=0\)</span>等价于物理中的基尔霍夫电流定律：任何中间节点的流量守恒。</li><li>电流函数要求 <span class="math inline">\(\theta=\nablag\in\bigstar\)</span> 等价于物理中的欧姆定律，即电流 <span class="math inline">\(\theta\)</span> 等于电势差除以电阻 <span class="math inline">\(r(e)\)</span>。</li></ol><h2 id="转移电流矩阵">转移电流矩阵</h2><p>在本文中，我们最关心的电流函数是将一条边 <span class="math inline">\(e=\{x,y\}\)</span> 的端点 <span class="math inline">\(x\)</span> 通入单位电流，另一端点 <span class="math inline">\(y\)</span> 接地时网络中对应的电流函数，此函数记作<span class="math inline">\(i^e\)</span>。对任一边 <span class="math inline">\(e'\)</span>，<span class="math inline">\(i^e(e')\)</span> 就是此时流过 <span class="math inline">\(e'\)</span> 的电流量。</p><div class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题2.3</span>.</span><span class="statement-spah"> </span><span class="math inline">\(\chi^e\)</span> 在 <span class="math inline">\(\bigstar\)</span> 上的正交投影即为 <span class="math inline">\(i^e\)</span>。</p></div><p><strong>证明</strong>：显然 <span class="math inline">\(\chi^e\)</span> 是从 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的单位流，且在任何 <span class="math inline">\(z\notin e\)</span> 处散度为 0。<span class="math inline">\(\chi^e\)</span> 在 <span class="math inline">\(\bigstar\)</span> 的投影是通过减去一个 <span class="math inline">\(\mathrm{div}\)</span> 处处为 0的流得到的，这不改变任何顶点处的散度值，所以投影分量仍然是从 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 的单位流且在任何 <span class="math inline">\(z\notin e\)</span> 处散度为 0。又由于投影分量属于<span class="math inline">\(\bigstar\)</span>所以还满足欧姆定律，从而必然是电流 <span class="math inline">\(i^e\)</span>。<span class="math inline">\(\blacksquare\)</span></p><div id="iee" class="statement proposition plain"><p><span class="statement-heading"><span class="statement-label">命题2.4</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(e,\,e'\)</span> 是两条边，则 <span class="math display">\[i^e(e')=c(e')(i^e,i^{e'})_E.\]</span></p></div><p><strong>证明</strong>：记 <span class="math inline">\(P_\bigstar\)</span> 为从 <span class="math inline">\(\ell^2_{-}(E)\)</span> 到 <span class="math inline">\(\bigstar\)</span> 的投影算子，则 <span class="math inline">\(P_\bigstar\)</span> 是自共轭算子以及 <span class="math inline">\(P_\bigstar^2=P_\bigstar\)</span>，从而 <span class="math display">\[(i^e,i^{e'})_E=(P_\bigstar\chi^e,P_\bigstar\chi^{e'})_E=(P_\bigstar\chi^e,\chi^{e'})_E=(i^e,\chi^{e'})_E=r(e')i^e(e').\]</span>即得结论。<span class="math inline">\(\blacksquare\)</span></p><div id="def-transfer-current" class="statement definition plain"><p><span class="statement-heading"><span class="statement-label">定义2.5</span>.</span><span class="statement-spah"> </span>记 <span class="math inline">\(Y(e,e')=i^e(e')\)</span>，则矩阵 <span class="math inline">\(\big(Y(e,e')\big)_{e,e'\in E}\)</span>叫做转移电流矩阵。<span class="math inline">\(Y(e,e')\)</span>满足互反律 <span class="math display">\[Y(e,e')r(e')=Y(e',e)r(e)=(i^e,i^{e'})_E.\]</span></p></div><div id="unit-flow" class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论2.6</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(x,\,y\)</span> 是两个顶点，在所有从 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span>的单位流中，电流的能量最小。并且电流的能量等于 <span class="math inline">\(x,\,y\)</span> 之间的等效电阻。</p></div><p><strong>证明</strong>：设 <span class="math inline">\(f,g\)</span>是任何这样的两个单位流，则 <span class="math inline">\(f-g\)</span>处处净流量为 0，即 <span class="math inline">\(f-g\in\lozenge\)</span>，从而 <span class="math inline">\(P_\bigstar f = P_\bigstar g = i\)</span>，所以电流<span class="math inline">\(i\)</span> 是唯一确定的。注意到 <span class="math inline">\((i, f-i)_E=0\)</span>，所以 <span class="math display">\[\mathcal{E}(f)=(f,\,f)_{E} = (i,i)_{E} +(f-i,f-i)_{E}\geq (i,i)_{E}=\mathcal{E}(i).\]</span>于是我们证明了电流能量的最小性。为了证明它等于 <span class="math inline">\(x,\, y\)</span> 之间的等效电阻，可以利用 <span class="math display">\[(i,i)_E = (i, \chi^e)_E = r(x,y)i(x,y)\chi^e(x,y)= r(x,y)i(x,y)= U(x)-U(y).\]</span> 其中 <span class="math inline">\(U(x)-U(y)\)</span> 是 <span class="math inline">\(x,\,y\)</span> 之间的电势差，而流入网络的总电流是1，所以这个电势差等于网络的等效电阻。</p><p>由此结论可以进一步得出 <strong>Rayleigh单调原理</strong>：如果把一个网络的电阻调低的话，则原来的单位电流会变成一个能量更小的单位流，而此单位流的能量又大于等于新网络对应的单位电流的能量，所以新网络的等效电阻相比之前是下降的。</p><h1 id="概率解释">3 概率解释</h1><p>在这一节中，我们会给出电势、电流对应的概率解释。假设 <span class="math inline">\(a\)</span> 是一个顶点，<span class="math inline">\(Z\)</span> 是一个顶点集合且 <span class="math inline">\(a\notin Z\)</span>。</p><ul><li><p>我们考虑从一点 <span class="math inline">\(x\)</span>出发，转移概率为 <span class="math inline">\(P(x,y)=c(x,y)/c(x)\)</span>的随机游动 <span class="math inline">\(\{X_t,t\geq0\}\)</span>，其中<span class="math inline">\(X_0=x\)</span>。这个随机游动是可逆的 Markov链，以 <span class="math inline">\(\{c(x),x\in V\}\)</span>为平稳测度：<span class="math inline">\(c(x)P(x,y)=c(y)P(y,x)\)</span>。</p></li><li><p>我们同时考虑在 <span class="math inline">\(a\)</span>点接上电源正极，<strong>并将 <span class="math inline">\(Z\)</span>接地</strong>，则电流从 <span class="math inline">\(a\)</span> 流入并从<span class="math inline">\(Z\)</span>流出。我们将建立随机游动和这一电网络之间的联系。</p></li></ul><h2 id="电压的概率解释-第一种">电压的概率解释 （第一种）</h2><p>电压有一个很简单的解释，它是直线上随机游动中赌徒获胜/破产概率的类比。</p><p>考虑从 <span class="math inline">\(x\)</span> 出发的随机游动，设<span class="math inline">\(\tau_a\)</span> 是这一随机游动首次到达 <span class="math inline">\(a\)</span> 点的时间 （类比赌徒获胜），<span class="math inline">\(\tau_Z\)</span> 是这一随机游动首次到达集合 <span class="math inline">\(Z\)</span> 的时间 （类比赌徒输光），并考虑概率<span class="math display">\[h(x) =\mathbb{P}_x(\tau_a&lt;\tau_Z).\]</span> 其中我们规定 <span class="math inline">\(h(a)=1, h(Z)=0\)</span>，则 <span class="math inline">\(h(x)\)</span> 在任何 <span class="math inline">\(x\notin \{a\}\cup Z\)</span>上是<strong>调和</strong>的： <span class="math display">\[h(x) =\sum_{y\sim x}P(x, y)h(y).\]</span> 此即为全概率公式，下一步到某个 <span class="math inline">\(y\sim x\)</span> 的概率是 <span class="math inline">\(P(x,y)\)</span>，从 <span class="math inline">\(y\)</span> 继续出发获胜的概率是 <span class="math inline">\(h(y)\)</span>，求和即可。</p><p>现在假设 <span class="math inline">\(a\)</span> 点加上的电压大小是1，则其电势 <span class="math inline">\(v(a)=1\)</span>，由于 <span class="math inline">\(Z\)</span> 接地所以 <span class="math inline">\(v(Z)=0\)</span>。我们断言电势函数 <span class="math inline">\(v(x)\)</span> 在任何一点 <span class="math inline">\(x\notin\{a\}\cup Z\)</span> 处也是调和的： <span class="math display">\[v(x) = \sum_{y\sim x}P(x, y)v(y).\]</span>这是因为设 <span class="math inline">\(v\)</span> 对应的电流是 <span class="math inline">\(i\)</span>，则</p><p><span class="math display">\[\begin{align*}v(x) - \sum_{y\sim x}P(x, y)v(y)&amp;=\sum_{y\sim x}P(x, y)(v(x)-v(y))\\&amp;=\sum_{y\sim x}\frac{c(x,y)}{c(x)}i(x,y)r(x,y)\\&amp;=\frac{1}{c(x)}\sum_{y\sim x}i(x,y)\\&amp;=0.\end{align*}\]</span></p><p>其中最后一个等号是根据基尔霍夫定律对任何中间节点 <span class="math inline">\(x\)</span> 有 <span class="math inline">\((\mathrm{div}\,i)(x)=0\)</span>。</p><p>现在获胜概率 <span class="math inline">\(\mathbb{P}_x(\tau_a&lt;\tau_Z)\)</span> 和电势函数<span class="math inline">\(v(x)\)</span> 在 <span class="math inline">\(\{a\}\cup Z\)</span> 上有相同的边界条件，在 <span class="math inline">\((\{a\}\cup Z)^c\)</span>上都是调和的，则它俩必然是同一个函数！（提示：考虑两个函数之差并利用有限图上的调和函数必然在边界上取得最大最小值）于是我们得到</p><blockquote><p><strong>电压的概率解释</strong>：在 <span class="math inline">\(a\)</span> 加上单位 1 的电压，将 <span class="math inline">\(Z\)</span> 接地，则任一顶点 <span class="math inline">\(x\)</span> 处的电势等于从 <span class="math inline">\(x\)</span> 出发的随机游动在到达 <span class="math inline">\(Z\)</span> 之前先到达 <span class="math inline">\(a\)</span> 的概率：<span class="math inline">\(v(x)=\mathbb{P}_x(\tau_a&lt;\tau_Z)\)</span>。</p></blockquote><p>如果 <span class="math inline">\(a\)</span>处不是单位电压的话，则结论中的 <span class="math inline">\(v(x)\)</span>应替换为 <span class="math inline">\(v(x)/v(a)\)</span>。</p><h2 id="电阻电压-第二种电流的概率解释">电阻、电压（第二种）、电流的概率解释</h2><p>在这一节中，我们将使用 Green函数给出电流的概率解释，以及电压的第二种解释。</p><p>Green函数是图上拉普拉斯算子的“基本解”，用它可以表示出一般的带边界条件的调和函数。</p><p>记 <span class="math inline">\(\mathbb{P}(a\to Z)=\mathbb{P}_a(\tau_Z&lt; \tau_a^+)\)</span> 为从 <span class="math inline">\(a\)</span>出发的随机游动在返回 <span class="math inline">\(a\)</span> 之前先到达<span class="math inline">\(Z\)</span> 的概率。此概率称作从 <span class="math inline">\(a\)</span> 到 <span class="math inline">\(Z\)</span> 的<strong>逃逸概率</strong>。</p><p>仍然在 <span class="math inline">\(a\)</span> 处加上电压，<span class="math inline">\(Z\)</span> 接地，考虑此网络的电势 <span class="math inline">\(v\)</span> 和电流 <span class="math inline">\(i\)</span>。</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理3.1</span>.</span><span class="statement-spah"> </span><span class="math display">\[\frac{v(a)}{\| i\|} =\frac{1}{c(a)\mathbb{P}(a\to Z)}.\]</span></p></div><p>注意 <span class="math inline">\(v(a)/\|i\|\)</span>正是网络的等效电阻。</p><p><strong>证明</strong>：</p><p><span class="math display">\[\begin{align*}\mathbb{P}(a\to Z) &amp;= \sum_{x\sim a}P(a, x)\mathbb{P}_x(\tau_Z &lt;\tau_a)\\&amp;=\sum_{x\sima}\frac{c(a,x)}{c(a)}\left(1-\frac{v(x)}{v(a)}\right)\\&amp;=\sum_{x\sim a}\frac{c(a,x)}{c(a)}\frac{v(a)-v(x)}{v(a)}\\&amp;=\sum_{x\sim a}\frac{i(a,x)}{c(a)v(a)}\\&amp;=\frac{\|i\|}{c(a)v(a)}.\end{align*}\]</span></p><p><span class="math inline">\(\blacksquare\)</span></p><p>对任何边 <span class="math inline">\(x\sim y\)</span>，定义随机变量<span class="math inline">\(N_{x\to y}^Z\)</span> 为从 <span class="math inline">\(a\)</span> 出发的随机游动在访问 <span class="math inline">\(Z\)</span> 之前从 <span class="math inline">\(x\)</span> 走到 <span class="math inline">\(y\)</span> 的次数，则我们有如下定理：</p><div id="current-interp" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理3.2</span>.</span><span class="statement-spah"></span>设电流是单位电流：<span class="math inline">\(\|i\|=1\)</span>，此时的电势函数为 <span class="math inline">\(v\)</span>，则</p><ol type="1"><li><span class="math inline">\(v(x) = \mathcal{G}_Z(a, x)/c(x)\)</span>。</li><li><span class="math inline">\(i(x,y)=\mathbb{E}_a\left[N_{x\to y}^Z -N_{y\to x}^Z\right]\)</span>。</li></ol><p>其中 <span class="math inline">\(\mathcal{G}_Z(a, x)\)</span>是随机游动的 Green 函数，其定义为从 <span class="math inline">\(a\)</span> 出发的随机游动在到达 <span class="math inline">\(Z\)</span> 之前访问 <span class="math inline">\(x\)</span> 的期望次数： <span class="math display">\[\mathcal{G}_Z(a, x) = \sum_{0\leqk&lt;\tau_Z}\mathbb{1}_{\{X_k=x\}}.\]</span></p></div><p><strong>证明</strong>：</p><ol type="1"><li><p>首先边界条件给出了 <span class="math inline">\(\mathcal{G}_Z(a,Z)=0\)</span>。此外 <span class="math inline">\(\mathcal{G}_Z(a,a)\)</span> 是一个每次试验成功概率为 <span class="math inline">\(\mathbb{P}(a\to Z)\)</span>的几何分布的随机变量的期望，故 <span class="math display">\[\mathcal{G}_Z(a, a)=\frac{1}{\mathbb{P}(a\toZ)},\]</span> 再由上面的引理，有 <span class="math display">\[\frac{\mathcal{G}_Z(a,a)}{c(a)}=\frac{1}{c(a)\mathbb{P}(a\to Z)}=v(a).\]</span> 所以 <span class="math inline">\(\mathcal{G}_Z(a, x)/c(x)\)</span>在边界上与电势函数是一致的，只要再证明在任意中间节点 <span class="math inline">\(x\)</span> 的调和性质。注意随机游动必然是从与<span class="math inline">\(x\)</span> 相邻的顶点走过去访问 <span class="math inline">\(x\)</span>，所以 <span class="math display">\[\frac{\mathcal{G}_Z(a,x)}{c(x)}=\frac{1}{c(x)}\sum_{y\sim x}\mathbb{E}_a[N_{y\tox}^Z].\]</span> 另一方面</p><p><span class="math display">\[\begin{align*}\mathbb{E}_a[N_{y\to x}^Z]&amp;=\mathbb{E}_a\left[\sum_{0\leq t&lt;\tau_Z}\mathbb{1}_{\{ X_t=y,X_{t+1}=x\}}\right]\\&amp;=\sum_{0\leq t&lt;\tau_Z}\mathbb{P}\left[X_t=y,X_{t+1}=x\right]\\&amp;=\sum_{0\leq t&lt;\tau_Z}\mathbb{P}(X_t=y)P(y,x)\\&amp;=P(y,x)\mathbb{E}_a\left[\sum_{0\leq t&lt;\tau_Z}\mathbb{1}_{\{ X_t=y\}}\right]\\&amp;=P(y,x)\mathcal{G}_Z(a,y).\end{align*}\label{eq:cross}\]</span></p><p>所以代入求和后有</p><p><span class="math display">\[\frac{1}{c(x)}\sum_{y\sim x}\mathbb{E}_a[N_{y\tox}^Z]=\frac{1}{c(x)}\sum_{y\sim x}P(y,x)\mathcal{G}_Z(a,y)=\sum_{y\simx}P(x,y)\frac{\mathcal{G}_Z(a,y)}{c(y)}.\]</span></p><p>其中我们使用了 Markov 链的可逆性：<span class="math inline">\(c(x)P(x,y)=c(y)P(y,x)\)</span>。这就证明了 <span class="math inline">\(\mathcal{G}_Z(a, x)/c(x)\)</span>在中间节点的调和性，从而它就是电势函数，这证明了 1。</p></li><li><p>直接验证即可： <span class="math display">\[\begin{align*}\mathbb{E}_a\left[N_{x\to y}^Z -N_{y\tox}^Z\right]&amp;=P(x,y)\mathcal{G}_Z(a,x)-P(y,x)\mathcal{G}_Z(a,y)\\&amp;=P(x,y)c(x)v(x)-P(y,x)c(y)v(y)\\&amp;=c(x,y)(v(x)-v(y))\\&amp;=i(x,y).\end{align*}\]</span></p></li></ol><p><span class="math inline">\(\blacksquare\)</span></p><h1 id="wilson-生成树算法">4 Wilson 生成树算法</h1><p>这一节的目的是介绍怎样将一条给定边 <span class="math inline">\(e\)</span> 属于一个随机生成树 <span class="math inline">\(T\)</span> 的概率 <span class="math inline">\(\mathbb{P}(e\in T)\)</span>表示为随机游动中的概率。这里的关键是 Wilson算法，它通过<strong>擦圈的随机游动</strong>按照一定的权重分布在全体生成树中随机地取样，这里一个生成树<span class="math inline">\(T\)</span> 的权重 <span class="math inline">\(w(T)=\prod_{e\in T}c(e)\)</span>，任一生成树 <span class="math inline">\(T_0\)</span> 被选中的概率为 <span class="math inline">\(w(T_0)/\sum_{T}w(T)\)</span>。</p><p>在下文中“随机生成树”一词均指服从上述权重分布的随机生成树。</p><p>Wilson 算法的步骤如下：</p><ol type="1"><li>任取一个根节点 <span class="math inline">\(r\)</span>，维护一个树<span class="math inline">\(T\)</span>，初始时 <span class="math inline">\(T=\{r\}\)</span>。</li><li>任取一个顶点 <span class="math inline">\(v\notin T\)</span>，从<span class="math inline">\(v\)</span> 出发作 <span class="math inline">\(G\)</span> 上的擦圈随机游动，直到随机游动撞到<span class="math inline">\(T\)</span> 为止，然后将随机游动的路径 <span class="math inline">\(p\)</span> 加入 <span class="math inline">\(T\)</span> 中：<span class="math inline">\(T=T\cupp\)</span>。</li><li>重复步骤 2 直到 <span class="math inline">\(T\)</span>是一个生成树为止。</li></ol><blockquote><p>下面这个动画演示了 Wilson算法的过程，你可以随时单击画布来重启动画。</p></blockquote><script type="text/javascript" src="/code/wilson_small.js"></script><div data-align="center"><canvas id="wilson" width="572" height="292"></canvas></div><p>Wilson 算法正确性的证明比较繁琐，这里不再赘述，你可以参考我 <a href="/wilson-uniform-spanning-tree-algorithm">之前的一篇文章</a>。初次遇到这个算法的话可以先跳过证明，只记住结论。这个算法的重点就是初始时的根节点是可以任意选取的，每次进行擦圈的随机游动时选择的出发顶点也可以是任意的，这都不影响得到的生成树<span class="math inline">\(T\)</span> 的分布。</p><div id="lerw" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理4.1</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\mathcal{N}=(G,c)\)</span> 是一个网络，给定边<span class="math inline">\(e=(x,y)\in E\)</span>，在 <span class="math inline">\(x\)</span> 处加上电源并将 <span class="math inline">\(y\)</span> 接地，使得流入网络的电流是单位流 <span class="math inline">\(i^e\)</span>。则对 <span class="math inline">\(G\)</span> 的随机生成树 <span class="math inline">\(T\)</span>，<span class="math inline">\(e\)</span>属于 <span class="math inline">\(T\)</span> 的概率即为此时 <span class="math inline">\(e\)</span> 中的电流量 <span class="math inline">\(i^e(e)\)</span>，它也等于从 <span class="math inline">\(x\)</span> 出发的随机游动首次访问 <span class="math inline">\(y\)</span> 是从边 <span class="math inline">\(e\)</span> 走过去的这一事件的概率： <span class="math display">\[\mathbb{P}(e \in T) = i^e(e) =\mathbb{P}_x\left[\text{the first visit to $y$ is across$(x,y)$}\right].\]</span></p></div><blockquote><p>一个非常出人意料的结论，它把生成树、随机游动和电网络统一在一起。</p></blockquote><p><strong>证明</strong>：在 Wilson 算法中将初始根节点选为 <span class="math inline">\(y\)</span>，并将第一次出发作擦圈随机游动的顶点选为<span class="math inline">\(x\)</span>，则此随机游动首次到达 <span class="math inline">\(y\)</span> 有两种可能：</p><ol type="1"><li>是从边 <span class="math inline">\((x,y)\)</span> 走到 <span class="math inline">\(y\)</span> 的，此随机游动的路径属于 <span class="math inline">\(T\)</span>，自然也有 <span class="math inline">\(e\in T\)</span>。</li><li>是从其它边走到 <span class="math inline">\(y\)</span>的，则此随机游动的路径属于 <span class="math inline">\(T\)</span>但不可能有 <span class="math inline">\(e\in T\)</span>，否则 <span class="math inline">\(T\)</span> 中会出现回路。</li></ol><p>于是我们证明了 <span class="math inline">\(e\in T\)</span> 当且仅当从<span class="math inline">\(x\)</span> 出发的随机游动首次到达 <span class="math inline">\(y\)</span> 是从边 <span class="math inline">\(e\)</span> 走过去的。</p><p>另一方面在 <a href="#current-interp" title="定理 3.2">定理 3.2</a>中取 <span class="math inline">\(Z=\{y\}\)</span> 有</p><p><span class="math display">\[i^e(x,y)=\mathbb{E}_x\left[N^{\{y\}}_{x\to y} - N^{\{y\}}_{y\tox}\right].\]</span></p><p>注意到从 <span class="math inline">\(x\)</span>出发的随机游动不可能在到达 <span class="math inline">\(y\)</span> 之前从<span class="math inline">\(y\)</span> 走到 <span class="math inline">\(x\)</span>，所以 <span class="math inline">\(N^{\{y\}}_{y\to x}=0\)</span>。同时它在到达 <span class="math inline">\(y\)</span> 之前从 <span class="math inline">\(x\)</span> 走到 <span class="math inline">\(y\)</span> 的次数只能是 0 或者 1，所以 <span class="math inline">\(N^{\{y\}}_{x\to y}\in\{0,1\}\)</span>，从而 <span class="math display">\[\mathbb{E}_xN^{\{y\}}_{x\toy}=\mathbb{P}_x(N^{\{y\}}_{x\to y}=1)=\mathbb{P}_x\left[\text{the firstvisit to $y$ is across $(x,y)$}\right].\]</span> 这就完成了证明。</p><h1 id="图的收缩">5 图的收缩</h1><p>设 <span class="math inline">\(\mathcal{N}=(G,c)\)</span>是一个网络，<span class="math inline">\(F\subset E\)</span> 是边的子集且<span class="math inline">\(F\)</span> 不含回路（不考虑边的方向），<span class="math inline">\(G\)</span> 关于 <span class="math inline">\(F\)</span> 的图收缩是一个图变换：如果 <span class="math inline">\(G\)</span> 中的两个顶点可以被 <span class="math inline">\(F\)</span>中的路径连接，则它们在新图中坍缩为同一个顶点；并且 <span class="math inline">\(F\)</span> 中的每条边 <span class="math inline">\(f\)</span> 的两个端点变成新顶点的一条自边(loop)。这样得到的新图记作 <span class="math inline">\(G/F\)</span>。注意当一条边 <span class="math inline">\(e\notin F\)</span> 如果和 <span class="math inline">\(F\)</span> 中的边构成回路的话，它在 <span class="math inline">\(G/F\)</span> 中也会变成自边。</p><p><img style="margin:0px auto;display:block" src="/images/electric-network/graph_reduction.svg" width="400"></p><p>在上图中，虽然 <span class="math inline">\(e_1,e_2\)</span> 不属于<span class="math inline">\(F\)</span>，但是由于它们的两端可以被 <span class="math inline">\(F\)</span> 中的路径连接，所以在收缩后 <span class="math inline">\(e_1,e_2\)</span>也都变成了自边。我们保留这些自边，于是在收缩变换下 <span class="math inline">\(G\)</span> 的边集 <span class="math inline">\(E\)</span> 与 <span class="math inline">\(G/F\)</span> 的边集 <span class="math inline">\(\widehat{E}\)</span> 一一对应。</p><p>严格的说图的收缩是 <span class="math inline">\(G\)</span> 的一个分割(partition)：在 <span class="math inline">\(G\)</span> 的顶点集 <span class="math inline">\(V\)</span> 上定义等价关系 <span class="math inline">\(\cong\)</span> 为：<span class="math inline">\(x\cong y\)</span> 当且仅当 <span class="math inline">\(x\)</span> 与 <span class="math inline">\(y\)</span> 可以被 <span class="math inline">\(F\)</span> 中的路径连接，则 <span class="math inline">\(G/F\)</span> 的顶点是 <span class="math inline">\(V/\cong\)</span> 下的等价类，<span class="math inline">\(G\)</span> 中的边 <span class="math inline">\(e=(x,y)\)</span> 在 <span class="math inline">\(G/F\)</span> 中的边变为 <span class="math inline">\(e=([x],[y])\)</span>，其中 <span class="math inline">\([x]\)</span> 是 <span class="math inline">\(x\)</span> 所在的等价类。</p><p>我们想知道图 <span class="math inline">\(G\)</span> 中的电流函数<span class="math inline">\(i^e\)</span> 和图 <span class="math inline">\(G/F\)</span> 中的电流函数 <span class="math inline">\(\widehat{i^e}\)</span> 之间的关系。这里需要假定<span class="math inline">\(e\)</span> 在 <span class="math inline">\(G/F\)</span> 中没有变成一条自边。收缩 <span class="math inline">\(F\)</span> 以后 <span class="math inline">\(i^e\)</span> 仍然是 <span class="math inline">\(G/F\)</span> 中从 <span class="math inline">\(e\)</span>的一端到另一端的单位流，但一般不再是电流。根据 <a href="#unit-flow" title="推论 2.6">推论 2.6</a>，<span class="math inline">\(\widehat{i^e}\)</span> 应该是 <span class="math inline">\(i^e\)</span> 在 <span class="math inline">\(G/F\)</span> 的星空间 <span class="math inline">\(\widehat{\bigstar}\)</span>上的投影分量，所以我们需要找出这个投影映射。</p><p>下面的论证读起来会有点让人恼火，但它的直观含义并不难理解：<span class="math inline">\(i^e\)</span> 不是 <span class="math inline">\(G/F\)</span> 中的电流的原因是，<span class="math inline">\(i^e\)</span> 可能在某些 <span class="math inline">\(F\)</span> 中的边上的值不是 0，而这些边在 <span class="math inline">\(G/F\)</span> 中变成了自边，自边的电流应该是0。所以为了从 <span class="math inline">\(i^e\)</span> 得到 <span class="math inline">\(\widehat{i^e}\)</span>，我们可以在某些 <span class="math inline">\(F\)</span>中的边两端加上电压，使得它们产生的电流可以和 <span class="math inline">\(i^e\)</span> 在 <span class="math inline">\(F\)</span> 上的电流抵消，这样处理后的 <span class="math inline">\(i^e\)</span> 转到 <span class="math inline">\(G/F\)</span> 中就是我们想要的电流了。即我们给<span class="math inline">\(i^e\)</span> 减去 <span class="math inline">\(Z=\text{span}\{i^f,f\in F\}\)</span>中的一个电流，这相当于取 <span class="math inline">\(i^e\)</span> 在<span class="math inline">\(Z\)</span> 的正交补 <span class="math inline">\(Z^\bot\)</span> 上的投影分量。由于 <span class="math inline">\(F\)</span> 中的边在 <span class="math inline">\(G/F\)</span> 中变成了自边，所以每个 <span class="math inline">\(i^f\)</span>都是从单个顶点流入流出，不会影响任何顶点处的守恒性。</p><p>我们下面就来论证上面这个直观分析是正确的。论证细节比较琐碎，如果理解了想法的话跳过去也不影响阅读。</p><p>记 <span class="math inline">\(\chi^F=\{\chi^f,f\inF\}\)</span>，<span class="math inline">\(Z=\mathrm{span}\{i^f,f\inF\}=P_\bigstar\chi^F\)</span>，则 <span class="math inline">\(Z\subset\bigstar\)</span>。我们来证明对 <span class="math inline">\(G/F\)</span> 的环空间 <span class="math inline">\(\widehat{\lozenge}\)</span> 有 <span class="math display">\[\widehat{\lozenge} = \lozenge + \chi^F.\]</span>首先若 <span class="math inline">\(C\)</span> 是 <span class="math inline">\(G\)</span> 中的环： <span class="math display">\[v_1\xrightarrow{e_1}v_2\xrightarrow{e_2}\cdots\xrightarrow{e_{k-1}}v_k\xrightarrow{e_k}v_1.\]</span></p><p>那自然有</p><p><span class="math display">\[[v_1]\xrightarrow{e_1}[v_2]\xrightarrow{e_2}\cdots\xrightarrow{e_{k-1}}[v_k]\xrightarrow{e_k}[v_1].\]</span></p><p>从而 <span class="math inline">\(C\)</span> 也是 <span class="math inline">\(G/F\)</span> 中的环，其对应的 <span class="math inline">\(f^C\in\widehat{\lozenge}\)</span>。此外 <span class="math inline">\(F\)</span> 中的边在 <span class="math inline">\(G/F\)</span> 变成自边，所以 <span class="math inline">\(\chi^F\)</span> 也属于 <span class="math inline">\(\widehat{\lozenge}\)</span>。即 <span class="math inline">\(\widehat{\lozenge} \supseteq \lozenge +\chi^F\)</span>。</p><p>反之对 <span class="math inline">\(G/F\)</span> 中的一个环 <span class="math inline">\(C_{G/F}\)</span>，我们显然可以通过适当插入 <span class="math inline">\(F\)</span> 中的边来得到 <span class="math inline">\(G\)</span> 中的一个环 <span class="math inline">\(C\)</span> （把每个等价类顶点展开为由 <span class="math inline">\(F\)</span> 中的边组成的路径即可），对应的 <span class="math inline">\(f^C\)</span> 是 <span class="math inline">\(f^{C_{G/F}}\)</span> 加上一些 <span class="math inline">\(\chi^f\)</span> 的和，所以 <span class="math inline">\(\widehat{\lozenge} \subseteq \lozenge +\chi^F\)</span>，从而反向的包含关系也成立，二者确实相等。</p><p>现在我们有 <span class="math display">\[\ell^2_{-}(E) =\bigstar\oplus\lozenge=\widehat{\bigstar}\oplus\widehat{\lozenge}.\]</span>以及 <span class="math inline">\(\widehat{\lozenge}\supseteq\lozenge\)</span>，从而<span class="math inline">\(\widehat{\bigstar}\subseteq\bigstar\)</span>。所以我们进一步有<span class="math display">\[\widehat{\lozenge}=(\bigstar\cap\widehat{\lozenge})\oplus\lozenge.\]</span></p><blockquote><p>上式右边显然是个直和，且包含在左边中。为了看出左边也包含在右边中，设<span class="math inline">\(x\in\widehat{\lozenge}=y+z\)</span>，其中<span class="math inline">\(y\in\bigstar,z\in\lozenge\)</span>，显然<span class="math inline">\(y=x-z\in\bigstar\cap\widehat{\lozenge}\)</span>。</p></blockquote><p>从而 <span class="math display">\[\ell^2_{-}(E)=\widehat{\bigstar}\oplus\widehat{\lozenge}=\widehat{\bigstar}\oplus(\bigstar\cap\widehat{\lozenge})\oplus\lozenge.\]</span>我们来证明中间的 <span class="math inline">\(\bigstar\cap\widehat{\lozenge}\)</span> 等于 <span class="math inline">\(Z=P_\bigstar\chi^F\)</span>。为此只要注意到 <span class="math display">\[\bigstar\cap\widehat{\lozenge} =P_{\bigstar}\widehat{\lozenge}=P_{\bigstar}\lozenge +P_{\bigstar}\chi^F=Z.\]</span> 于是 <span class="math display">\[\ell^2_{-}(E) =\widehat{\bigstar}\oplusZ\oplus\lozenge.\]</span> 所以对 <span class="math inline">\(G\)</span>的一条边 <span class="math inline">\(e\)</span>，如果它在 <span class="math inline">\(G/F\)</span> 中没有变成一条自边的话，则电流 <span class="math inline">\(i^e\)</span> 和 <span class="math inline">\(\widehat{i^e}\)</span> 的关系为 <span class="math display">\[\widehat{i^e}=P_{\widehat{\bigstar}}(\chi^e)=P_{Z}^\botP_{\bigstar}\chi^F=P_{Z}^\bot i^e.\]</span></p><p>至此我们就验证了之前的直观想法。</p><p>接下来是一个引理：</p><div class="statement lemma plain"><p><span class="statement-heading"><span class="statement-label">引理5.1</span>.</span><span class="statement-spah"> </span>当 <span class="math inline">\(F\)</span> 不含回路时，<span class="math inline">\(G\)</span> 的所有包含 <span class="math inline">\(F\)</span> 的生成树 <span class="math inline">\(\{T_G, F\subset T_G\}\)</span> 与 <span class="math inline">\(G/F\)</span> 的所有生成树 <span class="math inline">\(\{T_{G/F}\}\)</span> 一一对应，且 <span class="math display">\[w(T_G)=\prod_{f\in F}c(f)\cdotw(T_{G/F}).\]</span> 于是对任何 <span class="math inline">\(e\inE\)</span> 有 <span class="math display">\[\mathbb{P}(e\in T_G \,\big|\, F\subset T_G) = \mathbb{P}(e\in T_{G/F})=\widehat{i^e}(e).\]</span>其中 <span class="math inline">\(\widehat{i^e}\)</span> 是 <span class="math inline">\(G/F\)</span> 上的单位流 <span class="math inline">\(\chi^e\)</span> 对应的电流函数。</p></div><p><strong>证明</strong>：首先不难验证对 <span class="math inline">\(G\)</span> 的任何边集 <span class="math inline">\(C\)</span>，<span class="math inline">\(C\cupF\)</span> 包含回路当且仅当 <span class="math inline">\(C\)</span> 在<span class="math inline">\(G/F\)</span> 中包含回路。这是因为如果 <span class="math inline">\(C\cup F\)</span>包含回路的话，那么对回路的顶点取等价类以后自然得到了一个 <span class="math inline">\(G/F\)</span> 中的回路。反之如果 <span class="math inline">\(C\)</span> 在 <span class="math inline">\(G/F\)</span> 中包含回路的话，那么适当插入 <span class="math inline">\(F\)</span> 中的边以后就可以得到 <span class="math inline">\(G\)</span> 的回路，即 <span class="math inline">\(C\cup F\)</span> 是包含回路的。</p><p>于是我们得到 <span class="math inline">\(T_{G/F}\)</span> 是 <span class="math inline">\(G/F\)</span> 的生成树当且仅当 <span class="math inline">\(T_G = T_{G/F}\cup F\)</span> 是 <span class="math inline">\(G\)</span> 的生成树。</p><p>由于 <span class="math inline">\(\{T_G,F\subset T_G\}\)</span>上的分布是条件分布 <span class="math inline">\(\mathbb{P}(\cdot\,\big|\,F\subset T_G)\)</span>，所以当 <span class="math inline">\(T_G\leftrightarrow T_{G/F}\)</span> 时有 <span class="math inline">\(\mathbb{P}(e\in T_G \,\big| \, F\subset T_G) =\mathbb{P}(e\in T_{G/F})\)</span>。结合 <a href="#lerw" title="定理 4.1">定理 4.1</a>，引理的成立就是显然的事情了。<span class="math inline">\(\blacksquare\)</span></p><p>于是结合 <a href="#iee" title="命题 2.4">命题 2.4</a>我们有如下定理：</p><div id="contraction" class="statement theorem plain"><p><span class="statement-heading"><span class="statement-label">定理5.2</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(F\subset E\)</span> 不含回路，<span class="math inline">\(e\notin F\)</span> 且与 <span class="math inline">\(F\)</span> 中的边不构成回路，<span class="math inline">\(T_G\)</span> 是 <span class="math inline">\(G\)</span> 的随机生成树，则 <span class="math inline">\(G/F\)</span> 中的单位电流 <span class="math inline">\(\widehat{i^e}\)</span> 是 <span class="math inline">\(G\)</span> 中单位电流 <span class="math inline">\(i^e\)</span> 在子空间 <span class="math inline">\(Z^\bot\)</span> 上的正交投影： <span class="math inline">\(\widehat{i^e}=P_{Z}^\bot i^e\)</span>。于是 <span class="math display">\[\mathbb{P}(e\in T_G \,\big| \, F\subset T_G) =\widehat{i^e}(e)=c(e)(\widehat{i^e},\widehat{i^e})_{\widehat{E}}=c(e)\big\|P_Z^\boti^e\big\|^2.\]</span> 其中 <span class="math inline">\(Z\)</span> 是由<span class="math inline">\(\{i^f,f\in F\}\)</span> 张成的子空间，<span class="math inline">\(P_Z^\bot\)</span> 是到 <span class="math inline">\(Z^\bot\)</span> 的正交投影。</p></div><h1 id="转移电流定理">6 转移电流定理</h1><div id="------------------" class="statement sta_______ plain unnumbered"><p><span class="statement-heading"><span class="statement-label">转移电流定理</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(\{e_1,\ldots,e_k\}\)</span> 一组边的集合，<span class="math inline">\(T\)</span> 是一个随机生成树，<span class="math inline">\(Y\)</span> 是 <a href="#def-transfer-current" title="如前定义的转移电流矩阵">如前定义的转移电流矩阵</a>，定义 <span class="math inline">\(k\times k\)</span> 矩阵 <span class="math inline">\(Y^{(k)}(i,j)=Y(e_i,e_j)\)</span>，则 <span class="math display">\[\mathbb{P}(e_1,\ldots,e_k\in T) = \detY^{(k)}.\]</span></p></div><div class="statement corollary plain"><p><span class="statement-heading"><span class="statement-label">推论6.1</span>.</span><span class="statement-spah"> </span>考虑其中 <span class="math inline">\(r\)</span> 条边 <span class="math inline">\(\{e_1,\ldots,e_r\}\)</span> 不属于 <span class="math inline">\(T\)</span>，另外 <span class="math inline">\(k-r\)</span> 条边 <span class="math inline">\(\{e_{r+1},\ldots,e_k\}\)</span> 属于 <span class="math inline">\(T\)</span> 的概率 <span class="math inline">\(\mathbb{P}(e_1,\ldots,e_r\notin T,e_{r+1},\ldots,e_k\in T)\)</span>，令 <span class="math inline">\(M^{(r)}\)</span> 是对 <span class="math inline">\(Y^{(k)}\)</span> 的前 <span class="math inline">\(r\)</span> 行取反，给前 <span class="math inline">\(r\)</span> 个对角元加上 1，并保持后 <span class="math inline">\(k-r\)</span> 行不变得到的矩阵：</p><p><span class="math display">\[M^{(r)}(i, j) =\begin{cases}\delta_{ij} -Y^{(k)}(i, j), &amp; i\leq r\\Y^{(k)}(i,j), &amp;  r+1\leq i\leqk.\end{cases}\]</span></p><p>则 <span class="math display">\[\mathbb{P}(e_1,\ldots,e_r\notin T,e_{r+1},\ldots,e_k\in T)=\det M^{(r)}.\]</span></p></div><p>我们首先说明怎样用转移电流定理得出推论的结论。对排除的边的个数 <span class="math inline">\(r\)</span> 归纳，<span class="math inline">\(r=0\)</span>的情形就是转移电流定理。设推论对任何小于 <span class="math inline">\(r\)</span> 的情形成立，对 <span class="math inline">\(r\)</span> 的情形，考虑矩阵</p><p><span class="math display">\[P(i, j) = \begin{cases}  \delta_{ij} - Y^{(k)}(i,j),  &amp; i &lt; r \\  \delta_{ij}, &amp; i = r  \\  Y^{(k)}(i,j), &amp; r+1\leq i\leq k.  \end{cases}\]</span></p><p>则 <span class="math inline">\(M^{(r)},M^{(r-1)},P\)</span> 在所有<span class="math inline">\(i\ne r\)</span> 的行都相等，但是 <span class="math inline">\(M^{(r)}\)</span> 和 <span class="math inline">\(M^{(r-1)}\)</span> 的第 <span class="math inline">\(r\)</span> 行之和等于 <span class="math inline">\(P\)</span> 第 <span class="math inline">\(r\)</span> 行，于是根据行列式的多重线性性质，<span class="math display">\[\det M^{(r)}+\det M^{(r-1)}=\detP.\]</span> 将 <span class="math inline">\(\det P\)</span> 按照 <span class="math inline">\(P\)</span> 的第 <span class="math inline">\(r\)</span> 行展开并对 <span class="math inline">\(\{e_1,\ldots,e_{r-1},e_{r+1},\ldots,e_k\}\)</span>利用归纳假设，得到</p><p><span class="math display">\[\det P=\mathbb{P}(e_1,\ldots,e_{r-1}\notin T, e_{r+1},\ldots,e_k\in T).\]</span></p><p>又对 <span class="math inline">\(\{e_1,\ldots,e_{r-1},e_r,\ldots,e_k\}\)</span>利用归纳假设得到</p><p><span class="math display">\[\det M^{(r-1)} = \mathbb{P}(e_1,\ldots,e_{r-1}\notin T,e_{r},\ldots,e_k\in T)\]</span></p><p>相减即得结论。</p><p>回到转移电流定理的证明。分两种情形：</p><ol type="1"><li><p>如果 <span class="math inline">\(\{e_1,\ldots,e_k\}\)</span>中包含某个回路 <span class="math inline">\(C\)</span>的话，我们可以适当重排它们并选取 <span class="math inline">\(a_i\in\{+1,-1,0\}\)</span> 使得 <span class="math inline">\(\sum_{i=1}^ka_i\chi^{e_i}=f_C\in\lozenge\)</span>，这里对不属于 <span class="math inline">\(C\)</span> 的 <span class="math inline">\(e_i\)</span> 取 <span class="math inline">\(a_i=0\)</span>，对属于 <span class="math inline">\(C\)</span> 的 <span class="math inline">\(e_i\)</span> 通过选择 <span class="math inline">\(a_i=\pm1\)</span>使得它们的方向为依次首尾相接。根据基尔霍夫电压定律，对任何电流 <span class="math inline">\(i^{e_m}\,(1\leq m\leqk)\)</span>，其绕回路一圈电势的改变为 0，所以 <span class="math display">\[ 0 =\sum_{i=1}^kr(e_i)i^{e_m}(a_ie_i)=\sum_{i=1}^ka_ir(e_i)i^{e_m}(e_i)=\sum_{i=1}^ka_ir(e_i)Y^{(k)}(e_m,e_i).\]</span>所以 <span class="math inline">\(Y^{(k)}\)</span> 的列是线性相关的，从而<span class="math inline">\(\mathbb{P}(e_1,\ldots,e_k\in T)=\detY^{(k)}=0\)</span>，结论成立。</p></li><li><p>如果 <span class="math inline">\(\{e_1,\ldots,e_k\}\)</span>中不包含回路的话，对边的个数 <span class="math inline">\(k\)</span>归纳，<a href="#lerw" title="定理 4.1">定理 4.1</a> 已经给出了 <span class="math inline">\(k=1\)</span> 的情形，所以可以假设 <span class="math inline">\(k&gt;1\)</span> 且结论对所有小于 <span class="math inline">\(k\)</span> 的情形成立。我们注意到 <span class="math inline">\(Y^{(k)}\)</span> “差不多”是一个 <a href="en.wikipedia.org/wiki/Gramian_matrix">Gram 矩阵</a> （见 <a href="#iee" title="命题 2.4">命题 2.4</a>）： <span class="math display">\[Y^{(k)}(i,j)=Y(e_i,e_j)=c(e_j)(i^{e_i},i^{e_j})_E.\]</span>即 <span class="math inline">\(Y^{(k)}\)</span> 不过是对每个 <span class="math inline">\(j\)</span>，在 Gram 矩阵 <span class="math inline">\(I^{(k)}=\big((i^{e_i},i^{e_j})\big)_{1\leq i,j\leqk}\)</span> 的第 <span class="math inline">\(j\)</span> 列上乘以 <span class="math inline">\(c(e_j)\)</span> 得到的，所以 <span class="math display">\[\det Y^{(k)} = \left(\prod_{i=1}^k c(e_i)\right)\det I^{(k)}.\]</span> 回忆内积空间中 Gram矩阵的行列式的几何意义是其张成的平行多面体的体积的平方，它等于 <span class="math inline">\(\{i^{e_1},\ldots,i^{e_{k-1}}\}\)</span> 张成的底面<span class="math inline">\(Z\)</span> 面积平方乘以 <span class="math inline">\(i^{e_k}\)</span> 到这个底面距离的平方： <span class="math display">\[\det I^{(k)} = \big\|P_Z^\bot i^{e_k}\big\|^2\det I^{(k-1)}.\]</span> 其中 <span class="math inline">\(Z=\mathrm{span}\{i^{e_1},\ldots,i^{e_{k-1}}\}\)</span>，<span class="math inline">\(P_Z^\bot\)</span> 是到 <span class="math inline">\(Z\)</span> 的正交补空间 <span class="math inline">\(Z^\bot\)</span> 的投影算子。把 <span class="math inline">\(\prod_{i=1}^kc(e_i)\)</span> 乘回去就得到 <span class="math display">\[\det Y^{(k)} = c(e_k) \big\|P_Z^\bot i^{e_k}\big\|^2 \det Y^{(k-1)}.\]</span> 另一方面根据条件概率公式有 <span class="math display">\[\mathbb{P}(e_1,\ldots,e_k\in T)=\mathbb{P}(e_k\in T\,\big|\, e_1,\ldots,e_{k-1}\in T)\cdot\mathbb{P}(e_1,\ldots,e_{k-1}\in T).\]</span> 而根据 <a href="#contraction" title="定理 5.2">定理 5.2</a>的结论 <span class="math display">\[\mathbb{P}(e_k\in T\,\big|\, e_1,\ldots,e_{k-1}\in T) = c(e_k)\big\|P_Z^\bot i^{e_k}\big\|^2,\]</span> 从而 <span class="math inline">\(\det Y^{(k)}\)</span> 和<span class="math inline">\(\mathbb{P}(e_1,\ldots,e_k\in T)\)</span>有相同的初始条件和递推关系，从而它们相等，转移电流定理得证。</p></li></ol><h1 id="回答本文开头的问题">7 回答本文开头的问题</h1><p>如本文开头所述，解决 <span class="math inline">\(\mathbb{Z}^2\)</span>中顶点在随机迷宫中度数分布的问题归结为求解 <span class="math inline">\(\mathbb{Z}^2\)</span>上的转移电流矩阵，即令所有边的电导值均为 1，在一条边 <span class="math inline">\(e=(x,y)\)</span> 两端通入单位电流时，流过另一条边<span class="math inline">\(e'\)</span>的电流流量，这等价于求解对应的电势函数 <span class="math inline">\(v\)</span>，也等价于求解 <span class="math inline">\(\mathbb{Z}^2\)</span> 上拉普拉斯算子的解</p><p><span class="math display">\[(\Delta v)(x) = \mathbb{1}_{\{ x=e^- \}} - \mathbb{1}_{\{ x=e^+ \}}.\]</span></p><p>这一步可以通过 Fourier 分析的方法来做，比如 Lyons等人的教材就是采用的这种方法。但是假定你看过本系列的 <a href="/random-walk-potential-kernel">第一篇文章</a>的话，我们可以省很多事情，直接用二维随机游动的势核函数 <span class="math inline">\(a(x)\)</span> 来构造电势函数 <span class="math inline">\(v\)</span>。注意到 <span class="math inline">\(a(x)\)</span>在除去原点之外的任何点是调和的，并且在原点处的值为 0。记</p><p><span class="math display">\[g(u) = \frac{a(u-y)-a(u-x)}{4}.\]</span></p><p>则 <span class="math inline">\(g\)</span> 在除去 <span class="math inline">\(x,y\)</span> 外任何点处是调和的，从而 <span class="math inline">\(i=\nabla g\)</span> 满足欧姆定律、在除 <span class="math inline">\(x,y\)</span> 之外满足基尔霍夫定律，且 <span class="math inline">\(g(x)=a(x-y)/4 = -g(y)\)</span>。又</p><p><span class="math display">\[\begin{align*}\|i\| &amp;= \sum_{z\sim x}i(x, z)=\sum_{z\sim x}[g(x)-g(z)]\\&amp;=a(x-y)-\sum_{z\sim x}\frac{a(z-y)-a(z-x)}{4}\\&amp;=\left(a(x-y)-\sum_{z\sim x}\frac{a(z-y)}{4}\right) +\sum_{z\in\{\pm(1,0),\pm(0,1)\}}\frac{a(z)}{4}\\&amp;=1.\end{align*}\]</span></p><p>其中最后一个等号是因为势核在除去原点之外是调和的，且在原点的四个邻居处值为1。</p><p>于是 <span class="math inline">\(v(u)=g(u)-g(y)\)</span> 即为当 <span class="math inline">\(x\)</span> 通入单位电流，<span class="math inline">\(y\)</span> 接地时 <span class="math inline">\(\mathbb{Z}^2\)</span>上的电势函数，从而其在任何一边 <span class="math inline">\(e'=(z,w)\)</span> 上的电流为</p><p><span class="math display">\[i(z,w) = g(z) - g(w)=\frac{1}{4}\big[a(z-y)-a(z-x)-a(w-y)+a(w-x)\big].\]</span></p><p>当 <span class="math inline">\(e=(x,y)\)</span> 和 <span class="math inline">\(e'=(z,w)\)</span>都取自原点相邻的四条边时，根据下图中的势核值代入上式即得本文开头的转移电流矩阵。</p><p><img style="margin:0px auto;display:block" src="/images/electric-network/greenfunction.svg" width="350"></p><p>举个例子验证一下：取 <span class="math inline">\(e_1=(0,0)\to(1,0)\)</span>，<span class="math inline">\(e_2=(0,0)\to(0,1)\)</span>，则 <span class="math inline">\(x=z=(0,0)\)</span>，<span class="math inline">\(y=(1,0)\)</span>，<span class="math inline">\(w=(0,1)\)</span>，于是 <span class="math display">\[i^{e_1}(e_2)=\frac{a(-1,0)-a(0,0)-a(-1,1)+a(0,1)}{4}=\frac{1}{2}-\frac{1}{\pi}.\]</span> Bingo!</p><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>Lyons, Russell, and Peres, Yuval. 2016. Probability onTrees and Networks. Cambridge Series in Statistical and ProbabilisticMathematics, vol.&nbsp;42.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>Richard Stanley. 2013. Algebraic Combinatorics: Walks,Trees, Tableaux, and More. Undergraduate Texts in Mathematics.Springer-Verlag New York.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
    
    
    <summary type="html">
&lt;p&gt;和之前一样，我们还是通过一个有趣的问题来引入主题。&lt;/p&gt;
&lt;div class=&quot;unnumbered statement question-unnumbered definition&quot;&gt;
&lt;p&gt;&lt;span class=&quot;statement-heading&quot;&gt;&lt;span class=&quot;statement-label&quot;&gt;问题&lt;/span&gt;：&lt;/span&gt;&lt;span class=&quot;statement-spah&quot;&gt; &lt;/span&gt;在 &lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;times
n&#92;)&lt;/span&gt; 的正方形网格图 &lt;span class=&quot;math inline&quot;&gt;&#92;(G_n&#92;)&lt;/span&gt;
的所有生成树中等概率地随机任选一个，记这个随机生成树为 &lt;span class=&quot;math inline&quot;&gt;&#92;(T&#92;)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(T&#92;)&lt;/span&gt;
叫做 &lt;span class=&quot;math inline&quot;&gt;&#92;(G_n&#92;)&lt;/span&gt; 的一个均匀生成树。对 &lt;span class=&quot;math inline&quot;&gt;&#92;(G_n&#92;)&lt;/span&gt; 中任一顶点 &lt;span class=&quot;math inline&quot;&gt;&#92;(v&#92;)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(v&#92;)&lt;/span&gt;
是 &lt;span class=&quot;math inline&quot;&gt;&#92;(T&#92;)&lt;/span&gt; 的叶节点的概率是多少？&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;这个问题可以换一种更通俗的描述：&lt;/p&gt;
&lt;div class=&quot;unnumbered statement question-unnumbered definition&quot;&gt;
&lt;p&gt;&lt;span class=&quot;statement-heading&quot;&gt;&lt;span class=&quot;statement-label&quot;&gt;问题&lt;/span&gt;：&lt;/span&gt;&lt;span class=&quot;statement-spah&quot;&gt; &lt;/span&gt;对一个完全随机的 &lt;span class=&quot;math inline&quot;&gt;&#92;(n&#92;times n&#92;)&lt;/span&gt;
的完美迷宫，它包含的“死角”的比例是多少？&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;为什么这两个问题是一回事？&lt;/p&gt;
&lt;p&gt;一个迷宫称作是完美的，如果迷宫中的任何两个房间之间都有且仅有唯一的道路相连，这正是生成树的等价描述！迷宫中的一个房间称作是“死角”，当且仅当它只有一条道路与其它房间相通，没有其它出路，这正是叶节点的等价描述！&lt;/p&gt;
&lt;p&gt;下图显示了三个不同的均匀生成树，它们分别来自大小为 &lt;span class=&quot;math inline&quot;&gt;&#92;(80&#92;times 80&#92;)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(120&#92;times120&#92;)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;&#92;(200&#92;times200&#92;)&lt;/span&gt;
的三个网格图，这三个生成树的叶节点（用蓝色标出）占全体顶点的比例分别为
&lt;span class=&quot;math inline&quot;&gt;&#92;(1884/6400=0.294375&#92;)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(4234/14400&#92;approx0.294028&#92;)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;&#92;(11776/40000=0.2944&#92;)&lt;/span&gt;。咦？看起来好像是在围着一个固定的值波动喔？&lt;/p&gt;</summary>
    
    
    
    <category term="随机游动" scheme="https://pywonderland.com/categories/%E9%9A%8F%E6%9C%BA%E6%B8%B8%E5%8A%A8/"/>
    
    
    <category term="Electric network" scheme="https://pywonderland.com/tags/Electric-network/"/>
    
    <category term="Uniform spanning tree" scheme="https://pywonderland.com/tags/Uniform-spanning-tree/"/>
    
    <category term="Markov chain" scheme="https://pywonderland.com/tags/Markov-chain/"/>
    
    <category term="Transfer current matrix" scheme="https://pywonderland.com/tags/Transfer-current-matrix/"/>
    
    <category term="Kirchhoff law" scheme="https://pywonderland.com/tags/Kirchhoff-law/"/>
    
    <category term="Ohm law" scheme="https://pywonderland.com/tags/Ohm-law/"/>
    
    <category term="Harmonic function" scheme="https://pywonderland.com/tags/Harmonic-function/"/>
    
    <category term="Graph reduction" scheme="https://pywonderland.com/tags/Graph-reduction/"/>
    
    <category term="Cycle space" scheme="https://pywonderland.com/tags/Cycle-space/"/>
    
    <category term="Star space" scheme="https://pywonderland.com/tags/Star-space/"/>
    
  </entry>
  
  <entry>
    <title>Coxeter 群，有限状态机与均匀密铺</title>
    <link href="https://pywonderland.com/coxeter-groups-and-uniform-tilings/"/>
    <id>https://pywonderland.com/coxeter-groups-and-uniform-tilings/</id>
    <published>2019-12-14T16:00:00.000Z</published>
    <updated>2024-08-03T13:50:32.873Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>更新</strong>：由于使用 POV-Ray渲染三维双曲蜂巢非常的慢，所以我放弃了这种途径，并将代码从 Github主分支中移除。你可以在 <a href="https://github.com/neozhaoliang/pywonderland/releases/tag/0.1.0">旧存档</a>中找到本文使用的代码。关于怎样渲染双曲蜂巢读者可以参考 <a href="https://github.com/neozhaoliang/Hyperbolic-Honeycombs/">另一个项目</a>。</p></blockquote><p>本文介绍我刚刚完成的一个 <a href="https://github.com/neozhaoliang/pywonderland/">Python程序</a>。虽然是刚刚完成，但是它占去了我这半年来大部分的业余时间，也算是一个艰苦攻关，呕心沥血之作。主要是它涉及的理论比较复杂，要用到Coxeter 群的一些深刻的性质，即所谓的 automaticproperty。这半年里面不少时间是花在学习 Casselman 和 Brink &amp; Howlett等人的文章上面，这才弄懂了其中的数学原理（见参考文献）。</p><p>虽然完成这个程序很有成就感，但是我无意强调这个程序的任何优越性：它采用的Coxeter群的计算方法并不先进，难入行家的法眼。而且它的代码比较丑，大概率除了我，别人也很难用起来。</p><p>这个程序的目的是使用群论的方式来绘制二维和三维的各种 <a href="https://en.wikipedia.org/wiki/Uniform_tiling">均匀密铺</a>。所谓均匀密铺，你可以理解为用一些正多边形的瓷砖密铺整个空间，使得瓷砖的顶点在对称群作用下是传递的（构成单一轨道）。</p><p>我先展示一些这个程序的例子，然后介绍它的实现原理。</p><span id="more"></span><h1 id="例子">例子</h1><p>以下图片均由此程序绘制：</p><ul><li><p>Euclidean 密铺 omnitruncated (4, 2, 4)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-4-2-4.png" width="500"></p></li></ul><!-- more --><ul><li><p>二维 Poincaré 圆盘上的正双曲密铺 (2, 3, 13)，绘制了 3447个顶点，6971 条边，3549 个多边形：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/2-3-13.png" width="500"></p></li><li><p>二维上半平面模型中的双曲密铺 omnitruncated (4, 3, 3):</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/uhp-4-3-3.png" width="500"></p></li><li><p>三维 Poincaré 单位球中的正双曲密铺 (3, 5, 3)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/3-5-3.png" width="500"></p></li><li><p>三维 Poincaré 单位球中的正双曲密铺 (5, 3, 5)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/5-3-5.png" width="500"></p></li><li><p>三维 Poincaré 单位球中的正双曲密铺 (5, 3, 4)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/5-3-4.png" width="500"></p></li><li><p>三维 Poincaré 单位球中的正双曲密铺 (4, 3, 5)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/4-3-5.png" width="500"></p></li><li><p>以上四个密铺是三维双曲空间中仅有的正且每个胞腔为紧集的双曲密铺。如果去掉每个胞腔为紧集的限制的话，但是要求每个胞腔的体积有限的话，则还有10 个正双曲密铺，如下图的 (6, 3, 3)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/6-3-3.png" width="500"></p><p>你可以看到每个胞腔都有一个理想顶点，它位于空间的无穷远处（即单位球面上）。这种密铺叫做仿紧的(paracompact)，因为每个胞腔的体积仍然是有限的。如果再去掉每个胞腔的体积有限的条件的话，得到的密铺叫做非紧的，非紧的密铺有无限多个。</p></li><li><p>如果去掉正密铺这个限制，只考虑均匀密铺的话，那例子就非常多了。比如我们可以从正密铺出发通过截断操作得到许多均匀密铺，如rectified (3, 5, 3) 和 rectified (5, 3, 4)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/rectified-3-5-3.png" width="500"></p><p><img style="margin:0px auto;display:block" src="/images/coxeter/rectified-5-3-4.png" width="500"></p></li><li><p>二维的球面密铺 omnitruncated (5, 2, 3)：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-5-2-3.png" width="500"></p></li><li><p>最后是一个 shader 程序，来自 Matt Zucker 的 <a href="https://www.shadertoy.com/view/3tsSzM">shadertoy 项目</a>：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/wythoff_shader.png" width="500"></p></li></ul><h1 id="wythoff-构造法">Wythoff 构造法</h1><p>绘制均匀密铺的理论基础是所谓的 <a href="https://en.wikipedia.org/wiki/Wythoff_construction">Wythoff构造法</a>，也叫万花筒方法。即在空间中摆放若干反射平面（镜子），然后从一个初始点出发，关于这些镜子反复作反射变换，得到所有的虚像，就得到了密铺的全部顶点。</p><p>下面的视频演示了 Wythoff 构造法的效果：在二维的 Poincaré双曲圆盘中，房间四周的墙壁都是镜子，房间中的场景在镜子中反复成像，得到了无数个虚像房间，它们填满了整个双曲空间。但实际上这个场景里面只有观察者所在的房间是真实的，其它房间都是它在镜子中的虚像。</p><video src="/images/hyperbolic-honeycombs/lego-hyperbolic-kaleido.mp4" width="600" controls=""></video><p>在编程实现 Wythoff 构造法时有两种不同的方案：</p><ol type="1"><li><p>逆像素方法。这种方法是对图像中的每个像素，计算它在空间中的对应点<span class="math inline">\(p\)</span>，然后将 <span class="math inline">\(p\)</span>反复作镜面反射，直到其落入基本区域为止，得到一个点 <span class="math inline">\(q\)</span>。即我们找到 <span class="math inline">\(p\)</span> 在房间中的原像 <span class="math inline">\(q\)</span>。然后根据 <span class="math inline">\(q\)</span> 在基本区域中的位置给 <span class="math inline">\(p\)</span>对应的像素上色。这种方法可以对所有像素并行计算，特别是和 shader编程结合起来可以生成非常惊艳的效果。这里举两个 shadertoy 上的例子：</p><p><iframe width="480" height="270" frameborder="0" src="https://www.shadertoy.com/embed/mlGfzV?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe></p><p><iframe width="480" height="270" frameborder="0" src="https://www.shadertoy.com/embed/Nd3cR2?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe></p><p>逆像素方法只关心像素的颜色，完全不关心它的坐标是什么。它输出的是光栅图，无法输出矢量图形。而且如果你想导出数据用在建模软件中的话也不太方便。</p></li><li><p>坐标方法。这种方法就是从给定初始点 <span class="math inline">\(v_0\)</span>出发，计算它的所有虚像（限定顶点数目的阈值），以及边和面的连接关系，然后逐个进行绘制。这种方法可以获取顶点具体的坐标信息，并输出为矢量图形和模型文件，比较适合用在学术论文中。但是它无法并行，而且对双曲密铺这种指数增长的结构计算效率是很慢的。</p></li></ol><p>我的这个程序采用的是坐标方法。它首先在密铺的对称群中进行符号计算，得出每个顶点在最短字典序下对应的单词表示。（一个单词就是一个元素都是整数的<code>tuple</code>），以及边和面的连接关系（也是元素都是整数的<code>tuple</code>），然后将每个顶点对应的单词作用在初始顶点上得到该顶点的浮点坐标。换句话说，在计算每个顶点的最终坐标之前，它已经提前计算好了有多少个顶点，每个顶点是由初始顶点经过哪些反射得到的，哪些顶点构成边，哪些顶点构成面，哪些顶点构成胞腔，等等。这些计算仅涉及整数运算，完全避免了浮点数精度损失的问题。</p><p>听起来很神奇？下面我用一个例子来演示具体的步骤。</p><h1 id="例子omnitruncated-7-2-3-密铺">例子：omnitruncated (7, 2, 3)密铺</h1><p>Omnitruncated (7, 2, 3) 密铺对应的 Coxeter-Dynkin 图如下：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/coxeter723.svg" width="250"></p><p>这是一个二维的双曲密铺，其对称群是由 Coxeter 矩阵</p><p><span class="math display">\[M=\begin{pmatrix} 1 &amp; 7 &amp; 2 \\ 7&amp;1 &amp;3\\ 2 &amp; 3 &amp;1\end{pmatrix}\]</span></p><p>给出的 Coxeter 群</p><p><span class="math display">\[W=\langle s_0,s_1, s_2\ |\s_0^2=s_1^2=s_2^2=(s_0s_1)^7=(s_1s_2)^3=(s_0s_2)^2=1\rangle.\]</span></p><p>初始顶点不包含于任何镜面上，所以其稳定化子群只包含单位元 1，从而根据<a href="https://en.wikipedia.org/wiki/Wroup_action_(mathematics)#Orbit-stabilizer_theorem">轨道—稳定化子定理</a><span class="math inline">\(W\)</span>的每一个元素都对应密铺中的一个顶点。</p><p><span class="math inline">\(W\)</span> 中每个元素 <span class="math inline">\(w\)</span> 都可以表示为生成元 <span class="math inline">\(s_0,s_1,s_2\)</span>的乘积，我们称任何这样的表示方式为 <span class="math inline">\(w\)</span> 的一个单词表示。如果 <span class="math inline">\(w=s_{i_1}s_{i_2}\cdots s_{i_k}\)</span>是一个单词表示，且 <span class="math inline">\(w\)</span> 不存在长度小于<span class="math inline">\(k\)</span> 的表示，我们就称 <span class="math inline">\(s_{i_1}s_{i_2}\cdots s_{i_k}\)</span> 是 <span class="math inline">\(w\)</span> 的一个<strong>既约表示</strong>，并称<span class="math inline">\(l(w)=k\)</span> 是 <span class="math inline">\(w\)</span> 的<strong>长度</strong>。</p><p><span class="math inline">\(w\)</span>的既约表示一般不是唯一的，比如从 <span class="math inline">\(W\)</span>的生成关系中可以看出 <span class="math inline">\(s_0s_2=s_2s_0\)</span>,<span class="math inline">\(s_1s_2s_1=s_2s_1s_2\)</span> 等等。但是<span class="math inline">\(w\)</span>的所有既约表示的长度必然都是一样的，所以 <span class="math inline">\(l(w)\)</span> 的定义合理。</p><p>我们可以给 <span class="math inline">\(w\)</span>的所有既约表示排序，并选择最小的那个来作为 <span class="math inline">\(w\)</span>的<strong>规范表示</strong>。这个排序的依据叫做<strong>最短字典序</strong>(shortlexorder)。最短字典序顾名思义，就是字典在排列单词时采用的次序。</p><p>首先规定生成元 <span class="math inline">\(s_0,s_1,s_2\)</span>之间的字母顺序关系为 <span class="math inline">\(s_0&lt;s_1&lt;s_2\)</span>，然后将这个顺序扩展到任何两个既约表示<span class="math inline">\(w_1\)</span> 和 <span class="math inline">\(w_2\)</span> 上去：</p><div id="---------------" class="unnumbered statement sta______ plain"><p><span class="statement-heading"><span class="statement-label">最短字典序</span>.</span><span class="statement-spah"> </span>设 <span class="math inline">\(w_1=s_{i_1}s_{i_2}\cdots s_{i_n}\)</span> 和 <span class="math inline">\(w_2=s_{j_1}s_{j_2}\cdots s_{j_m}\)</span>是两个不同的既约表示，<span class="math inline">\(w_1,w_2\)</span>可以是不同的群元素。它们二者在最短字典序中的关系由如下方式确定：</p><ol type="1"><li>先比较长度，长度不同的话，长度小的为较小者，即若 <span class="math inline">\(n&lt;m\)</span> 则 <span class="math inline">\(w_1&lt;w_2\)</span>，反之若 <span class="math inline">\(n&gt;m\)</span> 则 <span class="math inline">\(w_1&gt;w_2\)</span>。</li><li>若长度相等则按字母顺序从左到右逐项比较，设 <span class="math inline">\(k\)</span> 使得对任何 <span class="math inline">\(l&lt;k\)</span> 有 <span class="math inline">\(s_{i_l}=s_{j_l}\)</span> 但 <span class="math inline">\(s_{i_k}\ne s_{j_k}\)</span>，则规定 <span class="math inline">\(w_1,w_2\)</span> 之间的大小关系与 <span class="math inline">\(s_{i_k},s_{j_k}\)</span> 之间的大小关系相同。</li></ol></div><p>于是任何 <span class="math inline">\(w\in W\)</span>在最短字典序下都有唯一的规范表示。</p><p>定义 <span class="math inline">\(\mathcal{SL}(W)\)</span> 为 <span class="math inline">\(W\)</span>中所有元素的规范表示组成的集合，下面列出了 <span class="math inline">\(\mathcal{SL}(W)\)</span> 中所有长度不超过 5的元素，一共有 37 个：（从小到大按行排列）</p><p><span class="math display">\[\begin{array}{lllll}e&amp;s_{0}&amp;s_{1}&amp;s_{2}&amp;s_{0}s_{1}\\s_{0}s_{2}&amp;s_{1}s_{0}&amp;s_{1}s_{2}&amp;s_{2}s_{1}&amp;s_{0}s_{1}s_{0}\\s_{0}s_{1}s_{2}&amp;s_{0}s_{2}s_{1}&amp;s_{1}s_{0}s_{1}&amp;s_{1}s_{0}s_{2}&amp;s_{1}s_{2}s_{1}\\s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{1}&amp;s_{0}s_{1}s_{0}s_{2}&amp;s_{0}s_{1}s_{2}s_{1}&amp;s_{0}s_{2}s_{1}s_{0}\\s_{1}s_{0}s_{1}s_{0}&amp;s_{1}s_{0}s_{1}s_{2}&amp;s_{1}s_{0}s_{2}s_{1}&amp;s_{1}s_{2}s_{1}s_{0}&amp;s_{2}s_{1}s_{0}s_{1}\\s_{0}s_{1}s_{0}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{1}s_{2}&amp;s_{0}s_{1}s_{0}s_{2}s_{1}&amp;s_{0}s_{1}s_{2}s_{1}s_{0}&amp;s_{0}s_{2}s_{1}s_{0}s_{1}\\s_{1}s_{0}s_{1}s_{0}s_{1}&amp;s_{1}s_{0}s_{1}s_{0}s_{2}&amp;s_{1}s_{0}s_{1}s_{2}s_{1}&amp;s_{1}s_{0}s_{2}s_{1}s_{0}&amp;s_{1}s_{2}s_{1}s_{0}s_{1}\\s_{2}s_{1}s_{0}s_{1}s_{0}&amp;s_{2}s_{1}s_{0}s_{1}s_{2}&amp;\end{array}\]</span></p><p>理论上由 <span class="math inline">\(s_0,s_1,s_2\)</span>组成的所有可能的长度不超过 5 的单词总共有 <span class="math inline">\(\sum_{i=0}^5 3^i=364\)</span>个，上表告诉我们实际上它们只包含了 <span class="math inline">\(W\)</span> 中 37个不同的元素，即将它们作用在密铺中的初始顶点上只会得到 37 个顶点，其余364 - 37 = 327 个都是重复的。进一步计算可得长度不超过 6 的单词有 1093个而实际上只包含了 53 个不同的元素。所以如果我们能够快速地生成 <span class="math inline">\(\mathcal{SL}(W)\)</span>中的元素而不是去遍历所有可能单词的话，就可以大大提高计算效率。</p><p>那么怎么计算 <span class="math inline">\(\mathcal{SL}(W)\)</span>中的元素呢？这就引出了一个关于 Coxeter 群的重要结论：</p><div id="-brigitte-brink---robert-b--howlett--1993-" class="unnumbered statement sta__brigitte_brink___robert_b__howlett__1993_ plain"><p><span class="statement-heading"><span class="statement-label">[Brigitte Brink &amp; Robert B. Howlett,1993]</span>.</span><span class="statement-spah"> </span>若 <span class="math inline">\(W\)</span> 是有限生成 Coxeter 群，则 <span class="math inline">\(\mathcal{SL}(W)\)</span> 是一个 <a href="https://en.wikipedia.org/wiki/Regular_language">正则语言</a>。</p></div><p>正则语言这个术语来自计算机科学，关于正则语言的一个基本事实是，一个有限字符集上的正则语言总是可以被一个确定的有限状态自动机(definite finite automaton)识别，这样的有限状态机不是唯一的，但是在等价意义下（对状态重新标号）总是存在一个状态数目最少的。下图显示的是识别(7, 2, 3) 这个群的 <span class="math inline">\(\mathcal{SL}(W)\)</span>的最小状态机：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/dfa_723.svg" width="600"></p><p>可以看到在上图中一共有 19 个节点（即状态），每个状态都有一个编号，这个编号并没有实际意义，可以不用理会，实际上给状态重新编号不影响有限状态机识别的语言。真正有意义的是顶点之间的关系以及边的编号。圈红的节点0 是初始状态。</p><p>图中的每条有向边规定了状态之间的转移规则，边的标号是生成元 <span class="math inline">\(s_i\)</span>。从初始状态出发，每次沿着一条有向边移动到下一个状态，经过的路径给出了一个由<span class="math inline">\(s_0,s_1,s_2\)</span>组成的单词，所有的路径给出的单词组成的集合就是这个有限状态机识别的语言，即<span class="math inline">\(\mathcal{SL}(W)\)</span>。</p><p>举个例子：</p><ol type="1"><li>长度为 0 的路径对应的是 <span class="math inline">\(W\)</span>的单位元。</li><li>长度为 1 的三条路径 <span class="math display">\[\begin{align*}0&amp;\xrightarrow{\ s_0\ }1,\\0&amp;\xrightarrow{\ s_1\ }2,\\0&amp;\xrightarrow{\ s_2\ }8.\end{align*}\]</span> 对应的是 <span class="math inline">\(W\)</span> 的三个长度为 1的元素 <span class="math inline">\(s_0,s_1,s_2\)</span>。</li><li>长度为 2 的 5 条路径 <span class="math display">\[\begin{align*}0&amp;\xrightarrow{\ s_0\}1\xrightarrow{\ s_1\ }2\\0&amp;\xrightarrow{\ s_0\ }1\xrightarrow{\ s_2\ }8\\0&amp;\xrightarrow{\ s_1\ }2\xrightarrow{\ s_0\ }3\\0&amp;\xrightarrow{\ s_1\ }2\xrightarrow{\ s_2\ }8\\0&amp;\xrightarrow{\ s_2\ }8\xrightarrow{\ s_1\ }9\end{align*}\]</span> 对应的是 <span class="math inline">\(W\)</span> 的 5 个长度为2 的元素 <span class="math inline">\(s_0s_1,s_0s_2,s_1s_0,s_1s_2,s_2s_1\)</span>。</li></ol><p>以此类推，我们可以很容易用宽度优先搜索遍历任意长度范围内的群元素。特别地如果你按图索骥地验证一下的话可以发现所有长度不超过5 的路径一共有 37 条，它们正对应前面列出的 <span class="math inline">\(\mathcal{SL}(W)\)</span> 中长度不超过 5 的 37个单词。</p><p>无限 Coxeter 群的有限状态机必然含有回路，而有限 Coxeter群的有限状态机则必然是一个以初始状态为根节点的有向树。例如下图显示的是置换群<span class="math inline">\(S_4\)</span> 对应的有限状态机：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/tetrahedron.svg" width="600"></p><p>用宽度优先搜索可以得出其包含 24 条不同的路径，它们对应 <span class="math inline">\(S_4\)</span> 的 24 个元素的最短字典序表示：</p><p><span class="math display">\[\begin{array}{llll}e&amp;s_{0}&amp;s_{1}&amp;s_{2}\\s_{0}s_{1}&amp;s_{0}s_{2}&amp;s_{1}s_{0}&amp;s_{1}s_{2}\\s_{2}s_{1}&amp;s_{0}s_{1}s_{0}&amp;s_{0}s_{1}s_{2}&amp;s_{0}s_{2}s_{1}\\s_{1}s_{0}s_{2}&amp;s_{1}s_{2}s_{1}&amp;s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{2}\\s_{0}s_{1}s_{2}s_{1}&amp;s_{0}s_{2}s_{1}s_{0}&amp;s_{1}s_{0}s_{2}s_{1}&amp;s_{1}s_{2}s_{1}s_{0}\\s_{0}s_{1}s_{0}s_{2}s_{1}&amp;s_{0}s_{1}s_{2}s_{1}s_{0}&amp;s_{1}s_{0}s_{2}s_{1}s_{0}&amp;s_{0}s_{1}s_{0}s_{2}s_{1}s_{0}\end{array}\]</span></p><p>既然通过 <span class="math inline">\(\mathcal{SL}(W)\)</span>来生成群元素如此方便，那问题来了：</p><div id="prob1" class="statement question definition"><p><span class="statement-heading"><span class="statement-label">问题3.1</span>：</span><span class="statement-spah"> </span>怎样计算 <span class="math inline">\(\mathcal{SL}(W)\)</span> 对应的有限状态机？</p></div><p>此问题技术太过复杂，完整介绍全部内容的话本文难以承受，我在后面的附录中作了一些简单的解释。</p><p>有了每个群元素的唯一的规范表示，我们就可以很容易地计算密铺中每个顶点的坐标了：</p><p>设 <span class="math inline">\(w=s_{i_0}s_{i_1}\cdotss_{i_n}\)</span>，初始顶点为 <span class="math inline">\(v_0\)</span>，则 <span class="math inline">\(w\)</span> 在 <span class="math inline">\(v_0\)</span> 上的作用为 <span class="math display">\[w\cdot v_0 = s_{i_0}(s_{i_1}(\cdotss_{i_n}(v_0))).\]</span>即从右到左依次计算每个生成元作用的结果。当然由于 <span class="math inline">\(W\)</span>是无限群，我们只能计算那些长度不超过一定范围的群元素对应的顶点。假设我们已经有了前面这37 个顶点，它们存储在一个列表 <span class="math inline">\(L\)</span>里。为了绘制密铺中的边，我们还需要计算 <span class="math inline">\(L\)</span>中哪些顶点是相邻的，这个怎么解决呢？</p><p>首先我们需要计算一个 <span class="math inline">\(L\)</span>中元素之间的乘法表 <span class="math inline">\(T\)</span>，<span class="math inline">\(T\)</span>的作用是帮助我们查找任何一个单词，其规范表示在 <span class="math inline">\(L\)</span> 中的下标 （不在 <span class="math inline">\(L\)</span> 中的话则返回 <code>None</code>）。<span class="math inline">\(T\)</span> 是一个大小为 <span class="math inline">\(|L|\times 3\)</span> 的二维数组，其第 <span class="math inline">\(i\)</span> 行对应 <span class="math inline">\(L\)</span> 中的第 <span class="math inline">\(i\)</span> 个群元素 <span class="math inline">\(w_i\)</span>，第 <span class="math inline">\(j\)</span> 列对应群的生成元 <span class="math inline">\(s_j\)</span>，<span class="math inline">\(T[i][j]\)</span> 的值等于 <span class="math inline">\(s_jw_i\)</span> 这个元素的规范表示在 <span class="math inline">\(L\)</span> 中的下标。如果这个元素不在 <span class="math inline">\(L\)</span> 中则以 <code>None</code> 代替。</p><p>在我们的例子中 <span class="math inline">\(T\)</span> 的值如下，<span class="math inline">\(L\)</span> 中的元素放在了第二列：</p><details><summary><font color="#D00"><strong>点击展开列表 <span class="math inline">\(T\)</span></strong></font></summary><div><table><thead><tr class="header"><th style="text-align: center;">V</th><th style="text-align: center;">word</th><th style="text-align: center;"><span class="math inline">\(s_0\)</span></th><th style="text-align: center;"><span class="math inline">\(s_1\)</span></th><th style="text-align: center;"><span class="math inline">\(s_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(e\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">2</td><td style="text-align: center;">3</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(s_{0}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">6</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(s_{1}\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">0</td><td style="text-align: center;">8</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(s_{2}\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">7</td><td style="text-align: center;">0</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">12</td><td style="text-align: center;">11</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">13</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}\)</span></td><td style="text-align: center;">9</td><td style="text-align: center;">1</td><td style="text-align: center;">15</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}\)</span></td><td style="text-align: center;">10</td><td style="text-align: center;">3</td><td style="text-align: center;">14</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}\)</span></td><td style="text-align: center;">11</td><td style="text-align: center;">14</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;">9</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">20</td><td style="text-align: center;">19</td></tr><tr class="odd"><td style="text-align: center;">10</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">21</td><td style="text-align: center;">18</td></tr><tr class="even"><td style="text-align: center;">11</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">8</td><td style="text-align: center;">22</td><td style="text-align: center;">4</td></tr><tr class="odd"><td style="text-align: center;">12</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">16</td><td style="text-align: center;">4</td><td style="text-align: center;">24</td></tr><tr class="even"><td style="text-align: center;">13</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">17</td><td style="text-align: center;">5</td><td style="text-align: center;">23</td></tr><tr class="odd"><td style="text-align: center;">14</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">18</td><td style="text-align: center;">8</td><td style="text-align: center;">7</td></tr><tr class="even"><td style="text-align: center;">15</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">19</td><td style="text-align: center;">23</td><td style="text-align: center;">6</td></tr><tr class="odd"><td style="text-align: center;">16</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">12</td><td style="text-align: center;">30</td><td style="text-align: center;">29</td></tr><tr class="even"><td style="text-align: center;">17</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">13</td><td style="text-align: center;">31</td><td style="text-align: center;">28</td></tr><tr class="odd"><td style="text-align: center;">18</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">14</td><td style="text-align: center;">32</td><td style="text-align: center;">10</td></tr><tr class="even"><td style="text-align: center;">19</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">15</td><td style="text-align: center;">33</td><td style="text-align: center;">9</td></tr><tr class="odd"><td style="text-align: center;">20</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">25</td><td style="text-align: center;">9</td><td style="text-align: center;">35</td></tr><tr class="even"><td style="text-align: center;">21</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">26</td><td style="text-align: center;">10</td><td style="text-align: center;">36</td></tr><tr class="odd"><td style="text-align: center;">22</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">27</td><td style="text-align: center;">11</td><td style="text-align: center;">34</td></tr><tr class="even"><td style="text-align: center;">23</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">28</td><td style="text-align: center;">15</td><td style="text-align: center;">13</td></tr><tr class="odd"><td style="text-align: center;">24</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">29</td><td style="text-align: center;">34</td><td style="text-align: center;">12</td></tr><tr class="even"><td style="text-align: center;">25</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">20</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr class="odd"><td style="text-align: center;">26</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">21</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">27</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{0}s_{2}s_{1}\)</span></td><td style="text-align: center;">22</td><td style="text-align: center;">None</td><td style="text-align: center;">None</td></tr><tr class="odd"><td style="text-align: center;">28</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{1}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">23</td><td style="text-align: center;">None</td><td style="text-align: center;">17</td></tr><tr class="even"><td style="text-align: center;">29</td><td style="text-align: center;"><span class="math inline">\(s_{0}s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">24</td><td style="text-align: center;">None</td><td style="text-align: center;">16</td></tr><tr class="odd"><td style="text-align: center;">30</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">16</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">31</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{0}s_{2}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">17</td><td style="text-align: center;">None</td></tr><tr class="odd"><td style="text-align: center;">32</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{1}s_{2}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">18</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">33</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{0}s_{2}s_{1}s_{0}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">19</td><td style="text-align: center;">None</td></tr><tr class="odd"><td style="text-align: center;">34</td><td style="text-align: center;"><span class="math inline">\(s_{1}s_{2}s_{1}s_{0}s_{1}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">24</td><td style="text-align: center;">22</td></tr><tr class="even"><td style="text-align: center;">35</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}s_{0}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">None</td><td style="text-align: center;">20</td></tr><tr class="odd"><td style="text-align: center;">36</td><td style="text-align: center;"><span class="math inline">\(s_{2}s_{1}s_{0}s_{1}s_{2}\)</span></td><td style="text-align: center;">None</td><td style="text-align: center;">None</td><td style="text-align: center;">21</td></tr></tbody></table></div></details><p></p><p>于是对任意的单词 <span class="math inline">\(w=s_{i_0}s_{i_1}\cdotss_{i_n}\)</span>，我们可以从 <span class="math inline">\(T\)</span> 的第0 行出发，先找到 <span class="math inline">\(s_{i_n}\)</span> 在 <span class="math inline">\(L\)</span> 中对应的元素，假设是第 <span class="math inline">\(k\)</span> 个，那么就跳到第 <span class="math inline">\(k\)</span> 行，由 <span class="math inline">\(s_{i_{n-1}}\)</span> 对应的列找到 <span class="math inline">\(s_{i_{n-1}}s_{i_n}\)</span> 在 <span class="math inline">\(L\)</span> 中对应的元素，再顺藤摸瓜找到 <span class="math inline">\(s_{i_{n-2}}s_{i_{n-1}}s_{i_n}\)</span> 在 <span class="math inline">\(L\)</span> 中对应的元素，…，如此下去即可确定 <span class="math inline">\(w\)</span> 在 <span class="math inline">\(L\)</span> 中对应的元素 （或者<code>None</code>）。</p><p>有了表 <span class="math inline">\(T\)</span>的帮助，我们可以来计算边的信息了。这里一条边 <span class="math inline">\(e\)</span> 用一对整数 <span class="math inline">\(e=(i,j)\)</span> 来表示，<span class="math inline">\(i,j\)</span> 分别是 <span class="math inline">\(e\)</span> 的两个端点在 <span class="math inline">\(L\)</span> 中的下标。</p><p>假设初始顶点 <span class="math inline">\(v_0\)</span> 关于第 <span class="math inline">\(i\)</span> 面镜子反射后得到的虚像是 <span class="math inline">\(v_1=s_i(v_0)\)</span>，则 <span class="math inline">\(e=(v_0,v_1)\)</span> 构成一条类型为 <span class="math inline">\(i\)</span> 的边。在我们这个情形下，边 <span class="math inline">\(e\)</span> 的稳定化子群是标准椭圆子群 <span class="math inline">\(W_I=\langles_i\rangle\)</span>。根据轨道—稳定化子定理，密铺中所有类型为 <span class="math inline">\(i\)</span> 的边可以通过将商群 <span class="math inline">\(W/W_I\)</span> 的每个元素作用在 <span class="math inline">\(e\)</span> 上得到。显然 <span class="math inline">\(e\)</span> 的两个端点对应的规范表示分别是单位元 1和 <span class="math inline">\(s_i\)</span>。对任一 <span class="math inline">\(w\in W\)</span>，我们首先计算 <span class="math inline">\(w\)</span> 关于 <span class="math inline">\(W_I\)</span> 的陪集代表元 <span class="math inline">\(w_I\)</span>，<span class="math inline">\(w_I\cdote\)</span> 的两个端点对应的单词分别是 <span class="math inline">\(w_I\)</span> 和 <span class="math inline">\(w_Is_i\)</span>，然后按照上面的步骤找到它俩在<span class="math inline">\(L\)</span>中对应的元素下标，这就得到了边对应的下标表示。当然如果出现了<code>None</code> 说明这条边连接了不在 <span class="math inline">\(L\)</span> 中的顶点，需要丢掉。</p><p><span class="math inline">\(L\)</span> 中 37 个顶点构成的边如下：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/723_edges.png" width="500"></p><p>图中标号 0 的顶点是初始顶点，其对应的单词是单位元1。边中白色的线条个数表示这条边的类型，</p><p>从这个图里可以看出很多有用的信息，非常有助于理解 Coxeter群的最短字典序表示与密铺顶点的对应关系：</p><ol type="1"><li>首先可以看出将顶点 0 关于三个镜面进行一次反射得到的新虚像是 1, 2,3，它们对应的单词是 <span class="math inline">\(L\)</span> 中长度为 1 的<span class="math inline">\(s_0,s_1,s_2\)</span>。</li><li>将顶点 0 关于各个镜面进行两次反射得到的新虚像是 4, 5, 6, 7,8，它们对应的单词是 <span class="math inline">\(L\)</span> 中长度为 2 的<span class="math inline">\(s_0s_1,s_0s_2,s_1s_0,s_1s_2,s_2s_1\)</span>。</li><li>所有顶点与初始顶点之间的最短路径的长度都不超过 5。</li><li>一个单词 <span class="math inline">\(w=s_{i_0}s_{i_1}\cdotss_{i_n}\)</span> 作用在 0 号顶点上 (<span class="math inline">\(s_{i_n}\)</span> 先作用，<span class="math inline">\(s_{i_0}\)</span> 在最后） 的结果是一条从 0号顶点出发，标号依次为 <span class="math inline">\(s_{i_0},s_{i_1},\ldots,s_{i_n}\)</span> 的路径 (<span class="math inline">\(s_{i_0}\)</span> 在先，<span class="math inline">\(s_{i_n}\)</span> 在最后），与作用的顺序相反。</li><li>从图中我们可以看出每个顶点对应的单词的规范表示。例如从 0 号顶点到 33号顶点有两条最短路径：<span class="math display">\[\begin{align*}&amp;0\xrightarrow{\ s_1\ }2\xrightarrow{\ s_0\}6\xrightarrow{\ s_2\ }13\xrightarrow{\ s_1\ }22\xrightarrow{\ s_0\}33.\\&amp;0\xrightarrow{\ s_1\ }2\xrightarrow{\ s_2\ }7\xrightarrow{\ s_0\}13\xrightarrow{\ s_1\ }22\xrightarrow{\ s_0\ }33.\end{align*}\]</span> 只要按顺序连起来 （从左到右） 就可以得到 33号顶点对应的两个单词：<span class="math inline">\(s_1s_0s_2s_1s_0\)</span> 和 <span class="math inline">\(s_1s_2s_0s_1s_0\)</span>，它们都把 0 号顶点变为 33号顶点，但是前者才是最短字典序表示。这一点也可以从顶点标号中看出来：从 2号顶点开始两条路径分别去了 6 号和 7 号顶点，由于 6 号顶点对应的单词在<span class="math inline">\(\mathcal{SL}(W)\)</span>中更小，因此这条路径必然才是 33 号顶点规范表示对应的路径。</li></ol><p>计算面的步骤也是完全类似的，初始顶点关于 <span class="math inline">\(i, j\)</span>两面镜子的反射的复合是一个旋转，这个旋转连续作用 <span class="math inline">\(m\)</span> 次可以生成一个正多边形的面，其中 <span class="math inline">\(m\)</span> 是 Coxeter 矩阵中的 <span class="math inline">\((i,j)\)</span>分量。这个多边形的稳定化子群是标准椭圆子群 <span class="math inline">\(W_I=\langle i,j\rangle\)</span>，我们仍然可以得出每个顶点对应的一个单词表示，用 <span class="math inline">\(W/W_I\)</span> 里的代表元作用在上面，然后去 <span class="math inline">\(L\)</span> 里面查找对应的下标。</p><p>最终得到的图像如下图，计算了 30517 个顶点，42057 条边，11541个多边形：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/omnitruncated-7-2-3.png" width="500"></p><p>在上面的过程中，我们其实还用到了一个重要的计算：</p><div id="prob2" class="statement question definition"><p><span class="statement-heading"><span class="statement-label">问题3.2</span>：</span><span class="statement-spah"> </span>给定任一单词<span class="math inline">\(w\)</span>，怎样计算 <span class="math inline">\(w\)</span> 的规范表示？怎样计算 <span class="math inline">\(w\)</span> 关于某个标准椭圆子群 <span class="math inline">\(W_I\)</span> 的陪集代表元？</p></div><p>同样我把解释放在附录里面。</p><h1 id="关于代码">关于代码</h1><p>整个代码主要包含如下的功能：</p><ol type="1"><li><p>Coxeter 群的计算。这部分由 <code>coxeter</code> 模块中的<code>CoxeterGroup</code> 类实现。Coxeter群的计算又包含如下几个部分：</p><ul><li>计算 Coxeter 群的极小根反射表。</li><li>计算 Coxeter 中群元素的乘法，并返回结果的规范表示。</li><li>计算群元素关于给定标准椭圆子群的陪集代表元，并返回结果的规范表示。</li><li>计算识别 <span class="math inline">\(\mathcal{SL}(W)\)</span>的有限状态机，将其最小化，并绘制状态机。</li></ul></li><li><p>密铺的绘制。主要是在 <code>tiling.py</code>文件中实现。它包含如下步骤：</p><ul><li>对给定的 Coxeter群和指定的初始顶点位置，计算反射镜面和基本区域。</li><li>计算所有顶点的规范表示，以及边和面的连接关系。</li><li>将规范表示作用在初始顶点上得到所有顶点的浮点坐标。这些计算都是在高一维的射影模型中进行，因为这时反射都是线性变换，可以避免使用仿射变换和反演。然后投影到二维。</li><li>调用绘图库绘制密铺。</li></ul></li></ol><p>其中绘制 <span class="math inline">\(\mathcal{SL}(W)\)</span>的有限状态机需要使用 <a href="https://pygraphviz.github.io/">pygraphviz</a> 模块，这个模块依赖于<a href="http://graphviz.org/">graphviz</a> 软件和<code>libgraphviz-dev</code>。</p><p>将有限状态机最小化我参考的是 <a href="https://link.springer.com/article/10.1007/BF00264025">Gries的文章</a>。Gries 的文章写的很棒，但是我认为他并没有把存储 <span class="math inline">\((B,a)\)</span> 对的列表性质讲清楚。</p><p>双曲情形的绘图我用的是一个叫 <a href="https://github.com/cduck/hyperbolic/">hyperbolic</a>的三方库。我对这个库其实不太满意，然而我一时也没有精力分出来再写一个，所以暂且先凑合着。这个库最大的好处是，它可以绘制具有常双曲宽度的边，即所谓的<a href="https://en.wikipedia.org/wiki/Hypercycle_(hyperbolic_geometry)">hypercycle</a>。</p><p>计算极小根的算法是这个代码中最大的性能陷阱。其中在判断一个极小根<span class="math inline">\(\gamma\)</span> 经过一个单反射 <span class="math inline">\(s_\alpha\)</span>以后是不是仍然是极小根时，采用的方法是判断 <span class="math inline">\(s_\gamma\)</span> 和 <span class="math inline">\(s_\alpha\)</span> 是不是生成一个有限群，即判断<span class="math inline">\(s_\gamma s_\alpha\)</span> 在单根 <span class="math inline">\(\Delta\)</span>下对应的矩阵是不是经过某次幂以后成为单位矩阵。这里面矩阵的元素都是分圆域里的代数整数，形如<span class="math inline">\(p(\xi)\)</span>，其中 <span class="math inline">\(p(x)\)</span> 是一个不可约整系数多项式，<span class="math inline">\(\xi\)</span> 是本原 <span class="math inline">\(m\)</span> 次单位根，其中 <span class="math inline">\(m\)</span> 是 Coxeter矩阵中所有元素的最大公倍数乘以 2。<span class="math inline">\(\xi\)</span> 可以用分圆多项式 <span class="math inline">\(\Phi_m(x)\)</span> 来描述。于是矩阵的计算被归结为<span class="math inline">\(\mathbb{Z}[x]/(\Phi_m(x))\)</span>中的多项式运算。这个计算量非常依赖于 <span class="math inline">\(m\)</span> 的值：例如对 (19, 20, 21)这样的三角群，<span class="math inline">\(\Phi_m(x)\)</span>的表达式非常复杂，计算速度就很慢了。这一点与逆像素反射方法是不同的，逆像素反射法的计算量几乎不随群的变化而变化。</p><p>一种更合理的实现方法见 <a href="https://github.com/ulthiel/CoxeterGroups.jl">这里</a>。</p><h1 id="附录对若干关键点的解释">附录：对若干关键点的解释</h1><p>在这里我简单回答前面正文中埋下的 <a href="#prob1" title="问题 3.1">问题 3.1</a> 和 <a href="#prob2" title="问题 3.2">问题3.2</a>。这部分内容需要你了解 Coxeter 群的几何实现、Tits锥、根系等预备知识，这部分内容可以参考 Humphreys 的教材。</p><p>仍然以 (7, 2, 3) 这个群为例子，先看下图：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/roots.png" width="600"></p><p>这个图和上图一样，只不过多了 12 个标记出的镜面，这 12个镜面有特殊的含义：它们是群 <span class="math inline">\(W\)</span>的根系中的 12 个极小根。</p><p>你可以把 <span class="math inline">\(W\)</span>的根系理解为图中所有的圆弧，每个圆弧都是一个反射镜面，这些镜面都是 <span class="math inline">\(\Delta ABC\)</span> 三条边所在的初始镜面 <span class="math inline">\(AB,AC,BC\)</span> 在群 <span class="math inline">\(W\)</span>作用下的结果。每个镜面有正反两面，其中基本区域 <span class="math inline">\(\Delta ABC\)</span>所在的那一面是镜子的正面，另一面是背面。镜子正面的法向量给出一个正根，背面对应的法向量是将该正根取负（负根）。</p><p>我们总是用一个镜子的正法向量（正根）来指代这面镜子。</p><p>从直观上说，极小根 <span class="math inline">\(\gamma\)</span>是那些满足如下条件的镜面：假设一个人站在 <span class="math inline">\(\Delta ABC\)</span> 的内部往外看，则不存在任何镜面<span class="math inline">\(\beta\ne\gamma\)</span> 完全挡在 <span class="math inline">\(\gamma\)</span> 前面，使得这个人看不到 <span class="math inline">\(\gamma\)</span>的任何一点。这个话反过来说就是，如果这个人要从 <span class="math inline">\(\Delta ABC\)</span> 的内部出发，走到 <span class="math inline">\(\gamma\)</span>的背面去，无论他怎么走都必须先跨过另一个镜子 <span class="math inline">\(\beta\ne \gamma\)</span>，那么 <span class="math inline">\(\gamma\)</span>就<strong>不是</strong>极小根。</p><p>单根必然都是极小根，因为它们是基本区域的边界，不可能还有镜子挡在它们和基本区域之间。</p><p>关于极小根的一个重要事实是，<strong>任何有限生成 Coxeter群的极小根的个数都是有限的</strong>。这个结论在 Brink 和 Howlett的证明中起到最关键的作用。</p><p>极小根的反射表 <code>reftable</code> 定义如下：它是一个二维数组，其第<span class="math inline">\(i\)</span> 行对应第 <span class="math inline">\(i\)</span> 个极小根 <span class="math inline">\(\alpha_i\)</span>，其第 <span class="math inline">\(j\)</span> 列对应第 <span class="math inline">\(j\)</span> 个生成元 <span class="math inline">\(s_j\)</span>，其 <span class="math inline">\((i,j)\)</span> 位置填入的是 <span class="math inline">\(\beta=s_j(\alpha_i)\)</span> 的结果：</p><ol type="1"><li>如果 <span class="math inline">\(\beta=\alpha_k\)</span> 是第 <span class="math inline">\(k\)</span> 个极小根，则填入 <span class="math inline">\(k\)</span>。</li><li>如果 <span class="math inline">\(\beta\)</span> 是一个负根（此情形发生当且仅当 <span class="math inline">\(\alpha_i\)</span> 是第<span class="math inline">\(j\)</span> 个单根），则填入<code>-1</code>。</li><li>如果 <span class="math inline">\(\beta\)</span>是一个正根，但不是极小根，则填入 <code>None</code>。</li></ol><p>(7, 2, 3) 群的极小根反射表如下：</p><table><thead><tr class="header"><th style="text-align: center;">root</th><th style="text-align: center;"><span class="math inline">\(s_0\)</span></th><th style="text-align: center;"><span class="math inline">\(s_1\)</span></th><th style="text-align: center;"><span class="math inline">\(s_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">-1</td><td style="text-align: center;">3</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">4</td><td style="text-align: center;">-1</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">5</td><td style="text-align: center;">-1</td></tr><tr class="even"><td style="text-align: center;">3</td><td style="text-align: center;">6</td><td style="text-align: center;">0</td><td style="text-align: center;">7</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">1</td><td style="text-align: center;">8</td><td style="text-align: center;">9</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">9</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;">3</td><td style="text-align: center;">10</td><td style="text-align: center;">11</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;">11</td><td style="text-align: center;">7</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;">10</td><td style="text-align: center;">4</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">9</td><td style="text-align: center;">5</td><td style="text-align: center;">None</td><td style="text-align: center;">4</td></tr><tr class="odd"><td style="text-align: center;">10</td><td style="text-align: center;">8</td><td style="text-align: center;">6</td><td style="text-align: center;">None</td></tr><tr class="even"><td style="text-align: center;">11</td><td style="text-align: center;">7</td><td style="text-align: center;">None</td><td style="text-align: center;">6</td></tr></tbody></table><p>设 <span class="math inline">\(W\)</span> 的所有极小根之集为 <span class="math inline">\(\Sigma\)</span>，<span class="math inline">\(\mathcal{SL}(W)\)</span> 的有限状态机 <span class="math inline">\(\mathcal{A}\)</span> 由如下规则给出：</p><ol type="1"><li><p><span class="math inline">\(\mathcal{A}\)</span> 的状态是 <span class="math inline">\(\Sigma\)</span> 的子集，其中初始状态为空集 <span class="math inline">\(\emptyset\)</span>。</p></li><li><p>从一个状态 <span class="math inline">\(S\)</span>转移到另一个状态 <span class="math inline">\(S'\)</span>的规则为：</p><p><span class="math display">\[S\xrightarrow{\ s_i\ } \{s_i\} \cup(s_i(S)\cup\{ s_i(\alpha_j),j&lt;i\})\cap\Sigma.\]</span></p></li></ol><p>我们可以用宽度优先搜索找到所有的状态以及它们之间的转移关系，然后用 <a href="https://en.wikipedia.org/wiki/DFA_minimization#Hopcroft's_algorithm">Hopcroft算法</a> 将得到的有限状态机最小化。</p><p>下图显示的是 (7, 2, 3) 这个群的状态机 <span class="math inline">\(\mathcal{A}\)</span>，每个状态的标号反映了它是<span class="math inline">\(\Sigma\)</span> 的哪个子集，例如<code>9 : {1, 2, 3, 5}</code> 表示这个状态的编号是 9，它是由第 1, 2, 3,5 个极小根构成的集合。</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/723_dfa_subsets.png" width="600"></p><p>计算两个群元素乘法的规范表示的算法来自Casselman。这个讲解起来可就太费功夫了，我可能未来需要专门再开一篇文章介绍。其代码如下，其中<code>s</code> 是一个生成元，<code>word</code>是一个逆最短字典序下的单词（逆最短字典序就是把最短字典序中的单词反过来），函数返回的也是对应结果在逆最短字典序下的规范形式：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">left_mul_invshortlex</span>(<span class="hljs-params">reftable, s, word</span>):</span><br>    word = <span class="hljs-built_in">tuple</span>(word)<br>    t = s<br>    k = -<span class="hljs-number">1</span><br>    mu = s<br>    <span class="hljs-keyword">for</span> i, s_i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(word):<br>        <span class="hljs-keyword">if</span> mu <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-keyword">return</span> word[:k+<span class="hljs-number">1</span>] + (t,) + word[k+<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">elif</span> mu &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> word[:i] + word[i+<span class="hljs-number">1</span>:]<br>        <span class="hljs-keyword">elif</span> mu &lt; s_i:<br>            t = mu<br>            k = i<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">return</span> word[:k+<span class="hljs-number">1</span>] + (t,) + word[k+<span class="hljs-number">1</span>:]<br></code></pre></td></tr></tbody></table></figure><p>由此函数不难计算任何两个单词相乘的逆最短字典序下的规范形式，倒过来自然也就解决了最短字典序下的乘法问题。</p><p>这里先在逆字典序下计算然后再倒过来获得字典序是为了和 Casselman的文章中的论述保持一致。</p><p>计算一个规范表示的单词 <code>word</code>关于某个标准椭圆子群的陪集是最简单的：设 <span class="math inline">\(W_T\)</span> 是一个标准椭圆子群，其生成元是 <span class="math inline">\(W\)</span> 的生成元 <span class="math inline">\(S\)</span> 的一个子集 <span class="math inline">\(T\)</span>，则计算 <code>word</code> 关于 <span class="math inline">\(W_T\)</span> 的左陪集代表元的伪代码如下：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">x := word<br>u := 1<br>while l(xt) &lt; l(x) for some t in T<br>    x = xt<br>    u = tu<br>end<br><br>return x<br></code></pre></td></tr></tbody></table></figure><p>其中 <span class="math inline">\(l(\cdot)\)</span> 是 Coxeter群上的长度函数。这个算法会把 <code>word</code> 分解为形如 <span class="math inline">\(x^T\cdot w_T\)</span> 的形式，其中 <span class="math inline">\(w_T\in W_T\)</span>，且对任何 <span class="math inline">\(t\in T\)</span> 有 <span class="math inline">\(l(x^Tt)&gt;l(x^T)\)</span>。最终得到的陪集代表元<span class="math inline">\(x^T\)</span> 是规范表示。</p><p>对有限 Coxeter 群，其所有正根都是极小根；对仿射 Coxeter群，其根系由一些平行的镜面族构成，每族镜面中的反射镜面互相平行。每个族中存在一对极小根，它们把基本区域<span class="math inline">\(\Delta ABC\)</span>夹在中间并完全挡住本族中外面的镜面，所以只有它俩才是极小根。下图显示的是(6, 2, 3) 密铺 （对称群为仿射 <span class="math inline">\(\widetilde{G}_2\)</span>） 的 12 个极小根：</p><p><img style="margin:0px auto;display:block" src="/images/coxeter/roots_623.png" width="600"></p><h1 id="参考文献">参考文献</h1><p>关于 Coxeter 群中的计算，我主要参考的是 Casselman 的三篇文章：</p><ol type="1"><li><p><a href="https://www.math.ubc.ca/~cass/research/pdf/banff.pdf">Automata toperform basic calculations in Coxeter groups, by BillCasselman</a>.</p></li><li><p><a href="https://www.math.ubc.ca/~cass/research/pdf/cm.pdf">Computation inCoxeter groups I. Multiplication, by Bill Casselman</a>.</p></li><li><p><a href="https://www.math.ubc.ca/~cass/research/pdf/roots.pdf">Computationin Coxeter groups II. Constructing minimal roots, by BillCasselman</a>.</p></li></ol><p>关于 Coxeter 群的自动性质，可以参考 Brink &amp; Howlett 的论文：</p><ol type="1"><li><a href="https://link.springer.com/article/10.1007/BF01445101">Afiniteness property an an automatic structure for Coxetergroups</a>.</li></ol><p>关于 Coxeter 群的基础知识，毫无疑问应该参考 Humphreys 的经典教材</p><ol type="1"><li><a href="https://www.cambridge.org/core/books/reflection-groups-and-coxeter-groups/2910C1E00877D33A04A512791B6EDD72">ReflectionWroups and Coxeter Wroups, by James E. Humphreys</a>.</li></ol>]]></content>
    
    
    <summary type="html">
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;更新&lt;/strong&gt;：由于使用 POV-Ray
渲染三维双曲蜂巢非常的慢，所以我放弃了这种途径，并将代码从 Github
主分支中移除。你可以在 &lt;a href=&quot;https://github.com/neozhaoliang/pywonderland/releases/tag/0.1.0&quot;&gt;旧存档&lt;/a&gt;
中找到本文使用的代码。关于怎样渲染双曲蜂巢读者可以参考 &lt;a href=&quot;https://github.com/neozhaoliang/Hyperbolic-Honeycombs/&quot;&gt;另一个项目&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文介绍我刚刚完成的一个 &lt;a href=&quot;https://github.com/neozhaoliang/pywonderland/&quot;&gt;Python
程序&lt;/a&gt;。虽然是刚刚完成，但是它占去了我这半年来大部分的业余时间，也算是一个艰苦攻关，呕心沥血之作。主要是它涉及的理论比较复杂，要用到
Coxeter 群的一些深刻的性质，即所谓的 automatic
property。这半年里面不少时间是花在学习 Casselman 和 Brink &amp;amp; Howlett
等人的文章上面，这才弄懂了其中的数学原理（见参考文献）。&lt;/p&gt;
&lt;p&gt;虽然完成这个程序很有成就感，但是我无意强调这个程序的任何优越性：它采用的
Coxeter
群的计算方法并不先进，难入行家的法眼。而且它的代码比较丑，大概率除了我，别人也很难用起来。&lt;/p&gt;
&lt;p&gt;这个程序的目的是使用群论的方式来绘制二维和三维的各种 &lt;a href=&quot;https://en.wikipedia.org/wiki/Uniform_tiling&quot;&gt;均匀密铺&lt;/a&gt;。所谓均匀密铺，你可以理解为用一些正多边形的瓷砖密铺整个空间，使得瓷砖的顶点在对称群作用下是传递的（构成单一轨道）。&lt;/p&gt;
&lt;p&gt;我先展示一些这个程序的例子，然后介绍它的实现原理。&lt;/p&gt;</summary>
    
    
    
    <category term="pywonderland 项目" scheme="https://pywonderland.com/categories/pywonderland-%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Coxeter group" scheme="https://pywonderland.com/tags/Coxeter-group/"/>
    
    <category term="Uniform tilings" scheme="https://pywonderland.com/tags/Uniform-tilings/"/>
    
    <category term="POV-Ray" scheme="https://pywonderland.com/tags/POV-Ray/"/>
    
    <category term="Automata" scheme="https://pywonderland.com/tags/Automata/"/>
    
    <category term="Minimal roots" scheme="https://pywonderland.com/tags/Minimal-roots/"/>
    
    <category term="Regular language" scheme="https://pywonderland.com/tags/Regular-language/"/>
    
    <category term="DFA minimization" scheme="https://pywonderland.com/tags/DFA-minimization/"/>
    
    <category term="Hyperbolic tilings" scheme="https://pywonderland.com/tags/Hyperbolic-tilings/"/>
    
    <category term="Spherical tilings" scheme="https://pywonderland.com/tags/Spherical-tilings/"/>
    
    <category term="Euclidean tilings" scheme="https://pywonderland.com/tags/Euclidean-tilings/"/>
    
  </entry>
  
  <entry>
    <title>刺客 vs 保镖</title>
    <link href="https://pywonderland.com/assassin-vs-bodyguards/"/>
    <id>https://pywonderland.com/assassin-vs-bodyguards/</id>
    <published>2019-07-18T16:00:00.000Z</published>
    <updated>2025-03-21T12:05:32.683Z</updated>
    
    <content type="html"><![CDATA[<p>Maryam Mirzakhani 在 2014 年的报告中提出了如下的问题（视频的 25 分 50秒处）：</p><iframe width="560" height="315" src="https://www.youtube.com/embed/tprlQMClSYQ?si=WTY5EAbK2GTigsrv" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen=""></iframe><div class="unnumbered statement question-unnumbered definition"><p><span class="statement-heading"><span class="statement-label">问题</span>：</span><span class="statement-spah"></span>假设平面上有一个正方形的房间，房间的四面墙壁都是光滑的反射镜子。子弹在碰到墙壁时会遵循入射角等于出射角的规律无限反射下去。房间中有一位政要和一个刺客，他们的位置是固定的，但可能是房间中任何两点。能否在房间中放置有限数量的保镖，使得这些保镖可以封锁刺客的所有射击角度，从而确保政要不被子弹击中？</p></div><p>根据 <a href="http://www.numdam.org/item/10.5802/aif.2124.pdf">这篇论文</a>的考据，这个问题曾经在 1989 年列宁格勒的数学竞赛中出现过。最近，通过 <a href="https://www.youtube.com/watch?v=a7gp9c2p0UQ">PBS</a> 和 <a href="https://www.math3ma.com/blog/is-the-square-a-secure-polygon">math3ma的博客</a>的科普推广，这个问题又引起了不少人的兴趣。我强烈建议读者在深入阅读本文之前，先观看这些视频和博客。它们的讲解通俗易懂，即便对于普通读者来说也非常友好。</p><p>Greg Egan 在 <a href="https://gregegan.net/SCIENCE/Lattices/Lattices.html">他的博客中</a>进一步讨论了房间是正三角形和正六边形的情况。虽然他给出的答案是正确的，但是他对正六边形情形的解释有点让人难以理解（GregEgan 的一贯风格）。</p><p>正三角形、正方形和正六边形房间是仅有的三种可以用有限多个保镖保护目标的情形，对其它正<span class="math inline">\(N\)</span> 边形房间（<span class="math inline">\(N\notin\{3,4,6\}\)</span>），有限数量的保镖是不行的。</p><p>本文是对 math3ma 和 Greg Egan博客文章的补充，我将主要针对正六边形的情况进行详细解释。我觉得从仿射Weyl群的角度来看这个问题会更清晰，不过这一概念可能对大多数读者来说较为陌生。本文将假定读者已具备群的相关基础知识，并尽可能结合直观图形加以说明。如果读者希望进一步了解仿射Weyl 群，可以参考 <span class="citation" data-cites="Humphreys90">(<a href="#ref-Humphreys90" role="doc-biblioref">Humphreys 1990, chap.4</a>)</span>。</p><p>本文的代码在 <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/assassin_vs_bodyguards">Github上</a>。这个项目包含了一个交互式脚本，你可以在窗口中点击并拖拽鼠标来查看刺客射击的轨迹以及保镖的位置：</p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr class="odd"><td style="text-align: center;">正方形</td><td style="text-align: center;">正三角形</td><td style="text-align: center;">正六边形</td></tr><tr class="even"><td style="text-align: center;"><img src="/images/polygon-billiard/square_guards.svg" height="200"></td><td style="text-align: center;"><img src="/images/polygon-billiard/triangle_guards.svg" height="200"></td><td style="text-align: center;"><img src="/images/polygon-billiard/hexagon_guards.svg" height="200"></td></tr></tbody></table><span id="more"></span><h1 id="反射和平移">反射和平移</h1><p>在照镜子的时候，你和自己在镜子中的像的左右是相反的，即镜面反射会改变“手性”。因此无论怎么平移或者旋转，你都无法与自己在镜子中的像完全重合。</p><p><img src="/images/polygon-billiard/inception.jpg" class="fig" width="500"></p><p>但是如果把镜子中的虚像通过另一面镜子再作一次反射，得到一个二次虚像，那么通过适当的平移或者旋转，你是可以和这个二次虚像完全重合的。这是因为两个反射变换的复合是一个平移或者旋转。具体取决于两个镜子的夹角：</p><ol type="1"><li>两个相交且夹角为 <span class="math inline">\(\theta\)</span>的镜面反射的复合是一个角度为 <span class="math inline">\(2\theta\)</span> 的旋转。</li><li>两个平行且距离为 <span class="math inline">\(d\)</span>的镜面反射的复合是一个距离为 <span class="math inline">\(2d\)</span>的平移。</li></ol><p>所以偶数次反射等同于若干次旋转和平移的叠加，手性不变；奇数次反射等同于若干次旋转和平移后再附加一次反射，手性相反。</p><p>观察上面盗梦空间的剧照，小李子位于两个平行的镜子中间，他有无穷多个虚像。这些虚像是交错出现的：那些面对他的虚像是经过奇数次反射得到的，这些虚像的手性和他相反，它们构成了集合<span class="math inline">\(L_1\)</span>；那些背对他的虚像是经过偶数次反射得到的（小李子本人看作<span class="math inline">\(0\)</span>次反射的像），这些虚像可以经过平移以后和他重合，它们构成了集合 <span class="math inline">\(L_2\)</span>。假设两个镜子的距离为 <span class="math inline">\(d\)</span>，则每个 <span class="math inline">\(L_i\)</span> 中的虚像以 <span class="math inline">\(2d\)</span> 为间隔均匀分布在一条直线上。</p><p>如果我们想在两个镜子中间放置若干保镖，以防止摄影师从任何角度拍摄到小李子，则我们恰好需要4名保镖。他们需要分别挡住小李子本人、小李子关于两个镜子第一次反射生成的两个虚像，以及任意一个二次反射生成的虚像。保镖们的位置是摄影师和小李子这四个虚像连线的中点。</p><figure><img src="/images/polygon-billiard/parallel.svg" width="400" alt="红色圆点表示刺客，绿色圆点表示目标，它们之间有四个保镖"><figcaption aria-hidden="true">红色圆点表示刺客，绿色圆点表示目标，它们之间有四个保镖</figcaption></figure><p>为什么需要 4 名保镖呢？假设一个保镖 <span class="math inline">\(G\)</span> 挡住了小李子的某个虚像 <span class="math inline">\(A\in L_1\)</span>（<span class="math inline">\(A\in L_2\)</span> 的分析是类似的）。<span class="math inline">\(G\)</span>的虚像也由两个格点组成，每个格点也都是间隔 <span class="math inline">\(2d\)</span>均匀排列的。根据三角形的相似原理，<span class="math inline">\(G\)</span>的奇数次反射构成的格点在 <span class="math inline">\(L_1\)</span>上的投影间隔是 <span class="math inline">\(4d\)</span>，这些投影覆盖了<span class="math inline">\(L_1\)</span> 中一半的格点。另一方面 <span class="math inline">\(G\)</span>的偶数次反射构成的格点一般来说是无用的（除非狗仔和明星恰好位于某些特殊位置）。所以保镖<span class="math inline">\(G\)</span> 只能挡住小李子的所有虚像的1/4。</p><h1 id="正方形-正三角形-正六边形">正方形 | 正三角形 | 正六边形</h1><p>理解正多边形房间情形的第一个关键，是要知道刺客的任何射击轨迹都可以展开为平面上的一条射线。刺客可以击中目标当且仅当这条射线经过目标的某个虚像。这个操作叫做展开(unfolding)。</p><p>与展开相对的操作是折叠 (folding)，我们可以用折叠操作将刺客发出的任何射线折叠回房间变成一条射击轨迹。具体做法如下：假设刺客位于点<span class="math inline">\(p\)</span>，虚像位于点 <span class="math inline">\(q\)</span>，则线段 <span class="math inline">\(\overline{pq}\)</span> 连接 <span class="math inline">\(p\)</span> 所在的真实房间和 <span class="math inline">\(q\)</span>所在的虚像房间，并且穿过若干房间的墙壁。记 <span class="math inline">\(\overline{pq}\)</span> 穿过的墙壁依次为 <span class="math inline">\(l_1,\ldots,l_m\)</span>，则将 <span class="math inline">\(q\)</span> 依次沿着墙壁 <span class="math inline">\(l_m,\ldots,l_1\)</span> 反射就可以将 <span class="math inline">\(q\)</span> 映射回真实房间。</p><p>当房间是正方形时，目标的所有虚像由 4个不同的二维格点组成，如下图所示：</p><figure><img src="/images/polygon-billiard/square_lattice.svg" width="350" alt="假设左下角的单位正方形是真实房间，如果我们在房间中摆放一个 L 形的记号，那么平面上每个单位正方形中都会出现一个 L 的虚像，这些虚像有四种不同的定向，具有相同定向的那些 L 之间互相只差一个平移，因而构成一个二维格点"><figcaption aria-hidden="true">假设左下角的单位正方形是真实房间，如果我们在房间中摆放一个L 形的记号，那么平面上每个单位正方形中都会出现一个 L的虚像，这些虚像有四种不同的定向，具有相同定向的那些 L之间互相只差一个平移，因而构成一个二维格点</figcaption></figure><p>刺客只要朝着目标的任何一个虚像开枪就能击中目标，因为他和任何虚像之间的连线都可以通过折叠操作变成一条子弹的反射路径：</p><figure><img src="/images/polygon-billiard/square_lattice_with_targets.svg" width="350" alt="左下角是真实房间，红色圆点是刺客，空心圆圈是目标，灰色圆点是保镖。目标在每个房间中都有一个虚像，刺客和任何一个虚像之间的连线都对应一条可以击中目标的反射路径"><figcaption aria-hidden="true">左下角是真实房间，红色圆点是刺客，空心圆圈是目标，灰色圆点是保镖。目标在每个房间中都有一个虚像，刺客和任何一个虚像之间的连线都对应一条可以击中目标的反射路径</figcaption></figure><p>在 math3ma 的博客中已经证明了封锁一个二维格点需要 4名保镖，所以一共需要 4 x 4=16 名保镖。</p><p>当房间是正三角形时，目标的所有虚像由 6 个不同的二维格点组成：</p><p><img src="/images/polygon-billiard/triangle_lattice.svg" class="fig" width="350"></p><p>同样刺客与目标的任何虚像之间的连线都对应一条房间内的射击路径：</p><p><img src="/images/polygon-billiard/triangle_lattice_with_targets.svg" class="fig" width="350"></p><p>封锁每个二维格点需要 4 个保镖，所以正三角形的情形总共需要 4 x 6 = 24名保镖。</p><p>正六边形是一个容易产生迷惑的情形。这时目标的虚像仍然由 6个不同的二维格点构成：</p><p><img src="/images/polygon-billiard/hexagon_lattice.svg" class="fig" width="350"></p><p>但是，如果你仍然猜测需要 4 x 6 = 24名保镖，那对不起，事情不是这样的。</p><p>注意在正六边形房间的情形，出现了一个不同的现象：沿着不同的路径反射，目标的虚像可以出现在另一个房间中不同的位置：</p><p><img src="/images/polygon-billiard/chirality-2.svg" class="fig" width="350"></p><p>由于光路的可逆性，这个话也可以反过来说，即虚像房间中的一点，它的原像可能来自真实房间中若干个不同的位置。我们后面会说明这样的位置最多有6种不同的可能。具体是哪个位置和反射路径有关，即和刺客与保镖虚像的连线有关。沿着每一个这样的连线把保镖的虚折叠回真实房间，保镖最终的位置可能是这6 个位置中的任何一个。所以保镖数目要乘以 6，即总共需要 4 x 6 x 6 = 144名保镖。</p><p>下图也验证了这一点：</p><p><img style="margin:0px auto;display:block" src="/images/polygon-billiard/24_guards_each_lattice.svg" height="350"></p><p>我选择了明星的 6个虚像格点中的一个，用黄色的点标记；刺客与每个虚像连线的中点有一个保镖的虚像，这个虚像来自房间中某个真实的保镖（用青色的点标记）。把射线折叠回房间我们可以得到真实保镖的位置。然而即便对同一个保镖，随着他的虚像变化，这个位置也可能不同，有6 种可能，所以封锁一个格点就需要 4 x 6 = 24 个保镖，封锁全部 6个格点需要 144 个保镖！</p><h1 id="仿射-weyl-群">仿射 Weyl 群</h1><p>从群论的角度可以更好的解释上面的现象。</p><p>首先介绍一个记号：设 <span class="math inline">\(\alpha\in\mathbb{R}^2\)</span>是一个单位向量，我们用 <span class="math inline">\(H_{\alpha,k}\)</span>表示仿射直线 <span class="math display">\[H_{\alpha,k}=\{x\in\mathbb{R}^2\mid (x,\alpha)=k\},\quad k\in\mathbb{Z}.\]</span>并用 <span class="math inline">\(s_{\alpha,k}\)</span> 表示关于 <span class="math inline">\(H_{\alpha,k}\)</span> 的反射。当 <span class="math inline">\(k=0\)</span> 时我们把 <span class="math inline">\(H_{\alpha,0}\)</span> 简写为 <span class="math inline">\(H_\alpha\)</span>，把 <span class="math inline">\(s_{\alpha,0}\)</span> 简写为 <span class="math inline">\(s_{\alpha}\)</span>。</p><p>正三角形、正方形、正六边形房间的共同之处，是房间的所有虚像可以密铺整个二维平面。而且它们是仅有的具有此性质的正多边形。这背后的原因是，这三种情形下，关于房间墙壁的反射生成的群<span class="math inline">\(W\)</span> 都是 <a href="https://en.wikipedia.org/wiki/Coxeter_group#Affine_Coxeter_groups">仿射Weyl 群</a>。仿射 Weyl群总是无限群，每个虚像房间都是通过将群元素作用在真实房间上得到的。</p><ol type="1"><li>在正方形的情形，<span class="math inline">\(W=\widetilde{A}_1\times\widetilde{A}_1\)</span>。</li><li>在正三角形和正六边形的情形，<span class="math inline">\(W=\widetilde{A}_2\)</span>。</li></ol><p>实际上在两个平行镜面的情形，尽管房间不是封闭多边形，<span class="math inline">\(W\)</span> 也是仿射 Weyl 群 <span class="math inline">\(\widetilde{A}_1\)</span>。</p><p>仿射 Weyl 群总可以分解为一个有限 Weyl 群 <span class="math inline">\(W_{\rm fin}\)</span> 和一个格点群 <span class="math inline">\(L\)</span> 的半直积： <span class="math display">\[W = W_{\rm fin}\ltimes L.\]</span> <span class="math inline">\(W_{\rm fin}\)</span> 的根系 <span class="math inline">\(\Phi\)</span> 是有限的；<span class="math inline">\(L\)</span> 是 <span class="math inline">\(\Phi\)</span> 的余根格点。</p><p>我们分别来考察它们：</p><p>在正方形的情形，假设房间 <span class="math inline">\(C=[0,1]\times[0,1]\)</span>是单位正方形。它的四面墙由两组平行的镜面组成，每组平行镜面生成的反射群是无穷二面体群<span class="math inline">\(\widetilde{A}_1\)</span>。由于这两组镜面互相垂直，所以它们合起来生成的反射群是两个<span class="math inline">\(\widetilde{A}_1\)</span> 的直积，即 <span class="math inline">\(W=\widetilde{A}_1\times\widetilde{A}_1\)</span>。</p><p><img src="/images/polygon-billiard/a1xa1.svg" class="fig" height="500"></p><p>我们来看看怎样把 <span class="math inline">\(W\)</span> 拆成 <span class="math inline">\(W=W_{\rm fin}\ltimes L\)</span> 的形式。</p><p>设 <span class="math inline">\(\alpha_1=(1,0),\alpha_2=(0,1)\)</span>是过原点的两个墙壁的法向量，记 <span class="math inline">\(\alpha_1^\vee=2\alpha_1\)</span> 和 <span class="math inline">\(\alpha_2^\vee=2\alpha_2\)</span>。在数学术语中，<span class="math inline">\(\alpha_1^\vee\)</span> 和 <span class="math inline">\(\alpha_2^\vee\)</span> 被称为 <span class="math inline">\(\alpha_1\)</span> 和 <span class="math inline">\(\alpha_2\)</span> 的余根 (coroot)。</p><p>记 <span class="math inline">\(s=s_{\alpha_1},t=s_{\alpha_2}\)</span>，则反射<span class="math inline">\(s,t\)</span> 生成的群是 Klein 群 <span class="math inline">\(K_4=\{1,s,t,st\}\)</span>。它就是上面直积分解中的<span class="math inline">\(W_{\rm fin}\)</span>。</p><p>设 <span class="math inline">\(L=\mathbb{Z}\alpha_1^\vee +\mathbb{Z}\alpha_2^\vee=2\mathbb{Z}\)</span> 是由余根 <span class="math inline">\(\alpha_1^\vee\)</span> 和 <span class="math inline">\(\alpha_2^\vee\)</span> 生成的二维格点群。则 <span class="math display">\[\widetilde{A}_1\times\widetilde{A}_1 = K_4\ltimes2\mathbb{Z}.\]</span></p><p>记真实房间为 <span class="math inline">\(C\)</span>，<span class="math inline">\(W\)</span> 在 <span class="math inline">\(C\)</span> 上的作用可以分成两步：首先将 <span class="math inline">\(K_4\)</span> 中的某个元素作用在 <span class="math inline">\(C\)</span> 上，得到 <span class="math inline">\(\{C,sC,tC,stC\}\)</span> 之一，然后分别在 <span class="math inline">\(x,y\)</span> 方向上平移偶数的距离。由于 <span class="math inline">\(K_4\)</span> 是 4 阶群，这解释了为什么目标虚像由 4个格点组成。</p><p><img src="/images/polygon-billiard/a2.svg" class="fig" height="500"></p><p>正三角形房间的情形是类似的。仍然记真实房间为 <span class="math inline">\(C\)</span>，并假设 <span class="math inline">\(C\)</span>的一个顶点位于原点。设经过原点的两面墙的法向量是 <span class="math inline">\(\alpha_1\)</span> 和 <span class="math inline">\(\alpha_2\)</span>，它们的夹角是 <span class="math inline">\(-\pi/3\)</span>。设 <span class="math inline">\(s=s_{\alpha_1},t=s_{\alpha_2}\)</span>是它们给出的反射，<span class="math inline">\(\alpha_1^\vee=2\alpha_1\)</span> 和 <span class="math inline">\(\alpha_2^\vee=2\alpha_2\)</span> 分别是 <span class="math inline">\(\alpha_1\)</span> 和 <span class="math inline">\(\alpha_2\)</span> 的余根。则 <span class="math inline">\(W\)</span> 可以表示为 <span class="math inline">\(s,t\)</span> 生成的有限二面体群 <span class="math inline">\(D_3\)</span> 和余根格点 <span class="math inline">\(L=\mathbb{Z}\alpha_1^\vee +\mathbb{Z}\alpha_2^\vee\)</span> 的半直积 <span class="math display">\[W=\widetilde{A}_2=D_3\ltimes L.\]</span> <span class="math inline">\(W\)</span> 在 <span class="math inline">\(C\)</span> 上的作用可以分成两步，首先用 <span class="math inline">\(D_3\)</span> 中的某个元素作用在 <span class="math inline">\(C\)</span> 上，得到环绕原点的 6 个房间 <span class="math inline">\(\{C,sC,tC,stC,tsC,stsC\}\)</span>之一，然后再将其沿着 <span class="math inline">\(L\)</span>中的一个格点进行平移。由于 <span class="math inline">\(D_3\)</span> 是 6阶群，所以目标虚像由 6 个不同的格点组成。</p><p>我们已经讨论了正方形和正三角形房间的情形，这两种情形中，群元素和房间都是一一对应的：对任何虚像房间<span class="math inline">\(C'\)</span>，有且仅有唯一的群元素 <span class="math inline">\(w\in W\)</span> 将真实房间 <span class="math inline">\(C\)</span> 映射为 <span class="math inline">\(C'\)</span>。但是在正六边形的情形，情况变得非常不同，群元素和房间是6 对 1 的关系！</p><p>我们可以继续使用上图来分析。注意到正六边形房间给出的反射群和正三角形的情形一样，都是<span class="math inline">\(\widetilde{A}_2\)</span>，因为它们都是由关于所有网格线的反射生成的。所以目标虚像也由6 个不同的格点组成。任何虚像房间也可以分两步得到：先用 <span class="math inline">\(D_3\)</span>中的某个元素作用在真实房间上，再沿着余根格点中的一个向量平移过去。但是<span class="math inline">\(D_3\)</span>保持正六边形不变，只是置换其内部的 6 个正三角形，所以最终的房间是由<span class="math inline">\(L\)</span> 唯一决定的。</p><p>这会导致什么后果呢？我们作如下分析：设 <span class="math inline">\(p\)</span> 是真实房间内的一点，<span class="math inline">\(q\)</span> 是 <span class="math inline">\(p\)</span> 的某个虚像，从而存在 <span class="math inline">\(x\in D_3\)</span> 和 <span class="math inline">\(t\in L\)</span> 使得 <span class="math inline">\(q=x\cdot p + t\)</span>。<span class="math inline">\(q\)</span> 所在的格点是 <span class="math display">\[q+L=q+\mathbb{Z}\alpha_1^\vee+\mathbb{Z}\alpha_2^\vee.\]</span>然而 <span class="math inline">\(p\)</span> 并不是真实房间中唯一可以生成<span class="math inline">\(q+L\)</span> 的点。考虑集合 <span class="math inline">\(S=\{y\cdot p\mid y\in D_3\}\)</span>，由于 <span class="math inline">\(D_3\)</span> 保持真实房间不变，所以 <span class="math inline">\(S\)</span> 都是真实房间中的点。对任何 <span class="math inline">\(y\cdot p\in S\)</span>，用 <span class="math inline">\(xy^{-1}\in D_3\)</span> 作用在 <span class="math inline">\(y\cdot p\)</span> 上，得到 <span class="math inline">\(x\cdot p\)</span>，然后按照 <span class="math inline">\(L\)</span> 进行平移，就可以得到格点 <span class="math inline">\(q+L\)</span>。这就证明了 <span class="math inline">\(p\)</span> 的一个虚像格点可以来自房间内 6个不同的位置。所以对一个保镖来说，假设 <span class="math inline">\(L\)</span>是他的某个虚像格点（由奇数或者偶数次反射生成），对他的任何虚像 <span class="math inline">\(q\in L\)</span>，刺客和 <span class="math inline">\(q\)</span> 的连线给出一个 <span class="math inline">\(\widetilde{A}_2\)</span> 中的元素 <span class="math inline">\(w\)</span>，<span class="math inline">\(w\)</span>将 <span class="math inline">\(q\)</span> 映射回真实房间的某个位置 <span class="math inline">\(p\)</span>。当 <span class="math inline">\(q\)</span> 跑遍 <span class="math inline">\(L\)</span> 时，<span class="math inline">\(p\)</span> 有 6个可能的位置。我们需要在每个位置上都放置一名保镖才能保证目标安全。这就是为什么保镖数目要乘以6。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Humphreys90" class="csl-entry" role="listitem">Humphreys, James E. 1990. <em>Reflection Groups and Coxeter Groups</em>.Cambridge Studies in Advanced Mathematics. Cambridge University Press.<a href="https://doi.org/10.1017/CBO9780511623646">https://doi.org/10.1017/CBO9780511623646</a>.</div></div>]]></content>
    
    
    <summary type="html">
&lt;p&gt;Maryam Mirzakhani 在 2014 年的报告中提出了如下的问题（视频的 25 分 50
秒处）：&lt;/p&gt;
&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/tprlQMClSYQ?si=WTY5EAbK2GTigsrv&quot; title=&quot;YouTube video player&quot; frameborder=&quot;0&quot; allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&quot; referrerpolicy=&quot;strict-origin-when-cross-origin&quot; allowfullscreen=&quot;&quot;&gt;
&lt;/iframe&gt;
&lt;div class=&quot;unnumbered statement question-unnumbered definition&quot;&gt;
&lt;p&gt;&lt;span class=&quot;statement-heading&quot;&gt;&lt;span class=&quot;statement-label&quot;&gt;问题&lt;/span&gt;：&lt;/span&gt;&lt;span class=&quot;statement-spah&quot;&gt;
&lt;/span&gt;假设平面上有一个正方形的房间，房间的四面墙壁都是光滑的反射镜子。子弹在碰到墙壁时会遵循入射角等于出射角的规律无限反射下去。房间中有一位政要和一个刺客，他们的位置是固定的，但可能是房间中任何两点。能否在房间中放置有限数量的保镖，使得这些保镖可以封锁刺客的所有射击角度，从而确保政要不被子弹击中？&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;根据 &lt;a href=&quot;http://www.numdam.org/item/10.5802/aif.2124.pdf&quot;&gt;这篇论文&lt;/a&gt;
的考据，这个问题曾经在 1989 年列宁格勒的数学竞赛中出现过。最近，通过 &lt;a href=&quot;https://www.youtube.com/watch?v=a7gp9c2p0UQ&quot;&gt;PBS&lt;/a&gt; 和 &lt;a href=&quot;https://www.math3ma.com/blog/is-the-square-a-secure-polygon&quot;&gt;math3ma
的博客&lt;/a&gt;
的科普推广，这个问题又引起了不少人的兴趣。我强烈建议读者在深入阅读本文之前，先观看这些视频和博客。它们的讲解通俗易懂，即便对于普通读者来说也非常友好。&lt;/p&gt;
&lt;p&gt;Greg Egan 在 &lt;a href=&quot;https://gregegan.net/SCIENCE/Lattices/Lattices.html&quot;&gt;他的博客中&lt;/a&gt;
进一步讨论了房间是正三角形和正六边形的情况。虽然他给出的答案是正确的，但是他对正六边形情形的解释有点让人难以理解（Greg
Egan 的一贯风格）。&lt;/p&gt;
&lt;p&gt;正三角形、正方形和正六边形房间是仅有的三种可以用有限多个保镖保护目标的情形，对其它正
&lt;span class=&quot;math inline&quot;&gt;&#92;(N&#92;)&lt;/span&gt; 边形房间（&lt;span class=&quot;math inline&quot;&gt;&#92;(N&#92;notin&#92;{3,4,6&#92;}&#92;)&lt;/span&gt;），有限数量的保镖是不行的。&lt;/p&gt;
&lt;p&gt;本文是对 math3ma 和 Greg Egan
博客文章的补充，我将主要针对正六边形的情况进行详细解释。我觉得从仿射
Weyl
群的角度来看这个问题会更清晰，不过这一概念可能对大多数读者来说较为陌生。本文将假定读者已具备群的相关基础知识，并尽可能结合直观图形加以说明。如果读者希望进一步了解仿射
Weyl 群，可以参考 &lt;span class=&quot;citation&quot; data-cites=&quot;Humphreys90&quot;&gt;(&lt;a href=&quot;#ref-Humphreys90&quot; role=&quot;doc-biblioref&quot;&gt;Humphreys 1990, chap.
4&lt;/a&gt;)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;本文的代码在 &lt;a href=&quot;https://github.com/neozhaoliang/pywonderland/tree/master/src/assassin_vs_bodyguards&quot;&gt;Github
上&lt;/a&gt;。这个项目包含了一个交互式脚本，你可以在窗口中点击并拖拽鼠标来查看刺客射击的轨迹以及保镖的位置：&lt;/p&gt;
&lt;table&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 33%&quot;&gt;
&lt;col style=&quot;width: 33%&quot;&gt;
&lt;col style=&quot;width: 33%&quot;&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&quot;odd&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;正方形&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;正三角形&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;正六边形&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&quot;even&quot;&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/polygon-billiard/square_guards.svg&quot; height=&quot;200&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/polygon-billiard/triangle_guards.svg&quot; height=&quot;200&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align: center;&quot;&gt;&lt;img src=&quot;/images/polygon-billiard/hexagon_guards.svg&quot; height=&quot;200&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</summary>
    
    
    
    <category term="pywonderland 项目" scheme="https://pywonderland.com/categories/pywonderland-%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>Todd-Coxeter 算法和 3D/4D 均匀多胞体</title>
    <link href="https://pywonderland.com/Todd-Coxeter-and-uniform-polytopes/"/>
    <id>https://pywonderland.com/Todd-Coxeter-and-uniform-polytopes/</id>
    <published>2018-05-21T00:00:00.000Z</published>
    <updated>2025-03-15T01:29:47.277Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍我写的一个高颜值的、脱离了低级趣味的小程序：用 Python 和POV-Ray 绘制各种三维多面体和四维多胞体，代码在 <a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/polytopes">Github</a>上。</p><p>以下是用这个程序渲染的一些例子，其中不同颜色的顶点/边/面表示它们在对称群的作用下位于不同的轨道中，具体解释见后。</p><span id="more"></span><h1 id="例子">例子</h1><ul><li><p>所有的 Platonic 多面体，Archimedean 多面体，比如 snubdodecahedron:</p><p><video src="/images/polytopes/snub-dodecahedron.mp4" controls=""></video></p></li><li><p>所有的 Kepler-Poinsot 多面体，比如 great icosahedron:</p><p><video src="/images/polytopes/great-icosahedron.mp4" controls=""></video></p></li><li><p>所有的四维均匀多胞体 （除去一个特例 <a href="https://en.wikipedia.org/wiki/Grand_antiprism">The grandantiprism</a>），比如我的 Github 头像 (runcinated 120-cell)：</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/github-favicon.png"></p></li><li><p>截断的四维正方体 truncated tesseract:</p><p><video src="/images/polytopes/truncated-tesseract.mp4" controls=""></video></p></li><li><p>4d cube:</p><p><img style="margin:0px auto;display:block" width="500" src="/images/polytopes/4-cube.png"></p></li><li><p>也可以是非凸的，比如星状正多胞体中的 grand stellated120-cell:</p><p><video src="/images/polytopes/grand-stellated-120-cell.mp4" controls=""></video></p></li><li><p>甚至是 5 维欧氏空间中的均匀多胞体，如 5-cube:</p><p><video src="/images/polytopes/5-cube.mp4" controls=""></video></p></li></ul><p>等等，可玩的效果是非常多的。</p><p>以上这些都是在 Python 中做好计算以后，将多胞体的数据导出到 POV-Ray中渲染得到的。你完全可以通过改写代码中的 POV-Ray的部分来渲染得出不同的效果，当然前提是需要掌握 POV-Ray的场景描述语言，不过这属于另一段故事，就不在本文的讨论范围内了。</p><p>下面介绍程序背后的数学原理。</p><h1 id="这些图画的都是什么">这些图画的都是什么？</h1><p>这些图都是三维或者四维<strong>欧氏空间</strong>中<strong>凸/非凸</strong>的<strong>均匀</strong>多胞体(polytope)，三维的情形更常用的称呼是多面体。这里有几个关键词需要注意：凸/非凸、均匀。</p><p>凸比较好理解，就是指多胞体上任意两点间的连线仍然属于此多胞体，否则就是非凸。上面的例子中Platonic 多面体、Archimedean 多面体都是凸的；但 Kepler-Poinsot多面体、星状正多胞体都是非凸的。</p><p>均匀这个词就不太好理解了。简单说就是：多胞体的所有顶点都一样，且每个二维的面都是正多边形，每个三维的胞腔都是均匀多面体（这是个递归的定义）。</p><p>要准确解释什么叫所有顶点都一样，就要用到群论的语言：一个多胞体 <span class="math inline">\(P\)</span> 的对称群 <span class="math inline">\(G\)</span>是欧氏空间中一组正交变换构成的有限群，<span class="math inline">\(G\)</span> 作用在 <span class="math inline">\(P\)</span> 上保持 <span class="math inline">\(P\)</span> 不变。所有顶点都一样的严格说法是 <span class="math inline">\(G\)</span> “传递地”作用在 <span class="math inline">\(P\)</span> 的顶点集上，即对 <span class="math inline">\(P\)</span> 的任何两个顶点 <span class="math inline">\(u,v\)</span>，都存在 <span class="math inline">\(g\in G\)</span>，<span class="math inline">\(g\)</span> 把 <span class="math inline">\(u\)</span> 映射为 <span class="math inline">\(v\)</span>。</p><h1 id="这些图是怎么画出来的">这些图是怎么画出来的？</h1><p>这些多胞体看起来样子大不相同，但它们都可以用同一种方法计算出来，叫做<a href="https://en.wikipedia.org/wiki/Wythoff_construction">Wythoff构造法</a>，也称万花筒构造法。它的原理跟我们小时候玩的万花筒的原理是一样的：在空间中放置若干过原点的反射平面（镜子），镜面之间的夹角是精心设计好的，都形如 <span class="math inline">\(\pi-\pi/p\)</span>，其中 <span class="math inline">\(p\)</span> 为有理数。在空间中选定一个初始顶点<span class="math inline">\(v_0\)</span>，将 <span class="math inline">\(v_0\)</span>关于这些镜子反复作反射变换，得到的全部镜像就是多胞体的顶点。如果 <span class="math inline">\(v_0\)</span> 关于第 <span class="math inline">\(i\)</span> 面镜子反射后得到的镜像是 <span class="math inline">\(v_1\)</span>，则 <span class="math inline">\((v_0,v_1)\)</span> 构成一条类型为 <span class="math inline">\(i\)</span>的边，我们把它以及在对称群作用下同轨道的所有边都染成 <span class="math inline">\(i\)</span> 号色。如果 <span class="math inline">\(v_0\)</span> 先关于镜面 <span class="math inline">\(i\)</span> 作反射，再关于镜面 <span class="math inline">\(j\)</span>作反射，则由于两个反射变换的复合是一个旋转变换，<span class="math inline">\(v_0\)</span>实际上是绕着某个面的中心和原点的连线作了一次旋转，旋转的角度为 <span class="math inline">\(2\pi/m\)</span> （假设镜面 <span class="math inline">\(i\)</span> 和镜面 <span class="math inline">\(j\)</span> 的法向量夹角是 <span class="math inline">\(\pi-\pi/m\)</span>），重复此旋转 <span class="math inline">\(m\)</span> 次即可得到多胞体的一个类型为 <span class="math inline">\((i,j)\)</span>的面，我们把它在对称群作用下同轨道的所有面都染成同一颜色。</p><p>这里的关键问题有两个：</p><ol type="1"><li>对于不同的均匀多胞体，应该如何放置这些镜面，并选择初始顶点？</li><li>摆好镜面和初始顶点以后，怎样不重复不遗漏地计算初始顶点的所有镜像？</li></ol><p>第一个问题的答案叫做 <a href="https://en.wikipedia.org/wiki/Coxeter%E2%80%93Dynkin_diagram">Coxeter-Dynkin图</a>，Coxeter-Dynkin图是一个带标记信息的无向图，它编码了多胞体的全部信息，即只要知道了多胞体对应的Coxeter-Dynkin 图，就可以求出该多胞体的所有数据（仅缩放大小和在空间中的摆放位置除外）。每个均匀多胞体都有一个Coxeter-Dynkin 图与之对应，但是不同的 Coxeter-Dynkin图可能描述的是相同的多胞体。</p><p>比如正方体的 Coxeter-Dynkin 图为：</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="200"></p><p>我们来解释这个图的含义：</p><p>在一个 Coxeter-Dynkin图中，每个顶点代表一面镜子，在上图中有三个顶点，所以有三面镜子。将这三面镜子从左到右依次记作<span class="math inline">\(m_0, m_1,m_2\)</span>，顶点之间的边记录了镜子间的夹角：</p><ol type="1"><li>若两个镜面之间的夹角为 <span class="math inline">\(\pi/2\)</span>则它们之间没有边相连。</li><li>若两个镜面之间的夹角为 <span class="math inline">\(\pi-\pi/3\)</span>则它们之间用一条无标记的边相连。</li><li>若两个镜面之间的夹角为 <span class="math inline">\(\pi-\pi/m\)</span> (<span class="math inline">\(m\)</span> 为有理数且 <span class="math inline">\(m&gt;2, m\ne3\)</span>)，则它们之间用一条标号为<span class="math inline">\(m\)</span> 的边相连。</li></ol><p>此外用圈出的镜面来标记初始顶点的位置，<strong>一个镜面被圈出当且仅当初始顶点不在这个镜面上</strong>。</p><p>从而在正方形的情形 <span class="math inline">\(\langlem_0,m_1\rangle=\pi-\pi/4\)</span>，<span class="math inline">\(\langlem_1,m_2\rangle=\pi-\pi/3\)</span>，<span class="math inline">\(\langlem_0,m_2\rangle=\pi/2\)</span>。初始顶点落在 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 上但是不属于 <span class="math inline">\(m_0\)</span>。</p><p>于是这三面镜子可以这样摆放：</p><ol type="1"><li>镜子 <span class="math inline">\(m_0\)</span> 的法向量可以随意，比如<span class="math inline">\(n_0=(1, 0, 0)\)</span>。</li><li>镜子 <span class="math inline">\(m_1\)</span> 的法向量 <span class="math inline">\(n_1\)</span> 与 <span class="math inline">\(n_0\)</span> 夹角为 <span class="math inline">\(3\pi/4\)</span>，于是 <span class="math inline">\(n_1\)</span> 可以取为 <span class="math inline">\((\cos\dfrac{3\pi}{4}, \sin\dfrac{3\pi}{4},0)\)</span>。</li><li>镜子 <span class="math inline">\(m_2\)</span> 的法向量 <span class="math inline">\(n_2\)</span> 与 <span class="math inline">\(n_0\)</span> 垂直，所以 <span class="math inline">\(n_2\)</span> 形如 <span class="math inline">\((0,y_3,z_3)\)</span>，它与 <span class="math inline">\(n_1\)</span> 夹角是 <span class="math inline">\(2\pi/3\)</span>，所以 <span class="math inline">\(y_3\sin\dfrac{3\pi}{4}=\cos\dfrac{2\pi}{3}\)</span>，再结合 <span class="math inline">\(n_2\)</span> 是单位向量，<span class="math inline">\(z_3=\sqrt{1-y_3^2}\)</span>，解出 <span class="math inline">\(y_3, z_3\)</span> 即可。</li></ol><p>要选择一个落在 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 上但是不落在 <span class="math inline">\(m_0\)</span> 上的初始点 <span class="math inline">\(v_0\)</span>，我们可以让 <span class="math inline">\(v_0\)</span> 到平面 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 的距离为 0，到平面 <span class="math inline">\(m_0\)</span> 的距离为 1，即</p><p><span class="math display">\[\langle v_0, n_0\rangle=1,\quad \langlev_0, n_1\rangle=0,\quad\langle v_0, n_2\rangle=0.\]</span></p><p>求解这个线性方程组即可。</p><p>我们前面提到过，要使得初始顶点的所有镜像恰好构成一个均匀多胞体，镜子之间的夹角必须精心设置，这实际上只有有限种可能。换句话说，只有有限个Coxeter-Dynkin 图可以给出 3D/4D 的均匀多胞体。在 <a href="https://en.wikipedia.org/wiki/Uniform_polytope">维基百科</a>上完整的列出了每种均匀多胞体对应的 Coxeter-Dynkin图，这里就不再专门列举了，但是特别指出两点：</p><ol type="1"><li>Coxeter-Dynkin图的标号完全决定了多胞体的对称性，而初始顶点的位置则决定了多胞体的截断类型。</li><li>对偶的多胞体具有相同的 Coxeter-Dynkin图，只不过要把边的标号从右到左反过来。比如正八面体和正方体的Coxeter-Dynkin 图是一样的，但是边的标号是 (3, 4)。</li></ol><p>第二个问题的答案叫做 Todd-Coxeter算法，展开讲的话比较复杂，我们单列一节专门谈谈。</p><h1 id="有限表现群和-todd-coxeter-算法">有限表现群和 Todd-Coxeter算法</h1><p>怎样求出初始顶点在所有镜子中的镜像？有个简单的办法：只要反复地将初始顶点关于每个镜面作反射，算出得到的镜像点的坐标，并与之前得到的点的坐标相比较（浮点数比较需要在一定的误差范围内考虑），直到不再有新的镜像点出现为止，不就得到全部顶点集吗？这个方法确实可行，但是既笨又丑陋：它完全没有用到多胞体具有对称性这一事实！</p><p>这个程序采用的是基于符号计算的途径，这个方法可以精准地得出所有顶点/边/面的信息，代价就是涉及的数学略复杂。我们先回忆一下群在集合上的作用的轨道—稳定化子定理：</p><div id="-----------------------------" class="unnumbered statement sta____________ plain"><p><span class="statement-heading"><span class="statement-label">轨道 —稳定化子定理</span>.</span><span class="statement-spah"> </span>设群<span class="math inline">\(G\)</span> 传递地作用在集合 <span class="math inline">\(S\)</span> 上，设 <span class="math inline">\(x\inS\)</span> 的稳定化子群是 <span class="math inline">\(H\)</span>，则集合<span class="math inline">\(S\)</span> 与 <span class="math inline">\(G/H\)</span> 中的右陪集之间有一一对应：<span class="math inline">\(x\cdot g\leftrightarrow Hg\)</span>。</p></div><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>和一般的约定不同，这里群在集合上的作用为作用在右边，主要是为了编程方便，实际上左边右边都一样。</p></div><p>这个定理告诉我们，如果群 <span class="math inline">\(G\)</span>传递地作用在一个集合 <span class="math inline">\(S\)</span> 上，而且对<span class="math inline">\(S\)</span> 中某个元素 <span class="math inline">\(x\)</span> 我们知道了它的稳定化子群 <span class="math inline">\(H\)</span>，则只要对 <span class="math inline">\(G/H\)</span> 的每个陪集代表元 <span class="math inline">\(g\)</span>，将 <span class="math inline">\(g\)</span> 作用在 <span class="math inline">\(x\)</span> 上就可以得到整个 <span class="math inline">\(S\)</span>。</p><p>于是给定一个均匀多胞体 <span class="math inline">\(P\)</span>，要求出其全部顶点集合，我们只要：</p><ol type="1"><li>根据 <span class="math inline">\(P\)</span> 的 Coxeter-Dynkin图确定其对称群 <span class="math inline">\(G\)</span> 和初始顶点 <span class="math inline">\(v_0\)</span>。</li><li>定出 <span class="math inline">\(v_0\)</span> 的稳定化子群 <span class="math inline">\(H\)</span> 并求出 <span class="math inline">\(G/H\)</span> 的一组陪集代表元。</li><li>将 <span class="math inline">\(G/H\)</span> 中的每个陪集代表元作用在<span class="math inline">\(v_0\)</span> 上即得 <span class="math inline">\(P\)</span> 的全部顶点。</li></ol><p>我们仍然以正方体为例来讲解：正方体的 Coxeter-Dynkin 图是</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/cube43.svg" width="200"></p><p>仍然记三个镜面为 <span class="math inline">\(m_0,m_1,m_2\)</span>，其法向量分别为 <span class="math inline">\(n_0,n_1,n_2\)</span>，设 <span class="math inline">\(\rho_0,\rho_1,\rho_2\)</span>分别是关于它们的反射变换，<span class="math inline">\(\rho_i\)</span>对应的矩阵为 <span class="math inline">\(M_i=I-2n_in_i^T\)</span>（见 <a href="https://en.wikipedia.org/wiki/Householder_transformation">Householder变换</a>）。</p><p>正方体的对称群 <span class="math inline">\(G\)</span> 由 <span class="math inline">\(\rho_0,\rho_1,\rho_2\)</span>这三个基本反射生成，其表现为： <span class="math display">\[G =\langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span>这是因为反射的平方总是恒等变换，所以 <span class="math inline">\(\rho_i^2=1\)</span>。<span class="math inline">\(\rho_0,\rho_1\)</span> 是两个夹角为 <span class="math inline">\(3\pi/4\)</span> 的反射，所以 <span class="math inline">\(\rho_0\rho_1\)</span> 是一个角度为 <span class="math inline">\(3\pi/2\)</span> 的旋转，旋转轴为 <span class="math inline">\(m_0\)</span> 和 <span class="math inline">\(m_1\)</span> 的交线，从而 <span class="math inline">\((\rho_0\rho_1)^4=1\)</span>。<span class="math inline">\(\rho_1\rho_2,\rho_0\rho_2\)</span>的情形是类似的。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p><p>利用 Todd-Coxeter 算法 （后面有解释） 不难求出这个群包含 48个元素，罗列如下： <span class="math display">\[\begin{array}{lll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{0}&amp;\rho_{1}&amp;\rho_{0}\rho_{2}\\\rho_{2}&amp;\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\\\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\\\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}&amp;\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\\\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\rho_{1}\rho_{0}\rho_{1}\rho_{2}\end{array}\]</span> 由于在正方形的 Coxeter-Dynkin 图中只有镜面 <span class="math inline">\(m_0\)</span> 是被圈出的，即初始顶点 <span class="math inline">\(v_0\)</span> 落在 <span class="math inline">\(m_1\)</span> 和 <span class="math inline">\(m_2\)</span> 上，但不属于 <span class="math inline">\(m_0\)</span>，所以反射 <span class="math inline">\(\rho_1,\rho_2\)</span> 保持 <span class="math inline">\(v_0\)</span> 不动，<span class="math inline">\(\rho_0\)</span> 将 <span class="math inline">\(v_0\)</span> 映射为其关于 <span class="math inline">\(m_0\)</span> 的镜像，于是 <span class="math inline">\(v_0\)</span> 的稳定化子群是 <a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a><span class="math display">\[H=\langle \rho_1, \rho_2\ |\\rho_1^2=\rho_2^2=(\rho_1\rho_2)^3=e\rangle.\]</span> 显然 <span class="math inline">\(H\)</span> 就是二面体群 <span class="math inline">\(D_3\)</span>，所以 <span class="math inline">\(|H|=6\)</span>，从而 <span class="math inline">\(|G/H|=8\)</span>。利用 Todd-Coxeter算法可得其一组右陪集代表元为 <span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span> 将它们作用在 <span class="math inline">\(v_0\)</span>上即可得到正方体的 8 个顶点。例如 <span class="math inline">\(\rho_0\rho_1\)</span> 作用在 <span class="math inline">\(v_0\)</span> 上为 <span class="math display">\[v_0(\rho_0\rho_1)=(v_0\rho_0)\rho_1=(v_0M_0)\rho_1=v_0M_0M_1.\]</span>其中 <span class="math inline">\(v_0\)</span> 写成行向量的形式，每个<span class="math inline">\(M_i\)</span> 是对称矩阵。</p><p>计算边/面/胞腔的原理是类似的，但考虑的细节要多一些。比如我们想求出所有关于第<span class="math inline">\(i\,(i=0,1,2)\)</span> 个镜面 <span class="math inline">\(m_i\)</span> 反射生成的类型为 <span class="math inline">\(i\)</span> 的边，可以这样做：</p><ol type="1"><li>检查初始顶点 <span class="math inline">\(v_0\)</span> 是否落在 <span class="math inline">\(m_i\)</span>上。如果答案为是，那么关于此镜面的反射保持 <span class="math inline">\(v_0\)</span> 不变，此多面体不含类型 <span class="math inline">\(i\)</span> 的边。否则设 <span class="math inline">\(v_0\)</span> 关于 <span class="math inline">\(m_i\)</span> 的镜像为 <span class="math inline">\(v_1\)</span>，则 <span class="math inline">\((v_0,v_1)\)</span> 构成一条类型为 <span class="math inline">\(i\)</span> 的边<span class="math inline">\(e\)</span>。</li><li>关于 <span class="math inline">\(m_i\)</span> 的反射 <span class="math inline">\(\rho_i\)</span> 把 <span class="math inline">\(v_0\)</span> 和 <span class="math inline">\(v_1\)</span> 互换，从而保持 <span class="math inline">\(e\)</span> 不变。<strong>注意其它任何与 <span class="math inline">\(m_i\)</span> 垂直并且包含初始点 <span class="math inline">\(v_0\)</span> 的镜面反射也会保持 <span class="math inline">\(e\)</span> 不变</strong>。在正方形的情形中，反射<span class="math inline">\(\rho_0\)</span> 互换 <span class="math inline">\(e\)</span> 的两端因而保持 <span class="math inline">\(e\)</span> 不变，此外镜面 <span class="math inline">\(m_0\)</span> 和 <span class="math inline">\(m_2\)</span> 是垂直的，且 <span class="math inline">\(v_0\)</span> 包含在 <span class="math inline">\(m_2\)</span> 中，所以反射 <span class="math inline">\(\rho_2\)</span> 保持 <span class="math inline">\(e\)</span> 上的每个点不变，于是 <span class="math inline">\(e\)</span> 的稳定化子群为 <span class="math inline">\(H=\langle \rho_0,\rho_2 \rangle\)</span>。显然<span class="math inline">\(H\)</span> 同构于 <span class="math inline">\(\mathbb{Z}_2\times\mathbb{Z}_2\)</span>，所以<span class="math inline">\(|H|=4\)</span>，从而 <span class="math inline">\(|G/H|=12\)</span>，即正方体有 12 条边 <a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>。</li><li>求出 <span class="math inline">\(G/H\)</span>的一组陪集代表元并作用在 <span class="math inline">\(e\)</span>上得出全部类型为 <span class="math inline">\(i\)</span> 的边。</li></ol><p>求面的情形复杂一些，基本原理是这样的：</p><ol type="1"><li>对 <span class="math inline">\(i\ne j\)</span>，如果初始顶点 <span class="math inline">\(v_0\)</span> 不同时属于镜面 <span class="math inline">\(i\)</span> 和镜面 <span class="math inline">\(j\)</span>，则旋转 <span class="math inline">\(\rho_i\rho_j\)</span> 就可以生成一个面 <span class="math inline">\(f\)</span>。需要注意的是，如果这两个镜面恰好垂直，则必须二者均不包含<span class="math inline">\(v_0\)</span>才能得到一个非退化的面，这个面是个正方形。在正方体的情形，<span class="math inline">\(\rho_0\rho_1\)</span> 可以生成一个面，<span class="math inline">\(\rho_0\rho_2\)</span>（两镜面垂直但只有一个镜面包含<span class="math inline">\(v_0\)</span>）和 <span class="math inline">\(\rho_1\rho_2\)</span>（两镜面均包含 <span class="math inline">\(v_0\)</span>）都不能给出面。</li><li><span class="math inline">\(f\)</span> 的稳定化子群是由 <span class="math inline">\(\rho_i,\rho_j\)</span> 和那些包含 <span class="math inline">\(v_0\)</span> 且与 <span class="math inline">\(m_i,m_j\)</span>均垂直的镜面反射生成。在正方形的情形是 <span class="math inline">\(H=\langle \rho_0,\rho_1 \rangle\)</span> <a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>，显然 <span class="math inline">\(H\)</span> 同构于二面体群 <span class="math inline">\(D_8\)</span>，因此 <span class="math inline">\(|H|=8\)</span>，<span class="math inline">\(|G/H|=6\)</span>，即正方体有 6 个面。</li></ol><p>总之关键的步骤都是给定群 <span class="math inline">\(G\)</span>和某个子群 <span class="math inline">\(H\)</span>，求 <span class="math inline">\(G/H\)</span> 的一组陪集代表元。</p><p>这里用到的算法叫做 <a href="https://en.wikipedia.org/wiki/Todd%E2%80%93Coxeter_algorithm">Todd-Coxeter算法</a>。</p><p>Todd-Coxeter算法在许多抽象代数或者群论的教材都有，用到的数学知识并不复杂。但完整描述并证明一份程序实现的细节还是很费功夫的，恐怕要好几页纸才能说清楚。限于篇幅，我这里仅用正方体的情形为例说明算法的步骤，具体的证明和更多的细节读者请参考</p><blockquote><p>Handbook of Computational Group Theory, Holt, D., Eick, B., O’Brien,E.</p></blockquote><p>中的 coset enumeration 一章。我个人认为这是讲解 Todd-Coxeter算法最棒的文献。</p><p>Todd-Coxeter 算法非常类似玩数独游戏，这里要填的表是一个变化的二维数组<span class="math inline">\(T\)</span>，<span class="math inline">\(T\)</span> 的行 <span class="math inline">\(i\)</span> 代表第 <span class="math inline">\(i\)</span> 个右陪集，<span class="math inline">\(T\)</span> 的列 <span class="math inline">\(j\)</span> 代表第 <span class="math inline">\(j\)</span> 个生成元 <span class="math inline">\(\rho_j\)</span>，<span class="math inline">\(T[i][j]\)</span> 的值等于 <span class="math inline">\(\rho_j\)</span> 右乘以第 <span class="math inline">\(i\)</span>个陪集后得到的陪集。初始时，我们知道肯定有一个陪集，就是 <span class="math inline">\(H\)</span>自身，还有没有其它的陪集我们不清楚。算法的主要流程就是根据 <span class="math inline">\(G\)</span> 和 <span class="math inline">\(H\)</span>的表现中包含的关系来发现新的陪集并填入表中，直到无法找到新的陪集为止。最终得到的<span class="math inline">\(T\)</span> 实际上是 <span class="math inline">\(G/H\)</span> 的 schreier 图的邻接矩阵，它记录了<span class="math inline">\(G/H\)</span> 的陪集间的乘法关系，由 <span class="math inline">\(T\)</span> 出发我们很容易求出这些陪集的 word表示。</p><div class="unnumbered statement example definition"><p><span class="statement-heading"><span class="statement-label">例</span>：</span><span class="statement-spah"></span>设 <span class="math inline">\(G\)</span>是正方体的对称群，其表现为 <span class="math display">\[G =\langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span>子群 <span class="math inline">\(H=\langle \rho_1,\rho_2\rangle\)</span> 是初始顶点的稳定化子群，求 <span class="math inline">\(G/H\)</span> 的一组右陪集代表元。</p></div><p>我们先罗列一下这个数独游戏已知的关系：</p><p><strong>已知关系</strong>：</p><ol type="1"><li>对 <span class="math inline">\(H\)</span> 的任何生成字 <span class="math inline">\(w\)</span> 有 <span class="math inline">\(H\cdotw=H\)</span>，即 <span class="math inline">\(H\rho_1=H\rho_2=H\)</span>。注意此关系仅要求对<span class="math inline">\(H\)</span> 成立。</li><li>对任何陪集 <span class="math inline">\(K\)</span> 和 <span class="math inline">\(G\)</span> 的任何生成关系 <span class="math inline">\(r\)</span> 有 <span class="math inline">\(K\cdotr=K\)</span>，即 <span class="math inline">\(K\rho_i^2=K,i=0,1,2\)</span> 以及 <span class="math inline">\(K(\rho_0\rho_1)^4=K(\rho_1\rho_2)^3=K(\rho_0\rho_2)^2=K\)</span>。注意此关系要求对所有陪集成立。</li></ol><p>这些关系可以存储在两个列表里面，每个关系用一个数组表示。</p><p>第一个列表存储的是 <span class="math inline">\(H\)</span>的生成字，即</p><blockquote><p><strong><span class="math inline">\(H\)</span>的生成字列表</strong>：</p><ol start="0" type="1"><li>(1,)</li><li>(2,)</li></ol></blockquote><p>第二个列表存储的是 <span class="math inline">\(G\)</span>的生成关系，即</p><blockquote><p><strong><span class="math inline">\(G\)</span>的生成关系列表</strong>：</p><ol start="2" type="1"><li>(0, 0)</li><li>(1, 1)</li><li>(2, 2)</li><li>(0, 1, 0, 1, 0, 1, 0, 1)</li><li>(1, 2, 1, 2, 1, 2)</li><li>(0, 2, 0, 2)</li></ol></blockquote><p>其中每条关系前面的数字是我们加上的编号以便于称呼。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在非 Coxeter 群的情形还要把每个生成元的逆也作为生成元加入，其在<span class="math inline">\(T\)</span> 中也占据一列，所以实际上 <span class="math inline">\(T\)</span> 的列的个数要 <span class="math inline">\(\times2\)</span>。但是在 Coxeter群的情形每个生成元是 2阶的，其逆元素等于自身，所以不需要额外考虑逆元素。</p></div><p>初始时刻表格 <span class="math inline">\(T\)</span> 是这样的：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>其中 <span class="math inline">\(H_0\)</span> 代表 <span class="math inline">\(H\)</span> 对应的陪集。程序首先验证 <span class="math inline">\(H_0\)</span> 所在的行满足第一个关系列表 （<span class="math inline">\(H\)</span>的生成字列表，随后此列表可以被丢弃），然后依次从上到下扫描 <span class="math inline">\(T\)</span> 的每一行，假设当前扫描的是第 <span class="math inline">\(i\)</span> 行，对应的陪集为 <span class="math inline">\(H_i\)</span>，程序验证确保对第二个列表 （<span class="math inline">\(G\)</span> 的生成关系列表） 中的每条关系 <span class="math inline">\(w\)</span>，<span class="math inline">\(H_i\)</span> 满足 <span class="math inline">\(H_iw=H_i\)</span>，这个过程中可能发现新的陪集，也可能发现已有的某些陪集是重复的，也有可能需要强行定义新的陪集来使得这个验证能够完成。</p><hr><p>我们来开始扫描 <span class="math inline">\(H_0\)</span>所在的行：首先检查第一个列表中的关系，<strong>这个列表仅在扫描 <span class="math inline">\(H_0\)</span>时使用一次，扫描完就可以丢弃</strong>。</p><p>(1). 对第 0 条关系 <span class="math inline">\(H_0\rho_1=H_0\)</span>，即 <span class="math inline">\(T[0][1]=0\)</span>。对第 1 条关系 <span class="math inline">\(H_0\rho_2=H_0\)</span>，即 <span class="math inline">\(T[0][2]=0\)</span>，这时 <span class="math inline">\(T\)</span> 变成了</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr></tbody></table><p>第一个列表扫描完毕，接下来扫描第二个列表。</p><p>(2). 对第 2 条关系 <span class="math inline">\(H_0\rho_0^2=H_0\)</span>，由于 <span class="math inline">\(H_0\rho_0\)</span> 还不知道，我们将其定义为新陪集<span class="math inline">\(H_1\)</span> 并将 1 填入 <span class="math inline">\(T[0][0]\)</span> 位置，此外还要为 <span class="math inline">\(H_1\)</span> 开辟新的一行：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>每次定义新陪集时，比如定义 <span class="math inline">\(H_i\rho_j=H_k\)</span>，我们同时自动得到了与之对称的关系<span class="math inline">\(H_k\rho_j=H_i\rho_j^2=H_i\)</span>，因此每次填表时我们都填写一对数字而不是一个，这样可以保证表格<span class="math inline">\(T\)</span> 的 “对称性”。</p></div><p>(3). 第 3 条和第 4 条关系已经满足，继续。</p><p>(4). 第 5 条关系，<span class="math inline">\(H_0\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1=H_0\)</span>，我们已经知道<span class="math inline">\(H_0\rho_0=H_1\)</span> 但是 <span class="math inline">\(H_1\rho_1\)</span> 还不知道，将其定义为 <span class="math inline">\(H_2\)</span>，于是 <span class="math inline">\(T\)</span> 中又添两项，并开辟新的一行给 <span class="math inline">\(H_2\)</span>：</p><table><thead><tr class="header"><th style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>但是 <span class="math inline">\(H_2\rho_0\)</span>还是不知道，所以继续定义 <span class="math inline">\(H_2\rho_0=H_3\)</span>，于是 <span class="math inline">\(T\)</span> 变成</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>于是现在关系变成了</p><p><span class="math display">\[\underbrace{\overbrace{\underbrace{H_0\rho_0}_{=H_1}\,\rho_1}^{=H_2}\,\rho_0}_{=H_3}\,\rho_1\rho_0\rho_1\rho_0\rho_1=H_0.\]</span></p><p>但是 <span class="math inline">\(H_3\rho_1\)</span>还是不知道，你可能会想把它继续定义为新的陪集 <span class="math inline">\(H_4\)</span>，然后继续扫描。<strong>这样做不是不可以，但是每次都定义新陪集会生成大量重复的陪集，导致<span class="math inline">\(T\)</span>增长的非常快，对更复杂的群非常耗费计算资源</strong>。我们采用更聪明的办法：倒着扫描整个关系，即从右到左扫描<span class="math inline">\(H_0\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1\rho_0\rho_1=H_0\)</span>这条关系。记住我们现在已经正向 （从左到右） 扫描到了下面的位置： <span class="math display">\[\underbrace{H_0\rho_0\rho_1\rho_0}_{=H_3}\,\rho_1|\rho_0\rho_1\rho_0\rho_1=H_0.\]</span>反向扫描意味着我们把上式左边末尾的 <span class="math inline">\(\rho_0\rho_1\rho_0\rho_1\)</span>挪到右边去，变形为 <span class="math display">\[\underbrace{H_0\rho_0\rho_1\rho_0}_{=H_3}\,\rho_1=\underbrace{H_0\rho_1}_{=H_0}\rho_0\rho_1\rho_0=H_0\rho_0\rho_1\rho_0=H_3.\]</span> 从而 <span class="math inline">\(H_3\rho_1=H_3\)</span>。这样通过反向扫描我们就推断出了<span class="math inline">\(H_3\rho_1\)</span>的值，避免了定义冗余的陪集。按照 Holt 书中的说法这叫做一个deduction。这时 <span class="math inline">\(T\)</span> 为</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>在实际的程序实现中，我们总是从关系的两头同时开始扫描，直到它们相遇为止。</p></div><p>(5). 关系 6 已经满足，继续。</p><p>(6). 对关系 7 <span class="math inline">\(H_0\rho_0\rho_2\rho_0\rho_2=H_0\)</span>，从两头扫描我们得到<span class="math display">\[\underbrace{H_0\rho_0}_{=H_1}\,\rho_2=\underbrace{\overbrace{H_0\rho_2}^{=H_0}\rho_0}_{=H_1}.\]</span>即 <span class="math inline">\(H_1\rho_2=H_1\)</span>，我们又得到了一个deduction，从而 <span class="math inline">\(T\)</span> 变成</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p>至此对 <span class="math inline">\(H_0\)</span>的扫描全部完成，我们转入扫描 <span class="math inline">\(H_1\)</span>所在的行。</p><hr><p><strong>注意：从现在起至程序结束，我们不再使用第一个列表</strong>。</p><p>下面开始扫描 <span class="math inline">\(H_1\)</span> 所在的行。</p><p>(1). 经检查关系 2, 3, 4, 5 已经满足，继续。</p><p>(2). 对关系 6 有 <span class="math inline">\(H_1\rho_1\rho_2\rho_1\rho_2\rho_1\rho_2=H_1\)</span>，其中<span class="math inline">\(H_1\rho_1=H_2\)</span> 已知但 <span class="math inline">\(H_2\rho_2\)</span> 未知。反向的扫描也会卡在这里：<span class="math display">\[\underbrace{H_1\rho_1}_{=H_2}\rho_2\rho_1=H_1\rho_2\rho_1\rho_2=H_2\rho_2.\]</span>所以我们定义新陪集 <span class="math inline">\(H_2\rho_2=H_4\)</span>，于是 <span class="math inline">\(H_4\rho_1=H_4\)</span>，从而此时 <span class="math inline">\(T\)</span> 为</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr></tbody></table><p>(3). 关系 7 已经满足，从而 <span class="math inline">\(H_1\)</span>检查完毕，接下来开始扫描 <span class="math inline">\(H_2\)</span>的行。</p><hr><p>下面开始扫描 <span class="math inline">\(H_2\)</span> 的行。</p><p>(1). 经检查关系 2, 3, 4, 5, 6 都已经满足，继续。</p><p>(2). 对关系 7 有 <span class="math inline">\(H_2\rho_0\rho_2\rho_0\rho_2=H_2\)</span>，两边同时扫描的结果为：<span class="math display">\[\underbrace{H_2\rho_0}_{=H_3}\rho_2\rho_0=H_2\rho_2=H_4.\]</span>即 <span class="math inline">\(H_3\rho_2\rho_0=H_4\)</span>，但是继续正向扫描<span class="math inline">\(H_3\rho_2\)</span> 不知道，继续反向扫描<span class="math inline">\(H_4\rho_0\)</span> 不知道。定义新陪集 <span class="math inline">\(H_3\rho_2=H_5\)</span>，于是 <span class="math inline">\(H_5\rho_0=H_4\)</span>，我们又可以填入两对 4个数字，此时 <span class="math inline">\(T\)</span> 为：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">3</td></tr></tbody></table><p><span class="math inline">\(H_2\)</span> 扫描完毕，下面扫描 <span class="math inline">\(H_3\)</span> 的行。</p><hr><p>我把 <span class="math inline">\(H_3, H_4, H_5\)</span>的扫描过程留给你作为练习，<span class="math inline">\(H_3\)</span>扫描结束后你得到的 <span class="math inline">\(T\)</span>应该如下图：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr></tbody></table><p><span class="math inline">\(H_4\)</span> 扫描结束后你得到的 <span class="math inline">\(T\)</span> 应该如下图：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;"><span class="math inline">\(\phantom{}\)</span></td></tr></tbody></table><p><span class="math inline">\(H_5\)</span> 的扫描给不出新的信息。</p><p>扫描 <span class="math inline">\(H_6\)</span> 时，关系 2, 3, 4, 5, 6都已经满足，由关系 7 <span class="math inline">\(H_6\rho_0\rho_2\rho_0\rho_2=H_6\)</span> 可得deduction <span class="math inline">\(H_7\rho_2=H_7\)</span>，于是 <span class="math inline">\(T\)</span> 可以补全为</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><span class="math inline">\(\rho_0\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_1\)</span></th><th style="text-align: center;"><span class="math inline">\(\rho_2\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_0\)</span></td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_1\)</span></td><td style="text-align: center;">0</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_2\)</span></td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_3\)</span></td><td style="text-align: center;">2</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_4\)</span></td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_5\)</span></td><td style="text-align: center;">4</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(H_6\)</span></td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(H_7\)</span></td><td style="text-align: center;">6</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td></tr></tbody></table><p>扫描 <span class="math inline">\(H_7\)</span>发现所有关系都已经满足。</p><p>至此 <span class="math inline">\(T\)</span>的空白位置都已经填满，没有新的陪集可以发现，数独游戏结束，这时得到的<span class="math inline">\(T\)</span> 就是 <span class="math inline">\(G/H\)</span> 的最终乘法表。</p><p>由此利用宽度优先搜索不难得出陪集间的关系为： <span class="math display">\[\begin{array}{l}H_0 = H_0\cdot e,\\H_1=H_0\cdot\rho_0,\\H_2=H_1\cdot\rho_1=H_0\cdot\rho_0\rho_1,\\H_3=H_2\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0,\\H_4=H_2\cdot\rho_2=H_0\cdot\rho_0\rho_1\rho_2,\\H_5=H_3\cdot\rho_2=H_0\cdot \rho_0\rho_1\rho_0\rho_2,\\H_6=H_5\cdot\rho_1=H_0\cdot \rho_0\rho_1\rho_0\rho_2\rho_1,\\H_7=H_6\cdot\rho_0=H_0\cdot\rho_0\rho_1\rho_0\rho_2\rho_1\rho_0.\end{array}\]</span></p><p>从而其一组陪集代表元可以选为 <span class="math display">\[\begin{array}{llll}e&amp;\rho_{0}&amp;\rho_{0}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\\\rho_{0}\rho_{1}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}&amp;\rho_{0}\rho_{1}\rho_{0}\rho_{2}\rho_{1}\rho_{0}\end{array}\]</span></p><p>这正是我们前面看到过的。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这个例子看似有点长，但还是一个比较简单的例子，其中并没有出现已知陪集重复的情形（Holt的书中称之为coincidence）。这种情形的处理麻烦一些，因为一旦出现重复的陪集，就有可能顺藤摸瓜找到更多重复的陪集。这时就要立刻暂停扫描，流程跳转到处理coincidence：开辟一个栈来存放已知的coincidence，每次弹出一对，将它们合并，然后把新发现的 coincidence压入栈中。</p></div><h1 id="星状多胞体的计算">星状多胞体的计算</h1><p>星状多胞体也可以使用 Wythoff构造法来生成，但是直接套用上面的方法一般是行不通的，我们需要在生成元中加入额外的生成关系。</p><p>这里以 <a href="https://en.wikipedia.org/wiki/Great_dodecahedron">Greatdodecahedron</a> 为例来说明：其 Coxeter-Dynkin 图为</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/coxeter552.svg" width="200"></p><p>于是三面镜子的法向量夹角分别为 <span class="math inline">\(\pi-2\pi/5, \pi/2,\pi-\pi/5\)</span>。如果我们仍然沿用以前的分析，会得出其对称群的表现为<span class="math display">\[K=\langle\tau_0,\tau_1,\tau_2 \|\  \tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=(\tau_0\tau_2)^2=1\rangle.\]</span></p><p>这是一个无限群，而且顶点的稳定化子的商群也是无限的，所以还想按以前的方法计算就行不通了。</p><p>实际上我们只要在生成关系中再加上一条 <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>即可，即对称群的表现为</p><p><span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>注意到我使用了字母 <span class="math inline">\(\tau\)</span>来表示反射，<span class="math inline">\(K\)</span> 表示 Greatdodecahedron的对称群，这个记号选择是有意的。这是怎么回事呢？先看视频：</p><video src="/images/polytopes/great-dodecahedron.mp4" width="480" controls=""></video><p>（请忽略左边错误的 Coxeter 图，这个 ui 界面我改不动）</p><p>由视频可见，Great dodecahedron 与正二十面体 (icosahedron)共用相同的顶点，并且看起来 Great dodecahedron 可以通过在 icosahedron表面挖一些三角形的洞得到。这个结论也可以推广：一般地如果星状多面体的洞是一个有<span class="math inline">\(h\)</span>条边的多边形，则对应的额外生成关系就是 <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^h=1\)</span>。</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/star.png" width="600"></p><p>在上图中，<span class="math inline">\(\Delta ABC\)</span>是正二十面体的基本区域，三个内角分别是 <span class="math inline">\(\angle CAB=\pi/5\)</span>，<span class="math inline">\(\angle CBA=\pi/2\)</span>，<span class="math inline">\(\angle ACB=\pi/3\)</span>，<span class="math inline">\(\rho_0,\rho_1,\rho_2\)</span> 分别是关于弧 <span class="math inline">\(BC, AC, AB\)</span>的反射。正二十面体的对称群的表现为 <span class="math display">\[G =\langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^3=(\rho_1\rho_2)^5=(\rho_0\rho_2)^2=1\rangle.\]</span></p><p>Great dodecahedron 可以这样得到：沿着正二十面体的边从顶点 <span class="math inline">\(Q\)</span> 走到 <span class="math inline">\(A\)</span>，右手边的面是三角形 <span class="math inline">\(\Delta OAQ\)</span>，接下来的第一条边应该是 <span class="math inline">\(AO\)</span>，我们跳过这条边，选择第二条边 <span class="math inline">\(AK\)</span>，到达 <span class="math inline">\(K\)</span> 后继续选择右手边的第二条边，这样绕着<span class="math inline">\(O\)</span> 一圈下来共经过 5条边，它们正好围成 Great dodecahedron的一个面。对正二十面体的其它边也如此操作会得到 Great dodecahedron其它的面。</p><p>像这样对一个多面体，保持它的顶点和边的集合不变，但是每次选择右手边的第<span class="math inline">\(k\)</span>个边走下去绕一圈获得一个面，这样构造新多面体的方法叫做 <strong>Facetting手术</strong>。在我们这个项目中 <span class="math inline">\(k\)</span>总是等于 2。</p><p>我们来导出正二十面体的对称群 <span class="math inline">\(G\)</span>和 Great dodecahedron 的对称群 <span class="math inline">\(K\)</span>之间的关系。</p><p>来看三角形 <span class="math inline">\(\DeltaOAB\)</span>，它的三个内角分别是 <span class="math inline">\(\angleOAB=2\pi/5\)</span>，<span class="math inline">\(\angleOBA=\pi/2\)</span>，<span class="math inline">\(\angleAOB=\pi/5\)</span>，它包含三个与 <span class="math inline">\(\DeltaABC\)</span> 全等的三角形，关于其三条边 <span class="math inline">\(OA,OB,AB\)</span> 的反射分别是 <span class="math inline">\(\tau_1=\rho_1\rho_2\rho_1,\tau_0=\rho_0,\tau_2=\rho_2\)</span><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>。</p><p>Facetting 操作 <span class="math inline">\(\varphi_k\)</span>用群的语言来描述就是（记住 <span class="math inline">\(k=2\)</span>）<span class="math display">\[G=\langle\rho_0,\rho_1,\rho_2\rangle\xrightarrow{\ \varphi_k\}\langle\rho_0,\rho_1(\rho_2\rho_1)^{k-1},\rho_2\rangle=\langle\tau_0,\tau_1,\tau_2\rangle=K.\]</span>一般来说 <span class="math inline">\(K\)</span> 是 <span class="math inline">\(G\)</span> 的子群，但在这里 <span class="math inline">\(G\)</span> 和 <span class="math inline">\(K\)</span> 就是同一个群。我们不解释为什么 <span class="math inline">\(G=K\)</span>，这里只承认这一点，然后借助这个事实来说明<span class="math inline">\(K\)</span> 就是 Great dodecahedron的对称群。</p><p>首先 <span class="math inline">\(\langle \tau_1,\tau_2\rangle=\langle\rho_1,\rho_2\rangle\)</span> 是顶点 <span class="math inline">\(A\)</span> 的稳定化子群，所以 Great dodecahedron和正二十面体的顶点集是一样的。但 <span class="math inline">\(\tau_1\tau_2\)</span> 是一个角度为 144度的旋转，这一点和 <span class="math inline">\(\rho_1\rho_2\)</span>是一个 72 度的旋转不同，所以 Great dodecahedron 的 vertex configure是一个五角星，而不像正二十面体那样是一个五边形。</p><p>其次 <span class="math inline">\(\langle\tau_0,\tau_2\rangle=\langle\rho_0,\rho_2\rangle\)</span>为边 <span class="math inline">\(AQ\)</span> 的稳定化子群，所以 Greatdodecahedron 的边集和正二十面体也是一样的。</p><p>它俩的区别在于边组成面的方式不一样。<span class="math inline">\(\langle\tau_0,\tau_1\rangle\)</span> 是 Greatdodecahedron 面的稳定化子群，注意到 <span class="math inline">\(\tau_1\)</span> 是关于 <span class="math inline">\(AO\)</span> 的反射，它会把 <span class="math inline">\(AQ\)</span> 映射为 <span class="math inline">\(AK\)</span>，这正对应选择第 <span class="math inline">\(k\)</span> 条边的操作。<span class="math inline">\(\tau_0\tau_1\)</span> 是一个绕着顶点 <span class="math inline">\(O\)</span> 的角度为 <span class="math inline">\(2\pi/5\)</span> 的旋转，所以 <span class="math inline">\(AQ\)</span> 在子群 <span class="math inline">\(\langle \tau_0,\tau_1\rangle\)</span> 作用下会绕<span class="math inline">\(O\)</span> 转一圈，正对应 Facetting操作得到的一个面。</p><p>我们来找出 <span class="math inline">\(\tau_0,\tau_1,\tau_2\)</span>之间隐藏的一条生成关系：</p><p>注意到 <span class="math inline">\(\tau_1\tau_2\tau_1=\tau_1\rho_2\tau_1\)</span>是关于 <span class="math inline">\(AP\)</span> 的反射，它和 <span class="math inline">\(\tau_0=\rho_0\)</span> 的复合是绕着 <span class="math inline">\(P\)</span> 点角度为 <span class="math inline">\(2\pi/3\)</span> 的旋转，所以 <span class="math inline">\((\tau_0\tau_1\tau_2\tau_1)^3=1\)</span>。加入这个额外的生成关系得到的就是<span class="math inline">\(K\)</span> 的正确的表现： <span class="math display">\[\begin{align*}K = \langle\tau_0,\tau_1,\tau_2 \|\  &amp;\tau_0^2=\tau_1^2=\tau_2^2=(\tau_0\tau_1)^5=(\tau_1\tau_2)^5=\\&amp;(\tau_0\tau_2)^2=(\tau_0\tau_1\tau_2\tau_1)^3=1\rangle.\end{align*}\]</span></p><p>所以我们就可以对 <span class="math inline">\(K\)</span>照搬之前的绘制步骤了。</p><p>这个额外的生成关系其实也有背后的解释：对 Faceting手术得到的新多面体再进行一次 Faceting 手术是可以回到原来的多面体的。对great dodecahedron每次沿着它的边，选择当前离开的边的右手第二个边走下去，即从 <span class="math inline">\(Q\)</span> 走到 <span class="math inline">\(A\)</span> 时，不是选择 <span class="math inline">\(AK\)</span> 继续走下去，而是选择 <span class="math inline">\(AO\)</span>，这样走下去又会得到正二十面体的三角形的面，这对应的就是额外的生成关系中的指数3。</p><p>这一点从群上也可以得到验证。</p><p><span class="math display">\[K=\langle\tau_0,\tau_1,\tau_2\rangle\xrightarrow{\ \varphi_2\}\langle\tau_0,\tau_1\tau_2\tau_1,\tau_2\rangle=\langle\rho_0,\rho_2\rho_1\rho_2,\rho_2\rangle=G.\]</span></p><blockquote><p>关于 Faceting 手术可以在 McMullen 和 Schulte 所著的 <a href="https://doi.org/10.1017/CBO9780511546686">Abstract RegularPolytopes</a> 一书中找到。</p></blockquote><h1 id="snub-cube-的计算">Snub cube 的计算</h1><p>如果你理解了上面的内容，snub 多面体的情形也是不难理解的。我以 snubcube 来说明：</p><p>Snub cube 和 cube 的区别在于它的对称群只包含旋转，我们已经看到 cube的对称群 <span class="math inline">\(G\)</span> 的表现为 <span class="math display">\[G = \langle\rho_0,\rho_1,\rho_2\ |\\rho_0^2=\rho_1^2=\rho_2^2=(\rho_0\rho_1)^4=(\rho_1\rho_2)^3=(\rho_0\rho_2)^2=1\rangle.\]</span>它有 48 个元素，其中 24 个是旋转。这些旋转可以由 <span class="math inline">\(r_0=\rho_0\rho_1,r_1=\rho_1\rho_2,r_2=\rho_0\rho_2\)</span> 生成 （由于 <span class="math inline">\(r_0r_1=r_2\)</span> 因此实际上可以由 <span class="math inline">\(r_0\)</span> 和 <span class="math inline">\(r_1\)</span> 生成）。这 24 个旋转就构成了 Snubcube 的对称群 <span class="math inline">\(\widetilde{G}\)</span>。</p><p>不难写出 <span class="math inline">\(\widetilde{G}\)</span> 的表现为<span class="math display">\[\widetilde{G}=\langle r_0,r_1\ |\r_0^4=r_1^3=(r_0r_1)^2=1\rangle.\]</span></p><p>利用 Todd-Coxeter 算法不难求出这个群的所有 24 个元素：</p><p><span class="math display">\[\begin{array}{lll}e&amp;r_{0}&amp;r_{0}r_{0}\\r_{0}r_{0}r_{0}&amp;r_{1}&amp;r_{1}r_{1}\\r_{0}r_{1}&amp;r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{1}\\r_{0}r_{0}r_{1}r_{1}&amp;r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}\\r_{1}r_{0}r_{0}&amp;r_{1}r_{0}r_{0}r_{0}&amp;r_{1}r_{1}r_{0}\\r_{1}r_{1}r_{0}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}\\r_{0}r_{0}r_{1}r_{1}r_{0}&amp;r_{1}r_{0}r_{0}r_{1}&amp;r_{1}r_{0}r_{0}r_{1}r_{1}\\r_{1}r_{0}r_{0}r_{0}r_{1}&amp;r_{1}r_{1}r_{0}r_{0}r_{1}&amp;r_{0}r_{1}r_{1}r_{0}r_{0}r_{1}\end{array}\]</span></p><p>注意在 snub 的情形初始顶点 <span class="math inline">\(v_0\)</span>不属于任何镜面，所以其稳定化子群只有单位元 1，即每个 <span class="math inline">\(g\in\widetilde{G}\)</span> 把 <span class="math inline">\(v_0\)</span> 变换为不同的顶点。将它们作用在 <span class="math inline">\(v_0\)</span> 上即得 snub cube 的所有顶点。</p><p>我们现在利用轨道—稳定化子的理论来求 snub cube 的边。snub cube的边也是分类型的，每个 <span class="math inline">\(r_i(i=0,1,2)\)</span>作用在 <span class="math inline">\(v_0\)</span> 上可得一个类型为 <span class="math inline">\(i\)</span> 的边 <span class="math inline">\(e_i=(v_0, v_0\cdot r_i)\)</span> <a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a>，我们来定出 <span class="math inline">\(e_i\)</span> 的稳定化子群 <span class="math inline">\(H\)</span>。</p><p>首先注意到任何 <span class="math inline">\(g\in G\)</span> 如果保持<span class="math inline">\(e_i\)</span>不变，则只有两种可能，要么它保持 <span class="math inline">\(e_i\)</span> 上每个点不变，要么它将 <span class="math inline">\(e_i\)</span> 关于其中点进行翻转。这一点对 <span class="math inline">\(g\in\widetilde{G}\)</span> 自然也成立。所以若<span class="math inline">\(g\in\widetilde{G}\)</span> 保持 <span class="math inline">\(e_i\)</span> 不变，则要么 <span class="math inline">\(v_0g = v_0, v_0r_i=v_0r_ig\)</span>，要么 <span class="math inline">\(v_0g = v_0r_i,v_0r_ig=v_0\)</span>。前一种情形说明<span class="math inline">\(g\)</span> 属于 <span class="math inline">\(v_0\)</span>的稳定化子群从而只能是单位元；后一种情形说明 <span class="math inline">\(r_ig\)</span> 和 <span class="math inline">\(r_ig^{-1}\)</span> 都属于 <span class="math inline">\(v_0\)</span> 的稳定化子群从而 <span class="math inline">\(r_ig=r_ig^{-1}=1\)</span>，即 <span class="math inline">\(g=r_i\)</span> 且 <span class="math inline">\(r_i^2=1\)</span>。总之我们证明了只有在 <span class="math inline">\(r_i^2=1\)</span> 时 <span class="math inline">\(e_i\)</span>才有非平凡的稳定化子群，这时稳定化子群是二阶循环群 <span class="math inline">\(\langle r_i\rangle\)</span>。</p><p>于是 snub cube 的类型为 <span class="math inline">\(r_0\)</span> 和<span class="math inline">\(r_1\)</span> 的边的个数都是 24/1=24个；类型为 <span class="math inline">\(r_2\)</span> 的边的个数为 24/2=12个，从而 snub cube 总共有 24+24+12=60 条边。</p><p>snub cube 的面可以这样求：由于 <span class="math inline">\(r_0^4=1\)</span> 所以 <span class="math inline">\(r_0\)</span> 可以生成一个正四边形的面，类似地由于<span class="math inline">\(r_1^3=1\)</span> 所以 <span class="math inline">\(r_1\)</span> 可以生成一个正三角形的面，而由于<span class="math inline">\(r_2^2=1\)</span> 所以 <span class="math inline">\(r_2\)</span>生成的面是退化的。这种由单个旋转生成的面的稳定化子群是很好求的：若 <span class="math inline">\(g\)</span> 保持 <span class="math inline">\(r_i\)</span> 生成的面不变，则其必然把某个形如<span class="math inline">\(v_0r_i^k\)</span> 的顶点变换为 <span class="math inline">\(v_0\)</span>，即 <span class="math inline">\(g=r_i^{-k}\)</span> 是 <span class="math inline">\(r_i\)</span> 的某次幂，反之易见 <span class="math inline">\(r_i\)</span>的任何幂都保持此面不变，所以其稳定化子群即为循环群 <span class="math inline">\(\langle r_i\rangle\)</span>。</p><p>于是 <span class="math inline">\(r_0\)</span> 生成的面的个数为24/4=6，<span class="math inline">\(r_1\)</span> 生成的面的个数为24/3=8，<span class="math inline">\(r_2\)</span>生成的面都退化因而个数是 0，总计 14 个面。</p><p>小心！我们还漏掉了一种三角面，它源自 <span class="math inline">\(r_0r_1=r_2\)</span> 这个关系。考虑 <span class="math inline">\(\{v_0, v_0r_1, v_0r_2\}\)</span>这三个顶点，这三个顶点中 <span class="math inline">\((v_0,v_0r_1)\)</span> 构成一条类型为 <span class="math inline">\(r_1\)</span> 的边， <span class="math inline">\((v_0,v_0r_2)\)</span> 构成一条类型为 <span class="math inline">\(r_2\)</span> 的边，而 <span class="math inline">\(r_0r_1=r_2\)</span> 这个关系告诉我们 <span class="math display">\[(v_0, v_0r_0)\xrightarrow{\ r_1\ }(v_0r_1,v_0r_0r_1) = (v_0r_1, v_0r_2).\]</span> 即 <span class="math inline">\((v_0r_1, v_0r_2)\)</span> 是一条类型为 <span class="math inline">\(r_0\)</span> 的边，它是由将 <span class="math inline">\(r_1\)</span> 作用在类型为 <span class="math inline">\(r_0\)</span> 的初始边 <span class="math inline">\((v_0, v_0r_0)\)</span> 上得到的，于是 <span class="math inline">\(\{v_0, v_0r_1, v_0r_2\}\)</span>构成一个三角形的三个顶点，其三条边在对称群作用下属于不同的轨道，所以这个三角形的稳定化子必然保持每条边不变，从而只能是恒等元，从而这样的面有24/1=24 个。</p><p>于是 snub cube 一共有 14+24=38 个不同的面。</p><p>这里介绍的方法也适用于其它的 snub 多面体以及 snub 24-cell。</p><h1 id="多面体的顶点投影到-coxeter-平面">多面体的顶点投影到 Coxeter平面</h1><p>项目中还实现了一个<code>draw_on_coxeter_plane(*args, **kwargs)</code>方法，用于绘制将多面体的顶点投影到其 Coxeter平面上后得到的图案，例如下图显示的是将 600-cell 的 120 个顶点投影到其Coxeter 平面上的结果：</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/600-cell.svg" width="350"></p><p>你可以和 <a href="https://en.wikipedia.org/wiki/600-cell#2D_projections">wikipedia上的效果</a> 比较一下。</p><h1 id="附录手算-todd-coxeter">附录：手算 Todd-Coxeter</h1><p>对简单的群，Todd-Coxeter 算法完全可以用手算快速得出结果。我非常推荐Borcherds 的视频，他的演示非常精彩：</p><iframe width="560" height="315" src="https://www.youtube.com/embed/BHezLvEH1DU?si=fw7X2z37wZEYcIG-" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe><p>仿照 Borcherds 的方法，前面正方形的例子可以很快写出来：</p><p><img style="margin:0px auto;display:block" src="/images/polytopes/todd-coxeter.svg" width="600"></p><p>我来解释一下步骤：我们将画出一个有限图，图的每个顶点代表 <span class="math inline">\(H=\langle s_0,s_1\rangle\)</span>的一个陪集，每个顶点有三条不同颜色的边，表示此陪集在生成元 <span class="math inline">\(s_i\)</span> 作用下的结果。</p><ol type="1"><li>首先我们在空白纸上画出第一个顶点，它对应的陪集是 <span class="math inline">\(H=H_0\)</span> 自身。<span class="math inline">\(H\)</span> 包含 <span class="math inline">\(s_0,s_1\)</span>，所以红、绿边是自边。<span class="math inline">\(s_2\)</span>，即蓝色的边，会把它映射为一个新顶点<span class="math inline">\(H_1\)</span>。</li><li>从 <span class="math inline">\(H_0\)</span>出发，利用红蓝交换，可得红色保持 <span class="math inline">\(H_1\)</span> 不动。但是绿蓝不交换，所以绿色将<span class="math inline">\(H_1\)</span> 映射为新顶点 <span class="math inline">\(H_2\)</span>。</li><li><span class="math inline">\((\text{绿蓝})^3=1\)</span>，即 <span class="math inline">\(H_2\xrightarrow{(\text{绿蓝})^3}H_2\)</span>，所以<span class="math display">\[H_2\xrightarrow{\text{绿}}H_1\xrightarrow{\text{蓝}} H_0\xrightarrow{\text{绿}}H_0\xrightarrow{\text{蓝}} H_1\xrightarrow{\text{绿}}H_2\xrightarrow{\text{蓝}} H_2.\]</span> 所以蓝色保持 <span class="math inline">\(H_2\)</span> 不动。红绿不交换，所以红色将 <span class="math inline">\(H_2\)</span> 映射为新顶点 <span class="math inline">\(H_3\)</span>。</li><li>仿照上面的分析继续下去，可以发现到 <span class="math inline">\(H_5\)</span> 时，三种颜色的边不会给出新顶点。所以<span class="math inline">\(\{H_0,\ldots,H_5\}\)</span> 就是 <span class="math inline">\(G/H\)</span> 的全部陪集。</li></ol><aside id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><hr><ol><li id="fn1"><p>你可能要问了，你怎么就敢肯定这个群的表现恰好就包含这些生成关系，而不会包含其它什么隐藏的生成关系呢？这是个好问题，回答起来并不容易，答案是对凸的多胞体而言这些生成关系确实给出了其对称群的一个表现，但是对星状多面体而言则未必。事实上星状多面体都和某个凸多面体有相同的对称群，但是群表现是不一样的（需要补上额外的生成关系）。这其中的根本原因是凸多面体的镜面法向量之间的夹角都形如<span class="math inline">\(\pi-\pi/m\)</span>，这里 <span class="math inline">\(m\)</span>是整数，这保证了所有镜面围成的凸锥构成一个基本区域。而星状多面体的镜面所夹的二面角至少有一个形如<span class="math inline">\(\pi-\pi/p\)</span>，其中 <span class="math inline">\(p\)</span>是一个非整数的有理数，这时所有镜面围成的凸锥并不是基本区域，在对称群的作用下这个凸锥会被覆盖若干次。见Vinberg 的文章 “Discrete linear groups generated by reflections” 和Coxeter 的著作 “The beauty of geometry: twelve essays”.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>以本文介绍的知识，这里似乎应该说 <span class="math inline">\(H\)</span> 保持 <span class="math inline">\(v_0\)</span> 不变，从而 <span class="math inline">\(v_0\)</span> 的稳定化子群包含 <span class="math inline">\(H\)</span>，怎么能断言 <span class="math inline">\(v_0\)</span> 的稳定化子群就等于 <span class="math inline">\(H\)</span> 呢？这实际上是 Coxeter 群的一个性质：在Coxeter 群 <span class="math inline">\(W\)</span>的标准几何实现中，对其基本区域闭包中的任何一点 <span class="math inline">\(v\)</span>，<span class="math inline">\(v\)</span>的稳定化子群是一个标准椭圆子群，其生成元恰好由超平面包含 <span class="math inline">\(v\)</span> 的那些单反射组成。<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p>道理与注解 2 类似。易见边 <span class="math inline">\(e\)</span> 的稳定化子群 <span class="math inline">\(H\)</span> 就是 <span class="math inline">\(e\)</span>的中点的稳定化子群，这也是一个标准椭圆子群，由那些包含 <span class="math inline">\(e\)</span>的中点的镜面对应的单反射生成。这样的镜面只能是 <span class="math inline">\(\rho_i\)</span> 和那些与 <span class="math inline">\(m_i\)</span> 垂直且包含 <span class="math inline">\(v_0\)</span> 的镜面。<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>解释与注解 2, 3 类似。<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn5"><p>有这么一个结论：如果 <span class="math inline">\(s_\alpha\)</span> 是关于镜面 <span class="math inline">\(\alpha\)</span> 的反射，镜面 <span class="math inline">\(\beta=g\alpha\)</span>，这里 <span class="math inline">\(g\)</span> 是空间中的可逆线性变换，则关于 <span class="math inline">\(\beta\)</span> 的反射 <span class="math inline">\(s_\beta=gs_\alpha g^{-1}\)</span>。令 <span class="math inline">\(\alpha=AB\)</span>，<span class="math inline">\(g=\rho_1\)</span>，<span class="math inline">\(\beta=AD\)</span> 即为结论。<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn6"><p>注意本文没有解释为什么这些边确实是不同类型的，即它们在对称群的作用下处于不同的轨道。严格说明这一点也要用到Coxeter 群的几何实现。<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
    
    
    <summary type="html">
&lt;p&gt;本文介绍我写的一个高颜值的、脱离了低级趣味的小程序：用 Python 和
POV-Ray 绘制各种三维多面体和四维多胞体，代码在 &lt;a href=&quot;https://github.com/neozhaoliang/pywonderland/tree/master/src/polytopes&quot;&gt;Github&lt;/a&gt;
上。&lt;/p&gt;
&lt;p&gt;以下是用这个程序渲染的一些例子，其中不同颜色的顶点/边/面表示它们在对称群的作用下位于不同的轨道中，具体解释见后。&lt;/p&gt;</summary>
    
    
    
    <category term="pywonderland 项目" scheme="https://pywonderland.com/categories/pywonderland-%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>Möbius 变换的分类与上半双曲空间的等距</title>
    <link href="https://pywonderland.com/mobius-h3space/"/>
    <id>https://pywonderland.com/mobius-h3space/</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2025-03-15T02:01:17.397Z</updated>
    
    <content type="html"><![CDATA[<p>本文的想法源自 Roice Nelson 的 <a href="https://www.shadertoy.com/view/MstcWr">shadertoy项目</a>，我觉得他的创意很棒，就是效果有点糙，于是 <a href="https://www.shadertoy.com/view/4scfR2">动手改进了一番</a>。乍一看，这个动画的场景很简单，其实它背后的数学并不平凡。</p><p>这个动画从三个角度了演示 Möbius 变换，这三个角度是密切相关的：</p><ol type="1"><li>Möbius 变换作为扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 到自身的全纯函数。</li><li>Möbius 变换作为 Riemann 球面 <span class="math inline">\(S^2\)</span> 到自身的全纯函数。</li><li>Möbius 变换作为上半双曲空间中的等距变换。</li></ol><p>本文只作概括性的介绍，并不展开详细的数学证明。读者可以参考下面的资料：</p><blockquote><ol type="1"><li><a href="https://en.wikipedia.org/wiki/M%C3%B6bius_transformation">维基百科</a>.</li><li><span class="citation" data-cites="Needham1997">Needham (<a href="#ref-Needham1997" role="doc-biblioref">1997</a>)</span> .</li><li><span class="citation" data-cites="indra">Mumford, Series, andWright (<a href="#ref-indra" role="doc-biblioref">2002</a>)</span>,chapter 3.</li><li><span class="citation" data-cites="palka1991">Palka (<a href="#ref-palka1991" role="doc-biblioref">1991</a>)</span>, chapter IX,section 2.</li></ol></blockquote><p>本文的动画应该可以帮助你更好地理解这些资料中的内容。</p><span id="more"></span><h1 id="预备知识之正交圆族">预备知识之正交圆族</h1><p>设 <span class="math inline">\(z_1,z_2\)</span>是复平面上的两点，我们考虑两个不同的圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span>：</p><ol type="1"><li><span class="math inline">\(\mathcal{C}_1\)</span> 由所有同时过<span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 的圆组成（包含过 <span class="math inline">\(z_1,z_2\)</span> 的直线）。</li><li><span class="math inline">\(\mathcal{C}_2\)</span> 由所有使得 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 关于 <span class="math inline">\(C\)</span> 互为反演点的圆 <span class="math inline">\(C\)</span> 组成（包含线段 <span class="math inline">\([z_1,z_2]\)</span> 的垂直平分线）。</li></ol><p>则圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 中的任何圆<span class="math inline">\(C_1\)</span> 与 <span class="math inline">\(\mathcal{C}_2\)</span> 中的任何圆 <span class="math inline">\(C_2\)</span> 正交（交点处的切线互相垂直）。</p><p>我们将考察当 <span class="math inline">\(z_1,z_2\)</span> 是一个Möbius 变换 <span class="math inline">\(M\)</span> 的两个不动点时，<span class="math inline">\(M\)</span> 作用在 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span> 上的效果。</p><h1 id="möbius-变换的共轭分类">Möbius 变换的共轭分类</h1><p>一个 Möbius 变换 <span class="math inline">\(M\)</span>是一个分式线性变换，它将扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 一对一地映射为自身：<span class="math display">\[M(z) = \frac{az+b}{cz+d},\quada,b,c,d\in\mathbb{C},ad-bc\ne0, z\in \hat{\mathbb{C}}.\]</span> 所有的Möbius 变换构成一个群 <span class="math inline">\({\rmPSL}_2(\mathbb{C})\)</span>。</p><p>我们称两个 Möbius 变换 <span class="math inline">\(M_1,M_2\)</span>是共轭的，当且仅当存在 <span class="math inline">\(g\in{\rmPSL}_2(\mathbb{C})\)</span> 使得 <span class="math display">\[M_1=gM_2g^{-1}.\]</span></p><p>可以证明，在共轭的意义下，任何非恒等元的 Möbius变换都属于下面四种类型之一：</p><ol type="1"><li><span class="math inline">\(M\)</span> 称作是抛物型的(parabolic)，如果它共轭于平移：<span class="math inline">\(z\toz+1\)</span>。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上仅有一个不动点。</li><li><span class="math inline">\(M\)</span> 称作是椭圆型的(elliptic)，如果它共轭于旋转：<span class="math inline">\(z\toe^{i\theta}z\)</span>，其中 <span class="math inline">\(\theta\in\mathbb{R}\)</span> 且 <span class="math inline">\(\theta\ne0\)</span>。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li><li><span class="math inline">\(M\)</span> 称作是双曲型的(hyperbolic)，如果它共轭于缩放：<span class="math inline">\(z\to\lambdaz\)</span>，其中 <span class="math inline">\(\lambda&gt;0\)</span>是实数且不为 1。这时 <span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li><li><span class="math inline">\(M\)</span> 称作是斜航型的(loxodromic)，如果它共轭于一个缩放和一个旋转的复合：<span class="math inline">\(z\to cz\)</span>，其中 <span class="math inline">\(c\in\mathbb{C}\setminus \mathbb{R}\)</span>。这时<span class="math inline">\(M\)</span> 在 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 上有两个不动点。</li></ol><p>我们把形如 <span class="math inline">\(z\to z+a\)</span> 和 <span class="math inline">\(z\to\lambda z\)</span>的变换称作<strong>特殊位置</strong>的变换，前者是抛物型的，以 <span class="math inline">\(\infty\)</span>为唯一不动点，后者包含了所有非抛物型的变换，它的两个不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>。这两种 Möbius变换具有简单的表现形式，并且它们在两个圆族上的作用也很容易分析，所以在研究每种类型的变换时，我们都先考虑这种简单的形式，然后再通过取共轭扩展到一般的情形。</p><h2 id="抛物型">1. 抛物型</h2><p>我们先考察最简单的抛物型变换 <span class="math inline">\(z\toz+1\)</span>。</p><p>这时唯一的不动点是 <span class="math inline">\(\infty\)</span>，<span class="math inline">\(\mathcal{C}_1\)</span> 是直线族 <span class="math inline">\(\{y=k\mid k\in\mathbb{R}\}\)</span>，<span class="math inline">\(\mathcal{C}_2\)</span> 是直线族 <span class="math inline">\(\{x=l\mid l\in\mathbb{R}\}\)</span>。<span class="math inline">\(M\)</span> 保持 <span class="math inline">\(\mathcal{C}_1\)</span> 中的每条直线不变，把 <span class="math inline">\(\mathcal{C}_2\)</span>中的每条直线变成同族中的另一条直线：</p><object data="/images/mobius/parabolic-plane.svg"></object><p>由动画可见所有点都向着不动点 <span class="math inline">\(\infty\)</span> 的方向「前进」。</p><p>对一般的抛物型变换 <span class="math inline">\(M\)</span> 且 <span class="math inline">\(M\)</span> 的唯一不动点 <span class="math inline">\(z_0\)</span> 有限的情形，结论仍然类似：圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 中的圆都在 <span class="math inline">\(z_0\)</span> 处相切且共用同一条切线 <span class="math inline">\(\ell_1\)</span>，圆族 <span class="math inline">\(\mathcal{C}_2\)</span> 也都在 <span class="math inline">\(z_0\)</span> 处相切且共用同一条切线 <span class="math inline">\(\ell_2\)</span>，<span class="math inline">\(\ell_1\)</span> 和 <span class="math inline">\(\ell_2\)</span> 互相垂直：</p><object data="/images/mobius/parabolic-plane2.svg"></object><p>由动画可见左右两侧的圆在旋转，但是圆本身保持不变，它们是圆族 <span class="math inline">\(\mathcal{C}_1\)</span>；上下两侧的圆在「扩散」，它们是圆族<span class="math inline">\(\mathcal{C}_2\)</span>。可以证明对任何 <span class="math inline">\(z\in\mathbb{C}\)</span> 都有 <span class="math inline">\(\lim\limits_{n\to\infty}M^n(z)=z_0\)</span>，即任何点在<span class="math inline">\(M\)</span> 反复作用下的轨迹都朝着 <span class="math inline">\(z_0\)</span> 的位置移动。</p><p>在 <a href="http://klein.math.okstate.edu/IndrasPearls/">Indra’spearls</a> 一书中，把 <span class="math inline">\(\mathcal{C}_1\)</span>和 <span class="math inline">\(\mathcal{C_2}\)</span>形象地比喻为两组「扇贝壳」：</p><figure><img src="/images/mobius/seashell.jpeg" width="200" alt="我从网上找了一张扇贝壳的图片"><figcaption aria-hidden="true">我从网上找了一张扇贝壳的图片</figcaption></figure><h2 id="椭圆型">2. 椭圆型</h2><p>我们先考察最简单的椭圆型变换 <span class="math inline">\(z\toe^{i\theta}z\)</span>。</p><p>这时两个不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>。圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 由所有过 <span class="math inline">\(0\)</span> 的直线组成，<span class="math inline">\(\mathcal{C}_2\)</span> 由所有以 <span class="math inline">\(0\)</span> 为中心的同心圆组成。<span class="math inline">\(M\)</span> 是个旋转，所以会把 <span class="math inline">\(\mathcal{C}_1\)</span>中的直线变成同族的另一条直线，同时保持 <span class="math inline">\(\mathcal{C}_2\)</span> 中的每个圆不变：</p><object data="/images/mobius/elliptic-plane.svg"></object><p>对两个不动点 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 都有限的情形，结论同样成立，<span class="math inline">\(M\)</span> 保持 <span class="math inline">\(\mathcal{C}_2\)</span> 中的每个圆不变，把 <span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆变为同族中的另一个圆：</p><object data="/images/mobius/elliptic-plane2.svg"></object><h2 id="双曲型">3. 双曲型</h2><p>与椭圆变换 <span class="math inline">\(z\to e^{i\theta}z\)</span>的情形类似，<span class="math inline">\(z\to\lambda z\)</span> 也以<span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span> 为不动点，但是圆族 <span class="math inline">\(\mathcal{C}_1\)</span> 和 <span class="math inline">\(\mathcal{C}_2\)</span> 的运动方式发生了互换：这次<span class="math inline">\(\mathcal{C}_1\)</span>中的每条直线在放缩下保持不变，<span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆在放缩下变成同族的另一个圆：</p><object data="/images/mobius/hyperbolic-plane.svg"></object><p>对两个不动点 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span> 都有限的双曲变换，结论仍然成立，圆族<span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆保持不变，<span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆被变成同族的另一个：</p><object data="/images/mobius/hyperbolic-plane2.svg"></object><p>这时在 <span class="math inline">\(M\)</span> 的作用下 <span class="math inline">\(z_1\)</span> 和 <span class="math inline">\(z_2\)</span>一个是「源点」，另一个是「汇点」，轨迹从源点源源不竭地发出，汇聚到汇点中。</p><h2 id="斜航型">4. 斜航型</h2><p>仍然先看 <span class="math inline">\(z\to cz\)</span> 的情形。</p><p>这时不动点是 <span class="math inline">\(0\)</span> 和 <span class="math inline">\(\infty\)</span>，<span class="math inline">\(M\)</span> 把圆族 <span class="math inline">\(\mathcal{C}_1\)</span>中的每个圆变为同族中的另一个圆，同样地也把圆族 <span class="math inline">\(\mathcal{C}_2\)</span>中的每个圆变为同族中的另一个圆，<strong>所以斜航型的变换没有不变圆</strong>：</p><object data="/images/mobius/loxodromic-plane.svg"></object><p>这时平面上一点 <span class="math inline">\(z\)</span> 在 <span class="math inline">\(M\)</span>的反复作用下的轨迹是一条形如「旋臂」的曲线，方程为 <span class="math inline">\(\gamma(t)=c^tz\)</span>，这是一条对数螺线(spiral)，其与 <span class="math inline">\(\mathcal{C}_1\)</span> 和<span class="math inline">\(\mathcal{C}_2\)</span> 的夹角都是常数。</p><p>这个结论对一般的斜航型变换也成立：</p><object data="/images/mobius/loxodromic-plane2.svg"></object><p>由于斜航型变换包含双曲变换作为组成成分，因此看起来它也有一个源点和一个汇点。这时任意一点<span class="math inline">\(z\)</span> 在 <span class="math inline">\(M\)</span> 的反复作用下的轨迹是一条双螺线 (doublespiral)，其与 <span class="math inline">\(\mathcal{C}_1\)</span> 和<span class="math inline">\(\mathcal{C}_2\)</span> 的夹角仍然都是常数（Möbius 变换是保角的）。</p><p>判断 Möbius 变换 <span class="math inline">\(M\)</span>具体属于哪一类可以根据其迹的平方 <span class="math inline">\(\mu=(a+d)^2\)</span> 来判断（当然，需要把 <span class="math inline">\(M\)</span> 归一化使得 <span class="math inline">\(ad-bc=1\)</span>）：</p><ol type="1"><li><span class="math inline">\(M\)</span> 是抛物型的当且仅当 <span class="math inline">\(\mu=4\)</span>。</li><li><span class="math inline">\(M\)</span> 是椭圆型的当且仅当 <span class="math inline">\(0\leq\mu&lt;4\)</span>。</li><li><span class="math inline">\(M\)</span> 是双曲型的当且仅当 <span class="math inline">\(\mu&gt;4\)</span>。</li><li><span class="math inline">\(M\)</span> 是斜航型的当且仅当 <span class="math inline">\(\mu&lt;0\)</span> 或者 <span class="math inline">\(\mu\notin\mathbb{R}\)</span>。</li></ol><h2 id="斜航-loxodromic-是什么意思">斜航 (loxodromic) 是什么意思？</h2><p>斜航这个词听起来好像和船的航行有关，怎么就用来给 Möbius变换分类了呢？这里面肯定有故事，值得扒一扒。</p><p>斜航线 (loxodrome)指的是地球上的一条航行路径，其在每个点处的切线与过该点的经线的夹角为定值。比如说，如果船始终朝着东北方向30 度行驶，走过的轨迹就是一条斜航线。Loxodrome 最初是一个希腊词，loxos的意思是 oblique，即倾斜的，dromos 意为bearing，方位的意思，后来拉丁化以后成为现在的样子。葡萄牙数学家 PedroNunes (1492-1577)第一个认识到斜航线并非两点之间最短路径，而且它无限接近但永不可能到达极点。</p><p><img style="margin:0px auto;display:block" width="300" src="/images/mobius/loxodrome.png"></p><p>在大航海的时代，没有卫星导航，只能靠罗盘或者星座来标识船的航向，而星座的方法在遇到恶劣天气的时候又不能使用，只有罗盘是最可靠的方法。理论上地球表面两点之间的最短路径是过球心的大圆，但罗盘只能定出经线的方向（原理是地球的磁极和南北极近似重合），这二者的夹角不是固定的，要保持沿着大圆的弧走就必须不停调整船的航向，但现实中的船不可能一直有人守在船舵处调整方向，一般是事先定好航向以后接下来的若干天都沿着这个方向走，所以在一定路程内船实际上走的是斜航线。</p><p>荷兰地图学家墨卡托 (Mercator) 据此于 1569年提出了墨卡托地图，将地球投影至墨卡托地图是一个保角变换，即曲线的夹角保持不变。不仅如此，球面上的斜航线在墨卡托地图中成为一条直线：</p><figure><img src="/images/mobius/mercator.jpg" width="500" alt="网上找了一张墨卡托地图"><figcaption aria-hidden="true">网上找了一张墨卡托地图</figcaption></figure><p>所以要从地球上的 <span class="math inline">\(A\)</span> 点航向到<span class="math inline">\(B\)</span>点，只要找到它们在墨卡托地图上的对应点 <span class="math inline">\(A',B'\)</span>，算出地图上的直线 <span class="math inline">\(A'B'\)</span> 与经线的夹角 <span class="math inline">\(\theta\)</span>，航行时只要让罗盘与经线一直保持角度为<span class="math inline">\(\theta\)</span> 就可以按照斜航线从 <span class="math inline">\(A\)</span> 航行到 <span class="math inline">\(B\)</span>了。这个路径虽不是最短，但是好在不容易迷失航向。</p><p>那这和 Möbius 变换有什么关系呢？</p><h1 id="möbius-变换作用在-riemann-球面上">Möbius 变换作用在 Riemann球面上</h1><p>由于 Möbius 变换都是扩充复平面 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 到 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 的自同构，而 <span class="math inline">\(\hat{\mathbb{C}}\)</span> 在球极投影下等同于Riemann 球面 <span class="math inline">\(S^2\)</span>，所以 Möbius变换也都是 Riemann 球面的自同构。我们来看看 Möbius 变换作用在 Riemann球面上是什么样子的。</p><p>这是一个作用在 Riemann 球上的斜航型变换：</p><object data="/images/mobius/loxodromic-sphere.svg"></object><p>从动画可见 Riemann球面上有一对源点和汇点，这对源点和汇点可以理解为球面的「北极」和「南极」，它们在球极投影下对应于<span class="math inline">\(M\)</span>在扩充复平面上的两个不动点。当这两个不动点分别是原点和无穷远点时，这两个极点就是通常意义下的北极和南极。这时球面上的「经线」是所有过两个极点的大圆，在球极投影下它们对应于同时过两个不动点的圆族<span class="math inline">\(\mathcal{C}_1\)</span>；球面上的「纬线」是所有与经线正交的圆，在球极投影下它们对应于反演圆族<span class="math inline">\(\mathcal{C}_2\)</span>，球面上每个点的轨迹是对数螺线轨迹在逆球极投影下在球面上的对应曲线，这条曲线与经线纬线的夹角都是常数（因为球极投影是保角的），从而是一条斜航线！</p><h1 id="möbius-变换作为上半双曲空间的等距">Möbius变换作为上半双曲空间的等距</h1><p>上半双曲空间 <span class="math inline">\(\mathbb{H}_3\)</span>的定义为 <span class="math display">\[\mathbb{H}_3 =\{(x,y,t)\in\mathbb{R}^3\ |\ t&gt;0\}.\]</span>这个空间中的度量是双曲度量：</p><p><span class="math display">\[\mathrm{d}s=\frac{(\mathrm{d}x)^2+(\mathrm{d}y)^2+(\mathrm{d}t)^2}{t}.\]</span></p><p>注意 <span class="math inline">\(xy\)</span> 平面，即复平面不属于<span class="math inline">\(\mathbb{H}_3\)</span>，它是 <span class="math inline">\(\mathbb{H}_3\)</span> 的无穷远边界，<span class="math inline">\(\mathbb{H}_3\)</span> 中任何一点到 <span class="math inline">\(xy\)</span> 平面的距离是无穷大。</p><p>一个复分析教材中不太常讲到的事实是：<strong>任何 Möbius变换都可以唯一地扩展为 <span class="math inline">\(\mathbb{H}_3\)</span>的一个等距变换 <span class="math inline">\(\overline{M}\)</span></strong>，此即所谓的Poincaré Extension。这个扩展用四元数来描述的话很简单：设 <span class="math display">\[M\colon\ z\to\frac{az+b}{cz+d},\quadad-bc=1.\]</span> 是任一 Möbius 变换。注意我们这里要求 <span class="math inline">\(ad-bc\)</span> 的值是1，其实任何非零实数都可以。这是可以做到的，因为给 Möbius 变换中的 <span class="math inline">\(a,b,c,d\)</span>同时乘以一个非零复数并不改变这个变换，所以同时乘以 <span class="math inline">\(1/\sqrt{ad-bc}\)</span> 就可以使得 <span class="math inline">\(ad-bc=1\)</span>。</p><p>对 <span class="math inline">\(p=(x,y,t)\in\mathbb{H}^3\)</span>，令<span class="math inline">\(q=x+yi+tj\)</span> 为与 <span class="math inline">\(p\)</span> 对应的四元数，定义 <span class="math display">\[\overline{M}(p) = (aq+b)(cq+d)^{-1}.\]</span>这里的运算都是在四元数体中进行。则 <span class="math inline">\(\overline{M}(p)\)</span> 是 <span class="math inline">\(\mathbb{H}_3\)</span> 到自身的等距，并且它限制在<span class="math inline">\(xy\)</span> 平面上与 <span class="math inline">\(M\)</span> 的作用一致。</p><p>关于 Poincaré Extension 读者可以参考 <span class="citation" data-cites="Bea95">(<a href="#ref-Bea95" role="doc-biblioref">Beardon1995, vol. 91, secs. 3.3, 4.1</a>)</span>。</p><p>我们还能像上面那样用动画演示 Möbius 变换 <span class="math inline">\(\overline{M}\)</span> 在 <span class="math inline">\(\mathbb{H}_3\)</span>上的作用吗？可以！比如下图是一个形如 <span class="math inline">\(z\tocz\)</span> 的斜航型变换扩展到 <span class="math inline">\(\mathbb{H}_3\)</span>后作用在一个<strong>圆柱</strong>体上的效果：</p><object data="/images/mobius/loxodromic-cone.svg"></object><p>你可能要问了：这明明是个圆锥体，你怎么说它是圆柱体呢？是不是笔误了啊？</p><p>其实是因为我们现在是在双曲空间里看待它，在双曲度量下，锥面上所有点到<span class="math inline">\(t\)</span>轴的距离都是一样的，实际上如果设锥的顶角为 <span class="math inline">\(2\alpha\)</span>，则锥面上任何一点到 <span class="math inline">\(t\)</span> 轴的双曲距离 <span class="math inline">\(d\)</span> 满足（见 <span class="citation" data-cites="Bea95">(<a href="#ref-Bea95" role="doc-biblioref">Beardon1995, vol. 91, sec. 7.9.1</a>)</span>） <span class="math display">\[\sinh d\cdot \cot\alpha = 1.\]</span> 即 <span class="math inline">\(d\)</span> 是定值。所以虽然在 <span class="math inline">\(\mathbb{R}^3\)</span> 中它是一个锥体，但是在 <span class="math inline">\(\mathbb{H}_3\)</span> 中它其实是圆柱体。</p><p>你可以看到这时 <span class="math inline">\(\overline{M}\)</span>有两个不动点，都位于无穷远边界上，这样的点叫做「理想点」。两个不动点之间的连线构成圆柱的轴。两个不动点一个是源点，一个是汇点，空间中的点在变换的作用下远离源点，趋向汇点。</p><p>对于一般的斜航型变换 <span class="math inline">\(M\)</span>，且其两个不动点都是扩充复平面上的有限点时，<span class="math inline">\(M\)</span> 在 <span class="math inline">\(\mathbb{H}_3\)</span> 上的扩展 <span class="math inline">\(\overline{M}\)</span> 仍然保持一个 <span class="math inline">\(\mathbb{H}_3\)</span> 中的圆柱体不变：</p><object data="/images/mobius/loxodromic-dupin.svg"></object><p>这个曲面叫做 <a href="https://www.maths.ox.ac.uk/about-us/departmental-art/dupin-cyclides">Dupincyclide</a>，它的两个端点恰好是 <span class="math inline">\(M\)</span>的两个不动点。但在双曲空间中它其实是一个圆柱体，由于其两端落在无穷远平面上，因此也是无限长的。圆柱体的轴是连接两个端点的测地线。如果<span class="math inline">\(M\)</span> 是椭圆型的话，那么 <span class="math inline">\(\overline{M}\)</span> 将该圆柱绕着轴旋转：</p><object data="/images/mobius/elliptic-dupin.svg"></object><h1 id="这些动画是怎么生成的">这些动画是怎么生成的？</h1><p>我以 Dupin cyclide 的动画为例子来说明动画的绘制过程。</p><p>一个非抛物型的变换 <span class="math inline">\(M\)</span>总是可以表示为 <span class="math inline">\(M = gM_\lambdag^{-1}\)</span> 的形式，其中 <span class="math inline">\(M_\lambda=z\to\lambda z\)</span>。我这里的 <span class="math inline">\(g\)</span> 取的是 <span class="math display">\[g^{-1}(z)=\frac{z-1}{z+1}.\]</span>注意我这里写的是 <span class="math inline">\(g^{-1}\)</span>，原因是我们不需要 <span class="math inline">\(g\)</span> 的显式表达式，相反我们只需要 <span class="math inline">\(g^{-1}\)</span>。</p><p>不难验证 <span class="math inline">\(g^{-1}(1)=0\)</span> 和 <span class="math inline">\(g^{-1}(-1)=\infty\)</span>，从而 <span class="math inline">\(g(0)=1\)</span> 和 <span class="math inline">\(g(\infty)=-1\)</span>，即 <span class="math inline">\(g\)</span> 将 <span class="math inline">\(M_\lambda\)</span> 的不动点 <span class="math inline">\(\{0,\infty\}\)</span> 分别映射为 <span class="math inline">\(M\)</span> 的不动点 <span class="math inline">\(\{1,-1\}\)</span>。<span class="math inline">\(g\)</span> 同时将 <span class="math inline">\(M_\lambda\)</span> 对应的圆族 <span class="math inline">\(\{\mathcal{C}_i,i=1,2\}\)</span> 映射为 <span class="math inline">\(M\)</span> 的圆族 <span class="math inline">\(\{g(\mathcal{C}_i),i=1,2\}\)</span>。</p><p><span class="math inline">\(g\)</span> 当然也可以扩展为 <span class="math inline">\(\mathbb{H}_3\)</span> 的等距，我们把扩展以后的<span class="math inline">\(g\)</span> 仍然记作 <span class="math inline">\(g\)</span>。</p><p>由 <span class="math inline">\(M = gM_\lambda g^{-1}\)</span> 可得<span class="math display">\[Mg(\mathcal{C}_i) = gM_\lambda(\mathcal{C}_i),\quad i=1,2.\]</span> 左边的 <span class="math inline">\(Mg(\mathcal{C}_i)\)</span> 是我们真正想绘制的<span class="math inline">\(M\)</span> 在其自己的圆族 <span class="math inline">\(g(\mathcal{C}_i)\)</span>上的作用，这等价于绘制右边的 <span class="math inline">\(gM_\lambda(\mathcal{C})_i\)</span>。<span class="math inline">\(M_\lambda(\mathcal{C}_i)\)</span>很好画，就是把一些同心圆和过原点的直线旋转或者放缩一下；但是它前面加了一个畸变<span class="math inline">\(g\)</span>。为此我们只要用 <span class="math inline">\(g^{-1}\)</span>作用在当前场景的物体上，把它们「去畸变」即可。所以在动画中，我其实根本没有计算Dupin cyclide 的任何显式或者隐式的曲面方程，而是直接用 <span class="math inline">\(g^{-1}\)</span> 作用在场景上。由于 <span class="math inline">\(g^{-1}\)</span> 是 <span class="math inline">\(\mathbb{H}_3\)</span> 上的等距，它一定会把连接<span class="math inline">\(\{\pm1\}\)</span> 的测地线映射为连接 <span class="math inline">\(\{0,\infty\}\)</span>的测地线，即锥面。换言之，判断场景中的一个点 <span class="math inline">\(p\)</span> 是不是落在 Dupin cyclide 上，只要判断<span class="math inline">\(g^{-1}(p)\)</span>是不是落在锥面上。这就好办了。</p><p>抛物的情形更简单一些，可以用 <span class="math inline">\(g(z)=1/z\)</span>把位于无穷远的不动点变到原点。</p><p>动画使用的是 GLSL 语言和 raymarching 的技术。我在 Roice的代码基础上作了许多优化，但肯定还可以更精炼。限于我写 shader的能力不足，做出更美轮美奂的效果就不指望了 …</p><p>严格讲，这些动画其实还是尝试在 Euclidean空间中去观察双曲空间中的对象，因为 raymarching技术假定的是光走直线，但在双曲空间中光一般不走直线，所以我们这里看到的效果与真实的生活在双曲空间中的“外星人”所看到的还是有差别的。</p><h1 class="unnumbered" id="bibliography">References</h1><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list"><div id="ref-Bea95" class="csl-entry" role="listitem">Beardon, Alan F. 1995. <em>The Geometry of Discrete Groups</em>. Vol.91. Graduate Texts in Mathematics. Springer-Verlag, New York.</div><div id="ref-indra" class="csl-entry" role="listitem">Mumford, David, Caroline Series, and David J. Wright. 2002. <em>Indra’sPearls: An Atlas of Kleinian Groups</em>. Cambridge University Press.</div><div id="ref-Needham1997" class="csl-entry" role="listitem">Needham, Tristan. 1997. <em>Visual Complex Analysis</em>. The ClarendonPress, Oxford University Press, New York.</div><div id="ref-palka1991" class="csl-entry" role="listitem">Palka, B. P. 1991. <em>An Introduction to Complex Function Theory</em>.An Introduction to Complex Function Theory. World PublishingCorporation.</div></div>]]></content>
    
    
    <summary type="html">
&lt;p&gt;本文的想法源自 Roice Nelson 的 &lt;a href=&quot;https://www.shadertoy.com/view/MstcWr&quot;&gt;shadertoy
项目&lt;/a&gt;，我觉得他的创意很棒，就是效果有点糙，于是 &lt;a href=&quot;https://www.shadertoy.com/view/4scfR2&quot;&gt;动手改进了一番&lt;/a&gt;。乍一看，这个动画的场景很简单，其实它背后的数学并不平凡。&lt;/p&gt;
&lt;p&gt;这个动画从三个角度了演示 Möbius 变换，这三个角度是密切相关的：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;Möbius 变换作为扩充复平面 &lt;span class=&quot;math inline&quot;&gt;&#92;(&#92;hat{&#92;mathbb{C}}&#92;)&lt;/span&gt; 到自身的全纯函数。&lt;/li&gt;
&lt;li&gt;Möbius 变换作为 Riemann 球面 &lt;span class=&quot;math inline&quot;&gt;&#92;(S^2&#92;)&lt;/span&gt; 到自身的全纯函数。&lt;/li&gt;
&lt;li&gt;Möbius 变换作为上半双曲空间中的等距变换。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文只作概括性的介绍，并不展开详细的数学证明。读者可以参考下面的资料：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/M%C3%B6bius_transformation&quot;&gt;维基百科&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;citation&quot; data-cites=&quot;Needham1997&quot;&gt;Needham (&lt;a href=&quot;#ref-Needham1997&quot; role=&quot;doc-biblioref&quot;&gt;1997&lt;/a&gt;)&lt;/span&gt; .&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;citation&quot; data-cites=&quot;indra&quot;&gt;Mumford, Series, and
Wright (&lt;a href=&quot;#ref-indra&quot; role=&quot;doc-biblioref&quot;&gt;2002&lt;/a&gt;)&lt;/span&gt;,
chapter 3.&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;citation&quot; data-cites=&quot;palka1991&quot;&gt;Palka (&lt;a href=&quot;#ref-palka1991&quot; role=&quot;doc-biblioref&quot;&gt;1991&lt;/a&gt;)&lt;/span&gt;, chapter IX,
section 2.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文的动画应该可以帮助你更好地理解这些资料中的内容。&lt;/p&gt;</summary>
    
    
    
    <category term="可视化复分析" scheme="https://pywonderland.com/categories/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%A4%8D%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
</feed>
