<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朝花夕拾</title>
  
  <subtitle>朝花夕拾</subtitle>
  <link href="https://pywonderland.com/atom.xml" rel="self"/>
  
  <link href="https://pywonderland.com/"/>
  <updated>2025-03-23T04:17:28.662Z</updated>
  <id>https://pywonderland.com/</id>
  
  <author>
    <name>Zhao Liang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IFS 分形揭秘</title>
    <link href="https://pywonderland.com/ifs-demystified/"/>
    <id>https://pywonderland.com/ifs-demystified/</id>
    <published>2024-06-16T00:00:00.000Z</published>
    <updated>2025-03-23T04:17:28.662Z</updated>
    
    <content type="html"><![CDATA[<p>本文整理自我 2024/06/14 在上海科技大学数学所的一个小报告，标题是「GPU涂鸦与数学可视化」。这个报告是我和上科大数学所的陈浩老师、Abdelaziz NaitMerzouk合作的双曲反射群画展期间的一个助兴小节目（感谢陈浩老师一己之力将画展办起来，并邀请我去上海逛了一圈）。我保留了报告的技术内容，略去了关于demoscene 和分形文化的部分。</p><span id="more"></span><hr><p>在 Shadertoy上有很多效果酷炫，但是代码非常短的分形作品。我挑选了其中三个优秀的例子展示如下：</p><table><colgroup><col style="width: 33%"><col style="width: 33%"><col style="width: 33%"></colgroup><tbody><tr class="odd"><td style="text-align: center;"><a href="https://www.shadertoy.com/view/ltB3DG">Ethereal</a> by Kali</td><td style="text-align: center;"><a href="https://www.shadertoy.com/view/NsVyRz">Apollonian fractal</a> byXor</td><td style="text-align: center;"><a href="https://www.shadertoy.com/view/mdG3Wy">Radiosity</a> by Xor</td></tr><tr class="even"><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/ltB3DG.jpg"></td><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/NsVyRz.jpg"></td><td style="text-align: center;"><img src="https://www.shadertoy.com/media/shaders/mdG3Wy.jpg"></td></tr></tbody></table><p>然而代码短可不代表它们容易看懂。尤其是很多作者还喜欢故弄玄虚，把代码作了混淆处理以增加神秘感。对我来说，这种被人秀了一脸却没搞明白对面是怎么装的逼的感觉让人很不爽。当然我不是在抱怨，这种炫技的行为本身就是黑客文化的一部分，可以理解。后来分形玩的多了，我也慢慢明白了其中的奥妙，这次上科大之行是一次很好的机会，促使我把这些理解完整的写下来。</p><p>在这篇文章中，我将为大家揭示这些作品背后的奥秘。这些分形作品别看场景千变万化，其实都是用同一个套路制作出来的。这个套路可以简述为三步：</p><ol type="1"><li>首先将像素的 2D 坐标映射为空间中的某个 3D 点 <code>p</code>；</li><li>然后用一个 <code>fold</code> 函数，即所谓的 <a href="https://en.wikipedia.org/wiki/Iterated_function_system">迭代函数系统</a>（iteratedfunction system，简称 IFS）反复作用在<code>p</code>上。每次迭代结束后，生成一个颜色并将其添加到当前的颜色<code>color</code> 上。</li><li>当达到一定的迭代次数后，终止迭代，返回 <code>color</code>的值作为像素最终的颜色。</li></ol><p>下面是具体步骤的解释。</p><h1 id="ifs-方法">IFS 方法</h1><div id="------------" class="unnumbered statement sta_____ plain"><p><span class="statement-heading"><span class="statement-label">压缩映射</span>.</span><span class="statement-spah"> </span><br></p><p>设 <span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}^n\)</span>是一个映射，如果存在 <span class="math inline">\(0&lt;r&lt;1\)</span>使得对任何 <span class="math inline">\(x,y\in\mathbb{R}^n\)</span> 有<span class="math display">\[d(f(x),f(y))\leq r\cdot d(x,y)\]</span>成立，我们就称 <span class="math inline">\(f\)</span>是一个压缩映射，<span class="math inline">\(r\)</span> 是压缩比例。这里<span class="math inline">\(d\)</span> 是通常的 Euclidean 距离。</p></div><p>记 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 是 <span class="math inline">\(\mathbb{R}^n\)</span>中所有紧集组成的集合，可以证明 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 在 <a href="https://en.wikipedia.org/wiki/Hausdorff_distance">Hausdorff度量</a> 下构成一个完备度量空间。读者不必关心 Hausdoff度量的具体细节，只要知道它是一个度量，可以衡量两个紧集的接近程度。</p><p>设 <span class="math inline">\(f_1,\ldots,f_N\)</span> 是 <span class="math inline">\(N\)</span> 个压缩映射，<span class="math inline">\(f_i\)</span> 的压缩比例是 <span class="math inline">\(r_i\)</span>。定义映射 <span class="math inline">\(F:K(\mathbb{R}^n)\to K(\mathbb{R}^n)\)</span>如下： <span class="math display">\[F(X) = f_1(X)\cupf_2(X)\cup\cdots\cup f_N(X),\quad X\in K(\mathbb{R}^n).\]</span> 即<span class="math inline">\(F\)</span> 把 <span class="math inline">\(X\)</span> 变成 <span class="math inline">\(N\)</span> 个更小的集合。</p><p>可以证明 <span class="math inline">\(F\)</span> 是空间 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 上的压缩映射，其压缩比例<span class="math inline">\(r=\max\{r_1,\ldots,r_N\}\)</span>。于是根据<a href="https://en.wikipedia.org/wiki/Banach_fixed-point_theorem">Banach不动点定理</a>，存在唯一的紧集 <span class="math inline">\(A\subset\mathbb{R}^n\)</span> 使得 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(F\)</span> 的不动点： <span class="math display">\[F(A) = A.\]</span> 不仅如此，对 <span class="math inline">\(K(\mathbb{R}^n)\)</span> 中的任何一点（注意 <span class="math inline">\(K(\mathbb{R}^n)\)</span>是紧集组成的度量空间，里面的点都是紧集）<span class="math inline">\(B\subset\mathbb{R}^n\)</span>，都有 <span class="math display">\[\lim_{n\to\infty} F^n(B) =A.\]</span> 紧集 <span class="math inline">\(A\)</span> 叫做 <span class="math inline">\(F\)</span> 的极限集，<span class="math inline">\(A\)</span> 是一个分形，它具有自相似的特征。</p><p>我们以著名的 <a href="https://en.wikipedia.org/wiki/Sierpi%C5%84ski_triangle">Sierpiński三角形</a> 为例来说明这个过程。我们选择的三个压缩映射分别是</p><p><span class="math display">\[\begin{align}f_1(x,y) &amp;= (x/2, y/2),\\f_2(x,y) &amp;= (x/2, y/2) + (0, 1/2),\\f_3(x,y) &amp;= (x/2, y/2) + (1/2, 0).\\\end{align}\]</span></p><p>这三个压缩映射的压缩比都是 1/2。初始的紧集 <span class="math inline">\(K_0\)</span> 可以随便选，比如就取为一个圆：</p><p><span class="math display">\[K_0 =\img{/images/ifs/dot0.svg}{-1.75em}{}{4em}.\]</span></p><p>在第 1 次迭代后，它变成</p><p><span class="math display">\[K_1 = f_1(K_0)\cup f_2(K_0)\cup f_3(K_0)= \img{/images/ifs/dot1.svg}{-1.75em}{}{4em}.\]</span></p><p>在第 2 次迭代后，结果是</p><p><span class="math display">\[K_2 = f_1(K_1)\cup f_2(K_1)\cup f_3(K_1)= \img{/images/ifs/dot2.svg}{-1.75em}{}{4em}.\]</span></p><p>第 3 次迭代：</p><p><span class="math display">\[K_3 = f_1(K_2)\cup f_2(K_2)\cup f_3(K_2)= \img{/images/ifs/dot3.svg}{-1.75em}{}{4em}.\]</span></p><p>当迭代次数趋于无穷，就得到了 Sierpiński 分形：</p><p><span class="math display">\[\lim_{n\to\infty} K_n = K = f_1(K)\cupf_2(K)\cup f_3(K) =\img{/images/ifs/dot6.svg}{-1.75em}{}{4em}.\]</span></p><p>你可以很容易看出来为什么初始紧集的选择是不重要的：因为在压缩的过程中，任何紧集都会逐渐缩小到一个单点，所以<span class="math inline">\(K_0\)</span> 甚至取成一个点也是可以的。</p><p>压缩映射是无穷无尽的，所以 IFS分形也是无穷无尽的。为了避免选择困难，我们一般只使用仿射和球反演这两种变换，通过组合它们来实现空间压缩。</p><div class="statement note definition unnumbered"><p><span class="statement-heading"><span class="statement-label">注</span>：</span><span class="statement-spah"></span>这里的球反演变换是指将单位球的外部反演到内部，单位球内部保持不动的变换。虽然在单位球内部它并不压缩距离，但是只要和其它变换适当结合（必须有缩放），使得最终的复合变换是压缩的，就仍然可以得到分形。</p></div><p>然而，同时选择 <span class="math inline">\(N\)</span> 个不同的变换<span class="math inline">\(f_1,\ldots,f_N\)</span>，还要让它们互相协调合作，共同生成漂亮的图案，还是太难做到了。我们后面会介绍，在着色器中绘制IFS 是通过 <span class="math inline">\(F\)</span> 的逆映射 <span class="math inline">\(F^{-1}\)</span> 来实现的，<span class="math inline">\(F^{-1}\)</span> 就是本文开头提到的<code>fold</code>函数，它是一种「空间折叠」操作，可以通过复合若干“折叠”函数来实现。就像古代的炼丹师会通过反复调整原料配方来寻找效果最佳的丹药一样，设计分形也可以通过调整<span class="math inline">\(F^{-1}\)</span>中的折叠函数，并观察屏幕上显示的效果来实现。所以你根本无需关心 <span class="math inline">\(f_i\)</span> 是什么！</p><h1 id="轨道着色">轨道着色</h1><p>我们希望给分形染上漂亮的颜色，这个染色应该满足如下的条件：</p><ol type="1"><li>在分形上颜色是连续变化的；</li><li>在分形和非分形的交界处（即 <span class="math inline">\(A\)</span> 和<span class="math inline">\(A^c\)</span>的边界上）颜色应该是不连续的，从而产生泾渭分明的效果。</li></ol><p>做到这一点并不难，但是需要在每一次迭代时考虑当前点的位置信息。</p><p>我们首先取一个底色，比如说<code>color=vec3(0)</code>，在每一次迭代中，根据当前位置 <code>p</code>生成一个颜色，并以一定的权重与 <code>color</code> 混合。理论上颜色的 rgb的取值范围应该是 <span class="math inline">\([0,1]\)</span>，但是多数情况下我们要放宽到 <span class="math inline">\([-1,1]\)</span>之间，即颜色可以增加也可以减少。否则如果颜色只增不减的话，那么多次迭代以后rgb值很可能会溢出，变成白色。此外，随着迭代次数的增加，后面加入的颜色的权重应该单调下降，以保证突出分形的细节。这也符合我们的生活直觉：想象一下，当一位画家作画时，在开始的时候他可以浓墨重彩地画一个轮廓，但是越到后面描绘更加精细的部分时，他就会换用更细的画笔，小心地蘸一点颜料。</p><p>根据 <code>p</code>生成颜色的着色方案无穷无尽，请随便发挥你的创造力。一般来说你需要反复试验各种不同的方案才能找到最合适的。下面的例子使用了一种非常流行的染色方案，它以<code>cos(vec3(0,1,2))</code> 作为底色，并根据当前时间<code>iTime</code> 以及坐标 <code>uv</code> 进行调整：</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 uv = fragCoord / iResolution.xy;    vec3 col = 0.5 + 0.45 * cos(vec3(0, 1, 2) + iTime + uv.yxy);    fragColor = vec4(col, 1.0);}"></div><h1 id="着色器编程基础">着色器编程基础</h1><p>我简单介绍一下着色器编程的基本概念。打开 shadertoy网站，点击右上角的<code>新建</code>按钮，你会看到一个 <a href="https://www.shadertoy.com/new">最简单的动画</a>：</p><p><img src="/images/ifs/shadertoy.png" class="fig" width="600"></p><p>左边的窗口是画布，显示渲染的结果；右边窗口是代码编辑器，你在这里书写着色器代码。写完以后，点击编辑器界面左下角的三角形（或者按下<code>Alt + Enter</code>）查看编译后的效果。</p><p>画布是由若干像素组成的，你需要根据每个像素的位置，即它的<code>fragCoord</code> 值指定一个颜色。这个过程是在<code>mainImage</code> 函数中实现的：</p><figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> mainImage(<span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> fragColor, <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> fragCoord);<br></code></pre></td></tr></tbody></table></figure><p>其中 <code>fragCoord</code> 是像素的位置，<code>fragColor</code>是需要设置的像素颜色。</p><p>现实生活中有一个很形象的例子可以帮你理解着色器编程：假设你是一场方阵表演的导演，所有演员排成一个<span class="math inline">\(W\times H\)</span>的方阵，每个演员可以改变自己衣服的颜色。你的任务是发出合适的指令让每个演员根据自己的位置计算出正确的颜色，使得整个方阵呈现出漂亮的图案。</p><p><img src="/images/ifs/array.png" class="fig" width="600"></p><p>如果你一个一个地对每个演员下指令，张三你应该显示红色，李四你应该显示蓝色，等等…对成千上万个演员，这么挨个下指令还不得把人累死？正确的做法是，你应该同时对所有演员发出相同的指令，比如：“每个人，计算自己和方阵中心的距离，小于10 米的显示红色，大于等于 10 米的显示黑色”。由于每个演员都是一个单独的GPU计算单元，他们可以根据你发出的同一条指令，在极短的时间内（毫秒级）分别计算出各自的颜色。计算完毕后，观众应该会看到一个红色的圆。这种基于相同指令并行计算的工作方式就是GPU 流水线的机制。</p><p>我们来试试在着色器中实际编程绘制这个圆的例子。为了方便起见，我们假设方阵的中心是原点，并尝试绘制一个以原点为中心，半径是0.5 的圆。这只需要三行代码：</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;    float d = length(p) - 0.5;    fragColor = d > 0.0 ? vec4(0, 0, 0, 1) : vec4(1, 0, 0, 1);}"></div><ul><li>首先，每个演员会根据自己在方阵中的位置<code>fragCoord</code>，计算自己的归一化坐标 <code>p</code>，使得<code>p</code> 的纵坐标 <code>p.y</code> 位于 <span class="math inline">\([-1,1]\)</span> 中；</li><li>然后，每个演员计算自己到以原点为中心、半径为 0.5 的圆的距离<code>d</code>。位于圆内部的演员得出的 <code>d</code>是负数，圆外部的演员得出的 <code>d</code> 是正数；</li><li>最终每个人根据 <code>d</code> 的符号来确定自己的颜色。</li></ul><p>你可以修改上面代码中的半径，颜色等参数，观察左边画布的变化来体会效果。</p><p>这个例子其实蕴含了 shader编程的一个非常核心的概念，即<strong>距离场</strong> (distancefield)。当我们想绘制某个图案时，我们通过计算像素到这个图案的距离来对像素进行着色。在绘制IFS分形时，我们同样需要计算像素到分形的距离，并根据距离值来确定像素的颜色。这一点在下节会详细介绍。</p><h1 id="空间折叠">空间折叠</h1><p>上面讲到，在着色器里面画 IFS就是给每个像素指定一个颜色，这个颜色应该由像素对应的点到分形的距离来决定。假设像素对应空间中的点<span class="math inline">\(p\)</span>，初始紧集是 <span class="math inline">\(K\)</span>，我们用迭代 <span class="math inline">\(n\)</span> 次的结果 <span class="math inline">\(F^n(K)\)</span> 作为分形的近似，这里 <span class="math inline">\(n\)</span> 是某个常数，在绝大多数场景下 <span class="math inline">\(n=30\)</span> 就足够了。于是我们需要计算距离 <span class="math inline">\(d(p,F^n(K))\)</span>并根据这个距离值对像素染色。然而，直接计算 <span class="math inline">\(d(p,F^n(K))\)</span> 是不可行的，因为如果有 <span class="math inline">\(N\)</span> 个不同的压缩映射 <span class="math inline">\(f_1,\ldots,f_N\)</span>，那么每次迭代后集合的数目会乘以<span class="math inline">\(N\)</span>，这是指数增长的，10次迭代后就会产生多达 <span class="math inline">\(10^N\)</span>个不同的集合。维护如此数量的集合会轻易耗尽内存。这该怎么办呢？</p><p>有个巧妙的做法可以绕过这个困难：我们把 <span class="math inline">\(d(p,F^n(K))\)</span> 中的 <span class="math inline">\(F^n\)</span> 挪到另一侧并取逆，转而计算 <span class="math inline">\(d(F^{-n}(p), K)\)</span>！实际上，如果 <span class="math inline">\(F\)</span>只包含旋转、平移、反射、缩放、球反演这些变换的话，<span class="math inline">\(d(p,F^n(K))\)</span> 和 <span class="math inline">\(d(F^{-n}(p), K)\)</span>之间存在非常简单的关系，我们可以通过计算后者来得到前者！这个关系的推导我放在<a href="#note-F" title="注释">注释</a> 中介绍。</p><p>于是，在着色器编程时，我们需要将压缩迭代映射的步骤倒过来，采取相反的操作：即将逆映射<span class="math inline">\(F^{-1}\)</span> 迭代作用在 <span class="math inline">\(p\)</span> 上，执行足够的迭代次数后，通过计算距离<span class="math inline">\(d(F^{-n}(p), K)\)</span> 来给 <span class="math inline">\(p\)</span> 对应的像素上色。由于 <span class="math inline">\(F\)</span> 是“一对多” 的映射，所以 <span class="math inline">\(F^{-1}\)</span> 是 “多对一”的，反复迭代应用 <span class="math inline">\(F^{-1}\)</span>会把空间“折叠”。我们实际上是在这个折叠后的空间上作画。</p><p>总而言之，在着色器编程中我们真正需要的函数不是 <span class="math inline">\(F\)</span>，而是 <span class="math inline">\(F^{-1}\)</span>！</p><p>这个先折叠后画图的操作，也可以用一个生活中的例子来形象地解释，即剪纸艺术：</p><figure><img src="/images/ifs/papercut.jpg" width="480" alt="在剪纸过程中，首先把纸张反复折叠，然后在折叠后的纸张上画出某个特定的图形，沿着这个图形裁剪，再将纸张展开得到的就是美丽的图案。展开纸张的操作对应迭代映射 F，它把一个初始的紧集铺开到空间中变成分形；折叠纸张的操作对应 F^{-1}，它把分形折叠回最初的紧集。"><figcaption aria-hidden="true">在剪纸过程中，首先把纸张反复折叠，然后在折叠后的纸张上画出某个特定的图形，沿着这个图形裁剪，再将纸张展开得到的就是美丽的图案。<strong>展开</strong>纸张的操作对应迭代映射<span class="math inline">\(F\)</span>，它把一个初始的紧集铺开到空间中变成分形；<strong>折叠</strong>纸张的操作对应<span class="math inline">\(F^{-1}\)</span>，它把分形折叠回最初的紧集。</figcaption></figure><p>在设置 <span class="math inline">\(F^{-1}\)</span>的时候，我们完全不必关心每个 <span class="math inline">\(f_i\)</span>是什么，我们需要的只是准备一些折叠函数，然后将它们组合起来得到 <span class="math inline">\(F^{-1}\)</span>。</p><p>如果你去看那些分形作品的代码的话，会发现它们几乎都在 <span class="math inline">\(F^{-1}\)</span> 中使用了 <code>abs</code>函数。这个函数是最简单的空间折叠函数，它会把整个空间折叠到第一象限。进一步，再叠加关于平面/球面的反射可以产生出更复杂的折叠。</p><p>在下面的例子中，我们首先用 <code>p = abs(p)</code>将整个空间折叠到第一象限，这相当于折纸的时候将纸对折两次；然后只要在第一象限中剪出一个圆，就可以同时在其它象限自动得到另外三个圆：</p><div class="codeAndCanvas" data="void mainImage(out vec4 fragColor, in vec2 fragCoord) {    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;    p = abs(p); //折叠    float d = length(p - vec2(0.5)) - 0.3; // 中心在 (0.5, 0.5), 半径为 0.3 的圆    d = smoothstep(-0.005, 0.005, d); // 平滑一下边缘    vec3 col = mix(vec3(0), vec3(0.9), d); //染色    fragColor = vec4(col, 1);}"></div><div id="note-F" class="statement sta_d_p_f_n_k_____d_f___n__p___k_______ definition unnumbered"><p><span class="statement-heading"><span class="statement-label"><span class="math inline">\(d(p,F^n(K))\)</span> 和 <span class="math inline">\(d(F^{-n}(p), K)\)</span>之间的关系</span>：</span><span class="statement-spah"> </span><br></p><p>如果 <span class="math inline">\(F\)</span>是平移、旋转、反射这样的保持 Euclidean 距离不变的刚体运动，那么自然有<span class="math display">\[d(p, F(K)) = d(F^{-1}(p), K).\]</span></p><p>如果 <span class="math inline">\(F\)</span> 是一个缩放变换，比如<span class="math inline">\(F(x) = x/s\,(s&gt;1)\)</span>，那么 <span class="math display">\[d(p, F(K)) = d(p, 1/s\cdot K) = 1/s\cdot d(s\cdotp, K) = 1/s\cdot d(F^{-1}(p), K).\]</span>即我们要对折叠以后算出来的距离值再除以 <span class="math inline">\(s\)</span>。</p><p>既然每次迭代 <span class="math inline">\(F\)</span> 以比例 <span class="math inline">\(1/s\)</span> 缩小，所以用 <span class="math inline">\(F^{-1}\)</span> 迭代 <span class="math inline">\(n\)</span> 次以后累积放大的比例就是 <span class="math inline">\(s^n\)</span>，我们要将 <span class="math inline">\(d(F^{-n}(p), K)\)</span> 再除以 <span class="math inline">\(s^n\)</span> 才是最终正确的距离值。</p><p>对球的反演变换，甚至更一般的变换，我们可以通过计算 <span class="math inline">\(F^{-1}\)</span> 在 <span class="math inline">\(p\)</span> 处 Jacobian 矩阵的行列式的绝对值，作为<span class="math inline">\(p\)</span>处缩放的近似。把迭代过程中所有这些行列式的绝对值相乘，并对最后得到的<span class="math inline">\(d(F^{-n}(p), K)\)</span>再除以这个乘积，就可以作为 <span class="math inline">\(d(p,F(K))\)</span> 的近似。</p></div><h1 id="实战演示">实战演示</h1><p>我以 Shadertoy 上一个混淆过的 <a href="https://www.shadertoy.com/view/WlGyWK">作品</a>为例子来完整展示上面的理论。下面是重新改写后的可读版本，我在注释中解释了每一步的含义：</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/l3cXR7?gui=true&amp;t=10&amp;paused=true&amp;muted=false" allowfullscreen=""></iframe>]]></content>
    
    
    <summary type="html">
&lt;p&gt;本文整理自我 2024/06/14 在上海科技大学数学所的一个小报告，标题是「GPU
涂鸦与数学可视化」。这个报告是我和上科大数学所的陈浩老师、Abdelaziz Nait
Merzouk
合作的双曲反射群画展期间的一个助兴小节目（感谢陈浩老师一己之力将画展办起来，并邀请我去上海逛了一圈）。我保留了报告的技术内容，略去了关于
demoscene 和分形文化的部分。&lt;/p&gt;</summary>
    
    
    
    <category term="Shadertoy" scheme="https://pywonderland.com/categories/Shadertoy/"/>
    
    
  </entry>
  
  <entry>
    <title>咖啡杯中的焦散线</title>
    <link href="https://pywonderland.com/envelope-and-caustics/"/>
    <id>https://pywonderland.com/envelope-and-caustics/</id>
    <published>2024-02-08T16:00:00.000Z</published>
    <updated>2025-03-14T15:45:19.690Z</updated>
    
    <content type="html"><![CDATA[<p>春节的晚上，外面鞭炮喧天，家人在看电视，我躲在屋里看数学，还是挺惬意的。</p><p>我看的是 <a href="https://johncarlosbaez.wordpress.com">John Baez</a>和 <a href="https://www.gregegan.net">Greg Egan</a> 的博客。John Baez是一位在科普方面非常高产的数学家，写过不计其数的科普文章。读他的文章非常让人享受，因为他总是从直观的例子入手，一步步启发读者，展开到更高级的数学。GregEgan是澳大利亚的一位非常高产的科幻小说作家，有不少作品已经被国内引入。他的小说属于硬科幻风格，而且是非常硬的那种。他也有不少有趣的<a href="https://www.gregegan.net/SCIENCE/Science.html">博客文章</a>。不过与John Baez 不同的是，Greg Egan的文章不太会去兼顾不同水平的读者，对我来说，要看懂他在说什么经常不是一件容易的事情。</p><p>John Baez 博客上有一个系列 <a href="https://johncarlosbaez.wordpress.com/2012/08/31/rolling-circles-and-balls-part-1/">Rollingcircles and balls</a> 讨论了圆的外摆线和焦散，Greg Egan 也有一篇 <a href="https://www.gregegan.net/SCIENCE/Catacaustics/Catacaustics.html">文章</a>更深入的讨论了曲线的焦散。这个话题非常有意思，我也一时手痒写代码实验了一番并记录在此。</p><span id="more"></span><h1 id="pov-ray-光学实验">POV-Ray 光学实验</h1><p>有一个有趣的物理现象，我想你已经知道了：当光线照在咖啡杯的内壁上时，光线反射以后会形成一个亮斑，术语叫做焦散(caustic)。</p><p><img src="/images/caustics/cup.jpg" class="fig" width="400"></p><p>形成焦散的原因是，光线在杯子内壁反射以后，光子的分布是不均匀的，某些区域经过的光子特别密集，所以亮度就更高。</p><p>焦散是一条曲线，它和所有的反射光线相切。用数学的术语说就是，焦散是所有反射光线的<a href="https://en.wikipedia.org/wiki/Envelope_(mathematics)">包络</a>(envelope)。焦散的具体形状和杯子的形状、光源的位置都有关。如果杯子是圆形的，则当光源是点光源且恰好位于杯子边缘上某一点时，焦散是<a href="https://en.wikipedia.org/wiki/Cardioid">心脏线</a>(cardioid)；当光源位于无穷远时（这时可以视作平行光源），焦散是 <a href="https://en.wikipedia.org/wiki/Nephroid">肾形线</a>(nephroid)。一般情况下焦散的形状介于心脏线和肾形线之间。</p><p>更有意思的是，如果杯子的外形是心脏线，而且光源正好位于心脏线的尖点时，得到的焦散正好是肾形线。我写了一个<a href="https://github.com/neozhaoliang/pywonderland/tree/master/src/catacaustic">POV-Ray脚本</a>，模拟了这一现象：</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr class="odd"><td style="text-align: center;">圆形杯子给出心脏线</td><td style="text-align: center;">心脏线杯子给出肾形线</td></tr><tr class="even"><td style="text-align: center;"><img src="/images/caustics/caustics_cardioid.png" class="fig" width="400"></td><td style="text-align: center;"><img src="/images/caustics/caustics_nephroid.png" class="fig" width="400"></td></tr></tbody></table><p>心脏线和肾形线都是所谓的 <a href="https://en.wikipedia.org/wiki/Epicycloid">外摆线</a>，只是两圆的半径之比不同：</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><tbody><tr class="odd"><td style="text-align: center;">心脏线</td><td style="text-align: center;">肾形线</td></tr><tr class="even"><td style="text-align: center;"><video src="/images/caustics/cardioid.mp4" controls=""></video></td><td style="text-align: center;"><video src="/images/caustics/nephroid.mp4" controls=""></video></td></tr></tbody></table><p>所以我们很容易作出如下的猜想：如果在肾形线的内部或者尖点放一个光源，是不是又会得到下一个外摆线？然而根据Greg Egan 在他博客中的实验，这个应该是不成立的。</p><h1 id="求解参数曲线的焦散">求解参数曲线的焦散</h1><p>这一节我们来介绍怎样计算一般的参数曲线 <span class="math inline">\(\mathbf{c}(t)=(x(t),y(t))\)</span> 的焦散。</p><p>设点光源的位置是 <span class="math inline">\((a,b)\)</span>，则在曲线上点 <span class="math inline">\((x,y)\)</span> 处，入射光线的方向是 <span class="math display">\[\mathbf{l}=(x-a,y-b).\]</span> 这里不需要把 <span class="math inline">\(\mathbf{l}\)</span>单位化，因为我们列方程的时候只需要光线的方向，并不在乎长度。</p><p>同样是在 <span class="math inline">\((x,y)\)</span>处，曲线的法向量是 <span class="math display">\[\mathbf{n}=\frac{(-y',x')}{\sqrt{(x')^2+(y')^2}}=\frac{(-y',x')}{|\mathbf{c}'|}.\]</span> 这里我们用 <span class="math inline">\(x',y'\)</span> 表示 <span class="math inline">\(x,y\)</span> 关于 <span class="math inline">\(t\)</span> 的导数。</p><p>于是 <span class="math inline">\((x,y)\)</span> 处的反射光线的方向<span class="math inline">\(\mathbf{r}\)</span> 由如下反射公式给出：<span class="math display">\[\mathbf{r}= \mathbf{l}- 2(\mathbf{l}\cdot\mathbf{n})\mathbf{n}.\]</span> 设 <span class="math inline">\((X,Y)\)</span> 是反射光线上的任一点，由于 <span class="math inline">\((x,y)\)</span> 是反射光线的起点，所以 <span class="math inline">\((X-x,Y-y)\)</span> 与 <span class="math inline">\(\mathbf{r}\)</span> 平行。记 <span class="math inline">\(\mathbf{r}=(r_x,r_y)\)</span>，则 <span class="math inline">\((X-x,Y-y)\)</span> 与 <span class="math inline">\((-r_y, r_x)\)</span> 垂直，即 <span class="math display">\[(X-x, Y-y)\cdot(-r_y, r_x)=0.\]</span>不要急着把这个式子展开：记 <span class="math display">\[F(X,Y,t)=(X-x,Y-y)\cdot(-r_y, r_x),\]</span> 则我们得到了反射光线 <span class="math inline">\((X(t), Y(t))\)</span> 满足的曲线族方程 <span class="math inline">\(F(X,Y,t)=0\)</span>。于是焦散曲线作为反射曲线的包络，可以通过联立方程组<span class="math display">\[\begin{align}F(X,Y,t)=0,\\\frac{\partialF}{\partial t}F(X,Y,t)=0.\end{align}\]</span> 也就是 <span class="math display">\[\begin{align}(X-x, Y-y)\cdot(-r_y,r_x)&amp;=0,\\-(x',y')\cdot(-r_y, r_x) +(X-x,Y-y)\cdot(-r_y', r_x') &amp;=0.\end{align}\]</span>然后解出 <span class="math inline">\(X,Y\)</span> 得到。</p><p>如果你还记得 2x2矩阵的逆公式的话，这个方程组其实可以目视写出解来。我们把它写成</p><p><span class="math display">\[\begin{pmatrix}-r_y &amp; r_x\\-r_y'&amp;r_x'\end{pmatrix}\cdot\begin{pmatrix}X-x\\Y-y\end{pmatrix}=\begin{pmatrix}0\\r_xy'-r_yx'\end{pmatrix}.\]</span> 于是 <span class="math display">\[\begin{pmatrix}X-x\\Y-y\end{pmatrix}=\begin{pmatrix}-r_y&amp; r_x\\ -r_y'&amp;r_x'\end{pmatrix}^{-1}\begin{pmatrix}0\\r_xy'-r_yx'\end{pmatrix}=\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span> 即 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix} +\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span></p><p>按照上面的理论，我写了一个小脚本，用 <code>sympy</code>(version=1.12) 来计算圆的焦散线。代码中假定圆心是原点，半径为 1，光源在<span class="math inline">\((1,0)\)</span> 处。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>t, X, Y = symbols(<span class="hljs-string">"t X Y"</span>)<br>C = Matrix([cos(t), sin(t)]) <span class="hljs-comment"># curve</span><br>light = Matrix([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]) <span class="hljs-comment"># light source</span><br>l = C - light <span class="hljs-comment"># incident ray</span><br>dx, dy = diff(C, t)<br>n = Matrix([dy, -dx]) <span class="hljs-comment"># normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n)) <span class="hljs-comment"># reflected ray</span><br>F = (Y - y) * r[<span class="hljs-number">0</span>] - (X - x) * r[<span class="hljs-number">1</span>]<br>dF = diff(F, t)<br>result = solve((F, dF), X, Y) <span class="hljs-comment"># solve the envelope</span><br>print(<span class="hljs-string">f"X(t)=<span class="hljs-subst">{trigsimp(result[X], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br>print(<span class="hljs-string">f"Y(t)=<span class="hljs-subst">{trigsimp(result[Y], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 给出的结果是：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X(t)=<span class="hljs-number">2</span>*cos(t)/<span class="hljs-number">3</span> + cos(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span><br>Y(t)=<span class="hljs-number">2</span>*sin(t)/<span class="hljs-number">3</span> + sin(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>这正是喜闻乐见的心脏线的参数表示： <span class="math display">\[\left\{\begin{align}x(t)&amp;=\frac{\cos(2t) +2\cos(t)}{3},\\ y(t)&amp;=\frac{\sin(2t) +2\sin(t)}{3}.\end{align}\right.\]</span></p><p>使用这个参数表示，我们继续计算当光源放在心脏线的尖点，即 <span class="math inline">\(t=\pi\)</span> 对应的点 <span class="math inline">\((-\frac{1}{3},0)\)</span> 时得到的焦散：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>t, X, Y = symbols(<span class="hljs-string">"t X Y"</span>)<br>C = Matrix([(<span class="hljs-number">2</span>*cos(t) + cos(<span class="hljs-number">2</span>*t)) / <span class="hljs-number">3</span>, (<span class="hljs-number">2</span>*sin(t) + sin(<span class="hljs-number">2</span>*t)) / <span class="hljs-number">3</span>])<br>light = Matrix([S(<span class="hljs-string">'-1/3'</span>, evaluate=<span class="hljs-literal">False</span>), <span class="hljs-number">0</span>])<br>l = C - light <span class="hljs-comment"># incident ray</span><br>dx, dy = diff(C, t)<br>n = Matrix([dy, -dx]) <span class="hljs-comment"># normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n)) <span class="hljs-comment"># reflected ray</span><br>F = (Y - y) * r[<span class="hljs-number">0</span>] - (X - x) * r[<span class="hljs-number">1</span>]<br>dF = diff(F, t)<br>result = solve((F, dF), X, Y) <span class="hljs-comment"># solve the envelope</span><br>print(<span class="hljs-string">f"X(t)=<span class="hljs-subst">{trigsimp(result[X], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br>print(<span class="hljs-string">f"Y(t)=<span class="hljs-subst">{trigsimp(result[Y], method=<span class="hljs-string">'groebner'</span>)}</span>"</span>)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 很快算出了正确的结果：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X(t)=sin(t)*sin(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span> + cos(t)/<span class="hljs-number">3</span><br>Y(t)=-sin(t)*cos(<span class="hljs-number">2</span>*t)/<span class="hljs-number">3</span> + sin(t)/<span class="hljs-number">3</span><br></code></pre></td></tr></tbody></table></figure><p>不难验证</p><p><span class="math display">\[\begin{align}\frac{\sin(t)\sin(2t) +\cos(t)}{3}&amp;=\frac{3\cos(t) - \cos(3t)}{6},\\ \frac{-\sin(t)\cos(2t)+ \sin(t)}{3}&amp;=\frac{3\sin(t) -\sin(3t)}{6}.\end{align}\]</span></p><p>这正是 <a href="https://en.wikipedia.org/wiki/Nephroid#Parametric">维基百科</a>中所列的肾形线的参数方程中取 <span class="math inline">\(a=1/6\)</span>的结果。</p><p>把上面的曲线画出来是这样的：</p><p><img src="/images/caustics/caustics_matplotlib.svg" class="fig" width="400"></p><h1 id="求解多项式曲线的焦散">求解多项式曲线的焦散</h1><p>很多时候曲线的方程是通过隐函数 <span class="math inline">\(P(x,y)=0\)</span> 的形式给出的，其中 <span class="math inline">\(P(x,y)\)</span> 是关于两个变元 <span class="math inline">\(x,y\)</span>的多项式。这样的曲线叫做平面代数曲线。这时求解焦散要用到 Gröbner基的工具。</p><p>让我们回到参数方程的情形，我们已经看到，这时焦散 <span class="math inline">\((X,Y)\)</span> 有显式解</p><p><span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix} +\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span></p><p>其中 <span class="math inline">\(x,y,r_x,r_y\)</span> 都是关于 <span class="math inline">\(t\)</span>的函数，它们的导数也是可计算的，所以可以算出 <span class="math inline">\((X,Y)\)</span> 来。</p><p>但是在隐函数的情形，我们没有 <span class="math inline">\(x,y\)</span>的某种关于 <span class="math inline">\(t\)</span>的表达式。不过没关系，我们先假设有这样的参数表达式，看看能得到什么结论。设<span class="math inline">\(x=x(t),y=y(t)\)</span> 是某个参变元 <span class="math inline">\(t\)</span> 的函数，在 <span class="math inline">\(P(x,y)=0\)</span> 两边对 <span class="math inline">\(t\)</span> 求导可得 <span class="math display">\[\frac{\partial P}{\partial t}=\frac{\partialP}{\partial x}x'(t) + \frac{\partial P}{\partialy}y'(t)=0.\]</span> 记 <span class="math inline">\(k=-\frac{\partialP}{\partial x}/\frac{\partial P}{\partial y}\)</span>，则 <span class="math inline">\(y'(t)=kx'(t)\)</span>。</p><p>对反射光线 <span class="math inline">\(\mathbf{r}\)</span> 的两个分量<span class="math inline">\(r_x,r_y\)</span> 也分别使用链式求导，我们有<span class="math display">\[\begin{align}\frac{\partial r_x}{\partialt}&amp;=\frac{\partial r_x}{\partial x}x'(t) + \frac{\partialr_x}{\partial y}y'(t),\\\frac{\partial r_y}{\partial t}&amp;=\frac{\partial r_y}{\partialx}x'(t) + \frac{\partial r_y}{\partialy}y'(t).\end{align}\]</span> 于是我们发现比值 <span class="math display">\[\begin{align}\frac{r_xy'-r_yx'}{r_yr_x'-r_xr_y'}&amp;=\frac{r_xk-r_y}{r_y(\frac{\partialr_x}{\partial x}+\frac{\partial r_x}{\partial y}k)-r_x(\frac{\partialr_y}{\partial x} + \frac{\partial r_y}{\partial y}k)}\\&amp;=-\frac{r_x\frac{\partial P}{\partial x}+r_y\frac{\partialP}{\partial y}}{r_y(\frac{\partial r_x}{\partial x}\frac{\partialP}{\partial y}-\frac{\partial r_x}{\partial y}\frac{\partial P}{\partialx})-r_x(\frac{\partial r_y}{\partial x}\frac{\partial P}{\partial y} -\frac{\partial r_y}{\partial y}\frac{\partial P}{\partial x})}.\end{align}\]</span> 变成了一个不需要显式用到 <span class="math inline">\(t\)</span> 的量，即变量 <span class="math inline">\(t\)</span> “消掉”了。代入上面焦散的表达式中，我们得到 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix}-\frac{r_x\frac{\partialP}{\partial x}+r_y\frac{\partial P}{\partial y}}{r_y(\frac{\partialr_x}{\partial x}\frac{\partial P}{\partial y}-\frac{\partialr_x}{\partial y}\frac{\partial P}{\partial x})-r_x(\frac{\partialr_y}{\partial x}\frac{\partial P}{\partial y} - \frac{\partialr_y}{\partial y}\frac{\partial P}{\partial x})}\begin{pmatrix}r_x\\r_y\end{pmatrix}.\]</span> 这个式子还可以再简化一点：注意到曲线在 <span class="math inline">\((x,y)\)</span> 处的法向量由 <span class="math inline">\(\mathbf{n}=\frac{\nabla P}{|\nabla P|}\)</span>给出，其中 <span class="math inline">\(\nabla P=(\frac{\partialP}{\partial x},\frac{\partial P}{\partial y})\)</span>。于是由 <span class="math display">\[\mathbf{r}= \mathbf{l}- 2(\mathbf{l}\cdot\mathbf{n})\mathbf{n}\]</span> 可得 <span class="math display">\[\mathbf{r}\cdot \nabla P=-\mathbf{l}\cdot \nablaP.\]</span> 从而 <span class="math display">\[\begin{pmatrix}X\\Y\end{pmatrix}=\begin{pmatrix}x\\y\end{pmatrix}+\frac{\mathbf{l}\cdot\nablaP}{r_y(\frac{\partial r_x}{\partial x}\frac{\partial P}{\partialy}-\frac{\partial r_x}{\partial y}\frac{\partial P}{\partialx})-r_x(\frac{\partial r_y}{\partial x}\frac{\partial P}{\partial y} -\frac{\partial r_y}{\partial y}\frac{\partial P}{\partialx})}\begin{pmatrix}r_x\\ r_y\end{pmatrix}.\]</span></p><p>这是四个变量 <span class="math inline">\(x,y,X,Y\)</span>满足的两个方程，形如 <span class="math inline">\(F(X,x,y)=0\)</span> 和<span class="math inline">\(G(Y,x,y)=0\)</span>。记住我们还有已知的方程<span class="math inline">\(P(x,y)=0\)</span>。为了从这三个方程中消掉<span class="math inline">\(x,y\)</span>，得到一个仅包含 <span class="math inline">\((X,Y)\)</span> 的表达式，我们可以尝试用 <a href="https://en.wikipedia.org/wiki/Gr%C3%B6bner_basis">Gröbnerbasis</a> 方法。Gröbner 基方法会把多项式方程组 <span class="math display">\[F=G=P=0\]</span> 转化为一组等价的新方程组 <span class="math display">\[g_1=g_2=\cdots=g_m=0.\]</span>即它们有完全相同的解集。</p><p><span class="math inline">\(\{g_1,\ldots,g_m\}\)</span> 是 <span class="math inline">\(F,G,P\)</span> 在多项式环 <span class="math inline">\(\mathbb{R}[x,y,X,Y]\)</span> 中生成的理想 <span class="math inline">\(I=\langle F,G,P\rangle\)</span>的一组生成元，<span class="math inline">\(\{g_1,\ldots,g_m\}\)</span>叫做 <span class="math inline">\(I\)</span> 的约化的 Gröbner基。在字典序 <span class="math inline">\(x\succ y\succ X\succ Y\)</span>下，约化的 Gröbner 基会有一个好的属性，即从 <span class="math inline">\(g_1\)</span> 到 <span class="math inline">\(g_m\)</span>，其中的变元会按照从 <span class="math inline">\(x\to y\to X\to Y\)</span>的先后顺序被消除掉。注意这是个不太严格的说法，我们并不是总能消掉顺序靠前的变元，但是如果消除发生的话，它就会按照这个顺序来。这样我们就可以执行类似高斯消元法中的回代操作，从而新方程组的求解会更加简单。</p><p>我们来用 <code>sympy</code> 实验一下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sympy <span class="hljs-keyword">import</span> *<br><br>x, y, X, Y = symbols(<span class="hljs-string">"x y X Y"</span>)<br>P = x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span> - <span class="hljs-number">1</span><br>dx = diff(P, x)  <span class="hljs-comment"># gradient of P</span><br>dy = diff(P, y)<br>curve = Matrix([x, y])<br>light_source = Matrix([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>l = curve - light_source  <span class="hljs-comment"># the incident ray</span><br>n = Matrix([dx, dy])  <span class="hljs-comment"># the normal vector</span><br>r = simplify(l - <span class="hljs-number">2</span> * l.dot(n) * n / n.dot(n))  <span class="hljs-comment"># the reflected ray</span><br>rx, ry = r<br>dxrx = diff(rx, x)<br>dyrx = diff(rx, y)<br>dxry = diff(ry, x)<br>dyry = diff(ry, y)<br>denominator = ry * (dxrx * dy - dyrx * dx) - rx * (dxry * dy - dyry * dx)<br>nominator = dx * l[<span class="hljs-number">0</span>] + dy * l[<span class="hljs-number">1</span>]<br>F = (X - x) * denominator - nominator * rx<br>G = (Y - y) * denominator - nominator * ry<br>eqs = [eq.as_numer_denom()[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> eq <span class="hljs-keyword">in</span> [F, G, P]]<br>gb = groebner(eqs, [x, y, X, Y])<br>print(gb)<br></code></pre></td></tr></tbody></table></figure><p><code>sympy</code> 给出的结果的最后一项是</p><p><span class="math display">\[27 X^{4} y^{2} + 54 X^{2} Y^{2} y^{2} -18 X^{2} y^{2} - 8 X y^{2} + 27 Y^{4} y^{2} - 18 Y^{2} y^{2} -y^{2}.\]</span></p><p><span class="math inline">\(x\)</span> 被消掉了！原方程组 <span class="math inline">\(F=G=P\)</span>的解必然是上面这个方程的解的子集。观察它的每一项都带有一个 <span class="math inline">\(y^2\)</span>，这显然不是我们要的解。把 <span class="math inline">\(y^2\)</span> 去掉，剩下的因子</p><p><span class="math display">\[27X^{4}+54X^{2}Y^{2}-18X^{2} -8X +27Y^{4}-18Y^{2}-1=0.\]</span></p><p>就是心脏线的隐函数表示。不信？在 <a href="https://www.desmos.com/geometry/vtjbq3ete1">Desmos</a>里面画出来看看！</p><p><img src="/images/caustics/desmos_cardioid.png" class="fig" width="300"></p><h1 id="后记">后记</h1><p>这篇文章主要覆盖了 Greg Egan博文的前半部分，他的后半部分内容我觉得有点放飞自我，也没怎么仔细看。</p><p>虽然我们用 <code>sympy</code>的实验很成功，但注意并不是所有情况下都能得到焦散曲线（比如光源位于抛物线的焦点时，反射光线都是平行的），而且对复杂的曲线<code>sympy</code> 算起来非常慢。</p><p>我研究生的时候上过计算机代数的课程，当时用的教学软件是 Maple。Maple编程是很不方便的，所以我其实没有多少计算机代数的编程经验。我之前一直觉得<code>sympy</code>运行又慢，输出的表达式也不够简化，所以不太愿意用它。这次实验有点刷新我对<code>sympy</code>的认知。我还记得当时课程要求每人提交一份读书报告，我写的是 <a href="https://link.springer.com/book/10.1007/978-3-319-16721-3">Ideals,Varieties, and Algorithms</a> 的笔记，但毕业多年以来这还是我第一次用到Gröbner 基！</p><p>我写这篇文章的时候正好临近情人节，所以我在想有没有什么曲线的焦散能给出<a href="https://www.desmos.com/geometry/ngdpq0zrei">爱心曲线</a>：</p><p><img src="/images/caustics/heart.png" class="fig" width="300"></p><p>于是我找到了 <a href="https://www.tandfonline.com/doi/full/10.1080/00029890.2020.1722019">这篇文章</a>。不过看起来里面给出的结论计算量很大，很难用在爱心线上（也许是我错了）。</p>]]></content>
    
    
    <summary type="html">
&lt;p&gt;春节的晚上，外面鞭炮喧天，家人在看电视，我躲在屋里看数学，还是挺惬意的。&lt;/p&gt;
&lt;p&gt;我看的是 &lt;a href=&quot;https://johncarlosbaez.wordpress.com&quot;&gt;John Baez&lt;/a&gt;
和 &lt;a href=&quot;https://www.gregegan.net&quot;&gt;Greg Egan&lt;/a&gt; 的博客。John Baez
是一位在科普方面非常高产的数学家，写过不计其数的科普文章。读他的文章非常让人享受，因为他总是从直观的例子入手，一步步启发读者，展开到更高级的数学。Greg
Egan
是澳大利亚的一位非常高产的科幻小说作家，有不少作品已经被国内引入。他的小说属于硬科幻风格，而且是非常硬的那种。他也有不少有趣的
&lt;a href=&quot;https://www.gregegan.net/SCIENCE/Science.html&quot;&gt;博客文章&lt;/a&gt;。不过与
John Baez 不同的是，Greg Egan
的文章不太会去兼顾不同水平的读者，对我来说，要看懂他在说什么经常不是一件容易的事情。&lt;/p&gt;
&lt;p&gt;John Baez 博客上有一个系列 &lt;a href=&quot;https://johncarlosbaez.wordpress.com/2012/08/31/rolling-circles-and-balls-part-1/&quot;&gt;Rolling
circles and balls&lt;/a&gt; 讨论了圆的外摆线和焦散，Greg Egan 也有一篇 &lt;a href=&quot;https://www.gregegan.net/SCIENCE/Catacaustics/Catacaustics.html&quot;&gt;文章&lt;/a&gt;
更深入的讨论了曲线的焦散。这个话题非常有意思，我也一时手痒写代码实验了一番并记录在此。&lt;/p&gt;</summary>
    
    
    
    <category term="pywonderland 项目" scheme="https://pywonderland.com/categories/pywonderland-%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
</feed>
