{"userName":"neozhaoliang","date":"2025-08-25T01:56:15.254Z","numShaders":55,"shaders":[{"ver":"0.1","info":{"id":"4scfR2","date":"1525866410","viewed":43036,"name":"Mobius trans in hyper 3-space","description":"This shader is based on Roice Nelson's work at https://www.shadertoy.com/view/MstcWr","likes":78,"published":"Public API","usePreview":1,"tags":["mobius","hyperbolic"]},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Keyboard control:\n    \n    Key 1 turn on/off applying the Mobius transformation\n    Key 2 turn on/off applying the elliptic rotation\n    Key 3 turn on/off applying the hyperbolic scaling\n    Key 4 turn on/off showing the Riemann sphere\n*/\n\n#define PI  3.1415926536\n#define E_  2.71828118285\n\n// Raymarching constants\n#define AA               2\n#define MIN_TRACE_DIST   0.01\n#define MAX_TRACE_STEPS  255\n#define PRECISION        1e-5\n#define FAR              100.\n\n// Animation speed\n#define anim_speed (iTime * .5)\n#define hue_speed  (iTime * .3)\n\n// grid and cone size\nconst vec2 polar_grid = vec2(0.4, PI / 7.0);\nconst vec2 cone_angle = normalize(vec2(1.5, 1.0));\n\n// Intensity constants\nconst float intensity_divisor = 40000.;\nconst float intensity_factor_max = 7.2;\nconst float center_intensity = 12.;\nconst float dist_factor = 3.;\nconst float ppow = 1.9;\n\n// Color constants\nconst float center_hue = 0.5;\nconst float center_sat = 0.18;\n\n// shape constants\nconst float strong_factor = 7.;\nconst float weak_factor = 1.;\nconst vec2 star_hv_factor = vec2(30, 1);\nconst vec2 star_diag_factor = vec2(30, 1);\n//const vec2 star_hv_factor = vec2(9.0, 0.3);\n//const vec2 star_diag_factor = vec2(12.0, 0.6);\n\n\n// b_apply: apply Mobius transformation or not\n// b_elliptic: apply rotation or not\n// b_hyperbolic: apply scaling or not\n// b_parabolic is true if b_elliptic and b_parabolic are both false\n// b_loxodromic is true if b_elliptic and b_parabolic are both true\nbool b_apply = true;\nbool b_elliptic = true;\nbool b_hyperbolic = true;\nbool b_riemann = true;  // action on Riemman sphere or not\nbool b_parabolic, b_loxodromic;\n\n// hsv to rgb conversion\nvec3 hsv2rgb(vec3 hsv)\n{\n    const vec3 p = vec3(0.0, 2.0/3.0, 1.0/3.0);\n    hsv.yz = clamp(hsv.yz, 0.0, 1.0);\n    return hsv.z*(0.63*hsv.y*(cos(2.*PI*(hsv.x + p)) - 1.0) + 1.0);\n}\n\n// Conversion between Euclidean distance and hyperbolic distance\n// in upper half space. They are inverse of each other.\nfloat eucToHyp(float d) { return log(d); }\nfloat hypToEuc(float d) { return pow(E_, d); }\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n// 1d and 2d rectangular grids\nfloat grid1d(float x, float size)\n{\n    return mod(x + 0.5 * size, size) - 0.5 * size;\n}\n\nvec2 grid2d(vec2 p, vec2 size)\n{\n    return mod(p + 0.5 * size, size) - 0.5 * size;\n}\n\n// 2d polar grids\nvec2 polarGrid(vec2 p, vec2 size)\n{\n    float theta = atan(p.y, p.x);\n    float r = eucToHyp(length(p));\n    return grid2d(vec2(r, theta), size);\n}\n\n/*\n * Complex arithmetic\n*/\nvec2 cmul(vec2 z, vec2 w)\n{\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w)\n{\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\nvec2 csqrt(vec2 z)\n{\n    float r2 = dot(z, z);\n    float r = sqrt(sqrt(r2));\n    float angle = atan(z.y, z.x);\n    return r * vec2(cos(angle / 2.0), sin(angle / 2.0));\n}\n\n/*\n * Quaternion arithmetic\n*/\nvec4 qmul(vec4 p, vec4 q)\n{\n    return vec4(p.x * q.x - dot(p.yzw, q.yzw),\n                p.x * q.yzw + q.x * p.yzw + cross(p.yzw, q.yzw));\n}\n\nvec4 qdiv(vec4 p, vec4 q)\n{\n    return qmul(p, vec4(q.x, -q.yzw) / dot(q, q));\n}\n\n/*\n * Mobius transformation z --> (Az + B) / (Cz + D)\n*/\nstruct Mobius\n{\n    vec2 A, B, C, D;\n};\n\nconst Mobius mob = Mobius(\n    vec2(-1, 0),\n    vec2(1, 0),\n    vec2(-1, 0),\n    vec2(-1, 0)\n);\n\n// Apply Mobius transformation on complex plane\nvec2 applyMobius(vec2 z)\n{\n    vec2 z1 = cmul(mob.A, z) + mob.B;\n    vec2 z2 = cmul(mob.C, z) + mob.D;\n    return cdiv(z1, z2);\n}\n\n// Apply Mobius transformation on upper half space as quaternions\n// (x, y, z) --> (x + yi + zj + 0k)\nvec4 applyMobius(vec4 p)\n{\n    vec4 p1 = qmul(vec4(mob.A, 0., 0.), p) + vec4(mob.B, 0., 0.);\n    vec4 p2 = qmul(vec4(mob.C, 0., 0.), p) + vec4(mob.D, 0., 0.);\n    return qdiv(p1, p2);\n}\n\nfloat applyMobius(inout vec3 p)\n{\n    if (!b_apply)\n        return 1.0;\n\n    p = applyMobius(vec4(p, 0)).xyz;\n    float scale = length(p);\n    return scale > 1.0 ? 1.0 / scale : scale;\n}\n\n// A Mobius transformation of hyperbolic type is conjugate to a pure scaling\nvoid trans_hyperbolic(inout vec2 p)\n{\n    float d = eucToHyp(length(p)) - anim_speed * polar_grid.x;\n    // This avoids running out of resolution.\n    d = grid1d(d, polar_grid.x);\n    p = normalize(p) * hypToEuc(d);\n}\n\n// A Mobius transformation of elliptic type is conjugate to a pure rotation\nvoid trans_elliptic(inout vec2 p)\n{\n    p = rot2d(p, anim_speed * polar_grid.y);\n}\n\n// A Mobius transformation of parabolic type is conjugate to a pure translation\nvoid trans_parabolic(inout vec2 p)\n{\n    p.x += iTime * polar_grid.x / 3.;\n}\n\n// signed distance function for sphere kissing at y=0 with radius r\nfloat sdSphere(vec3 p, float r) { p.y -= r; return length(p) - r; }\n// signed distance functions for plane y=0 and y=c\nfloat sdPlane(vec3 p) { return p.y; }\nfloat sdPlane(vec3 p, float c) { return p.y - c; }\n// a cone in the upper hyperbolic space may be a usual cone at the origin\n// or a Dupin cyclide with its two horns on the plane\nfloat sdCone(vec3 p)\n{\n    float t = 1.0;\n    if (b_apply)\n    {\n        t = applyMobius(p);\n        p = normalize(p);\n    }\n    float q = length(p.xz);\n    return dot(cone_angle, vec2(q, -p.y)) * t;\n}\n\n// signed distance function for parabolic case\nfloat sdScene1(vec3 p)\n{\n    return b_apply ? min(sdPlane(p), sdSphere(p, 1.0)) : sdPlane(p, 0.5);\n}\n\n// signed distance function for elliptic/hyperbolic case\nfloat sdScene2(vec3 p)\n{\n    if (b_riemann)\n        return min(sdPlane(p), sdSphere(p, 1.));\n\n    return min(sdPlane(p), sdCone(p));\n}\n\n\nvec3 getColor(vec2 p, float pint)\n{\n    float sat = 0.75 / pow(pint, 2.5) + center_sat;\n    // change hue by time\n    float hue2 = b_parabolic ?\n        hue_speed - length(p.y) / 5.0 :\n        hue_speed - eucToHyp(length(p)) / 7.0;\n    float hue = center_hue + hue2;\n    return hsv2rgb(vec3(hue, sat, pint)) + pint / 3.;\n}\n\nfloat getIntensity1(vec2 p)\n{\n    float dist = length(p);\n    float disth = length(p * star_hv_factor);\n    float distv = length(p * star_hv_factor.yx);\n\n    vec2 q = 0.7071 * vec2(dot(p, vec2(1.)), dot(p, vec2(1., -1.)));\n    float dist1 = length(q * star_diag_factor);\n    float dist2 = length(q * star_diag_factor.yx);\n\n    // Middle point star intensity\n    float pint1 = .5 / (dist * dist_factor + 0.015)\n        + strong_factor / (distv * dist_factor + 0.01)\n        + weak_factor / (disth * dist_factor + 0.01)\n        + weak_factor / (dist1 * dist_factor + 0.01)\n        + weak_factor / (dist2 * dist_factor + 0.01);\n\n    return center_intensity * intensity_factor_max * pow(pint1, ppow) / intensity_divisor;\n}\n\nfloat getIntensity2(vec2 p)\n{\n    float angle = atan(polar_grid.x, polar_grid.y);\n    float dist  = length(p);\n    float disth = length(p * star_hv_factor);\n    float distv = length(p * star_hv_factor.yx);\n\n    vec2 q1 = rot2d(p, angle);\n    float dist1 = length(q1 * star_diag_factor);\n    vec2 q2 = rot2d(p, -angle);\n    float dist2 = length(q2 * star_diag_factor);\n\n    float pint1 = 1. / (dist * dist_factor  + .5);\n    if (b_loxodromic)\n    {\n        pint1 = strong_factor / (dist2 * dist_factor + 0.01)\n            + weak_factor  / (dist1 * dist_factor + 0.01)\n            + weak_factor / (disth * dist_factor + 0.01)\n            + weak_factor / (distv * dist_factor + 0.01);\n    }\n    else if (b_elliptic)\n    {\n        pint1 += weak_factor / (distv * dist_factor + 0.01) +\n            strong_factor / (disth * dist_factor + 0.01) +\n            weak_factor / (dist1 * dist_factor + 0.01) +\n            weak_factor / (dist2 * dist_factor + 0.01);\n    }\n    else\n    {\n        pint1 += weak_factor / (disth * dist_factor + 1.) +\n            strong_factor / (distv * dist_factor + .01) +\n            weak_factor / (dist1 * dist_factor + 0.01) +\n            weak_factor / (dist2 * dist_factor + 0.01);\n    }\n    return intensity_factor_max * pow(pint1, ppow) / intensity_divisor * center_intensity * 3.;\n}\n\nfloat map(vec3 pos)\n{\n    return b_parabolic ? sdScene1(pos) : sdScene2(pos);\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(.003, 0);\n    float d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n    float d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n    float d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    float d = map(p) * 2.;\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k)\n{\n    const int maxShadeIterations = 20;\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < maxShadeIterations; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, smoothstep(0., 1., k * h / t));\n        t += clamp(h, 0.01, 0.2);\n        if (abs(h) < 1e-4 || t > tmax)\n            break;\n    }\n    return clamp(res+0.15, 0.0, 1.0);\n}\n\n\n// iq's ambient occlusion\nfloat calcAO(vec3 p, vec3 n)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nfloat trace(vec3 ro, vec3 rd, out vec2 p, out float pint)\n{\n    float depth = MIN_TRACE_DIST;\n    float dist;\n    vec3 pos;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++)\n    {\n        pos = ro + rd * depth;\n        dist = map(pos);\n        if (dist < PRECISION || depth >= FAR)\n            break;\n        depth += dist;\n    }\n    if (b_parabolic)\n    {\n        if (b_apply)\n            pos /= dot(pos, pos);\n\n        p = pos.xz;\n        trans_parabolic(pos.xz);\n        pos.xz = grid2d(pos.xz, vec2(polar_grid.x / 2.0));\n        pint = getIntensity1(pos.xz);\n    }\n    else\n    {\n        applyMobius(pos);\n        p = pos.xz;\n        if (b_hyperbolic) trans_hyperbolic(pos.xz);\n        if (b_elliptic)   trans_elliptic(pos.xz);\n        pos.xz = polarGrid(pos.xz, polar_grid);\n        pint = getIntensity2(pos.xz);\n    }\n    return depth;\n}\n\n// ACES tone mapping\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 tonemap(vec3 color)\n{\n    const float A = 2.51;\n    const float B = 0.03;\n    const float C = 2.43;\n    const float D = 0.59;\n    const float E = 0.14;\n    return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\n\nconst int CHAR_1 = 49;\nconst int CHAR_2 = 50;\nconst int CHAR_3 = 51;\nconst int CHAR_4 = 52;\n\n// https://www.shadertoy.com/view/lsXGzf\nbool keypress(int code) \n{\n\treturn texelFetch(iChannel0, ivec2(code,2), 0).x != 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    b_apply = !keypress(CHAR_1);\n    b_elliptic = !keypress(CHAR_2);\n    b_hyperbolic = !keypress(CHAR_3);\n    b_riemann = keypress(CHAR_4);\n\n    b_parabolic = !(b_elliptic || b_hyperbolic);\n    b_loxodromic = b_elliptic && b_hyperbolic;\n    vec3 ro = vec3(-2.0, 4.0, 6.0);\n    vec3 lookat = vec3(0.0, 0.6, 0.0);\n    //ro.xz = rot2d(ro.xz, iTime*0.3);\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    vec3 tot = vec3(0);\n    vec3 lp = ro + vec3(.2, .8, -0.2);\n    \n\n    for (int ii = 0; ii < AA; ii++)\n    {\n        for (int jj = 0; jj < AA; jj++)\n        {\n            vec2 offset = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (fragCoord + offset) / iResolution.xy;\n            uv = 2.0 * uv - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 rd = normalize(uv.x * r + uv.y * u + 4.0 * f);\n            vec2 p;\n            float pint;\n            float t = trace(ro, rd, p, pint);\n            vec3 col = vec3(0);\n            if (t >= 0.0)\n            {     \n                vec3 ocol = tonemap(4.0 * getColor(p, pint));\n                vec3 pos = ro + rd * t;\n                vec3 nor = getNormal(pos);\n                vec3 ld = lp - pos;\n                float dist = max(length(ld), 0.001);\n                ld /= dist;\n                float at = 2.2 / (1. + dist*.1 + dist*dist*.05);\n                float ao = calcAO(pos, nor);\n                float sh = softShadow(pos, ld, 0.04, dist, 8.);\n\n                float diff = clamp(dot(nor, ld), 0.0, 1.0);\n                float spec = max( 0.0, dot( reflect(-ld, nor), -rd));\n\t            spec = pow(spec, 50.0);\n                col += diff * 2.5 * ocol + vec3(0.6, 0.8, 0.8) * spec * 2.;\n                col *= ao * sh * at;\n            }\n            if(t >= FAR)\n                lp = normalize(lp - ro - rd*FAR);\n\n            vec3 bg = mix(vec3(.5, .7, 1), vec3(1, .5, .6), .5 - .5*lp.y) * 1.3;\n            col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-2., t));\n            tot += col;\n            \n        }\n    }\n    tot /= float(AA * AA);\n    fragColor = vec4(sqrt(clamp(tot, 0., 1.)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wsKBW1","date":"1607445143","viewed":2085,"name":" Impossible Aperiodic Tilings","description":"Draw aperiodic rhombus tiling using de Bruijn's algebraic approach.\n\"Aperiodic\" means the tiling has no translation symmetry.\nAdd some Escher style decorations to make it look impossible.\nQuality is better at full screen mode.","likes":56,"published":"Public API","usePreview":0,"tags":["escher","tiling","rhombus","aperiodic","quasicrystals","debruijn"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nAperiodic tiling using de Bruijn's algebraic approach, Zhao Liang.\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis shader was motivated by Greg Egan's JavaScript applet at\n\nhttp://gregegan.net/APPLETS/02/02.html\n\nThanks Greg for explaining his idea to me and the comments in his code.\nI also learned a lot from Shane's excellent examples.\n\nHere is a brief overview of the procedure used in this program,\nusing N=5 as an example.\n\n1. We choose the five fifth roots of unity as grid directions.\nEach direction has a family of grid lines orthogonal to it,\nwith unit spacing between adjacent lines.\n\n2. We choose five real values to shift each grid along its direction.\n\n3. Any intersection point P of two grid lines can be identified by four\nintegers (r, s, kr, ks), where P is the intersection of the kr-th line\nin the r-th grid and the ks-th line in the s-th grid. It must hold that\n0 <= r < s < 5, and kr and ks can be any pair of integers.\n\n4. Each intersection point corresponds to a unique rhombus in the final tiling.\nNote that this rhombus does not necessarily contain P, but rather a\ntransformed version of P.\n\n5. For each pixel uv, we perform a lengthy computation to determine which\nrhombus its transformed position lies in.\n\n6. We then color the rhombus according to its shape, position, ..., whatever you\nwant.\n\n7. In addition, we draw a tunnel in each face and randomly flip the tunnel to\ncreate some cubes that appear impossible. Note that this is different from\nEgan's applet, where he carefully chose fixed flips for each rhombus to make\nevery cube look impossible. Our random flips only make some cubes look\nimpossible.\n\nFor a detailed explanation of the procedure used in this program, please refer\nto\n\n\"Algebraic theory of Penrose's non-periodic tilings of the plane\"\n\nby N.G. de Bruijn, or\n\n\"Aperiodic Order, Volume 1\" by Baake M., Grimm U., and Penrose R.\n\nPlease feel free to offer any suggestions.\n*/\n\n// If you want some cube faces are closed and draw a cross bar on them\n#define SOME_CLOSED_FACES\n\n// dimension of the grids, N=5 is the (generalized) Penrose pattern\nconst int N = 5;\n\n// control hole size\nconst float hs = 3.33;\n\n// N real numbers for the shifts of the grids.\nfloat[N] shifts;\n\n// directions of the grids, will be initialized later\nvec2[N] grids;\n\nstruct Rhombus {\n    // r, s for the r-th and s-th grids.\n    int r;\n    int s;\n\n    // kr, ks for the lines in the two grids\n    float kr;\n    float ks;\n\n    // center and vertices of the rhombus\n    vec2 cen;\n    vec2[4] verts;\n\n    // vertices of the tunnels, each tunnel contains two pieces.\n    vec2[4] inset1;\n    vec2[4] inset2;\n};\n\n#define PI 3.141592653\n\n// initialize the grid directions, for N = 5 they are the five fifth roots of\n// unity\nvoid init_grids() {\n    float FN = float(N), theta;\n    for (int k = 0; k < N; k++) {\n        theta = (N % 2 == 0) ? PI / FN * float(k) : PI / FN * float(k) * 2.;\n        grids[k] = vec2(cos(theta), sin(theta));\n        // for N=5 (0.2, 0.2, 0.2, 0.2, 0.2) gives the classical Penrose tiling.\n        // set all shifts to 0.5 will give the star pattern which has ten thin\n        // rhombus around a vertex hence is non-Penrose. shifts[k] = 0.5;\n        shifts[k] = fract(iTime / 10.) + 1. / (float(k) + 1.);\n    }\n}\n\n// distance from a 2d point p to a 2d segment (a, b)\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n    vec2 v = b - a;\n    p -= a;\n    float t = clamp(dot(p, v) / dot(v, v), 0., 1.);\n    return length(p - t * v);\n}\n\n// iq's hash function, for randomly flip the tunnels and open/closed faces\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(141.13, 289.97))) * 43758.5453);\n}\n\nfloat cross_prod(vec2 p, vec2 q) {\n    return p.x * q.y - p.y * q.x;\n}\n\n// signed distance function to a polygon using winding number\nfloat sdPoly4(in vec2 p, in vec2[4] verts) {\n    float d = dot(p - verts[0], p - verts[0]);\n    float s = 1.0;\n    for (int i = 0, j = 3; i < 4; j = i, i++) {\n        vec2 e = verts[j] - verts[i];\n        vec2 w = p - verts[i];\n        vec2 b = w - e * clamp(dot(w, e) / dot(e, e), 0., 1.);\n        d = min(d, dot(b, b));\n\n        bvec3 cond = bvec3(p.y >= verts[i].y, p.y<verts[j].y, cross_prod(e, w)> 0.);\n        if (all(cond) || all(not(cond)))\n        s *= -1.0;\n    }\n    return s * sqrt(d);\n}\n\n// project a vector p to the k-th grid, note each grid line is shifted so we\n// need to add the corresponding shifts.\nfloat project_point_grid(vec2 p, int k) {\n    return dot(p, grids[k]) + shifts[k];\n}\n\n// find the vertices of the rhombus corresponding to the intersection point P,\n// where P is the intersection of the kr-th line and ks-th line in the r/s\n// grids.\nvoid solve_rhombus_verts(int r, int s, float kr, float ks, out vec2[4] verts) {\n    vec2 P = grids[r] * (ks - shifts[s]) - grids[s] * (kr - shifts[r]);\n    P = vec2(-P.y, P.x) / grids[s - r].y;\n    vec2 sum = kr * grids[r] + ks * grids[s];\n    for (int k = 0; k < N; k++) {\n        if ((k != r) && (k != s))\n        sum += grids[k] * ceil(project_point_grid(P, k));\n    }\n    verts[0] = sum;\n    verts[1] = sum + grids[r];\n    verts[3] = sum + grids[s];\n    verts[2] = verts[1] + grids[s];\n}\n\n// this is the \"continous\" version of de Bruijn's transformation that maps a\n// pixel to its position in the tiling.\nvec2 debruijn_transform(vec2 p) {\n    vec2 sum = vec2(0.0);\n    for (int k = 0; k < N; k++) {\n        sum += grids[k] * project_point_grid(p, k);\n    }\n    return sum;\n}\n\n// a bit lengthy computation to find after the transformation p --> q,\n// which rhombus q lies in. we simply iterate over all possible combinations:\n// for each pair 0 <= r < s < 5, we find (kr, ks) so that p lies in the (kr,\n// kr+1) strip in the r-th grid and (ks, ks+1) strip in the s-th grid, and check\n// which of the four rhombus (r, s, kr, ks), (r, s, kr, ks+1), (r, s, kr+1, ks),\n// (r, s, kr+1, ks+1) contains q. Sadly due to float rounding errors, we have to\n// search from (r, s, kr-1, ks-1).\nRhombus get_mapped_rhombus(vec2 p, out vec2 q) {\n    q = debruijn_transform(p);\n    Rhombus rb;\n    float kr, ks;\n    vec2[4] verts;\n    float[N] pindex;\n    for (int i = 0; i < N; i++) {\n        pindex[i] = floor(project_point_grid(p, i));\n    }\n    for (int r = 0; r < N - 1; r++) {\n        for (int s = r + 1; s < N; s++) {\n            for (float dr = -1.; dr < 2.; dr += 1.0) {\n                for (float ds = -1.; ds < dr + 2.; ds += 1.0) {\n                    kr = pindex[r] + dr;\n                    ks = pindex[s] + ds;\n                    solve_rhombus_verts(r, s, kr, ks, verts);\n                    if (sdPoly4(q, verts) < 0.) {\n                        rb.r = r, rb.s = s, rb.kr = kr, rb.ks = ks;\n                        rb.verts = verts;\n                        rb.cen = (verts[0] + verts[1] + verts[2] + verts[3]) / 4.0;\n                        return rb;\n                    }\n                }\n            }\n        }\n    }\n}\n\n// For each tunnel in the face, we want it to slant by a best-looking direction.\n// We simply choose a grid line direction that matches best with the diagonal\n// line of this face. This is proposed by Greg Egan.\nvec2 get_best_dir(int r, int s, vec2 v) {\n    float maxdot = 0.;\n    float inn = 0.;\n    vec2 result;\n    for (int k = 0; k < N; k++) {\n        if ((k != r) && (k != s)) {\n            inn = dot(grids[k], v);\n            if (abs(inn) > maxdot) {\n                maxdot = abs(inn);\n                result = (inn > 0.) ? grids[k] : -grids[k];\n            }\n        }\n    }\n    return result;\n}\n\n// Compute the vertices of the two pieces of the tunnel\nvoid get_tunnels(inout Rhombus rb) {\n    vec2 gr = grids[rb.r] / 2.;\n    vec2 gs = grids[rb.s] / 2.;\n    float cA = dot(gr, gs);\n    float sgn = sign(cA);\n    if (sgn == 0.0)\n    sgn = sign(hash21(rb.cen) - 0.5);\n    vec2 xy = (-gr + sgn * gs) / 2.;\n    vec2 XY = get_best_dir(rb.r, rb.s, xy);\n\n    XY /= 7.0;\n\n    // the first piece\n    rb.inset1[0] = (gr - sgn * gs) / 2.;\n    rb.inset1[1] = rb.inset1[0] + XY;\n    rb.inset1[3] = (sgn * gr + gs) / 2.;\n    vec2 v1 = rb.inset1[0] + rb.inset1[3];\n    vec2 v2 = rb.inset1[3] - rb.inset1[0];\n    float t = cross_prod(XY, v2) / cross_prod(v1, v2);\n    rb.inset1[2] = rb.inset1[3] + t * v1;\n    // the other piece. it shares two vertices with the first one.\n    rb.inset2[0] = rb.inset1[0];\n    rb.inset2[1] = rb.inset1[1];\n    rb.inset2[3] = -rb.inset1[3];\n\n    v1 = rb.inset2[0] + rb.inset2[3];\n    v2 = rb.inset2[3] - rb.inset2[0];\n    t = cross_prod(XY, v2) / cross_prod(v1, v2);\n    rb.inset2[2] = rb.inset2[3] + t * v1;\n}\n\nfloat getCross(vec2 p, Rhombus rb) {\n    vec2 vA = (rb.verts[0] + rb.cen) / 2.;\n    vec2 vB = (rb.verts[1] + rb.cen) / 2.;\n    vec2 vC = (rb.verts[2] + rb.cen) / 2.;\n    vec2 vD = (rb.verts[3] + rb.cen) / 2.;\n    float dcross = dseg(p, vA, vB);\n    dcross = min(dcross, dseg(p, vB, vC));\n    dcross = min(dcross, dseg(p, vC, vD));\n    dcross = min(dcross, dseg(p, vD, vA));\n    dcross = min(dcross, dseg(p, vA, vC));\n    dcross = min(dcross, dseg(p, vB, vD));\n    return dcross;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    // zoom factor\n    float zoom = iResolution.y > 600. ? 4.5 : 3.2;\n    zoom *= 5. / float(N);\n    uv *= zoom;\n\n    float sf = 2. / clamp(iResolution.y, 360., 600.);\n\n    init_grids();\n    // p is transformed position of uv, vary its position by translating along\n    // a fixed direction.\n    vec2 p;\n    Rhombus rb = get_mapped_rhombus(uv + iTime * 0.2, p);\n    get_tunnels(rb);\n\n    // relative position of the transformed position with respect to rhombus\n    // center\n    vec2 q = p - rb.cen;\n\n    // assign a random number to each face, we let this random number vary by time\n    // so the face can also vary its tunnel directions, openness, etc.\n    float rnd = hash21(rb.cen);\n    rnd = sin(rnd * 6.283 + iTime) * .5 + .5;\n\n    float blink = smoothstep(0.15, .3, rnd);\n    vec3 col = .5 + .45 * cos(6.2831 * rnd + vec3(0., 1., 2.) - .25);\n    vec3 col2 =\n    .5 + .45 * cos(6.2831 * dot(rb.cen, vec2(1.)) + vec3(2., 3., 1.) - .25);\n    col = mix(col, pow(col * col2, vec3(.65)) * 2., .25);\n    col = mix(col, col2.yxz, float(rb.r * rb.s) / float(N * N * 2) * blink);\n\n    // cA and sA are the cos/sin of the angle at vertice A\n    float cA = dot(grids[rb.r], grids[rb.s]);\n    float sA = sqrt(1. - cA * cA);\n\n    float dcen = dot(q, q) * .95;\n\n    if (rnd > .2) {\n        q.xy =\n        -q.xy; // randomly flip the tunnels to make some cubes look impossible\n        col *= max(1.25 - dcen, 0.);\n    } else {\n        col *= max(dcen + 0.55, 1.);\n    }\n\n    // distance to the boundary of the face\n    float dface = sdPoly4(p, rb.verts);\n\n    // distance to the face border\n    float dborder = max(dface, -(dface + sf * 4.));\n\n    // distance to the tunnel of the face\n    vec2 q1 = q * 4. / hs;\n    float dtunnel = min(sdPoly4(q1, rb.inset1), sdPoly4(q1, rb.inset2));\n\n    // distance to the hole of the face,\n    // we choose the size of the hole to half the width/height of the rhombus.\n    // note each rhombus has unit side length, so sA is twice the distance\n    // from the center to its four edges.\n    float dhole = dface + sA / hs;\n\n    float dcross = 1e5;\n\n#ifdef SOME_CLOSED_FACES\n    // really dirty, maybe should put into a function\n    if (abs(rnd - 0.5) > .495) {\n        dhole += 1e5;\n        dtunnel += 1e5;\n        dcross = min(dcross, getCross(p, rb));\n    }\n#endif\n\n    // shade the tunnels by the type of the rhombus\n    float shade;\n\n    float id = floor(hash21(vec2(float(rb.r), float(rb.s))) * float(N));\n\n    // qd is our shading direction\n    int ind = cA >= 0. ? 0 : 1;\n    float qd = dot(q, rb.cen - rb.verts[ind]);\n\n    shade = .7 - smoothstep(-sf * 2., sf * 2., -sign(rnd - .5) * qd) *\n    clamp(id / float(N), 0.2, 0.6);\n\n    // draw the face border, multiply a factor 0.9 makes the edge look more\n    // antialiased\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf * 2., dborder)) * 0.9);\n\n    // add a thin bounding box around the hole\n    col = mix(col, vec3(0),\n        (1. - smoothstep(0., sf * 4., abs(dface + sA / 8.))) * .5);\n\n    // draw the black hole\n    col = mix(col, vec3(0), (1. - smoothstep(-sf * 2., sf * 2., dhole)));\n\n    // shade the tunnels\n    col = mix(col, vec3(1),\n        (1. - smoothstep(-sf * 4., 0., dtunnel - sf * 4.)) * shade);\n\n    // redraw the border of the hole to fix some tiny artifacts\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf * 8., abs(dhole))));\n\n    // highlight the edges\n    col = mix(col, col * 1.5, (1. - smoothstep(sf * 6., sf * 12., dborder)) * .8);\n\n    // draw the crosses on solid faces\n    col = mix(col, vec3(0.), (1. - smoothstep(0., sf * 6., dcross)) * .5);\n\n    // adjust luminance of faces by their types\n    col *= min(id / float(N) + .7, 1.);\n\n    // draw hatch lines on the face to add some decorate pattern.\n    // we get line direction first\n    vec2 diag = (rb.verts[0] - rb.cen);\n    float dd = cA < 0. ? dot(q, diag) : dot(q, vec2(-diag.y, diag.x));\n\n    float hatch = clamp(sin(dd * 60. * PI) * 2. + .5, 0., 1.);\n    float hrnd = hash21(floor(q * 40.) + 0.73);\n    if (hrnd > 0.66)\n    hatch = hrnd;\n\n    // we dont't want the hatch lines to show on top of the hole and tunnel\n    if (dtunnel < 0.0 || dhole < 0.0)\n    hatch = 1.0;\n    col *= hatch * .25 + .75;\n\n    uv = fragCoord / iResolution.xy;\n    col *= pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .125) * .75 + .25;\n    fragColor = vec4(sqrt(max(col, 0.0)), 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"WdGBz3","date":"1607739529","viewed":3196,"name":"Boyd-Maxwell 2D circle packing","description":"Limit set of rank 4 hyperbolic Coxeter groups, drawn both on the boundary sphere and the stereo-projected plane.","likes":77,"published":"Public API","usePreview":0,"tags":["coxeter","tiling","hyperbolic","circlepacking","limitset"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nBoyd-Maxwell circle packings of hyperbolic Coxeter groups: rank 4/level 2 case\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor more information check the github repo:\n\n    https://github.com/neozhaoliang/Hyperbolic-Honeycombs\n\nRequired input:\n\nThe Coxeter diagram of a rank 4 Coxeter group G = <A, B, C, D>, with dihedral angles\nm_{s,t} in the order (AB, AC, AD, BC, BD, CD).\n\nNote:\n\n1. CD must be finite\n2. The triangle group <B, C, D> must be hyperbolic\n*/\n\n\n//If you see only a sphere and a small disk under it, try comment out this.\n// This is because by default the circle packing fills only the unit disk.\n\n//#define useMouseInvert\n\n//#define config      initLevel2Graph(4., 4., 4., 4., 4., 4.)\n#define config        initLevel2Graph(4., 2., inf, 4., 3., 3.)\n\n\nconst float sphereSize = 2.25;\n\nfloat sdSphere(vec3 p) { return length(p - vec3(0, 0, sphereSize)) - sphereSize; }\n\nfloat sdPlane(vec3 p) { return p.z; }\n\nvec2 rot2d(vec2 p, float a) { return p * cos(a) + vec2(-p.y, p.x) * sin(a); }\n\nvec3 colormap(int index, float t) {\n  float c = float(index) + 1.;\n  return .5 + .45 * cos(PI * pow(t, 0.3) * 1.6 * c + vec3(0, 1, 2));\n}\n\nvec3 getFloorColor(inout vec2 p) {\n    int index = -1;\n    int count = 0;\n    fold(p, count, index);\n    float lw = EdgeSize;\n    float dist = dist2Mirrors(p, lw);\n    float t = clamp(float(count + 1) / float(MaxIters + 1), 0., 1.);\n    vec3 col = colormap(index, t);\n    float aa = fwidth(dist) / 2.;\n    col = mix(col, vec3(0), 1. - smoothstep(lw - aa, lw + aa, dist));\n    return col;\n}\n\nvec2 sphereToPlane(vec3 p) {\n    float k = 2. * sphereSize / (2. * sphereSize - p.z);\n    return k * p.xy;\n}\n\nvec2 map(vec3 p) {\n    float d1 = sdSphere(p);\n    float d2 = sdPlane(p);\n    float id = (d1 < d2) ? 0.: 1.;\n    return vec2(min(d1, d2), id);\n}\n\n// standard scene normal\nvec3 getNormal(vec3 p) {\n    const vec2 e = vec2(0.001, 0.);\n    return normalize(\n        vec3(\n            map(p + e.xyy).x - map(p  - e.xyy).x,\n            map(p + e.yxy).x - map(p  - e.yxy).x,\n            map(p + e.yyx).x - map(p  - e.yyx).x\n            )\n        );\n}\n\n// get the signed distance to an object and object id\nvec2 raymarch(in vec3 ro, in vec3 rd)\n{\n    float t = MIN_TRACE_DIST;\n    vec2 h;\n    for(int i=0; i<MAX_TRACE_STEPS; i++)\n    {\n        h = map(ro + t * rd);\n        if (h.x < PRECISION * (t*0.125+1.))\n            return vec2(t, h.y);\n\n        if (t > MAX_TRACE_DIST)\n            break;\n\n        t += h.x;\n    }\n    return vec2(-1.0);\n}\n\nfloat calcOcclusion(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.85;\n    }\n    return clamp(1.0 - occ, 0.2, 1.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) {\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 30; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, k * h / t);\n        t += clamp(h, 0.001, 0.1);\n        if (h < 0.0001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0., 1.0);\n}\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, vec3 lp, vec3 basecol) {\n    vec3 col = vec3(0.0);\n    vec3 ld = lp - pos;\n    float lDist = max(length(ld), .001);\n    ld /= lDist;\n    float ao = calcOcclusion(pos, nor);\n    float sh = softShadow(pos+0.001*nor, ld, 0.01, lDist, 32.);\n    sh = min(sh + ao * 0.2, 1.);\n    \n    float diff = clamp(dot(nor, ld), 0., 1.);\n    float atten = 1. / (1. + lDist * 0.01 + lDist * lDist * 0.002);\n    float spec = pow(max( dot( reflect(-ld, nor), -rd ), 0.0 ), 20.);\n    float fres = clamp(1.0 + dot(rd, nor), 0.0, 1.0);\n    col += basecol * (diff + .5 * ao);\n    col += basecol * vec3(.8, 1., 0.3) * spec * 8.;\n    col += basecol * vec3(1.2, 1., .8) * fres * fres * 6.;\n    col *= atten * sh * ao;\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 scenecol = vec3(0.);\n\n    config;\n\n    vec3 camera = vec3(0.1, 10., 10.);\n    vec3 lp =  vec3(1., 0., 20.);\n    camera.xy = rot2d(camera.xy, iTime*0.3);\n    vec3 lookat  = vec3(0.);\n    vec3 up = vec3(0, 0, 1);\n    vec3 forward = normalize(lookat - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n\n// antialiasing loop\n\n    for(int ii=0; ii<AA; ii++) {\n        for(int jj=0; jj<AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * fragCoord + o - iResolution.xy) / iResolution.y;\n            vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);\n            vec2 res = raymarch(camera, rd);\n            float t = res.x;\n            float id = res.y;\n            vec3 pos = camera + t * rd;\n\n            vec3 col;\n            vec2 p0;\n            vec3 nor;\n\n            // the sphere is hit\n            if (id == 0.) {\n                nor = normalize(pos - vec3(0, 0, sphereSize));\n                p0 = sphereToPlane(pos);\n            }\n            \n            // the plane is hit\n            else if (id == 1.) {\n                nor = vec3(0, 0, 1);\n                p0 = pos.xy;\n            }\n#ifdef useMouseInvert      \n            vec2 mouse = (iMouse.xy-2.*iResolution.xy)/iResolution.y;\n            if (iMouse.z == 0.)\n                mouse = vec2(1.5, 1.5);\n            mouse = rot2d(mouse, iTime*0.1);\n            float k = 1./L2(mouse);\n            vec2 invCtr = k * mouse;\n            float tt = (k - 1.) / L2(p0 -invCtr);\n            p0 = tt*p0 + (1. - tt)*invCtr;\n            p0.x = -p0.x;\n#endif\n            vec3 basecol = getFloorColor(p0);\n            col = getColor(camera, rd, pos, nor, lp, basecol);\n            col *= max(0.0, min(1.1, 120. / dot(pos,pos)) - 0.1);\n            scenecol += col;\n        }\n    }\n    scenecol /= (float(AA) * float(AA));\n    fragColor = vec4(sqrt(clamp(scenecol, 0.0, 1.0)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Vinberg convention for edge labels\n#define inf                 1.0\n#define MaxIters            500\n#define AA                  3\n#define PI                  3.141592653\n#define L2(x)               dot(x, x)\n#define Hyperbolic          -1.0\n#define Euclidean           0.\n#define Spherical           1.\n#define MAX_TRACE_STEPS     500\n#define MIN_TRACE_DIST      0.001\n#define MAX_TRACE_DIST      100.0\n#define PRECISION           0.0001\n#define EdgeSize            0.005\n\n// Move a vertex of Euclidean type (if there is any) to infinity,\n// so the pattern tiles the entire plane\n#define moveVertexToInf\n\n// 4x4 Cartan matrix for the Coxeter group\nmat4 cartan;\n\n// geometry type of each vertex in the Coxeter diagram\n// -1 for hyerbolic, 0 for Euclidean, 1 for spherial\nvec4 vertexType;\n\n// coordinates of a Euclidean vertex\nvec2 euclideanVertex;\n\n// whether there is an Euclidean vertex, i.e. if this vertex is removed,\n// the remain diagram is affine\nbool hasEuclideanVertex;\n\n// compute cos(PI / x), for x = inf this is just inf\nfloat dihedral(float x) {\n    return x == inf ? inf : cos(PI / x);\n}\n\n// complex multiplication\nvec2 cmul(vec2 p, vec2 q) { return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x); }\n\n\n// complex division\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\n// For circles |x - cen| = r.\n// For lines (x, cen) = r. \n// If inverted then the inside/outside of the sphere is exchanged.\nstruct Ball {\n    vec2 cen;\n    float r;\n    bool isplane;\n    bool invert;\n};\n\n// realBalls corresponde to the normalized real weights omega_i\n// virtualBalls corresponde to the simple roots alpha_i\n// inversions about the virtualBalls (i.e. reflections about alpha_i) generate\n// the Coxeter group W, applying W act on realBalls give the full ball-packing.\nBall[4] realBalls, virtualBalls;\n\nBall defaultBall() { return Ball(vec2(0), 1., false, false); }\n\nBall from_line(vec2 n) { return Ball(n, 0., true, false); }\n\nBall from_sphere(vec2 cen, float r) { return Ball(cen, r, false, false); }\n\nvoid invertBall(inout Ball B) { B.invert = !B.invert; }\n\n// the inside of the sphere has positive distance\nfloat sdBall(vec2 p, Ball B) {\n    if (B.isplane) {\n        return dot(p, B.cen);\n    }\n    float k = length(p - B.cen) - B.r;\n    return B.invert ? k : -k;\n}\n\nbool insideBall(vec2 p, Ball B) { return sdBall(p, B) > 0.; }\n\n// compute the vertex type of each vertex.\n// for each vertex in the Coxeter diagram, its vertex type has the same type as the\n// triangle group G given by the remaining three vertices.\n// This can be checked from the determinant of the leading minors of the Cartan matrix.\nvoid checkCartan(mat4 M) {\n    const float e = 0.001;\n    float det;\n    det = determinant(mat3(M[1].yzw, M[2].yzw, M[3].yzw));\n    vertexType.x = step(-e, det) + step(e, det) - 1.;\n    \n    det = determinant(mat3(M[0].xzw, M[2].xzw, M[3].xzw));\n    vertexType.y = step(-e, det) + step(e, det) - 1.;\n\n    det = determinant(mat3(M[0].xyw, M[1].xyw, M[3].xyw));\n    vertexType.z = step(-e, det) + step(e, det) - 1.;\n\n    det = determinant(mat3(M[0].xyz, M[1].xyz, M[2].xyz));\n    vertexType.w = step(-e, det) + step(e, det) - 1.;\n}\n\n\n// try to reflect a point p to the inside of a ball\nbool try_reflect(inout vec2 p, Ball B, inout int count) {\n    if (insideBall(p, B))\n        return true;\n    vec2 cen = B.cen;\n    float r = B.r;\n    if (B.isplane) {\n        p = p - 2. * dot(p, cen) * cen;\n    }\n    else {\n        p = (r * r) / L2(p - cen) * (p - cen) + cen;\n    }\n    count += 1;\n    return false;\n}\n\n\n/*\nGet the intersection of three given balls.\nB3(n,0) is a line through the origin, B1 and B2 are circles.\nEquations:\n    (a, n) = 0\n    |a - a1|^2 = r1^2\n    |a - a2|^2 = r2^2\n\nLet d = (-n.y, n.x), then a = k * d for some real k.\nSubstitute a into the last two equations:\n    k = (|a1|^2 - |a2|^2 - r1^2 + r2^2) / 2(d, a1 - a2)\n*/\nvec2 getIntersection(Ball B1, Ball B2, Ball B3) {\n    vec2 d = vec2(-B3.cen.y, B3.cen.x);\n    float r1 = B1.r, r2 = B2.r;\n    float k = (L2(B1.cen) - L2(B2.cen) - r1 * r1 + r2 * r2) /\n              (2. * dot(d, B1.cen - B2.cen));\n    return k * d;\n}\n\n/*\nSolve the ball B(a,r) that orthogonally intersects three given balls.\nB3(n, 0) is a line through the origin, B1 and B2 are circles.\nEquations:\n    (a, n) = 0\n    |a - a1|^2 = r1^2 + r^2\n    |a - a2|^2 = r2^2 + r^2\n\nLet d = (-n.y, n.x), then a = k * d for some real k.\nSubstitute into the last two equations:\n\n    k^2 + (a1, a1) - 2k(d, a1) = r1^2 + r^2\n    k^2 + (a2, a2) - 2k(d, a2) = r2^2 + r^2\n\nSolve for k:\n\n    k = (|a1|^2 - |a2|^2 - r1^2 + r2^2) / 2(d, a1 - a2)\n*/\nBall solveBall(Ball B1, Ball B2, Ball B3) {\n    vec2 d = vec2(-B3.cen.y, B3.cen.x);\n    float r1 = B1.r, r2 = B2.r;\n    float k = (L2(B1.cen) - L2(B2.cen) - r1 * r1 + r2 * r2) / (2. * dot(B1.cen - B2.cen, d));\n    vec2 a = k * d;\n    float r = sqrt(L2(a - B1.cen) - r1 * r1);\n    return from_sphere(a, r);\n}\n\n\nfloat sdistanceToBall(vec2 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec3(p, 1), vec3(B.cen, B.r));\n        return k;\n    }\n    else {\n        float k = length(p - B.cen) - B.r;\n        return B.invert ? -k : k;\n    }\n}\n\n\nvoid initLevel2Graph(float a0, float a1, float a2, float a3, float a4, float a5) {\n    Ball B0, B1, B2, B3;\n    float c01 = dihedral(a0);\n    float c02 = dihedral(a1);\n    float c03 = dihedral(a2);\n    float c12 = dihedral(a3);\n    float c13 = dihedral(a4);\n    float c23 = dihedral(a5);\n\n    cartan = mat4(  1, -c01, -c02, -c03,\n                 -c01,    1, -c12, -c13,\n                 -c02, -c12,    1, -c23,\n                 -c03, -c13, -c23,    1);\n\n    checkCartan(cartan);\n\n    float s23 = sqrt(1. - c23 * c23);\n    B2 = from_line(vec2(1, 0));\n    B3 = from_line(vec2(-c23, s23));\n\n    /* Equations for the virtual ball B1(x, y, r)\n    Angle with B2: \n        dot((x, y), (1, 0)) / r = c12\n        x = k1 * r\n    Angle with B3:\n        dot((x, y), (-c23, s23)) / r = c13\n        y = k2 * r\n    Orthogonal to the real ball (unit circle) C0:\n        x^2 + y^2 = r^2 + 1\n        r = 1 / sqrt(k1^2 + k2^2 - 1)\n    */\n    float k1 = c12;\n    float k2 = (c13 + c23 * c12) / s23;\n    float r = 1. / sqrt(k1 * k1 + k2 * k2 - 1.);\n    B1 = from_sphere(vec2(k1 * r, k2 * r), r);\n    invertBall(B1);\n\n    /* Equations for the virtual ball B0(x, y, r)\n    Angle with B2:\n        dot((x, y), (1, 0)) / r = c02\n        x = k1 * r\n    Angle with B3:\n        dot((x, y), (-c23, s23)) / r = c03\n        y = k2 * r\n    Angle with B1:\n        r^2 + r1^2 - |(k1,k2)r - (x1,y1)|^2\n        --------------------------------  = -c01\n                2 * r * r1\n\n        r^2 + r1^2 - |(k1,k2)|^2*r^2 + 2r*dot((k1,k2), (x1,y1)) - |(x1,y1)|^2 = -2r*r1*c01\n\n        (|(k1,k2)|^2 - 1) * r^2 - 2r * (dot((k1,k2), (x1,y1)) + r1*c01) + |(x1,y1)|^2 - r1^2 = 0\n    \n    This is a quadratic equaiton of r, choose the smaller one. \n    */\n    k1 = c02;\n    k2 = (c03 + c23 * c02) / s23;\n    float a = k1 * k1 + k2 * k2 - 1.;\n    float b = dot(vec3(k1, k2, c01), vec3(B1.cen, B1.r));\n    float c = L2(B1.cen) - B1.r * B1.r;\n    r = b / a - sqrt(b * b - a * c) / a;\n    B0 = from_sphere(vec2(k1 * r, k2 * r), r);\n    invertBall(B0);\n\n    virtualBalls = Ball[4] (B0, B1, B2, B3);\n\n    for (int k = 0; k < 4; k++) {\n        realBalls[k] = defaultBall();\n    }\n    invertBall(realBalls[0]);\n\n    if (vertexType.y == Hyperbolic) {\n        float r = sqrt(L2(B0.cen) - B0.r * B0.r);\n        realBalls[1] = from_sphere(vec2(0), r);\n    }\n    if (vertexType.z == Hyperbolic) {\n        realBalls[2] = solveBall(B0, B1, B3);\n    }\n    if (vertexType.w == Hyperbolic) {\n        realBalls[3] = solveBall(B0, B1, B2);\n    } \n    \n    if (vertexType.y == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = vec2(0);\n        return;\n    }\n\n    if (vertexType.z == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = getIntersection(B0, B1, B3);\n        return;\n    }\n\n    if (vertexType.w == Euclidean) {\n        hasEuclideanVertex = true;\n        euclideanVertex = getIntersection(B0, B1, B2);\n        return;\n    }\n}\n\n\nvec2 applyMobius(vec2 p) {\n    if (hasEuclideanVertex) {\n        vec2 A = euclideanVertex;\n        vec2 B = vec2(0, 0);\n        vec2 C = vec2(1, 0);\n        vec2 D = vec2(4, 0);\n        p = cdiv(cmul(p, A) + B, cmul(C, p) + D);\n    }\n    return p;\n}\n\n\nvoid fold(inout vec2 p, inout int count, inout int index) {\n#ifdef moveVertexToInf\n    p = applyMobius(p);\n#endif\n    for (int i = 0; i < MaxIters; i++) {\n        bool found = true;\n        for (int k = 0; k < 4; k++) {\n            found = try_reflect(p, virtualBalls[k], count) && found;\n        }\n        if (found)\n            break;\n    }\n    for (int k = 0; k < 4; k++) {\n        if (vertexType[k] == Hyperbolic && insideBall(p, realBalls[k])) {\n            index = k;\n            break;\n    }\n  }\n}\n\nfloat dist2Mirrors(vec2 p, inout float lw) {\n    float d = 1e30;\n    for (int i = 0; i < 4; i++) {\n        d = min(d, abs(sdBall(p, virtualBalls[i])));\n    }\n    if (L2(p) > 1.) lw *= 3. * L2(p);\n    return d;\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"3sVBWV","date":"1608739422","viewed":765,"name":"Uniform 3D hyperbolic honeycombs","description":"Exploring the fun of hyperbolic geometry with hyperbolic honeycombs. Sorry for the low fps.\nThis is a somewhat simplified version of https://github.com/neozhaoliang/Hyperbolic-Honeycombs/","likes":12,"published":"Public API","usePreview":1,"tags":["geometry","honeycomb","tiling","hyperbolic","poincare","hyperboloid"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 postProcess(in vec3 col, in vec2 q) {\n    col = pow(clamp(col, 0.0, 1.0), vec3(1.0 / 2.2));\n    col = col * 0.6 + 0.4 * col * col * (3.0 - 2.0 * col); // contrast\n    col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);      // satuation\n    col *= 0.5 + 0.5 * pow(19.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y),\n                           0.7); // vigneting\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 tex = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 c = tex.rgb / tex.a;\n    c = postProcess(c, uv);\n    fragColor = vec4(c, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nCompact and paracompact Hyperbolic honeycombs in H3 space\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis program draws compact/paracompact uniform hyperbolic honeycombs in\nPoincaré's 3D ball model. For a complete list of available honeycombs see\n\n    \"https://en.wikipedia.org/wiki/Uniform_honeycombs_in_hyperbolic_space\"\n\nThanks @knighty for his fragmentarium code && help.\n\nSome math stuff:\n\n1. The 4D space R^4 is endowed with Minkowski inner product: for\n   p=(x1, y1, z1, w1) and q=(x2, y2, z2, w2), their \"hyperbolic dot\" is given by\n\n       hdot(p, q) := x1*y1 + x2*y2 * x3*y3 - x4*y4.\n\n   This inner product has Sylvester type (3, 1), the quadratic form is Q(p) = hdot(p, p).\n\n2. The hyperboloid are those vectors in R^4 with Q(p) = -1 (time-like). For those q with\n   Q(q) > 0 we call q space-like. The hyperboloid consists of two sheets: w > 0 and w < 0.\n\n3. The distance between two vectors p, q on the same sheet is given by\n\n       cosh(d(p, q)) = -hdot(p, q).\n\n4. Any geodesic line from a point p on the hyperboloid can be parameterized by\n\n       p*cosh(t) + v*sinh(t),\n\n   where v is a unit tangent vector at p (v must be space-like).\n\n5. A reflection across a plane with normal `n` is given by\n\n       ref(p) = p - 2 * hdot(p, n) * n.\n\n   Here p is time-like and n is space-like.\n\n6. We iteratively reflect a 4d point until it's in the fundamental domian, we get\n   its distance to the initial vertex/mirrors, then use knighty's magic formula to\n   estimate a `safe` distance that we can march in the 3d space. This is the most\n   intriguing part in the code.\n\n\n@mla has another honeycomb demo:\n\n    https://www.shadertoy.com/view/XddyR2\n\n@knighty's fragmentarium code:\n\n    https://github.com/3Dickulus/Fragmentarium_Examples_Folder/tree/master/Knighty%20Collection/Hyperbolic-tesselations-named\n    \n    \n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nList of available honeycombs\n\n\n***9 compact ones***\n\n(5, 2, 2, 3, 2, 5), (3, 2, 2, 5, 2, 3), (4, 2, 2, 5, 2, 3), (5, 2, 2, 4, 2, 3)\n\n  5       5            5            4       5        5       4\no---o---o---o    o---o---o---o    o---o---o---o    o---o---o---o\n\n\n(4, 2, 3, 3, 2, 4), (5, 2, 3, 3, 2, 4), (5, 2, 3, 3, 2, 5), (5, 2, 2, 3, 3, 2), (5, 2, 3, 3, 2, 3)\n\n                                             o\n  o---o        o---o        o---o        5  /       o---o\n4 |   | 4    5 |   | 4    5 |   | 5    o---o      5 |   |\n  o---o        o---o        o---o           \\       o---o\n                                             o     \n\n***paracompact ones***\n\n\n(6, 2, 2, 2, 3, 3), (3, 2, 2, 2, 3, 6), (6, 2, 2, 2, 3, 6), (3, 2, 2, 2, 6, 3)\n\n  6                        6        6       6            6   \no---o---o---o    o---o---o---o    o---o---o---o    o---o---o---o\nA   B   D   C    A   B   D   C    A   B   D   C    A   B   D   C\n\n\n(4, 2, 2, 2, 4, 4), (4, 2, 2, 2, 4, 3), (3, 2, 2, 2, 4, 4)\n\n  4   4   4        4   4                4   4               \no---o---o---o    o---o---o---o    o---o---o---o\nA   B   D   C    A   B   D   C    A   B   D   C\n\n\n(6, 2, 2, 2, 3, 5), (5, 2, 2, 2, 3, 6), (4, 2, 2, 2, 3, 6), (6, 2, 2, 2, 3, 4)\n\n\n  6       5        5       6        4       6        6       4\no---o---o---o    o---o---o---o    o---o---o---o    o---o---o---o\nA   B   D   C    A   B   D   C    A   B   D   C    A   B   D   C\n\n\n(4, 2, 2, 3, 4, 2), (4, 2, 4, 3, 2, 3), (4, 2, 4, 3, 2, 4), (3, 2, 6, 4, 2, 3), (3, 2, 6, 5, 2, 3)\n\n                 B\nA o              o            4\n  4\\           4/ \\       A o---o B    A o---o B    A o---o B\n    o---o    A o   o C    4 |   |      6 |   | 4    6 |   | 5\n  4/B   C      4\\ /       D o---o C    D o---o C    D o---o C\n  o              o            4\n  D              D\n\n     \n(3, 2, 2, 3, 3, 3), (3, 2, 3, 4, 3, 2), (3, 2, 3, 5, 3, 2)\n      \n      o C          o A          o A\nA   B/|      C 4 B/|      C 5 B/|\no---o |      o---o |      o---o |  \n     \\|           \\|           \\|  \n      o D          o D          o D\n     \n     \n(3, 2, 3, 3, 3, 3)\n\n    B\n    o    \n   /|\\\nA o | o C\n   \\|/\n    o\n    D\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n*/\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.141592654\n#define FAR 0.99995\n#define MAX_TRACE_STEPS 600\n#define FOV 1.0\n#define MAX_BOUNCES 1\n#define MAX_ITER    40\n\n// ===========\n// !Important:\n// ===========\n// Due to the way we construct the mirrors, the first three mirrors must have\n// spherical type, so for paracompact honeycombs like (4, 4, x), (6, 3, x), (3,\n// 6, x), you need to swap the order of the last two mirrors, i.e. use (4, 2, 2,\n// 2, 4, 4) or (6, 2, 2, 2, 3, x) in the Coxeter diagram. Suggested by @mla. For\n// diagram = (a, b, c, d, e, f) the corresponding Coxeter matrix is\n//\n// | 1  a  b  c |\n// | a  1, d  e |\n// | b  d  1  f |\n// | c  e  f  1 |\n//\nconst float[6] diagram = float[6](5., 2., 2., 3., 2., 4.);\n\n// active mirrors, 1 for active, 0 for non-active. This determines the position\n// of the initial vertex hence the truncation type of the honeycomb\nconst vec4 active_mirrors = vec4(1, 0, 0, 0);\n\n// size of the vertex and segments\n// you may need to adjust these for different scenes\nconst float vradius = 0.14;\nconst float sradius = 0.05;\nconst float cvr = cosh(vradius);\nconst float svr = sinh(vradius);\nconst float csr = cosh(sradius);\nconst float ssr = sinh(sradius);\n\nconst vec3 vertexColor = vec3(0.71, 0.65, 0.26);\nconst vec3 edgeColors[4] =\n    vec3[4](vec3(0.74, 0.62, 0.56), vec3(0.90, 0.91, 0.98),\n            vec3(0.72, 0.45, 0.2), vec3(0.32, 0.79, 0.36));\n\nfloat seed;\n\nfloat hash() {\n    float p = fract((seed++) * 0.1031);\n    p += (p * (p + 19.19)) * 3.;\n    return fract((p + p) * p);\n}\n\nvec2 hash2() { return vec2(hash(), hash()); }\n\n// normal vectors of the four mirrors\nmat4 M;\n\n// the initial vertex\nvec4 v0;\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n// Minkowski inner product with Sylvester type (3, 1)\nfloat hdot(in vec4 p, in vec4 q) { return dot(p.xyz, q.xyz) - p.w * q.w; }\n\n// normalize a time-like vector <v, v> < 0\nvec4 hnormalize(in vec4 p) { return p / sqrt(-hdot(p, p)); }\n\n// reflection about a plane with normal `n`\nfloat href(inout vec4 p, in vec4 n) {\n    float k = min(0., hdot(p, n));\n    p -= 2. * k * n;\n    return k;\n}\n\n// knighty's conservative distance conversion from hyperboloid to 3d flat\n// distance. for a 3d point p, it's lifted to a 4d point q on the hyperboloid:\n//\n//        2p     1+r^2\n// q = ( -----,  ----- ).\n//       1-r^2   1-r^2\n//\n// any point with distance d (ca=cosh(d),sa=sinh(d)) to q can be written as q*ca\n// + v*sa, wheren v is a unit tangent vector at q. We want v look like (sp, t).\n// so we have two unknowns (s, t) and two equations:\n\n// 1. s^2 * r^2 - t^2 = 1  (tangent vector must be space-like)\n// 2. 2*s/(1-r^2)*r^2 - (1+r^2)/(1-r^2)*t = 0 (definition of tangent vector at\n// q)\n\n// solve for s, t we have s = (1+r^2)/(r *(1-r^2)) and t = 2*r/(1-r^2).\n// hence the point we choose to project to 3d is\n// ([ 2*ca/(1-r^2) + (1+r^2)/(r *(1-r^2))*sa ] * p,\n//  [ ca*(1+r^2)/(1-r^2) + sa*2*r/(1-r^2) ])\nfloat knightyDD(float ca, float sa, float r) {\n    float x = 1. + r * r;\n    float y = 2. - x;\n    return (2. * r * ca + x * sa) / (x * ca + 2. * r * sa + y) - r;\n}\n\n// Given the Coxeter diagram and active mirrors (on/off),\n// get the normals of the reflection mirrors and the initial vertex.\n// Warning: due to the procedure used here, the first three mirrors must\n// have \"spherical\" type.\nvoid init(in float[6] diagram, in vec4 active_mirrors, inout mat4 M,\n          inout vec4 v0) {\n    // Cartan matrix of the Coxeter group:\n    // ( -1  c01  c02  c03)\n    // (c01   -1  c12  c13)\n    // (c02  c12   -1  c23)\n    // (c03  c13  c23   -1)\n    // cij = -cos(PI / (Coxeter label bewteen i-th and j-th mirror))\n    float c01 = -cos(PI / diagram[0]);\n    float c02 = -cos(PI / diagram[1]);\n    float c03 = -cos(PI / diagram[2]);\n    float c12 = -cos(PI / diagram[3]);\n    float c13 = -cos(PI / diagram[4]);\n    float c23 = -cos(PI / diagram[5]);\n\n    // find the reflection mirrors A, B, C, D.\n    // A can be always chosen as x-axis\n    vec4 A, B, C, D;\n    A = vec4(1, 0, 0, 0);\n\n    B = vec4(c01, sqrt(1. - c01 * c01), 0., 0.);\n\n    C = vec4(c02, 0, 0, 0);\n    C.y = (c12 - C.x * B.x) / B.y;\n    C.z = sqrt(\n        abs(1. - dot(C.xy, C.xy))); // avoid rounding error in paracompact case\n\n    D = vec4(c03, 0, 0, 0);\n    D.y = (c13 - D.x * B.x) / B.y;\n    D.z = (c23 - dot(D.xy, C.xy)) / C.z;\n    // !important: if you want to make the fundamental chamber lie in the upper\n    // sheet of the hyperboloid then you must use \"-\" sign here.\n    D.w = -sqrt(abs(dot(D.xyz, D.xyz) - 1.));\n\n    vec4 H = vec4(1, 1, 1, -1);\n    v0 = hnormalize(active_mirrors * inverse(mat4(H * A, H * B, H * C, H * D)));\n    M = mat4(A, B, C, D);\n}\n\n// if distance between p and q is a, C is a circle with radius VR centered at q,\n// then the distance from p to C is a - VR, hence\n// cosh(a - VR) = cosh(a)cosh(VR) - sinh(a)sinh(VR)\n// sinh(a - VR) = sinh(a)cosh(VR) - cosh(a)sinh(VR)\nfloat dVertex(vec4 p, float r) {\n    float ca = -hdot(p, v0);\n    float sa = 0.5 * sqrt(-hdot(p - v0, p - v0) * hdot(p + v0, p + v0));\n    return knightyDD(ca * cvr - sa * svr, sa * cvr - ca * svr, r);\n}\n\n// let pj = a * n + b * v0 be the projection of p onto the plane given by (v0,\n// n). take Minkowski dot with p - pj by v0 and n: (p, n) = a + b * (v0, n) (p,\n// v0) = a * (v0, n) - b then solve this 2x2 linear system.\nfloat dSegment(vec4 p, vec4 n, float r) {\n    float pn = hdot(p, n);\n    float pv = hdot(p, v0);\n    float nv = hdot(n, v0);\n    float det = -1.0 - nv * nv;\n    float a = (-nv * pv - pn) / det;\n    float b = (pv - pn * nv) / det;\n    vec4 pj = hnormalize(min(a, 0.) * n + b * v0);\n    float ca = -hdot(p, pj);\n    float sa = 0.5 * sqrt(-hdot(p - pj, p - pj) * hdot(p + pj, p + pj));\n    return knightyDD(ca * csr - sa * ssr, sa * csr - ca * ssr, r);\n}\n\n// fold a point p in 4d up to a given maximum of steps, return true if\n// we successfully transformed p into the fundamental domain else return false.\nbool fold(inout vec4 p, mat4 M) {\n    float k;\n    for (int i = 0; i < MAX_ITER; i++) {\n        k = 0.;\n        p.x = abs(p.x);\n        k += href(p, M[1]);\n        k += href(p, M[2]);\n        k += href(p, M[3]);\n        if (k == 0.)\n            return true;\n    }\n    return false;\n}\n\n// find the shortest distance from p to the 4 base edges\n// as well as the index of that edge.\nfloat dSegments(vec4 p, float r, inout float index) {\n    float d = 1.0;\n    for (int i = 0; i < 4; i++) {\n        float dseg = dSegment(p, M[i], r);\n        if (dseg < d) {\n            d = dseg;\n            index = float(i);\n        }\n    }\n    return d;\n}\n\nvec3 environment(vec3 dir) {\n    dir = normalize(dir);\n    float t = 0.5 * (dir.y + 1.0);\n    vec3 bg = mix(vec3(0.2, 0.3, 0.5), vec3(0.8, 0.9, 1.0), t);\n    return bg * 0.33 ;\n}\n\nvec2 map(vec3 p) {\n    float r = length(p);\n    vec4 q = vec4(2. * p, 1. + r * r) / (1. - r * r);\n    bool found = fold(q, M);\n    if (found) {\n        float id;\n        float dvert = dVertex(q, r);\n        float dedge = dSegments(q, r, id);\n        id = (dvert < dedge) ? 4. : id; // 4 for vertex, 0-3 for edges\n        return vec2(min(dvert, dedge), id);\n    }\n    return vec2(FAR, -1.0);\n}\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n    float t;\n};\n\nvec3 RayCurrentPt(Ray ray) { return ray.origin + ray.dir * ray.t; }\n\nvoid RayAdvance(inout Ray ray, float dist) { ray.t += dist; }\n\nRay RayReflect(Ray ray, vec3 normal) {\n    vec3 hit = RayCurrentPt(ray);\n    ray.dir = reflect(ray.dir, normal);\n    ray.origin = hit + normal * 1e-4;\n    ray.t = 0.0;\n    return ray;\n}\n\nvec2 trace(inout Ray ray) {\n    float dist = 0.0;\n    float eps = 1e-5;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        vec3 p = RayCurrentPt(ray);\n        dist = map(p).x;\n        RayAdvance(ray, dist);\n\n        if (dist < eps * (ray.t * 0.01 + 1.0)) {\n            for (int j = 0; j < 3; j++) {\n                RayAdvance(ray, -1.5 * eps); // Retreat a bit\n                p = RayCurrentPt(ray);\n                dist = map(p).x;\n            }\n            return vec2(ray.t, map(RayCurrentPt(ray)).y);\n        }\n        if (ray.t > FAR) {\n            break;\n        }\n    }\n    return vec2(FAR, -1.0);\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1e-4, 0);\n    float d1 = map(p + e.xyy).x, d2 = map(p - e.xyy).x;\n    float d3 = map(p + e.yxy).x, d4 = map(p - e.yxy).x;\n    float d5 = map(p + e.yyx).x, d6 = map(p - e.yyx).x;\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.75;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float tmin, float tmax, float k) {\n    const int maxShadeIterations = 24;\n    float res = 1.0;\n    float t = tmin;\n    vec3 rd = lp - ro;\n    rd /= max(length(rd), 1e-4);\n    for (int i = 0; i < maxShadeIterations; i++) {\n        float h = map(ro + rd * t).x;\n        t += clamp(h, 0.005, 0.2);\n        res = min(res, smoothstep(0., 1., k * h / t));\n        if (abs(h) < 0.0001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 lighting(vec3 pos, vec3 nor, vec3 rd, vec3 lp, vec3 basecol) {\n    vec3 col = vec3(0.0);\n    vec3 ld = lp - pos;\n    float lDist = max(length(ld), .001);\n    ld /= lDist;\n    float ao = calcAO(pos, nor);\n    float sh = softShadow(pos + 0.001 * nor, lp, 0.02, lDist, 32.);\n    float diff = clamp(dot(nor, ld), 0., 1.);\n    float atten = 1. / (1. + lDist + lDist * lDist * .5);\n\n    float spec = pow(max(dot(reflect(-ld, nor), -rd), 0.0), 32.);\n    col += basecol * diff;\n    col += basecol * vec3(.3, 0.8, 1.) * spec * 6.;\n    col *= ao * atten * sh;\n\n    return col;\n}\n\nvec3 render(Ray ray, vec3 lp) {\n    vec3 col = vec3(0);\n    vec3 throughput = vec3(1);\n\n    for (int i = 0; i < MAX_BOUNCES + 1; i++) {\n        vec2 res = trace(ray);\n        float t = res.x;\n        float id = res.y;\n\n        if (id < 0.0) {\n            col += throughput * environment(ray.dir);\n            break;\n        }\n\n        vec3 pos = ray.origin + ray.dir * t;\n        vec3 normal = calcNormal(pos);\n\n        vec3 basecol;\n        if (id < 4.)\n            basecol = edgeColors[int(id)];\n        else\n            basecol = vertexColor;\n\n        vec3 directLight = lighting(pos, normal, ray.dir, lp, basecol);\n        col += throughput * directLight;\n\n        throughput *= basecol * 0.5;\n\n        ray = RayReflect(ray, normal);\n\n        if (max(throughput.r, max(throughput.g, throughput.b)) < 0.05)\n            break;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    init(diagram, active_mirrors, M, v0);\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    seed = float((iFrame * 73856093) % 38069);\n\n    vec3 ro = vec3(0, 0, 0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 lookat = vec3(0, 0, -1);\n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n\n    vec3 lp = vec3(.3, 0.2, 0.1);\n\n    vec2 jittered = fragCoord + hash2() - .5;\n    vec2 uv = (2. * jittered - iResolution.xy) / iResolution.y;\n\n    vec3 rd = normalize(forward * FOV + uv.x * right + uv.y * up);\n    Ray ray = Ray(ro, rd, 0.0001);\n\n    vec3 col = render(ray, lp);\n    col = clamp(col, 0., 1.);\n    if (!isnan(col.x) && !isnan(col.y) && !isnan(col.z)) {\n        data += vec4(col, 1.);\n    }\n    if (iMouse.z > 0.) {\n        data *= 0.0;\n    }\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"3tccWf","date":"1609987591","viewed":2550,"name":"Uniform 3D Euclidean Honeycombs","description":"3D Wythoffian uniform honeycombs and their duals in Euclidean space, a flythrough version.","likes":35,"published":"Public API","usePreview":1,"tags":["3d","geometry","honeycomb","coxeter","group","tiling","euclidean","symmetry","lattice"]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nUniform honeycombs and their duals\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis program draws uniform honeycombs and their duals in 3D Euclidean space.\n\nYou can learn more about these honeycombs on the Wikipedia page for convex\nuniform honeycombs:\n\n    https://en.wikipedia.org/wiki/Convex_uniform_honeycomb\n\nThe main rendering procedure is based on the work of @shane:\n\n    https://www.shadertoy.com/view/4l2cD3.\n\nI particularly like the metallic effects in many of his examples.\n\nThe honeycomb data is taken from @mla's work at\n\n    https://www.shadertoy.com/view/WsfcRn.\n\nI'm also grateful to @mla for helpful discussions.\n\n@mla's code is a great reference for the general Wythoff construction,\nwhich saved me a lot of hard (and even boring) computations.\nIf you have any difficulty understanding this code, I recommend referring to\n@mla's version, as the ideas are the same.\n\nThe trickiest part of this program is to render the octagonal edges\n(or other prism-like shapes) instead of just cylinder edges.\nThis is due to the fact that Wythoff construction may change the distance\nbetwwen a point and the cell edges: In the Wythoff construction, one need to\nreflect a point P across the mirrors repeatly until it falls within a certain\nregion, known as the \"fundamental domain\". Say its final location in the\nfundamental domain is Q. In the cases that edges have prism-like shapes, the\ndistances d(P, edges) and d(Q, edges) may not be equal. This results in annoying\nartifacts in the final image. It took me 90% of the time to figure out how to\ntackle this. My solution is brute-force: just render more copies of the\nfundamental domain. This made the code look ugly and the program take a bit long\ntime to compile, but it worked and looked right in the end.\n*/\n\n// Honeycomb type. 0 for affine A3, 1 for affine B3, 2 for affine C3\n#define LATTICE 0\n\n// Barycentric coordinates of the initial vertex v0 in the fundamental\n// tetrahedron. This determines the truncation type of the honeycomb.\nconst vec4 T = vec4(0, 1, 1, 1);\n\nconst float tbsize = 0.055;\n\n// use another color style\n#define GOLD_STYLE\n\n// render the dual honeycomb?\n//#define DUAL\n\n// initial vertex\nvec3 v0;\n\n// M is the four reflection mirrors of the fundamental tetrahedron,\n// M_inv is the inverse of M.\nmat4 M, M_inv;\n\n// The four vertices of the fundamental tetrahedron and the four mirror images\n// of v0 about the four mirrors\nmat4x3 V, E;\n\n// object id\nvec3 objIDs;\n\nfloat glow;\n\nvec3 do_reflect(vec3 p, vec4 n) {\n    vec4 q = vec4(p, 1.);\n    return p - 2. * dot(q, n) * n.xyz;\n}\n\nvec3 rA(vec3 p) { return do_reflect(p, M[0]); }\nvec3 rB(vec3 p) { return do_reflect(p, M[1]); }\nvec3 rC(vec3 p) { return do_reflect(p, M[2]); }\nvec3 rD(vec3 p) { return do_reflect(p, M[3]); }\n\nvoid init() {\n\n    const float s = 0.70710678; // sqrt(2) / 2\n\n#if LATTICE == 0\n    // affine A3 lattice\n    //\n    // A     C\n    //  o---o\n    //  |   |\n    //  o---o\n    // D     B\n    M = mat4(vec4(-s, -s, 0, 2. * s), vec4(s, -s, 0, 0), vec4(0, s, -s, 0),\n             vec4(0, s, s, 0));\n\n    V = mat4x3(vec3(0, 0, 0), vec3(2, 0, 0), vec3(1, 1, -1), vec3(1, 1, 1));\n\n#elif LATTICE == 1\n    // affine B3 lattice\n    //          C\n    //         o\n    //     4  /\n    // A o---o B\n    //        \\\n    //         o\n    //          D\n    M = mat4(vec4(0, 0, 1, 0), vec4(0, s, -s, 0), vec4(s, -s, 0, 0),\n             vec4(-s, -s, 0, 2. * s));\n\n    V = mat4x3(vec3(1, 1, 1), vec3(1, 1, 0), vec3(2, 0, 0), vec3(0, 0, 0));\n\n// affine C3 lattice\n#else\n    //   4       4\n    // o---o---o---o\n    // A   B   C   D\n    M = mat4(vec4(0, 0, 1, 0), vec4(0, s, -s, 0), vec4(s, -s, 0, 0),\n             vec4(-1, 0, 0, 1));\n\n    V = mat4x3(vec3(0, 0, 0), vec3(1, 0, 0), vec3(1, 1, 0), vec3(1, 1, 1));\n\n#endif\n\n    M_inv = inverse(M);\n    vec4 v4 = T * M_inv;\n    v4 /= v4.w;\n    v0 = v4.xyz;\n    for (int i = 0; i < 4; i++) {\n        E[i] = v0 - 2. * dot(v4, M[i]) * M[i].xyz;\n    }\n}\n\n#define FAR 80.\n#define PI 3.141592654\n\nfloat sgn(float x) { return x > 0. ? 1. : -1.; }\n\n// Camera path as a function of time t.\n// I think it's unlikely to devise an universal path that flies through all\n// honeycombs without hitting the lattice.\nvec3 camPath(float t) { return vec3(t, 0, 0); }\n\n// A mirror is active if and only if the initial vertex v0 is not on it,\n// or equivalently, the barycentric coordinate with respect to this mirror is\n// non-zero.\nbool isActive(int k) { return T[k] != 0.0; }\n\n// try to reflect a point p about mirror with normal `n`, if p and the\n// fundamental domain are on the different sides of the mirror\nvec4 try_reflect(vec4 p, vec4 n, inout int flips) {\n    float k = dot(p, n);\n    if (k < 0.) {\n        flips += 1;\n        p.xyz -= 2. * k * n.xyz;\n    }\n    return p;\n}\n\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n// fold a point p into the fundamental domain.\n// we return the final position of p, but also track an intermediate state of p\n// for handling dual cases.\nvec3 fold(inout vec3 p, inout int flips) {\n\n    vec4 q;\n\n#if LATTICE == 0\n\n    p = mod(p + 2., 4.) - 2.;\n    q = vec4(p, 1);\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            q = try_reflect(q, M[j], flips);\n        }\n    }\n\n#elif LATTICE == 1\n\n    p = mod(p + 2., 4.) - 2.;\n    flips += int(p.x < 0.0) + int(p.y < 0.0) + int(p.z < 0.0);\n    p = abs(p);\n    q = vec4(p, 1);\n    for (int i = 0; i < 2; i++) {\n        q = try_reflect(q, M[3], flips);\n        q = try_reflect(q, M[2], flips);\n        q = try_reflect(q, M[1], flips);\n    }\n\n#else\n\n    p = mod(p + 1., 2.) - 1.;\n    flips += int(p.x < 0.0) + int(p.y < 0.0) + int(p.z < 0.0);\n    p = abs(p);\n    q = vec4(p, 1.);\n    q = try_reflect(q, M[1], flips);\n    q = try_reflect(q, M[2], flips);\n    q = try_reflect(q, M[1], flips);\n\n#endif\n\n    return q.xyz;\n}\n\n// Shane's tex3D function\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n) {\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n    vec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    return (tx * tx * n.x + ty * ty * n.y + tz * tz * n.z);\n}\n\n// I hacked this function to rotate any edge (a, b) to z-axis\nmat3 rotAxis(vec3 n) {\n    n = normalize(n);\n    vec3 x;\n    if (n.x == 0.)\n        x = vec3(1, 0, 0);\n    else\n        x = normalize(vec3(-n.y, n.x, 0.));\n    vec3 y = cross(n, x);\n    return mat3(x, y, n);\n}\n\nfloat tube(vec2 p, float sc, float rad) {\n    return max(max(p.x, p.y), (p.x + p.y) * sc) - rad;\n}\n\n// draw an edge with two ends at a, b.\nvec3 dSegment(vec3 p, vec3 a, vec3 b) {\n    // set local origin at middle point of the edge\n    vec3 m = (a + b) / 2.;\n    p -= m;\n    b -= m;\n    a -= m;\n    vec3 h = (b - a) / 2.;\n    float L = length(h); // length of half the edge\n\n    p = p * rotAxis(h); // reorient the edge along with z-axis\n    p = abs(p);\n\n    // the main tube, currently this has infinite length\n    float tb;\n    tb = tube(p.xy, 0.75, tbsize);\n\n    float band = 1e5;\n    float innerTb = 1e5;\n\n    // add a band of 1/4 length of the edge\n    band = max(tb - 0.0075, p.z - L / 4.);\n\n    // trick: rotate p to make two smaller tubes\n    // remove them from the main tube to make the holes\n    float psize = tbsize / 1.5;\n    vec2 peg = vec2(tube(p.xz, .64, psize), tube(p.yz, .64, psize));\n    float hole = min(peg.x, peg.y);\n\n    // use planes to cut the band\n    float dp1 = max(peg.x, p.y - tbsize - .0095);\n    dp1 = max(dp1, p.y - L / 4.);\n    float dp2 = max(peg.y, p.x - tbsize - .0095);\n    dp2 = max(dp2, p.x - L / 4.);\n    band = min(band, min(dp1, dp2));\n\n    // make holes on the main tube\n    tb = max(tb, -(hole - .015));\n\n    // cut the infinite main tube at the two ends\n    tb = max(tb, p.z - L);\n\n    // make holes on the band\n    band = max(band, -(hole + .0125));\n\n    // use sphere to create a fake inner tube\n    innerTb = length(p) - tbsize;\n\n    return vec3(tb, band, innerTb);\n}\n\n// This function is only used for handling dual of A3 honeycombs.\n// verts[4] are four non-adjacent vertices of a cube, so each face of the cube\n/// contains exactly one pair of vertices in verts[4].\n// For p a point in the cube, we find this pair of vertices so that p is nearest\n// to the face contains this pair among all six faces.\nvoid findVertexPair(vec3 p, vec3 verts[4], out int i1, out int j1) {\n    float d = 1e5;\n    float d1;\n    for (int i = 0; i < 4; i++) {\n        for (int j = i + 1; j < 4; j++) {\n            // (verts[i] + verts[j]) / 2. is the center of the face since they\n            // form a diagonal pair.\n            d1 = length(p - (verts[i] + verts[j]) / 2.);\n            if (d1 < d) {\n                i1 = i;\n                j1 = j;\n                d = d1;\n            }\n        }\n    }\n}\n\nfloat map(vec3 p) {\n    vec3 dedge = vec3(1e5);\n    vec3 p0 = p;\n    int flips = 0;\n    p = fold(p0, flips);\n\n// For the usual uniform honeycomb just render the edges, that's safe since they\n// lie inside the fundamental tetrahedron.\n#ifndef DUAL\n\n    for (int i = 0; i < 4; i++) {\n        dedge = min(dedge, dSegment(p, v0, E[i]));\n    }\n\n#else\n/*\nRender the dual honeycomb.\n\nIn the dual honeycomb two cells are adjacent if and only if they share a common\nface.\n\nFor two mirrors A, B they generate a non-degenerate face if and only if either\nof below holds:\n\n    1. A, B are perpendicular and they are both active\n    2. A, B are not perpendicular and at least one of them is active\n\nFor such a face we further check if {A, B, C} and {A, B, D} both generate\nnon-degenerate cells.\n\n1. If {A, B, C} and {A, B, D} are both non-degenerate, (C, D) form an edge in\nthe dual honeycomb.\n2. If {A, B, D} degenerates to a face, (D, 2*C-D) form an edge in the dual\nhoneycomb.\n3. If both {A, B, C} and {A, B, D} are degenerate, no edge between C and D.\n*/\n\n// The C3 honeycomb is the easiest, handle this case first.\n//   4       4\n// o---o---o---o\n// A   B   C   D\n#if LATTICE == 2\n    // if either A or B is active, then {A, B} generate a face and {A, B, C} is\n    // a non-degenerate cell. {A, B, D} is non-degenerate iff D is active. Other\n    // procedures below are all similar.\n    if (isActive(0) || isActive(1)) {\n        if (isActive(3))\n            dedge = min(dedge, dSegment(p, V[2], V[3]));\n        else\n            dedge = min(dedge, dSegment(p, V[3], 2. * V[2] - V[3]));\n    }\n    if (isActive(0) && isActive(2))\n        dedge = min(dedge, dSegment(p, V[1], V[3]));\n    if (isActive(1) || isActive(2))\n        dedge = min(dedge, dSegment(p0, V[0], V[3]));\n    if (isActive(0) && isActive(3))\n        dedge = min(dedge, dSegment(p, V[1], V[2]));\n    if (isActive(1) && isActive(3))\n        dedge = min(dedge, dSegment(p, V[0], V[2]));\n    if (isActive(2) || isActive(3)) {\n        if (isActive(0))\n            dedge = min(dedge, dSegment(p, V[1], V[0]));\n        else\n            dedge = min(dedge, dSegment(p, V[0], 2. * V[1] - V[0]));\n    }\n\n#elif LATTICE == 1\n\n    if (isActive(0) || isActive(1))\n        dedge = min(dedge, dSegment(p, V[2], V[3]));\n    if (isActive(0) && isActive(2)) {\n        if (isActive(3))\n            dedge = min(dedge, dSegment(p, V[1], V[3]));\n        else\n            dedge = min(dedge, dSegment(p, V[3], 2. * V[1] - V[3]));\n    }\n    // trick: the edge (V[0], V[3]) does not lie inside the fundamental domain\n    // hence octahedral shapes won't work. we render its 4 copies in the cube\n    // [0, 0, 0] x [2, 2, 2].\n    if (isActive(1) || isActive(2)) {\n        dedge = min(dedge, dSegment(p0, V[0], V[3]));\n        dedge = min(dedge, dSegment(p0, V[0], vec3(2, 2, 0)));\n        dedge = min(dedge, dSegment(p0, V[0], vec3(2, 0, 2)));\n        dedge = min(dedge, dSegment(p0, V[0], vec3(0, 2, 2)));\n    }\n\n    if (isActive(0) && isActive(3)) {\n        if (isActive(2))\n            dedge = min(dedge, dSegment(p, V[1], V[2]));\n        else\n            dedge = min(dedge, dSegment(p, V[2], 2. * V[1] - V[2]));\n    }\n    if (isActive(1) || isActive(3)) {\n        dedge = min(dedge, dSegment(p0, V[0], V[2]));\n        dedge = min(dedge, dSegment(p0, V[0], vec3(0, 2, 0)));\n        dedge = min(dedge, dSegment(p0, V[0], vec3(0, 0, 2)));\n        dedge = min(dedge, dSegment(p0, V[0], vec3(2, 2, 2)));\n    }\n    if (isActive(2) && isActive(3)) {\n        if (isActive(1))\n            dedge = min(dedge, dSegment(p, V[1], V[0]));\n        else\n            dedge = min(dedge, dSegment(p, V[0], 2. * V[1] - V[0]));\n    }\n\n#else\n    // The duals of A3 honeycombs are the most difficult. Recall p0 is now in\n    // [-2, -2, -2] x [2, 2, 2]. We use a completely different way to render\n    // them. The idea is, vertices of the A3 regular honeycombs are integer\n    // lattices points (i, j, k) with: i + j + k = 0 mod 4 for V0 i + j + k = 2\n    // mod 4 for V1 i + j\n    // + k = 1 mod 4 for V2 i + j + k = 3 mod 4 for V3\n\n    // find the center of the 2x2x2 cube that p belongs to\n    vec3 C = vec3(sgn(p0.x), sgn(p0.y), sgn(p0.z));\n\n    float k = mod(C.x + C.y + C.z, 4.);\n    // if k = 1 mod 4, then the center of this cube is congruent to V[2] of the\n    // fundamental tetrahedron. else k = 3 mod 4 and the center is congruent to\n    // V[3].\n    int type = (k == 1.) ? 2 : 3;\n\n    vec3 V0[4]; // holds the vertices of this 2x2x2 cube that are congruent to\n                // V[0]\n    vec3 V1[4]; // holds the vertices of this 2x2x2 cube that are congruent to\n                // V[1]\n\n    if (type == 2) {\n        V0[0] = C + vec3(1, 1, 1);\n        V0[1] = C + vec3(-1, -1, 1);\n        V0[2] = C + vec3(1, -1, -1);\n        V0[3] = C + vec3(-1, 1, -1);\n        V1[0] = C + vec3(1, -1, 1);\n        V1[1] = C + vec3(-1, 1, 1);\n        V1[2] = C + vec3(1, 1, -1);\n        V1[3] = C + vec3(-1, -1, -1);\n    } else { // switch the role of V0, V1 above\n        V1[0] = C + vec3(1, 1, 1);\n        V1[1] = C + vec3(-1, -1, 1);\n        V1[2] = C + vec3(1, -1, -1);\n        V1[3] = C + vec3(-1, 1, -1);\n        V0[0] = C + vec3(1, -1, 1);\n        V0[1] = C + vec3(-1, 1, 1);\n        V0[2] = C + vec3(1, 1, -1);\n        V0[3] = C + vec3(-1, -1, -1);\n    }\n\n    int r0, s0, r1, s1;\n    findVertexPair(p0, V0, r0, s0);\n    findVertexPair(p0, V1, r1, s1);\n    vec3 P0 = V0[r0] + V0[s0] - C;\n    vec3 P1 = V1[r1] + V1[s1] - C;\n\n    if (isActive(2) && isActive(3))\n        dedge = min(dedge, dSegment(p, V[0], V[1]));\n    if (isActive(1) || isActive(3)) {\n        if (type == 2) {\n            dedge = min(dedge, dSegment(p0, C, V0[r0]));\n            dedge = min(dedge, dSegment(p0, C, V0[s0]));\n        } else {\n            dedge = min(dedge, dSegment(p0, P0, V0[r0]));\n            dedge = min(dedge, dSegment(p0, P0, V0[s0]));\n        }\n    }\n    if (isActive(1) || isActive(2)) {\n        if (type == 3) {\n            dedge = min(dedge, dSegment(p0, C, V0[r0]));\n            dedge = min(dedge, dSegment(p0, C, V0[s0]));\n        } else {\n            dedge = min(dedge, dSegment(p0, P0, V0[r0]));\n            dedge = min(dedge, dSegment(p0, P0, V0[s0]));\n        }\n    }\n    if (isActive(0) || isActive(3)) {\n        if (type == 2) {\n            dedge = min(dedge, dSegment(p0, C, V1[r1]));\n            dedge = min(dedge, dSegment(p0, C, V1[s1]));\n        } else {\n            dedge = min(dedge, dSegment(p0, P1, V1[r1]));\n            dedge = min(dedge, dSegment(p0, P1, V1[s1]));\n        }\n    }\n    if (isActive(0) || isActive(2)) {\n        if (type == 3) {\n            dedge = min(dedge, dSegment(p0, C, V1[r1]));\n            dedge = min(dedge, dSegment(p0, C, V1[s1]));\n        } else {\n            dedge = min(dedge, dSegment(p0, P1, V1[r1]));\n            dedge = min(dedge, dSegment(p0, P1, V1[s1]));\n        }\n    }\n    if (isActive(0) && isActive(1))\n        dedge = min(dedge, dSegment(p, V[2], V[3]));\n\n#endif\n#endif\n\n    // store the object ids.\n    objIDs = dedge;\n    return min(dedge.x, min(dedge.y, dedge.z));\n}\n\n// This reduces the compiling time to about 7x times faster\nvec3 calcNormal(vec3 p, inout float edge, float t) {\n    float eps = 1. / mix(400., iResolution.y, .5) * (1. + t * .5);\n    float d = map(p);\n    vec3 e = vec3(eps, 0, 0);\n    vec3 da = vec3(-2. * d);\n    for (int i = min(iFrame, 0); i < 3; i++) {\n        for (int j = min(iFrame, 0); j < 2; j++)\n            da[i] += map(p + e * float(1 - 2 * j));\n        e = e.zxy;\n    }\n    da = abs(da);\n\n    edge = da.x + da.y + da.z;\n    edge = smoothstep(0., 1., sqrt(edge / e.x * 2.));\n\n    vec3 n = vec3(0.0);\n    for (int i = min(iFrame, 0); i < 4; i++) {\n        vec3 e =\n            .57735 *\n            (2. * vec3((((i + 3) >> 1) & 1), ((i >> 1) & 1), (i & 1)) - 1.);\n        n += e * map(p + .001 * e);\n    }\n    return normalize(n);\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float tmin, float tmax, float k) {\n    const int maxShadeIterations = 32;\n    vec3 rd = lp - ro;\n    rd /= max(length(rd), 1e-4);\n    float shade = 1.0;\n    float t = tmin;\n    for (int i = 0; i < maxShadeIterations; i++) {\n        float h = map(ro + rd * t);\n        t += clamp(h, 0.01, 0.2);\n        shade = min(shade, smoothstep(0., 1., k * h / t));\n        if (abs(h) < 1e-4 || t > tmax)\n            break;\n    }\n    return min(max(shade, 0.) + .1, 1.);\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\nfloat trace(in vec3 ro, in vec3 rd) {\n    glow = 0.;\n    float ah;\n    const float precis = 1e-3;\n    float t = 0.0;\n    for (int i = 0; i < 128; i++) {\n        float h = map(ro + rd * t);\n        ah = abs(h);\n        glow += 1. / (1. + ah * ah * 8.);\n        if (ah < (t * 0.125 + 1.) * precis || t > FAR)\n            break;\n        t += h;\n    }\n    return min(t, FAR);\n}\n\nvec3 transform(in vec3 p) {\n    if (iMouse.x > 0.0) {\n        float phi = 2.0 * iMouse.x / iResolution.x * PI - PI;\n        float theta = iMouse.y / iResolution.y * PI - 0.5 * PI;\n        p.xz = rot2d(p.xz, phi / 6.);\n        p.yx = rot2d(p.yx, theta / 4.);\n    }\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    init();\n\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    vec3 up = vec3(0, 1, 0);\n    vec3 ro = camPath(iTime * 1.1);\n    vec3 lookat = camPath(iTime * 1.1 + 0.1);\n\n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward * 2.);\n    ro = transform(ro);\n    rd = transform(rd);\n    vec3 lp = ro + vec3(-1, 2, -1);\n    vec3 col = vec3(0);\n\n    float t = trace(ro, rd);\n\n    float objID = (objIDs.x < objIDs.y && objIDs.x < objIDs.z) ? 0.\n                  : (objIDs.y < objIDs.z)                      ? 1.\n                                                               : 2.;\n\n    if (t < FAR) {\n        float ed;\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos, ed, t);\n\n        vec3 oCol;\n#ifndef GOLD_STYLE\n        vec3 bCol = mix(\n            vec3(1, .1, .5).zyx, vec3(1, .3, .1).zyx,\n            dot(sin(pos * 8. - cos(pos.yzx * 4. + iTime * 4.)), vec3(.166)) +\n                .5);\n#else\n        vec3 bCol = mix(\n            vec3(1, .5, .1), vec3(1, .1, .2),\n            dot(sin(pos * 8. - cos(pos.yzx * 4. + iTime * 4.)), vec3(.166)) +\n                .5);\n#endif\n        if (objID < .5)\n            oCol = mix(bCol, vec3(1), .97);\n\n        else if (objID > 1.5)\n            oCol = mix(bCol, vec3(1), .05) + bCol * 2.;\n\n        else\n            oCol = mix(bCol, vec3(1.35), .97) * vec3(1.1, 1, .9);\n\n        vec3 tx = tex3D(iChannel0, pos * 2., nor);\n        tx = smoothstep(.0, .5, tx) * 2.;\n\n        if (objID < 1.5)\n            oCol *= tx;\n        else\n            oCol *= mix(vec3(1), tx, .5);\n\n        float ao = calcAO(pos, nor);\n        float sh = softShadow(pos + nor * .002, lp, 0.001, 16., t);\n\n        vec3 ld = lp - pos;\n        float dist = max(length(ld), 0.001);\n        ld /= dist;\n\n        float atten = 3. / (1. + dist * 0.05 + dist * dist * 0.025);\n\n        float diff = max(dot(ld, nor), 0.);\n        if (objID < 1.5)\n            diff = pow(diff, 4.) * 2.;\n        float spec = pow(max(dot(reflect(ld, nor), rd), 0.0), 32.0);\n\n        col = oCol * (diff + .25) +\n              mix(bCol.zyx, vec3(1, .7, .3), .5) * spec * 4.;\n\n        col += .015 / max(abs(.05 - map(pos * 1.5 + sin(iTime / 6.))), .01) *\n               oCol * mix(bCol, vec3(1, .8, .5), .35);\n\n        // Adding a bit of glow. It was tempting to get my money's worth, but I\n        // kept it subtle. :)\n        if (objID < 1.5)\n            col += bCol * glow * .02;\n        else\n            col += bCol * glow * 1.5;\n\n        // Applying the dark edges, attenuation, shadows and ambient occlusion.\n        col *= (1. - ed * .7);\n        col *= atten * (sh + ao * .25) * ao;\n    }\n\n    float fog = 1. / (1. + t * .125 + t * t * .01);\n    col = mix(vec3(0), col, fog); //\n\n    uv = fragCoord / iResolution.xy;\n    col *= pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .125);\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"tlKcRw","date":"0","viewed":0,"name":"polytestt","description":"test","likes":0,"published":"Private","usePreview":0,"tags":["test"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653\nconst vec4 u = vec4(0.04032913,\n                    0.13985282,\n                    0.28973322,0.94597537);\nconst vec4 v = vec4(-0.7695257,\n0.55022818,-0.32034564,0.04957647);\n\nconst float[6] diagram = float[6](5.0, 2.0, 2.0, 3.0, 2.0, 3.0);\nconst vec4 active_mirrors = vec4(1.0, 0.0, 0.0, 0.0);\nmat4 M;\nvec4 v0;\nconst float vradius = 0.01;\nconst float sradius = 0.1;\nfloat cvr, svr;\nmat4 R;\n// --- NEW: Define the polytope's center position ---\n// We move its center to z=5, so its lowest point (radius ~1) is at z=4.\nconst vec3 POLYTOPE_CENTER = vec3(0.0, 0.0, 6.0);\n\n\nvoid init() {\n    float c01 = -cos(PI / diagram[0]);\n    float c02 = -cos(PI / diagram[1]);\n    float c03 = -cos(PI / diagram[2]);\n    float c12 = -cos(PI / diagram[3]);\n    float c13 = -cos(PI / diagram[4]);\n    float c23 = -cos(PI / diagram[5]);\n    vec4 A, B, C, D;\n    A = vec4(1., 0., 0., 0.);\n    B = vec4(c01, sqrt(1. - c01 * c01), 0., 0.);\n    C = vec4(c02, 0., 0., 0.);\n    C.y = (c12 - C.x * B.x) / B.y;\n    C.z = sqrt(abs(1. - dot(C.xy, C.xy)));\n    D = vec4(c03, 0., 0., 0.);\n    D.y = (c13 - D.x * B.x) / B.y;\n    D.z = (c23 - dot(D.xy, C.xy)) / C.z;\n    D.w = -sqrt(abs(1. - dot(D.xyz, D.xyz)));\n    M = mat4(A, B, C, D);\n    v0 = normalize(active_mirrors * inverse(M));\n    \n   vec4 w, z;\n    vec4 e3 = vec4(0,0,1,0);\n    vec4 e4 = vec4(0,0,0,1);\n    w = normalize(e3 - dot(e3, u) * u - dot(e3, v) * v);\n    z = normalize(e4 - dot(e4, u) * u - dot(e4, v) * v - dot(e4, w) * w);\n    \n    // The matrix to transform from Object to World is B = mat4(u,v,w,z).\n    // We need the inverse, from World to Object, which for an orthonormal matrix is its transpose.\n   R = transpose(mat4(u, v, w, z));\n}\n\nfloat ref(inout vec4 p, in vec4 n) {\n    float k = min(0., dot(p, n));\n    p -= 2. * k * n;\n    return k;\n}\n\nbool fold(inout vec4 p) {\n    for (int i = 0; i < 20; i++) {\n        p.x = abs(p.x);\n        if (ref(p, M[1]) + ref(p, M[2]) + ref(p, M[3]) == 0.)\n            return true;\n    }\n    return false;\n}\n\nfloat knightyDD(float ca, float sa, float r) {\n    float x = 1. - r * r;\n    float y = 2. - x;\n    return r - (2. * r * ca - x * sa) / (x * ca + 2. * r * sa + y);\n}\nfloat dVertex(vec4 p, float r) {\n    float ca = dot(p, v0);\n    float sa = 0.5 * length(p - v0) * length(p + v0);\n    return knightyDD(ca * cvr + sa * svr, sa * cvr - ca * svr, r);\n}\n\nfloat dSegment(vec4 p, vec4 n, float r) {\n    float adjusted_sradius = sradius * 2.0 / (1.0 + r*r);\n    float csr = cos(adjusted_sradius);\n    float ssr = sin(adjusted_sradius);\n    float pn = dot(p, n);\n    float pv = dot(p, v0);\n    float nv = dot(n, v0);\n    float a = pv - pn * nv;\n    float b = pn - pv * nv;\n    vec4 pj = normalize(min(b, 0.) * n + a * v0);\n    float ca = dot(p, pj);\n    float sa = sqrt(max(0.0, 1.0 - ca * ca));\n    return knightyDD(ca * csr + sa * ssr, sa * csr - ca * ssr, r);\n}\nfloat dSegments(vec4 p, float r, inout float index) {\n    float d = 1.0;\n    for (int i = 0; i < 4; i++) {\n        float dseg = dSegment(p, M[i], r);\n        if (dseg < d) {\n            d = dseg;\n            index = float(i);\n        }\n    }\n    return d;\n}\n\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\nvoid rot4d(inout vec4 p) {\n    p.xy = rot2d(p.xy, iTime * 0.2);\n    p.zw = rot2d(p.zw, iTime * 0.2);\n}\n\n// CHANGE: This function now calculates distance to a translated polytope\nfloat distanceToPolytope(vec3 p) {\n    // The input 'p' is already in the polytope's local space.\n    float r = length(p);\n    vec4 q = vec4(2. * p, 1. - r * r) / (1. + r * r);\n    vec4 zz = q;\n    for (int i = 0; i < 4; i++)\n       q[i] = dot(zz, R[i]);\n \n    bool found = fold(q);\n    if (found) {\n        float id;\n        float dvert = dVertex(q, r);\n        float dedge = dSegments(q, r, id);\n        id = (dvert < dedge) ? 4. : id;\n        return min(dvert, dedge);\n    }\n    return 1e5;\n}\n\n// --- CHANGE: Scene Definition updated for new layout ---\nvec2 map(vec3 p) {\n    // Calculate distance to the polytope, which is centered at POLYTOPE_CENTER\n    float dist_poly = distanceToPolytope(p - POLYTOPE_CENTER);\n    // Calculate distance to the plane at z=0\n    float dist_plane = p.z; \n    \n    if (dist_plane < dist_poly) {\n        return vec2(dist_plane, 2.0); // Hit plane\n    }\n    return vec2(dist_poly, 1.0); // Hit polytope\n}\n\n// --- CHANGE: Shadow function updated to check against translated polytope ---\nfloat calcShadow(vec3 p, vec3 lightDir, float maxDist) {\n    float t = 0.01;\n    for (int i = 0; i < 64; i++) {\n        // We check the distance to the polytope in its translated position\n        float d = distanceToPolytope(p + t * lightDir - POLYTOPE_CENTER);\n        if (d < 0.001) return 0.2; // In shadow\n        t += d;\n        if (t > maxDist) break; // Ray passed the light\n    }\n    return 1.0; // Not in shadow\n}\n\n// --- CHANGE: Surface normal function updated ---\nvec3 computeSurfaceNormal(vec3 p, float id) {\n    // Plane is now at z=0, so its normal is along the z-axis\n    if (id == 2.0) return vec3(0.0, 0.0, 1.0);\n    \n    const float e = 0.001;\n    vec2 h = vec2(1, -1);\n    // Gradient calculation must also account for the object's offset\n    vec3 p_local = p - POLYTOPE_CENTER;\n    return normalize(h.xyy * distanceToPolytope(p_local + h.xyy * e) +\n                     h.yyx * distanceToPolytope(p_local + h.yyx * e) +\n                     h.yxy * distanceToPolytope(p_local + h.yxy * e) +\n                     h.xxx * distanceToPolytope(p_local + h.xxx * e));\n}\n\nmat3 setCamera_Zup(in vec3 ro, in vec3 ta) {\n    vec3 fwd = normalize(ta - ro);             // Camera's forward direction\n    vec3 worldUp = vec3(0.0, 0.0, 1.0);        // Define world's \"up\" as +Z axis\n    vec3 right = normalize(cross(fwd, worldUp)); // Camera's \"right\" is perpendicular to fwd and worldUp\n    vec3 up = cross(right, fwd);               // Camera's \"up\" is perpendicular to its right and fwd\n    return mat3(right, up, fwd);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    cvr = cos(vradius);\n    svr = sin(vradius);\n    init();\n\n    vec2 p_uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n\n    // --- Camera setup for new perspective (No changes here) ---\n    vec3 cam_state = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n    float yaw = cam_state.x;\n    float dist = cam_state.z; \n\n    vec3 tar = vec3(0.0, 0.0, 4.0);\n    vec3 pos = tar + vec3(dist * cos(yaw), dist * sin(yaw), 0.0);\n    \n    // --- CHANGE: Use the new setCamera_Zup function ---\n    // Note that it doesn't need a 'roll' parameter anymore.\n    vec3 dir = setCamera_Zup(pos, tar) * normalize(vec3(p_uv.xy, 2.0));\n\n    // --- Spotlight setup for Z-up world (No changes here) ---\n    vec3 lightPos = vec3(2.0, -1.0, 20.0);\n    vec3 lightColor = vec3(1.0, 0.95, 0.85);\n    vec3 spotDir = normalize(vec3(0.0, 0.0, -1.0));\n    float spotCutoff = cos(radians(40.0));\n    float spotFeather = 0.15; \n\n    // --- Raymarching Loop (No changes here) ---\n    float t = 0.0;\n    float id = 0.0;\n    for (int i = 0; i < 256; i++) {\n        vec3 p_march = pos + t * dir;\n        vec2 res = map(p_march);\n        id = res.y;\n        float d = res.x;\n        if (d < 0.0005) break;\n        t += d;\n        if (t > 100.0) {\n            t = -1.0;\n            break;\n        }\n    }\n\n    // --- Shading (No changes here) ---\n    vec3 col = vec3(0.0); \n    \n    if (t > 0.0) {\n        vec3 p = pos + t * dir;\n        vec3 nor = computeSurfaceNormal(p, id);\n        vec3 viewDir = -dir;\n\n        vec3 lightDir = normalize(lightPos - p);\n        float distToLight = length(lightPos - p);\n        float spotTheta = dot(-lightDir, spotDir);\n        float spotAtten = smoothstep(spotCutoff - spotFeather, spotCutoff, spotTheta);\n        float shadow = calcShadow(p + nor * 0.01, lightDir, distToLight);\n\n        if (spotAtten > 0.0) {\n            vec3 finalLightColor = lightColor * spotAtten;\n\n            if (id == 1.0) { // Polytope shading\n                vec3 polytopeColor = vec3(1.0, 0.7, 0.3);\n                vec3 ambient = vec3(0.05);\n                float diffuse = max(0.0, dot(nor, lightDir));\n                vec3 halfDir = normalize(lightDir + viewDir);\n                float spec = pow(max(0.0, dot(nor, halfDir)), 64.0);\n                vec3 specular = vec3(1.0) * spec;\n                float fresnel = pow(1.0 - max(0.0, dot(nor, viewDir)), 3.0);\n                \n                col = polytopeColor * (ambient + diffuse * finalLightColor * shadow);\n                col += specular * shadow * finalLightColor;\n                col += fresnel * 0.3 * polytopeColor;\n\n            } else if (id == 2.0) { // Plane shading\n                float diffuse = max(0.0, dot(nor, lightDir));\n                float checker = mod(floor(p.x * 2.0) + floor(p.y * 2.0), 2.0);\n                vec3 planeColor = vec3(0.5) + checker * 0.2;\n                float ao = smoothstep(0.0, 1.0, distanceToPolytope(p - POLYTOPE_CENTER) / 1.0);\n                \n                col = planeColor * (vec3(0.01) + diffuse * finalLightColor * shadow * ao);\n            }\n        }\n    }\n    \n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // We only need to perform this calculation once per frame, for a single pixel.\n    if ( fragCoord.x > 1.0 || fragCoord.y > 1.0 ) {\n        discard;\n        return;\n    }\n\n    // Read the full camera state (angles, distance) from the previous frame.\n    vec3 state = texelFetch(iChannel0, ivec2(0,0), 0).xyz;\n\n    // --- Mouse Rotation Logic (no changes) ---\n    // iMouse.z > 0 means the left mouse button is currently held down.\n    if (iMouse.z > 0.0) {\n        // To get delta from last frame, we need last frame's mouse position.\n        // We'll store it in the output's .w component.\n        float last_mouse_x = texelFetch(iChannel0, ivec2(0,0), 0).w;\n        \n        // A simple way to get delta without complex state machine:\n        // Assume first drag frame is iMouse.zw. Subsequent frames must use last frame's pos.\n        // A robust way that works well:\n        vec2 mouse_delta = iMouse.xy - iMouse.zw; // Delta from click start point.\n        \n        // We need the angles from when the click started.\n        // This requires another buffer or more complex state.\n        \n        // Let's stick to a simpler, direct accumulation model. It's less \"sticky\" but works.\n        // Get last frame's mouse pos from our buffer (we will store it there)\n        vec4 prev_frame = texelFetch(iChannel0, ivec2(0,0), 0);\n        vec2 prev_mouse = prev_frame.zw;\n\n        if (iMouse.z > 0.0 && prev_mouse.x != 0.0) {\n             vec2 mouse_d = iMouse.xy - prev_mouse;\n             state.x += mouse_d.x * 0.005; // Yaw\n             state.y -= mouse_d.y * 0.005; // Pitch\n        }\n    }\n\n    // --- Keyboard Zoom Logic (NEW) ---\n    float zoom_speed = 0.1;\n    // Check if 'W' key (ASCII 87) is pressed\n    if (texelFetch(iChannel3, ivec2(87, 0), 0).x > 0.0) {\n        state.z -= zoom_speed;\n    }\n    // Check if 'S' key (ASCII 83) is pressed\n    if (texelFetch(iChannel3, ivec2(83, 0), 0).x > 0.0) {\n        state.z += zoom_speed;\n    }\n\n    // --- Clamp and Initialize ---\n    // Clamp pitch\n    state.y = clamp(state.y, -PI * 0.49, PI * 0.49);\n    // Clamp distance to prevent going inside the object or too far away\n    state.z = clamp(state.z, 1.5, 20.0);\n\n    // On the first few frames, or if reset, initialize state.\n    if (iFrame < 2 || texelFetch(iChannel0, ivec2(0,0), 0) == vec4(0.0)) {\n        // Initial state: yaw=0.5, pitch=-0.2, distance=4.5\n        state = vec3(0.5, -0.2, 14.5);\n    }\n    \n    // Output the new state and current mouse pos for the next frame's calculation.\n    // .xyz = new state, .w = current mouse x for delta calculation\n    fragColor = vec4(state, iMouse.z > 0.0 ? iMouse.x : 0.0); // Simple mouse tracking\n    // A slightly better way for mouse delta:\n    fragColor = vec4(state, iMouse.xy);\n    }","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"7lf3Wn","date":"1621876254","viewed":1127,"name":"Marden's Theorem","description":"This shader illustrates Marden's theorem on the Steiner inellipse of a triangle.","likes":31,"published":"Public API","usePreview":0,"tags":["2d","ellipse","marden","saddlepoint"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Marden's theorem on Steiner inellipse, Zhao Liang.\n\nMotivated by this tweet:\n\n    https://twitter.com/theAlbertChern/status/1395468792788967428?s=20\n*/\n#define PI 3.141592653\n\nfloat sl;\n\nconst float palNum = 70.;\n\nfloat sFract(float x, float sm) {\n    // Extra smoothing factor. \"1\" is the norm.\n    const float sf = 1.;\n\n    // The hardware \"fwidth\" is cheap, but you could take the expensive route\n    // and calculate it by hand if more quality was required.\n    vec2 u = vec2(x, fwidth(x) * sf * sm);\n\n    // Ollj's original formula with a transcendental term omitted.\n    u.x = fract(u.x);\n    u += (1. - 2. * u) * step(u.y, u.x);\n    return clamp(1. - u.x / u.y, 0., 1.); // Cos term ommitted.\n}\n\n// Only correct for nonnegative values, but in this example, numbers aren't\n// negative.\nfloat sFloor(float x) { return x - sFract(x, 1.); }\n\nfloat sdCross(in vec2 p, in vec2 b, float r) {\n    p = abs(p);\n    p = (p.y > p.x) ? p.yx : p.xy;\n\n    vec2 q = p - b;\n    float k = max(q.y, q.x);\n    vec2 w = (k > 0.0) ? q : vec2(b.y - p.x, -k);\n    float d = length(max(w, 0.0));\n    return ((k > 0.0) ? d : -d) + r;\n}\n\nvec3 rotHue(vec3 p, float a) {\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr =\n        mat3(0.299, 0.587, 0.114, 0.299, 0.587, 0.114, 0.299, 0.587, 0.114) +\n        mat3(0.701, -0.587, -0.114, -0.299, 0.413, -0.114, -0.300, -0.588,\n             0.886) *\n            cs.x +\n        mat3(0.168, 0.330, -0.497, -0.328, 0.035, 0.292, 1.250, -1.050,\n             -0.203) *\n            cs.y;\n\n    return clamp(p * hr, 0., 1.);\n}\n\nfloat msign(in float x) { return x < 0.0 ? -1.0 : 1.0; }\n\nmat2 rot2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvec2 cmul(vec2 p, vec2 q) {\n    return vec2(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);\n}\n\nvec2 csqrt(vec2 p) {\n    float a = atan(p.y, p.x) / 2.;\n    return vec2(cos(a), sin(a)) * sqrt(length(p));\n}\n\n// distance from a 2d point p to a 2d segment (a, b)\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n    vec2 v = b - a;\n    p -= a;\n    float t = clamp(dot(p, v) / dot(v, v), 0., 1.);\n    return length(p - t * v);\n}\n\n// iq's triangle signed distance function\nfloat sdTriangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2) {\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0 * clamp(dot(v0, e0) / dot(e0, e0), 0.0, 1.0);\n    vec2 pq1 = v1 - e1 * clamp(dot(v1, e1) / dot(e1, e1), 0.0, 1.0);\n    vec2 pq2 = v2 - e2 * clamp(dot(v2, e2) / dot(e2, e2), 0.0, 1.0);\n\n    float s = e0.x * e2.y - e0.y * e2.x;\n    vec2 d = min(min(vec2(dot(pq0, pq0), s * (v0.x * e0.y - v0.y * e0.x)),\n                     vec2(dot(pq1, pq1), s * (v1.x * e1.y - v1.y * e1.x))),\n                 vec2(dot(pq2, pq2), s * (v2.x * e2.y - v2.y * e2.x)));\n\n    return -sqrt(d.x) * sign(d.y);\n}\n\n// ellipse signed distance function\nfloat sdEllipse(vec2 p, vec2 cen, float theta, in vec2 ab) {\n    p -= cen;\n    float c = cos(theta), s = sin(theta);\n    p *= mat2(c, s, -s, c);\n    vec2 pab = p / (ab * ab);\n    return (0.5 * dot(pab, p) - 0.5) / length(pab);\n}\n\nfloat sdEllipseFromTriangle(vec2 p, vec2 p0, vec2 p1, vec2 p2, out vec2 f1,\n                            out vec2 f2) {\n    vec2 m = (p0 + p1 + p2) / 3.;\n    vec2 n = (cmul(p0, p1) + cmul(p1, p2) + cmul(p2, p0)) / 3.;\n    f1 = m + csqrt(cmul(m, m) - n);\n    f2 = m - csqrt(cmul(m, m) - n);\n    vec2 mid = (p0 + p1) / 2.;\n    float a = (length(mid - f1) + length(mid - f2)) / 2.;\n    vec2 cen = (f1 + f2) / 2.;\n    vec2 dir = (f1 - f2) / 2.;\n    float b = sqrt(a * a - dot(dir, dir));\n    float theta = atan(dir.y, dir.x);\n    return sdEllipse(p, cen, theta, vec2(a, b));\n}\n\nfloat getVoltage(vec2 p, vec2 p0, vec2 p1, vec2 p2) {\n    float c = length(p - p0) * length(p - p1) * length(p - p2);\n    c = log(max(c, 0.001));\n    c = c / 10. + 0.5;\n    c = clamp(c, 0., 1.);\n    float level = sFloor(c * (palNum - .001));\n    sl = level;\n    return clamp(level / (palNum - 1.), 0., 1.) * .85 + .15 * c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float sf = 2. / iResolution.y;\n    vec2 p = uv * 2.;\n\n    // triangle vertices\n    vec2 A = vec2(1.5 * sin(iTime), 1.5);\n    vec2 B = vec2(-2. + 0.4 * cos(iTime * 0.7), -1. + 0.6 * cos(iTime * 0.7));\n    vec2 C = vec2(1.8 + cos(iTime), -1.6);\n\n    // distance to the triangle\n    float dtri = sdTriangle(p, A, B, C);\n\n    // foci of the Steiner inscribed ellipse.\n    vec2[2] foci;\n\n    // solve the ellipse and foci\n    vec2 m = (A + B + C) / 3.;\n    vec2 n = (cmul(A, B) + cmul(B, C) + cmul(C, A)) / 3.;\n    foci[0] = m + csqrt(cmul(m, m) - n);\n    foci[1] = m - csqrt(cmul(m, m) - n);\n    // the tangent point is the middle point of an edge.\n    vec2 mid = (A + B) / 2.;\n    // semi-axis\n    float a = (length(mid - foci[0]) + length(mid - foci[1])) / 2.;\n    vec2 cen = (foci[0] + foci[1]) / 2.;\n    vec2 dir = (foci[0] - foci[1]) / 2.;\n    float b = sqrt(a * a - dot(dir, dir));\n    float theta = atan(dir.y, dir.x);\n    // now we have the distance to the ellipse and the foci\n    float dellipse = sdEllipse(p, cen, theta, vec2(a, b));\n    float dfoci = min(length(p - foci[0]), length(p - foci[1])) - 0.04;\n\n    // distance to the medians\n    float dlines = 1e5;\n    dlines = min(dlines, dseg(p, A, (B + C) / 2.));\n    dlines = min(dlines, dseg(p, B, (A + C) / 2.));\n    dlines = min(dlines, dseg(p, C, (B + A) / 2.));\n\n    // inside the ellipse/between ellipse and triangle/outside the triangle\n    float sgn = dellipse < 0. ? -2. : (dtri < 0. ? 0. : 1.);\n\n    // get voltage at this point\n    float volt = getVoltage(p, A, B, C);\n    float ssl = sl;\n\n    vec2 e = vec2(8. / clamp(iResolution.y, 300., 800.), 0);\n    float fxl = getVoltage(p + e.xy, A, B, C);\n    float fxr = getVoltage(p - e.xy, A, B, C);\n    float fyt = getVoltage(p + e.yx, A, B, C);\n    float fyb = getVoltage(p - e.yx, A, B, C);\n\n    // color the region between voltage contours\n    vec3 col = vec3(0.4, 0.7, 0.4) - sgn * vec3(0.2, 0., 0.2) * ssl / palNum;\n    // dissipate the colors by doing some rotation\n    col = rotHue(col, -(min(ssl / palNum, 0.85)) * 12. + 1.);\n    // darken the edges\n    col *= max(1. - (abs(fxl - fxr) + abs(fyt - fyb)) * 10., 0.);\n    // make some highlight\n    fxl = getVoltage(p + e.xy * 1.5, A, B, C);\n    fyt = getVoltage(p + e.yx * 1.5, A, B, C);\n    col += vec3(.9, .7, 1.) *\n           (max(volt - fyt, 0.) + max(volt - fxl, 0.) + max(volt - fxr, 0.) +\n            max(volt - fyb, 0.)) *\n           ssl;\n    // draw the triangle\n    col *= smoothstep(0.005, 0.005 + 2.0 * sf, abs(dtri) - 0.01);\n    // draw the ellipse\n    col *= smoothstep(0.005, 0.005 + 2.0 * sf, abs(dellipse) - 0.005);\n    // draw the medians\n    col *= smoothstep(0.005, 0.005 + 2.0 * sf, abs(dlines) - 0.002);\n    // draw the segment connecting the foci\n    col = mix(\n        col, vec3(0.91, 0.1, 0.1),\n        1. - smoothstep(0., 0.005 + 2. * sf, dseg(p, foci[0], foci[1]) - 0.01));\n\n    // decorate the vertices and foci\n    vec2[3] verts;\n    verts[0] = A;\n    verts[1] = B;\n    verts[2] = C;\n    float lw = 0.02;\n\n    for (int i = 0; i < 3; i++) {\n        float dv = length(p - verts[i]) - .12;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf * 8., dv)) * .5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        col = mix(col, vec3(1, .7, .6), 1. - smoothstep(0., sf, dv + lw * 1.6));\n        float cro = sdCross(p - verts[i], vec2(0.06, 0.012), 0.01);\n        cro = abs(cro);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, cro - lw));\n    }\n    for (int i = 0; i < 2; i++) {\n        float dv = length(p - foci[i]) - .07;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf * 8., dv)) * .5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        col =\n            mix(col, vec3(.4, .6, 1.), 1. - smoothstep(0., sf, dv + lw * 1.2));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv + .075 - lw));\n    }\n\n    col *= 1.25 - 0.2 * length(p);\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"sl2GWd","date":"0","viewed":0,"name":"Fork [TDF2018]T neozhaolia 228","description":"glsl compo for tokyo demo fest 2018, 3rd place\n\nNice to be there, thanks tdf!","likes":0,"published":"Private","usePreview":0,"tags":["raymarching","fractal","tdf","doraemon"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by EvilRyu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n#define PI 3.1415926535\n#define FAR 30.0\n\nvec2 hash22(vec2 p)\n{\n    float f=p.x+p.y*37.0;\n    return fract(cos(f)*vec2(10003.579, 37049.7));\n}\n\nfloat hash13(vec3 p)\n{\n    p=fract(p * vec3(5.3983, 5.4472, 6.9371));\n    p += dot(p.yzx, p.xyz + vec3(21.5351, 14.3137, 15.3219));\n    return fract(p.x * p.y * p.z * 95.4337);\n}\n\nmat2 rot(float t)\n{\n    float c=cos(t);\n    float s=sin(t);\n    return mat2(c,-s,s,c);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h=clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n\nfloat smax(float a, float b, float k)\n{\n    return smin(a, b, -k);\n}\n\n\nvec2 line(vec3 pos, vec3 a, vec3 b)\n{\n    vec3 pa=pos-a;\n    vec3 ba=b-a;\n   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    \n    return vec2(length(pa-h*ba), h);\n}\n\nfloat line(vec3 pos, vec3 a, vec3 b, float r)\n{\n    vec3 pa=pos-a;\n    vec3 ba=b-a;\n   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    \n    return length(pa-h*ba)-r;\n}\n\nfloat line(vec2 pos, vec2 a, vec2 b, float r)\n{\n    vec2 pa=pos-a;\n    vec2 ba=b-a;\n   \n    float h=clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    \n    return length(pa-h*ba)-r;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n  vec2 q=vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sphere(vec3 p)\n{\n    return length(p)-0.5;\n}\n\nfloat cylinder(vec3 p, vec2 h)\n{\n  vec2 d=abs(vec2(length(p.xz),p.y))-h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  vec3 d=abs(p)-b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); \n}\n\nfloat prism(vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat ellipsoid(vec3 p, vec3 r)\n{\n    float k0=length(p/r);\n    float k1=length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat rbox(vec3 p, vec3 b, float r)\n{\n  vec3 d=abs(p)-b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nvec3 swing(vec3 p)\n{\n    p.xy*=rot(0.15*sin(1.5*iTime));\n\n    p+=vec3(0.5*sin(1.5*iTime),0.,-0.3+2.*iTime);\n    return p;\n}\n\n// for bounding sphere\nvec3 inverse_swing(vec3 p)\n{\n    p.xy*=rot(-0.15*sin(1.5*iTime));\n\n    p-=vec3(0.5*sin(1.5*iTime),0.,-0.3+2.*iTime);\n    return p;\n}\n\n#define HEAD 1\n#define BODY 2\n#define NOSE 3\n#define HAND 4\n#define BELL 5\n// machine\n#define BASE 6\n#define CONTROL 7\n#define CONTROL_FRONT 8\n#define FUEL 9\n#define HANDLE1 10\n#define HANDLE2 11\n#define SOFA 12\n#define LIGHT 13\n\nint obj_id, machine_id;\n\nvoid body(vec3 p, inout float d0)\n{\n    float d1=line(p+vec3(0.,.6,0.),vec3(0),vec3(0.,0.2,0.),0.32);\n    if(d1<d0) obj_id=BODY;\n    d0=smin(d0,d1,0.03);\n}\n\nvoid brace(vec3 p, inout float d0)\n{\n    float d2=torus(p+vec3(0.,.4,0.),vec2(0.31,0.03));\n    if(d2<d0) {obj_id=NOSE;d0=d2;}\n}\n\nvoid legs(vec3 p, inout float d0)\n{\n    vec3 q=vec3(abs(p.x)-.18,p.y,p.z);\n    float d3=line(q+vec3(0,.95,0.),vec3(0),vec3(0.,0.2,0.),0.15);\n    d0=smin(d0,d3,0.13);\n    \n    // feet\n    q.x=abs(p.x)-0.2;\n    float d4=torus(q+vec3(0.,1.05,0.),vec2(0.08,0.09));\n    if(d4<d0) {obj_id=HAND;d0=d4;}\n}\n\nvoid arms(vec3 p, inout float d0)\n{\n    vec2 d5=line(p+vec3(-.28,0.5,0.),vec3(0),vec3(0.27,0.25,0.));\n    d5.x=d5.x-0.1*(1.-.6*d5.y);\n    if(d5.x<d0) obj_id=BODY;\n    d0=smin(d0,d5.x,.02);\n    d5.x=length(p+vec3(-.6,0.2,0.))-0.09;\n    if(d5.x<d0) {obj_id=HAND;d0=d5.x;}\n    \n    d5=line(p+vec3(.28,0.5,0.),vec3(0),.9*vec3(-0.27,-0.25,0.));\n    d5.x=d5.x-0.1*(1.-.6*d5.y);\n    if(d5.x<d0){obj_id=BODY;d0=d5.x;}\n    d5.x=length(p+vec3(.55,0.75,0.))-0.08;\n    if(d5.x<d0) {obj_id=HAND;d0=d5.x;}\n}\n\nvoid nose_tail(vec3 p, inout float d0)\n{\n    float d6=length(p+vec3(0.,-0.15,0.5))-0.05;\n    if(d6<d0) {obj_id=NOSE;d0=d6;}\n    \n    // tail\n    float d7=line(p+vec3(0.,0.77,-0.1),vec3(0),vec3(0.,-0.1,0.25),0.01);\n    float dt=length(p+vec3(0.,0.87,-0.35))-0.04;\n    if(dt<d0) {obj_id=NOSE;d0=dt;}\n    if(d7<d0) {obj_id=BODY;d0=d7;}\n\n}\n\nvoid bag(vec3 p, inout float d0)\n{\n    vec3 q=p;\n    q.yz*=rot(0.14);\n    float d8=cylinder(vec3(q.x,q.z+.16,abs(q.y+0.55)), vec2(0.1,.19))-0.05;\n    float d9=box(q+vec3(0.,.1,.0),vec3(1.,.44,1.));\n    d8=smax(-d9,d8,.02);\n    d0=smin(d0,d8,0.01);\n    \n    // bell\n    float d10=length(p+vec3(0.,0.46,0.36))-0.06;\n    float d11=torus(p+vec3(0.,0.46,0.36),vec2(0.06,0.009));\n    d10=min(d10,d11);\n    if(d10<d0) {obj_id=BELL;d0=d10;}\n}\n\nvoid mouth(vec3 p, inout float d0)\n{\n    vec3 q=p;\n    \n    p.yz*=rot(0.2);\n    float d12=cylinder(vec3(p.x,p.z+.6,abs(p.y-0.11)), vec2(0.25,.19))-0.05;\n    float d13=box(p+vec3(0.,-1.11,.0),vec3(1.,1.,1.));\n    d12=smax(-d13,d12,.06);\n    if(-d12>d0) obj_id=NOSE;\n    d0=smax(-d12,d0,.03); \n    float dt=length(vec3(abs(p.x)-.05,p.y+.18,p.z+.2))-0.2;\n    if(dt<d0) {obj_id=NOSE;d0=dt;}\n    \n    \n    q.x=abs(q.x);\n    \n    vec2 d5=line(q+vec3(0.,-0.03,0.41),vec3(0),vec3(0.27,-0.01,-0.02));\n    //if(d14<d0) obj_id=NOSE;\n    d5.x-=0.07+0.01*(1.-d5.y);\n    d0=smin(d0,d5.x,0.01);\n}\n\nfloat doraemon(vec3 p)\n{\n    p=swing(p);\n    \n    obj_id=HEAD;\n    float d0=length(p)-0.5;\n    \n    body(p,d0);\n    brace(p,d0);\n    legs(p,d0);\n    arms(p,d0);\n    nose_tail(p,d0);\n    bag(p,d0);\n    mouth(p,d0);\n    return d0;\n}\n\nvoid main_control(vec3 p, inout float d0)\n{\n    float d2=box(p+vec3(0.,-0.4,.9), vec3(.87,.4, .2));    \n    if(d2<d0){machine_id=CONTROL;d0=d2;}\n    float d3=prism(vec3(p.z+1.,p.y-0.24,p.x), vec2(0.4,0.87));\n    if(d3<d0){machine_id=CONTROL_FRONT;d0=d3;}\n    \n    float d4=box(p+vec3(0.,-0.8,.85),vec3(0.8,0.2,0.2));\n    d0=max(-d4,d0);\n    \n    float d5=cylinder(p+vec3(-0.5,-0.7,.8),vec2(0.015,0.2));\n    if(d5<d0){machine_id=CONTROL;d0=d5;}\n    \n    float d6=length(p+vec3(-0.5,-0.88,.8))-0.05;\n    if(d6<d0) {machine_id=HANDLE1; d0=d6;}\n}\n\nvoid lamp(vec3 p, inout float d0)\n{\n    float d7=cylinder(p+vec3(-1.17,-1.,.8),vec2(0.025,1.));\n    float d8=line(p+vec3(-1.17,-2.,.8),vec3(0.),vec3(-0.35,0.35,0.),0.025);\n    d8=min(d7,d8);\n    if(d8<d0){machine_id=CONTROL;d0=d8;}\n    \n    vec3 q=p;\n    q.xy*=rot(0.8);\n    float d9=ellipsoid(q+vec3(1.32,-2.22,.8),vec3(0.25,0.07,0.2));\n    if(d9<d0){machine_id=LIGHT;d0=d9;}\n}\n\nvoid handles(vec3 p, inout float d0)\n{\n    float d=cylinder(vec3(p.x+1.35,p.z-1.2, p.y-.1),vec2(0.3,.25));\n    d=max(d,-box(p+vec3(1.65,-.2,-1.2),vec3(0.3,0.4,0.3)));\n    d=max(d,-box(p+vec3(1.25,.4,-1.2),vec3(0.3,0.4,0.3)));\n    if(d<d0){machine_id=CONTROL;d0=d;}\n    \n    p=p+vec3(1.15,-.3,-1.1);\n    \n    for(int i=0;i<3;++i)\n    {\n        d=line(p,vec3(0),vec3(0.1,0.2,0.),0.01);\n        d0=min(d0,d);\n        d=length(p+vec3(-0.1,-0.2,0.))-0.04;\n        if(d<d0){machine_id=HANDLE2;d0=d;}\n        p.z-=0.11;\n    }\n}\n\nvoid sofa(vec3 p, inout float d0)\n{\n    float d12=rbox(p+vec3(0.,-.5,-.8),vec3(0.6,0.5,0.04), 0.05);\n    float d13=rbox(p+vec3(0.,-.15,-.4),vec3(0.6,0.15,0.3), 0.05);\n    d13=smin(d12,d13,0.2);  \n    if(d13<d0){machine_id=SOFA;d0=d13;}\n}\n\nfloat timemachine(vec3 p)\n{\n    p=swing(p+vec3(0,0,0));p.y+=1.15;\n    \n    machine_id=BASE;\n    \n    float d0=box(p+vec3(0.,0.02,0.), vec3(1.5,0.06,1.8));\n    \n    main_control(p,d0);\n    lamp(p,d0);\n    handles(p,d0);\n    sofa(p,d0);\n    \n    p.x=abs(p.x)-1.17;\n    float d1=line(p+vec3(0.,-0.1,1.45),vec3(0),vec3(0.,0.,1.5),0.2);\n    if(d1<d0) {machine_id=FUEL; d0=d1;}\n    return d0;\n}\n\n\nvec2 fold(vec2 p, float a)\n{\n    p.x=abs(p.x);\n    vec2 n = vec2(cos(a),sin(a));\n    for(int i = 0; i < 3; ++i)\n    {\n        p -= 2.*min(0.,dot(p,n))*n;\n        n = normalize(n-vec2(1.,0.));\n    }\n    return p;\n}\n\nvec3 path(float p)\n{\n    return vec3(sin(p*0.05)*cos(p*0.025)*18., 0.,0.);\n}\n\n/// from Klem's Olympian: https://www.shadertoy.com/view/XltyRf\nvec3 tunnel(vec3 rd, float pos, float speed) \n{\n    const float max_r = 5.;\n    vec3 col;//=vec3(1.);\n    for (float r=1.0;r<max_r+float(min(0,iFrame));r+=1.0) \n    {\n        // calculate where the ray intersects several fixed radius cylinders\n        // using cylindrical coordinates\n        // (phi, r, z)\n        // phi=arctan(rd.y/rd.x)\n        // r=r\n        // length(rd.xy) / r = rd.z / z ==> z=rd.z*r/length(rd.xy)\n        float phi=atan(rd.x, rd.y);\n        float z=rd.z*r/length(rd.xy);\n        if(r<1.5)col=vec3(abs(z)*.005);\n        // adjust the uv acoording to cylinder size and position\n        vec2 uv=vec2(phi*r, pos+z);\n        uv.x+=1.717*hash13(vec3(floor(uv),r))*r;\n        \n        vec2 cell_center=floor(uv)+0.5;\n        cell_center+=hash22(cell_center+vec2(0.,r))-.5;\n\n        vec2 size=vec2(.01);\n        size.y+=speed/r;\n        size.y/=sin(atan(r/abs(z)));\n        \n        //float d=(length((uv-cell_center)/size)-1.)*size.y;\n        //col+=vec3(1,.9,.6)*smoothstep(0.105,-0.105,d)/(.5*r*r+.3*z*z);\n\n        \n        float redshift=0.01+speed/r;\n        cell_center.y-=redshift;\n        for (int i=0; i<3+min(0,iFrame); i++) \n        {\n            cell_center.y+=redshift;\n            \n            // draw stars\n            vec2 p=uv-cell_center;\n            float d=(length(p/size)-1.0)*size.y;\n            float dist=(r*r+z*z);\n            col[i]+=smoothstep(0.02, -0.02, d)/dist;\n        }\n        \n    }\n    return 3.*col;\n}\n\n\nfloat get_ao(vec3 p, vec3 n)\n{\n    float r=0.0, w=1.0, d;\n    for(float i=1.; i<5.0+1.1+float(min(0,iFrame)); i++)\n    {\n        d=i/5.0;\n        r+=w*(d-min(doraemon(p+n*d),timemachine(p+n*d)));\n        w*=0.5;\n    }\n    return 1.0-clamp(r,0.0,1.0);\n}\n\n\n\nvec3 material_doraemon(vec3 rd, vec3 pos, vec3 nor)\n{\n    vec3 col=vec3(0);\n    float d; \n    pos=swing(pos);\n    \n    if(obj_id==HEAD)\n    {\n        col=vec3(0.,0.5,1.0); \n        if(pos.z<0.&&length(vec2(pos.x*0.9,pos.y+0.05))<0.38)col=vec3(0.9);\n        \n        // eyes\n        if(pos.z<0.)\n        {\n            vec2 p=vec2(abs(pos.x)-0.1,pos.y*.7-0.2);\n            float r=length(p.xy);\n            col*=pow(1.-smoothstep(0.08,0.09,r)*smoothstep(0.1,0.09,r),1.);\n            if(r<0.085) col=vec3(1.);\n            p=vec2(abs(pos.x)-0.06, pos.y-0.26);\n            r=length(p);\n            p=vec2(abs(pos.x)-0.06, pos.y-0.26);\n            float r1=length(p);\n            col*=pow(1.-smoothstep(0.0,0.025,r)*smoothstep(0.03,0.025,r),7.0);\n            \n            // beards\n            if(pos.y>0.&&pos.y<0.11)\n            col*=smoothstep(0.,0.01,abs(pos.x));\n            col*=smoothstep(0.,0.01, line(vec2(abs(pos.x)-0.16,pos.y), vec2(0.,0.14),vec2(0.14,0.18),0.001));\n            col*=smoothstep(0.,0.01, line(vec2(abs(pos.x)-0.16,pos.y+0.04), vec2(0.,0.14),vec2(0.15,0.15),0.001));\n            col*=smoothstep(0.,0.01, line(vec2(abs(pos.x)-0.16,pos.y+0.08), vec2(0.,0.14),vec2(0.15,0.13),0.001));\n        }\n    }\n    else if(obj_id==BODY)\n    {\n        col=vec3(0.,0.5,1.0); \n        if(pos.z<0.&&length(vec2(pos.x,pos.y+.6))<.22)col=vec3(0.9);\n    }\n    else if(obj_id==NOSE)\n        col=vec3(.4,0.,0.);\n    else if(obj_id==BELL)\n        col=vec3(1.2,0.7,0.);\n    else if(obj_id==HAND)\n        col=vec3(.9);\n    else if(obj_id==BASE)\n        col=vec3(0.05,0.1,0.2);\n    else if(obj_id==CONTROL)\n        col=vec3(.9,.7,.5);\n    else if(obj_id==CONTROL_FRONT)\n    {\n        col=vec3(.9,.7,.5);\n        // pos.y -1.x -> -0.7\n        col=mix(vec3(1.,0.2,0.),col,pow(smoothstep(0.,0.04, line(vec2(pos.x,pos.y), vec2(-0.5,-0.8),vec2(0.5,-0.8),0.001)),40.));\n        col=mix(vec3(1.,0.2,0.),col,pow(smoothstep(0.,0.04, line(vec2(pos.x,pos.y), vec2(-0.5,-0.9),vec2(0.5,-0.9),0.001)),40.));\n        col=mix(vec3(1.,0.2,0.),col,pow(smoothstep(0.,0.04, line(vec2(pos.x,pos.y), vec2(-0.5,-1.),vec2(0.5,-1.),0.001)),40.));\n        \n    }\n    else if(obj_id==HANDLE1)\n        col=vec3(0.,0.1,0.3);\n    else if(obj_id==FUEL)\n        col=vec3(0.01,0.04,0.1);\n    else if(obj_id==HANDLE2||obj_id==SOFA)\n        col=vec3(0.1,0.,0.04);\n    else if(obj_id==LIGHT)\n    {\n        // pixel light\n        vec2 frp=abs(fract(pos.xz*10.));\n        frp=pow(frp, vec2(4.));\n        float edge=max(0.,1.-(frp.x+frp.y));\n        vec2 flp=floor(pos.xz*10.);\n        float k=dot(sin(flp+cos(flp.yx*2.+iTime*2.)),vec2(.5));\n        col=nor.y<0.? 10.*edge*vec3(pow(k,.7)*2., 4.*pow(k, 1.5), pow(k,2.)) : vec3(.9,.7,.5);\n    }\n    return col;\n}\n\nvec3 get_doraemon_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*doraemon(p+0.001*e);\n    }\n    return normalize(n);\n}\n\nvec3 get_timemachine_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*timemachine(p+0.001*e);\n    }\n    return normalize(n);\n}\n\nvec3 lighting_doraemon(vec3 rd, vec3 pos, float ps,float hitinfo, float t)\n{\n    vec3 l1dir=normalize(vec3(1.0,2.,-1.));\n    vec3 l1col=vec3(1.,0.8,0.8);\n    \n    vec3 e=vec3(0.5*ps,0.0,0.0); \n    vec3 nor;\n\n    if(hitinfo<.9)\n        nor=get_doraemon_normal(pos);\n    else\n        nor=get_timemachine_normal(pos);\n    \n    if(timemachine(pos)<doraemon(pos))obj_id=machine_id;\n    if(t>FAR&&obj_id==LIGHT)obj_id=CONTROL; // avoid weird artifacts, should find a bettwe way\n    \n    vec3 mate=material_doraemon(rd,pos,nor);\n    float ao=get_ao(pos,nor);\n    float dif=max(0.0,dot(nor,l1dir));\n    float bac=max(0.0,dot(nor,-l1dir));\n    float spe=max(0.0, pow(clamp(dot(l1dir, reflect(rd, nor)), 0.0, 1.0), 32.0));\n\n    vec3 lin=6.0*dif*l1col*ao;\n    lin+=1.*bac*l1col;\n    lin+=3.*spe*vec3(1.);\n    return lin*0.2*mate;\n}\n\nfloat pixel_size;\n\nvec4 intersect_doraemon(vec3 ro, vec3 rd, out vec3 hitinfo)\n{\n    hitinfo=vec3(0.,0.,1.);\n    float d_first=100.0, t_first=0.0;\n    float old_d=1000.0;\n    float d_max=1000.0, t_max=0.0;\n    float t=1.0;\n    float d=100.0;\n    float hitwho=0.,old_hitwho=0.;\n    \n    for(int i=0; i<64+min(0,iFrame); ++i) \n    {\n        hitwho=0.;\n        // splitting them is just for not crashing my windows laptop....\n        d=doraemon(ro+rd*t);\n        float d1=timemachine(ro+rd*t);\n        if(d1<d){hitwho=1.;d=d1;}\n\n        \n        if(d_first == 100.0)  // the first edge\n        {\n            hitinfo.x=hitwho;\n            if(d>old_d) \n            {\n                if(old_d<pixel_size * (t-old_d))\n                {\n                    d_first=old_d;\n                    t_first=t-old_d;\n                    hitinfo.x=old_hitwho;\n                }\n            }\n            old_d=d;\n            old_hitwho=hitwho;\n        }\n        if(d<d_max) // save the max occluder\n        { \n            t_max=t; \n            d_max=d;\n            hitinfo.y=hitwho;\n        }  \n        \n        if(d<0.00001 || t>FAR)\n            break;\n        t += d;\n        hitinfo.z=t;\n    }\n    return vec4(t_max, d_max, t_first, d_first);\n}\n\nfloat bounding_sphere(in vec3 ro, in vec3 rd, in vec4 sph)\n{\n    vec3 p=sph.xyz;\n    p=inverse_swing(p);\n    float t=-1.0;\n    vec3  ce=ro-p;\n    float b=dot(rd, ce);\n    float c=dot(ce, ce)-sph.w*sph.w;\n    float h=b*b - c;\n    if(h>0.0)\n    {\n        t=-b-sqrt(h);\n    }\n    \n    return t;\n}\n\nvec3 render_doraemon(vec3 ro, vec3 rd, vec3 bg)\n{\n    float t=bounding_sphere(ro,rd,vec4(0.,-0.35,0.,2.5));\n    if(t<=0. || t>1000.)\n        return bg;\n    \n    // first hit, max hit, t\n    vec3 hitinfo;\n    vec4 res=intersect_doraemon(ro,rd,hitinfo);\n    \n    float d_max, t_max, d_first, t_first;\n    t_max=res.x;\n    d_max=res.y;\n    t_first=res.z;\n    d_first=res.w;\n    vec3 nor,pos;\n    \n    vec3 col=bg;\n    \n    if(d_max < pixel_size*t_max) \n    {\n        pos=ro+rd*t_max;\n        col=mix(lighting_doraemon(rd, pos, pixel_size*t_max,hitinfo.y, hitinfo.z), col, \n                  clamp(d_max/(pixel_size * t_max), 0.0, 1.0));\n    }\n    float ratio=0.0;\n\n    if(d_first==100.0 || t_max==t_first)\n    {\n        t_first=t_max;\n        d_first=d_max;\n        ratio=0.5;\n    }\n    \n    pos=ro+rd*t_first;\n    col=mix(lighting_doraemon(rd, pos, pixel_size*t_first,hitinfo.x, hitinfo.z),\n              col, clamp(ratio+d_first/(pixel_size*t_first), 0.0, 1.0));\n    \n    return col;\n}\n\n\n#define CITY_MENGER 1\n#define CITY_ROAD 2\n\n#define VOXEL_GAP 0.1\n\nconst mat3 ma=mat3(0.6,0.,0.8,\n                   0.,1.,0.,\n                   -0.8,0.,0.6);\n\nvec4 city(vec3 p)\n{\n    p.y-=0.3;\n    obj_id=CITY_MENGER;\n    vec2 flp=floor(p.xz);\n    vec2 frp=fract(p.xz);\n    \n    frp-=0.5;\n    \n    vec2 rand;\n    rand=hash22(flp);\n    float height=0.4+rand.x*rand.x*1.7;\n    float d0=box(vec3(frp.x,p.y,frp.y),vec3(0.1,height,.4));   \n    \n    vec4 res=vec4(d0, 1.0, 0.0, 0.0);\n    \n    // menger spone from iq\n    // larger value gives higher density of rooms\n    // I like 1.1, 1.2, 1.7\n    float s=1.+.2*rand.y*(1.-step(1.6,height)); \n    vec3 q=p;\n    for(int m=0; m<4+min(0,iFrame); m++)\n    {      \n        p.y+=rand.y;\n        vec3 a=mod(p*s, 2.0)-1.0;\n        s*=3.;\n        vec3 r=abs(1. - 3.0*abs(a));\n        float da=max(r.x,r.y);\n        float db=r.y;//max(r.y,r.z);\n        float dc=max(r.z,r.x);\n        float c=(min(da,min(db,dc))-1.)/s;\n\n        if(c>d0)\n        {\n          d0=c;\n          res=vec4(d0, min(res.y,.2*da*db*dc), (1.0+float(m))/4.0, 0. );\n        }\n    }\n   \n    if(q.y<res.x){obj_id=CITY_ROAD;res.x=q.y;}\n    return res;\n}\n\n\nvec3 get_city_normal(vec3 p)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*city(p+0.001*e).x;\n    }\n    return normalize(n);\n}\n\n#define CITY_ITER 250\n#define CITY_FAR 50.\n\nvec4 intersect_city_voxel(vec3 ro, vec3 rd)\n{\n    vec4 h=vec4(100.),res=vec4(-1);\n    float t = 0.05;\n    vec3 p=vec3(0.0);\n\n    for (int i=0; i<CITY_ITER+min(0,iFrame); i++)\n    {\n        if(h.x<0.0001+0.000125*t||t>CITY_FAR)\n        {\n            continue;\n        }\n        p=ro+rd*t;\n\n        h=city(p);\n\n        // 2d voxel marching the city blocks, as the boundaries are not continues\n        \n        float dx=-fract(p.x);\n        if (rd.x>0.) \n            dx=fract(-p.x);\n        \n        float dz=-fract(p.z);\n        if (rd.z>0.)\n            dz=fract(-p.z);\n        \n        float nearest=min(fract(dx/rd.x), fract(dz/rd.z))+VOXEL_GAP;\n        nearest=max(VOXEL_GAP, nearest);\n        \n        t+= min(h.x, nearest); \n        res=vec4(t,h.yzw);\n        \n    }\n    return res;\n}\n\nvec3 material_city(vec3 p, float night)\n{\n    vec3 col=vec3(0.4,0.6,1.0)*0.15;\n    vec4 res=city(p);\n    if(obj_id==CITY_MENGER)\n    {\n        res.z=1.-res.z;\n        col=(1.2*(1.-night)+0.8)* vec3(.5+res.z*res.z,.3+pow(res.z, 3.), res.z*res.z*0.9);\n        //col=vec3(res.z);  \n\n        if(night>0.5)\n        {\n            if(res.z<.25)\n                col=50.*vec3(1.2,0.3,0.);\n            else if(res.z<0.75)\n                col*=6.;\n        }\n        \n    }\n    else\n    {\n        p.z-=iTime*2.;\n        col+=(1.-smoothstep(0.01,0.025,abs(abs(p.x)-.25)))*vec3(1);\n        col=mix(col,vec3(1.2,0.7,0.),floor(fract(p.z)+.5)*(1.-smoothstep(0.01,0.02,abs(p.x)-0.001)));//*vec3(1);\n        // fake shadow\n        col*=(0.06+smoothstep(0.4,0.6,abs(abs(p.x+0.13)-0.7))); \n        col*=(0.06+smoothstep(0.4,0.6,-p.x+1.47))*vec3(1); \n    }\n    return col;\n}\n\nvec3 city_bg(vec3 ro, vec3 rd, float night)\n{\n    const vec3 moon_col=vec3(0.8,1.,1.);\n    const vec3 moon_dir=vec3(0,0,-1.);    \n    vec3 col;\n    \n    col=vec3(1.)-moon_col*smoothstep(-.1,0.,rd.y)*smoothstep(0.33,0.37,pow(max(dot(moon_dir, rd), 0.0), 32.0));\n\n    if(night>0.)\n        col=vec3(0.)+vec3(0.3,0.,0.)*smoothstep(-.1,0.,rd.y)*smoothstep(0.33,0.37,pow(max(dot(moon_dir, rd), 0.0), 32.0));\n    \n    return col;\n}\n\n\nfloat curve(in vec3 p, in float w)\n{\n    vec2 e=vec2(-1., 1.)*w;\n    \n    float t1=city(p+e.yxx).x, t2=city(p+e.xxy).x;\n    float t3=city(p+e.xyx).x, t4=city(p+e.yyy).x;\n    \n    return 0.0125/(w*w)*(t1+t2+t3+t4-4.*city(p).x);\n}\n\nvec4 render_city(vec3 ro, vec3 rd, float night)\n{\n    vec4 res=intersect_city_voxel(ro,rd);\n    vec3 col=city_bg(ro,rd,night);\n\n    if(res.x<CITY_FAR)\n    {\n       // if(city(ro+res.x*rd).x>0.005/res.x)\n         //   res.x=res.w;\n        vec3 pos=ro+res.x*rd;\n        vec3 nor=get_city_normal(pos);\n        vec3 l1dir=normalize(vec3(1.0,2.,-1.));\n        vec3 l1col=vec3(1.2,0.8,0.5);\n        \n        float ao=res.y*res.y;\n        if(obj_id==CITY_ROAD)\n            ao=1.;\n\n        vec3 mate=material_city(pos,night);\n        float dif=max(0.0,dot(nor,l1dir));\n        float bac=max(0.0,dot(nor,-l1dir));\n        float sky=0.5+0.5*nor.y;\n        float spe=pow(max(dot(reflect(-l1dir, nor), -rd), 0.0), 16.0);\n        float crv=clamp(1.-abs(curve(pos,0.0015)),0.,1.);\n\n        vec3 lin=4.0*(1.-night)*dif*l1col*ao;\n        lin+=3.*sky*vec3(0.1,0.2,0.5)*ao;\n        lin+=1.*bac*l1col*ao;\n        lin+=1.*spe*vec3(1.);\n        col=lin*crv*0.2*mate;\n        \n        vec3 skycol=vec3(1.-night);\n        if(rd.z<0.)\n            col=mix(col,vec3(.15,0,0),1.-exp(-0.005*res.x*res.x));\n        else col=mix(col,skycol,1.-exp(-0.001*res.x*res.x));\n       //col=vec3(lin);\n    }\n    return vec4(col,res.x);\n}\n\n\nvec3 tonemap(vec3 x) \n{\n    const float a=2.51;\n    const float b=0.03;\n    const float c=2.43;\n    const float d=0.59;\n    const float e=0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q=fragCoord/iResolution.xy;\n    vec2 p=q*2.-1.;\n    p.x*=iResolution.x/iResolution.y;\n    pixel_size=1.0/(iResolution.y);\n   \n     // debugging camera\n    //float x_rot=-iMouse.x/iResolution.x*PI*2.0;\n    //float y_rot=iMouse.y/iResolution.y*3.14*0.5 + PI/2.0;\n    //vec3 ro=vec3(0.,0.9,-2.*iTime)+vec3(cos(y_rot)*cos(x_rot),0.,cos(y_rot)*sin(x_rot))*10.;\n    //vec3 ta=vec3(0.,0.,-2.*iTime);\n   \n    float time=mod(iTime,40.);\n    vec3 ro,ro2;\n    if(time < 20.)\n    {\n        ro=vec3(0.,.9,-9.);\n        ro2=ro;\n        \n        if(time>10.)\n        {\n            ro.xz*=rot(-(time-10.)*0.07);\n        }\n    }\n    else\n    {\n        ro=vec3(0.,.9,9.);\n        ro2=ro;\n    }\n\n    ro.z-=2.*iTime;\n    ro2.z-=2.*iTime;\n    vec3 ta=vec3(0.,0.,-2.*iTime);\n    \n    \n    vec3 f=normalize(ta-ro);\n    vec3 r=normalize(cross(f,vec3(0.,1.,0.)));\n    vec3 u=normalize(cross(r,f));\n    \n    vec3 rd=normalize(r*p.x + u*p.y + f*2.3);\n    \n    vec3 timetunnel=tunnel(rd,-iTime*8.,.05);\n    vec3 menger=render_city(ro2,rd, 1.0-step(0.0,sin(0.05*(iTime+40.-14.)))).xyz;\n    \n    vec3 bg=mix(timetunnel,menger,1.-smoothstep(0.,1.,sin(0.1*(iTime+40.))));\n    vec3 col=render_doraemon(ro,rd,bg);\n    \n    // post processing\n    col=tonemap(col);\n    col=pow(clamp(col,0.,1.0),vec3(0.45));\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"fst3Rl","date":"1630480754","viewed":552,"name":"Poncelet-Blaschke triangle","description":"This animation shows the connection between Poncelet's triangle and degree 3 Blaschke product.\n\nSee the book  \"Finding Ellipses: What Blaschke Products, Poncelet's Theorem,  and the Numerical Range Know about Each Other\".","likes":18,"published":"Public API","usePreview":0,"tags":["2d","complex","geometry","blaschke","poncelet"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Poncelet's triangle and degree 3 Blaschke product.\n\nA Blaschke product B(z) of degree n is a mapping of the unit disc D to itself and has the form\n\nB(z) = \\prod_{i=1}^n (z - a_i) / (1 - conjugate(a_i)*z) where a_i, i=1,2,...,n are all in D.\n\nB(z) preserves ∂D. Further more, for each point P on ∂D, there are n preimages\nz1, ..., zn on ∂D such that B(z1) = ... = B(zn) = P.\n\nNow fix n=3, and let a, b be complex numbers in D. For simplicity we choose a, b\nboth are reals and a is always the origin. Let\n\nB(z) = z * (z-a)/(1-a*z) * (z-b)/(1-b*z)\n\nSo B(z) is a Blaschke product of degree 3 and it has zeros at 0, a, b.\n\nThen for each point P on ∂D, the preimages z1, z2, z3 form an inscribed triagle\nABC of D, interestingly, ABC is also the circumscribe triangle of an ellipse\nwith foci at a and b:\n\n|z - a| + |z - b| = |1 - conjugate(a)*b|.\n\nIn the animtion P is colored yellow, z1, z2, z3 are colored pink.\n\nTo show that I'm not cheating, I choosed a, b and draw the ellipse using the\nexpression as above, then solve the cubic equation B(z) = P for P moving along\nthe circle and draw the triangle ABC. You can see the triangle does circumscribe\nthe ellipse!\n\nThis result generalizes to Blaschke product of degree n, the curve that the n-gon\ncircumscribes is a Poncelet curve.\n\n*/\n#define PI 3.141592653\n\nvec3 rotHue(vec3 p, float a) {\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n              mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n              mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\n    return clamp(p*hr, 0., 1.);\n}\n\n\nvec2 cmul(vec2 p, vec2 q) {\n    return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);\n}\n\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\nvec2 csqrt(vec2 p) {\n    float a = atan(p.y, p.x) / 2.;\n    return vec2(cos(a), sin(a)) * sqrt(length(p));\n}\n\nvec2 ccubrt(vec2 z) {\n    float r = length(z);\n    r = pow(r, 1./3.);\n    float angle = atan(z.y, z.x);\n    return r * vec2(cos(angle / 3.0), sin(angle / 3.0));\n}\n\nvec2 cpow2(vec2 z) {\n    return cmul(z, z);\n}\n\nvec2 cpow3(vec2 z) {\n    return cmul(z, cmul(z, z));\n}\n\nvoid solveCubic(float b, vec2 k, inout vec2 z1, inout vec2 z2, inout vec2 z3) {\n    vec2 t1 = vec2(2.*b*b*b, 0) - 9.*b*b*k;\n    vec2 t2 = cpow2(t1 + 27.*k);\n    vec2 t3 = 3.*b*k - vec2(b*b, 0);\n    vec2 t4 = 4.*cpow3(t3);\n    vec2 s1 = ccubrt(csqrt(t4 + t2) + 27.*k + t1);\n    vec2 s2 = cdiv(t3, s1);\n    z1 = 0.264566842 * s1 - 0.41997368 * s2 + vec2(b/3.,0.);\n    z2 = cmul(vec2(-0.132283421, 0.2291216), s1) + cmul(vec2(0.209998684, 0.36371), s2) + vec2(b/3., 0);\n    z3 = cmul(vec2(-0.132283421, -0.2291216), s1) + cmul(vec2(0.209998684, -0.36371), s2) + vec2(b/3., 0);\n}\n\n// distance from a 2d point p to a 2d segment (a, b)\nfloat dseg(vec2 p, vec2 a, vec2 b) {\n    vec2 v = b - a;\n    p -= a;\n    float t = clamp(dot(p, v)/dot(v, v), 0., 1.);\n    return length(p - t * v);\n}\n\nvec3 cubehelix(vec3 c) {\n    vec2 sc = vec2(sin(c.x), cos(c.x));\n    return c.z * (1.0 + c.y * (1.0 - c.z) * (\n        sc.x * vec3(0.14861, 0.29227, -1.97294) +\n        sc.y * vec3(1.78277, -0.90649, 0.0)\n        ));\n}\n\nvec3 rainbow(float t) {\n    return cubehelix(vec3(\n        2. * PI * t - 1.74533,\n        (0.25 * cos(2. * PI * t) + 0.25) * vec2(-1.5, -0.9) + vec2(1.5, 0.8)\n        ));\n}\n\n// iq's triangle signed distance function\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ) {\n    vec2 e0 = p1 - p0;\n    vec2 e1 = p2 - p1;\n    vec2 e2 = p0 - p2;\n\n    vec2 v0 = p - p0;\n    vec2 v1 = p - p1;\n    vec2 v2 = p - p2;\n\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// ellipse signed distance function\nfloat sdEllipse( vec2 p, vec2 cen, in vec2 ab ) {\n    p -= cen;\n    vec2 pab = p / (ab * ab);\n    return (0.5 * dot(pab, p) - 0.5) / length(pab);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float sf = 2. / iResolution.y;\n    vec2 p = uv * 1.1;\n\n    mat2 foci;\n    float b = sin(iTime) * 0.3 + 0.6;\n    // for a fixed ellipse, you can see each point on the unit cicle is a Poncelet point.\n    //float b = 0.6;\n    foci[0] = vec2(0);\n    foci[1] = vec2(b, 0);\n\n    vec2 k = vec2(cos(iTime), sin(iTime));\n    vec2 A, B, C;\n    solveCubic(b, k, A, B, C);\n\n    // distance to the triangle\n    float dtri = sdTriangle(p, A, B, C);\n    float dcirc = length(p) - 1.;\n\n    vec2 cen = vec2(b*0.5, 0);\n    vec2 ab = vec2(0.5, sqrt(1.-b*b)/2.);\n    float dellipse = sdEllipse(p, cen, ab);\n    float dfoci = min(length(p), length(p - foci[1])) - 0.04;\n\n    float sgn = dellipse < 0. ? -2. : (dtri < 0. ?  0. : 1.);\n\n    vec3 col = vec3(0.4, 0.7, 0.4) - sgn*vec3(0.2, 0., 0.2);\n    col = rotHue(col, sgn + 5.);\n    const float numlines = 30.;\n    for (float i=0.; i<numlines; i+=1.0) {\n        vec2 Q = vec2(cos(i/numlines*2.*PI), sin(i/numlines*2.*PI));\n        vec2 z1, z2, z3;\n        solveCubic(b, Q, z1, z2, z3);\n        float ds = dseg(p, z1, z2);\n        ds = min(ds, dseg(p, z2, z3));\n        ds = min(ds, dseg(p, z3, z1));\n        col = mix(col, rainbow(i/numlines), 1.-smoothstep(0., 0.003+2.*sf, ds));\n    }\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dtri)-0.01);\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dcirc)-0.01);\n    col *= smoothstep(0.005, 0.005+2.0*sf, abs(dellipse)-0.005);\n    col = mix(col, vec3(0.91, 0.1, 0.1), 1.-smoothstep(0., 0.005+2.*sf, dseg(p, foci[0], foci[1])-0.01));\n\n    // decorate the vertices and foci\n    mat4x2 verts; verts[0] = A; verts[1] = B; verts[2] = C, verts[3] = k;\n    float lw = 0.02;\n    for (int i=0; i<4; i++) {\n        float dv = length(p - verts[i]) - .08;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        if (i < 3)\n            col = mix(col, vec3(1, .5, .8), 1. - smoothstep(0., sf, dv + lw*1.6));\n        else\n            col = mix(col, vec3(1, 1., .2), 1. - smoothstep(0., sf, dv + lw*1.6));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv + .08 - lw));\n    }\n    for (int i=0; i<2; i++) {\n        float dv = length(p - foci[i]) - .06;\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dv))*.5);\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv));\n        col = mix(col, vec3(.4, .6, 1.), 1. - smoothstep(0., sf, dv + lw*1.2));\n        col = mix(col, vec3(0), 1. - smoothstep(0., sf, dv + .065 - lw));\n    }\n\n    col *= 1.25 - 0.4*length(p);\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"fdK3RD","date":"1631196606","viewed":1018,"name":"Rouché - winding number theorem","description":"Rouché's theorem in complex analysis","likes":23,"published":"Public API","usePreview":0,"tags":["2d","complexanalysis"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nWinding number theorem:\n\nA man is walking his dog along closed paths represented by f(z) and g(z),\nrespectively. If the man holds the leash tight enough to prevent the dog\nfrom touching the tree throughout their walk, they will circle the tree the\nsame number of times when they return to their initial positions.\n\nRouché's theorem:\n\nWhen f and g are analytic functions in a region that encloses the unit circle S\nand |f(z)| > |f(z) - g(z)| whenever z in S (here |f-g| is the length of the leash),\nthen f(S) and g(S) will circle the origin the same number of times, and this number\nequals the number of their zeros inside S.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    \n    vec2 p = uv * 9.;\n    p -= vec2(1.5, .5); // adjust the postion of the curves\n    vec2 O = vec2(0.5);\n\n    // Smoothing factor.\n    float sf = 8./iResolution.y;\n\n    // background color\n    vec3 col = vec3(1, .92, .75);\n    float hatch = doHatch(uv, iResolution.y);\n    col *= hatch*.2 + .8;\n    \n    vec2 e = vec2(.015, .03);\n    float le = length(e);\n\n    // curve width\n    float lw = .02;\n\n    float dc1 = dcurve(p, 0);\n    float dc2 = dcurve(p, 1);\n\n    float tA = mod(iTime*.2, 2.*PI);\n    float tB = max(0., tA + sin(iTime) * .1 - .1);\n    vec2 A0 = map1(0.), B0 = map2(0.);\n   \n    vec2 A = map1(tA);\n    vec2 B = map2(tB);\n    float dA = length(p - A) ;\n    float dB = length(p - B) ;\n\n    // dash grid lines\n    vec2 p1 = uv * 6.;\n    p1 -= floor(p1) + 0.5;\n    float bord = max(abs(p1.x), abs(p1.y))-0.49;\n    vec2 q1 = abs(mod(p1, 1./8.) - .5/8.);\n    float lines = (min(q1.x, q1.y) - .5/8./3.);\n    bord = min(bord, lines);\n    bord = step(0., bord);\n    \n    float dlink = dSegment(p, A, B);\n    // noisy background pattern\n    col *= fbm(p*48.)*.4 + .6;\n    // draw the grid lines\n    col = mix(col, vec3(0), bord*.8);\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*16., dc2))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*8., dc2 - lw*2.4));\n    col = mix(col, colorB, (1. - smoothstep(0., sf*4., dc2 - lw*1.6))*.8);\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*16., dc1))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*8., dc1 - lw*2.4));\n    col = mix(col, colorA, 1. - smoothstep(0., sf*4., dc1 - lw*1.6));\n\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*.7, dlink - 0.005))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*.7, dlink - .008));\n    col = mix(col, vec3(1, 1, .3), 1. - smoothstep(0., sf*.7, dlink));\n\n    lw *= 12.;\n\n    dA -= lw;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dA - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dA));\n    dA += .12;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA - .03));\n\tcol = mix(col, vec3(1, .8, .6), 1. - smoothstep(0., sf, dA)); \n    dA += .08;\n\tcol = mix(col, vec3(0), (1. - smoothstep(0., sf, dA))); \n\n    dB -= lw;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dB - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB - 0.04));\n\tcol = mix(col, colorB, 1. - smoothstep(0., sf, dB));\n    dB += .12;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB - .03));\n\tcol = mix(col, vec3(1, .8, .6), 1. - smoothstep(0., sf, dB)); \n    dB += .08;\n\tcol = mix(col, vec3(0), (1. - smoothstep(0., sf, dB)));\n    \n    float dA0 = length(p - A0);\n    dA0 -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dA0 - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA0 - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dA0));\n    dA0 += .06;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dA0));\n    \n    float dB0 = length(p - B0);\n    dB0 -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dB0 - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB0 - 0.04));\n\tcol = mix(col, colorB, 1. - smoothstep(0., sf, dB0));\n    dB0 += .06;\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dB0));\n \n    vec2 q = p - O;\n    float ci = length(q) - .7;\n    float sh = max(.75 - ci*4., 0.);\n    col = mix(col, vec3(0), (ss(sf*6., ci - .04))*.5);\n    col = mix(col, vec3(0), ss(sf, ci));\n    col = mix(col, vec3(1, .7, .4)*(ci + sh*sh*.1 + .5), ss(sf, ci + .03));\n    col = mix(col, col*1.6, ss(sf*4., ci + .15));\n   \tcol = mix(col, vec3(0), ss(sf, abs(ci + .1) - .01));   \n    col = mix(col, vec3(0), (ss(sf, length(q) - .18))*.5);\n    col = mix(col, vec3(0), ss(sf, abs(length(q) - .12) - .01));\n    col = mix(col, vec3(0), ss(sf, length(q) - .05));\n        \n    A -= O;\n    B -= O;\n    vec2 qA = rot2(atan(A.y, A.x-.5) -PI/2.) * q;\n    vec2 qB = rot2(atan(B.y, B.x)-PI/2.) * q;\n    float indA = distLine(qA - vec2(0, -.005), qA - vec2(0, .46)) - .01;\n    float indB = distLine(qB - vec2(0, -.005), qB - vec2(0, .3)) - .01;\n    \n    const float rad = .45;\n    const float aNum = 12.;\n    q = rot2(3.14159/aNum)*q;\n    float a = atan(q.y, q.x);\n    float ia = floor(a/6.283*aNum) + .5; // .5 to center cell.\n    ia = ia*6.283/aNum;\n    q = rot2(ia)*q;\n    q.x -= rad;\n        \n    // Markings.\n    float mark = sBox(q, vec2(.04, .022), 0.);\n    col = mix(col, vec3(.5), ss(sf, mark - .015));\n    col = mix(col, vec3(0), ss(sf, mark));\n        \n    // Indicator.        \n    col = mix(col, vec3(0), ss(sf, indA - .025));\n    col = mix(col, colorA, ss(sf, indA));\n    col = mix(col, vec3(0), ss(sf, indB - .025));\n    col = mix(col, colorB, ss(sf, indB));\n    \n    p -= vec2(-7.5, -3.);\n    p *= .8;\n    float ds1 = min(abs(length(p) - 1.), sqrt(dSegment(p, vec2(0), vec2(1, 0))));\n    col = mix(col, vec3(0.2), ss(sf, ds1 - 0.025));\n    float dr = distRoots(p);\n    col = mix(col, vec3(0.5, 0, 0), ss(sf, dr - .05));\n    col = mix(col, vec3(0.2), ss(sf, length(p - vec2(1, 0)) - .1));\n    \n    vec2 P = vec2(cos(tA), sin(tA));\n    float dP = length(p - P);\n    \n    dP -= lw * .5;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dP - 0.02))*.75);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dP - 0.04));\n\tcol = mix(col, colorA, 1. - smoothstep(0., sf, dP));\n\n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./16.)*1.05;\n\n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define NUM_SEGMENTS  100\n#define PI            3.141592653\n#define ss(a, b)      (1. - smoothstep(0., a, b))\n#define colorA   vec3(1, 0.2, 0.2)\n#define colorB   vec3(0.3, 1., .6)\n\n\nmat2 rot2(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n// complex multiplication\nvec2 cmul(vec2 p, vec2 q) {\n    return vec2(p.x*q.x-p.y*q.y, p.x*q.y+p.y*q.x);\n}\n\n// complex division\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\nvec2 transform(vec2 z, vec2 a) {\n    return cdiv(z - a, vec2(1, 0) - cmul(vec2(a.x, -a.y), z));\n}\n\nfloat n2D(vec2 p) {\n    const vec2 s = vec2(1, 113);\n    vec2 ip = floor(p); p -= ip;\n    vec4 h = vec4(0., s.x, s.y, s.x + s.y) + dot(ip, s);\n    p = p*p*(3. - 2.*p);\n    h = fract(sin(h)*43758.5453);\n    h.xy = mix(h.xy, h.zw, p.y);\n    return mix(h.x, h.y, p.x);\n}\n\nfloat fbm(vec2 p) {\n    return n2D(p)*.533 + n2D(p*2.)*.267 + n2D(p*4.)*.133 + n2D(p*8.)*.067; }\n\nfloat distLine(vec2 a, vec2 b) {\n    b = a - b;\n    float h = clamp(dot(a, b)/dot(b, b), 0., 1.);\n    return length(a - b*h);\n}\n\nfloat sBox(vec2 p, vec2 b, float r) {\n    vec2 d = abs(p) - b + r;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\nfloat dot2(in vec2 v) {\n    return dot(v, v);\n}\n\nfloat dSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return dot2(pa - ba*clamp(dot(pa,ba) / dot(ba,ba), 0.0, 1.0));\n}\n\nvec2 map1(float t) {\n    const float s = 2.;\n    vec2 p = vec2(cos(t), sin(t));\n    vec2 z = transform(p, vec2(.5, .7));\n    z = cmul(z, transform(p, vec2(-.6, 0.5)));\n    z = cmul(z, transform(p, vec2(-0.4)));\n    z = cmul(z, p - vec2(s, s));\n    return z;\n}\n\nfloat distRoots(vec2 p) {\n    float d = length(p - vec2(.5, .7));\n    d = min(d, length(p - vec2(-0.6, 0.5)));\n    d = min(d, length(p - vec2(-0.4)));\n    return d;\n}\n\nvec2 map2(float t) {\n    return map1(t) + vec2(cos(t) * 1.6, sin(t) * 1.2);\n}\n\nfloat dcurve(vec2 p, int index) {\n    float h = 0.05;\n    float t = 0.0;\n\n    vec2  a = index == 0 ? map1(t) : map2(t);\n    float d = dot2(p - a);\n\n    for(int i = 0; i < NUM_SEGMENTS; i++) {\n        vec2  b = index == 0 ? map1(t) : map2(t);\n        d = min(d, dSegment(p, a, b));\n        t += clamp(0.01*length(a-p)/length(a-b), 0.01, 0.15);\n        a = b;\n    }\n    return sqrt(d);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453);\n}\n\nfloat doHatch(vec2 p, float res) {\n    p *= res/16.;\n    float hatch;\n    float hRnd = hash21(floor(p*6.) + .73);\n    if(hRnd>.66) hatch = hRnd;\n    else if (hRnd > 0.33) hatch = clamp(sin((p.x - p.y)*3.14159*200.)*2. + .5, 0., 1.);\n    else hatch = clamp(sin((p.x + p.y)*3.14159*200.)*2. + .5, 0., 1.);\n    return hatch;\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"7dK3WD","date":"1631608166","viewed":940,"name":"Kleinian limit set","description":"Another Kleinian limit set. A mix of the work https://www.shadertoy.com/view/ttdXDl and  https://www.shadertoy.com/view/Wl3fzM","likes":36,"published":"Public API","usePreview":0,"tags":["2d","fractal","kleinian","limitset"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define L2(x)           dot(x, x)\n#define MAX_ITER        50\n\n\nbool doHalfPlane = true;\n\nconst vec2[] PARAMS = vec2[] (\n    vec2(1.8462756, 0.09627581),\n    vec2(1.958591, 0.011278),\n    vec2(1.857382, 0.076258),\n    vec2(1.64213876, 0.76658841),\n    vec2(1.658312, 0.5),\n    vec2(1.926434053, 0.027381792),\n    vec2(2, 0)\n);\n\nconst int NUM_PARAMS = PARAMS.length();\n\nfloat wrap(in float x, in float a, in float s) {\n    return mod(x - s, a) + s;\n}\n\nvec2 transA(in vec2 z, float a, float b, inout float scale) {\n    float k = 1. / dot(z, z);\n    z *= k;\n    scale *= k;\n    z.x -= b;\n    z.y = a - z.y;\n    return z;\n}\n\nbool separation(in vec2 z, in float a, in float b) {\n    float f = (z.x >= -b/2.0) ? 1.0 : -1.0;\n    float K = sign(b) * (2.0*a - 1.95) / 4.3;\n    float M = 7.2 - (1.95 - a) * 18.0;\n    return z.y >= 0.5*a + K*f*(1.0 - exp(-M*abs(z.x + b * 0.5)));\n}\n\nfloat kleinian(in vec2 z, vec2 pattern, float scale) {\n    float a = pattern.x, b = pattern.y;\n    float f = sign(b);\n    vec2 lz = z + vec2(1), llz = z - vec2(1);\n    for (int i = 0; i < MAX_ITER; i++) {\n        z.x = z.x + f * b / a * z.y;\n        z.x = wrap(z.x, 2.0, -1.0);\n        z.x = z.x - f * b / a * z.y;\n\n        if (separation(z, a, b)) {\n            z = vec2(-b, a) - z;\n        }\n\n        z = transA(z, a, b, scale);\n\t\t\n        // If the iterated points enters a 2-cycle, bail out.\n        if (dot(z-llz, z-llz) < 1e-6) {\n            return abs(z.y)  / scale;\n        }\n    \n       // If the iterated point gets outside z.y=0 and z.y=a, bail out.\n        if (z.y < 0.0)\n            return -z.y/scale;\n        if (z.y > a)\n            return (z.y - a)/scale;\n\n        llz=lz; lz=z;\n    }\n    return 1e3;\n}\n\n\nvec3 hsv2rgb(vec3 c) {\n    const vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 postprocess(vec3 col, vec2 q) {\n    col = pow(clamp(col, 0.0, 1.0), vec3(1.0/2.2)); \n    col = col*0.6 + 0.4*col*col*(3.0 - 2.0*col);\n    col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n    col *= 0.5 + 0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.7);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    const float zoom = 3.;\n    \n    float time = mod(0.2*iTime, float(NUM_PARAMS));\n    int it = int(floor(time));\n    float ft = fract(time);\n    vec2 pattern = mix(PARAMS[it], PARAMS[(it+1) % NUM_PARAMS], smoothstep(0., 1., ft));\n    float scale = 1.2;\n    vec2 p = uv * 1.1;\n    \n    if (doHalfPlane) {\n        p.y += 1.0;\n        p *= 0.5*pattern.x;\n    }\n    else {\n        p -= vec2(0, -1);\n        float r2 = 2. / dot(p, p);\n        p *= r2;\n        scale *= r2;\n        p += vec2(0, -1);\n    }\n    float aa = 2. / iResolution.y;\n    \n    float d = zoom * kleinian(p, pattern, scale);\n    \n    float b = -0.125;\n    float t = 20.0;\n    const float lh = 1.25;\n    const vec3 lp1 = vec3(.5, .5, lh);\n    const vec3 lp2 = vec3(-0.5, .5, lh);\n    \n    vec3 ro = vec3(0, 0, t);\n    vec3 pp = vec3(p, 0);\n    \n    vec3 rd = normalize(pp - ro);\n\n    vec3 ld1 = normalize(lp1 - pp);\n    vec3 ld2 = normalize(lp2 - pp);\n\n    float bt = -(t-b)/rd.z;\n  \n    vec3  bp   = ro + bt*rd;\n    vec3  srd1 = normalize(lp1 - bp);\n    vec3  srd2 = normalize(lp2 - bp);\n    float bl21 = L2(lp1 - bp);\n    float bl22 = L2(lp2 - bp);\n\n    float st1 = (0.0-b)/srd1.z;\n    float st2 = (0.0-b)/srd2.z;\n    vec3  sp1 = bp + srd1*st1;\n    vec3  sp2 = bp + srd2*st1;\n\n    float bd = zoom * kleinian(bp.xy, pattern, scale);\n    float sd1= zoom * kleinian(sp1.xy, pattern, scale);\n    float sd2= zoom * kleinian(sp2.xy, pattern, scale);\n\n    vec3 col = vec3(0.0);\n    const float ss = 15.0;\n  \n    col       += vec3(1)  * (1.0 - exp(-ss*(max(sd1, 0.0)))) / bl21;\n    col       += vec3(.5) * (1.0 - exp(-ss*(max(sd2, 0.0)))) / bl22;\n    float l   = length(p);\n    float hue = fract(0.75*l-0.3*iTime) + .5;\n    float sat = tanh(4.*l);\n    vec3 hsv  = vec3(hue, sat, 1.0);\n    vec3 bcol = hsv2rgb(hsv);\n    col       *= (1.0-tanh(0.25*l))*0.5;\n    col       = mix(col, bcol, smoothstep(-aa, aa, -d));  \n    col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n    \n    col = postprocess(col, fragCoord/iResolution.xy);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"NdK3zy","date":"1631768030","viewed":1241,"name":"Boyd-Maxwell ball packings","description":"Beautiful math produce beautiful images. This program draws 2d sections of 3d Boyd-Maxwell ball packings.","likes":30,"published":"Public API","usePreview":0,"tags":["2d","coxeter","hyperbolic","circlepacking"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n2d slices of 3D Boyd-Maxwell Ball packings\n\nauthors: Chen Hao: https://num.math.uni-goettingen.de/~hchen/\n         Zhao Liang: https://twitter.com/neozhaoliang\n\nReference: see Hao's Ph.D thesis:\n\n    https://refubium.fu-berlin.de/bitstream/handle/fub188/1147/diss_haochen.pdf?sequence=1&isAllowed=y\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThe name may sound unfamiliar to most people, but basically this is a kind of\nkaleidoscope structure in 4D hyperbolic space, we just draw their 2d slices here.\n\nFor a Coxeter group of rank 5 and level 2, the complement of its limit set form a dense\nball packing of the ideal boundary of hyperbolic 4-space, hence a ball packing of the\nEuclidean 3-space. We use z=c or y=c planes with varying c to see the circle packing patterns\non these slices.\n\n \nIn Hao's paper he listed out all Coxeter groups of level 2, the diagrams that\nhave 5 vertices with none of them surrounded by a blue box are all valid inputs for this program.\n\nUsage:\n\n1. Select a configuration below and uncomment it, or you can input one manually\n2. In common.frag, use `#define DrawLimitSet` to switch between the limit set view and circle packing view\n3. In common.frag, change `ZOOM` to zoom in/out.\n4. When drawing circle packings, use the bvec4 param 'isRealBall' to add/remove circles (explained below).\n5. In common.frag, use `#define DrawVerticalSections` to show vertical sections (suggested by @mla)\n\nExample:\n\nThis is a rank 5 group of level 2:\n     \n     v2\n     x\n       \\   5\n     |  o --- o --- x\n     | / v4   v1    v0\n     x\n     v3\n     \nEach vertex in the diagram represents a 'virtual mirror' in 3d space (a plane or a sphere),\nthe labels on the edges indicate the angles between the mirrors.\n\nA vertex drawn by `x` means it has a `real ball` correspondes to it,\nA vertex drawn by `o` means it does not have a real ball correspondes to it.\nThere are always 5 virtual balls and at least one real ball.\n\nIf we iteratively reflect the real balls across the virual balls, we will eventually get a dense packing of\nthe 3d space.\n\nThe set of virtual balls are called coclusters, the set of real balls are called clusters.\n\nYou can see there is a Euclidean triangle (333) in the diagram, this holds for almost all groups of rank 5 and level 2.\n\nThe input data requires you specify:\n\nparam 1:\n\nThe type of the Euclidean triangle, must be one of 244, 236 or 333. In this example it's 333.\nThese virual mirrors are labelled as v2, v3, v4.\n\n| For the remaining two vertices, at least one must be 'x', choose such one as v0. If both two are 'x',\n| choose either of them as v0, the remaining one is labelled v1.\n\nparam 2:\n\nThe labels between v0 and (v2, v3, v4), in this example it's (2, 2, 2) (in a Coxeter diagram\ndisjoint mirrors are orthogonal with each other, hence has dihedral angle PI/2, hence label 2)\n\nparam 3:\n\nThe labels between v1 and (v2, v3, v4), in this example it's (2, 2, 5). Note v1 and v4 are connected\nby an edge of label 5.\n\nparam 4:\n\nThe label between v0 and v1, in this example it's 3 (edges with labels 3 are represented by an unlabelled line)\n\nparam 5:\n\nFour bools indicate those virtual mirrors in (v1, v2, v3, v4) that have real balls corresponde to them.\nIn this example v2, v3 are represented by 'x', v1, v4 are represented by 'o', hence v2, v3 have real balls,\nwhile v1, v4 do not. So the four bools should be (false, true, true, false). Note by our choice v0 is\nalways 'x', so v0 has a real ball correspondes to it. This real ball is always the z=0 plane.\n\nSo the above diagram gives input\n\ninit(333, vec3(2, 2, 2), vec3(2, 2, 5), 3, bvec4(0, 1, 1, 0))\n\n\n!important:\n\nFor the 333 triangle, you can arbitrarily order them as (v2, v3, v4), it doesn't matter.\n\nBut for the 236 triangle, the ordering is fixed, you must label them as\n\n  6   3\n*---*---*\nv2  v3  v4\n\nAlso for the 244 triangle, the ordering must be\n\n  4   4\n*---*---*\nv2  v3  v4\n\n\nI have included ~60 examples below, a complete list would contain around ~180+ diagrams,\naccording to Hao's enumeration. You can find other diagrams in his thesis paper.\n\nNote: \n\n1. Some diagrams may give equivalent packings, though the visual effects are different.\n2. The bvec param 'isRealBall' does not take effect in the 'limit set' view in most times,\nit's mainly used for adding/removing circles in the circle packing view. You can change some\n1's in it to 0 to remove the corresponding real balls, hence produce holes in the pattern.\n*/\n\n\n#define TT (iTime+1.)\n//#define MS iMouse\n#define MS ((2.0*iMouse.xyz-iResolution.xyz)/iResolution.y)\n\n//*****************************************************************************\n\n//#define config init(236, vec3(2, 2, 2), vec3(3, 2, 2), 5., bvec4(0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 5), 3., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(3, 2, 2), 4., bvec4(0, 0, 0, 1))\n//#define config init(333, vec3(3, 3, 3), vec3(3, 3, 3), 3., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(3, 3, 2), vec3(2, 3, 3), 3., bvec4(1, 1, 0, 1))\n//#define config init(333, vec3(3, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(4, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 3, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(3, 2, 3), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 3, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 3), vec3(3, 3, 2), 5., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(2, 2, 3), vec3(3, 3, 2), 6., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(2, 3, 3), vec3(2, 3, 3), 2., bvec4(0, 0, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 3., bvec4(0, 0, 0, 0))\n//#define config init(244, vec3(2, 3, 2), vec3(2, 4, 2), 2., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 4., bvec4(0, 0, 0, 0))\n//#define config init(244, vec3(2, 2, 2), vec3(2, 3, 2), 5., bvec4(0, 1, 0, 1))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 3), 5., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 2, 3), 6., bvec4(0, 1, 0, 0))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 3, 2), 4., bvec4(0, 0, 0, 1))\n//#define config init(333, vec3(3, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(2, 2, 4), vec3(2, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 5), vec3(2, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 6), vec3(2, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 4), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(2, 2, 3), vec3(2, 2, 3), 2., bvec4(1, 0, 0, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(4, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 3), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(6, 2, 2), vec3(2, 2, 4), 2., bvec4(1, 0, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 6), 3., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 5), 3., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 4), 4., bvec4(0, 1, 1, 0))\n//#define config init(333, vec3(2, 2, 2), vec3(2, 2, 4), 3., bvec4(0, 0, 0, 0))\n//#define config init(236, vec3(2, 2, 3), vec3(3, 2, 6), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 4), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 3), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 3), vec3(3, 2, 5), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 4), vec3(3, 2, 4), 2., bvec4(1, 1, 1, 0))\n//#define config init(244, vec3(2, 2, 3), vec3(2, 3, 2), 5., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(3, 2, 4), 4., bvec4(0, 1, 1, 0))\n//#define config init(244, vec3(2, 4, 2), vec3(3, 2, 3), 2., bvec4(1, 1, 0, 1))\n//#define config init(236, vec3(2, 2, 6), vec3(3, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(2, 2, 5), vec3(3, 2, 3), 2., bvec4(1, 1, 1, 0))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 6), 3., bvec4(1, 1, 1, 1))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 5), 3., bvec4(1, 1, 0, 1))\n//#define config init(236, vec3(3, 2, 2), vec3(2, 2, 4), 3., bvec4(1, 0, 0, 1))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 5., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 5., bvec4(1, 1, 1, 1))\n//#define config init(333, vec3(5, 2, 2), vec3(2, 2, 6), 3., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 4), vec3(4, 2, 4), 2., bvec4(1, 1, 1, 1))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n//#define config init(236, vec3(2, 3, 2), vec3(3, 2, 4), 3., bvec4(1, 1, 0, 1))\n//#define config init(244, vec3(2, 2, 2), vec3(3, 2, 3), 4., bvec4(0))\n//#define config init(244, vec3(4, 2, 2), vec3(2, 2, 4), 4., bvec4(1, 1, 1, 1))\n//#define config init(236, vec3(2, 2, 2), vec3(2, 3, 2), 5., bvec4(0, 0, 0, 1))\n#define config init(244, vec3(3, 2, 2), vec3(2, 2, 3), 3., bvec4(1, 0, 0, 0))\n\n\n//*****************************************************************************\n\nfloat map(vec2 p, inout int index) {\n    vec2 mouse = MS.xy;\n    float k = 1.0;\n    if (MS.z > 0.0) {\n        p -= mouse;\n        k = dot(p,p);\n        p /= k;\n        p += mouse;\n    }\n    const float strong_factor = 4.;\n#ifdef DrawVerticalSections\n    vec3 q = vec3(p.x, TT*0.1, p.y + 1.);\n#else\n    vec3 q = vec3(p, mod(TT*0.2 - 0.01, SECTION_HEIGHT - 0.02) + 0.01);\n#endif\n    return k*DE(q, index) * strong_factor;\n    \n}\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 post_process(vec3 col, vec2 uv) {\n  col = pow(clamp(col, 0., 1.), vec3(1.0/2.2)); \n  col = col*0.6+0.4*col*col*(3.0-2.0*col);\n  col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col *= 0.5 + 0.5*pow(19.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.7);\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    config;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 p = 2. * uv - 1.;\n    p.x *= iResolution.x / iResolution.y;\n    p *= ZOOM;\n    float aa  = 2.0 / clamp(iResolution.y, 400., 800.);\n\n    int index, cid;\n    \n    float d = map(p, index);\n    cid = index;\n    \n    \n    float b = -0.4;\n    float t = 10.0;\n    const float lh = 2.;\n    const vec3 lp = vec3(2.5, 2.5, lh);\n    \n    vec3 ro = vec3(0, 0, t);\n    vec3 pp = vec3(p, 0);\n    \n    vec3 rd = normalize(pp - ro);\n\n    vec3 ld = normalize(lp - pp);\n    \n    float bt = -(t-b)/rd.z;\n  \n    vec3  bp   = ro + bt*rd;\n    vec3  srd = normalize(lp - bp);\n    float bl = L2(lp - bp);\n\n    float st = (0.0-b)/srd.z;\n    vec3  sp = bp + srd*st;\n\n    float bd = map(bp.xy, index);\n    float sd = map(sp.xy, index);\n\n    vec3 col = vec3(0);\n    const float ss = 15.0;\n    col       += vec3(1.)  * (1.0 - exp(-ss*(max(sd, 0.0)))) / bl;\n    float l   = length(p);\n#ifdef DrawLimitSet\n    float hue = fract(0.75*l-0.3*TT) + .45;\n#else\n    float hue = fract(0.15*l-0.3*TT) + .5;\n#endif\n    float sat = .9*tanh(4.*l);\n    vec3 hsv  = vec3(hue, sat, 1.0);\n    vec3 bcol = hsv2rgb(hsv);\n    \n    col       *= (1.0-clamp(tanh(0.75*l), 0., .1)) * 1.3;\n\n#ifdef DrawLimitSet\n    col       = mix(col, vec3(1), smoothstep(-aa, aa, -d));\n#else\n    col       = mix(col, bcol, 1. - step(-d, aa));\n#endif\n    col       += 0.5*sqrt(bcol.zxy)*(exp(-(10.0+100.0*tanh(l))*max(d, 0.0)));\n    \n    col = post_process(col, uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_ITER         30\n#define PI               3.141592653\n#define L2(x)            dot(x, x)\n#define ZOOM             4.\n#define inf              -1.\n\n// comment out this to show the circles\n#define DrawLimitSet\n\n\n// uncomment this to show the vertice sections\n//#define DrawVerticalSections\n\nfloat dihedral(float x) {\n    return x == inf ? 1. : cos(PI / x);\n}\n\nvec3 dihedral(vec3 v) {\n    return vec3(dihedral(v.x), dihedral(v.y), dihedral(v.z));\n}\n\nfloat SECTION_HEIGHT;\n\n// For spheres n is the center, r is the radius\n// For planes n is the normal vector, r is the distance between the plane and the origin\n// if invert is true then the inside/outside of the sphere is interchanged (not used in this program)\n// if hasRealBall is true then this virtual ball has a real ball correspondes to it\nstruct Ball {\n    bool isplane;\n    vec3 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[5] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[5] clusters;\n\n\n// create a ball. by default it's the z=0 plane with normal points to the negative half\nBall defaultBall() {\n    return Ball(false, vec3(0, 0, -1), 0., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec3 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        return k;\n    }\n    else\n        return length(p - B.n) - B.r;\n}\n\nBall from_plane(vec3 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec3 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec3 p, Ball B, inout float scale) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec3 cen = B.n;\n        float r = B.r;\n        vec3 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        return false;\n    }\n}\n\n// return distance to the scene, and get the index of the real ball hitted\nfloat DE(vec3 p, inout int index) {\n    float scale = 3.;\n    for (int i = 0; i < MAX_ITER; i++) {\n        bool cond = true;\n        for (int k = 0; k < 5; k++) {\n            cond = try_reflect(p, coclusters[k], scale) && cond;\n        }\n\n        if (cond)\n            break;\n    }\n    index = 0;\n#ifdef DrawLimitSet\n    float d = abs(p.z);\n    for (int j = 1; j < 5; j++) {\n        if (clusters[j].isRealBall) {\n            float d1 = abs(sdistanceToBall(p, clusters[j]));\n            if (d1 < d) { d = d1; index = j; }\n        }\n    }\n#else\n    float d = p.z;\n    for (int j = 1; j < 5; j++) {\n        if (clusters[j].isRealBall) {\n            float d1 = sdistanceToBall(p, clusters[j]);\n            if (d1 < d) { d = d1; index = j; }\n        }\n    }\n    \n#endif\n    return d / scale;\n}\n\n// solve M*v = b, where v = (x, y, r) is the xy-coordinate of the center of the ball,\n// r is the radius of the ball.\nBall solveBall(mat3 M, vec3 b) {\n    vec3 p = b * inverse(M);\n    return from_sphere(vec3(p.xy, 0.), p.z);\n}\n\n// Solve a ball with its center has xy-coordinates P, and is orthogonal to other two Balls B0, B1.\n// Here B0 may be either a sphere or a plane, B1 is always a sphere. \nBall solveBall(vec2 P, Ball B0, Ball B1) {\n    if (B0.isplane) {\n        float z = B0.r;\n        vec3 cen = vec3(P, z);\n        float R = sqrt(L2(cen - B1.n) - B1.r*B1.r);\n        return from_sphere(cen, R);\n    }\n    else {\n        float r1 = B1.r;\n        float r0 = B0.r;\n        float z0 = B0.n.z;\n        float k0 = L2(P - B0.n.xy);\n        float k1 = L2(P - B1.n.xy);\n        float z = (r1*r1 - r0*r0 + z0*z0 + k0 - k1) / (2.*z0);\n        float R = sqrt(k1 + z*z - r1*r1);\n        return from_sphere(vec3(P, z), R);\n    }\n    \n}\n\n// triangleType: must be one of 236, 244 or 333\n// dihedralAngles0: labels of the edges between v0 and (v2, v3, v4)\n// dihedralAngles1: labels of the edges between v1 and (v2, v3, v4)\n// dihedralAngles0_1: label of the edge between (v0, v1)\n// isRealBall: specify which of (v1, v2, v3, v4) has real balls\nvoid init(int triangleType,\n          vec3 dihedralAngles0,\n          vec3 dihedralAngles1,\n          float dihedralAngle0_1,\n          bvec4 isRealBall) {\n    const float s2 = sqrt(2.);\n    const float s3 = sqrt(3.);\n    mat3 M0, M1;\n    vec3 b;\n    Ball B0, B1, B2, B3, B4;\n    vec3 t0 = dihedral(dihedralAngles0);\n    vec3 t1 = dihedral(dihedralAngles1);\n    float t01 = dihedral(dihedralAngle0_1);\n    // A, B, C are the vertices of the triangle formed by mirror plane v2, v3, v4 and z=0 plane\n    vec2 A, B, C;\n\n    // the 236 case\n    if (triangleType == 236) {\n        A = vec2(0, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s3/2., -0.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(s3/2., 0.5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(s3/2., 0.5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s3/2., 0);\n    }\n    \n    // the 244 case\n    else if (triangleType == 244) {\n        A = vec2(0, 0), B = vec2(0, 1), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s2/2., -s2/2., 0), s2/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(1./s2, 1./s2, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(1./s2, 1./s2, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s2/2., 0);\n    }\n    \n    // the 333 case\n    else {\n        A = vec2(-1, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(s3/2., -.5, 0), s3/2.);\n        B3 = from_plane(vec3(-s3/2., -.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(-s3/2., 0.5, t1.x), vec3(s3/2., .5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(-s3/2., 0.5, t0.x), vec3(s3/2., .5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(s3, s3, 0)/2.;\n    }\n    \n    // now we solve the virtual ball B1, this can't be a plane\n    B1 = solveBall(M1, b);\n    invertBall(B1);\n    \n    // now we solve the virtual ball B0, this can be either a plane or a sphere\n    // this depends on if all entries in dihedralAngles0 are all 2\n    if (dot(dihedralAngles0, vec3(1)) == 6.) {\n        B0 = from_plane(vec3(0, 0, -1), B1.r*t01);\n    }\n    else {\n        B0 = solveBall(M0, b);\n        float r1 = B1.r, r0 = B0.r;\n        B0.n.z = sqrt(r0*r0 + r1*r1 + 2.*r0*r1*t01 - L2(B1.n.xy - B0.n.xy));\n        invertBall(B0);\n    }\n    coclusters = Ball[5] (B0, B1, B2, B3, B4);\n    \n    SECTION_HEIGHT = B0.isplane ? 2.*B0.r : B0.n.z;\n    \n    //now we process the real balls\n    for (int k = 0; k < 5; k++)\n        clusters[k] = defaultBall();\n        \n    if (isRealBall.x) {\n        clusters[1] = from_plane(vec3(0, 0, -1.), B0.n.z);\n        clusters[1].isRealBall = true;\n    }\n    if (isRealBall.y) {\n        clusters[2] = solveBall(C, B0, B1);\n        clusters[2].isRealBall = true;\n    }\n    if (isRealBall.z) {\n        clusters[3] = solveBall(A, B0, B1);\n        clusters[3].isRealBall = true;\n    }\n   \n    if (isRealBall.w) {\n        clusters[4] = solveBall(B, B0, B1);\n        clusters[4].isRealBall = true;\n    }\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"7dcXDB","date":"1633863097","viewed":1210,"name":"Hyperbolic tilings: intro","description":"This is similar to Shane's work https://www.shadertoy.com/view/WlBczG but uses a different approach.","likes":26,"published":"Public API","usePreview":0,"tags":["2d","tiling","hyperbolic","poincare"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    A mimic of shane's work at https://www.shadertoy.com/view/WlBczG\n    But using a more general approach.\n\n    Show the basic procedure to draw a 2d hyperbolic Poincare tiling.\n\n    Also can draw paracompact and noncompact tilings (with ideal and hyperideal\n   vertices)\n\n*/\n// show the three reflection mirrors\n//#define debug_mirrors\n\n// comment out this to see the initial pattern\n#define enableMouseInversion\n\n// change to Klein model\n//#define KleinModel\n\n// set inf = 1.0 for paracompact tiling\n// and inf > 1.0 for noncompact tiling\n#define inf 1.0\n\n#define PI 3.14159265\n#define TAU 6.28318531\n#define MAX_ITER 30\n\n// the smaller this value, the larger the black area\n#define BlackRegionSize 0.065\n\n// the first entry in PQR must be finite, other two entries can be either finite\n// or infinite for example (3, inf 4), (3, 4, inf), etc\nconst vec3 PQR = vec3(3, 3, 7);\n\n// reflection mirrors, two lines and a circle\nvec2 A, B; // normal vectors of the two lines\nvec3 C;    // (center, radius)\n\n// two vertices of the fundamental triangle, the 3rd one is the origin\nvec2 v0, m0;\n\n// count the total number of reflections\nfloat count;\n\n// compute cos(PI / x) using Vinberg's convention for inf.\nfloat dihedral(float x) { return x == inf ? inf : cos(PI / x); }\n\nmat2 rot2(in float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nvoid init() {\n\n    float cAB = dihedral(PQR.x);\n    float sAB = sqrt(1. - cAB * cAB);\n\n    A = vec2(1, 0);\n    B = vec2(-cAB, sAB);\n\n    float cAC = dihedral(PQR.y);\n    float cBC = dihedral(PQR.z);\n\n    float k1 = cAC;\n    float k2 = (cBC + cAB * cAC) / sAB;\n    float r = 1. / sqrt(k1 * k1 + k2 * k2 - 1.);\n\n    C = vec3(k1, k2, 1.) * r;\n\n    if (r * r >= C.x * C.x)\n        v0 = vec2(0., C.y - sqrt(r * r - C.x * C.x));\n    else\n        v0 = vec2(0, 1);\n\n    vec2 n = vec2(-B.y, B.x);\n    float b = dot(C.xy, n);\n    float c = dot(C.xy, C.xy) - r * r;\n    float k = -1.0;\n\n    if (b * b >= c)\n        k = b + sqrt(b * b - c);\n\n    m0 = k * n;\n}\n\nbool try_reflect(inout vec2 p, vec2 mirror, inout float count) {\n    float k = dot(p, mirror);\n    if (k >= 0.)\n        return true;\n    p -= 2. * k * mirror;\n    count += 1.;\n    return false;\n}\n\nbool try_reflect(inout vec2 p, vec3 sphere, inout float count) {\n    vec2 cen = sphere.xy;\n    float r = sphere.z;\n    float d = length(p - cen) - r;\n    if (d >= 0.)\n        return true;\n    p -= cen;\n    p *= r * r / dot(p, p);\n    p += cen;\n    count += 1.;\n    return false;\n}\n\nvoid fold(inout vec2 p, inout float count) {\n    count = 0.;\n    for (int k = 0; k < MAX_ITER; k++) {\n        try_reflect(p, A, count);\n        try_reflect(p, B, count);\n        try_reflect(p, C, count);\n    }\n}\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang) * (p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew) / 2.);\n}\n\nvec2 mouseInversion(vec2 p) {\n    vec2 m = vec2((2. * iMouse.xy - iResolution.xy) / iResolution.y);\n    if (length(m) < 1e-3)\n        m += 1e-3;\n    if (abs(m.x) > .98 * .7071 || abs(m.y) > .98 * .7071)\n        m *= .98;\n\n    float k = 1. / dot(m, m);\n    vec2 invCtr = k * m;\n    float t = (k - 1.) / dot(p - invCtr, p - invCtr);\n    p = t * p + (1. - t) * invCtr;\n    p.x = -p.x;\n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 1.05;\n    vec2 p = uv;\n\n#ifdef enableMouseInversion\n    p = mouseInversion(p);\n    p = rot2(iTime / 16.) * p;\n#endif\n\n    init();\n\n    if (length(p) > 1.)\n        p /= dot(p, p);\n\n#ifdef KleinModel\n    p = p / (1. + sqrt(1. - dot(p, p)));\n#endif\n\n    fold(p, count);\n\n    float lw = 0.002;\n\n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, vec2(0), v0, lw));\n    ln = min(ln, lBox(p, vec2(0), m0, lw));\n    ln = min(ln, length(p - C.xy) - C.z - lw);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, lw));\n    pnt = min(pnt, length(p - v0));\n    pnt = min(pnt, length(p - m0));\n\n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2. / iResolution.y * ssf;\n\n    vec3 oCol = .55 + .45 * cos(count * TAU / 8. + vec3(0, 1, 2));\n    float pat = smoothstep(0., .25, abs(fract(ln2 * 50. - .2) - .5) * 2. - .2);\n\n    float sh = clamp(.65 + ln / v0.y * 4., 0., 1.);\n\n    vec3 col = min(oCol * (pat * .2 + .9) * sh, 1.);\n\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    col = mix(col, vec3(1, .8, .3), 1. - smoothstep(0., sf, pnt + .02));\n\n    vec3 bg = vec3(1, .2, .4);\n    bg *= .7 *\n          (mix(col, vec3(1) * dot(col, vec3(.299, .587, .114)), .5) * .5 + .5);\n    pat = smoothstep(0., .25,\n                     abs(fract((uv.x - uv.y) * 43. - .25) - .5) * 2. - .5);\n    bg *= max(1. - length(uv) * .5, 0.) * (pat * .2 + .9);\n\n    float cir = length(uv);\n    col = mix(col, vec3(0),\n              (1. - smoothstep(0., sf * 10., abs(cir - 1.) - .05)) * .7);\n    col =\n        mix(col, vec3(0), (1. - smoothstep(0., sf * 2., abs(cir - 1.) - .05)));\n    col =\n        mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col * max(1. - length(uv) * .5, 0.),\n              (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.05)));\n\n    col = mix(col, vec3(0),\n              (1. - smoothstep(0., sf, abs(cir - 1.035) - .03)) * .8);\n    col = mix(col, 1. - exp(-col), .35);\n\n#ifdef debug_mirrors\n    col = mix(col, vec3(1, 0, 0),\n              1. - smoothstep(0., 0.01, abs(dot(uv, A)) - 0.01));\n    col = mix(col, vec3(1, 0, 0),\n              1. - smoothstep(0., 0.01, abs(dot(uv, B)) - 0.01));\n    col = mix(col, vec3(1, 0, 0),\n              1. - smoothstep(0., 0.02, abs(length(uv - C.xy) - C.z)) - 0.01);\n#endif\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"NstSDs","date":"1634176278","viewed":6208,"name":"Hyperbolic Group Limit Set","description":"old version of https://www.shadertoy.com/view/WdGBz3","likes":178,"published":"Public API","usePreview":0,"tags":["3d","tiling","hyperbolic","limitset"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n=============================================\n\nLimit set of rank 4 hyperbolic Coxeter groups\n\n                                by Zhao Liang\n=============================================\n\nThis program shows the limit sets of rank 4 hyperbolic Coxeter groups.\n\nSome math stuff:\n\nLet G be a hyperbolic Coxeter group, and let x be a point located\nwithin the hyperbolic unit ball. The orbit S_x = { gx | g \\in G }\nhas accumulation points (under the Euclidean metric) only on the\nboundary of the space. These accumulation points are called the limit\nset of the group. This set is independent of the choice of x, and it\nis the smallest closed subset of the boundary that remains invariant\nunder the action of the group.\n\nThe Coxeter-Dynkin diagram of a rank 4 Coxeter group of string type\nhas the form\n\n   A --- B --- C --- D\n      p     q     r\n\nHere A, B, D can be chosen as ususal Euclidean planes,\nC is a sphere orthongonal to the unit ball. This is taken from\n@mla's notation, and as far as I know this is also used by\nusers on fractalforums. (fragmentarium)\n\nIn this animation these points are colored in \"brass metal\".\n\n==========\n!important\n==========\n\nThe limit set is a closed set with no interior points, to show them\nwe have to use an approximate procedure: we simply try to reflect a\npoint p on the boundary back to the fundamental domain up to a maximum\nsteps, once failed then we think p belongs to the limit set.\n\n**So the number MAX_REFLECTIONS is an important parameter**,\nif it's set too high then little limit set will be shown, or if it's\nnot high enough then the boundary of the set will look too coarse,\nso beware of this.\n\nAs always, you can do whatever you want to this work.\n\nUpdate: thanks @mla for helping fix some bugs!\n\nYou can try more patterns like\n(3, 7, 3), (4, 6, 3), (4, 4, 5), (5, 4, 4), (7, 3, 4), ..., etc.\n5, 4, 4) is my favorite!\nSet PQR below to see the result.\nFor large PQRs the limit set will become too small to be visible,\nyou need to adjust MAX_REFLECTIONS and tweak with the function\nchooseColor to get appealling results.\n*/\n\n#define inf -1.\n\n// Try this one!\n// const vec3 PQR = vec3(6, 3, inf);\n\n// and this one!\n// const vec3 PQR = vec3(4, 4, 5);\n\nconst vec3 PQR = vec3(3, 3, 7);\n\n// --------------------------\n// some global settings\n\n#define MAX_TRACE_STEPS 100\n#define MIN_TRACE_DIST 0.1\n#define MAX_TRACE_DIST 100.0\n#define PRECISION 0.0001\n#define AA 2\n#define MAX_REFLECTIONS 500\n#define PI 3.141592653\n\n// another pattern\n//#define CHECKER1  vec3(0.196078, 0.33, 0.82)\n//#define CHECKER2  vec3(0.75, 0.35, 0.196078)\n\n/*\n#define CHECKER1  vec3(0.82, 0.196078, 0.33)\n#define CHECKER2  vec3(0.196078, 0.35, 0.92)\n#define MATERIAL  vec3(0.71, 0.65, 0.26)\n#define FUNDCOL   vec3(0., 0.82, .33)\n*/\n\n// Shane's color scheme\n#define CHECKER1 vec3(0., 0., 0.05)\n#define CHECKER2 vec3(0.2)\n#define MATERIAL vec3(10, 0.3, 0.2)\n#define FUNDCOL vec3(.3, 1, 8)\n\n// used to highlight the limit set\n#define LighteningFactor 8.\n// --------------------------\n\nvec3 A, B, D;\nvec4 C;\nfloat orb;\n\nfloat dihedral(float x) { return x == inf ? 1. : cos(PI / x); }\n\n// minimal distance to the four mirrors\nfloat distABCD(vec3 p) {\n    float dA = abs(dot(p, A));\n    float dB = abs(dot(p, B));\n    float dD = abs(dot(p, D));\n    float dC = abs(length(p - C.xyz) - C.w);\n    return min(dA, min(dB, min(dC, dD)));\n}\n\n// try to reflect across a plane with normal n and update the counter\nbool try_reflect(inout vec3 p, vec3 n, inout int count) {\n    float k = dot(p, n);\n    // if we are already inside, do nothing and return true\n    if (k >= 0.0)\n        return true;\n\n    p -= 2.0 * k * n;\n    count += 1;\n    return false;\n}\n\n// similar with above, instead this is a sphere inversion\nbool try_reflect(inout vec3 p, vec4 sphere, inout int count) {\n    vec3 cen = sphere.xyz;\n    float r = sphere.w;\n    vec3 q = p - cen;\n    float d2 = dot(q, q);\n    if (d2 == 0.0)\n        return true;\n    float k = (r * r) / d2;\n    if (k < 1.0)\n        return true;\n    p = k * q + cen;\n    count += 1;\n    orb *= k;\n    return false;\n}\n\n// sdf of the unit sphere at origin\nfloat sdSphere(vec3 p, float radius) { return length(p) - 1.0; }\n\n// sdf of the plane y=-1\nfloat sdPlane(vec3 p, float offset) { return p.y + 1.0; }\n\n// inverse stereo-graphic projection, from a point on plane y=-1 to\n// the unit ball centered at the origin\nvec3 planeToSphere(vec2 p) {\n    float pp = dot(p, p);\n    return vec3(2.0 * p, pp - 1.0).xzy / (1.0 + pp);\n}\n\n// iteratively reflect a point on the unit sphere into the fundamental cell\n// and update the counter along the way\nbool iterateSpherePoint(inout vec3 p, inout int count) {\n    bool inA, inB, inC, inD;\n    for (int iter = 0; iter < MAX_REFLECTIONS; iter++) {\n        inA = try_reflect(p, A, count);\n        inB = try_reflect(p, B, count);\n        inC = try_reflect(p, C, count);\n        inD = try_reflect(p, D, count);\n        p = normalize(p); // avoid floating error accumulation\n        if (inA && inB && inC && inD)\n            return true;\n    }\n    return false;\n}\n\n// colors for fundamental domain, checker pattern and limit set.\nvec3 chooseColor(bool found, int count) {\n    vec3 col;\n    if (found) {\n        if (count == 0)\n            return FUNDCOL;\n        else if (count >= 300)\n            col = MATERIAL;\n        else\n            col = (count % 2 == 0) ? CHECKER1 : CHECKER2;\n\n    } else\n        col = MATERIAL;\n\n    float t = float(count) / float(MAX_REFLECTIONS);\n    col = mix(MATERIAL * LighteningFactor, col,\n              1. - t * smoothstep(0., 1., log(orb) / 32.));\n    return col;\n}\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return p * cos(a) + vec2(-p.y, p.x) * sin(a); }\n\nvec2 map(vec3 p) {\n    float d1 = sdSphere(p, 1.0);\n    float d2 = sdPlane(p, -1.0);\n    float id = (d1 < d2) ? 0. : 1.;\n    return vec2(min(d1, d2), id);\n}\n\n// standard scene normal\nvec3 getNormal(vec3 p) {\n    const vec2 e = vec2(0.001, 0.);\n    return normalize(vec3(map(p + e.xyy).x - map(p - e.xyy).x,\n                          map(p + e.yxy).x - map(p - e.yxy).x,\n                          map(p + e.yyx).x - map(p - e.yyx).x));\n}\n\n// get the signed distance to an object and object id\nvec2 raymarch(in vec3 ro, in vec3 rd) {\n    float t = MIN_TRACE_DIST;\n    vec2 h;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        h = map(ro + t * rd);\n        if (h.x < PRECISION * t)\n            return vec2(t, h.y);\n\n        if (t > MAX_TRACE_DIST)\n            break;\n\n        t += h.x;\n    }\n    return vec2(-1.0);\n}\n\nfloat calcOcclusion(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.75;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) {\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 12; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, k * h / t);\n        t += clamp(h, 0.01, 0.2);\n        if (h < 0.0001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, vec3 lp, vec3 basecol) {\n    vec3 col = vec3(0.0);\n    vec3 ld = lp - pos;\n    float lDist = max(length(ld), .001);\n    ld /= lDist;\n    float ao = calcOcclusion(pos, nor);\n    float sh = softShadow(pos + 0.001 * nor, ld, 0.02, lDist, 32.);\n    float diff = clamp(dot(nor, ld), 0., 1.);\n    float atten = 2. / (1. + lDist * lDist * .01);\n\n    float spec = pow(max(dot(reflect(-ld, nor), -rd), 0.0), 32.);\n    float fres = clamp(1.0 + dot(rd, nor), 0.0, 1.0);\n\n    col += basecol * diff;\n    col += basecol * vec3(1., 0.8, 0.3) * spec * 20.;\n    col += basecol * vec3(0.8) * pow(fres, 5.0) * 2.;\n    col *= ao * atten * sh;\n    col += basecol * clamp(0.8 + 0.2 * nor.y, 0., 1.) * 0.5;\n    return col;\n}\n\nmat3 sphMat(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(cy, -sy * -sx, -sy * cx, 0, cx, sx, sy, cy * -sx, cy * cx);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 finalcol = vec3(0.);\n    int count = 0;\n    vec2 m = vec2(0.0, 1.0) + iMouse.xy / iResolution.xy;\n    float rx = m.y * PI;\n    float ry = -m.x * 2. * PI;\n    mat3 mouRot = sphMat(rx, ry);\n\n    // ---------------------------------\n    // initialize the mirrors\n\n    float P = PQR.x, Q = PQR.y, R = PQR.z;\n    float cp = dihedral(P), sp = sqrt(1. - cp * cp);\n    float cq = dihedral(Q);\n    float cr = dihedral(R);\n    A = vec3(0, 0, 1);\n    B = vec3(0, sp, -cp);\n    D = vec3(1, 0, 0);\n\n    float r = 1.0 / cr;\n    float k = r * cq / sp;\n    vec3 cen = vec3(1, k, 0);\n    C = vec4(cen, r) / sqrt(dot(cen, cen) - r * r);\n\n    // -------------------------------------\n    // view setttings\n\n    vec3 camera = vec3(3., 3.2, -3.);\n    vec3 lp = vec3(0.5, 3.0, -0.8); // light position\n    camera.xz = rot2d(camera.xz, iTime * 0.3);\n    vec3 lookat = vec3(0., -0.5, 0.);\n    vec3 up = vec3(0., 1., 0.);\n    vec3 forward = normalize(lookat - camera);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n\n    // -------------------------------------\n    // antialiasing loop\n\n    for (int ii = 0; ii < AA; ii++) {\n        for (int jj = 0; jj < AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * fragCoord + o - iResolution.xy) / iResolution.y;\n            vec3 rd = normalize(uv.x * right + uv.y * up + 3.0 * forward);\n            orb = 1.0;\n            // ---------------------------------\n            // hit the scene and get distance, object id\n\n            vec2 res = raymarch(camera, rd);\n            float t = res.x;\n            float id = res.y;\n            vec3 pos = camera + t * rd;\n\n            bool found;\n            float edist;\n            vec3 col;\n            // the sphere is hit\n            if (id == 0.) {\n                vec3 nor = pos;\n                vec3 q = pos * mouRot;\n                found = iterateSpherePoint(q, count);\n                edist = distABCD(q);\n                vec3 basecol = chooseColor(found, count);\n\n                col = getColor(camera, rd, pos, nor, lp, basecol);\n            }\n            // the plane is hit\n            else if (id == 1.) {\n                vec3 nor = vec3(0., 1., 0.);\n                vec3 q = planeToSphere(pos.xz);\n                q = q * mouRot;\n                found = iterateSpherePoint(q, count);\n                edist = distABCD(q);\n                vec3 basecol = chooseColor(found, count);\n                col = getColor(camera, rd, pos, nor, lp, basecol) * .9;\n            }\n            // draw the arcs\n            col =\n                mix(col, vec3(0.), (1.0 - smoothstep(0., 0.005, edist)) * 0.85);\n            col = mix(col, vec3(0.), 1.0 - exp(-0.01 * t * t));\n            finalcol += col;\n        }\n    }\n    finalcol /= (float(AA) * float(AA));\n\n    // ------------------------------------\n    // a little post-processing\n\n    finalcol = mix(finalcol, 1. - exp(-finalcol), .35);\n    fragColor = vec4(sqrt(max(finalcol, 0.0)), 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"NlcGRM","date":"0","viewed":0,"name":"Fork Motion Twe neozhaolia 288","description":"Creating a looping magnetized block animation using basic motion tweening techniques. ","likes":0,"published":"Private","usePreview":0,"tags":["motion","tweening","keyframe"]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n\n\tMotion Tweening\n\t---------------\n\n\tCreating a looping animation with magnetized blocks utilizing basic motion \n    tweening techniques. The animation sequence itself is a rough recreation \n    of a sequence I've seen around in GIF form on the internet. I'm not sure \n    where the original came from, but if I were to take a guess, I'd say it was \n    created by Andreas Wannerstedt, who produces a lot of mesmerizing looping \n    animations... but I wouldn't quote me on it.\n\n    I've been away for a while, so wanted to start with something relatively\n\tsimple. Motion tweening requires a bit of effort, but is relatively easy\n\trepetitive work. Demosceners do stuff like this all the time, but for those \n\tnot familar with the process, you just choose a total looping time \n    (tm = mod(iTime, totalTime)), then partition it into individual time segments \n    using a case statement, or some if-elseif statements. The segment intervals \n    themselves are filled with interpolated motion, distortion, morphing, etc.\n\n    As you can see, none of the individual movements are particularly complex;\n    rotations, pivots, translations, etc -- A lot of it was made up on the fly,\n\tso I'd imagine there'd be more efficient ways to achieve the same. One thing\n\tto note is that the colored cube moves in conjunction with the larger one, \n    which might throw some people off, but that's just a simple case of moving \n    the chrome looking box, setting the cube coordinates to the chrome box \n\tcoordinate system (p = pPrevious), then peforming more simple operations.\n\t\n    I seem to say this a lot, but apologies in advance for the extended compile\n\ttime. This should run pretty quickly, but the lengthy decision-making logic\n\tinside the raymarching loop taxes the compiler, which is amplified with the \n\treflection pass. By the way, you could simplify the objects and use IQ's \n    raytraced rounded-box intersection formulas to make this way, way more\n\tefficient. However, keeping track of the rotations for normal calculations, \n    and so forth, would get pretty tiresome... It's the kind of thing I'll leave \n    for Dr2 to do. :)\n\n\n\n    Other examples:\n\n\n    // This is one of the most clever and innovative examples on here.\n    [SH18] Human Document - reinder\n    https://www.shadertoy.com/view/XtcyW4\n\n*/\n\n#define FAR 30.\n\nvec4 vObjID;\nint objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n    \n    // Ryan Geiss effectively multiplies the first line by 7. It took me a while to realize that \n    // it's largely redundant, due to the division process that follows. I'd never noticed on \n    // account of the fact that I'm not in the habit of questioning stuff written by Ryan Geiss. :)\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n    \n    // Texure samples. One for each plane.\n    vec3 tx = texture(tex, p.yz).xyz;\n    vec3 ty = texture(tex, p.zx).xyz;\n    vec3 tz = texture(tex, p.xy).xyz;\n    \n    // Multiply each texture plane by its normal dominance factor.... or however you wish\n    // to describe it. For instance, if the normal faces up or down, the \"ty\" texture sample,\n    // represnting the XZ plane, will be used, which makes sense.\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n\n// Time variables.\nfloat tm, t, t2;\n\n// Animation segment ID.\nint segID = 0;\n\n\n\n\n// Distance function: This one is pretty simple.\nfloat map(vec3 p){\n\n\n    // Floor.\n    float fl = p.y;  //-sBoxS(p - vec3(0, 3, 0), vec3(6, 3, 6),.04);//min(p.y, -p.y + 3.8);\n    \n    \n\n   \n    const vec3 bDim = vec3(.25, .5, .25);\n    const vec3 bDim2 = vec3(.25, .25, .25);\n    vec3 svDim = bDim;\n\n    vec3 q = p, q2 = p;\n \n    \n    // The rendering portion is the easy bit; Just some standard distance\n    // field operations with IQ's box formula.\n    \n    \n    // The chrome box.\n    float obj = sdSponge(q);\n    \n    // The colored cube.\n    float obj2 = sierpinski(q); \n    \n\n\n    // Store the floor, chrome box and gold cube positions for sorting\n    // and surface identification outside the loop.\n    vObjID = vec4(fl, obj, obj2, 0);\n    \n    \n    // Return the minimum object.\n    return min(min(fl, obj), obj2);\n}\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = min(0, iFrame); i<80; i++){\n\n        d = map(ro + rd*t);\n        \n        // Using the hacky \"abs,\" trick, for more accuracy. \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        t += d;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = min(0, iFrame); i<48; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.001 || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(0, iFrame); i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .01, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 1.5, occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.25/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// The floor, chrome cube, and colored cube materials. These ones are pretty\n// basic, but you could put more effort in.\n//\nvec3 getObjectColor(vec3 p, vec3 r, vec3 n){\n    \n    \n    vec3 col;\n        \n    if(objID == 0) {\n       \n        // The floor.\n        vec3 tx = texture(iChannel0, p.xz/4.).xyz; tx *= tx;\n        col = tx*vec3(1, .7, .5)*.5;\n        \n    }\n    else if(objID == 2) {\n        \n        // The chrome colored box. It's something I tend to get, but tinging\n        // things blue can help bring about a metallic color... kind of. :)\n        col = vec3(.65, .85, 1);\n    }\n    else {\n        \n        // The cube. \n        col = vec3(2, 2, .45); // Redish gold.\n        //col = vec3(.7, 1.2, .3); // Green.\n        //col = vec3(2, .35, .85); // Pink.\n        //col = vec3(.3, 1, 2.5); // Blue.\n        //col = vec3(.3); // Grey\n    }\n    \n\n    // Adding some fake cube mapping information. The science is terrible, but it \n    // adds a bit of shine. :)\n    vec3 cTx = tex3D(iChannel0, reflect(r, n)/1.5, n);\n    cTx *= vec3(1, .8, .6);\n    \n    // Add a dose of fake reflection to the box and cube, and just a bit to the floor.\n    if(objID>0) col *= cTx*2.;\n    else col += cTx*.1;\n    \n    return col;\n\n}\n\n// Using the hit point, unit direction ray, etc, to color the \n// scene. Diffuse, specular, falloff, etc. It's all pretty \n// standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    \n    // Initiate the scene color to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){\n        \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), .0001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n        \n        float ao = calcAO(sp, sn);\n\n        // Attenuating the light, based on distance.\n        float atten = 1./(1. + lDist*.2 + lDist*lDist*.05);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n        \n        // Ramp up the diffuse value. Sometimes, it can help things look metallic.\n        diff = pow(diff, 4.)*2.;\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, rd, sn);\n        \n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*((diff + ao*.2) + vec3(1, .97, .92)*spec*4.);\n        \n        // Apply the attenuation and ambient occlusion.\n        sceneCol *= atten*ao;\n        \n    }\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .9, t/FAR);\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n    sceneCol = mix(sceneCol, vec3(0), fogF); \n\n    \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\n\n\nvec3 getRd(vec2 u, vec3 ro){\n   \n    // Camera Setup.     \n    vec3 lk = vec3(0, .5, 0);  // \"Look At\" position.\n\n \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/3.; // FOV - Field of view.\n    vec3 fw = normalize(lk - ro);\n    vec3 rt = normalize(vec3(fw.z, 0, -fw.x )); \n    vec3 up = cross(fw, rt);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(fw + (u.x*rt + u.y*up)*FOV);\n    // Warping the ray to give that curved lens effect.\n    //rd = normalize(vec3(rd.xy, rd.z*(1. - length(rd.xy)*.25)));\n    \n    return rd;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    // Aspect correct screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Slight barrel distortion.\n    float r = dot(uv, uv);\n    uv *= 1. + .2*(r*r + r);\n    \n    float cTm = iTime/2.;\n    vec3 ro = vec3(sin(cTm)*2.65, cos(tm)*sin(cTm)*.25 + 2.25, cos(cTm)*2.65);//vec3(0, 0, 0);\n    //vec3 ro = vec3(sin(cTm)*.75, cos(tm)*sin(cTm)*.25 + 2.25, -2.65);//vec3(0, 0, 0);\n \n    \n    vec3 rd = getRd(uv, ro);\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n\n    vec3 lp = vec3(1, 3, -1); // Light position. Set in the vicinity the ray origin.\n    \n    \n    // FIRST PASS.\n    \n    // Raymarch.\n    float t = trace(ro, rd);\n \n    // Obtain the current object ID.\n    objID = vObjID.x < vObjID.y && vObjID.x < vObjID.z? 0 : vObjID.y < vObjID.z? 1 : 2;\n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n    \n    // Retrieving the color at the hit point, which is now \"ro.\" I agree, reusing \n    // the ray origin to describe the surface hit point is kind of confusing. The reason \n    // we do it is because the reflective ray will begin from the hit point in the \n    // direction of the reflected ray. Thus the new ray origin will be the hit point. \n    // See \"traceRef\" below.\n    vec3 sceneColor = doColor(ro, rd, sn, lp, t);\n    \n    // Checking to see if the surface is in shadow. Ideally, you'd also check to\n    // see if the reflected surface is in shadow. However, shadows are expensive, so\n    // it's only performed on the first pass. If you pause and check the reflections,\n    // you'll see that they're not shadowed. OMG! Better call the shadow police. :)\n    float sh = softShadow(ro +  sn*.0015, lp, 12.);\n    sh = min(sh + .3, 1.);\n    \n    \n    // SECOND PASS - REFLECTED RAY\n    \n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that. Hopefully, it's common sense.\n    rd = reflect(rd, sn);\n    \n    \n    // The reflected pass begins where the first ray ended, which is the suface\n    // hit point, or in a few cases, beyond the far plane. By the way, for the sake\n    // of simplicity, we'll perform a reflective pass for non hit points too. Kind\n    // of wasteful, but not really noticeable. The direction of the new ray will\n    // obviously be in the direction of the reflected ray. See just above.\n    //\n    // To anyone who's new to this, don't forgot to nudge the ray off of the \n    // initial surface point. Otherwise, you'll intersect with the surface\n    // you've just hit. After years of doing this, I still forget on occasion.\n    t = traceRef(ro +  sn*.003, rd);\n    \n\n    // Obtain the current object ID.\n    objID = vObjID.x < vObjID.y && vObjID.x < vObjID.z? 0 : vObjID.y < vObjID.z? 1 : 2;\n    \n    // Advancing the ray origin, \"ro,\" to the new reflected hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the reflected hit point.\n    sn = getNormal(ro);\n    \n    // Coloring the reflected hit point, then adding a portion of it to the final scene color.\n    // How much you add, and how you apply it is up to you, but I'm simply adding 35 percent.\n    //sceneColor += doColor(ro, rd, sn, lp, t)*.5;\n    // Other combinations... depending what you're trying to achieve.\n    vec3 rCol = doColor(ro, rd, sn, lp, t);\n    sceneColor = sceneColor + rCol*.75;\n    \n    \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway. By the way, ambient\n    // occlusion would make it a little nicer, but we're saving cycles and keeping things simple.\n    sceneColor *= sh;\n    \n    \n    // Extra coloring.\n    //sceneColor *= vec3(1.1, 1, .9);\n\n    // Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    // presenting it to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Easing functions are their own topic, but a lot of it is straight forward.\n// Usage is easy. Normalize the time between zero and one, then choose the \n// one you're after.\n\nconst float PI = 3.14159265358979;\n\n// Robert Penner's easing functions in GLSL.\n// Available as a module for glslify. http://stack.gl/glsl-easings/\n\nfloat easeInOutCubic(float t){\n\n    return t<0.5 ? 4.*t*t*t : (t - 1.)*(2.*t - 2.)*(2.*t - 2.) + 1.;\n}\n\nfloat easeInOutQuint(float t){\n\n    return t<.5 ? 16.*t*t*t*t*t : 1. +16.*(--t)*t*t*t*t;\n}\n\nfloat easeOutQuad(float t) {\n    return -1. * t * (t - 2.);\n}\n\nfloat easeInQuad(float t) {\n    return t * t;\n}\n\n \nfloat bounceOut(float t) {\n    \n  const float a = 4.0 / 11.0;\n  const float b = 8.0 / 11.0;\n  const float c = 9.0 / 10.0;\n\n  const float ca = 4356.0 / 361.0;\n  const float cb = 35442.0 / 1805.0;\n  const float cc = 16061.0 / 1805.0;\n\n  float t2 = t * t;\n\n  return t < a\n    ? 7.5625 * t2\n    : t < b\n      ? 9.075 * t2 - 9.9 * t + 3.4\n      : t < c\n        ? ca * t2 - cb * t + cc\n        : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\nfloat bounceInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n\nfloat bounceIn(float t) {\n  return 1.0 - bounceOut(1.0 - t);\n}\n\n\nfloat elasticOut(float t) {\n  return sin(-13.0 * (t + 1.0) * PI/2.) * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat circularInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat exponentialIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\n\n// IQ's unsigned box formula.\nfloat sBox(in vec3 p, in vec3 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n// IQ's unsigned rectangle formula.\nfloat sBox(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n\n\n\nfloat sdSponge(vec3 z) {\n    const float s = 1.8;\n    z *= s;\n    z.y -= 1.;\n    const int SPONGE_ITERATIONS = 5;\n    for(int i = 0; i < SPONGE_ITERATIONS; i++) {\n        z = abs(z);\n        z.xy = (z.x < z.y) ? z.yx : z.xy;\n        z.xz = (z.x < z.z) ? z.zx : z.xz;\n        z.zy = (z.y < z.z) ? z.yz : z.zy;\n        z = z * 3.0  - 2.0 ;\n        z.z += (z.z < -1.0) ? 2.0 : 0.0;\n    }\n    //distance to cube\n    z = abs(z) - vec3(1);\n    float dis = min(max(z.x, max(z.y, z.z)), 0.0) + length(max(z, 0.0));\n    //scale cube size to iterations\n    dis =  dis * pow(3.0, -float(SPONGE_ITERATIONS)) ;\n    return dis / s;\n\n}\n\n\n\nfloat sierpinski( vec3 z )\n{\n    z *= 1.5;\n    z -= vec3(2, 1, 2);\n   const float Phi = 1.61803398875;\nconst vec3 n1   = normalize(vec3(-Phi   , Phi-1.0, 1.0    ));\nconst vec3 n2   = normalize(vec3(1.0    , -Phi   , Phi+1.0));\nconst vec3 o    = normalize(vec3(-Phi, -1.   , 0      ));\n\n    float s = 1.;\n    float orbit = 1e20;\n       \n    z = abs(z);      \n    z -= 2.*max(0.,dot(z,n2))*n2;\n    z.z = abs(z.z); \n    z -= 2.*max(0.,dot(z,n2))*n2;\n    const int ITERATIONS = 10;\n    const float SCALE = 2.;\n    for(int n=0;n < ITERATIONS;n++) {\n\t\torbit = min(orbit,dot(z,z));\n         \n        z = abs(z);             \n        z -= 2.*max(0.,dot(z,n1))*n1; \n        \n\t\tz *= SCALE;\n        s *= SCALE;\n        \n        z += o;\n    }\n    \n    //dis & descale\n    \n    return (length(z)-1.) / s / 1.5; \n\n\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"NlVGRd","date":"0","viewed":0,"name":"hyperbolic tiling step by step","description":"This is similar to shane's work https://www.shadertoy.com/view/WlBczG but used a different approach","likes":0,"published":"Private","usePreview":0,"tags":["2d","tiling","hyperbolic","poincare"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    A mimic of shane's work at https://www.shadertoy.com/view/WlBczG.\n    \n    Show the basic procedure to draw a 2d hyperbolic Poincare tiling.\n\n*/\n\n// comment out this to see the initial pattern\n//#define enableMouseInversion\n\n\n\n#define PI\t\t  3.14159265\n#define TAU\t      6.28318531\n#define inf       -1.\n\nint MAX_ITER = 0;\n\n\n// the smaller this value, the larger the black area\n#define BlackRegionSize   0.065\n\n// the first entry in PQR must be finite, other two entries can be either finite or infinite\nconst vec3 PQR = vec3(3, 3, 7);\n\n\n// reflection mirrors\nvec2 A, B;\nvec3 C;\n\n// two vertices of the fundamental triangle, the 3rd one is the origin\nvec2 v0, m0;\n\n// count the number of reflections across each mirror\nfloat count;\n\n\n// compute cos(PI / x), for x = infiniy this is cos(0) = 1.0\nfloat dihedral(float x) { return x == inf ? 1. : cos(PI / x); }\n\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\nvoid init() {\n\n    float cAB = dihedral(PQR.x);\n    float sAB = sqrt(1. - cAB*cAB);\n    \n\tA = vec2(1, 0);\n    B = vec2(-cAB, sAB);\n    \n    float cAC = dihedral(PQR.y);\n    float cBC = dihedral(PQR.z);\n    \n    float k1 = cAC;\n    float k2 = (cBC + cAB*cAC) / sAB;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    C = vec3(k1, k2, 1.)*r;\n    \n    v0 = vec2(0., C.y - sqrt(r*r - C.x*C.x));\n    vec2 n = vec2(-B.y, B.x);\n    float b = dot(C.xy, n);\n    float c = dot(C.xy, C.xy) - r*r;\n    float k = b + sqrt(b*b-c);\n    m0 = k*n;\n}\n\n\nbool try_reflect(inout vec2 p, vec2 mirror, inout float count) {\n    float k = dot(p, mirror);\n    if (k >= 0.)\n        return true;\n    p -= 2. * k  * mirror;\n    count += 1.;\n    return false;\n}\n\n\nbool try_reflect(inout vec2 p, vec3 sphere, inout float count) {\n    vec2 cen = sphere.xy;\n    float r = sphere.z;\n    float d = length(p - cen) - r;\n    if (d >= 0.)\n        return true;\n    p -= cen;\n    p *= r * r/ dot(p, p);\n    p += cen;\n    count += 1.;\n    return false;\n}\n\n\nbool fold(inout vec2 p, inout float count) {\n    count = 0.;\n    for (int k = 0; k < MAX_ITER; k++) {\n        bool cond = true;\n        cond = cond && try_reflect(p, A, count);\n        cond = cond && try_reflect(p, B, count);\n        cond = cond && try_reflect(p, C, count);\n        if (cond)\n            return true;\n    }\n    return false;\n}\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\nfloat darc(vec2 p, float k) {\n   \n   \n    vec2 q = p;\n    float tmp = 0.;\n    bool isout = try_reflect(q, C, tmp);\n    float dp = length(p - C.xy) - C.z;\n    float d = length(q - C.xy) - C.z;\n    float d1 = length(q - v0);\n    float d2 = length(q - m0);\n     if (dot(p, A) < 0.)\n        return d1;\n    if (dot(p, B) < 0.)\n        return d2;\n\n    if (!isout && dot(p, A) < 0.02 && d > 0.02)\n        return d1;\n    if (!isout && dot(p, B) < 0.05 && d > 0.02)\n        return d2;\n        \n\n    return d;\n}\n\n\nvec2 mouseInversion(vec2 p) {\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    if(length(m) < 1e-3) m += 1e-3; \n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m;\n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x;\n    return p;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 1.05;\n    vec2 p = uv;\n    \n#ifdef enableMouseInversion\n    p = mouseInversion(p);\n    p = rot2(iTime/16.)*p;\n#endif\n\n    init();\n    \n    if(length(p)> 1.)\n        p /= dot(p, p);\n        \n    MAX_ITER = int(mod(iTime, 20.0));\n  \n    bool found = fold(p, count);\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    float tm = -0.005;\n    ln = min(ln, lBox(p, vec2(0), v0, .007));\n    ln = min(ln, lBox(p, vec2(0), m0, .007));\n    ln = min(ln, darc(p, tm) + tm);\n\n    \n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf;\n        \n    vec3 oCol = .55 + .45*cos(count*TAU / 8. + vec3(0, 1, 2));\n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    \n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    col = mix(col, vec3(1, .8, .3), 1. - smoothstep(0., sf, pnt + .02));\n    \n    vec3 bg = vec3(1, .2, .4);\n    bg *= .7*(mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5)*.5 + .5);\n    pat = smoothstep(0., .25, abs(fract((uv.x - uv.y)*43. - .25) - .5)*2. -.5);\n    bg *= max(1. - length(uv)*.5, 0.)*(pat*.2 + .9);\n    \n    float cir = length(uv);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., abs(cir - 1.) - .05))*.7);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(cir - 1.) - .05)));\n    col = mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col*max(1. - length(uv)*.5, 0.), (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.05)));\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cir - 1.035) - .03))*.8);\n    col = mix(col, 1. - exp(-col), .35);\n\n    //debug mirrors\n/*\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, A)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, B)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.02, abs(length(uv-C.xy) - C.z))-0.01);\n*/\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ss2cz3","date":"1643890479","viewed":715,"name":"Neo three worlds","description":"Motivated by Escher's artwork \"three worlds\", try to combine spherical, Euclidean, hyperbolic geometry in one scene. See three worlds through the mirrors at the same time.","likes":26,"published":"Public API","usePreview":1,"tags":["3d","escher","geometry","tiling","polyhedra","hyperbolic","wythoff"]},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 get_floor_color(vec2 z) {\n    // Modify P, Q, R to change the tiling\n    const float P = 7.;\n    const float Q = 2.;\n    const float R = 3.;\n    const float cp = cos(PI / P), sp = sin(PI / P);\n    const vec2 mB = vec2(-cp, sp);\n    const float k1 = cos(PI / Q);\n    const float k2 = (cos(PI / R) + cp * k1) / sp;\n    const float rad = 1. / sqrt(k1 * k1 + k2 * k2 - 1.);\n    const vec2 cen = vec2(k1 * rad, k2 * rad);\n    const vec2 v0 = vec2(0, cen.y - sqrt(rad * rad - cen.x * cen.x));\n    const vec2 n_ = vec2(-mB.y, mB.x);\n    const float b_ = dot(cen, n_);\n    const float c_ = dot(cen, cen) - rad * rad;\n    const float k_ = b_ + sqrt(b_ * b_ - c_);\n    const vec2 m0 = k_ * n_;\n\n    vec2 p = square_to_disc(z);\n    vec2 invCtr = vec2(1);\n    float t = 1. / dot(p -invCtr, p - invCtr);\n    p = mix(invCtr, p, t);\n    p.x = -p.x;\n    p = rot2(iTime/12.)*p;\n\n    if (length(p) > 1.)\n        p /= dot(p, p);\n\n    float count = 0.;\n    for (int i = 0; i < MAX_TILING_REFLECTIONS; i++) {\n        if (p.x < 0.) {\n            p.x = -p.x;\n            count += 1.;\n        }\n        float k = dot(p, mB);\n        if (k < 0.) {\n            p -= 2. * k * mB;\n            count += 1.;\n        }\n        \n        float d = length(p - cen) - rad;\n        if (d < 0.) {\n            p -= cen;\n            p *= rad * rad / dot(p, p);\n            p += cen;\n            count += 1.;\n        }\n    }\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, vec2(0), v0, .007));    \n    ln = min(ln, lBox(p, vec2(0), m0, .007));\n    ln = min(ln, length(p - cen) - rad - 0.007);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float sf = 2. / iResolution.y;\n    float rnd = smoothstep(.8, .97, sin(iTime*.5 + count)*.5 + .5);\n        \n    vec3 oCol = .55 + .45*cos(count * PI / 4. + vec3(0, 1, 2));\n    oCol = mix(oCol*.1, clamp(oCol*3.5, 0., 1.), rnd);\n     \n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    \n    rnd = smoothstep(.8, .97, sin(iTime * 1.5)*.5 + .5);\n    vec3 blink = vec3(1.3, 0.25, 0.35);\n    blink = mix(blink * 0.5, blink * 2.2, rnd);\n    col = mix(col, blink, 1. - smoothstep(0., sf, pnt + .02));\n    return col;\n}\n\nvec3 get_ceil_color(vec2 p) {\n    const float P = 3.;\n    const float Q = 3.;\n    const float R = 3.;\n    const float cp = cos(PI / P), sp = sin(PI / P);\n    const float cq = cos(PI / Q), cr = cos(PI / R);\n    const vec2 mB = vec2(-cp, sp);\n    const vec3 mC = vec3(-cr, -(cq + cr * cp) / sp, 1.);\n    const vec2 v0 = vec2(0, -1./mC.y);\n    const float k_ = mB.x / mB.y;\n    const float x_ = 1. / (k_ * mC.y - mC.x);\n    const float y_ = -k_ * x_;\n    const vec2 m0 = vec2(x_, y_);\n    \n    p = rot2(iTime/12.)*p;\n\n    float count = 0.;\n    for (int i = 0; i < MAX_TILING_REFLECTIONS; i++) {\n        if (p.x < 0.) {\n            p.x = -p.x;\n            count += 1.;\n        }\n        float k = dot(p, mB);\n        if (k < 0.) {\n            p -= 2. * k * mB;\n            count += 1.;\n        }\n        \n        k = dot(vec3(p, 1.), mC);\n        if (k < 0.) {\n            p -= 2. * k * mC.xy;\n            count += 1.;\n        }\n    }\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    //ln = min(ln, lBox(p, vec2(0), v0, .05));    \n    //ln = min(ln, lBox(p, vec2(0), m0, .05));\n    ln = min(ln, lBox(p, v0, m0, .05));\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float sf = 2. / iResolution.y;\n    float rnd = smoothstep(.8, .97, sin(iTime + count * PI)*.5 + .5);\n        \n    vec3 oCol = .55 + .45*cos(count * PI / 8. + vec3(0, 1, 2)).yzx;\n    oCol = mix(oCol*.1, clamp(oCol*1.5, 0., 1.), rnd);\n     \n    float pat = smoothstep(0., .25, abs(fract(ln2*15. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize * 16.)));\n\n    pnt -= .15;\n    pnt = min(pnt, length(p) - .15);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    \n    rnd = smoothstep(.4, .5, sin(iTime)*.5 + .5);\n    vec3 blink = vec3(1.3, 0.25, 0.35);\n    blink = mix(blink * 0.5, blink * 2.2, rnd);\n    col = mix(col, blink, 1. - smoothstep(0., sf, pnt + .02));\n    return col;\n}\n\n// distance to the four sides of mirrors \nfloat sdMirror(vec3 p) {\n    vec2 d = RoomSize.xz - abs(p.xz);\n    return min(d.x, d.y);\n}\n\n// the floor and the ceil\nfloat sdFloor(vec3 p) {\n    return RoomSize.y - abs(p.y);\n}\n\n// wood framework\nfloat sdRoomFrame(vec3 p) {\n    return sdBoxFrame(p, RoomSize, vec3(RoomFrameSize));\n}\n\nfloat sdMirrorFrame(vec3 p) {    \n    float d1 = sdBoxFrame(p, RoomSize, WindowFrameSize.xyy);\n    float d2 = sdBoxFrame(p, RoomSize, WindowFrameSize.yxy);\n    float d3 = sdBoxFrame(p, RoomSize, WindowFrameSize.yyx);\n    return min(d1, min(d2, d3));\n}\n\n// polyhedra with faces and edges\nvec2 sdPolyhedra(vec3 p) {\n    p *= RotObj;\n    p = fold_spherical(p);\n    p -= v0S;\n    float d1 = sdPolyhedraFaces(p);\n    float d2 = sdPolyhedraEdges(p);\n    float d = min(d1, d2);\n    float id = d1 < d2 ? 1. : 2.;\n    return vec2(d, id);\n}\n\nfloat sdScene(vec3 p) {\n    float d1 = sdMirror(p);\n    float d2 = sdFloor(p);\n    float d3 = sdRoomFrame(p);\n    float d4 = sdMirrorFrame(p);\n    float d5 = sdPolyhedra(p).x;\n    return min(d1, min(d2, min(d3, min(d4, d5))));\n}\n\nvec3 trace(vec3 pos, vec3 rd) {\n    float h = 1.0;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        if (h < PRECISION)\n            break;\n        h = sdScene(pos);\n        pos += rd * min(h, MAX_MARCH_STEP);\n    }\n    return pos;\n}\n\nfloat soft_shadow(vec3 pos, vec3 lp) {\n    const float softness = 16.;\n    const float shadowStartDistance = .1;\n    const int shadowLoopCount = 16;\n\n    vec3 ld = lp - pos;\n    float ldist = max(length(lp), 0.001);\n    ld /= ldist;\n    float epsilon = .001;\n    float t = shadowStartDistance;\n    float h = 1.;\n    float shade = 1.0;\n    for (int i=0; i < shadowLoopCount; i++ ) {\n        if (h < epsilon || t > ldist)\n            break;\n        h = sdScene(pos + ld * t);\n        shade = min(shade, smoothstep(0.0, 1.0, softness*h/t));\n        t += h;\n    }\n    return clamp(shade + 0.25, 0., 1.);\n}\n\nvec3 get_normal(vec3 p) {\n    const vec2 d = vec2(-1, 1) * .001;\n    return normalize(\n            sdScene(p + d.xxx)*d.xxx +\n            sdScene(p + d.yyx)*d.yyx +\n            sdScene(p + d.yxy)*d.yxy +\n            sdScene(p + d.xyy)*d.xyy);\n}\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n};\n\nLight lights[] = Light[] (\n    Light(vec3(2.5, 2.2, 2.5), vec3(1) * 5.),\n    Light(vec3(-1, -.5, -1), vec3(1)),\n    Light(vec3(-2.5,-1.9,-2.5), vec3(0, .3, 1))\n);\n\nvoid ray_bounce(in vec3 p,\n                in vec3 rd,\n                out vec3 diffuse,\n                out vec3 ref_dir,\n                out vec3 bounceTint,\n                in vec3 normal) {\n\n    vec3 bCol = vec3(0);\n    for( int i=0; i < lights.length(); i++ ) {\n        vec3 ld = lights[i].pos - p;\n        float ldist = max(length(ld), 0.001);\n        ld /= ldist;\n        float diff = max(0., dot(normal, ld));\n        vec3 viewDir = -rd;\n        vec3 halfDir = normalize(ld + viewDir);\n        float spec = pow(max(dot(normal, halfDir), 0.0), 20.);\n        float at = 1.5 / (1. + ldist * 0.3 + ldist * ldist * 0.1);\n        float sh = soft_shadow(p, lights[i].pos);\n        bCol += lights[i].col * sh * (.2 + diff + spec) * at;\n    }\n    // ambient light\n    vec3 ao = vec3(.03,.05,.07);\n    // sample SDF to approximate occlusion\n    ao *= exp2(min(0., sdScene(p + normal * 0.3) / 0.3 - 1.));\n    ao *= exp2(min(0., sdScene(p + normal * .15) / .15 - 1.));\n    ao *= exp2(min(0., sdScene(p + normal * .07) / .07 - 1.));\n    bCol += ao;\n    \n    // https://www.shadertoy.com/view/tlBGR1\n    vec3 albedo = vec3(.3,.5,.6) * .4;\n    vec4 specLevel = vec4(0.9, 0.9, 0.9, 1);\n\n    float d1 = sdMirror(p);\n    float d2 = sdFloor(p);\n    float d3 = sdRoomFrame(p);\n    float d4 = sdMirrorFrame(p);\n    vec2 sdPoly = sdPolyhedra(p);\n    float d5 = sdPoly.x, id = sdPoly.y;\n    float d = min(d1, min(min(d2, d3), min(d4, d5)));\n    \n    if (d == d3) {  // room frame\n        albedo = vec3(.25);\n        specLevel = vec4(0.08);\n    }\n    else if (d == d4) {  // mirror border\n        albedo = vec3(0.01);\n        specLevel = vec4(0.2, 0.2, 0.2, 1.);\n    }\n    else if (d == d5) {  // polyhedra\n        if (id == 2.) {  // polyhedra edges\n            albedo = vec3(0.15, 0.3, 0.8);\n            specLevel = vec4(vec3(0.05), 1.);\n        }\n        else {  // polyhedra faces\n            specLevel = vec4(0.7);\n            vec3 bump = texture(iChannel0, p.xz * 0.5).rgb - 0.5;\n            normal = normalize(normal + bump * 0.01);\n        }\n    }\n    else if (d == d2) {  // floor and ceil\n        vec2 uv = p.xz;\n        albedo = p.y < 0. ? get_floor_color(uv / (RoomSize.x - RoomFrameSize))\n                          : get_ceil_color(uv * 2.);\n        float ior = 1.33;\n        float schlick = pow((ior - 1.) / (ior + 1.), 2.);\n\t    specLevel = vec4(vec3(schlick), 1);\n    \tspecLevel *= mix(.2, .7, p.x);\n    \tnormal = normalize(normal + (texture(iChannel0, vec2(p.xz) /2.).rgb - .5) * .005);\n    }\n    \n    float fresnel = pow(dot(normal, rd) + 1., 5.);\n    vec3 spec = mix(specLevel.xyz, specLevel.www, fresnel);\n    \n    bounceTint = spec;\n    diffuse = albedo * (vec3(1) - spec) * bCol;\n    ref_dir = reflect(rd, normal);\n}\n\nvec3 get_ray_color(vec3 ro, vec3 rd) {\n    vec3 pos = ro;\n    vec3 tint = vec3(1);\n\n    vec3 col = vec3(0);\n    for (int i = 0; i < MAX_RAY_BOUNCES; i++) {\n        pos = trace(pos, rd);\n        vec3 normal = get_normal(pos);\n        vec3 bounceTint, diffuse;\n        ray_bounce(pos, rd, diffuse, rd, bounceTint, normal);\n        pos += normal * PRECISION * 2.;\n        col += diffuse * tint;\n        tint *= bounceTint;\n        if (length(tint) < .01)\n            break;\n    }\n    return col;\n}\n\nmat3 camera_matrix(vec3 eye, vec3 lookat, vec3 up) {\n    vec3 forward = normalize(lookat - eye);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, -forward);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init_spherical();\n\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 movement = vec2(iTime * 0.2, sin(iTime * 0.2) * 0.5);\n    vec3 eye = 2.5 * vec3(\n        cos(movement.x) * cos(movement.y),\n        0.5*sin(movement.y),\n        sin(movement.x) * cos(movement.y));\n    eye += vec3(1, 0.3, 1) * cos(vec3(0.75, 0.3, 0.2) * iTime);\n   \n    vec2 mouse = vec2(0);\n    if (iMouse.x > 0.) {\n        mouse = 2. * iMouse.xy / iResolution.y - 1.;\n        eye = rot_y(mouse.x) * rot_x(mouse.y) * eye;\n    }\n    vec3 lookat = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    mat3 M = camera_matrix(eye, lookat, up);\n    \n    vec3 ray = M * normalize(vec3(uv, -2.));\n    vec3 col = get_ray_color(eye, ray);\n    fragColor = vec4(clamp(sqrt(col), 0., 1.), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.141592654\n#define BlackRegionSize  0.03\n#define L2(x)  dot(x, x)\n#define RotObj  rot_x(iTime/2.)*rot_z(iTime/3.)\n#define PolyhedraEdgeSize  0.02\n#define PolyhedraFaceOffset  0.\n#define RoomSize  vec3(5, 2.5, 5)\n#define RoomFrameSize  0.5\n#define WindowFrameSize vec2(RoomFrameSize*1.2, 0)\n#define MAX_TILING_REFLECTIONS 12\n#define MAX_TRACE_STEPS  128\n#define MAX_RAY_BOUNCES  15\n#define PRECISION        1e-3\n#define MAX_MARCH_STEP   1.0\n\nconst vec3 pqr_wythoff = vec3(5, 2, 3);\nconst vec3 bary = vec3(1, 1, 1);\n\nmat3 matS, triS;\nvec3 v0S;\n\nvoid init_spherical() {\n    vec3 c = cos(PI / pqr_wythoff);\n    float sp = sin(PI / pqr_wythoff.x);\n    vec3 m1 = vec3(1, 0, 0);\n    vec3 m2 = vec3(-c.x, sp, 0);\n    float x3 = -c.z;\n    float y3 = -(c.y + c.x*c.z)/sp;\n    float z3 = sqrt(1.0 - x3*x3 - y3*y3);\n    vec3 m3 = vec3(x3, y3, z3);\n    matS = mat3(m1, m2, m3);\n    triS[0] = normalize(cross(m2, m3));\n    triS[1] = normalize(cross(m3, m1));\n    triS[2] = normalize(cross(m1, m2));\n    v0S = normalize(bary * inverse(matS));\n}\n\nvec3 fold_spherical(vec3 p) {\n    for (int i = 0; i < 5; i++)\n    for (int j = 0; j < 3; j++) {\n        p -= 2. * min(dot(p, matS[j]), 0.) * matS[j];\n    }\n    return p;\n}\n\nvec3 tex3D(sampler2D tex, in vec3 p, in vec3 n ) {\n    n = max(n * n, 0.001);\n    n /= (n.x + n.y + n.z ); \n\treturn (\n        texture(tex, p.yz) * n.x +\n        texture(tex, p.zx) * n.y +\n        texture(tex, p.xy) * n.z\n    ).xyz;\n}\n\nmat2 rot2(in float a) {\n    float c = cos(a), s = sin(a); return mat2(c, -s, s, c);\n}\n\nmat3 rot_x(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0,  0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rot_y(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n}\n\nmat3 rot_z(in float t) {\n    float cz = cos(t), sz = sin(t);\n    return mat3(cz, -sz, 0.,\n                sz, cz, 0.,\n                0., 0., 1.);\n}\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n// https://www.shadertoy.com/view/3ljcRh\n// I changed e to vec3 so it works for non-uniform edge size\nfloat sdBoxFrame(vec3 p, vec3 b, vec3 e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    return min(min(\n        length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n        length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n        length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdPolyhedraEdges(vec3 p) {\n    float d = 1e5;\n    for (int i = 0; i < 3; i++) {\n        d = min(d, L2(p - min(0., dot(p, matS[i])) * matS[i]));\n    }\n\treturn sqrt(d) - PolyhedraEdgeSize;\n}\n\nfloat sdPolyhedraFaces(vec3 p) {\n   return max(dot(p, triS[0]), max(dot(p, triS[1]), dot(p, triS[2]))) - PolyhedraFaceOffset;\n}\n\n//complex multiplication\nvec2 cMul(vec2 a, vec2 b) {\n\treturn vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n// complex inverse \nvec2 cDiv( vec2 a, vec2 b ) {\n  float d = dot(b, b);\n  return vec2(dot(a, b), a.y*b.x - a.x*b.y ) / d;\n}\n\n// complex inverse \nvec2 cInv(vec2 a) {\n\treturn vec2(a.x, -a.y) / dot(a, a);\n}\n\n// code below taken from @mla's https://www.shadertoy.com/view/Mlsfzs\nvoid sncndn(float u, float k2,\n            out float sn, out float cn, out float dn) {\n    float emc = 1.0 - k2;\n    float a = 1.0, b, c;\n    const int N = 4;\n    float em[N], en[N];\n    dn = 1.0;\n    for (int i = 0; i < N; i++) {\n        em[i] = a;\n        emc = sqrt(emc);\n        en[i] = emc;\n        c = 0.5*(a + emc);\n        emc *= a;\n        a = c;\n    }\n\n    u = c*u;\n    sn = sin(u);\n    cn = cos(u);\n    if (sn != 0.0) {\n        a = cn / sn;\n        c *= a;\n        for(int i = N - 1; i >= 0; i--) {\n            b = em[i];\n            a *= c;\n            c *= dn;\n            dn = (en[i] + a) / (b + a);\n            a = c/b;\n        }\n        a = 1.0 / sqrt(c*c + 1.0);\n        if (sn < 0.0)\n            sn = -a;\n        else\n            sn = a;\n        cn = c * sn;\n    }\n}\n\nvec2 cn(vec2 z, float k2) {\n  float snu, cnu, dnu, snv, cnv, dnv;\n  sncndn(z.x, k2, snu, cnu, dnu);\n  sncndn(z.y, 1.0-k2, snv, cnv, dnv);\n  return vec2(cnu * cnv, -snu*dnu*snv*dnv) / (1. - dnu*dnu*snv*snv);\n}\n\nvec2 square_to_disc(vec2 z) {     \n    z = cDiv(z, vec2(1));\n    z -= vec2(1, 0);\n    z *= 1.854;\n    z = cn(z, 0.5);\n    z = cMul(z, vec2(0.70711));\n    return z;\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"fljfRm","date":"1651976315","viewed":1738,"name":"Mobius transformation revealed","description":"A recreation of the video: https://www-users.cse.umn.edu/~arnold/moebius/","likes":29,"published":"Public API","usePreview":0,"tags":["3d","mobius"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis animation shows that Mobius transformations are rigid motions\nof \"admissible\" spheres in the upper half-space.\n\nA sphere is called admissible if its highest point is above the xy-plane.\n\nThe procedure involves four steps:\n\n1. Map the complex plane (xy) to the sphere using inverse\n   stereographic projection.\n\n2. Translate and rotate the sphere, but keeping it admissible..\n\n3. Map the sphere back to the complex plane using stereographic projection,\n   with the north pole being the highest point of the sphere.\n\n4. Combine steps 1-3 to get a Mobius transformation of the complex plane.\n   All Mobius transformations can be obtained this way.\n\n\nIn this process,\n\n1. moving the sphere in the xy-plane is a translation of the complex plane.\n\n2. moving it along the z-axis is a scaling of the complex plane.\n\n3. rotating it in the xy-plane is a rotation of the complex plane.\n\n4. rotating 180 degree about the x-axis is the inverse map z -> 1/z.\n\n\nFor a given Mobius transformation M and a chosen initial position\nof the sphere, the rigid motion that gives M is unique.\n*/\n#define AA   3\n#define PI 3.141592654\n#define TAU (2.0 * PI)\n#define ROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x) (0.5 + 0.5 * cos(x))\n#define DOT2(x) dot(x, x)\n#define TIME iTime\n#define Y vec3(0, 1, 0)\n#define NPOLE(sph) (sph.xyz + sph.w * Y)\n#define PLANE vec4(0, 1, 0, 0.)\n#define aa (2.0 / iResolution.y)\n\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n#define HSV2RGB(c)                                                             \\\n    (c.z * mix(hsv2rgb_K.xxx,                                                  \\\n               clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - \\\n                         hsv2rgb_K.xxx,                                        \\\n                     0.0, 1.0),                                                \\\n               c.y))\n\nconst float grid_max = 10000.0;\nconst float grid_size = 0.5;\nconst vec3 light_pos = vec3(3, 4, 3);\nconst vec3 light_dir = normalize(light_pos);\nconst vec3 sky0_color = HSV2RGB(vec3(0.0, 0.65, 0.95));\nconst vec3 sky1_color = HSV2RGB(vec3(0.6, 0.5, 0.5));\nconst vec3 grid_color = HSV2RGB(vec3(0.6, 0.6, 1.0));\nconst vec3 light_color = 12.0 * HSV2RGB(vec3(0.6, 0.5, 1.0));\nconst vec3 plane_color = HSV2RGB(vec3(0.7, 0.125, 1.0 / 32.0));\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 id = floor(p / size);\n    p = mod(p + size * 0.5, size) - size * 0.5;\n    return id;\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n    return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0)\n        return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 58.233))) * 13758.5453);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, vec4 sph, float k) {\n    vec3 oc = ro - sph.xyz;\n    float r2 = sph.w * sph.w;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r2;\n    float h = b * b - c;\n    float d = -sph.w + sqrt(max(0.0, r2 - h));\n    float t = -b - sqrt(max(0.0, h));\n    return (t < 0.0) ? 1.0 : smoothstep(0.0, 1.0, k * d / t);\n}\n\nfloat bounce() {\n    float t = fract(TIME) - 0.5;\n    return 0.25 - t * t;\n}\n\nvec2 path(float t) {\n    const float rad = 0.8;\n    return rad * vec2(cos(t), sin(t));\n}\n\nvoid rot(inout vec3 sp) {\n    sp.xy *= ROT(TIME * 0.3);\n    sp.xz *= ROT(TIME * 0.3);\n}\n\nvec3 diffuse(vec3 pos, vec3 nor) {\n    float ll = DOT2(light_pos - pos);\n    vec3 ld = normalize(light_pos - pos);\n    return light_color * max(dot(nor, ld), 0.0) / ll * 20.;\n}\n\nvec3 restrictColor(vec2 p, vec3 col) {\n    float cond = step(abs(p.x), grid_max);\n    cond *= step(abs(p.y), grid_max);\n    return mix(plane_color, col, cond);\n}\n\nvec3 planeToSphere(vec3 p, vec4 sph) {\n    vec3 N = NPOLE(sph);\n    vec3 rd = normalize(N - p);\n    float t = raySphere(p, rd, sph).x;\n    return p + rd * t;\n}\n\nvec3 sphereToPlane(vec3 p, vec4 sph, vec4 plane) {\n    vec3 N = NPOLE(sph);\n    vec3 rd = normalize(p - N);\n    float t = rayPlane(p, rd, plane);\n    return p + rd * t - sph.xyz;\n}\n\nvec3 computeGridColor(vec3 pos, vec2 pp) {\n    vec2 z = pp;\n    mod2(z, vec2(grid_size));\n    float d1 = smin(abs(z.x), abs(z.y), .05);\n    float gm = PCOS(-TAU * TIME + 0.25 * TAU * length(pos.xz));\n\n    z = pp;\n    vec2 id = mod2(z, vec2(grid_size / 6.));\n    float d2 = min(abs(z.x), abs(z.y)) - 0.0125;\n\n    float n = hash21(id);\n    float n2 = n * 0.3 + .7;\n    if (n < 0.1 * sin(TIME) + 0.1)\n        n = 1E6;\n    else\n        n = 0.0;\n\n    vec3 gcol = vec3(0);\n    gcol = mix(gcol, HSV2RGB(vec3(hash21(id), 1.0, n2)), vec3(n > 1.0));\n    gcol -= 0.2 * vec3(2.0, 1.0, 1.0) * exp(-100.0 * max(d2 + 0.01, 0.0));\n    gcol = mix(gcol, 6. * vec3(0.1, 0.09, 0.125),\n               smoothstep(-aa, aa, -(d2 + 0.0075)));\n    gcol += 0.5 * vec3(2.0, 1.0, 1.0) * exp(-900.0 * abs(d2 - 0.00125));\n\n    vec3 col = clamp(gcol, -1.0, 1.0);\n\n    gcol = mix(vec3(0.75), 2.0 * vec3(3.5, 2.0, 1.25), gm);\n    gcol *= exp(-mix(400.0, 100.0, gm) * max(d1 - 0.0125, 0.0));\n    gcol *= 0.3;\n    col = mix(col, gcol, smoothstep(-aa, aa, -d1 + 0.0125));\n    return col;\n}\n\nvec3 renderBackground(vec3 ro, vec3 rd, vec4 sph, float T) {\n    vec3 sky = smoothstep(1.0, 0.0, rd.y) * sky1_color +\n               smoothstep(0.5, 0.0, rd.y) * sky0_color;\n\n    sky += pow(max(dot(rd, light_dir), 0.0), 800.0) * light_color;\n    if (rd.y >= 0.0)\n        return sky;\n\n    float ht = 1.0 + 0.2 * smoothstep(-0.05, 0.1, bounce());\n    float t = rayPlane(ro, rd, vec4(vec3(0.0, ht, 0.0), 0.5));\n    vec3 pos = ro + t * rd;\n    vec3 dif = diffuse(pos, Y);\n    float sha = softShadow(pos, normalize(light_pos - pos), sph, 2.0);\n    dif *= sha;\n\n    vec3 sp = planeToSphere(pos, sph);\n    sp -= sph.xyz;\n    rot(sp);\n    sp += sph.xyz;\n    vec3 pp = sphereToPlane(sp, sph, PLANE);\n\n    vec3 col = computeGridColor(pos, pp.xz);\n    col = restrictColor(pp.xz, col);\n    col += plane_color * dif;\n    col /= (1.0 + 0.25 * DOT2(pos.xz));\n    col = mix(sky, col, tanh(500.0 / (1.0 + DOT2(pos))));\n    return col;\n}\n\nvec3 renderBall(vec3 ro, vec3 rd, vec4 sph, vec2 st, float T) {\n    vec3 pos = ro + st.x * rd;\n    vec3 sp = pos - sph.xyz;\n    vec3 nor = normalize(sp);\n    vec3 ref = reflect(rd, nor);\n    vec3 dif = diffuse(pos, nor);\n    rot(sp);\n    pos = sp + sph.xyz;\n    vec3 pp = sphereToPlane(pos, sph, vec4(0, 1, 0, 0.5));\n    vec3 rcol = renderBackground(pos, ref, sph, T);\n\n    vec2 z = pp.xz;\n    mod2(z, vec2(grid_size));\n    float d1 = smin(abs(z.x), abs(z.y), .05);\n    float gm = PCOS(-TAU * T + 0.25 * TAU * length(pp));\n\n    z = pp.xz;\n    vec2 id = mod2(z, vec2(grid_size / 6.));\n    float d2 = min(abs(z.x), abs(z.y)) - 0.0125;\n\n    float n = hash21(id);\n    float n2 = n * 0.3 + .7;\n    if (n < 0.1 * sin(T) + 0.1)\n        n = 1E6;\n    else\n        n = 0.0;\n\n    vec3 gcol = vec3(0);\n    gcol =\n        mix(gcol, HSV2RGB(vec3(hash21(sin(id * TAU)), 1.0, n2)), vec3(n > 1.0));\n    gcol -= 0.2 * vec3(2.0, 1.0, 1.0) * exp(-100.0 * max(d2 + 0.01, 0.0));\n    gcol = mix(gcol, 6. * vec3(0.09, 0.1, 0.125),\n               smoothstep(-aa, aa, -(d2 + 0.0075)));\n    gcol += 1. * vec3(2.0, 1.0, 1.0) * exp(-900.0 * abs(d2 - 0.00125));\n    vec3 col = clamp(gcol, -1., 1.);\n    gcol = mix(vec3(0.75), 2.0 * vec3(3.5, 2.0, 1.25), gm);\n    gcol *= exp(-mix(400.0, 100.0, gm) * max(d1 - 0.0125, 0.0));\n    gcol *= 0.3;\n    col = mix(col, gcol, smoothstep(-aa, aa, -d1 + 0.0125));\n    col = restrictColor(pp.xz, col);\n    col += rcol * 0.175;\n    return col;\n}\n\nvec3 render(vec2 p) {\n    vec2 ph = path(TIME * 0.5);\n    vec3 ro = vec3(2.5, 1.0, 0.);\n    ro.xz *= ROT(TIME / 3.);\n    vec3 lookat = vec3(0., 0., 0.);\n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, Y));\n    vec3 up = normalize(cross(right, forward));\n    vec3 rd = normalize(p.x * right + p.y * up + 2.0 * forward);\n    vec4 sph = vec4(vec3(0., bounce(), 0.), 0.5);\n    sph.xz += ph;\n    vec2 st = raySphere(ro, rd, sph);\n    if (st.x >= 0.0)\n        return renderBall(ro, rd, sph, st, TIME);\n    else\n        return renderBackground(ro, rd, sph, TIME);\n}\n\nvec3 postprocess(vec3 col, vec2 q) {\n    col = pow(clamp(col, 0.0, 1.0), vec3(1.0 / 2.2));\n    col = col * 0.6 + 0.4 * col * col * (3.0 - 2.0 * col);\n    col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n    col *= 0.5 + 0.5 * pow(19.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.7);\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 col = vec3(0);\n    for (int i = 0; i < AA; i++) {\n        for (int j = 0; j < AA; j++) {\n            vec2 p = (2. * fragCoord + 2. * vec2(i, j) / float(AA) - iResolution.xy) / iResolution.y;\n            col += render(p);\n        }\n    }\n    col /= float(AA * AA);\n\n    // float fi = smoothstep(0.0, 5.0, TIME);\n    // col = mix(vec3(0.0), col, fi);\n\n    col = postprocess(col, uv);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"fstyz2","date":"0","viewed":0,"name":"Lots of pseudo kleinian fractals","description":"Boyd-Maxwell ball packings 3d version","likes":0,"published":"Private","usePreview":0,"tags":["3d","fractals","boydmaxwell"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2 // Make it 3 if you have a fast machine\n#endif\n\nfloat map(vec3 p, inout int index) {\n    float scale = 3.;\n    orb = vec4(1000.0); \n    for (int i = 0; i < MAX_ITER; i++) {\n        bool cond = true;\n        for (int k = 0; k < 5; k++) {\n            cond = try_reflect(p, coclusters[k], scale) && cond;\n            orb = min( orb, vec4(abs(p), dot(p, p)));\n        }\n\n        if (cond)\n            break;\n    }\n    index = 0;\n\n    float d = p.z;\n    for (int j = 1; j < 5; j++) {\n        if (clusters[j].isRealBall) {\n            float d1 = sdistanceToBall(p, clusters[j]);\n            if (d1 < d) { d = d1; index = j; }\n        }\n    }\n    return d / scale;\n}\n\n\n\nfloat trace( in vec3 ro, in vec3 rd, inout int index )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<512; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, index );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float precis = 0.001 * t;\n    int index;\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, index) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, index ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, index ) + \n                      e.xxx*map( pos + e.xxx, index ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    int index = 0;\n    float t = trace( ro, rd, index);\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, 0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.z);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.80,0.2), clamp(6.0*tra.z,0.0,1.0) );\n        rgb = mix( rgb, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init(333, vec3(3, 3, 2), vec3(3, 3, 2), inf, bvec4(1, 0, 0, 0));\n    float time = iTime*0.05 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.4 + 0.30*cos(0.37*time), 1.2+1.2*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.5 + 1.*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(0, 0, 1);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_ITER         30\n#define PI               3.141592653\n#define L2(x)            dot(x, x)\n#define ZOOM             3.\n#define inf              -1.05\n\nvec4 orb; \n\n// uncomment this to show the vertice sections\n//#define DrawVerticalSections\n\nfloat dihedral(float x) {\n    return x == inf ? 1. : cos(PI / x);\n}\n\nvec3 dihedral(vec3 v) {\n    return vec3(dihedral(v.x), dihedral(v.y), dihedral(v.z));\n}\n\n\n// For spheres n is the center, r is the radius\n// For planes n is the normal vector, r is the distance between the plane and the origin\n// if invert is true then the inside/outside of the sphere is interchanged (not used in this program)\n// if hasRealBall is true then this virtual ball has a real ball correspondes to it\nstruct Ball {\n    bool isplane;\n    vec3 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[5] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[5] clusters;\n\n\n// create a ball. by default it's the z=0 plane with normal points to the negative half\nBall defaultBall() {\n    return Ball(false, vec3(0, 0, -1), 0., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec3 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        return k;\n    }\n    else\n        return length(p - B.n) - B.r;\n}\n\nBall from_plane(vec3 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec3 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec3 p, Ball B, inout float scale) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec3 cen = B.n;\n        float r = B.r;\n        vec3 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        return false;\n    }\n}\n\n// return distance to the scene, and get the index of the real ball hitted\n\n\n// solve M*v = b, where v = (x, y, r) is the xy-coordinate of the center of the ball,\n// r is the radius of the ball.\nBall solveBall(mat3 M, vec3 b) {\n    vec3 p = b * inverse(M);\n    return from_sphere(vec3(p.xy, 0.), p.z);\n}\n\n// Solve a ball with its center has xy-coordinates P, and is orthogonal to other two Balls B0, B1.\n// Here B0 may be either a sphere or a plane, B1 is always a sphere. \nBall solveBall(vec2 P, Ball B0, Ball B1) {\n    if (B0.isplane) {\n        float z = B0.r;\n        vec3 cen = vec3(P, z);\n        float R = sqrt(L2(cen - B1.n) - B1.r*B1.r);\n        return from_sphere(cen, R);\n    }\n    else {\n        float r1 = B1.r;\n        float r0 = B0.r;\n        float z0 = B0.n.z;\n        float k0 = L2(P - B0.n.xy);\n        float k1 = L2(P - B1.n.xy);\n        float z = (r1*r1 - r0*r0 + z0*z0 + k0 - k1) / (2.*z0);\n        float R = sqrt(k1 + z*z - r1*r1);\n        return from_sphere(vec3(P, z), R);\n    }\n    \n}\n\n// triangleType: must be one of 236, 244 or 333\n// dihedralAngles0: labels of the edges between v0 and (v2, v3, v4)\n// dihedralAngles1: labels of the edges between v1 and (v2, v3, v4)\n// dihedralAngles0_1: label of the edge between (v0, v1)\n// isRealBall: specify which of (v1, v2, v3, v4) has real balls\nvoid init(int triangleType,\n          vec3 dihedralAngles0,\n          vec3 dihedralAngles1,\n          float dihedralAngle0_1,\n          bvec4 isRealBall) {\n    const float s2 = sqrt(2.);\n    const float s3 = sqrt(3.);\n    mat3 M0, M1;\n    vec3 b;\n    Ball B0, B1, B2, B3, B4;\n    vec3 t0 = dihedral(dihedralAngles0);\n    vec3 t1 = dihedral(dihedralAngles1);\n    float t01 = dihedral(dihedralAngle0_1);\n    // A, B, C are the vertices of the triangle formed by mirror plane v2, v3, v4 and z=0 plane\n    vec2 A, B, C;\n\n    // the 236 case\n    if (triangleType == 236) {\n        A = vec2(0, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s3/2., -0.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(s3/2., 0.5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(s3/2., 0.5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s3/2., 0);\n    }\n    \n    // the 244 case\n    else if (triangleType == 244) {\n        A = vec2(0, 0), B = vec2(0, 1), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s2/2., -s2/2., 0), s2/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(1./s2, 1./s2, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(1./s2, 1./s2, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s2/2., 0);\n    }\n    \n    // the 333 case\n    else {\n        A = vec2(-1, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(s3/2., -.5, 0), s3/2.);\n        B3 = from_plane(vec3(-s3/2., -.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(-s3/2., 0.5, t1.x), vec3(s3/2., .5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(-s3/2., 0.5, t0.x), vec3(s3/2., .5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(s3, s3, 0)/2.;\n    }\n    \n    // now we solve the virtual ball B1, this can't be a plane\n    B1 = solveBall(M1, b);\n    invertBall(B1);\n    \n    // now we solve the virtual ball B0, this can be either a plane or a sphere\n    // this depends on if all entries in dihedralAngles0 are all 2\n    if (dot(dihedralAngles0, vec3(1)) == 6.) {\n        B0 = from_plane(vec3(0, 0, -1), B1.r*t01);\n    }\n    else {\n        B0 = solveBall(M0, b);\n        float r1 = B1.r, r0 = B0.r;\n        B0.n.z = sqrt(r0*r0 + r1*r1 + 2.*r0*r1*t01 - L2(B1.n.xy - B0.n.xy));\n        invertBall(B0);\n    }\n    coclusters = Ball[5] (B0, B1, B2, B3, B4);\n\n    //now we process the real balls\n    for (int k = 0; k < 5; k++)\n        clusters[k] = defaultBall();\n        \n    if (isRealBall.x) {\n        clusters[1] = from_plane(vec3(0, 0, -1.), B0.n.z);\n        clusters[1].isRealBall = true;\n    }\n    if (isRealBall.y) {\n        clusters[2] = solveBall(C, B0, B1);\n        clusters[2].isRealBall = true;\n    }\n    if (isRealBall.z) {\n        clusters[3] = solveBall(A, B0, B1);\n        clusters[3].isRealBall = true;\n    }\n   \n    if (isRealBall.w) {\n        clusters[4] = solveBall(B, B0, B1);\n        clusters[4].isRealBall = true;\n    }\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"sddyRl","date":"0","viewed":0,"name":"Fork Lots of ps neozhaolia 847","description":"Boyd-Maxwell ball packings 3d version","likes":0,"published":"Private","usePreview":0,"tags":["3d","fractals","boydmaxwell"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2 // Make it 3 if you have a fast machine\n#endif\n\nfloat map(vec3 p, inout int index) {\n    float scale = 3.;\n    orb = vec4(1000.0); \n    for (int i = 0; i < MAX_ITER; i++) {\n        bool cond = true;\n        for (int k = 0; k < 5; k++) {\n            cond = try_reflect(p, coclusters[k], scale) && cond;\n            orb = min( orb, vec4(abs(p), dot(p, p)));\n        }\n\n        if (cond)\n            break;\n    }\n    index = 0;\n\n    float d = p.z;\n    for (int j = 1; j < 5; j++) {\n        if (clusters[j].isRealBall) {\n            float d1 = sdistanceToBall(p, clusters[j]);\n            if (d1 < d) { d = d1; index = j; }\n        }\n    }\n    return d / scale;\n}\n\n\n\nfloat trace( in vec3 ro, in vec3 rd, inout int index )\n{\n\tfloat maxd = 30.0;\n    float t = 0.001;\n    for( int i=0; i<512; i++ )\n    {\n\t    float precis = 0.001;\n        \n\t    float h = map( ro+rd*t, index );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    float precis = 0.0001 ;\n    int index;\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, index) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, index ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, index ) + \n                      e.xxx*map( pos + e.xxx, index ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    int index = 0;\n    float t = trace( ro, rd, index);\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, 0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.z);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.80,0.2), clamp(6.0*tra.z,0.0,1.0) );\n        rgb = mix( rgb, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init(333, vec3(2, 2, 3), vec3(3, 4, 2), inf, bvec4(1, 0, 0, 0));\n    float time = iTime*0.05 + 0.01*iMouse.x;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.4 + 0.30*cos(0.37*time), 1.2+1.2*cos(0.5+0.35*time) );\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.5 + 1.*cos(2.0+0.38*time) );\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(0, 0, 1);\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define MAX_ITER         40\n#define PI               3.141592653\n#define L2(x)            dot(x, x)\n#define ZOOM             3.\n#define inf              -1.05\n\nvec4 orb; \n\n// uncomment this to show the vertice sections\n//#define DrawVerticalSections\n\nfloat dihedral(float x) {\n    return x == inf ? 1. : cos(PI / x);\n}\n\nvec3 dihedral(vec3 v) {\n    return vec3(dihedral(v.x), dihedral(v.y), dihedral(v.z));\n}\n\n\n// For spheres n is the center, r is the radius\n// For planes n is the normal vector, r is the distance between the plane and the origin\n// if invert is true then the inside/outside of the sphere is interchanged (not used in this program)\n// if hasRealBall is true then this virtual ball has a real ball correspondes to it\nstruct Ball {\n    bool isplane;\n    vec3 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[5] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[5] clusters;\n\n\n// create a ball. by default it's the z=0 plane with normal points to the negative half\nBall defaultBall() {\n    return Ball(false, vec3(0, 0, -1), 0., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec3 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        return k;\n    }\n    else\n        return length(p - B.n) - B.r;\n}\n\nBall from_plane(vec3 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec3 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec3 p, Ball B, inout float scale) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec3 cen = B.n;\n        float r = B.r;\n        vec3 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        p = k * q + cen;\n        scale *= k;\n        return false;\n    }\n}\n\n// return distance to the scene, and get the index of the real ball hitted\n\n\n// solve M*v = b, where v = (x, y, r) is the xy-coordinate of the center of the ball,\n// r is the radius of the ball.\nBall solveBall(mat3 M, vec3 b) {\n    vec3 p = b * inverse(M);\n    return from_sphere(vec3(p.xy, 0.), p.z);\n}\n\n// Solve a ball with its center has xy-coordinates P, and is orthogonal to other two Balls B0, B1.\n// Here B0 may be either a sphere or a plane, B1 is always a sphere. \nBall solveBall(vec2 P, Ball B0, Ball B1) {\n    if (B0.isplane) {\n        float z = B0.r;\n        vec3 cen = vec3(P, z);\n        float R = sqrt(L2(cen - B1.n) - B1.r*B1.r);\n        return from_sphere(cen, R);\n    }\n    else {\n        float r1 = B1.r;\n        float r0 = B0.r;\n        float z0 = B0.n.z;\n        float k0 = L2(P - B0.n.xy);\n        float k1 = L2(P - B1.n.xy);\n        float z = (r1*r1 - r0*r0 + z0*z0 + k0 - k1) / (2.*z0);\n        float R = sqrt(k1 + z*z - r1*r1);\n        return from_sphere(vec3(P, z), R);\n    }\n    \n}\n\n// triangleType: must be one of 236, 244 or 333\n// dihedralAngles0: labels of the edges between v0 and (v2, v3, v4)\n// dihedralAngles1: labels of the edges between v1 and (v2, v3, v4)\n// dihedralAngles0_1: label of the edge between (v0, v1)\n// isRealBall: specify which of (v1, v2, v3, v4) has real balls\nvoid init(int triangleType,\n          vec3 dihedralAngles0,\n          vec3 dihedralAngles1,\n          float dihedralAngle0_1,\n          bvec4 isRealBall) {\n    const float s2 = sqrt(2.);\n    const float s3 = sqrt(3.);\n    mat3 M0, M1;\n    vec3 b;\n    Ball B0, B1, B2, B3, B4;\n    vec3 t0 = dihedral(dihedralAngles0);\n    vec3 t1 = dihedral(dihedralAngles1);\n    float t01 = dihedral(dihedralAngle0_1);\n    // A, B, C are the vertices of the triangle formed by mirror plane v2, v3, v4 and z=0 plane\n    vec2 A, B, C;\n\n    // the 236 case\n    if (triangleType == 236) {\n        A = vec2(0, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s3/2., -0.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(s3/2., 0.5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(s3/2., 0.5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s3/2., 0);\n    }\n    \n    // the 244 case\n    else if (triangleType == 244) {\n        A = vec2(0, 0), B = vec2(0, 1), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s2/2., -s2/2., 0), s2/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(1./s2, 1./s2, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(1./s2, 1./s2, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s2/2., 0);\n    }\n    \n    // the 333 case\n    else {\n        A = vec2(-1, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(s3/2., -.5, 0), s3/2.);\n        B3 = from_plane(vec3(-s3/2., -.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(-s3/2., 0.5, t1.x), vec3(s3/2., .5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(-s3/2., 0.5, t0.x), vec3(s3/2., .5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(s3, s3, 0)/2.;\n    }\n    \n    // now we solve the virtual ball B1, this can't be a plane\n    B1 = solveBall(M1, b);\n    invertBall(B1);\n    \n    // now we solve the virtual ball B0, this can be either a plane or a sphere\n    // this depends on if all entries in dihedralAngles0 are all 2\n    if (dot(dihedralAngles0, vec3(1)) == 6.) {\n        B0 = from_plane(vec3(0, 0, -1), B1.r*t01);\n    }\n    else {\n        B0 = solveBall(M0, b);\n        float r1 = B1.r, r0 = B0.r;\n        B0.n.z = sqrt(r0*r0 + r1*r1 + 2.*r0*r1*t01 - L2(B1.n.xy - B0.n.xy));\n        invertBall(B0);\n    }\n    coclusters = Ball[5] (B0, B1, B2, B3, B4);\n\n    //now we process the real balls\n    for (int k = 0; k < 5; k++)\n        clusters[k] = defaultBall();\n        \n    if (isRealBall.x) {\n        clusters[1] = from_plane(vec3(0, 0, -1.), B0.n.z);\n        clusters[1].isRealBall = true;\n    }\n    if (isRealBall.y) {\n        clusters[2] = solveBall(C, B0, B1);\n        clusters[2].isRealBall = true;\n    }\n    if (isRealBall.z) {\n        clusters[3] = solveBall(A, B0, B1);\n        clusters[3].isRealBall = true;\n    }\n   \n    if (isRealBall.w) {\n        clusters[4] = solveBall(B, B0, B1);\n        clusters[4].isRealBall = true;\n    }\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"cst3DH","date":"0","viewed":0,"name":"[For]Rectangular domain coloring","description":"The same domain coloring algorithm as https://www.shadertoy.com/view/tlcGzf, except rectangular.","likes":0,"published":"Private","usePreview":0,"tags":["math","complex","domaincoloring"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 f (vec2 z, float t, vec2 mouse) {\n    return cpow(z, 3.);\n}\n\nconst bool animate = true;\nconst bool grid = true; // (when not animating)\n\nconst float octaves = 4.0;\n\n// Grid lines:\nconst float lineWidth = 1.0;\nconst float lineFeather = 1.0;\nconst vec3 gridColor = vec3(0);\n\n// Power of contrast ramp function\n\nvec2 pixelToXY (vec2 point) {\n  \tvec2 aspect = vec2(1, iResolution.y / iResolution.x);\n    return (point / iResolution.xy - 0.5) * aspect * 5.0;\n}\n\n// Select an animation state\nfloat selector (float time) {\n    const float period = 10.0;\n    float t = fract(time / period);\n    return smoothstep(0.4, 0.5, t) * smoothstep(1.0, 0.9, t);\n}\n\nvec3 colorscale (float phase) {\n    return rainbow(phase / 2.0 - 0.25);\n}\n\nvec2 complexContouringGridFunction (vec2 x) {\n// distance to integer grid x=k, k in Z\n  return 2. * abs(fract(x - 0.5) - 0.5);\n}\n\nfloat checkerboard (vec2 xy) {\n// checker pattern with unit length squares\n  vec2 f = fract(xy * 0.5) * 2.0 - 1.0;\n  return f.x * f.y > 0.0 ? 1.0 : 0.0;\n}\n\nvec4 rectangularDomainColoring (vec4 f_df,\n                     vec2 steps,\n                     vec2 baseScale,\n                     vec2 gridOpacity,\n                     float shadingOpacity,\n                     float lineWidth,\n                     float lineFeather,\n                     vec3 gridColor,\n                     float phaseColoring\n) {\n  vec2 f = f_df.xy;\n  vec2 df = f_df.zw;\n  float absf = hypot(f);\n\n  baseScale *= 10.0;\n\n  // Computed as d|f|\n  float absdf = hypot(df);\n\n  float logdfx = log2(absdf) / log2(steps.x);  // logDx (|df|)\n  float Nx = floor(logdfx);\n  float fx = Nx + 1.0 - logdfx;\n\n  float logdfy = log2(absdf) / log2(steps.y);\n  float Ny = floor(logdfy);\n  float fy = Ny + 1.0 - logdfy;\n\n  // delta = D^{N} * m\n  vec2 delta = vec2(pow(steps.x, Nx), pow(steps.y, Ny)) * baseScale;\n  \n  float width1 = max(0.0, lineWidth - lineFeather);\n  float width2 = lineWidth + lineFeather;\n\n  float totalWeight = 0.0;\n  float shading = 0.0;\n\n  vec2 octaveScale = vec2(1.0);\n  vec2 grid = vec2(0.0);\n  vec2 gridScaleBase = vec2(\n    pow(steps.x, fx),\n    pow(steps.y, fy)\n  );\n\n  for(float i = 0.; i < octaves; i++) {\n    float w0 = i == 0. ? 1e-4 : i + 1.;\n    float w1 = i == octaves - 1. ? 1e-4 : i + 2.;\n    float w = mix(w0, w1, fx);\n\n    totalWeight += w;\n    vec2 value = f / delta * octaveScale;\n\n    vec2 gridSlope = baseScale * gridScaleBase / octaveScale / steps;\n    \n    \n    // draw contour lines for value = k, i.e. f / delta * octaveScale = k\n    vec2 xygrid = complexContouringGridFunction(value) * gridSlope;\n\n    grid += w * vec2(smoothstep(width2, width1, xygrid.x), smoothstep(width2, width1, xygrid.y));\n\n    shading += w * checkerboard(value);\n\n    octaveScale /= steps;\n  }\n\n  shading = shading / totalWeight;\n  grid /= totalWeight;\n  grid *= gridOpacity;\n\n  float carg = atan(f_df.y, f_df.x) * HALF_PI_INV * 2.0;\n  vec3 color = mix(vec3(1.0), clamp(colorscale(carg), 0.0, 1.0), phaseColoring);\n\n  const float gamma = 0.454;\n  color.r = pow(color.r, gamma);\n  color.g = pow(color.g, gamma);\n  color.b = pow(color.b, gamma);\n\n  color = mix(vec3(1), color, 0.97);\n\n  float mixedGrid = max(grid.x, grid.y);\n  float shade = mix(1.0, shading, shadingOpacity);\n  vec3 result = clamp(mix(color * shade, gridColor, mixedGrid), vec3(0), vec3(1));\n\n  result.r = pow(result.r, 1.0 / gamma);\n  result.g = pow(result.g, 1.0 / gamma);\n  result.b = pow(result.b, 1.0 / gamma);\n\n  return vec4(result, 1);\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = pixelToXY(fragCoord);\n    vec2 mouse = pixelToXY(iMouse.xy);\n\n    vec2 fz = f(xy, iTime * 0.2, mouse);\n\n    // fwidth(fz) works, but it adds ugly anisotropy in the width of lines near zeros/poles.\n    // Insead, we compute the magnitude of the derivatives separately.\n    //\n    // Also *NOTE* that this is a very important place in which we use `hypot` instead of an\n    // algebraically equivalent built-in `length`. Floating point is limited and we lose lots\n    // of our floating point domain if we're not careful about over/underflow.\n    vec4 fdf = vec4(fz, vec2(hypot(dFdx(fz)), hypot(dFdy(fz))));\n\n   \tfloat select = animate ? selector(iTime) : (grid ? 1.0 : 0.0);\n\n    fragColor = rectangularDomainColoring(\n        fdf,\n        vec2(8.0), // steps\n        vec2(1.0), // scale\n        mix(vec2(0.4), vec2(1.0), select), // grid opacity\n        mix(0.2, 0.0, select),       // shading opacity\n        lineWidth,\n        lineFeather,\n        gridColor,\n        mix(1.0, 0.0, select)        // phase coloring\n    );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Complex math! Beware that these functions are not all great for overflow,\n// even though a GPU is precisely the sort of place where you ought to be \n// *very* concerned about overflow.\n//\n// This also includes a partial implementation of automatic differentiation\n// for complex arithmetic using vec4 as a + bi --> vec4(a, b, da, db). This\n// may be used to successfully avoid standard derivatives, though I just\n// didn't find it worthwhile when standard derivatives are so easy and well\n// supported.\n\n#define PI 3.141592653589793238\n#define TO_RADIANS 0.01745329251\n#define HALF_PI 1.57079633\n#define HALF_PI_INV 0.15915494309\n#define PI_INV 0.31830988618\n#define TWO_PI 6.28318530718\n\nfloat hypot (vec2 z) {\n  float x = abs(z.x);\n  float y = abs(z.y);\n  float t = min(x, y);\n  x = max(x, y);\n  t = t / x;\n  return x * sqrt(1.0 + t * t);\n}\n\nvec2 cadd (vec2 a, vec2 b) {\n  return a + b;\n}\n\nvec2 csub (vec2 a, vec2 b) {\n  return a - b;\n}\n\nfloat cmod (vec2 z) {\n  return hypot(z);\n} \n\nvec2 csqrt (vec2 z) {\n  float t = sqrt(2.0 * (cmod(z) + (z.x >= 0.0 ? z.x : -z.x)));\n  vec2 f = vec2(0.5 * t, abs(z.y) / t);\n\n  if (z.x < 0.0) f.xy = f.yx;\n  if (z.y < 0.0) f.y = -f.y;\n\n  return f;\n}\n\n/*\nfloat sinh (float x) {\n  return 0.5 * (exp(x) - exp(-x));\n}\n\nfloat cosh (float x) {\n  return 0.5 * (exp(x) + exp(-x));\n}*/\n\nvec2 sinhcosh (float x) {\n  vec2 ex = exp(vec2(x, -x));\n  return 0.5 * (ex - vec2(ex.y, -ex.x));\n}\n\nfloat cabs (vec2 z) {\n  return cmod(z);\n}\n\nvec2 clog(vec2 z) {\n  return vec2(\n    log(hypot(z)),\n    atan(z.y, z.x)\n  );\n}\n\nvec2 catan (vec2 z) {\n  float a = z.x * z.x + (1.0 - z.y) * (1.0 - z.y);\n  vec2 b = clog(vec2(1.0 - z.y * z.y - z.x * z.x, -2.0 * z.x) / a);\n  return 0.5 * vec2(-b.y, b.x);\n} \n\nvec2 catanh (vec2 z) {\n  float oneMinus = 1.0 - z.x;\n  float onePlus = 1.0 + z.x;\n  float d = oneMinus * oneMinus + z.y * z.y;\n\n  vec2 x = vec2(onePlus * oneMinus - z.y * z.y, z.y * 2.0) / d;\n\n  vec2 result = vec2(log(hypot(x)), atan(x.y, x.x)) * 0.5;\n\n  return result;\n} \n\nvec2 cacos (vec2 z) {\n  vec2 a = csqrt(vec2(\n    z.y * z.y - z.x * z.x + 1.0,\n    -2.0 * z.x * z.y\n  ));\n\n  vec2 b = clog(vec2(a.x - z.y, a.y + z.x));\n  return vec2(HALF_PI - b.y, b.x);\n} \n\nvec2 cacosh (vec2 z) {\n  vec2 a = cacos(z);\n\n  if (a.y <= 0.0) {\n    return vec2(-a.y, a.x);\n  }\n\n  return vec2(a.y, -a.x);\n} \n\nvec2 cacot (vec2 z) {\n  return catan(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 cacoth(vec2 z) {\n  return catanh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casin (vec2 z) {\n  vec2 a = csqrt(vec2(\n    z.y * z.y - z.x * z.x + 1.0,\n    -2.0 * z.x * z.y\n  ));\n\n  vec2 b = clog(vec2(\n    a.x - z.y,\n    a.y + z.x\n  ));\n\n  return vec2(b.y, -b.x);\n} \n\nvec2 casinh (vec2 z) {\n  vec2 res = casin(vec2(z.y, -z.x));\n  return vec2(-res.y, res.x);\n} \n\nvec2 cacsch(vec2 z) {\n  return casinh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casec (vec2 z) {\n  float d = dot(z, z);\n  return cacos(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 casech(vec2 z) {\n  return cacosh(vec2(z.x, -z.y) / dot(z, z));\n} \n\nvec2 cconj (vec2 z) {\n  return vec2(z.x, -z.y);\n} \n\nvec2 ccos (vec2 z) {\n  return sinhcosh(z.y).yx * vec2(cos(z.x), -sin(z.x));\n} \n\nvec2 ccosh (vec2 z) {\n  return sinhcosh(z.x).yx * vec2(cos(z.y), sin(z.y));\n} \n\nvec2 ccot (vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.y);\n  return vec2(-sin(z.x), sch.x) / (cos(z.x) - sch.y);\n} \n\nvec2 ccoth(vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.x);\n  return vec2(sch.x, -sin(z.y)) / (sch.y - cos(z.y));\n} \n\nvec2 ccsc (vec2 z) {\n  float d = 0.25 * (exp(2.0 * z.y) + exp(-2.0 * z.y)) - 0.5 * cos(2.0 * z.x);\n\n  return sinhcosh(z.y).yx * vec2(sin(z.x), -cos(z.x)) / d;\n} \n\nvec2 ccsch (vec2 z) {\n  vec2 sch = sinhcosh(z.x);\n  float d = cos(2.0 * z.y) - (exp(2.0 * z.x) + exp(-2.0 * z.x)) * 0.5;\n  return vec2(-cos(z.y), sin(z.y)) * sch / (0.5 * d);\n} \n\nvec2 cdiv (vec2 a, vec2 b) {\n  float e, f;\n  float g = 1.0;\n  float h = 1.0;\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    h = e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g = e;\n  }\n\n  return (a * g + h * vec2(a.y, -a.x)) / f;\n} \n\nvec2 cexp(vec2 z) {\n  return vec2(cos(z.y), sin(z.y)) * exp(z.x);\n} \n\nvec2 cinv (vec2 b) {\n  float e, f;\n  vec2 g = vec2(1, -1);\n\n  if( abs(b.x) >= abs(b.y) ) {\n    e = b.y / b.x;\n    f = b.x + b.y * e;\n    g.y = -e;\n  } else {\n    e = b.x / b.y;\n    f = b.x * e + b.y;\n    g.x = e;\n  }\n\n  return g / f;\n} \n\nvec2 cmul (vec2 a, vec2 b) {\n  return vec2(\n    a.x * b.x - a.y * b.y,\n    a.y * b.x + a.x * b.y\n  );\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c) {\n  return cmul(cmul(a, b), c);\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d) {\n  return cmul(cmul(a, b), cmul(c, d));\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e) {\n  return cmul(cmul(a, b, c), cmul(d, e));\n}\n\nvec2 cmul (vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, vec2 f) {\n  return cmul(cmul(a, b, c), cmul(d, e, f));\n} \n\nvec2 cpolar (vec2 z) {\n  return vec2(\n    atan(z.y, z.x),\n    hypot(z)\n  );\n} \n\nvec2 cpow (vec2 z, float x) {\n  float r = hypot(z);\n  float theta = atan(z.y, z.x) * x;\n  return vec2(cos(theta), sin(theta)) * pow(r, x);\n}\n\nvec2 cpow (vec2 a, vec2 b) {\n  float aarg = atan(a.y, a.x);\n  float amod = hypot(a);\n\n  float theta = log(amod) * b.y + aarg * b.x;\n\n  return vec2(\n    cos(theta),\n    sin(theta)\n  ) * pow(amod, b.x) * exp(-aarg * b.y);\n} \n\nvec2 csec (vec2 z) {\n  float d = 0.25 * (exp(2.0 * z.y) + exp(-2.0 * z.y)) + 0.5 * cos(2.0 * z.x);\n  return sinhcosh(z.y).yx * vec2(cos(z.x), sin(z.x)) / d;\n} \n\nvec2 csech(vec2 z) {\n  float d = cos(2.0 * z.y) + 0.5 * (exp(2.0 * z.x) + exp(-2.0 * z.x));\n  vec2 sch = sinhcosh(z.x);\n\n  return vec2(cos(z.y), -sin(z.y)) * sch.yx / (0.5 * d);\n} \n\nvec2 csin (vec2 z) {\n  return sinhcosh(z.y).yx * vec2(sin(z.x), cos(z.x));\n} \n\nvec4 csincos (vec2 z) {\n  float c = cos(z.x);\n  float s = sin(z.x);\n  return sinhcosh(z.y).yxyx * vec4(s, c, c, -s);\n} \n\nvec2 csinh (vec2 z) {\n  return sinhcosh(z.x) * vec2(cos(z.y), sin(z.y));\n} \n\nvec2 csqr (vec2 z) {\n  return vec2(\n    z.x * z.x - z.y * z.y,\n    2.0 * z.x * z.y\n  );\n} \n\nvec2 ctan (vec2 z) {\n  vec2 e2iz = cexp(2.0 * vec2(-z.y, z.x));\n\n  return cdiv(\n    e2iz - vec2(1, 0),\n    vec2(-e2iz.y, 1.0 + e2iz.x)\n  );\n} \n\nvec2 ctanh (vec2 z) {\n  z *= 2.0;\n  vec2 sch = sinhcosh(z.x);\n  return vec2(sch.x, sin(z.y)) / (sch.y + cos(z.y));\n}\n\n\nvec4 cmul (vec4 a, vec4 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.xy, b.zw) + cmul(a.zw, b.xy)\n  );\n}\n\nvec4 cmul (vec2 a, vec4 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.xy, b.zw)\n  );\n}\n\nvec4 cmul (vec4 a, vec2 b) {\n  return vec4(\n    cmul(a.xy, b.xy),\n    cmul(a.zw, b.xy)\n  );\n}\n\nvec4 cmul (vec4 a, vec4 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec4 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec2 b, vec4 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec4 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec4 a, vec2 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec4 b, vec2 c) { return cmul(cmul(a, b), c); }\nvec4 cmul (vec2 a, vec2 b, vec4 c) { return cmul(cmul(a, b), c); }\n\nvec4 csqr (vec4 a) {\n  return vec4(\n    csqr(a.xy),\n    2.0 * cmul(a.xy, a.zw)\n  );\n}\nvec4 cdiv (vec4 a, vec4 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(cmul(b.xy, a.zw) - cmul(a.xy, b.zw), csqr(b.xy))\n  );\n}\n\nvec4 cdiv (vec2 a, vec4 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(-cmul(a.xy, b.zw), csqr(b.xy))\n  );\n}\n\nvec4 cdiv (vec4 a, vec2 b) {\n  return vec4(\n    cdiv(a.xy, b.xy),\n    cdiv(cmul(b.xy, a.zw), csqr(b.xy))\n  );\n}\n\nvec4 csub(vec4 a, vec4 b) {\n  return a - b;\n}\n\nvec4 csub(vec2 a, vec4 b) {\n  return vec4(a.xy - b.xy, -b.zw);\n}\n\nvec4 csub(vec4 a, vec2 b) {\n  return vec4(a.xy - b.xy, a.zw);\n}\n\nvec4 cadd(vec4 a, vec4 b) {\n  return a + b;\n}\n\nvec4 cadd(vec2 a, vec4 b) {\n  return vec4(a.xy + b.xy, b.zw);\n}\n\nvec4 cadd(vec4 a, vec2 b) {\n  return vec4(a.xy + b.xy, a.zw);\n}\n\n\nvec4 cinv(vec4 a) {\n  vec2 ainv = cinv(a.xy);\n  return vec4(ainv, cmul(a.zw, -csqr(ainv)));\n}\n\nvec4 cexp(vec4 a) {\n  vec2 expa = cexp(a.xy);\n  return vec4(expa, cmul(expa, a.zw));\n}\n\nvec4 csqrt(vec4 a) {\n  float r = hypot(a.xy);\n  float b = sqrt(2.0 * (r + a.x));\n  float c = sqrt(2.0 * (r - a.x));\n  float re = a.x >= 0.0 ? 0.5 * b : abs(a.y) / c;\n  float im = a.x <= 0.0 ? 0.5 * c : abs(a.y) / b;\n  vec2 s = vec2(re, a.y < 0.0 ? -im : im);\n  return vec4(s, cmul(a.zw, 0.5 * cinv(s)));\n}\n\n/*vec4 cpow(vec4 a, float n) {\n  float theta = atan(a.y, a.x);\n  float r = hypot(a.xy);\n  float tn = theta * n;\n  float rn = pow(r, n);\n  vec2 s = rn * vec2(sin(tn), cos(tn));\n  float rn1 = pow(r, n - 1.0);\n  float tn1 = theta * (n - 1.0);\n  return vec4(s, cmul(a.zw, n * rn1 * vec2(sin(tn1), cos(tn1))));\n}*/\n\nvec4 clog(vec4 z) {\n  return vec4(\n    log(hypot(z.xy)),\n    atan(z.y, z.x),\n    cdiv(z.zw, z.xy)\n  );\n}\n\nvec4 csin(vec4 a) {\n  vec4 asincos = csincos(a.xy);\n  return vec4(asincos.xy, cmul(asincos.zw, a.zw));\n}\n\nvec4 ccos(vec4 a) {\n  vec4 asincos = csincos(a.xy);\n  return vec4(asincos.zw, cmul(-asincos.xy, a.zw));\n}\n\nvec4 ctan(vec4 a) {\n  return cdiv(csin(a), ccos(a));\n}\n\nvec4 casin(vec4 z) {\n  vec4 s = clog(vec4(-z.y, z.x, -z.w, z.z) + csqrt(csub(vec2(1, 0), csqr(z))));\n  return vec4(s.y, -s.x, s.w, -s.z);\n}\n\nvec4 cacos(vec4 z) {\n  vec4 s = -casin(z);\n  s.x += HALF_PI;\n  return s;\n}\n\nvec4 catan(vec4 z) {\n  vec2 s = clog(cdiv(cadd(vec2(0, 1), z.xy), csub(vec2(0, 1), z.xy)));\n  return vec4(\n     0.5 * vec2(-s.y, s.x),\n     cmul(z.zw, cinv(cadd(vec2(1, 0), csqr(z))))\n  );\n}\n\nvec4 csinh(vec4 z) {\n  vec4 ez = cexp(z);\n  return 0.5 * (ez - cinv(ez));\n}\n\nvec4 ccosh(vec4 z) {\n  vec4 ez = cexp(z);\n  return 0.5 * (ez + cinv(ez));\n}\n\nvec4 ctanh(vec4 z) {\n  vec4 ez = cexp(z);\n  vec4 ezinv = cinv(ez);\n  return 0.5 * cdiv(ez - ezinv, ez + ezinv);\n}\n\nvec4 casinh(vec4 z) {\n  return clog(cadd(z, csqrt(cadd(vec2(1, 0), csqr(z)))));\n}\n\nvec4 cacosh(vec4 z) {\n  return clog(z + cmul(csqrt(cadd(z, vec2(1, 0))), csqrt(csub(z, vec2(1, 0)))));\n}\n\nvec4 catanh(vec4 z) {\n  return 0.5 * clog(cdiv(cadd(z, vec2(1,  0)), csub(vec2(1, 0), z)));\n}\n\n// https://github.com/d3/d3-color\n// Copyright 2010-2016 Mike Bostock\n// All rights reserved.\n// \n// Redistribution and use in source and binary forms, with or without modification,\n// are permitted provided that the following conditions are met:\n// \n// * Redistributions of source code must retain the above copyright notice, this\n//   list of conditions and the following disclaimer.\n// \n// * Redistributions in binary form must reproduce the above copyright notice,\n//   this list of conditions and the following disclaimer in the documentation\n//   and/or other materials provided with the distribution.\n// \n// * Neither the name of the author nor the names of contributors may be used to\n//   endorse or promote products derived from this software without specific prior\n//   written permission.\n// \n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n// ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\nvec3 cubehelix(vec3 c) {\n  vec2 sc = vec2(sin(c.x), cos(c.x));\n  return c.z * (1.0 + c.y * (1.0 - c.z) * (\n    sc.x * vec3(0.14861, 0.29227, -1.97294) + \n    sc.y * vec3(1.78277, -0.90649, 0.0)\n  ));\n}\n\nvec3 rainbow(float t) {\n  return cubehelix(vec3(\n    TWO_PI * t - 1.74533,\n    (0.25 * cos(TWO_PI * t) + 0.25) * vec2(-1.5, -0.9) + vec2(1.5, 0.8)\n  ));\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"msd3WN","date":"0","viewed":0,"name":"Isometries in Poincare's disk","description":"Isometries of hyperbolic space in Poincare's disk model","likes":0,"published":"Private","usePreview":0,"tags":["2d","math","geometry","hyperbolic"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI        3.141592654\n\nmat2 rot2d(float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x + z.y * w.y,\n        -z.x * w.y + z.y * w.x\n    ) / dot(w, w);\n}\n\nvec2 cconj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nstruct Mobius {\n    vec2 A, B, C, D;\n};\n\nfloat hypot (vec2 z) {\n    float x = abs(z.x);\n    float y = abs(z.y);\n    float t = min(x, y);\n    x = max(x, y);\n    t = t / x;\n    return x * sqrt(1.0 + t * t);\n}\n\n\nfloat e2h(float r) {\n    return 2. * atanh(r);\n}\n\nfloat h2e(float r) {\n    return tanh(0.5 * r);\n}\n\nMobius mobInverse(Mobius m) {\n    return Mobius(\n        m.D, -m.B, -m.C, m.A\n    );\n}\n\nvec2 applyMobius(Mobius m, vec2 z) {\n    return cdiv(cmul(m.A, z) + m.B, cmul(m.C, z) + m.D);\n}\n\nMobius translation(vec2 p) {\n    return Mobius(\n        vec2(1, 0), -p, -cconj(p), vec2(1, 0)\n    );\n}\n\nMobius translation2(vec2 p) {\n    return Mobius(\n        vec2(1, 0), p, cconj(p), vec2(1, 0)\n    );\n}\n\nMobius rotation(float a) {\n    return Mobius(\n        vec2(cos(a), sin(a)), vec2(0), vec2(0), vec2(1, 0)\n    );\n}\n\nMobius composite(Mobius m1, Mobius m2) {\n    vec2 A = cmul(m1.A, m2.A) + cmul(m1.B, m2.C);\n    vec2 B = cmul(m1.A, m2.B) + cmul(m1.B, m2.D);\n    vec2 C = cmul(m1.C, m2.A) + cmul(m1.D, m2.C);\n    vec2 D = cmul(m1.C, m2.B) + cmul(m1.D, m2.D);\n    return Mobius(A, B, C, D);\n}\n\nMobius composite(Mobius m1, Mobius m2, Mobius m3) {\n    return composite(m1, composite(m2, m3));\n}\n\nMobius rotation(vec2 p, float a) {\n    Mobius m1 = translation(-p);\n    Mobius m2 = rotation(a);\n    Mobius m3 = translation(p);\n    return composite(m3, m2, m1);\n}\n\n\nvec2 rectGrid(vec2 z, vec2 size) {\n    return mod(z + 0.5 * size, size) - 0.5 * size;\n}\n\nvec2 polarGrid(vec2 z, vec2 size) {\n    float theta = atan(z.y, z.x);\n    float r = e2h(hypot(z));\n    return rectGrid(vec2(r, theta), size);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 c = vec2(0.2, 0.4);\n    Mobius m = translation(c);\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 1.02;\n    vec2 p = uv;\n    vec3 col = vec3(1);\n    \n    if (length(p) < 1.) {\n\n        p = applyMobius(m, p);\n        p = rot2d(iTime / 3.) * p;\n        vec2 polar = polarGrid(p, vec2(.5, PI/6.));\n        float d1 = abs(polar.x);\n        float d2 = abs(polar.y);\n        \n                \n        float K = hypot(vec2(dFdx(e2h(length(p))), dFdy(e2h(length(p)))));\n        d1 /= K * iResolution.y / 2.;\n        \n       \n        \n        float L = hypot(vec2(dFdx(atan(p.y, p.x)), dFdy(atan(p.y, p.x))));\n        d2 /= L * iResolution.y / 2.;\n        \n        float d = hypot(vec2(d1, d2));\n        //d /= (1. - pow(dot(p, p), 10.));\n\n        float sf = 2. / iResolution.y;\n        col = mix(col, vec3(0), 1. - smoothstep(0.00, sf, d1 - sf));\n        col = mix(col, vec3(0), 1. - smoothstep(0.00, sf, d2 - sf));\n       \n        col = mix(col, vec3(0), 1. - smoothstep(0.00, sf, d - 7.*sf));\n    }\n    \n    vec2 q = vec2(0.1, 0);\n             \n    q = applyMobius(m, q);\n  \n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0.00, 0.01, abs(length(p-q)) - 0.03));\n    col = mix(col, vec3(0), 1. - smoothstep(0.00, 0.01, abs(length(p) - 1.0)));\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"Dd33RB","date":"0","viewed":0,"name":"Fork Isometries neozhaolia 602","description":"Isometries of hyperbolic space in Poincare's disk model","likes":0,"published":"Private","usePreview":0,"tags":["2d","math","geometry","hyperbolic"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI        3.141592654\n\nmat2 rot2d(float a) {\n    float ca = cos(a), sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x - z.y * w.y,\n        z.x * w.y + z.y * w.x\n    );\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    return vec2(\n        z.x * w.x + z.y * w.y,\n        -z.x * w.y + z.y * w.x\n    ) / dot(w, w);\n}\n\nvec2 cconj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nstruct Mobius {\n    vec2 A, B, C, D;\n};\n\nfloat hypot (vec2 z) {\n    float x = abs(z.x);\n    float y = abs(z.y);\n    float t = min(x, y);\n    x = max(x, y);\n    t = t / x;\n    return x * sqrt(1.0 + t * t);\n}\n\n\nfloat e2h(float r) {\n    return 2. * atanh(r);\n}\n\nfloat h2e(float r) {\n    return tanh(0.5 * r);\n}\n\nMobius mobInverse(Mobius m) {\n    return Mobius(\n        m.D, -m.B, -m.C, m.A\n    );\n}\n\nvec2 applyMobius(Mobius m, vec2 z) {\n    return cdiv(cmul(m.A, z) + m.B, cmul(m.C, z) + m.D);\n}\n\nMobius translation(vec2 p) {\n    return Mobius(\n        vec2(1, 0), -p, -cconj(p), vec2(1, 0)\n    );\n}\n\nMobius translation2(vec2 p) {\n    return Mobius(\n        vec2(1, 0), p, cconj(p), vec2(1, 0)\n    );\n}\n\nMobius rotation(float a) {\n    return Mobius(\n        vec2(cos(a), sin(a)), vec2(0), vec2(0), vec2(1, 0)\n    );\n}\n\nMobius composite(Mobius m1, Mobius m2) {\n    vec2 A = cmul(m1.A, m2.A) + cmul(m1.B, m2.C);\n    vec2 B = cmul(m1.A, m2.B) + cmul(m1.B, m2.D);\n    vec2 C = cmul(m1.C, m2.A) + cmul(m1.D, m2.C);\n    vec2 D = cmul(m1.C, m2.B) + cmul(m1.D, m2.D);\n    return Mobius(A, B, C, D);\n}\n\nMobius composite(Mobius m1, Mobius m2, Mobius m3) {\n    return composite(m1, composite(m2, m3));\n}\n\nMobius rotation(vec2 p, float a) {\n    Mobius m1 = translation(-p);\n    Mobius m2 = rotation(a);\n    Mobius m3 = translation(p);\n    return composite(m3, m2, m1);\n}\n\n\nvec2 recGrid(vec2 z, vec2 size) {\n    return mod(z + 0.5 * size, size) - 0.5 * size;\n}\n\nvec2 polarGrid(vec2 z, vec2 size) {\n    float theta = atan(z.y, z.x);\n    float r = e2h(hypot(z));\n    return recGrid(vec2(r, theta), size);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 c = vec2(0.2, 0.4);\n    Mobius m = translation(c);\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    uv *= 1.1;\n    vec2 p = uv;\n    vec3 col = vec3(1);\n    \n    if (length(p) < 1.) {\n\n        p = applyMobius(m, p);\n        p = rot2d(iTime / 3.) * p;\n        vec2 polar = polarGrid(p, vec2(.5, PI/6.));\n        float d1 = abs(polar.x);\n        float d2 = abs(polar.y);\n        \n                \n        float K = hypot(vec2(dFdx(e2h(length(p))), dFdy(e2h(length(p)))));\n        d1 /= K * iResolution.y / 2.;\n        \n       \n        \n        float L = hypot(vec2(dFdx(atan(p.y, p.x)), dFdy(atan(p.y, p.x))));\n        d2 /= L * iResolution.y / 2.;\n        \n        float d = hypot(vec2(d1, d2));\n\n        float sf = 2. / iResolution.y;\n        col = mix(col, vec3(0), 1. - smoothstep(0.00, sf, d1 - sf));\n        col = mix(col, vec3(0), 1. - smoothstep(0.00, sf, d2 - sf));\n       \n        col = mix(col, vec3(0), 1. - smoothstep(0.00, sf, d - 4.*sf));\n    }\n    \n    vec2 q = vec2(0.1, 0);\n             \n    q = applyMobius(m, q);\n  \n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0.00, 0.01, abs(length(p-q)) - 0.03));\n    col = mix(col, vec3(0), 1. - smoothstep(0.00, 0.01, abs(length(p) - 1.0) - 0.01));\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"dtdGWn","date":"0","viewed":0,"name":"liang fork Apollonian","description":"The classic standard apollonian/kleinian fractal (everybody needs to render one at some point).","likes":0,"published":"Private","usePreview":0,"tags":["3d","raymarching","fractal","distancefield","kleinian","apollonian","vr"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Apollonian\" by iq. https://shadertoy.com/view/4ds3zn\n// 2023-04-23 15:41:41\n\n// Created by inigo quilez - iq/2013\n//   https://www.youtube.com/c/InigoQuilez\n//   https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\n// I can't recall where I learnt about this fractal.\n//\n// Coloring and fake occlusions are done by orbit trapping, as usual.\n\n\n// Antialiasing level\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2 // Make it 3 if you have a fast machine\n#endif\n\nvec4 orb; \n\nfloat map( vec3 p, float s )\n{\n float DEfactor=1.;\n\tfloat scale = 1.0;\n\n\torb = vec4(1000.0); \n\t\n\t float d = map(p, DEfactor, orbitTrap);\n\n\t\n\treturn 0.25*d/scale;\n}\n\nfloat trace( in vec3 ro, in vec3 rd, float s )\n{\n\tfloat maxd = 30.0;\n    float t = 0.01;\n    for( int i=0; i<512; i++ )\n    {\n\t    float precis = 0.001 * t;\n        \n\t    float h = map( ro+rd*t, s );\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos, in float t, in float s )\n{\n    float precis = 0.001 * t;\n\n    vec2 e = vec2(1.0,-1.0)*precis;\n    return normalize( e.xyy*map( pos + e.xyy, s ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, s ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, s ) + \n                      e.xxx*map( pos + e.xxx, s ) );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in float anim )\n{\n    // trace\t\n    vec3 col = vec3(0.0);\n    float t = trace( ro, rd, anim );\n    if( t>0.0 )\n    {\n        vec4 tra = orb;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t, anim );\n\n        // lighting\n        vec3  light1 = vec3(  0.577, 0.577, -0.577 );\n        vec3  light2 = vec3( -0.707, 0.000,  0.707 );\n        float key = clamp( dot( light1, nor ), 0.0, 1.0 );\n        float bac = clamp( 0.2 + 0.8*dot( light2, nor ), 0.0, 1.0 );\n        float amb = (0.7+0.3*nor.y);\n        float ao = pow( clamp(tra.w*2.0,0.0,1.0), 1.2 );\n\n        vec3 brdf  = 1.0*vec3(0.40,0.40,0.40)*amb*ao;\n        brdf += 1.0*vec3(1.00,1.00,1.00)*key*ao;\n        brdf += 1.0*vec3(0.40,0.40,0.40)*bac*ao;\n\n        // material\t\t\n        vec3 rgb = vec3(1.0);\n        rgb = mix( rgb, vec3(1.0,0.80,0.2), clamp(6.0*tra.y,0.0,1.0) );\n        rgb = mix( rgb, vec3(1.0,0.55,0.0), pow(clamp(1.0-2.0*tra.z,0.0,1.0),8.0) );\n\n        // color\n        col = rgb*brdf*exp(-0.2*t);\n    }\n\n    return sqrt(col);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init();\n    float time = iTime*0.25;\n    float anim = 1.1 + 0.5*smoothstep( -0.3, 0.3, cos(0.1*iTime) );\n    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int jj=0; jj<AA; jj++ )\n    for( int ii=0; ii<AA; ii++ )\n    #else\n    int ii = 1, jj = 1;\n    #endif\n    {\n        vec2 q = fragCoord.xy+vec2(float(ii),float(jj))/float(AA);\n        vec2 p = (2.0*q-iResolution.xy)/iResolution.y;\n\n        // camera\n        vec3 ro = vec3( 2.8*cos(0.1+.33*time), 0.4 + 0.30*cos(0.37*time), 2.8*cos(0.5+0.35*time) ).xzy;\n        vec3 ta = vec3( 1.9*cos(1.2+.41*time), 0.4 + 0.10*cos(0.27*time), 1.9*cos(2.0+0.38*time) ).xzy;\n        float roll = 0.2*cos(0.1*time);\n        vec3 cw = normalize(ta-ro);\n        vec3 cp = vec3(sin(roll), 0., cos(roll));\n        vec3 cu = normalize(cross(cw,cp));\n        vec3 cv = normalize(cross(cu,cw));\n        vec3 rd = normalize( p.x*cu + p.y*cv + 2.0*cw );\n\n        tot += render( ro, rd, anim );\n    }\n    \n    tot = tot/float(AA*AA);\n    \n\tfragColor = vec4( tot, 1.0 );\t\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"int euclideanTriangleType = 1;\nvec3 dihedralAngles0_234 = vec3(3, 2, 7);\nvec3 dihedralAngles1_234 = vec3(2, 3, 7);\nfloat dihedralAngle0_1 = 4.;\nvec4 isRealBall = vec4(0);\nint Iterations = 39;\nfloat DEcor = 1.;\nvec4 orbitTrap;\n\n#define inf           1.0\n#define L2(x)         dot(x, x)\n#define PI           3.141592653\n\n//infinite foldings-----------------------------------------------------------//\n//fold about line with normal ndir (normalized) and dist to origin d.\nvoid fold(inout vec2 p, in vec2 ndir, in float d) {\n    float t = dot(p, ndir) + d;\n    t = 2.*min(t,0.);\n    p -= t * ndir;\n}\n\n//fmod with step = stp\nvoid infmod(inout float x, float stp) {\n    x *= 1./stp;\n    x -= floor(x);\n    x *= stp;\n}\n\n//infinite fold. stp is the tile size.\n//its like performing infinite folds about plane at 0 and plane at stp\nvoid inffold(inout float x, float stp) {\n    x *= 1./(2.*stp);\n    x -= floor(x);\n    x  = 0.5 - abs( x - 0.5 );\n    x *= 2.*stp;\n}\n\n//Simplest: fold into unit square then about the diagonal\nvoid fold244(inout vec2 p) {\n    inffold( p.x , 1. );\n    inffold( p.y , 1. );\n#define VAL sqrt(2.)/2.\n    fold( p, -vec2( VAL, VAL ), VAL);\n#undef VAL\n}\n\n//fold into rectangle then a little sequence of line folds.\nvoid fold236(inout vec2 p) {\n#define S3 sqrt(3.)\n    inffold( p.x , 3. );\n    inffold( p.y , S3 );\n    vec2 n = -0.5 * vec2(S3, 1.);\n    float d = .5 * S3;\n    fold(p, n, d);\n    p = abs(p);\n    fold(p, n, d);\n#undef S3\n}\n\n//most complicated\nvoid fold333(inout vec2 p) {\n#define S3 sqrt(3.)\n    //change origin\n    p.x += 1.;\n    //fold y into segment of height sqrt(3)\n    inffold( p.y ,S3 );\n    //change of coordinates to go to ( (2,0) ; (1,sqrt(3)) ) ish basis. We only nees x coordinate to be transformed\n    p.x -= p.y * 1. / S3;\n    //do an fmod instead for x.\n    infmod(p.x, 6.);\n    //undo the coordinates change\n    p.x += p.y * 1./S3;\n    //The folding sequence... 4 folds\n    //There are other choices. I've choosen the one where I need only one direction instead of two.\n    vec2 n = -0.5 * vec2(S3, 1.);\n    float d = 2. * S3;\n    //1st\n    fold(p, n, d);\n    //2nd\n    d = S3;\n    fold(p, n, d);\n    //3rd\n    p.y = abs(p.y);\n    //4th same as 2nd\n    fold(p, n, d);\n    //restore origin\n    p.x -=1.;\n#undef S3\n}\n\nconst float s2 = sqrt(2.);\nconst float s3 = sqrt(3.);\n\nfloat dihedral(float x) {\n    return x == inf ? inf : cos(PI / x);\n}\n\nvec3 dihedral(vec3 v) {\n    return vec3(dihedral(v.x), dihedral(v.y), dihedral(v.z));\n}\n\nstruct Ball {\n    bool isplane;\n    vec3 n;\n    float r;\n    bool invert;\n    bool isRealBall;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[5] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[5] clusters;\n\nBall defaultBall() {\n    return Ball(false, vec3(0, 0, -1), 0., false, false);\n}\n\n// Distance from a point to a ball\nfloat sdistanceToBall(vec3 p, Ball B) {\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        return k;\n    }\n    else\n        return length(p - B.n) - B.r;\n}\n\nBall from_plane(vec3 n, float d) {\n    return Ball(true, n, d, false, false);\n}\n\nBall from_sphere(vec3 cen, float r) {\n    return Ball(false, cen, r, false, false);\n}\n\nvoid invertBall(inout Ball B) {\n    B.invert = !B.invert;\n}\n\nbool try_reflect(inout vec3 p,\n                 in Ball B,\n                 inout float scale,\n                 inout vec4 orb) {\n    orb = min(orb, vec4(abs(p),dot(p,p)));\n    if (B.isplane) {\n        float k = dot(vec4(p, 1), vec4(B.n, B.r));\n        if (k >= 0.)\n            return true;\n        p -= 2. * k  * B.n;\n        return false;\n    }\n    else {\n        vec3 cen = B.n;\n        float r = B.r;\n        vec3 q = p - cen;\n        float d2 = dot(q, q);\n        float k = (r * r) / d2;\n        if ( (k < 1.0 && B.invert) || (k > 1. && !B.invert) )\n            return true;\n        else {\n            scale *= k;\n            p = k * q + cen;\n            return false;\n        }\n    }\n}\n\nBall solveBall(mat3 M, vec3 b) {\n    vec3 p = b * inverse(M);\n    return from_sphere(vec3(p.xy, 0.), p.z);\n}\n\nBall solveBall(vec2 P, Ball B0, Ball B1) {\n    if (B0.isplane) {\n        float z = B0.r;\n        vec3 cen = vec3(P, z);\n        float R = sqrt(L2(cen - B1.n) - B1.r*B1.r);\n        return from_sphere(cen, R);\n    }\n    else {\n        float r1 = B1.r;\n        float r0 = B0.r;\n        float z0 = B0.n.z;\n        float k0 = L2(P - B0.n.xy);\n        float k1 = L2(P - B1.n.xy);\n        float z = (r1*r1 - r0*r0 + z0*z0 + k0 - k1) / (2.*z0);\n        float R = sqrt(k1 + z*z - r1*r1);\n        return from_sphere(vec3(P, z), R);\n    }\n}\n\nvoid init() {\n\n    mat3 M0, M1;\n    vec3 b;\n    Ball B0, B1, B2, B3, B4;\n    vec3 t0 = dihedral(dihedralAngles0_234);\n    vec3 t1 = dihedral(dihedralAngles1_234);\n    float t01 = dihedral(dihedralAngle0_1);\n    // A, B, C are the vertices of the triangle formed by mirror plane v2, v3, v4 and z=0 plane\n    vec2 A, B, C;\n\n    // the 236 case\n    if (euclideanTriangleType == 0) {\n        A = vec2(0, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s3/2., -0.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(s3/2., 0.5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(s3/2., 0.5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s3/2., 0);\n    }\n\n    // the 244 case\n    else if (euclideanTriangleType == 1) {\n        A = vec2(0, 0), B = vec2(0, 1), C = vec2(1, 0);\n        B2 = from_plane(vec3(1, 0, 0), 0.);\n        B3 = from_plane(vec3(-s2/2., -s2/2., 0), s2/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(1, 0, -t1.x), vec3(1./s2, 1./s2, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(1, 0, -t0.x), vec3(1./s2, 1./s2, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(0, s2/2., 0);\n    }\n\n    // the 333 case\n    else {\n        A = vec2(-1, 0), B = vec2(0, s3), C = vec2(1, 0);\n        B2 = from_plane(vec3(s3/2., -.5, 0), s3/2.);\n        B3 = from_plane(vec3(-s3/2., -.5, 0), s3/2.);\n        B4 = from_plane(vec3(0, 1, 0), 0.);\n        M1 = mat3(vec3(-s3/2., 0.5, t1.x), vec3(s3/2., .5, t1.y), vec3(0, 1, -t1.z));\n        M0 = mat3(vec3(-s3/2., 0.5, t0.x), vec3(s3/2., .5, t0.y), vec3(0, 1, -t0.z));\n        b = vec3(s3, s3, 0)/2.;\n    }\n\n    // now we solve the virtual ball B1, this can't be a plane\n    B1 = solveBall(M1, b);\n    invertBall(B1);\n\n    // now we solve the virtual ball B0, this can be either a plane or a sphere\n    // this depends on if all entries in dihedralAngles0 are all 2\n    if (dot(dihedralAngles0_234, vec3(1)) == 6.) {\n        B0 = from_plane(vec3(0, 0, -1), B1.r*t01);\n    }\n    else {\n        B0 = solveBall(M0, b);\n        float r1 = B1.r, r0 = B0.r;\n        B0.n.z = sqrt(r0*r0 + r1*r1 + 2.*r0*r1*t01 - L2(B1.n.xy - B0.n.xy));\n        invertBall(B0);\n    }\n    coclusters = Ball[5] (B0, B1, B2, B3, B4);\n\n    //now we process the real balls\n    for (int k = 0; k < 5; k++) {\n        clusters[k] = defaultBall();\n    }\n\n    clusters[1] = from_plane(vec3(0, 0, -1.), B0.n.z);\n    clusters[1].isRealBall = isRealBall.x == 1.;\n\n    clusters[2] = solveBall(C, B0, B1);\n    clusters[2].isRealBall = isRealBall.y == 1.;\n\n    clusters[3] = solveBall(A, B0, B1);\n    clusters[3].isRealBall = isRealBall.z == 1.;\n\n    clusters[4] = solveBall(B, B0, B1);\n    clusters[4].isRealBall = isRealBall.w == 1.;\n}\n\n#if 1\n// In this version, invisible (non active) real balls are used to reduce oerstepping.\n// One may notice that when activating other balls the ovestepping is educed a lot.\n// Not very good but better than nothing. :)\nfloat dist2balls(vec3 p, float scale) {\n    float d = abs(p.z); //Ball 0\n    for (int j = 1; j < 5; j++) {\n        float s = clusters[j].isRealBall ? 0. : DEcor*scale;\n        d = min( s + abs( sdistanceToBall( p, clusters[j] ) ) , d );\n    }\n    return d/scale;\n}\n#else\n// Normal version\nfloat dist2balls( vec3 p, float scale) {\n    float d = abs(p.z); //Ball 0\n    for (int j = 1; j < 5; j++)\n        if (clusters[j].isRealBall)\n            d = min(abs(sdistanceToBall(p, clusters[j])), d);\n    return d/scale;\n}\n#endif\n\nvoid EuclideanFold(inout vec3 p) {\n    if( euclideanTriangleType == 0)\n        fold236(p.xy);\n    else if ( euclideanTriangleType == 1)\n        fold244(p.xy);\n    else\n        fold333(p.xy);\n}\n\nfloat map(inout vec3 p, inout float scale, inout vec4 orb) {\n    float d = dist2balls(p, scale);\n    // bool cond = true;\n    // K: Very strange behaviour : doing cond && tru_reflect() cuts things out.\n    // Remove all those tests and just see if the orbit stops. Now DE is \"much\" better.\n    for (int i = 0; i < Iterations ; i++) {\n        vec3 ap = p;\n        EuclideanFold(p);\n        for (int k = 0; k < 2; k++)\n            try_reflect(p, coclusters[k], scale, orb);\n        if (all(not(bvec3(p-ap))))\n            break;\n        d = min( d, dist2balls(p, scale));\n    }\n#if 0\n    // Slow version. DEs to balls are each iterations\n    return d;\n#else\n    // Fast version. distance to balls is done only once.\n    return dist2balls(p, scale);\n#endif\n}\n\nfloat DE(vec3 p) {\n    float DEfactor=1.;\n    //orbiTrap is not initialized by default. That's what was producing the strange haze and colors.\n    orbitTrap = vec4(1);\n    float d = map(p, DEfactor, orbitTrap);\n\n    //Call basic shape and scale its DE\n    return 0.3 * d ;// Fudging here because fudge factor desn't seem to affect shadows :-/\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"ctVGRR","date":"1683457379","viewed":2887,"name":"Reflective Wythoff polyhedra","description":"Another reflective polyhedra shader","likes":46,"published":"Public API","usePreview":0,"tags":["3d","mirror","reflect","polyhedra","wythoff"]},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nWythoff reflective polyhedra, code adapted from\n\nhttps://www.shadertoy.com/view/tlX3WH\n\nI basically rewrote the polyhera construction and raytracing part there,\nand kept the rendering part untouched.\n\nThe code should look simpler now?\n\nTo play with:\n\n1. Change pqr and truncation_type to see other polyhedron.\n2. use 'INSIDE_VIEW' to view from the inside.\n3. use 'DUAL' to view the dual polyhera.\npqr=(2, 3, 4) and truncation_type=(0, 0, 1) will give the\nrhombic dodecahedron that tiles the whole inner space.\n*/\n#define PI 3.141592654\n#define L2(x) dot(x, x)\n#define EDGE_THICKNESS 0.05\n#define MAX_TRACE_STEPS 128\n#define MAX_RAY_BOUNCES 12\n#define EPSILON 1e-4\n#define FAR 20.\n#define min3(x, y, z) (min(x, min(y, z)))\n#define max3(x, y, z) (max(x, max(y, z)))\n\n//#define INSIDE_VIEW\n\n//#define DUAL\n\nconst vec3 pqr = vec3(2, 3, 5); // (2, 3, 3), (2, 3, 4)\nconst vec3 truncation_type = vec3(1, 1, 1);\n\nconst float size = 1.35; // polyhera size\n\nmat3 M;  // normals of reflection mirrors\nmat3 T;  // three vertices of the fundamental triangle\nvec3 v0; // initial vertex\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(1, 0, 0), vec3(0, c, -s), vec3(0, s, c));\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(c, 0, s), vec3(0, 1, 0), vec3(-s, 0, c));\n}\n\nvoid init() {\n    vec3 c = cos(PI / pqr);\n    float sp = sin(PI / pqr.x);\n    vec3 m1 = vec3(1, 0, 0);\n    vec3 m2 = vec3(-c.x, sp, 0);\n    float x3 = -c.z;\n    float y3 = -(c.y + c.x * c.z) / sp;\n    float z3 = sqrt(1.0 - x3 * x3 - y3 * y3);\n    vec3 m3 = vec3(x3, y3, z3);\n    M = mat3(m1, m2, m3);\n    T[0] = normalize(cross(m2, m3));\n    T[1] = normalize(cross(m3, m1));\n    T[2] = normalize(cross(m1, m2));\n    v0 = normalize(truncation_type * inverse(M)) * size;\n#ifdef DUAL\n#define proj(p, n) (length(p - dot(p, n) * n))\n    float scale = min3(proj(v0, m1), proj(v0, m2), proj(v0, m3));\n    v0 /= scale;\n#endif\n}\n\nvec3 fold(vec3 p) {\n    for (int i = 0; i < 5; i++)\n        for (int j = 0; j < 3; j++) {\n            p -= 2. * min(dot(p, M[j]), 0.) * M[j];\n        }\n    return p;\n}\n\nfloat dSegment(vec3 p, vec3 a, vec3 b) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float d = length(pa - ba * h);\n    return d;\n}\n\nvec3 distEdges(vec3 p) {\n    p = fold(p);\n#ifdef DUAL\n    vec3 ed = vec3(1e5);\n    vec3 a = T[0] / dot(T[0], v0) * size;\n    vec3 b = T[1] / dot(T[1], v0) * size;\n    vec3 c = T[2] / dot(T[2], v0) * size;\n    if (bool(truncation_type.x))\n        ed.x = dSegment(p, b, c);\n    if (bool(truncation_type.y))\n        ed.y = dSegment(p, c, a);\n    if (bool(truncation_type.z))\n        ed.z = dSegment(p, a, b);\n    return ed;\n#else\n    p -= v0;\n    vec3 ed;\n    for (int i = 0; i < 3; i++) {\n        ed[i] = L2(p - min(0., dot(p, M[i])) * M[i]);\n    }\n    return sqrt(ed);\n#endif\n}\n\nfloat map(vec3 p) {\n    p = fold(p);\n#ifdef DUAL\n    return dot(p, v0) - size;\n#else\n    p -= v0;\n    return max(dot(p, T[0]), max(dot(p, T[1]), dot(p, T[2])));\n#endif\n}\n\nfloat trace(vec3 pos, vec3 rd, bool outside) {\n    float t = 0.0;\n    float sgn = outside ? 1.0 : -1.0;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        float d = map(pos + t * rd);\n        if (abs(d) < EPSILON)\n            return t;\n        if (t > FAR)\n            break;\n        t += sgn * d * 0.9;\n    }\n    return FAR;\n}\n\nvec4 wallColor(vec3 dir, vec3 nor, vec3 eds) {\n    float d = min3(eds.x, eds.y, eds.z);\n\n    // Texturing of walls\n    vec3 albedo = texture(iChannel1, vec2(eds.xy * 2.0)).rgb;\n    albedo = pow(albedo, vec3(2.2)) * 0.5;\n\n    // Simple diffuse lighting\n    float lighting = 0.2 + max(dot(nor, vec3(0.8, 0.5, 0.0)), 0.0);\n\n    if (dot(dir, nor) < 0.0) {\n        // Outer walls, just add a black line to hide seams\n        float f = clamp(d * 1000.0 - 3.0, 0.0, 1.0);\n        albedo = mix(vec3(0.01), albedo, f);\n        return vec4(albedo * lighting, f);\n    } else {\n        // Inner walls, add fancy lights\n        float m = max3(eds.x, eds.y, eds.z);\n        vec2 a = fract(vec2(d, m) * 40.6) - 0.5;\n        float b = 1.0 - sqrt(dot(a, a));\n        b = 0.2 / (dot(a, a) + 0.2);\n\n        float lightShape = 1.0 - clamp(d * 100.0 - 2.0, 0.0, 1.0);\n        lightShape *= b;\n\n        vec3 emissive = vec3(3.5, 1.8, 1.0);\n        return vec4(mix(albedo * lighting, emissive, lightShape), 0.0);\n    }\n    return vec4(1.0);\n}\n\nmat3 camera_matrix(vec3 eye, vec3 lookat, vec3 up) {\n    vec3 forward = normalize(lookat - eye);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    return mat3(right, up, -forward);\n}\n\nvec3 get_normal(in vec3 pos) {\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(map(pos + eps.xyy) - map(pos - eps.xyy),\n                          map(pos + eps.yxy) - map(pos - eps.yxy),\n                          map(pos + eps.yyx) - map(pos - eps.yyx)));\n}\n\nvec3 background(vec3 dir) {\n    vec3 col = texture(iChannel0, dir).rgb;\n    col = pow(col, vec3(2.2));\n    float origLuma = dot(col, vec3(0.2126, 0.7152, 0.0722)) * 0.7;\n    return 2.5 * col / (1.0 - origLuma);\n}\n\nvec3 drawRay(vec3 pos, vec3 rd) {\n    vec3 color = vec3(0.0);\n#ifndef INSIDE_VIEW\n    float t = trace(pos, rd, true);\n    if (t == FAR) {\n        return background(rd);\n    }\n    pos = pos + t * rd;\n    vec3 nor = get_normal(pos);\n    vec3 reflDir = reflect(rd, nor);\n    vec3 bgColor = pow(background(reflDir), vec3(1.0));\n    float fresnel = 0.04 + 0.96 * pow(1.0 - max(dot(rd, -nor), 0.0), 5.0);\n    color += bgColor * fresnel;\n    vec3 eds = distEdges(pos);\n    float d = min3(eds.x, eds.y, eds.z);\n    if (d < EDGE_THICKNESS) {\n        vec4 wc = wallColor(rd, nor, eds);\n        return color * wc.a + wc.rgb;\n    }\n#endif\n    vec3 transmittance = vec3(1.0);\n    for (int i = 0; i < MAX_RAY_BOUNCES; i++) {\n        float t = trace(pos, rd, false);\n        pos = pos + t * rd;\n        vec3 eds = distEdges(pos);\n        vec3 nor = get_normal(pos);\n        float d = min3(eds.x, eds.y, eds.z);\n        if (d < EDGE_THICKNESS) {\n            return color + transmittance * wallColor(rd, nor, eds).rgb;\n        }\n        rd = reflect(rd, nor);\n        pos += rd * 0.005;\n        transmittance *= vec3(0.4, 0.7, 0.7);\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    init();\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec2 move = vec2(iTime * 0.2, sin(iTime * 0.2) * 0.5);\n\n#ifdef INSIDE_VIEW\n    float radius = 0.1;\n#else\n    float radius = 2.0;\n#endif\n    vec3 eye = radius * vec3(cos(move.x) * cos(move.y), sin(move.y),\n                             sin(move.x) * cos(move.y));\n\n    vec2 mouse = vec2(0);\n    if (iMouse.x > 0.)\n        mouse = 2. * iMouse.xy / iResolution.y - 1.;\n    eye = rotateY(mouse.x) * rotateX(-mouse.y) * eye;\n\n    vec3 lookat = vec3(0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 forward = normalize(lookat - eye);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n    vec3 ray = normalize(uv.x * right + uv.y * up + forward * 1.0);\n    vec3 color = drawRay(eye, ray);\n    color = color / (color * 0.5 + 0.5);\n    color = pow(color, vec3(1.0 / 2.2));\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"DtKcRh","date":"0","viewed":0,"name":"Fork Hyperbolic neozhaolia 147","description":"This is similar to Shane's work https://www.shadertoy.com/view/WlBczG but uses a different approach.","likes":0,"published":"Private","usePreview":0,"tags":["2d","tiling","hyperbolic","poincare"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    A mimic of shane's work at https://www.shadertoy.com/view/WlBczG.\n    \n    Show the basic procedure to draw a 2d hyperbolic Poincare tiling.\n    \n    Also can draw paracompact and noncompact tilings (with ideal and hyperideal vertices)\n\n*/\n// show the three reflection mirrors\n//#define debug_mirrors\n\n// comment out this to see the initial pattern\n//#define enableMouseInversion\n\n// change to Klein model\n//#define KleinModel\n\n// set inf = 1.0 for paracompact tiling\n// set inf > 1.0 for noncompact tiling\n#define inf       1.15\n\n#define PI\t\t  3.14159265\n#define TAU\t      6.28318531\n#define MAX_ITER  30\n\n\n// the smaller this value, the larger the black area\n#define BlackRegionSize   0.065\n\n// the first entry in PQR must be finite, other two entries can be either finite or infinite\n// for example (3, inf 4), (3, 4, inf), etc\nconst vec3 PQR = vec3(3, inf, 2);\n\n\n// reflection mirrors\nvec2 A, B;\nvec3 C;\n\n// two vertices of the fundamental triangle, the 3rd one is the origin\nvec2 v0, m0;\n\n// count the number of reflections across each mirror\nfloat count;\n\n// compute cos(PI / x), for x = infiniy this is inf using Vinberg's convention.\nfloat dihedral(float x) { return x == inf ? inf : cos(PI / x); }\n\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\nvoid init() {\n\n    float cAB = dihedral(PQR.x);\n    float sAB = sqrt(1. - cAB*cAB);\n    \n\tA = vec2(1, 0);\n    B = vec2(-cAB, sAB);\n    \n    float cAC = dihedral(PQR.y);\n    float cBC = dihedral(PQR.z);\n    \n    float k1 = cAC;\n    float k2 = (cBC + cAB*cAC) / sAB;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    C = vec3(k1, k2, 1.)*r;\n    \n    if (r*r >= C.x*C.x)\n        v0 = vec2(0., C.y - sqrt(r*r - C.x*C.x));\n    else\n        v0 = vec2(0, 1);\n        \n    vec2 n = vec2(-B.y, B.x);\n    float b = dot(C.xy, n);\n    float c = dot(C.xy, C.xy) - r*r;\n    float k = -1.0;\n    \n    if (b*b >= c)\n        k = b + sqrt(b*b-c);\n    \n    m0 = k*n;\n}\n\n\nbool try_reflect(inout vec2 p, vec2 mirror, inout float count) {\n    float k = dot(p, mirror);\n    if (k >= 0.)\n        return true;\n    p -= 2. * k  * mirror;\n    count += 1.;\n    return false;\n}\n\n\nbool try_reflect(inout vec2 p, vec3 sphere, inout float count) {\n    vec2 cen = sphere.xy;\n    float r = sphere.z;\n    float d = length(p - cen) - r;\n    if (d >= 0.)\n        return true;\n    p -= cen;\n    p *= r * r/ dot(p, p);\n    p += cen;\n    count += 1.;\n    return false;\n}\n\n\nvoid fold(inout vec2 p, inout float count) {\n    count = 0.;\n    for (int k = 0; k < MAX_ITER; k++) {\n        try_reflect(p, A, count);\n        //try_reflect(p, B, count);\n        try_reflect(p, C, count);\n    }\n}\n\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n\nvec2 mouseInversion(vec2 p) {\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    if(length(m) < 1e-3) m += 1e-3; \n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m;\n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x;\n    return p;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 1.05;\n    vec2 p = uv;\n    \n#ifdef enableMouseInversion\n    p = mouseInversion(p);\n    p = rot2(iTime/16.)*p;\n#endif\n\n    init();   \n    \n    if(length(p)> 1.)\n        p /= dot(p, p);\n        \n#ifdef KleinModel\n    p = p / (1. + sqrt(1. - dot(p, p)));\n#endif\n  \n    fold(p, count);\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, -v0, v0, .007));    \n    //ln = min(ln, lBox(p, vec2(0), m0, .007));\n    ln = min(ln, length(p-C.xy) - C.z - 0.007);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    //pnt = min(pnt, length(p - v0)); \n    //pnt = min(pnt, length(p - m0)); \n    \n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf;\n        \n    vec3 oCol = .55 + .45*cos(count*TAU / 8. + vec3(0, 1, 2));\n    //float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    \n    vec3 col = min(oCol*(0.*.2 + .9)*sh, 1.);\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n    vec3 bg = vec3(1, .2, .4);\n    bg *= .7*(mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5)*.5 + .5);\n    //pat = smoothstep(0., .25, abs(fract((uv.x - uv.y)*43. - .25) - .5)*2. -.5);\n    bg *= max(1. - length(uv)*.5, 0.)*(0. + .9);\n    \n    float cir = length(uv);\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., abs(cir - 1.) - .05))*.7);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(cir - 1.) - .01)));\n    //col = mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col*max(1. - length(uv)*.5, 0.), (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.01)));\n    \n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cir - 1.035) - .03))*.8);\n    col = mix(col, 1. - exp(-col), .35);\n\n#ifdef debug_mirrors\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, A)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, B)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.02, abs(length(uv-C.xy) - C.z))-0.01);\n#endif\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"ctVyWD","date":"0","viewed":0,"name":"forkforHyperbolic tilings: intro","description":"This is similar to Shane's work https://www.shadertoy.com/view/WlBczG but uses a different approach.","likes":0,"published":"Private","usePreview":0,"tags":["2d","tiling","hyperbolic","poincare"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Hyperbolic tilings: intro\" by None. https://shadertoy.com/view/-1\n// 2023-11-17 15:16:59\n\n/*\n    A mimic of shane's work at https://www.shadertoy.com/view/WlBczG.\n    \n    Show the basic procedure to draw a 2d hyperbolic Poincare tiling.\n    \n    Also can draw paracompact and noncompact tilings (with ideal and hyperideal vertices)\n\n*/\n// show the three reflection mirrors\n//#define debug_mirrors\n\n// comment out this to see the initial pattern\n//#define enableMouseInversion\n\n// change to Klein model\n//#define KleinModel\n\n// set inf = 1.0 for paracompact tiling\n// set inf > 1.0 for noncompact tiling\n#define inf       1.0\n\n#define PI\t\t  3.14159265\n#define TAU\t      6.28318531\n#define MAX_ITER  30\n\n\n// the smaller this value, the larger the black area\n#define BlackRegionSize   0.065\n\n// the first entry in PQR must be finite, other two entries can be either finite or infinite\n// for example (3, inf 4), (3, 4, inf), etc\nconst vec3 PQR = vec3(3, inf, 3);\n\n\n// reflection mirrors\nvec2 A, B;\nvec3 C;\n\n// two vertices of the fundamental triangle, the 3rd one is the origin\nvec2 v0, m0;\n\n// count the number of reflections across each mirror\nfloat count;\n\n// compute cos(PI / x), for x = infiniy this is inf using Vinberg's convention.\nfloat dihedral(float x) { return x == inf ? inf : cos(PI / x); }\n\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\nvoid init() {\n\n    float cAB = dihedral(PQR.x);\n    float sAB = sqrt(1. - cAB*cAB);\n    \n\tA = vec2(1, 0);\n    B = vec2(-cAB, sAB);\n    \n    float cAC = dihedral(PQR.y);\n    float cBC = dihedral(PQR.z);\n    \n    float k1 = cAC;\n    float k2 = (cBC + cAB*cAC) / sAB;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    C = vec3(k1, k2, 1.)*r;\n    \n    if (r*r >= C.x*C.x)\n        v0 = vec2(0., C.y - sqrt(r*r - C.x*C.x));\n    else\n        v0 = vec2(0, 1);\n        \n    vec2 n = vec2(-B.y, B.x);\n    float b = dot(C.xy, n);\n    float c = dot(C.xy, C.xy) - r*r;\n    float k = -1.0;\n    \n    if (b*b >= c)\n        k = b + sqrt(b*b-c);\n    \n    m0 = k*n;\n}\n\n\nbool try_reflect(inout vec2 p, vec2 mirror, inout float count) {\n    float k = dot(p, mirror);\n    if (k >= 0.)\n        return true;\n    p -= 2. * k  * mirror;\n    count += 1.;\n    return false;\n}\n\n\nbool try_reflect(inout vec2 p, vec3 sphere, inout float count) {\n    vec2 cen = sphere.xy;\n    float r = sphere.z;\n    float d = length(p - cen) - r;\n    if (d >= 0.)\n        return true;\n    p -= cen;\n    p *= r * r/ dot(p, p);\n    p += cen;\n    count += 1.;\n    return false;\n}\n\n\nvoid fold(inout vec2 p, inout float count) {\n    count = 0.;\n    for (int k = 0; k < MAX_ITER; k++) {\n        try_reflect(p, A, count);\n        try_reflect(p, B, count);\n        try_reflect(p, C, count);\n    }\n}\n\nvoid fold2(inout vec2 p, inout float count) {\n    count = 0.;\n    for (int k = 0; k < MAX_ITER; k++) {\n        try_reflect(p, A, count);\n        //try_reflect(p, B, count);\n        try_reflect(p, C, count);\n    }\n}\n\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n\nvec2 mouseInversion(vec2 p) {\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    if(length(m) < 1e-3) m += 1e-3; \n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m;\n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x;\n    return p;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 1.05;\n    vec2 p = uv;\n    \n#ifdef enableMouseInversion\n    p = mouseInversion(p);\n    p = rot2(iTime/16.)*p;\n#endif\n\n    init();   \n    \n    if(length(p)> 1.)\n        p /= dot(p, p);\n        \n#ifdef KleinModel\n    p = p / (1. + sqrt(1. - dot(p, p)));\n#endif\n    vec2 q = p;\n    float count2= count;\n    fold(p, count);\n    fold2(q, count2);\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, vec2(0), v0, .007));    \n    ln = min(ln, lBox(p, vec2(0), m0, .007));\n    ln = min(ln, length(p-C.xy) - C.z - 0.007);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0));\n   \n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf;\n        \n    vec3 oCol = .55 + .45*cos(count*TAU / 8. + vec3(0, 1, 2));\n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n   \n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    \n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt = min(pnt, length(p));\n    float ddd = length(q - vec2(0.15, 0.3));\n    int id = (pnt < ddd) ? 0 : 1;\n    pnt = min(pnt, ddd) - 0.032;\n   \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    \n    if (id == 0)\n        col = mix(col, vec3(1, .8, .3), 1. - smoothstep(0., sf, pnt + .02));\n    else\n        col = mix(col, vec3(3., .2, .8), 1. - smoothstep(0., sf, pnt));\n    \n    vec3 bg = vec3(1, .2, .4);\n    bg *= .7*(mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5)*.5 + .5);\n    pat = smoothstep(0., .25, abs(fract((uv.x - uv.y)*43. - .25) - .5)*2. -.5);\n    bg *= max(1. - length(uv)*.5, 0.)*(pat*.2 + .9);\n    \n    float cir = length(uv);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., abs(cir - 1.) - .05))*.7);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(cir - 1.) - .05)));\n    col = mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col*max(1. - length(uv)*.5, 0.), (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.05)));\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cir - 1.035) - .03))*.8);\n    col = mix(col, 1. - exp(-col), .35);\n\n#ifdef debug_mirrors\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, A)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, B)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.02, abs(length(uv-C.xy) - C.z))-0.01);\n#endif\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"X3fGzf","date":"1735635948","viewed":39,"name":"Icosahedral Quasicrystal ","description":"Icosahedral Quasicrystal using de Bruijn's multigrid method","likes":0,"published":"Unlisted","usePreview":1,"tags":["3d","geometry","honeycomb","coxeter","group","tiling","euclidean","symmetry","lattice"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR     20.\n#define PI      3.141592654\n\n\nfloat project_point_grid(vec3 p, int k)\n{\n    return dot(p, icosa[k]) + offsets[k];\n}\n\nvec3 debruijn_transform(vec3 p)\n{\n    vec3 sum = vec3(0);\n    for(int k = 0; k < 6; k++)\n    {\n        sum += icosa[k] * project_point_grid(p, k);\n    }\n    return sum;\n}\n\nfloat IF;\nstruct Cell {\n    ivec3 rst;\n    vec3 vertices[8];\n};\n\n\nbool isInCell(vec3 p, Cell cell) {\n    bool cond = true;\n    for (int m=min(0,iFrame); m<6; m++) {\n        ivec3 ijk = face_indices[m].xyz;\n        vec3 vi = cell.vertices[ijk.x];\n        vec3 vj = cell.vertices[ijk.y];\n        vec3 vk = cell.vertices[ijk.z];\n        vec3 normal = cross(vj - vi, vk - vi);\n        cond = cond && dot(p - vi, normal) <= 0.0;\n    }\n    return cond;\n}\n\nvoid solveVertices(int r, int s, int t, float kr, float ks, float kt, inout Cell cell) {\n    mat3 M = mat3(\n        icosa[r], icosa[s], icosa[t]\n    );\n    vec3 b = vec3(kr - offsets[r], ks - offsets[s], kt - offsets[t]);\n    vec3 p = inverse(M) * b;\n    vec3 sum = kr * icosa[r] + ks * icosa[s] + kt * icosa[t];\n    for(int k = 0; k < 6; k++)\n    {\n        if ((k != r) && (k != s) && (k != t))\n            sum +=  icosa[k] * ceil(project_point_grid(p, k));\n    }\n    \n    int count = 0;\n    for(float dr=min(0., IF); dr<2.; dr+=1.) {\n    for(float ds=min(0., IF); ds<2.; ds+=1.) {\n    for(float dt=min(0., IF); dt<2.; dt+=1.) {\n        cell.vertices[count++] = \n            sum + dr * icosa[r]\n                + ds * icosa[s]\n                + dt * icosa[t];\n            }\n        }\n    }\n}\n\nCell getMappedCell(in vec3 p, out vec3 q) {\n     q = debruijn_transform(p);\n     Cell cell;\n     float kr, ks, kt;\n     float[6] pindex;\n     for (int i = 0; i < 6; i++) {\n        pindex[i] = floor(project_point_grid(p, i));\n     }\n     for(int r = min(0, iFrame); r < min(4, iFrame+4); r++) {\n     for(int s = r+1;            s < min(5, iFrame+5); s++) {\n     for(int t = s+1;            t < min(6, iFrame+6); t++) {\n     for(float dr = -1.; dr < 2.; dr += 1.0) {\n     for(float ds = -1.; ds < 2.; ds += 1.0) {\n     for(float dt = -1.; dt < 2.; dt += 1.0) {\n         kr = pindex[r] + dr;\n         ks = pindex[s] + ds;\n         kt = pindex[t] + dt;\n         solveVertices(r, s, t, kr, ks, kt, cell);\n         if (isInCell(q, cell)) {\n             cell.rst = ivec3(r,s,t);\n             return cell;\n         }\n     }\n     }\n     }\n     }\n     }\n     }\n}\n\n\n\nfloat map(vec3 p) {\n    float d = 1e5;\n    vec3 q;\n    Cell cell = getMappedCell(p, q);\n    for (int m=min(iFrame, 0); m<8; m++) {\n        d = min(d, length(q - cell.vertices[m]) - 0.5);\n    }\n    return d;\n}\n\n\n// This reduces the compiling time to about 7x times faster\nvec3 calcNormal(vec3 p, float t) {\n    float eps = 1./mix(400., iResolution.y, .5)*(1. + t*.5);\n    float d = map(p);\n    vec3 e = vec3(eps, 0, 0);\n    vec3 da = vec3(-2.*d);\n    for(int i = min(iFrame, 0); i < 3; i++ ) {\n        for(int j = min(iFrame, 0); j < 2; j++)\n            da[i] += map(p + e * float(1 - 2*j));\n        e = e.zxy;\n    }\n    da = abs(da);\n    vec3 n = vec3(0.0);\n    for(int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    return normalize(n);\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float tmin, float tmax, float k) {\n    const int maxShadeIterations = 32;\n    vec3 rd = lp - ro;\n    rd /= max(length(rd), 1e-4);\n    float shade = 1.0;\n    float t = tmin;\n    for (int i = min(0,iFrame); i < maxShadeIterations; i++) {\n        float h = map(ro + rd * t);\n        t += clamp(h, 0.01, 0.2);\n        shade = min(shade, smoothstep(0., 1., k * h / t));\n        if (abs(h) < 1e-4 || t > tmax)\n            break;\n    }\n    return min(max(shade, 0.) + .1, 1.);\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = map(p + h * n);\n        occ += (h - d) * sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\n\nfloat trace(in vec3 ro, in vec3 rd) {\n    float ah;\n    const float precis = 1e-3;\n    float t = 0.0;\n    for (int i = 0; i < 128; i++) {\n        float h = map(ro + rd * t);\n        ah = abs(h);\n        if (ah < (t * 0.125 + 1.) * precis || t > FAR)\n            break;\n        t += h;\n    }\n    return min(t, FAR);\n}\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    IF = float(iFrame);\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 up = vec3(0, 1, 0);\n    vec3 ro = vec3(5, 5, 0);\n    vec3 lookat = vec3(0);\n    \n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, up));\n    up = cross(right, forward);\n    vec3 rd = normalize(uv.x * right + uv.y * up + forward * 2.);\n   \n    vec3 lp = ro + vec3(-1, 2, -1);\n    vec3 col = vec3(0);\n    \n    float t = trace(ro, rd);\n    \n    if (t < FAR) {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos, t);       \n        vec3 bCol = mix(vec3(1, .1, .5).zyx,\n                        vec3(1, .3, .1).zyx,\n                        dot(sin(pos*8. - cos(pos.yzx*4. + iTime*4.)), vec3(.166)) + .5);\n      \n        vec3 oCol = mix(bCol, vec3(1.35), .97)*vec3(1.1, 1, .9);\n\n        float ao = calcAO(pos, nor);\n        float sh = softShadow(pos + nor*.002, lp, 0.001, 16., t);\n\n        vec3 ld = lp - pos;\n        float dist = max(length(ld), 0.001);\n        ld /= dist;\n\n        float atten = 3./(1. + dist*0.05 + dist*dist*0.025);\n\n        float diff = max(dot(ld, nor), 0.);\n        float spec = pow(max(dot( reflect(ld, nor), rd), 0.0 ), 32.0);\n\n        col = oCol*(diff + .25) + mix(bCol.zyx, vec3(1, .7, .3), .5)*spec*4.;\n        col += .015/max(abs(.05 - map(pos*1.5 + sin(iTime/6.))), .01)*oCol*mix(bCol, vec3(1, .8, .5), .35);\n        col *= atten*(sh + ao*.25)*ao;\n\n    }\n\n    float fog = 1./(1. + t*.125 + t*t*.01);\n    col = mix(vec3(0), col, fog);//\n\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125);\n    //col = vec3(0.5);\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float sq5 = sqrt(5.0);\nconst float pi = 3.141592654;\nconst float sq52 = 2.0 / sq5;\n\nconst vec3 icosa[6] = vec3[6] (\n vec3(0.85065081,  0.52573111,  0.),\n vec3(0.85065081, -0.52573111,  0.),\n vec3(0.        ,  0.85065081,  0.52573111),\n vec3(0.        ,  0.85065081, -0.52573111),\n vec3(0.52573111,  0.        ,  0.85065081),\n vec3(-0.52573111, 0.        ,  0.85065081)\n);\n\nconst float offsets[6] = float[6] (1./6., 1./6., 1./6., 1./6., 1./6., 1./6.);\n\nconst ivec4 face_indices[6] = ivec4[6] (\n     ivec4(0, 2, 3, 1),\n     ivec4(0, 1, 5, 4),\n     ivec4(5, 7, 6, 4),\n     ivec4(2, 6, 7, 3),\n     ivec4(0, 4, 6, 2),\n     ivec4(3, 7, 5, 1)\n);","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"432GW3","date":"0","viewed":0,"name":"Conway's topograph","description":"This is similar to Shane's work https://www.shadertoy.com/view/WlBczG but uses a different approach.","likes":0,"published":"Private","usePreview":0,"tags":["2d","tiling","hyperbolic","poincare"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nhttps://been-jamming.github.io/topographs/\n*/\n#define debug_mirrors\n\n// comment out this to see the initial pattern\n//#define enableMouseInversion\n\n// change to Klein model\n//#define KleinModel\n\n// set inf = 1.0 for paracompact tiling\n// set inf > 1.0 for noncompact tiling\n#define inf       1.0\n\n#define PI\t\t  3.14159265\n#define TAU\t      6.28318531\n#define MAX_ITER  30\n\n\n// the smaller this value, the larger the black area\n#define BlackRegionSize   0.065\n\n// the first entry in PQR must be finite, other two entries can be either finite or infinite\n// for example (3, inf 4), (3, 4, inf), etc\nconst vec3 PQR = vec3(2, 3, inf);\n\n\n// reflection mirrors\nvec2 A, B;\nvec3 C;\n\n// two vertices of the fundamental triangle, the 3rd one is the origin\nvec2 v0, m0;\n\n// count the total number of reflections\nfloat count;\n\n// compute cos(PI / x) using Vinberg's convention for inf.\nfloat dihedral(float x) { return x == inf ? inf : cos(PI / x); }\n\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\nvoid init() {\n\n    float cAB = dihedral(PQR.x);\n    float sAB = sqrt(1. - cAB*cAB);\n    \n\tA = vec2(1, 0);\n    B = vec2(-cAB, sAB);\n    \n    float cAC = dihedral(PQR.y);\n    float cBC = dihedral(PQR.z);\n    \n    float k1 = cAC;\n    float k2 = (cBC + cAB*cAC) / sAB;\n    float r = 1. / sqrt(k1*k1 + k2*k2 - 1.);\n    \n    C = vec3(k1, k2, 1.)*r;\n    \n    if (r*r >= C.x*C.x)\n        v0 = vec2(0., C.y - sqrt(r*r - C.x*C.x));\n    else\n        v0 = vec2(0, 1);\n        \n    vec2 n = vec2(-B.y, B.x);\n    float b = dot(C.xy, n);\n    float c = dot(C.xy, C.xy) - r*r;\n    float k = -1.0;\n    \n    if (b*b >= c)\n        k = b + sqrt(b*b-c);\n    \n    m0 = k*n;\n}\n\n\nbool try_reflect(inout vec2 p, vec2 mirror, inout float count) {\n    float k = dot(p, mirror);\n    if (k >= 0.)\n        return true;\n    p -= 2. * k  * mirror;\n    count += 1.;\n    return false;\n}\n\n\nbool try_reflect(inout vec2 p, vec3 sphere, inout float count) {\n    vec2 cen = sphere.xy;\n    float r = sphere.z;\n    float d = length(p - cen) - r;\n    if (d >= 0.)\n        return true;\n    p -= cen;\n    p *= r * r/ dot(p, p);\n    p += cen;\n    count += 1.;\n    return false;\n}\n\n\nvoid fold(inout vec2 p, inout float count) {\n    count = 0.;\n    for (int k = 0; k < MAX_ITER; k++) {\n        try_reflect(p, A, count);\n        try_reflect(p, B, count);\n        try_reflect(p, C, count);\n    }\n}\n\n\nfloat sBox(in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew) {\n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n\nvec2 mouseInversion(vec2 p) {\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    if(length(m) < 1e-3) m += 1e-3; \n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m;\n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x;\n    return p;    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    uv *= 1.05;\n    vec2 p = uv;\n    \n#ifdef enableMouseInversion\n    p = mouseInversion(p);\n    p = rot2(iTime/16.)*p;\n#endif\n\n    init();   \n    \n    if(length(p)> 1.)\n        p /= dot(p, p);\n        \n#ifdef KleinModel\n    p = p / (1. + sqrt(1. - dot(p, p)));\n#endif\n  \n    fold(p, count);\n    \n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    ln = min(ln, lBox(p, vec2(0), v0, .007));    \n    //ln = min(ln, lBox(p, vec2(0), m0, .007));\n    //ln = min(ln, length(p-C.xy) - C.z - 0.007);\n\n    ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n    pnt = min(pnt, length(p - v0)); \n    pnt = min(pnt, length(p - m0)); \n    \n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf;\n        \n    vec3 oCol = .55 + .45*cos(count*TAU / 8. + vec3(0, 1, 2));\n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n    float sh = clamp(.65 + ln/v0.y*4., 0., 1.);\n    \n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - BlackRegionSize)));\n\n    pnt -= .032;\n    //pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    col = mix(col, vec3(1, .8, .3), 1. - smoothstep(0., sf, pnt + .02));\n    \n    vec3 bg = vec3(1, .2, .4);\n    bg *= .7*(mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5)*.5 + .5);\n    pat = smoothstep(0., .25, abs(fract((uv.x - uv.y)*43. - .25) - .5)*2. -.5);\n    bg *= max(1. - length(uv)*.5, 0.)*(pat*.2 + .9);\n    \n    float cir = length(uv);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., abs(cir - 1.) - .05))*.7);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(cir - 1.) - .05)));\n    col = mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col*max(1. - length(uv)*.5, 0.), (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.05)));\n    \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cir - 1.035) - .03))*.8);\n    col = mix(col, 1. - exp(-col), .35);\n\n#ifdef debug_mirrors\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, A)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.01, abs(dot(uv, B)) - 0.01));\n    col = mix(col, vec3(1, 0, 0), 1. - smoothstep(0., 0.02, abs(length(uv-C.xy) - C.z))-0.01);\n#endif\n\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"l3cXR7","date":"1718788185","viewed":816,"name":"IFS demystified","description":"The original work is by gaz, and I have deobfuscated it. This is for a blog post introducing IFS fractals.","likes":9,"published":"Public API","usePreview":0,"tags":["fractal"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#if 0\n// original obfuscated code by gaz\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O-=O;\n    for(float g,e,i=0.;++i<80.;e<1e-4?O+=.9/i:O)\n    {\n        vec3 r=iResolution,\n        p=g*vec3((C-.5*r.xy)/r.y,1);\n        p.y+=3.;\n        p.xz*=R(iTime*.2);\n        for(int j=0;++j<8;)\n            p.z-=.3,\n            p.xz=abs(p.xz),\n            p.xz=(p.z>p.x)?p.zx:p.xz,\n            p.xy=(p.y>p.x)?p.yx:p.xy,\n            p.z=1.-abs(p.z-1.),\n            p=p*3.-vec3(10,4,2);\n        g+=e=length(p)/6561.0-.001;\n    }\n}\n\n#else\n// deobfuscated code with explanations\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // clear the screen\n    fragColor = vec4(0.0);\n    \n    // d is the distance to the compact set A\n    float d, total = 0.0;\n\n    // Each iteration draws part of the final fractal\n    for(float i = 1.0; i < 80.0; i++)\n    {\n        // screen to world\n        vec3 p = total * vec3((fragCoord - 0.5 * iResolution.xy) / iResolution.y, 1);\n        p.y += 3.0;\n        p.xz *= R(iTime * 0.2);\n\n        // fold p back\n        // the total scaling factor is 3^7\n        for(int j = 1; j < 8; j++)\n        {\n            // the lines below defines the invere of\n            // the contraction mapping F^{-1}\n            // here `abs` and conditional statements creates many copies\n            // of the initial compact set A\n            p.z -= 0.3;\n            p.xz = abs(p.xz);\n            p.xz = (p.z > p.x) ? p.zx : p.xz;\n            p.xy = (p.y > p.x) ? p.yx : p.xy;\n            p.z = 1.0 - abs(p.z - 1.0);\n            p = p * 3.0 - vec3(10, 4, 2);\n        }\n\n        // distance to the compact set A\n        // which is a sphere of radius 6.0 at the origin\n        // note we divided 3^8 instead of 3^7 to get a better distance\n        d = (length(p) - 6.) / pow(3.0, 8.0);\n        total += d;\n\n        // if d is small enough, we are in the compact set\n        // add a little color to the pixel, decreased in i\n        if(d < 0.0001)\n        {\n            fragColor += vec4(0.9) / i;\n        }\n    }\n}\n\n#endif","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\nQ: How are those cool fractal scenes on Shadertoy created?\n\nA: Most of them are IFS fractals and can be created using the\nso called 'space folding' trick.\n\n--------------------------------\n  1. Contraction Mapping and IFS\n--------------------------------\n\nSuppose f: Rn --> Rn is a mapping. If there exists 0<r<1 such that for\nany x,y∈Rn, we have\n\n    d(f(x),f(y)) ≤ r ⋅ d(x,y)\n\nthen f is called a contraction mapping. Here d is the usual Euclidean distance.\n\nLet K(Rn) denote the set of all compact sets in Rn. It can be proven that\nK(Rn) is a complete metric space under the Hausdorff metric. \n\nSuppose f1, …, fN are contraction mappings, where the contraction ratio\nof fi is ri. Define the mapping\n\n    F: K(RN) -> K(RN)\n    \nas follows:\n    \n    F(X) = f1(X)∪f2(X)∪⋯∪fN(X), X∈K(RN).\n\nIt can be proven that F is a contraction mapping on the space K(RN)\nwith a contraction ratio r=max⁡{r1,…,rN}. According to the Banach fixed-point\ntheorem, there exists a unique compact set A⊂RN such that A is a fixed\npoint of F: F(A)=A\n\nMoreover, for any point in K(RN), that is, any compact set B, we have\n    \n    lim⁡n→∞ F^n(B) = A\n\nThe compact set A is called the limit set of F, and A is a fractal.\n\n-----------------------------------\n   2. Spacing folding in shader\n-----------------------------------\n\n\nTo implement an IFS fractal in shader, we need to use the inverse of F,\nnot F. This process works exactly in the same way as paper cutting.\n\nIn the process of paper cutting, you first repeatedly fold the paper,\nthen draw some pattern on the folded paper, cut along this pattern,\nand finally unfold the paper to reveal a beautiful design.\n\nHere, the operation of unfolding the paper corresponds to the previous\niterative mapping F. It spreads an initial compact set across the space,\ntransforming it into a fractal, which is a \"one-to-many\" mapping.\n\nThe operation of folding the paper corresponds to F^{-1}. It folds the\nfractal back into the initial compact set, which is a \"many-to-one\"\nmapping.\n\nIf you look at the code of the numerous IFS fractal demos on shadertoy,\nyou will find that they almost always use the `abs` function.\nThis function is many-to-one, folding the entire space into the first\nquadrant, which corresponds to F containing 4 different f_i's.\nAdditionally, further folding with respect to other planes or spheres\ncan generate more fi. This explains why in shaders, we do not need to\nexplicitly write out each individual fi. We just fold, fold, and draw once!\n\n------------------------\n   3. Further detail\n------------------------\n\nAnother important detail is that we need to record a deformation factor\nduring each folding process to correct the final distance field.\n\nWhen drawing an IFS fractal, we need to compute the distance from a point p to it.\nlet A be the initial compact set. We will use F^n(A) as an approximatioin to the fractal,\nfor some sufficiently large n. So we need to know the distance from any point p\nin the space to F^n(A):\n    \n    d(p, F^n(A))\n\nAs mentioned earlier, what we actually compute is\n\n    d(F^{-n}(p), A)\n \nThese two distances are not necessarily equal, but there is a nice relation between them in most cases.\n\nIf F is a rigid body motion such as translation, rotation, or reflection,\nwhich preserves Euclidean distance, then naturally\n\n    d(p, F(A)) = d(F^{-1}(p), A)\n\nHowever, if F is a scaling transformation, for example,\n\n    F(x) = x/s (s>1)\n\nthen\n\n    d(p, F(A)) = d(p, A/s) = d(s⋅p, A)/s = d(F^{-1}(p), A)/s\n    \nThat is, we need to divide the distance value obtained after folding by\nthe accumulated factor s.\n\nHence if F^{-1} is repeated k times, then we need to divide s^n in the end.\n\nFor sphere inversion fractals, similar relation stills holds, except we need to\nreplace the uniform scaling factor s by a local distortion facotr, i.e. the Jacobian.\n\n*/","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"XfXczH","date":"1720747679","viewed":23,"name":"Gray-Scott 2d","description":"Gray-Scott simulation","likes":0,"published":"Unlisted","usePreview":0,"tags":["2d","simulation"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float scale = 2.0;\n\nconst vec4[5] palette = vec4[5] (\n    vec4(0),\n    vec4(0.0, 1.0, 0.0, 0.2),\n    vec4(1.0, 1.0, 0.0, 0.208),\n    vec4(1.0, 0.0, 0.0, 0.4),\n    vec4(1.0, 1.0, 1.0, 0.6));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy / scale;\n    float value = texture(iChannel0, uv).y;\n    float a;\n    vec3 col;\n\n    if (value <= palette[0].w)\n    {\n        col = palette[0].xyz;\n    }\n\n    for (int i=0; i<=3; ++i)\n\n    {\n        if (value > palette[i].w && value <= palette[i+1].w)\n        {\n            a = (value - palette[i].w) / (palette[i+1].w - palette[i].w);\n            col = mix(palette[i].xyz, palette[i+1].xyz, a);\n        }\n    }\n    fragColor = vec4(col.xyz, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define tx(p)  texture(iChannel0, p).xy\n\nconst vec4 params = \n    // vec4(0.210, 0.105, 0.018, 0.051); // unstable\n    // vec4(0.160, 0.080, 0.060, 0.062); // coral\n    // vec4(0.190, 0.050, 0.060, 0.062); // fingerprint\n    // vec4(0.140, 0.060, 0.035, 0.065); // bacteria\n    // vec4(0.160, 0.080, 0.050, 0.065); // worms\n    // vec4(0.160, 0.080, 0.035, 0.060); // zebrafish\n    // vec4(0.210, 0.105, 0.039, 0.058); // net\n    // vec4(0.210, 0.105, 0.014, 0.054); // moving spots\n     vec4(0.210, 0.105, 0.025, 0.060); // pulsating solitons\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iMouse.x < -5.0) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec2 pixelSize = 1.0 / iResolution.xy;\n    vec2 cen = tx(uv);\n    vec2 rig = tx(uv + vec2( pixelSize.x,          0.0));\n    vec2 top = tx(uv + vec2(         0.0,  pixelSize.y));\n    vec2 lef = tx(uv + vec2(-pixelSize.x,          0.0));\n    vec2 bot = tx(uv + vec2(         0.0, -pixelSize.y));\n\n    float Du   = params.x;\n    float Dv   = params.y;\n    float feed = params.z;\n    float kill = params.w;\n\n    vec2 lapl = rig + top + lef + bot - 4.0 * cen;\n    float du = Du * lapl.x - cen.x * cen.y * cen.y + feed * (1.0 - cen.x);\n    float dv = Dv * lapl.y + cen.x * cen.y * cen.y - (feed + kill) * cen.y;\n    vec2 newValue = cen + 0.6 * vec2(du, dv);\n\n    if(iMouse.x > 0.0)\n    {\n        vec2 diff = uv * iResolution.xy - iMouse.xy;\n        float dist = dot(diff, diff);\n        if(dist < 1.0)\n            newValue.y = 0.9;\n    }\n\n    fragColor = vec4(newValue, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"MXdBRS","date":"1737362760","viewed":260,"name":"Fricke & Klein Fig. 156","description":"A limit set (black curve) generated by inversions of five circles.","likes":12,"published":"Public API","usePreview":0,"tags":["fractal","inversion","limitset"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nReproduce an image by Fricke and Klein over a century ago.\n\nIt's Fig 156 in the book\n\n    \"Vorlesungen uber die Theorie der automorphen Funktionen,\n     Teubner Leipzig, Germany, 1897.\"\n\nThe coloring and circle parameters are taken from\n\n    https://images-archive.math.cnrs.fr/Un-ensemble-limite.html?lang=fr\n\nControls:\n\n1. Use mouse to pan\n2. Press W/S to zoom in/out\n*/\n\n#define PI 3.141592653589793\n#define MAX_ITER 1000\n#define CURVE_THICKNESS 0.006\n#define AA 3\n\nfloat zoom;\n\n// Pixels near the center of a circle will be inverted to\n// very far away and have too large scales. This causes such\n// pixels to be incorrectly rendered.\n// For such pixels, scale will be roughly the square of |z|,\n// where z is the final location in the fundamental domain.\n// so add a squared term to fix this.\nbool Equal(vec2 z, vec2 a, float scale) {\n    float k = 1. + length(z);\n    return k * length(z - a) / (scale * zoom) < CURVE_THICKNESS;\n}\n\nconst vec2 z2 = vec2(0.068, -0.272);\nconst vec2 z3 = vec2(0.426, -0.672);\nconst vec2 z4 = vec2(0.816, 0.362);\nconst vec2 z5 = vec2(-1.154, 0.854);\nconst float r1 = 0.4;\n\nconst float d23 = length(z3 - z2);\nconst float d34 = length(z3 - z4);\nconst float d24 = length(z4 - z2);\nconst float d45 = length(z4 - z5);\n\nconst float r2 = (d23 + d24 - d34) / 2.0;\nconst float r3 = (d23 + d34 - d24) / 2.0;\nconst float r4 = (d24 + d34 - d23) / 2.0;\nconst float r5 = d45 - r4;\n\nconst float a = r5 + r1;\nconst float b = r2 + r1;\nconst float c = length(z2 - z5);\n\nvec2 z1;\nvec2 u24, u23, u34, u12, u15, u45;\nvec2 zr1;\nfloat rr1;\n\nvec2 circles[5];\nfloat radii[5];\n\nbool region1(vec2 z) { return length(z - zr1) < rr1; }\n\nbool region2(vec2 z) {\n    return cross2d(z, u12, u24) > 0. && cross2d(z, u24, u45) > 0. &&\n           cross2d(z, u45, u15) > 0. && cross2d(z, u15, u12) > 0.;\n}\n\nvec3 getColor(vec2 z) {\n    vec2 w = z;\n    int count = 0;\n    vec3 color = RED;\n    float scale = 1.0;\n\n    for (int i = 0; i < MAX_ITER; i++) {\n        for (int j = 0; j < 6; j++) {\n            vec2 p = vec2[6](u12, u15, u23, u24, u34, u45)[j];\n            if (Equal(z, p, scale)) {\n                return BLACK;\n            }\n        }\n\n        bool found = true;\n        for (int j = 0; j < 5; j++) {\n            if (length(z - circles[j]) < radii[j]) {\n                z = invert(z, circles[j], radii[j], scale);\n                count++;\n                found = false;\n            }\n        }\n\n        if (found) {\n            if (region1(z)) {\n                color = (count % 2 == 0) ? BROWN : YELLOW;\n            } else if (region2(z)) {\n                color = (count % 2 == 0) ? GREEN : LTGREEN;\n            } else {\n                color = (count % 2 == 0) ? VIOLET : LTVIOLET;\n            }\n            break;\n        }\n    }\n\n    float d = 1e5;\n    for (int j = 0; j < 5; j++) {\n        float d1 = abs(length(w - circles[j]) - radii[j]) - 0.002;\n        d = min(d, d1);\n    }\n    d = smoothstep(0., 0.003, d);\n    color = mix(vec3(1.0), color, d);\n    return color;\n}\n\nvoid init() {\n    z1 = findThirdVertex(z2, z5, a, b, c);\n    u24 = getTouchPoint(z2, r2, z4);\n    u23 = getTouchPoint(z2, r2, z3);\n    u34 = getTouchPoint(z3, r3, z4);\n    u12 = getTouchPoint(z1, r1, z2);\n    u15 = getTouchPoint(z1, r1, z5);\n    u45 = getTouchPoint(z4, r4, z5);\n    zr1 = circumcenter(u23, u24, u34);\n    rr1 = length(u24 - zr1);\n\n    circles[0] = z1;\n    circles[1] = z2;\n    circles[2] = z3;\n    circles[3] = z4;\n    circles[4] = z5;\n    radii[0] = r1;\n    radii[1] = r2;\n    radii[2] = r3;\n    radii[3] = r4;\n    radii[4] = r5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    init();\n    vec4 pan_vals = textureLod(iChannel0, vec2(0.0, 0.0), 0.0);\n    zoom = textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n    vec3 col = vec3(0);\n    for (int ii = 0; ii < AA; ii++) {\n        for (int jj = 0; jj < AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * (fragCoord + o) - iResolution.xy -\n                       pan_vals.xy * pow(zoom, -1.0)) /\n                      iResolution.y;\n            uv *= zoom * 0.8;\n            col += getColor(uv);\n        }\n    }\n    col /= (float(AA) * float(AA));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define L2(x) dot(x, x)\n\nconst vec3 BLACK = vec3(0.0);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst vec3 VIOLET = vec3(0.39, 0.16, 0.71);\nconst vec3 GREEN = vec3(0.0, 0.5, 0.0);\nconst vec3 YELLOW = vec3(0.78, 0.78, 0.0);\nconst vec3 BROWN = vec3(0.75, 0.5, 0.0);\nconst vec3 LTGREEN = vec3(0.36, 0.88, 0.25);\nconst vec3 LTVIOLET = vec3(0.78, 0.39, 1.0);\n\nvec2 findThirdVertex(vec2 z, vec2 w, float a, float b, float c) {\n    vec2 d = z - w;\n    d /= length(d);\n    float k = (a * a - b * b + c * c) / (2.0 * c);\n    float h = sqrt(a * a - k * k);\n    return w + vec2(d.x * k + d.y * h, d.y * k - d.x * h);\n}\n\nvec2 circumcenter(vec2 A, vec2 B, vec2 C) {\n    float dx = B.x - A.x;\n    float dy = B.y - A.y;\n    float ex = C.x - A.x;\n    float ey = C.y - A.y;\n    float bl = dx * dx + dy * dy;\n    float cl = ex * ex + ey * ey;\n    float d = 0.5 / (dx * ey - dy * ex);\n    float x = A.x + (ey * bl - dy * cl) * d;\n    float y = A.y + (dx * cl - ex * bl) * d;\n    return vec2(x, y);\n}\n\nvec2 getTouchPoint(vec2 z1, float r1, vec2 z2) {\n    vec2 d = z2 - z1;\n    d /= length(d);\n    return d * r1 + z1;\n}\n\nfloat cross2d(vec2 A, vec2 B, vec2 C) {\n    vec2 AB = B - A;\n    vec2 AC = C - A;\n    return AB.x * AC.y - AB.y * AC.x;\n}\n\nvec2 invert(vec2 z, vec2 cen, float r, inout float scale) {\n    float k = (r * r) / dot(z - cen, z - cen);\n    scale *= k;\n    return cen + k * (z - cen);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// https://www.shadertoy.com/view/ldyGzW\nconst int Key_A = 65;\nconst int Key_B = 66;\nconst int Key_C = 67;\nconst int Key_D = 68;\nconst int Key_E = 69;\nconst int Key_F = 70;\nconst int Key_G = 71;\nconst int Key_H = 72;\nconst int Key_I = 73;\nconst int Key_J = 74;\nconst int Key_K = 75;\nconst int Key_L = 76;\nconst int Key_M = 77;\nconst int Key_N = 78;\nconst int Key_O = 79;\nconst int Key_P = 80;\nconst int Key_Q = 81;\nconst int Key_R = 82;\nconst int Key_S = 83;\nconst int Key_T = 84;\nconst int Key_U = 85;\nconst int Key_V = 86;\nconst int Key_W = 87;\nconst int Key_X = 88;\nconst int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48;\nconst int Key_1 = 49;\nconst int Key_2 = 50;\nconst int Key_3 = 51;\nconst int Key_4 = 52;\nconst int Key_5 = 53;\nconst int Key_6 = 54;\nconst int Key_7 = 55;\nconst int Key_8 = 56;\nconst int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal(int key, bool toggle) {\n    return textureLod(iChannel1,\n                      vec2((float(key) + .5) / 256.0, toggle ? .75 : .25), 0.0)\n        .x;\n}\n\nfloat ReadKey(int key) { return ReadKeyInternal(key, false); }\n\nfloat ReadKeyToggle(int key) { return ReadKeyInternal(key, true); }\n\n// Storage Code For Pan and Zoom\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    // Only run once each frame\n\n    if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n        // Mouse Pan Stored In Here\n\n        vec4 prev_info = textureLod(iChannel0, vec2(0.0, 0.0), 0.0);\n        float Zoom =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n        float prev_pan_x = prev_info.x;\n        float prev_pan_y = prev_info.y;\n\n        float legacy_pan_x = prev_info.z;\n        float legacy_pan_y = prev_info.w;\n\n        float pan_x = (iMouse.x - abs(iMouse.z)) * Zoom + legacy_pan_x;\n        float pan_y = (iMouse.y - abs(iMouse.w)) * Zoom + legacy_pan_y;\n\n        if (iMouse.z < 0.0) {\n            // Mouse has been lifted up\n            legacy_pan_x = prev_pan_x;\n            legacy_pan_y = prev_pan_y;\n            pan_x = legacy_pan_x;\n            pan_y = legacy_pan_y;\n        }\n\n        fragColor = vec4(pan_x, pan_y, legacy_pan_x, legacy_pan_y);\n    }\n\n    // Zoom settings\n    if (ivec2(fragCoord.xy) == ivec2(10, 10)) {\n\n        float x =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).y;\n        // Number of times zoom in - zoom out has happend\n\n        x += ReadKey(Key_W) - ReadKey(Key_S);\n\n        float Zoom = pow(2.71, -x * 0.05); // Times all limits by this value\n\n        fragColor = vec4(Zoom, x, 0.0, 0.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"43dfWj","date":"1737636585","viewed":225,"name":"Fricke & Klein Fig. 145/148","description":"A limit set (black curve) generated by inversions of four circles.","likes":11,"published":"Public API","usePreview":0,"tags":["alimitsetblackcurvegeneratedbyinversionsoffivecircles"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis program draws Fig. 145 and Fig. 148 in Fricke and Klein's book\n\n    \"Vorlesungen uber die Theorie der automorphen Funktionen,\n     Teubner Leipzig, Germany, 1897.\"\n\nControls:\n\n1. Use mouse to pan\n2. Press W/S to zoom in/out\n\n\nAlso, if you comment out the line '#define apollonian', it will show\nfigure 7.4 of the apollonian circle packing in the book \"Indra's pearls\".\n\n*/\n\n//try comment out the line below!\n//#define apollonian\n\n\n// distance between y=0 and the middle small circle (z3, r3)\n\n#define PI 3.141592653589793\n#define MAX_ITER 1000\n#define CURVE_THICKNESS 0.007\n#define AA 3\n#define L2(x)  dot(x, x)\n\n\n// middle small circle\nconst float r3 = 0.3;\n\n#ifdef apollonian\n    const float r2 = 4.0 * r3;\n    const float r4 = 4.0 * r3;\n#else\n    const float r2 = 0.8;\n    const float r4 = 0.8;\n#endif\n\nconst float radii[3] = float[3] (r2, r3, r4);\nconst vec3 COLOR1 = vec3(0.85, 0.85, 0.1);\nconst vec3 COLOR2 = vec3(0.75, 0.5, 0.1);\nconst vec3 COLOR3 = vec3(0.7, 0.6, 0.85);\nconst vec3 COLOR4 = vec3(0.3, 0.4, 0.6);\n\nfloat spacing, zoom;\n\nvec2 getTouchPoint(vec2 z1, float r1, vec2 z2) {\n    vec2 d = z2 - z1;\n    d /= length(d);\n    return d * r1 + z1;\n}\n\nfloat cross2d(vec2 A, vec2 B, vec2 C) {\n    vec2 AB = B - A;\n    vec2 AC = C - A;\n    return AB.x * AC.y - AB.y * AC.x;\n}\n\nvec2 invert(vec2 z, vec2 cen, float r, inout float scale) {\n    float k = (r * r) / dot(z - cen, z - cen);\n    scale *= k;\n    return cen + k * (z - cen);\n}\n\n// Pixels near the center of a circle will be inverted to\n// very far away and have too large scales. This causes such\n// pixels to be incorrectly rendered.\n// For such pixels, scale will be roughly the square of |z|,\n// where z is the final location in the fundamental domain.\n// so add a squared term to fix this.\nbool Equal(vec2 z, vec2 a, float scale) {\n    float k = 1. + length(z);\n    return k * length(z - a) / (scale * zoom) < CURVE_THICKNESS;\n}\n\n\nfloat y3, x2, x4;\nvec2 z2, z3, z4;\nconst vec2 z1 = vec2(0, -1);\nvec2 u12, u14, u23, u34;\nvec2 circles[3];\n\nbool region1(vec2 z) {\n    return cross2d(z, u23, u34) > 0. && \n           cross2d(z, u12, u23) > 0. &&\n           cross2d(z, u34, u14) > 0.;\n}\n\nvec3 getColor(vec2 z) {\n    vec2 w = z;\n    int count = 0;\n    vec3 color = vec3(1, 0, 0);\n    float scale = 1.0;\n    \n    for (int i = 0; i < MAX_ITER; i++) {\n        for (int j = 0; j < 4; j++) {\n            vec2 p = vec2[4](u12, u23, u34, u14)[j];\n            if (Equal(z, p, scale)) { return vec3(0); }\n        }\n\n        bool found = true;\n        \n        if (z.y > 0.) {\n            z.y = -z.y;\n            count++;\n            found = false;\n        }\n        for (int j = 0; j < 3; j++) {\n            if (length(z - circles[j]) < radii[j]) {\n                z = invert(z, circles[j], radii[j], scale);\n                count++;\n                found = false;\n            }\n        }\n\n        if (found) {\n            if (region1(z)) {\n                color = (count % 2 == 0) ? COLOR1 : COLOR2;\n            } \n            else {\n                color = (count % 2 == 0) ? COLOR3 : COLOR4;\n            }\n            break;\n        }   \n    }\n\n    float d = 1e5;\n    for (int j = 0; j < 3; j++) {\n        float d1 = abs(length(w - circles[j]) - radii[j]) - 0.002;\n        d = min(d, d1);\n    }\n    d = min(d, abs(w.y) - 0.002);\n    d = smoothstep(0., 0.003, d);\n    color = mix(vec3(1.0), color, d);\n    return color;\n}\n\nvoid init() {\n    zoom = textureLod(iChannel0, vec2(10.5,10.5)/iResolution.xy, 0.0).x;\n#ifdef apollonian\n    spacing = 0.0;\n    zoom *= 1.6;\n#else\n    spacing = (1. + sin(iTime * 1.5)) / 20.;\n#endif\n\n    y3 = -(spacing + r3);\n    z3 = vec2(0., y3);\n    x2 = -sqrt((r2+r3)*(r2+r3) - (r2+y3)*(r2+y3));\n    z2 = vec2(x2, -r2);\n    x4 = sqrt((r4+r3)*(r4+r3) - (r4+y3)*(r4+y3));\n    z4 = vec2(x4, -r4);\n    u12 = vec2(z2.x, 0.);\n    u14 = vec2(z4.x, 0.);\n    u23 = getTouchPoint(z2, r2, z3);\n    u34 = getTouchPoint(z3, r3, z4);\n    circles = vec2[3] (z2, z3, z4);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    init();\n    vec4 pan_vals = textureLod(iChannel0, vec2(0.0,0.0),0.0);\n    vec3 col = vec3(0);\n    for(int ii=0; ii<AA; ii++) {\n    for(int jj=0; jj<AA; jj++) {\n        vec2 o = vec2(float(ii), float(jj)) / float(AA);\n        vec2 uv = (2. * (fragCoord  + o) -iResolution.xy - pan_vals.xy * pow(zoom, -1.0)) / iResolution.y;\n        uv *= 0.8;\n        uv *= zoom;\n        col += getColor(uv);\n    }\n    }\n    col /= (float(AA) * float(AA));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// https://www.shadertoy.com/view/ldyGzW\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal( int key, bool toggle )\n{\n\treturn textureLod( iChannel1, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ), 0.0 ).x;\n}\n\nfloat ReadKey( int key )\n{\n\treturn ReadKeyInternal(key,false);\n}\n\nfloat ReadKeyToggle( int key )\n{\n\treturn ReadKeyInternal(key,true);\n}\n\n\n\n//Storage Code For Pan and Zoom\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n    //Only run once each frame\n    \n        if (ivec2(fragCoord.xy) == ivec2(0,0) )\n        {\n            //Mouse Pan Stored In Here\n        \n        \n            vec4 prev_info = textureLod(iChannel0, vec2(0.0,0.0),0.0);\n            float Zoom = textureLod(iChannel0, vec2(10.5,10.5)/iResolution.xy,0.0).x;\n            float prev_pan_x = prev_info.x;\n            float prev_pan_y = prev_info.y;\n            \n            float legacy_pan_x = prev_info.z;\n            float legacy_pan_y = prev_info.w;\n            \n            float pan_x = (iMouse.x - abs(iMouse.z))*Zoom + legacy_pan_x;\n            float pan_y = (iMouse.y - abs(iMouse.w))*Zoom + legacy_pan_y;\n    \n            if (iMouse.z < 0.0)\n            {\n                //Mouse has been lifted up\n                legacy_pan_x = prev_pan_x;\n                legacy_pan_y = prev_pan_y;\n                pan_x = legacy_pan_x;\n                pan_y = legacy_pan_y;\n\n            }     \n         \n            fragColor = vec4(pan_x, pan_y, legacy_pan_x, legacy_pan_y);\n        }\n        \n    //Zoom settings\n    if (ivec2(fragCoord.xy) == ivec2(10,10) )\n    {\n    \n        float x = textureLod(iChannel0, vec2(10.5,10.5)/iResolution.xy,0.0).y;\n        //Number of times zoom in - zoom out has happend\n        \n        x += ReadKey(Key_W)-ReadKey(Key_S);\n        \n        float Zoom = pow(2.71, -x*0.05); //Times all limits by this value\n        \n        fragColor = vec4(Zoom, x,0.0,0.0);\n    }\n    \n    \n}\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"X3GBzD","date":"1740626915","viewed":175,"name":"Indra's pearls, Fig 4.2 ","description":"Fig 4.2 in Indra's pearls","likes":14,"published":"Public API","usePreview":0,"tags":["fractal","2s","schottkygroup"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nFractal Dust\n\nFig 4.2 in the book Indra's Pearls, Chapter 4, \"The Schottky Dance\".\n\nA Schottky group generated by two Mobius transformations that pairing\nfour disjoint circles. The limit set is a Cantor set, it looks like a\nnecklace that has been cut into countless pieces.\n\nControls:\n\n1. Use mouse to pan\n2. Press W/S to zoom in/out\n*/\n\n#define AA 3\nconst float PI = 3.141592654;\nconst int maxIter = 20;\nconst float ra = 0.55;\nconst float rA = 0.55;\nconst float rb = 0.45;\nconst float rB = 0.45;\n\nconst float thetaA = -PI / 2.;\nconst float thetaB = PI / 2.;\n\n// colors for disks of different levels\n#define N 7\nconst vec3 colors[N] =\n    vec3[N](vec3(0.95, 0.2, 0.2), vec3(.9, .9, 0.3), vec3(.1, .6, .3),\n            vec3(0.2, 0.3, 1.), vec3(0.5, .6, 1.), vec3(1, 0.7, 0.75),\n            vec3(0.2, 1., 0.95));\n\nvec2 za, zb, zA, zB;\n\nfloat zoom;\n\nvec2 rot2d(vec2 p, float a) { return p * cos(a) + vec2(-p.y, p.x) * sin(a); }\n\nvec2 conj(vec2 z) { return vec2(z.x, -z.y); }\n\nvec2 a(vec2 z, inout float scale) {\n    z -= zA;\n    float k = (ra * rA) / dot(z, z);\n    scale *= k;\n    return za + k * rot2d(conj(z), thetaA);\n}\n\nvec2 A(vec2 z, inout float scale) {\n    float k = (ra * rA) / dot(z - za, z - za);\n    scale *= k;\n    return zA + k * rot2d(conj(z - za), thetaA);\n}\nvec2 b(vec2 z, inout float scale) {\n    float k = (rb * rB) / dot(z - zB, z - zB);\n    scale *= k;\n    return zb + k * rot2d(conj(z - zB), thetaB);\n}\nvec2 B(vec2 z, inout float scale) {\n    float k = (rb * rB) / dot(z - zb, z - zb);\n    scale *= k;\n    return zB + k * rot2d(conj(z - zb), thetaB);\n}\n\nvec3 getColor(vec2 z) {\n    float count = 0.;\n    float lig = 0.;\n    float scale = 1.;\n    for (int i = 0; i < maxIter; i++) {\n        if (length(z - za) < ra) {\n            lig = length(z - za) / ra;\n            z = A(z, scale);\n            count += 1.0;\n        } else if (length(z - zA) < rA) {\n            lig = length(z - zA) / rA;\n            z = a(z, scale);\n            count += 1.0;\n        } else if (length(z - zb) < rb) {\n            lig = length(z - zb) / rb;\n            z = B(z, scale);\n            count += 1.0;\n        } else if (length(z - zB) < rB) {\n            lig = length(z - zB) / rB;\n            z = b(z, scale);\n            count += 1.0;\n        } else {\n            break;\n        }\n    }\n\n    float d = length(z - za) - ra;\n    d = min(d, length(z - zb) - rb);\n    d = min(d, length(z - zA) - rA);\n    d = min(d, length(z - zB) - rB);\n    float k = 1. / (10. + length(z));\n    d /= k * scale;\n    vec3 basecol = vec3(1);\n    if (count > 0.) {\n        basecol = colors[int(count - 1.) % N];\n        basecol =\n            vec3(pow(basecol.x, lig), pow(basecol.y, lig), pow(basecol.z, lig));\n    }\n    float thickness = iResolution.y > 400. ? 2.5 : 4.;\n    thickness *= zoom / 200.;\n    vec3 col =\n        mix(vec3(0), basecol, smoothstep(0., thickness, abs(d) - thickness));\n    return col;\n}\n\nvoid init() {\n    float t = 3. * iTime;\n    const float k = 0.05;\n    za = vec2(ra) * (1. + k + k * cos(t));\n    zA = vec2(-rA) * (1. + k + k * cos(t));\n    zb = vec2(rb, -rb) * (1. + k + k * cos(t));\n    zB = vec2(-rB, rB) * (1. + k + k * cos(t));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    init();\n    vec4 pan_vals = textureLod(iChannel0, vec2(0.0, 0.0), 0.0);\n    zoom = textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n\n    vec3 col = vec3(0);\n    for (int ii = 0; ii < AA; ii++) {\n        for (int jj = 0; jj < AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (fragCoord + o - .5 * iResolution.xy -\n                       pan_vals.xy * pow(zoom, -1.0)) /\n                      iResolution.y;\n            uv *= 2.0;\n            uv *= zoom;\n            col += getColor(uv);\n        }\n    }\n    col /= (float(AA) * float(AA));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// https://www.shadertoy.com/view/ldyGzW\nconst int Key_A = 65;\nconst int Key_B = 66;\nconst int Key_C = 67;\nconst int Key_D = 68;\nconst int Key_E = 69;\nconst int Key_F = 70;\nconst int Key_G = 71;\nconst int Key_H = 72;\nconst int Key_I = 73;\nconst int Key_J = 74;\nconst int Key_K = 75;\nconst int Key_L = 76;\nconst int Key_M = 77;\nconst int Key_N = 78;\nconst int Key_O = 79;\nconst int Key_P = 80;\nconst int Key_Q = 81;\nconst int Key_R = 82;\nconst int Key_S = 83;\nconst int Key_T = 84;\nconst int Key_U = 85;\nconst int Key_V = 86;\nconst int Key_W = 87;\nconst int Key_X = 88;\nconst int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48;\nconst int Key_1 = 49;\nconst int Key_2 = 50;\nconst int Key_3 = 51;\nconst int Key_4 = 52;\nconst int Key_5 = 53;\nconst int Key_6 = 54;\nconst int Key_7 = 55;\nconst int Key_8 = 56;\nconst int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal(int key, bool toggle) {\n    return textureLod(iChannel1,\n                      vec2((float(key) + .5) / 256.0, toggle ? .75 : .25), 0.0)\n        .x;\n}\n\nfloat ReadKey(int key) { return ReadKeyInternal(key, false); }\n\nfloat ReadKeyToggle(int key) { return ReadKeyInternal(key, true); }\n\n// Storage Code For Pan and Zoom\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    // Only run once each frame\n\n    if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n        // Mouse Pan Stored In Here\n\n        vec4 prev_info = textureLod(iChannel0, vec2(0.0, 0.0), 0.0);\n        float Zoom =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n        float prev_pan_x = prev_info.x;\n        float prev_pan_y = prev_info.y;\n\n        float legacy_pan_x = prev_info.z;\n        float legacy_pan_y = prev_info.w;\n\n        float pan_x = (iMouse.x - abs(iMouse.z)) * Zoom + legacy_pan_x;\n        float pan_y = (iMouse.y - abs(iMouse.w)) * Zoom + legacy_pan_y;\n\n        if (iMouse.z < 0.0) {\n            // Mouse has been lifted up\n            legacy_pan_x = prev_pan_x;\n            legacy_pan_y = prev_pan_y;\n            pan_x = legacy_pan_x;\n            pan_y = legacy_pan_y;\n        }\n\n        fragColor = vec4(pan_x, pan_y, legacy_pan_x, legacy_pan_y);\n    }\n\n    // Zoom settings\n    if (ivec2(fragCoord.xy) == ivec2(10, 10)) {\n\n        float x =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).y;\n        // Number of times zoom in - zoom out has happend\n\n        x += ReadKey(Key_W) - ReadKey(Key_S);\n\n        float Zoom = pow(2.71, -x * 0.05); // Times all limits by this value\n\n        fragColor = vec4(Zoom, x, 0.0, 0.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"WclXR7","date":"0","viewed":0,"name":"Fractal sponge","description":"A Kleinian variant","likes":0,"published":"Private","usePreview":0,"tags":["3d","fractal"]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 3\n\n#define FOV_DIST         3.0\n#define FOLDING_NUMBER   8\n#define MAX_TRACE_STEPS  200\n#define MIN_TRACE_DIST   0.01\n#define MAX_TRACE_DIST   10.0\n#define PRECISION        1e-4\n#define PI               3.14159265358979323\n#define T                (iTime * 0.005)\n\n\nconst vec4 param_min = vec4(-1.4661, -1.1076, -1.1844, 1.8886);\nconst vec4 param_max = vec4(3.7324, 1.1972, 1.1204, 2.4136);\n\n\n// view to world transformation\nmat3 viewMatrix(vec3 camera, vec3 lookat, vec3 up) {\n    vec3 f = normalize(lookat - camera);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    return mat3(r, u, -f);\n}\n\n// 2D rotatation\nvoid R(inout vec2 p, float a) {\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nfloat sdSponge(vec3 z) {\n    z *= 5.0;\n    //folding\n    for(int i = 0; i < 4; i++) {\n        z = abs(z);\n        z.xy = (z.x < z.y) ? z.yx : z.xy;\n        z.xz = (z.x < z.z) ? z.zx : z.xz;\n        z.zy = (z.y < z.z) ? z.yz : z.zy;\n        z = z * 3.0 - 2.0;\n        z.z += (z.z < -1.0) ? 2.0 : 0.0;\n    }\n    //distance to cube\n    z = abs(z) - vec3(1.0);\n    float dis = min(max(z.x, max(z.y, z.z)), 0.0) + length(max(z, 0.0));\n    //scale cube size to iterations\n    return dis * 0.2 * pow(3.0, -3.0);\n}\n\nvec2 DE(vec3 p) {\n    float k, r2;\n    float scale = 1.0;\n    float orb = 1e4;\n    for (int i = 0; i < FOLDING_NUMBER; i++) {\n        p = 2.0 * clamp(p, param_min.xyz, param_max.xyz) - p;\n        r2 = dot(p, p);\n        k = max(param_min.w / r2, 1.0);\n        p *= k;\n        scale *= k;\n        orb = min(orb, r2);\n    }\n    p /= scale;\n    p *= param_max.w * 10.0;\n    return vec2(0.1 * sdSponge(p) / (param_max.w * 10.0),\n                sqrt(orb));\n}\n\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n\t\t\t  DE(p + e.xyy).x - DE(p - e.xyy).x,\n\t\t\t  DE(p + e.yxy).x - DE(p - e.yxy).x,\n\t\t\t  DE(p + e.yyx).x - DE(p - e.yyx).x));\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n    float t = MIN_TRACE_DIST;\n    vec2 h;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        h = DE(ro + rd * t);\n        if (h.x < PRECISION * t || t > MAX_TRACE_DIST)\n            return vec2(t, h.y);\n        t += h.x;\n    }\n    return vec2(-1.0, 0.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) {\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 30; i++) {\n        float h = DE(ro + rd * t).x;\n        res = min(res, k * h / t);\n        t += clamp(h, 0.01, 0.1);\n        if (h < 0.001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat calcAO(vec3 p, vec3 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = DE(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\n// https://www.shadertoy.com/view/4dSfRc\nvec3 render(vec3 ro, vec3 rd, vec3 lig, vec2 uv) {\n    vec3 background = vec3(0.08, 0.16, 0.32);\n    vec3 col = background;\n    vec2 res = trace(ro, rd);\n    float t = res.x;\n    if (t >= 0.0) {\n        col = vec3(0.94, 0.93, 0.90); // silver taken from POV-Ray\n        vec3 pos = ro + rd * t;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n        float occ = calcAO(pos, nor);\n        float amb = 0.2;\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp(1.0 - pos.y, 0.0, 1.0);\n        float dom = smoothstep(-0.1, 0.1, ref.y);\n        float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n        float spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 16.0);\n        dif *= softShadow(pos, lig, 0.02, 5.0, 16.0);\n        dom *= softShadow(pos, ref, 0.02, 5.0, 16.0);\n\n        vec3 lin = vec3(0.05);\n        lin += 1.5 * dif * texture(iChannel0, uv).rgb;\n        lin += 4.0 * spe * vec3(1.0, 0.9, 0.7) * dif;\n        lin += 0.3 * amb * vec3(0.4, 0.6, 1.0) * occ;\n        lin += 0.2 * bac * vec3(0.25) * occ;\n        lin += 0.5 * dom * vec3(0.4, 0.6, 1.0) * occ;\n        lin += 0.25 * fre * vec3(1.0) * occ;\n\n        col *= lin;\n        float atten = 1.0 / (1.0 + t * t * 0.3);\n        col *= atten;\n        col = mix(col, background, smoothstep(0.0, 0.95, t / MAX_TRACE_DIST));\n    }\n    return sqrt(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 tot = vec3(0.0);\n    for (int ii = 0; ii < AA; ii++) {\n        for (int jj = 0; jj < AA; jj++) {\n            // map uv to (-1, 1) and adjust aspect ratio\n            vec2 offset = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (fragCoord + offset) / iResolution.xy;\n            uv = 2.0 * uv - 1.0;\n            uv.x *= iResolution.x / iResolution.y;\n            vec3 camera = vec3(1.0, -1.0, 0.6);\n            vec3 lookat = vec3(0.0);\n            vec3 up = vec3(0.0, 0.0, 1.0);\n            // set camera\n            vec3 ro = camera;\n            R(ro.xy, T);\n            mat3 M = viewMatrix(ro, lookat, up);\n            // put screen at distance FOV_DISt in front of the camera\n            vec3 rd = M * normalize(vec3(uv, -FOV_DIST));\n            vec3 lig = normalize(vec3(1.0));\n            vec3 col = render(ro, rd, lig, fragCoord);\n            tot += col;\n        }\n    }\n    tot /= float(AA * AA);\n    fragColor = vec4(tot, 1.0);\n}\n","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"wcsXzX","date":"0","viewed":0,"name":"Rewrit Boyd-Maxwe","description":"Limit set of rank 4 hyperbolic Coxeter groups, drawn both on the boundary sphere and the stereo-projected plane.","likes":0,"published":"Private","usePreview":0,"tags":["coxeter","tiling","hyperbolic","circlepacking","limitset"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nBoyd-Maxwell circle packings of hyperbolic Coxeter groups: rank 4/level 2 case\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor more information check the github repo:\n\n    https://github.com/neozhaoliang/Hyperbolic-Honeycombs\n\nRequired input:\n\nThe Coxeter diagram of a rank 4 Coxeter group G = <A, B, C, D>, with dihedral\nangles m_{s,t} in the order (AB, AC, AD, BC, BD, CD).\n\nNote:\n\n1. CD must be finite\n2. The triangle group <B, C, D> must be hyperbolic\n\nIf you see only a sphere and a small disk under it, try comment out `#define\nuseMouseInvert` below.\n*/\n\n#define useMouseInvert\n\n#define shiny 5.\n\n//#define config      initLevel2Graph(float[6](4., 2., 7., 4., 2., 5.))\n//#define config      initLevel2Graph(float[6](3., 2., 2., 3., 2., 7.))\n//#define config      initLevel2Graph(float[6](3., 3., 2., 3., 2., 7.))\n//#define config      initLevel2Graph(float[6](4., 4., 4., 4., 4., 4.))\n//#define config      initLevel2Graph(float[6](2., 2., 7., inf, 3., 3.))\n//#define config      initLevel2Graph(float[6](3., 3., 2., 7., 2., 3.))\n#define config initLevel2Graph(float[6](5., 2., 3., 4., 3., 3.))\n\nvec2 map(vec3 p) {\n  float d1 = sdSphere(p);\n  float d2 = sdPlane(p);\n  float id = (d1 < d2) ? 0. : 1.;\n  return vec2(min(d1, d2), id);\n}\n\n// standard scene normal\nvec3 getNormal(vec3 p) {\n  const vec2 e = vec2(0.0001, 0.);\n  return normalize(vec3(map(p + e.xyy).x - map(p - e.xyy).x,\n                        map(p + e.yxy).x - map(p - e.yxy).x,\n                        map(p + e.yyx).x - map(p - e.yyx).x));\n}\n\n// get the signed distance to an object and object id\nvec2 raymarch(in vec3 ro, in vec3 rd) {\n  float t = MIN_TRACE_DIST;\n  vec2 h;\n  for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n    h = map(ro + t * rd);\n    if (h.x < PRECISION * (t * 0.125 + 1.))\n      return vec2(t, h.y);\n\n    if (t > MAX_TRACE_DIST)\n      break;\n\n    t += h.x;\n  }\n  return vec2(-1.0);\n}\n\nfloat calcOcclusion(vec3 p, vec3 n) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.15 * float(i) / 4.0;\n    float d = map(p + h * n).x;\n    occ += (h - d) * sca;\n    sca *= 0.85;\n  }\n  return clamp(1.0 - occ, 0.2, 1.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 20; i++) {\n    float h = map(ro + rd * t).x;\n    res = min(res, k * h / t);\n    t += clamp(h, 0.001, 0.1);\n    if (h < 0.0001 || t > tmax)\n      break;\n  }\n  return clamp(res, 0., 1.0);\n}\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, vec3 lp, vec3 basecol) {\n  vec3 col = vec3(0.0);\n  vec3 ld = lp - pos;\n  float lDist = max(length(ld), .001);\n  ld /= lDist;\n  float ao = calcOcclusion(pos, nor);\n  float sh = softShadow(pos + 0.001 * nor, ld, 0.01, lDist, 8.);\n  float diff = clamp(dot(nor, ld), 0., 1.);\n  float atten = shiny / (1. + lDist * lDist * .001);\n  float spec = pow(max(dot(reflect(-ld, nor), -rd), 0.0), 6.);\n  float fres = clamp(1.0 + dot(rd, nor), 0.0, 1.0);\n  col += basecol * diff;\n  col += basecol * vec3(.8, 1., 0.3) * spec * 4.;\n  col += basecol * vec3(1.2, 1., .8) * fres * fres * 2.;\n  col *= ao * atten * sh;\n  col += basecol * clamp(0.8 + 0.2 * nor.z, 0., 1.);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 scenecol = vec3(0.);\n\n  // initialize the mirrors\n\n  config;\n\n  vec3 camera = vec3(4, 1.5, 4);\n  vec3 lp = vec3(.5, .5, 4.); // light position\n  camera.xy = rot2d(camera.xy, iTime * 0.3);\n  vec3 lookat = vec3(0.);\n  vec3 up = vec3(0, 0, 1);\n  vec3 forward = normalize(lookat - camera);\n  vec3 right = normalize(cross(forward, up));\n  up = normalize(cross(right, forward));\n\n  float lw = 8. / iResolution.y;\n\n  // antialiasing loop\n\n  for (int ii = 0; ii < AA; ii++) {\n    for (int jj = 0; jj < AA; jj++) {\n      vec2 o = vec2(float(ii), float(jj)) / float(AA);\n      vec2 uv = (2. * fragCoord + o - iResolution.xy) / iResolution.y;\n      vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);\n      vec2 res = raymarch(camera, rd);\n      float t = res.x;\n      float id = res.y;\n      vec3 pos = camera + t * rd;\n\n      float ed;\n      vec3 col;\n      vec2 p0;\n      vec3 nor;\n\n      // the sphere is hit\n      if (id == 0.) {\n        nor = pos;\n        p0 = sphereToPlane(pos);\n      }\n\n      // the plane is hit\n      else if (id == 1.) {\n        nor = vec3(0, 0, 1);\n        p0 = pos.xy;\n      }\n#ifdef useMouseInvert\n      vec2 mouse = (iMouse.xy - 2. * iResolution.xy) / iResolution.y;\n      if (iMouse.z == 0.)\n        mouse = vec2(1.5, 1.5);\n      mouse = rot2d(mouse, iTime * 0.1);\n      float k = 1. / L2(mouse);\n      vec2 invCtr = k * mouse;\n      float tt = (k - 1.) / L2(p0 - invCtr);\n      p0 = tt * p0 + (1. - tt) * invCtr;\n#endif\n      vec3 basecol = getcolor(p0, ed);\n      col = getColor(camera, rd, pos, nor, lp, basecol);\n      float dist = distanceToMirrors(p0);\n      col = mix(col, vec3(0.), 1.0 - exp(-0.01 * t * t));\n      scenecol += col;\n    }\n  }\n  scenecol /= (float(AA) * float(AA));\n\n  fragColor = vec4(sqrt(max(scenecol, 0.0)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define inf 1.0 // Vinberg convention for edge labels\n#define MAX_REFLECTIONS 500\n#define AA 2\n#define PI 3.141592653\n#define L2(x) dot(x, x)\n#define L2XY(x, y) L2(x - y)\n#define Hyperbolic -1.0\n#define Euclidean 0.\n#define Spherical 1.\n#define MAX_TRACE_STEPS 500\n#define MIN_TRACE_DIST 0.001\n#define MAX_TRACE_DIST 100.0\n#define PRECISION 0.0001\n#define EdgeSize1 0.0035\n#define EdgeSize2 0.01\n#define ColorScale 0.8\n\n// Move a vertex of Euclidean type (if there is any) to infinity,\n// so the pattern tiles the entire plane\n#define moveVertexToInf\n\n// 4x4 Cartan matrix for the Coxeter group\nmat4 cartan;\n\n// geometry type of each vertex in the Coxeter diagram\n// -1 for hyerbolic, 0 for Euclidean, 1 for spherial\nvec4 vertexType = vec4(1);\n\n// coordinates of a Euclidean vertex\nvec2 euclideanVertex;\n\n// if we are outside of the unit circle\n// if a point lies outside of unit circle, the distance\n// estimation becomes inaccurate. We use EdgeSize2 to control the edge size for\n// this case.\nbool outside = false;\n\n// if there is an Euclidean vertex, i.e. if remove this vertex, the remain\n// diagram is affine\nbool hasEuclideanVertex;\n\n// compute cos(PI / x), for x = inf this is just inf\nfloat dihedral(float x) { return x == inf ? inf : cos(PI / x); }\n\n// complex multiplication\nvec2 cmul(vec2 p, vec2 q) {\n  return vec2(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);\n}\n\n// complex division\nvec2 cdiv(vec2 z, vec2 w) {\n  return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\n// compute the vertex type of each vertex.\n// for each vertex in the Coxeter diagram, its vertex type is determined by the\n// triangle group G formed by the remaining three vertices. This vertex is of\n// hyperbolic/spherical/euclidean iff G is hyperbolic/spherical/euclidean,\n// respectively. This can be checked from the determinant of the leading minors\n// of the Cartan matrix.\nvoid checkCartan(mat4 M) {\n  const float e = 0.001;\n  float det;\n  det = determinant(mat3(M[1].yzw, M[2].yzw, M[3].yzw));\n  vertexType.x = step(-e, det) + step(e, det) - 1.;\n\n  det = determinant(mat3(M[0].xzw, M[2].xzw, M[3].xzw));\n  vertexType.y = step(-e, det) + step(e, det) - 1.;\n\n  det = determinant(mat3(M[0].xyw, M[1].xyw, M[3].xyw));\n  vertexType.z = step(-e, det) + step(e, det) - 1.;\n\n  det = determinant(mat3(M[0].xyz, M[1].xyz, M[2].xyz));\n  vertexType.w = step(-e, det) + step(e, det) - 1.;\n}\n\n// For spheres cen is the center, r is the radius\n// For planes cen is the normal vector, r is the offset from the origin along\n// the normal. if invert is true then the inside/outside of the sphere is\n// exchanged.\nstruct Ball {\n  vec2 cen;\n  float r;\n  bool isplane;\n  bool invert;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[4] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[4] clusters;\n\n// create a default ball (unit circle)\nBall defaultBall() { return Ball(vec2(0), 1., false, false); }\n\nBall from_plane(vec2 normal, float offset) {\n  return Ball(normal, offset, true, false);\n}\n\nBall from_sphere(vec2 cen, float r) { return Ball(cen, r, false, false); }\n\nvoid invertBall(inout Ball B) { B.invert = !B.invert; }\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec2 p, Ball B, inout int count) {\n  vec2 cen = B.cen;\n  float r = B.r;\n  if (B.isplane) {\n    float k = dot(vec3(p, 1), vec3(cen, r));\n    if (k >= 0.)\n      return true;\n    p -= 2. * k * cen;\n    count += 1;\n    return false;\n  } else {\n    vec2 q = p - cen;\n    float d2 = dot(q, q);\n    float k = (r * r) / d2;\n    if (k < 1.0)\n      return true;\n    p = k * q + cen;\n    count += 1;\n    return false;\n  }\n}\n\nvec2 getIntersection(Ball B1, Ball B2, Ball B3) {\n  vec2 dir = vec2(-B3.cen.y, B3.cen.x);\n  float r1 = B1.r, r2 = B2.r;\n  float k = (L2(B1.cen) - L2(B2.cen) - (r1 * r1 - r2 * r2)) /\n            (2. * dot(B1.cen - B2.cen, dir));\n  return k * dir;\n}\n\nBall solveBall(Ball B1, Ball B2, Ball B3) {\n  vec2 dir = vec2(-B3.cen.y, B3.cen.x);\n  float r1 = B1.r, r2 = B2.r;\n  float k = (L2(B1.cen) - L2(B2.cen) - (r1 * r1 - r2 * r2)) /\n            (2. * dot(B1.cen - B2.cen, dir));\n  vec2 cen = k * dir;\n  float r = sqrt(L2XY(cen, B1.cen) - r1 * r1);\n  return from_sphere(cen, r);\n}\n\nfloat sdistanceToBall(vec2 p, Ball B) {\n  if (B.isplane) {\n    float k = dot(vec3(p, 1), vec3(B.cen, B.r));\n    return k;\n  } else {\n    float k = length(p - B.cen) - B.r;\n    return B.invert ? -k : k;\n  }\n}\n\nvoid initLevel2Graph(in float[6] diagram) {\n  Ball B0, B1, B2, B3;\n  float c01 = dihedral(diagram[0]);\n  float c02 = dihedral(diagram[1]);\n  float c03 = dihedral(diagram[2]);\n  float c12 = dihedral(diagram[3]);\n  float c13 = dihedral(diagram[4]);\n  float c23 = dihedral(diagram[5]);\n\n  cartan = mat4(1, -c01, -c02, -c03, -c01, 1, -c12, -c13, -c02, -c12, 1, -c23,\n                -c03, -c13, -c23, 1);\n  checkCartan(cartan);\n\n  float s23 = sqrt(1. - c23 * c23);\n\n  // The two virtual balls B2, B3 (reflection mirrors) are lines through the\n  // origin\n  B2 = from_plane(vec2(1, 0), 0.);\n  B3 = from_plane(vec2(-c23, s23), 0.);\n\n  // The mirror ball B1(x, y, r) satisfy\n  // Angle with B2: dot((x, y), (1, 0)) / r = c12\n  // Angle with B3: dot((x, y), (-c23, s23)) / r = c13\n  // Orthogonal to the real ball (unit ball) C0: x^2 + y^2 = r^2 + 1\n  float k1 = c12;\n  float k2 = (c13 + c23 * c12) / s23;\n  float r = 1. / sqrt(k1 * k1 + k2 * k2 - 1.);\n\n  B1 = from_sphere(vec2(k1 * r, k2 * r), r);\n\n  // The mirror ball B0(x, y, r) satisfy\n  // Angle with B2: dot((x, y), (1, 0)) / r = c02\n  // Angle with B3: dot((x, y), (-c23, s23)) / r = c03\n  // Angle with B1:\n  //\n  //        r^2 + r1^2 - |(x,y) - (x1,y1)|^2\n  //        --------------------------------  = -c01\n  //                   2 * r * r1\n  k1 = c02;\n  k2 = (c03 + c23 * c02) / s23;\n\n  float a = k1 * k1 + k2 * k2 - 1.;\n  float b = dot(vec3(k1, k2, c01), vec3(B1.cen, B1.r));\n  float c = L2(B1.cen) - B1.r * B1.r;\n\n  r = b / a - sqrt(b * b - a * c) / a;\n  B0 = from_sphere(vec2(k1 * r, k2 * r), r);\n\n  coclusters = Ball[4](B0, B1, B2, B3);\n\n  for (int k = 0; k < 4; k++) {\n    clusters[k] = defaultBall();\n  }\n\n  invertBall(clusters[0]);\n\n  if (vertexType.y == Hyperbolic) {\n    float r = sqrt(L2(B0.cen) - B0.r * B0.r);\n    clusters[1] = from_sphere(vec2(0), r);\n  }\n  if (vertexType.z == Hyperbolic) {\n    clusters[2] = solveBall(B0, B1, B3);\n  }\n  if (vertexType.w == Hyperbolic) {\n    clusters[3] = solveBall(B0, B1, B2);\n  }\n\n  if (vertexType.y == Euclidean) {\n    hasEuclideanVertex = true;\n    euclideanVertex = vec2(0);\n    return;\n  }\n\n  if (vertexType.z == Euclidean) {\n    hasEuclideanVertex = true;\n    euclideanVertex = getIntersection(B0, B1, B3);\n    return;\n  }\n\n  if (vertexType.w == Euclidean) {\n    hasEuclideanVertex = true;\n    euclideanVertex = getIntersection(B0, B1, B2);\n    return;\n  }\n}\n\nvec2 applyMobius(vec2 p) {\n  if (hasEuclideanVertex) {\n    vec2 A = euclideanVertex;\n    vec2 B = vec2(0, 0);\n    vec2 C = vec2(1, 0);\n    vec2 D = vec2(4, 0);\n    p = cdiv(cmul(p, A) + B, cmul(C, p) + D);\n  }\n  return p;\n}\n\nfloat distanceToMirrors(vec2 p) {\n  float d = abs(sdistanceToBall(p, coclusters[0]));\n\n  if (length(p) > 1.) {\n    p /= L2(p);\n    outside = true;\n  }\n\n  for (int k = 1; k < 4; k++) {\n    d = min(d, abs(sdistanceToBall(p, coclusters[k])));\n  }\n  return d;\n}\n\nvoid fold(inout vec2 p, inout int count, inout int index) {\n#ifdef moveVertexToInf\n  p = applyMobius(p);\n#endif\n  for (int i = 0; i < MAX_REFLECTIONS; i++) {\n    bool cond = true;\n    for (int k = 0; k < 4; k++) {\n      cond = try_reflect(p, coclusters[k], count) && cond;\n    }\n    if (cond)\n      break;\n  }\n  for (int k = 0; k < 4; k++) {\n    if (vertexType[k] == Hyperbolic &&\n        sdistanceToBall(p, clusters[k]) < -0.0001) {\n      index = k;\n      break;\n    }\n  }\n}\n\n// signed distance to unit ball and plane z=-1\nfloat sdSphere(vec3 p) { return length(p) - 1.0; }\nfloat sdPlane(vec3 p) { return p.z + 1.0; }\n\n// project points on the unit ball to plabe z=-1\nvec2 sphereToPlane(vec3 p) { return 2. * p.xy / (1. - p.z); }\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return p * cos(a) + vec2(-p.y, p.x) * sin(a); }\n\n// you can implement your color functions here\nvec3 colormap(int index, float t) {\n  float c = float(index) + 1.;\n  return .5 + .45 * cos(2. * PI * pow(t, 0.3) * ColorScale * c + vec3(0, 1, 2));\n}\n\nvec3 getcolor(inout vec2 p, out float ed) {\n  int index = -1;\n  int count = 0;\n  fold(p, count, index);\n  float dist = distanceToMirrors(p);\n  float t = clamp(float(count + 1) / float(MAX_REFLECTIONS), 0., 1.);\n  vec3 col = colormap(index, t);\n  float es = outside ? EdgeSize2 : EdgeSize1;\n  float aa = fwidth(dist) / 2.;\n  col = mix(col, vec3(0), 1. - smoothstep(es - aa, es + aa, dist));\n  return col;\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"wcXSW2","date":"0","viewed":0,"name":"旧 Boyd-Maxwell 备份","description":"Limit set of rank 4 hyperbolic Coxeter groups, drawn both on the boundary sphere and the stereo-projected plane.","likes":0,"published":"Private","usePreview":0,"tags":["coxeter","tiling","hyperbolic","circlepacking","limitset"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nBoyd-Maxwell circle packings of hyperbolic Coxeter groups: rank 4/level 2 case\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nFor more information check the github repo:\n\n    https://github.com/neozhaoliang/Hyperbolic-Honeycombs\n\nRequired input:\n\nThe Coxeter diagram of a rank 4 Coxeter group G = <A, B, C, D>, with dihedral\nangles m_{s,t} in the order (AB, AC, AD, BC, BD, CD).\n\nNote:\n\n1. CD must be finite\n2. The triangle group <B, C, D> must be hyperbolic\n\nIf you see only a sphere and a small disk under it, try comment out `#define\nuseMouseInvert` below.\n*/\n\n#define useMouseInvert\n\n#define shiny 5.\n\n//#define config      initLevel2Graph(float[6](4., 2., 7., 4., 2., 5.))\n//#define config      initLevel2Graph(float[6](3., 2., 2., 3., 2., 7.))\n//#define config      initLevel2Graph(float[6](3., 3., 2., 3., 2., 7.))\n//#define config      initLevel2Graph(float[6](4., 4., 4., 4., 4., 4.))\n//#define config      initLevel2Graph(float[6](2., 2., 7., inf, 3., 3.))\n//#define config      initLevel2Graph(float[6](3., 3., 2., 7., 2., 3.))\n#define config initLevel2Graph(float[6](5., 2., 3., 4., 3., 3.))\n\nvec2 map(vec3 p) {\n  float d1 = sdSphere(p);\n  float d2 = sdPlane(p);\n  float id = (d1 < d2) ? 0. : 1.;\n  return vec2(min(d1, d2), id);\n}\n\n// standard scene normal\nvec3 getNormal(vec3 p) {\n  const vec2 e = vec2(0.0001, 0.);\n  return normalize(vec3(map(p + e.xyy).x - map(p - e.xyy).x,\n                        map(p + e.yxy).x - map(p - e.yxy).x,\n                        map(p + e.yyx).x - map(p - e.yyx).x));\n}\n\n// get the signed distance to an object and object id\nvec2 raymarch(in vec3 ro, in vec3 rd) {\n  float t = MIN_TRACE_DIST;\n  vec2 h;\n  for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n    h = map(ro + t * rd);\n    if (h.x < PRECISION * (t * 0.125 + 1.))\n      return vec2(t, h.y);\n\n    if (t > MAX_TRACE_DIST)\n      break;\n\n    t += h.x;\n  }\n  return vec2(-1.0);\n}\n\nfloat calcOcclusion(vec3 p, vec3 n) {\n  float occ = 0.0;\n  float sca = 1.0;\n  for (int i = 0; i < 5; i++) {\n    float h = 0.01 + 0.15 * float(i) / 4.0;\n    float d = map(p + h * n).x;\n    occ += (h - d) * sca;\n    sca *= 0.85;\n  }\n  return clamp(1.0 - occ, 0.2, 1.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k) {\n  float res = 1.0;\n  float t = tmin;\n  for (int i = 0; i < 20; i++) {\n    float h = map(ro + rd * t).x;\n    res = min(res, k * h / t);\n    t += clamp(h, 0.001, 0.1);\n    if (h < 0.0001 || t > tmax)\n      break;\n  }\n  return clamp(res, 0., 1.0);\n}\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 pos, vec3 nor, vec3 lp, vec3 basecol) {\n  vec3 col = vec3(0.0);\n  vec3 ld = lp - pos;\n  float lDist = max(length(ld), .001);\n  ld /= lDist;\n  float ao = calcOcclusion(pos, nor);\n  float sh = softShadow(pos + 0.001 * nor, ld, 0.01, lDist, 8.);\n  float diff = clamp(dot(nor, ld), 0., 1.);\n  float atten = shiny / (1. + lDist * lDist * .001);\n  float spec = pow(max(dot(reflect(-ld, nor), -rd), 0.0), 6.);\n  float fres = clamp(1.0 + dot(rd, nor), 0.0, 1.0);\n  col += basecol * diff;\n  col += basecol * vec3(.8, 1., 0.3) * spec * 4.;\n  col += basecol * vec3(1.2, 1., .8) * fres * fres * 2.;\n  col *= ao * atten * sh;\n  col += basecol * clamp(0.8 + 0.2 * nor.z, 0., 1.);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec3 scenecol = vec3(0.);\n\n  // initialize the mirrors\n\n  config;\n\n  vec3 camera = vec3(4, 1.5, 4);\n  vec3 lp = vec3(.5, .5, 4.); // light position\n  camera.xy = rot2d(camera.xy, iTime * 0.3);\n  vec3 lookat = vec3(0.);\n  vec3 up = vec3(0, 0, 1);\n  vec3 forward = normalize(lookat - camera);\n  vec3 right = normalize(cross(forward, up));\n  up = normalize(cross(right, forward));\n\n  float lw = 8. / iResolution.y;\n\n  // antialiasing loop\n\n  for (int ii = 0; ii < AA; ii++) {\n    for (int jj = 0; jj < AA; jj++) {\n      vec2 o = vec2(float(ii), float(jj)) / float(AA);\n      vec2 uv = (2. * fragCoord + o - iResolution.xy) / iResolution.y;\n      vec3 rd = normalize(uv.x * right + uv.y * up + 1.5 * forward);\n      vec2 res = raymarch(camera, rd);\n      float t = res.x;\n      float id = res.y;\n      vec3 pos = camera + t * rd;\n\n      float ed;\n      vec3 col;\n      vec2 p0;\n      vec3 nor;\n\n      // the sphere is hit\n      if (id == 0.) {\n        nor = pos;\n        p0 = sphereToPlane(pos);\n      }\n\n      // the plane is hit\n      else if (id == 1.) {\n        nor = vec3(0, 0, 1);\n        p0 = pos.xy;\n      }\n#ifdef useMouseInvert\n      vec2 mouse = (iMouse.xy - 2. * iResolution.xy) / iResolution.y;\n      if (iMouse.z == 0.)\n        mouse = vec2(1.5, 1.5);\n      mouse = rot2d(mouse, iTime * 0.1);\n      float k = 1. / L2(mouse);\n      vec2 invCtr = k * mouse;\n      float tt = (k - 1.) / L2(p0 - invCtr);\n      p0 = tt * p0 + (1. - tt) * invCtr;\n#endif\n      vec3 basecol = getcolor(p0, ed);\n      col = getColor(camera, rd, pos, nor, lp, basecol);\n      col = mix(col, vec3(0.), 1.0 - exp(-0.01 * t * t));\n      scenecol += col;\n    }\n  }\n  scenecol /= (float(AA) * float(AA));\n\n  fragColor = vec4(sqrt(max(scenecol, 0.0)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Vinberg convention for edge labels\n#define inf 1.0\n#define MAX_REFLECTIONS 500\n#define AA 2\n#define PI 3.141592653\n#define L2(x) dot(x, x)\n#define L2XY(x, y) L2(x - y)\n#define Hyperbolic -1.0\n#define Euclidean 0.\n#define Spherical 1.\n#define MAX_TRACE_STEPS 500\n#define MIN_TRACE_DIST 0.001\n#define MAX_TRACE_DIST 100.0\n#define PRECISION 0.0001\n#define EdgeSize1 0.0035\n#define EdgeSize2 0.01\n#define ColorScale 0.8\n\n// Move a vertex of Euclidean type (if there is any) to infinity,\n// so the pattern tiles the entire plane\n#define moveVertexToInf\n\n// 4x4 Cartan matrix for the Coxeter group\nmat4 cartan;\n\n// geometry type of each vertex in the Coxeter diagram\n// -1 for hyerbolic, 0 for Euclidean, 1 for spherial\nvec4 vertexType = vec4(1);\n\n// coordinates of a Euclidean vertex\nvec2 euclideanVertex;\n\n// if we are outside of the unit circle\n// if a point lies outside of unit circle, the distance\n// estimation becomes inaccurate. We use EdgeSize2 to control the edge size for\n// this case.\nbool outside = false;\n\n// if there is an Euclidean vertex, i.e. if remove this vertex, the remain\n// diagram is affine\nbool hasEuclideanVertex;\n\n// compute cos(PI / x), for x = inf this is just inf\nfloat dihedral(float x) { return x == inf ? inf : cos(PI / x); }\n\n// complex multiplication\nvec2 cmul(vec2 p, vec2 q) {\n  return vec2(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);\n}\n\n// complex division\nvec2 cdiv(vec2 z, vec2 w) {\n  return vec2(z.x * w.x + z.y * w.y, -z.x * w.y + z.y * w.x) / dot(w, w);\n}\n\n// compute the vertex type of each vertex.\n// for each vertex in the Coxeter diagram, its vertex type is determined by the\n// triangle group G formed by the remaining three vertices. This vertex is of\n// hyperbolic/spherical/euclidean iff G is hyperbolic/spherical/euclidean,\n// respectively. This can be checked from the determinant of the leading minors\n// of the Cartan matrix.\nvoid checkCartan(mat4 M) {\n  const float e = 0.001;\n  float det;\n  det = determinant(mat3(M[1].yzw, M[2].yzw, M[3].yzw));\n  vertexType.x = step(-e, det) + step(e, det) - 1.;\n\n  det = determinant(mat3(M[0].xzw, M[2].xzw, M[3].xzw));\n  vertexType.y = step(-e, det) + step(e, det) - 1.;\n\n  det = determinant(mat3(M[0].xyw, M[1].xyw, M[3].xyw));\n  vertexType.z = step(-e, det) + step(e, det) - 1.;\n\n  det = determinant(mat3(M[0].xyz, M[1].xyz, M[2].xyz));\n  vertexType.w = step(-e, det) + step(e, det) - 1.;\n}\n\n// For spheres cen is the center, r is the radius\n// For planes cen is the normal vector, r is the offset from the origin along\n// the normal. if invert is true then the inside/outside of the sphere is\n// exchanged.\nstruct Ball {\n  vec2 cen;\n  float r;\n  bool isplane;\n  bool invert;\n};\n\n// coclusters are mirror balls, they corresponde to root vectors (space-like)\nBall[4] coclusters;\n// clusters are real balls, they corresponde to space-like weight vectors\nBall[4] clusters;\n\n// create a default ball (unit circle)\nBall defaultBall() { return Ball(vec2(0), 1., false, false); }\n\nBall from_plane(vec2 normal, float offset) {\n  return Ball(normal, offset, true, false);\n}\n\nBall from_sphere(vec2 cen, float r) { return Ball(cen, r, false, false); }\n\nvoid invertBall(inout Ball B) { B.invert = !B.invert; }\n\n// try to reflect a point p to the positive half space bounded by a ball\n// if we are already in the positive half space, do nothing and return true,\n// else reflect about the ball and return false\n// if B is a sphere we try to reflect p into the interior of B\nbool try_reflect(inout vec2 p, Ball B, inout int count) {\n  vec2 cen = B.cen;\n  float r = B.r;\n  if (B.isplane) {\n    float k = dot(vec3(p, 1), vec3(cen, r));\n    if (k >= 0.)\n      return true;\n    p -= 2. * k * cen;\n    count += 1;\n    return false;\n  } else {\n    vec2 q = p - cen;\n    float d2 = dot(q, q);\n    float k = (r * r) / d2;\n    if (k < 1.0)\n      return true;\n    p = k * q + cen;\n    count += 1;\n    return false;\n  }\n}\n\nvec2 getIntersection(Ball B1, Ball B2, Ball B3) {\n  vec2 dir = vec2(-B3.cen.y, B3.cen.x);\n  float r1 = B1.r, r2 = B2.r;\n  float k = (L2(B1.cen) - L2(B2.cen) - (r1 * r1 - r2 * r2)) /\n            (2. * dot(B1.cen - B2.cen, dir));\n  return k * dir;\n}\n\nBall solveBall(Ball B1, Ball B2, Ball B3) {\n  vec2 dir = vec2(-B3.cen.y, B3.cen.x);\n  float r1 = B1.r, r2 = B2.r;\n  float k = (L2(B1.cen) - L2(B2.cen) - (r1 * r1 - r2 * r2)) /\n            (2. * dot(B1.cen - B2.cen, dir));\n  vec2 cen = k * dir;\n  float r = sqrt(L2XY(cen, B1.cen) - r1 * r1);\n  return from_sphere(cen, r);\n}\n\nfloat sdistanceToBall(vec2 p, Ball B) {\n  if (B.isplane) {\n    float k = dot(vec3(p, 1), vec3(B.cen, B.r));\n    return k;\n  } else {\n    float k = length(p - B.cen) - B.r;\n    return B.invert ? -k : k;\n  }\n}\n\nvoid initLevel2Graph(in float[6] diagram) {\n  Ball B0, B1, B2, B3;\n  float c01 = dihedral(diagram[0]);\n  float c02 = dihedral(diagram[1]);\n  float c03 = dihedral(diagram[2]);\n  float c12 = dihedral(diagram[3]);\n  float c13 = dihedral(diagram[4]);\n  float c23 = dihedral(diagram[5]);\n\n  cartan = mat4(1, -c01, -c02, -c03, -c01, 1, -c12, -c13, -c02, -c12, 1, -c23,\n                -c03, -c13, -c23, 1);\n  checkCartan(cartan);\n\n  float s23 = sqrt(1. - c23 * c23);\n\n  // The two virtual balls B2, B3 (reflection mirrors) are lines through the\n  // origin\n  B2 = from_plane(vec2(1, 0), 0.);\n  B3 = from_plane(vec2(-c23, s23), 0.);\n\n  // The mirror ball B1(x, y, r) satisfy\n  // Angle with B2: dot((x, y), (1, 0)) / r = c12\n  // Angle with B3: dot((x, y), (-c23, s23)) / r = c13\n  // Orthogonal to the real ball (unit ball) C0: x^2 + y^2 = r^2 + 1\n  float k1 = c12;\n  float k2 = (c13 + c23 * c12) / s23;\n  float r = 1. / sqrt(k1 * k1 + k2 * k2 - 1.);\n\n  B1 = from_sphere(vec2(k1 * r, k2 * r), r);\n\n  // The mirror ball B0(x, y, r) satisfy\n  // Angle with B2: dot((x, y), (1, 0)) / r = c02\n  // Angle with B3: dot((x, y), (-c23, s23)) / r = c03\n  // Angle with B1:\n  //\n  //        r^2 + r1^2 - |(x,y) - (x1,y1)|^2\n  //        --------------------------------  = -c01\n  //                   2 * r * r1\n  k1 = c02;\n  k2 = (c03 + c23 * c02) / s23;\n\n  float a = k1 * k1 + k2 * k2 - 1.;\n  float b = dot(vec3(k1, k2, c01), vec3(B1.cen, B1.r));\n  float c = L2(B1.cen) - B1.r * B1.r;\n\n  r = b / a - sqrt(b * b - a * c) / a;\n  B0 = from_sphere(vec2(k1 * r, k2 * r), r);\n\n  coclusters = Ball[4](B0, B1, B2, B3);\n\n  for (int k = 0; k < 4; k++) {\n    clusters[k] = defaultBall();\n  }\n\n  invertBall(clusters[0]);\n\n  if (vertexType.y == Hyperbolic) {\n    float r = sqrt(L2(B0.cen) - B0.r * B0.r);\n    clusters[1] = from_sphere(vec2(0), r);\n  }\n  if (vertexType.z == Hyperbolic) {\n    clusters[2] = solveBall(B0, B1, B3);\n  }\n  if (vertexType.w == Hyperbolic) {\n    clusters[3] = solveBall(B0, B1, B2);\n  }\n\n  if (vertexType.y == Euclidean) {\n    hasEuclideanVertex = true;\n    euclideanVertex = vec2(0);\n    return;\n  }\n\n  if (vertexType.z == Euclidean) {\n    hasEuclideanVertex = true;\n    euclideanVertex = getIntersection(B0, B1, B3);\n    return;\n  }\n\n  if (vertexType.w == Euclidean) {\n    hasEuclideanVertex = true;\n    euclideanVertex = getIntersection(B0, B1, B2);\n    return;\n  }\n}\n\nvec2 applyMobius(vec2 p) {\n  if (hasEuclideanVertex) {\n    vec2 A = euclideanVertex;\n    vec2 B = vec2(0, 0);\n    vec2 C = vec2(1, 0);\n    vec2 D = vec2(4, 0);\n    p = cdiv(cmul(p, A) + B, cmul(C, p) + D);\n  }\n  return p;\n}\n\nfloat distanceToMirrors(vec2 p) {\n  float d = abs(sdistanceToBall(p, coclusters[0]));\n\n  if (length(p) > 1.) {\n    p /= L2(p);\n    outside = true;\n  }\n\n  for (int k = 1; k < 4; k++) {\n    d = min(d, abs(sdistanceToBall(p, coclusters[k])));\n  }\n  return d;\n}\n\nvoid fold(inout vec2 p, inout int count, inout int index) {\n#ifdef moveVertexToInf\n  p = applyMobius(p);\n#endif\n  for (int i = 0; i < MAX_REFLECTIONS; i++) {\n    bool cond = true;\n    for (int k = 0; k < 4; k++) {\n      cond = try_reflect(p, coclusters[k], count) && cond;\n    }\n    if (cond)\n      break;\n  }\n  for (int k = 0; k < 4; k++) {\n    if (vertexType[k] == Hyperbolic &&\n        sdistanceToBall(p, clusters[k]) < -0.0001) {\n      index = k;\n      break;\n    }\n  }\n}\n\n// signed distance to unit ball and plane z=-1\nfloat sdSphere(vec3 p) { return length(p) - 1.0; }\nfloat sdPlane(vec3 p) { return p.z + 1.0; }\n\n// project points on the unit ball to plabe z=-1\nvec2 sphereToPlane(vec3 p) { return 2. * p.xy / (1. - p.z); }\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return p * cos(a) + vec2(-p.y, p.x) * sin(a); }\n\n// you can implement your color functions here\nvec3 colormap(int index, float t) {\n  float c = float(index) + 1.;\n  return .5 + .45 * cos(2. * PI * pow(t, 0.3) * ColorScale * c + vec3(0, 1, 2));\n}\n\nvec3 getcolor(inout vec2 p, out float ed) {\n  int index = -1;\n  int count = 0;\n  fold(p, count, index);\n  float dist = distanceToMirrors(p);\n  float t = clamp(float(count + 1) / float(MAX_REFLECTIONS), 0., 1.);\n  vec3 col = colormap(index, t);\n  float es = outside ? EdgeSize2 : EdgeSize1;\n  float aa = fwidth(dist) / 2.;\n  col = mix(col, vec3(0), 1. - smoothstep(es - aa, es + aa, dist));\n  return col;\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"33V3RR","date":"1751983423","viewed":1122,"name":"Three body periodic solutions","description":"A few periodic solutions to the 3 body problem","likes":34,"published":"Public API","usePreview":0,"tags":["2d","simulation","threebody"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\nPeriodic solutions of the three body problem (equal mass)\n\nUse adaptive RK45 with a fixed number of max iterations\n\n*/\n\n#define get(n, i) texelFetch(iChannel0, ivec2(i, n), 0).xy\n\nconst vec3 col[3] = vec3[3](\n    vec3(0.1, 0.9, 0.1),\n    vec3(0.9, 0.05, 0.05),\n    vec3(0.02, 0.02, 0.8));\nconst vec3 weights = vec3(0.299, 0.587, 0.114);\n\nconst float lum[3] = float[3](dot(col[0], weights),\n                              dot(col[1], weights),\n                              dot(col[2], weights));\n\nconst float scales[6] = float[6](2.1, 2.8, 3.4, 2.0, 1.7, 1.9);\n\nconst float fade = 0.025;\nconst float trail_strength = 0.008;\nconst float particle_strength = 0.04;\n\nvec3 glowPoint(vec2 p, vec2 center, vec3 col, float lum, float strength) {\n    float d = max(abs(length(p - center)), 1e-5);\n    d = pow(strength / d, 2.);\n    d /= lum;\n    return 1.0 - exp(-d * col);\n}\n\nvec2 sdSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float d = length(pa - ba * h);\n    d = max(abs(d), 1e-5);\n    return vec2(d, h);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    ivec2 grid = ivec2(3, 2);\n    ivec2 cell = ivec2(uv * vec2(grid));\n    int simIndex = cell.y * grid.x + cell.x;\n\n    vec2 cellCenter = (vec2(cell) + 0.5) / vec2(grid);\n    vec2 shift = vec2(0);\n\n    vec2 localUV = (uv - cellCenter) * vec2(grid);\n    float aspect =\n        (iResolution.x / float(grid.x)) / (iResolution.y / float(grid.y));\n    localUV.x *= aspect;\n\n    float zoom = scales[simIndex];\n    localUV *= zoom;\n\n    if (simIndex == 4)\n        shift = vec2(-0.15, 0.1);\n    else if (simIndex == 5)\n        shift = vec2(0.1, -0.1);\n    localUV -= shift;\n\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < min(iFrame, NTRAIL - 2); i++) {\n        for (int j = 0; j < 3; j++) {\n            int idx = simIndex * 3 + j;\n            vec2 a = get(idx, i);\n            vec2 b = get(idx, i + 1);\n            vec2 seg = sdSegment(localUV, a, b);\n            float fade_factor = (seg.y + float(i)) / float(NTRAIL);\n            float d = pow(trail_strength / (seg.x + fade * fade_factor), 4.0) /\n                      lum[j];\n            color += 1.0 - exp(-col[j] * d);\n        }\n    }\n\n    for (int j = 0; j < 3; j++) {\n        int idx = simIndex * 3 + j;\n        vec2 end = get(idx, 0);\n        color += glowPoint(localUV, end, col[j], lum[j], particle_strength);\n    }\n\n    fragColor =\n        vec4(pow(clamp(color, 0.0, 1.0), vec3(0.4545)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec2 accel(vec2 pi, vec2 pj) {\n    vec2 r = pj - pi;\n    float k = dot(r, r);\n    float invDist3 = inversesqrt(k * k * k);\n    return G * r * invDist3;\n}\n\nvec2[3] acceleration(vec2[3] positions) {\n    vec2 a[3];\n    a[0] =\n        accel(positions[0], positions[1]) + accel(positions[0], positions[2]);\n    a[1] =\n        accel(positions[1], positions[0]) + accel(positions[1], positions[2]);\n    a[2] =\n        accel(positions[2], positions[0]) + accel(positions[2], positions[1]);\n    return a;\n}\n\n\nvoid RK4(inout vec2[3] p, inout vec2[3] v) {\n    const float dt = 0.01;\n    vec2[3] k1v = acceleration(p);\n    vec2[3] k1p = v;\n\n    vec2[3] p2, v2;\n    for (int i = 0; i < 3; i++) {\n        p2[i] = p[i] + 0.5 * dt * k1p[i];\n        v2[i] = v[i] + 0.5 * dt * k1v[i];\n    }\n    vec2[3] k2v = acceleration(p2), k2p = v2;\n\n    vec2[3] p3, v3;\n    for (int i = 0; i < 3; i++) {\n        p3[i] = p[i] + 0.5 * dt * k2p[i];\n        v3[i] = v[i] + 0.5 * dt * k2v[i];\n    }\n    vec2[3] k3v = acceleration(p3), k3p = v3;\n\n    vec2[3] p4, v4;\n    for (int i = 0; i < 3; i++) {\n        p4[i] = p[i] + dt * k3p[i];\n        v4[i] = v[i] + dt * k3v[i];\n    }\n    vec2[3] k4v = acceleration(p4), k4p = v4;\n\n    for (int i = 0; i < 3; i++) {\n        p[i] += dt * (k1p[i] + 2. * k2p[i] + 2. * k3p[i] + k4p[i]) / 6.0;\n        v[i] += dt * (k1v[i] + 2. * k2v[i] + 2. * k3v[i] + k4v[i]) / 6.0;\n    }\n}\n\n\n// suggested by @rreusser and code taken from his notebook\n// https://observablehq.com/@rreusser/magnetic-pendulum#drawField\nvoid RK45(inout vec2[3] p, inout vec2[3] v, inout float dt) {\n    const float safety = 0.95;\n    const float maxDecrease = 0.2;\n    const float maxIncrease = 5.0;\n    const float tol2 = 1e-8;\n\n    vec2[3] k1p = v;\n    vec2[3] k1v = acceleration(p);\n\n    vec2[3] p2, v2;\n    for (int i = 0; i < 3; i++) {\n        p2[i] = p[i] + dt * 0.2 * k1p[i];\n        v2[i] = v[i] + dt * 0.2 * k1v[i];\n    }\n    vec2[3] k2p = v2, k2v = acceleration(p2);\n\n    vec2[3] p3, v3;\n    for (int i = 0; i < 3; i++) {\n        p3[i] = p[i] + dt * (0.075 * k1p[i] + 0.225 * k2p[i]);\n        v3[i] = v[i] + dt * (0.075 * k1v[i] + 0.225 * k2v[i]);\n    }\n    vec2[3] k3p = v3, k3v = acceleration(p3);\n\n    vec2[3] p4, v4;\n    for (int i = 0; i < 3; i++) {\n        p4[i] = p[i] + dt * (0.3 * k1p[i] - 0.9 * k2p[i] + 1.2 * k3p[i]);\n        v4[i] = v[i] + dt * (0.3 * k1v[i] - 0.9 * k2v[i] + 1.2 * k3v[i]);\n    }\n    vec2[3] k4p = v4, k4v = acceleration(p4);\n\n    vec2[3] p5, v5;\n    for (int i = 0; i < 3; i++) {\n        p5[i] = p[i] + dt * (-0.2037037 * k1p[i] + 2.5 * k2p[i] - 2.5925926 * k3p[i] + 1.2962963 * k4p[i]);\n        v5[i] = v[i] + dt * (-0.2037037 * k1v[i] + 2.5 * k2v[i] - 2.5925926 * k3v[i] + 1.2962963 * k4v[i]);\n    }\n    vec2[3] k5p = v5, k5v = acceleration(p5);\n\n    vec2[3] p6, v6;\n    for (int i = 0; i < 3; i++) {\n        p6[i] = p[i] + dt * (0.0294958 * k1p[i] + 0.3417969 * k2p[i] + 0.0415943 * k3p[i] + 0.4003454 * k4p[i] + 0.0617676 * k5p[i]);\n        v6[i] = v[i] + dt * (0.0294958 * k1v[i] + 0.3417969 * k2v[i] + 0.0415943 * k3v[i] + 0.4003454 * k4v[i] + 0.0617676 * k5v[i]);\n    }\n    vec2[3] k6p = v6, k6v = acceleration(p6);\n    float err2 = 0.0;\n    for (int i = 0; i < 3; i++) {\n        vec2 err = dt * (\n            0.00429377 * k1p[i]\n            - 0.0186686 * k3p[i]\n            + 0.0341550 * k4p[i]\n            + 0.0193220 * k5p[i]\n            - 0.0391022 * k6p[i]\n        );\n        err2 += dot(err, err);\n    }\n\n    bool accept = err2 <= tol2;\n\n    if (accept) {\n        for (int i = 0; i < 3; i++) {\n            p[i] += dt * (0.0978836 * k1p[i] + 0.4025765 * k3p[i] + 0.2104377 * k4p[i] + 0.2891022 * k6p[i]);\n            v[i] += dt * (0.0978836 * k1v[i] + 0.4025765 * k3v[i] + 0.2104377 * k4v[i] + 0.2891022 * k6v[i]);\n        }\n    }\n    float scale = clamp(safety * pow(tol2 / (err2 + 1e-12), accept ? 0.125 : 0.1), maxDecrease, maxIncrease);\n    dt *= scale;\n}\n\n\nvoid adaptiveRK45(inout vec2[3] p, inout vec2[3] v) {\n    float t = 0.0;\n    float totalDt = 0.01;\n    float dt = totalDt / float(MaxIterEachStep);\n\n    for (int i = 0; i < MaxIterEachStep; i++) {\n        if (t + dt > totalDt) {\n            dt = totalDt - t;\n        }\n\n        vec2[3] pTemp = p;\n        vec2[3] vTemp = v;\n        float dtTemp = dt;\n\n        RK45(pTemp, vTemp, dtTemp);\n\n        if (dtTemp >= dt * 0.99) {\n            p = pTemp;\n            v = vTemp;\n            t += dt;\n        }\n\n        dt = dtTemp;\n\n        if (t >= totalDt - 1e-6) break;\n    }\n}\n\n\nvoid initState(int idx, out vec2[3] p, out vec2[3] v) {\n    if (idx == 0) {\n        p = vec2[3](vec2(-1, 0), vec2(1, 0), vec2(0, 0));\n        v = vec2[3](vec2(0.347111, 0.532728), vec2(0.347111, 0.532728),\n                    vec2(-2. * 0.347111, -2. * 0.532728));\n    } else if (idx == 1) {\n        p = vec2[3](vec2(0.2843198916, 0), vec2(0.8736097872, 0),\n                    vec2(-1.1579296788, 0));\n        v = vec2[3](vec2(0, 1.3774179570), vec2(0, -0.4884226932),\n                    vec2(0, -0.8889952638));\n    } else if (idx == 2) {\n        p = vec2[3](vec2(0.0132604844, 0), vec2(1.4157286016, 0),\n                    vec2(-1.4289890859, 0));\n        v = vec2[3](vec2(0, 1.054151921), vec2(0, -0.2101466639),\n                    vec2(0, -0.8440052572));\n\n    } else if (idx == 3) {\n        p = vec2[3](vec2(0.8733047091, 0), vec2(-0.6254030288, 0),\n                    vec2(-0.2479016803, 0));\n        v = vec2[3](vec2(0, 1.0107764436), vec2(0, -1.6833533458),\n                    vec2(0, 0.6725769022));\n\n    } else if (idx == 4) {\n        p = vec2[3](vec2(0.6661637520772179, -0.081921852656887),\n                    vec2(-0.025192663684493022, 0.45444857588251897),\n                    vec2(-0.10301329374224, -0.765806200083609));\n        v = vec2[3](vec2(0.84120297540307, 0.029746212757039),\n                    vec2(0.142642469612081, -0.492315648524683),\n                    vec2(-0.98384544501151, 0.462569435774018));\n    } else if (idx == 5) {\n\n        p = vec2[3](vec2(0.486657678894505, 0.755041888583519),\n                    vec2(-0.681737994414464, 0.29366023319721),\n                    vec2(-0.02259632746864, -0.612645601255358));\n        v = vec2[3](vec2(-0.182709864466916, 0.363013287999004),\n                    vec2(-0.579074922540872, -0.748157481446087),\n                    vec2(0.761784787007641, 0.385144193447218));\n    } else {\n        p = vec2[3](vec2(0.5, 0), vec2(-0.5, 0), vec2(0, 0));\n        v = vec2[3](vec2(0, 0.3), vec2(0, 0.3), vec2(0, -0.6));\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 uv = ivec2(fragCoord);\n    int objIdx = uv.y / 3;\n    int localIdx = uv.y % 3;\n\n    vec2[3] p, v;\n\n    if (uv.x == 0 && uv.y < 18) {\n        if (iFrame == 0) {\n            initState(objIdx, p, v);\n        } else {\n            for (int i = 0; i < 3; i++) {\n                vec4 data = texelFetch(iChannel0, ivec2(0, objIdx * 3 + i), 0);\n                p[i] = data.xy;\n                v[i] = data.zw;\n            }\n            #ifdef USE_ADAPTIVE_RK45\n                adaptiveRK45(p, v);\n            #else\n                RK4(p,v);\n            #endif\n        }\n        fragColor = vec4(p[localIdx], v[localIdx]);\n    } else if (uv.x > 0 && uv.x < NTRAIL && uv.y < 18) {\n        vec4 prev = texelFetch(iChannel0, ivec2(uv.x - 1, uv.y), 0);\n        fragColor = vec4(prev.xy, 0.0, 1.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define USE_ADAPTIVE_RK45\n\n#define NTRAIL           300\n#define G                1.0\n#define MaxIterEachStep  40","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"33KGWV","date":"0","viewed":0,"name":"test spehre","description":"test","likes":0,"published":"Private","usePreview":0,"tags":["3d"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n\n// --- SDF（有向距离函数）定义 ---\n\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\nfloat sdPlane(vec3 p) { return p.z; }\n\n// --- 场景构建 ---\n// map函数返回最近物体的距离和ID (1.0: Sphere, 2.0: Plane)\nvec2 map(vec3 p) {\n    float sphereDist = sdSphere(p, 1.0);\n    float planeDist = sdPlane(p);\n    \n    if (sphereDist < planeDist) {\n        return vec2(sphereDist, 1.0);\n    } else {\n        return vec2(planeDist, 2.0);\n    }\n}\n\n// --- 核心算法 ---\n\n// Raymarching (光线步进)\nvec2 raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + t * rd;\n        vec2 res = map(p);\n        if (res.x < SURF_DIST) return vec2(t, res.y);\n        t += res.x;\n        if (t > MAX_DIST) break;\n    }\n    return vec2(MAX_DIST, 0.0);\n}\n\n// 计算表面法线\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    float d = map(p).x;\n    vec3 n = d - vec3(map(p - e.xyy).x, map(p - e.yxy).x, map(p - e.yyx).x);\n    return normalize(n);\n}\n\n// 计算软阴影\nfloat getSoftShadow(vec3 ro, vec3 rd, float k) {\n    float res = 1.0;\n    float t = 0.01;\n    for (int i = 0; i < 50; i++) {\n        float h = map(ro + rd * t).x;\n        if (h < SURF_DIST) return 0.0;\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// 计算环境光遮蔽 (AO)\nfloat getAO(vec3 p, vec3 nor) {\n    float occ = 0.0, sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = p + nor * hr;\n        float dd = map(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.75;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\n// --- 渲染与着色 ---\n\n// 封装一个函数来单独渲染平面，方便复用\nvec3 shadePlane(vec3 p, vec3 normal, vec3 lightDir, float ao, float shadow) {\n    // 棋盘格纹理\n    vec2 uv = p.xy * 2.0;\n    float c = mod(floor(uv.x) + floor(uv.y), 2.0);\n    vec3 baseColor = vec3(0.4 + c * 0.1);\n    \n    // 漫反射\n    float diffuse = max(0.0, dot(normal, lightDir));\n    \n    // 组合光照\n    return baseColor * (diffuse * 0.6 + 0.4) * shadow * ao;\n}\n\n\n// 主渲染函数\nvec3 render(vec3 ro, vec3 rd) {\n    // 1. 第一次光线步进\n    vec2 hit1 = raymarch(ro, rd);\n    float t1 = hit1.x;\n    float materialID1 = hit1.y;\n\n    // 如果未命中任何物体，返回背景色\n    if (t1 > MAX_DIST - 1.0) return vec3(0.1, 0.1, 0.2);\n\n    // 2. 计算第一个交点的信息\n    vec3 p1 = ro + t1 * rd;\n    vec3 n1 = getNormal(p1);\n    \n    // 3. 设置光照\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 lightPos = vec3(4.0 * (mouse.x - 0.5) * 2.0, 2.0 * mouse.y * 2.0, 4.0);\n    if(iMouse.z <= 0.0) lightPos = vec3(2.0, 3.0, 4.0);\n    vec3 lightDir = normalize(lightPos - p1);\n    \n    // 计算光照效果\n    float ao = getAO(p1, n1);\n    float shadow = getSoftShadow(p1, lightDir, 16.0);\n\n    // 4. 根据材质ID进行着色\n    vec3 finalColor = vec3(0.0);\n\n    if (materialID1 == 2.0) { // 如果直接击中了平面\n        finalColor = shadePlane(p1, n1, lightDir, ao, shadow);\n    } \n    else if (materialID1 == 1.0) { // 如果击中了球体 (核心透明逻辑)\n        \n        // a. 计算球体表面的颜色贡献 (漫反射+高光)\n        vec3 sphereBaseColor = vec3(0.2, 0.5, 0.9); // 蓝色\n        float diffuse = max(0.0, dot(n1, lightDir));\n        \n        vec3 viewDir = -rd;\n        vec3 halfVec = normalize(lightDir + viewDir);\n        float spec = pow(max(0.0, dot(n1, halfVec)), 64.0);\n        \n        vec3 sphereSurfaceColor = (sphereBaseColor * diffuse + vec3(1.0) * spec) * shadow * ao;\n        \n        // b. 计算透过球体看到的背景颜色\n        // 从第一个交点p1处继续步进\n        vec3 ro2 = p1 + rd * SURF_DIST * 2.0; // 将起点向前推一点，防止自交\n        vec2 hit2 = raymarch(ro2, rd);\n        \n        vec3 backgroundColor;\n        if(hit2.x < MAX_DIST - 1.0) {\n            // 如果击中了后面的物体（平面）\n            vec3 p2 = ro2 + hit2.x * rd;\n            vec3 n2 = getNormal(p2);\n            vec3 lightDir2 = normalize(lightPos-p2);\n            float ao2 = getAO(p2, n2);\n            // 注意：这里的阴影计算应该从p2点开始，但为了性能可以简化\n            float shadow2 = getSoftShadow(p2, lightDir2, 16.0);\n            backgroundColor = shadePlane(p2, n2, lightDir2, ao2, shadow2);\n        } else {\n            // 如果后面没有物体，则看到的是天空背景色\n            backgroundColor = vec3(0.1, 0.1, 0.2);\n        }\n\n        // c. 根据菲涅尔效应混合前景和背景\n        // 菲涅尔效应：视线与法线越垂直，反射/不透明度越高\n        float fresnel = pow(1.0 + dot(rd, n1), 4.0);\n        \n        // 定义基础不透明度，并用菲涅尔效应进行调制\n        float baseOpacity = 0.2;\n        float finalOpacity = baseOpacity + (1.0 - baseOpacity) * fresnel;\n        finalOpacity = clamp(finalOpacity, 0.0, 1.0);\n        \n        // 使用mix函数混合\n        // mix(background, foreground, alpha) = background * (1-alpha) + foreground * alpha\n        finalColor = mix(backgroundColor, sphereSurfaceColor, finalOpacity);\n    }\n    \n    return finalColor;\n}\n\n// --- 主函数 ---\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 2.5, 3.5); // 摄像机位置\n    vec3 lookAt = vec3(0.0, 0.0, 0.0); // 观察目标\n    \n    vec3 fwd = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 0.0, 1.0), fwd));\n    vec3 up = cross(fwd, right);\n    \n    vec3 rd = normalize(fwd + uv.x * right + uv.y * up);\n\n    vec3 col = render(ro, rd);\n    \n    col = pow(col, vec3(0.4545)); // Gamma校正\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*#define MAX_STEPS 100         // 最大步进次数\n#define MAX_DIST 100.0        // 最大渲染距离\n#define SURF_DIST 0.001       // 表面命中阈值\n\n// --- SDF（有向距离函数）定义 ---\n\n// 单位球的SDF\n// p: 采样点, r: 半径\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n// XY平面的SDF\n// p: 采样点\nfloat sdPlane(vec3 p) {\n    return p.z;\n}\n\n// --- 场景构建 ---\n\n// map函数返回到场景中最近物体的距离和其材质ID\n// 返回值: vec2(距离, 材质ID)，1.0代表球体，2.0代表平面\nvec2 map(vec3 p) {\n    // 物体1: 半径为1的单位球\n    float sphereDist = sdSphere(p, 1.0);\n    \n    // 物体2: 球体内部的XY平面部分\n    // 这里使用了CSG（构造实体几何）的交集操作(max)\n    // max(sdPlane(p), -sdSphere(p, 1.0)) 表示平面和球体内部空间的交集\n    // 1.0 - length(p) 是球体内部的距离场\n    float planeInSphereDist = max(sdPlane(p), 1.0 - length(p));\n    \n    // 使用min操作将两个物体组合（并集）\n    if (sphereDist < planeInSphereDist) {\n        return vec2(sphereDist, 1.0); // 命中了球体表面\n    } else {\n        return vec2(planeInSphereDist, 2.0); // 命中了球体内部的平面\n    }\n}\n\n// --- 核心算法 ---\n\n// Raymarching (光线步进)\n// ro: 光线原点, rd: 光线方向\n// 返回值: 光线行进的距离t\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + t * rd;\n        float dist = map(p).x;\n        if (dist < SURF_DIST) {\n            return t;\n        }\n        t += dist;\n        if (t > MAX_DIST) {\n            break;\n        }\n    }\n    return MAX_DIST;\n}\n\n// 计算表面法线\n// p: 表面上的点\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.001, 0.0);\n    float d = map(p).x;\n    // 使用四面体差分法计算梯度，以获得更精确的法线\n    vec3 n = d - vec3(\n        map(p - e.xyy).x,\n        map(p - e.yxy).x,\n        map(p - e.yyx).x);\n    return normalize(n);\n}\n\n// 计算软阴影\n// ro: 阴影光线的起点, rd: 指向光源的方向, k: 阴影柔和度\nfloat getSoftShadow(vec3 ro, vec3 rd, float k) {\n    float res = 1.0;\n    float t = 0.01; // 从一个小的偏移开始，防止自阴影\n    for (int i = 0; i < 50; i++) {\n        float h = map(ro + rd * t).x;\n        if (h < SURF_DIST) {\n            return 0.0;\n        }\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// 计算环境光遮蔽 (AO)\n// p: 表面上的点, nor: 表面法线\nfloat getAO(vec3 p, vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = p + nor * hr;\n        float dd = map(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.75;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\n// --- 渲染与着色 ---\n\n// 主渲染函数\n// ro: 摄像机位置, rd: 视线方向\nvec3 render(vec3 ro, vec3 rd) {\n    // 1. 光线步进找到交点\n    float t = raymarch(ro, rd);\n    \n    // 如果没有命中，返回背景色\n    if (t > MAX_DIST - 1.0) {\n        return vec3(0.1, 0.1, 0.2); // 深蓝色背景\n    }\n    \n    // 2. 计算命中点、法线和材质信息\n    vec3 p = ro + t * rd;\n    vec3 normal = getNormal(p);\n    vec2 hitInfo = map(p);\n    float materialID = hitInfo.y;\n\n    // 3. 设置光照\n    // 让光源位置可以被鼠标控制\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 lightPos = vec3(4.0 * (mouse.x - 0.5), 2.0 * mouse.y, 4.0);\n    if (iMouse.z <= 0.0) { // 如果没有鼠标输入，使用默认位置\n        lightPos = vec3(2.0, 3.0, 4.0);\n    }\n    vec3 lightDir = normalize(lightPos - p);\n\n    // 4. 计算光照效果\n    float ao = getAO(p, normal);\n    float shadow = getSoftShadow(p, lightDir, 16.0);\n    \n    // 5. 根据材质ID进行着色\n    vec3 materialColor = vec3(1.0);\n    \n    if (materialID == 1.0) { // 球体材质\n        vec3 baseColor = vec3(0.2, 0.5, 0.9); // 蓝色基色\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // Blinn-Phong 高光\n        vec3 viewDir = -rd;\n        vec3 halfVec = normalize(lightDir + viewDir);\n        float spec = pow(max(0.0, dot(normal, halfVec)), 64.0);\n        vec3 specularColor = vec3(1.0);\n        \n        // Fresnel 菲涅尔效应\n        float fresnel = pow(1.0 + dot(rd, normal), 5.0);\n        fresnel = clamp(fresnel, 0.0, 1.0);\n        \n        // 组合光照和颜色\n        vec3 lighting = (diffuse * vec3(1.0) + specularColor * spec) * shadow * ao;\n        materialColor = baseColor * lighting;\n        \n        // 应用菲涅尔效应，边缘部分更像反射\n        materialColor = mix(materialColor, vec3(1.0) * ao * shadow, fresnel);\n    } \n    else { // 平面材质\n        // 使用棋盘格纹理\n        vec2 uv = p.xy * 2.0;\n        float c = mod(floor(uv.x) + floor(uv.y), 2.0);\n        vec3 baseColor = vec3(0.4 + c * 0.1);\n        float diffuse = max(0.0, dot(normal, lightDir));\n        \n        // 组合光照和颜色\n        materialColor = baseColor * (diffuse * 0.6 + 0.4) * shadow * ao;\n    }\n    \n    return materialColor;\n}\n\n// --- 主函数 ---\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // 1. 设置UV坐标\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    // 2. 设置摄像机\n    vec3 ro = vec3(0.0, 1.5, 3.5); // 摄像机位置 (Ray Origin)\n    vec3 lookAt = vec3(0.0, 0.0, 0.0); // 观察目标\n    \n    // 摄像机矩阵\n    vec3 fwd = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 0.0, 1.0), fwd));\n    vec3 up = cross(fwd, right);\n    \n    // 计算视线方向 (Ray Direction)\n    vec3 rd = normalize(fwd + uv.x * right + uv.y * up);\n\n    // 3. 渲染场景\n    vec3 col = render(ro, rd);\n    \n    // 4. Gamma校正并输出\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}*/","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"3XcXR4","date":"0","viewed":0,"name":"whatthefuck","description":"3ddd","likes":0,"published":"Private","usePreview":0,"tags":["3d"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n\nconst float vertexRadius  = 0.035;\nconst float edgeThickness = 0.012;\n\n// --- Constants & Basis Vectors ---\n#define PI 3.14159265359\n#define PHI 1.61803398875 // The Golden Ratio\n\n// The 6 projection vectors from 6D to 3D.\nconst vec3 K[6] = vec3[](\n    normalize(vec3( PHI, 1.0, 0.0)),\n    normalize(vec3(-PHI, 1.0, 0.0)),\n    normalize(vec3( 1.0, 0.0, PHI)),\n    normalize(vec3(-1.0, 0.0, PHI)),\n    normalize(vec3( 0.0, PHI, 1.0)),\n    normalize(vec3( 0.0,-PHI, 1.0))\n);\n\n// --- Main Distance Function (map) ---\nfloat map(vec3 p) {\n    // A fixed 6D offset (\"phase\"). CRITICAL: The values must be \"generic\"\n    // to avoid rational approximants. Simple fractions (like 1/6) or highly\n    // symmetric values will cause the structure to degenerate into a\n    // periodic crystal. These \"boring\" numbers ensure a true quasicrystal.\n    const float phase[6] = float[6](0.123, 0.456, 0.789, 0.321, 0.654, 0.987);\n\n    // 1. Lift the 3D point p to its 6 coordinates in the 6D space.\n    float n[6];\n    for(int i=0; i<6; ++i) {\n        n[i] = dot(p, K[i]) + phase[i];\n    }\n    \n    // 2. Find the distance to the center of the containing hyper-cubic cell.\n    float d[6];\n    for (int i=0; i<6; ++i) {\n        d[i] = abs(n[i] - round(n[i]));\n    }\n\n    // 3. Sort the distances to find the three smallest: d1, d2, d3.\n    // A simple, unrolled bubble sort is clear and efficient enough.\n    for (int i=0; i<5; ++i) {\n        for (int j=i+1; j<6; ++j) {\n            if(d[i] > d[j]) {\n                float temp = d[i];\n                d[i] = d[j];\n                d[j] = temp;\n            }\n        }\n    }\n    float d1 = d[0], d2 = d[1], d3 = d[2];\n\n    // 4. The SDF is the distance to the nearest vertex or edge locus.\n    float vertDist = sqrt(d1*d1 + d2*d2 + d3*d3) - vertexRadius;\n    float edgeDist = sqrt(d1*d1 + d2*d2) - edgeThickness;\n    \n    return min(vertDist, edgeDist);\n}\n\n// --- Standard Raymarching Boilerplate ---\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(SURF_DIST*0.5, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy) - map(p - e.xyy),\n        map(p + e.yxy) - map(p - e.yxy),\n        map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\nmat3 setCamera(vec3 ro, vec3 ta) {\n    vec3 cw = normalize(ta-ro);\n    vec3 cu = normalize(cross(cw, vec3(0,1,0)));\n    vec3 cv = cross(cu,cw);\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // --- Camera ---\n    float time = iTime * 0.25;\n    float dist = 5.0;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    float rot_y = -PI, rot_x = 0.4;\n    if(iMouse.z > 0.0) {\n        rot_y = (mouse.x - 0.5) * 2.0 * PI;\n        rot_x = (mouse.y - 0.5) * PI;\n    } else {\n        rot_y += time;\n    }\n    \n    vec3 ro = vec3(sin(rot_y)*cos(rot_x), sin(rot_x), cos(rot_y)*cos(rot_x)) * dist;\n    vec3 ta = vec3(0.0);\n    mat3 ca = setCamera(ro, ta);\n    vec3 rd = ca * normalize(vec3(uv.xy, 2.0)); // Zoom\n\n    // --- Raymarching ---\n    float t = 0.0;\n    vec3 bcol = vec3(0.1, 0.15, 0.2);\n    vec3 col = bcol;\n\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 pos = ro + t*rd;\n        float h = map(pos);\n        if(abs(h) < SURF_DIST*t || t > MAX_DIST) {\n            if (h < MAX_DIST) t += h;\n            break;\n        }\n        t += h * 0.8;\n    }\n\n    if(t < MAX_DIST) {\n        vec3 pos = ro + t*rd;\n        vec3 nor = getNormal(pos);\n        vec3 lightDir = normalize(vec3(0.8, 0.9, 0.3));\n        \n        float dif = clamp(dot(nor, lightDir), 0.0, 1.0);\n        float rim = pow(1.0 - clamp(dot(nor, -rd), 0.0, 1.0), 2.0);\n        \n        col = vec3(1.0, 0.7, 0.4) * dif + bcol * 0.8 + vec3(1.0,0.9,0.8)*rim*0.4;\n        col = mix(col, bcol, 1.0 - exp(-0.01*t*t)); // Fog\n    }\n\n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"W3tXDr","date":"0","viewed":0,"name":"Fork Uniform 3D neozhaolia 651","description":"Exploring the fun of hyperbolic geometry with hyperbolic honeycombs. Sorry for the low fps.\nThis is a somewhat simplified version of https://github.com/neozhaoliang/Hyperbolic-Honeycombs/","likes":0,"published":"Private","usePreview":0,"tags":["geometry","honeycomb","tiling","hyperbolic","poincare","hyperboloid"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 postProcess(in vec3 col, in vec2 q) {\n    col = pow(clamp(col, 0.0, 1.0), vec3(1.0 / 2.2));\n    col = col * 0.6 + 0.4 * col * col * (3.0 - 2.0 * col); // contrast\n    col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);      // satuation\n    col *= 0.5 + 0.5 * pow(19.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y),\n                           0.7); // vigneting\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 tex = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec3 c = tex.rgb / tex.a;\n    c = postProcess(c, uv);\n    fragColor = vec4(c, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nCompact and paracompact Hyperbolic honeycombs in H3 space\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis program draws compact/paracompact uniform hyperbolic honeycombs in\nPoincaré's 3D ball model. For a complete list of available honeycombs see\n\n    \"https://en.wikipedia.org/wiki/Uniform_honeycombs_in_hyperbolic_space\"\n\nThanks @knighty for his fragmentarium code && help.\n\nSome math stuff:\n\n1. The 4D space R^4 is endowed with Minkowski inner product: for\n   p=(x1, y1, z1, w1) and q=(x2, y2, z2, w2), their \"hyperbolic dot\" is given by\n\n       hdot(p, q) := x1*y1 + x2*y2 * x3*y3 - x4*y4.\n\n   This inner product has Sylvester type (3, 1), the quadratic form is Q(p) = hdot(p, p).\n\n2. The hyperboloid are those vectors in R^4 with Q(p) = -1 (time-like). For those q with\n   Q(q) > 0 we call q space-like. The hyperboloid consists of two sheets: w > 0 and w < 0.\n\n3. The distance between two vectors p, q on the same sheet is given by\n\n       cosh(d(p, q)) = -hdot(p, q).\n\n4. Any geodesic line from a point p on the hyperboloid can be parameterized by\n\n       p*cosh(t) + v*sinh(t),\n\n   where v is a unit tangent vector at p (v must be space-like).\n\n5. A reflection across a plane with normal `n` is given by\n\n       ref(p) = p - 2 * hdot(p, n) * n.\n\n   Here p is time-like and n is space-like.\n\n6. We iteratively reflect a 4d point until it's in the fundamental domian, we get\n   its distance to the initial vertex/mirrors, then use knighty's magic formula to\n   estimate a `safe` distance that we can march in the 3d space. This is the most\n   intriguing part in the code.\n\n\n@mla has another honeycomb demo:\n\n    https://www.shadertoy.com/view/XddyR2\n\n@knighty's fragmentarium code:\n\n    https://github.com/3Dickulus/Fragmentarium_Examples_Folder/tree/master/Knighty%20Collection/Hyperbolic-tesselations-named\n    \n    \n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nList of available honeycombs\n\n\n***9 compact ones***\n\n(5, 2, 2, 3, 2, 5), (3, 2, 2, 5, 2, 3), (4, 2, 2, 5, 2, 3), (5, 2, 2, 4, 2, 3)\n\n  5       5            5            4       5        5       4\no---o---o---o    o---o---o---o    o---o---o---o    o---o---o---o\n\n\n(4, 2, 3, 3, 2, 4), (5, 2, 3, 3, 2, 4), (5, 2, 3, 3, 2, 5), (5, 2, 2, 3, 3, 2), (5, 2, 3, 3, 2, 3)\n\n                                             o\n  o---o        o---o        o---o        5  /       o---o\n4 |   | 4    5 |   | 4    5 |   | 5    o---o      5 |   |\n  o---o        o---o        o---o           \\       o---o\n                                             o     \n\n***paracompact ones***\n\n\n(6, 2, 2, 2, 3, 3), (3, 2, 2, 2, 3, 6), (6, 2, 2, 2, 3, 6), (3, 2, 2, 2, 6, 3)\n\n  6                        6        6       6            6   \no---o---o---o    o---o---o---o    o---o---o---o    o---o---o---o\nA   B   D   C    A   B   D   C    A   B   D   C    A   B   D   C\n\n\n(4, 2, 2, 2, 4, 4), (4, 2, 2, 2, 4, 3), (3, 2, 2, 2, 4, 4)\n\n  4   4   4        4   4                4   4               \no---o---o---o    o---o---o---o    o---o---o---o\nA   B   D   C    A   B   D   C    A   B   D   C\n\n\n(6, 2, 2, 2, 3, 5), (5, 2, 2, 2, 3, 6), (4, 2, 2, 2, 3, 6), (6, 2, 2, 2, 3, 4)\n\n\n  6       5        5       6        4       6        6       4\no---o---o---o    o---o---o---o    o---o---o---o    o---o---o---o\nA   B   D   C    A   B   D   C    A   B   D   C    A   B   D   C\n\n\n(4, 2, 2, 3, 4, 2), (4, 2, 4, 3, 2, 3), (4, 2, 4, 3, 2, 4), (3, 2, 6, 4, 2, 3), (3, 2, 6, 5, 2, 3)\n\n                 B\nA o              o            4\n  4\\           4/ \\       A o---o B    A o---o B    A o---o B\n    o---o    A o   o C    4 |   |      6 |   | 4    6 |   | 5\n  4/B   C      4\\ /       D o---o C    D o---o C    D o---o C\n  o              o            4\n  D              D\n\n     \n(3, 2, 2, 3, 3, 3), (3, 2, 3, 4, 3, 2), (3, 2, 3, 5, 3, 2)\n      \n      o C          o A          o A\nA   B/|      C 4 B/|      C 5 B/|\no---o |      o---o |      o---o |  \n     \\|           \\|           \\|  \n      o D          o D          o D\n     \n     \n(3, 2, 3, 3, 3, 3)\n\n    B\n    o    \n   /|\\\nA o | o C\n   \\|/\n    o\n    D\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n*/\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.141592654\n#define FAR 1e30\n#define MAX_TRACE_STEPS 500\n#define FOV 1.0\n#define MAX_BOUNCES 1\n#define MAX_ITER 40\n\n// ===========\n// !Important:\n// ===========\n// Due to the way we construct the mirrors, the first three mirrors must have\n// spherical type, so for paracompact honeycombs like (4, 4, x), (6, 3, x), (3,\n// 6, x), you need to swap the order of the last two mirrors, i.e. use (4, 2, 2,\n// 2, 4, 4) or (6, 2, 2, 2, 3, x) in the Coxeter diagram. Suggested by @mla. For\n// diagram = (a, b, c, d, e, f) the corresponding Coxeter matrix is\n//\n// | 1  a  b  c |\n// | a  1, d  e |\n// | b  d  1  f |\n// | c  e  f  1 |\n//\nconst float[6] diagram = float[6](5., 2., 2., 3., 2., 4.);\n\n// active mirrors, 1 for active, 0 for non-active. This determines the position\n// of the initial vertex hence the truncation type of the honeycomb\nconst vec4 active_mirrors = vec4(1, 0, 0, 0);\n\n// size of the vertex and segments\n// you may need to adjust these for different scenes\nconst float vradius = 0.14;\nconst float sradius = 0.05;\n\nconst vec3 vertexColor = vec3(0.71, 0.65, 0.26);\nconst vec3 edgeColors[4] =\n    vec3[4](vec3(0.74, 0.62, 0.56), vec3(0.90, 0.91, 0.98),\n            vec3(0.72, 0.45, 0.2), vec3(0.32, 0.79, 0.36));\n\nfloat seed;\n\nfloat hash() {\n    float p = fract((seed++) * 0.1031);\n    p += (p * (p + 19.19)) * 3.;\n    return fract((p + p) * p);\n}\n\nvec2 hash2() { return vec2(hash(), hash()); }\n\n// normal vectors of the four mirrors\nmat4 M;\n\n// the initial vertex\nvec4 v0;\n\n// 2d rotation\nvec2 rot2d(vec2 p, float a) { return cos(a) * p + sin(a) * vec2(p.y, -p.x); }\n\n// Minkowski inner product with Sylvester type (3, 1)\nfloat hdot(in vec4 p, in vec4 q) { return dot(p.xyz, q.xyz) - p.w * q.w; }\n\n// normalize a time-like vector <v, v> < 0\nvec4 normalize_t(vec4 v) { return v / sqrt(-hdot(v, v)); }\n// normalize a space-like vector <v, v> > 0\nvec4 normalize_s(vec4 v) { return v / sqrt(hdot(v, v)); }\n\nfloat arccosh(float x) { return log(x + sqrt(x * x - 1.0)); }\n\n// reflection about a plane with normal `n`\nfloat href(inout vec4 p, in vec4 n) {\n    float k = min(0., hdot(p, n));\n    p -= 2. * k * n;\n    return k;\n}\n\nvec4 reflect_hyp(vec4 p, vec4 n) { return p - 2. * hdot(p, n) * n; }\n\nfloat hyp_distance(vec4 p, vec4 q) { return arccosh(-hdot(p, q)); }\n\n// Given the Coxeter diagram and active mirrors (on/off),\n// get the normals of the reflection mirrors and the initial vertex.\n// Warning: due to the procedure used here, the first three mirrors must\n// have \"spherical\" type.\nvoid init(in float[6] diagram, in vec4 active_mirrors, inout mat4 M,\n          inout vec4 v0) {\n    // Cartan matrix of the Coxeter group:\n    // ( -1  c01  c02  c03)\n    // (c01   -1  c12  c13)\n    // (c02  c12   -1  c23)\n    // (c03  c13  c23   -1)\n    // cij = -cos(PI / (Coxeter label bewteen i-th and j-th mirror))\n    float c01 = -cos(PI / diagram[0]);\n    float c02 = -cos(PI / diagram[1]);\n    float c03 = -cos(PI / diagram[2]);\n    float c12 = -cos(PI / diagram[3]);\n    float c13 = -cos(PI / diagram[4]);\n    float c23 = -cos(PI / diagram[5]);\n\n    // find the reflection mirrors A, B, C, D.\n    // A can be always chosen as x-axis\n    vec4 A, B, C, D;\n    A = vec4(1, 0, 0, 0);\n\n    B = vec4(c01, sqrt(1. - c01 * c01), 0., 0.);\n\n    C = vec4(c02, 0, 0, 0);\n    C.y = (c12 - C.x * B.x) / B.y;\n    C.z = sqrt(\n        abs(1. - dot(C.xy, C.xy))); // avoid rounding error in paracompact case\n\n    D = vec4(c03, 0, 0, 0);\n    D.y = (c13 - D.x * B.x) / B.y;\n    D.z = (c23 - dot(D.xy, C.xy)) / C.z;\n    // !important: if you want to make the fundamental chamber lie in the upper\n    // sheet of the hyperboloid then you must use \"-\" sign here.\n    D.w = -sqrt(abs(dot(D.xyz, D.xyz) - 1.));\n\n    vec4 H = vec4(1, 1, 1, -1);\n    v0 =\n        normalize_t(active_mirrors * inverse(mat4(H * A, H * B, H * C, H * D)));\n    M = mat4(A, B, C, D);\n}\n\n// fold a point p in 4d up to a given maximum of steps, return true if\n// we successfully transformed p into the fundamental domain else return false.\nbool fold(inout vec4 p, mat4 M) {\n    float k;\n    for (int i = 0; i < MAX_ITER; i++) {\n        k = 0.;\n        p.x = abs(p.x);\n        k += href(p, M[1]);\n        k += href(p, M[2]);\n        k += href(p, M[3]);\n        if (k == 0.)\n            return true;\n    }\n    return false;\n}\n\n// vec3 environment(vec3 dir) {\n//     dir = normalize(dir);\n//     float t = 0.5 * (dir.y + 1.0);\n//     vec3 bg = mix(vec3(0.2, 0.3, 0.5), vec3(0.8, 0.9, 1.0), t);\n//     return bg * 0.33;\n// }\n\nvec2 map_hyp(vec4 q) {\n    vec4 p = q; // Use a copy to fold\n    bool found = fold(p, M);\n\n    if (found) {\n        float id;\n\n        // Distance to the central vertex (hyperbolic)\n        // d = d(p, v0) - radius\n        float d_vert = hyp_distance(p, v0) - vradius;\n\n        // Distance to the 4 base edges (hyperbolic)\n        float d_edge = FAR; // A large number\n        for (int i = 0; i < 4; i++) {\n            vec4 n = M[i];\n            // Project p onto the geodesic defined by v0 and n\n            float pn = hdot(p, n);\n            float pv = hdot(p, v0);\n            float nv = hdot(n, v0);\n            float det = -1.0 - nv * nv;\n            float a = (-nv * pv - pn) / det;\n            float b = (pv - pn * nv) / det;\n            vec4 pj = normalize_t(min(a, 0.) * n + b * v0);\n\n            // d = d(p, pj) - radius\n            float d_seg = hyp_distance(p, pj) - sradius;\n\n            if (d_seg < d_edge) {\n                d_edge = d_seg;\n                id = float(i);\n            }\n        }\n\n        if (d_vert < d_edge) {\n            id = 4.0;\n            return vec2(d_vert, id);\n        }\n        return vec2(d_edge, id);\n    }\n    return vec2(FAR, -1.0);\n}\n\nvec2 trace_hyp(vec4 ro_hyp, vec4 rd_hyp) {\n    float t = 0.0; // Total hyperbolic distance traveled\n    const float eps = 1e-4;\n\n    for (int i = 0; i < MAX_TRACE_STEPS; i++) {\n        // Current point on the geodesic\n        vec4 p = ro_hyp * cosh(t) + rd_hyp * sinh(t);\n        vec2 res = map_hyp(p);\n        float d = res.x;\n        if (d < eps) {\n            return vec2(t, res.y);\n        }\n        t += d;\n        if (t > FAR) {\n            break;\n        }\n    }\n    return vec2(FAR, -1.0);\n}\n\n\nvec4 calcNormal_hyp(vec4 p) {\n    float inv_w1 = 1.0 / (1.0 + p.w);\n    // Orthonormal basis in the tangent space at p\n    vec4 Bx = vec4(1.0 + p.x * p.x * inv_w1, p.x * p.y * inv_w1,\n                   p.x * p.z * inv_w1, p.x);\n    vec4 By = vec4(p.y * p.x * inv_w1, 1.0 + p.y * p.y * inv_w1,\n                   p.y * p.z * inv_w1, p.y);\n    vec4 Bz = vec4(p.z * p.x * inv_w1, p.z * p.y * inv_w1,\n                   1.0 + p.z * p.z * inv_w1, p.z);\n    const float eps = 5e-4; // Small step for finite differences\n\n    // Sample the SDF in 6 directions around p\n    float dx = map_hyp(normalize_t(p + eps * Bx)).x -\n               map_hyp(normalize_t(p - eps * Bx)).x;\n    float dy = map_hyp(normalize_t(p + eps * By)).x -\n               map_hyp(normalize_t(p - eps * By)).x;\n    float dz = map_hyp(normalize_t(p + eps * Bz)).x -\n               map_hyp(normalize_t(p - eps * Bz)).x;\n    // The gradient is a linear combination of the basis vectors\n    return normalize_s(dx * Bx + dy * By + dz * Bz);\n}\n\nfloat softShadow_hyp(vec4 ro_hyp, vec4 lp_hyp, float t_max, float k) {\n    float t = 1e-4; // Start a bit away from the surface\n    float res = 1.0;\n    // Calculate the direction vector from surface to light in tangent space\n    vec4 rd_hyp = normalize_s(lp_hyp + hdot(lp_hyp, ro_hyp) * ro_hyp);\n\n    for (int i = 0; i < 24; i++) {\n        // Current point on the geodesic towards the light\n        vec4 p = ro_hyp * cosh(t) + rd_hyp * sinh(t);\n        float h = map_hyp(p).x;\n        res = min(res, smoothstep(0.0, 1.0,\n                                  k * h / t)); // Use sinh(t) for penumbra\n\n        t += clamp(h, 0.01, .1);\n        if (h < 1e-4 || t > t_max)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat calcAO_hyp(vec4 p, vec4 n) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float h = 0.001 + float(i) / 10.; // Hyperbolic step distance\n        // Point stepped along the normal direction\n        vec4 p_occ = p * cosh(h) + n * sinh(h);\n        float d = map_hyp(p_occ).x;\n        occ += (h - d) * sca;\n        sca *= 0.9;\n    }\n    return clamp(1.0 - occ, 0.0, 1.0);\n}\n\nvec3 lighting_hyp(vec4 pos, vec4 nor, vec4 view_dir, vec4 light_pos,\n                  vec3 basecol) {\n    vec3 col = vec3(0.0);\n\n    // Calculate light direction vector IN THE TANGENT SPACE at the surface\n    // point 'pos'\n    float ldist = hyp_distance(pos, light_pos);\n    vec4 ld = normalize_s(light_pos + hdot(light_pos, pos) * pos);\n\n    // AO and Shadow are already hyperbolic\n    float ao = calcAO_hyp(pos, nor);\n    float sh = softShadow_hyp(pos, light_pos, ldist, 32.0);\n\n    // Diffuse term using hyperbolic dot product\n    float diff = clamp(hdot(nor, ld), 0., 1.);\n\n    // Attenuation based on true hyperbolic distance\n    float atten = 1.0 / pow(clamp(sinh(ldist), 0.001, 1.), 2.);\n\n    // Specular term\n    // Reflection of light direction about the normal in hyperbolic space\n    vec4 reflect_dir = normalize_s(reflect_hyp(ld, nor));\n    float spec = pow(max(hdot(reflect_dir, -view_dir), 0.0), 32.0);\n\n    col += basecol * diff;\n    col += basecol * spec * 6.;\n    //col *= ao * atten * sh;\n    col *= sh;\n    return col;\n}\n\nvec4 R3_to_hyp(vec3 p) {\n    float r2 = dot(p, p);\n    return vec4(2. * p, 1. + r2) / (1. - r2);\n}\n\nvec3 render(vec3 ro, vec3 rd, vec3 lp_euc) {\n    vec3 col = vec3(0);\n    vec3 throughput = vec3(1);\n\n    // Initial ray setup in Hyperboloid model\n    vec4 ro_hyp = R3_to_hyp(ro);\n    vec4 rd_hyp = vec4(rd, 0.);\n\n    vec4 lp_hyp = R3_to_hyp(lp_euc);\n\n    for (int i = 0; i < MAX_BOUNCES + 1; i++) {\n        vec2 res = trace_hyp(ro_hyp, rd_hyp);\n        float t = res.x;\n        float id = res.y;\n\n        if (id < 0.0) {\n            break;\n        }\n        vec4 pos_hyp = ro_hyp * cosh(t) + rd_hyp * sinh(t);\n        vec4 normal_hyp = calcNormal_hyp(pos_hyp);\n        vec4 view_dir_hyp = -(ro_hyp * sinh(t) + rd_hyp * cosh(t));\n        vec3 basecol;\n        if (id < 4.)\n            basecol = edgeColors[int(id)];\n        else\n            basecol = vertexColor;\n        vec3 directLight =\n            lighting_hyp(pos_hyp, normal_hyp, view_dir_hyp, lp_hyp, basecol);\n        col += throughput * directLight;\n\n        throughput *= basecol * 0.5;\n        if (max(throughput.r, max(throughput.g, throughput.b)) < 0.05)\n            break;\n\n        // Reflection is the same as before\n        rd_hyp = normalize_s(reflect_hyp(-view_dir_hyp, normal_hyp));\n        float eps = 1e-3;\n        ro_hyp = normalize_t(pos_hyp * cosh(eps) + normal_hyp * sinh(eps));\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    init(diagram, active_mirrors, M, v0);\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    seed = float((iFrame * 73856093) % 38069);\n\n    vec3 ro = vec3(0, 0, 0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 lookat = vec3(0, 0, -1);\n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, up));\n    up = normalize(cross(right, forward));\n\n    vec3 lp = vec3(.3, 0.2, 0.1);\n\n    vec2 jittered = fragCoord + hash2() - 0.5;\n    vec2 uv = (2. * jittered - iResolution.xy) / iResolution.y;\n\n    vec3 rd = normalize(forward * FOV + uv.x * right + uv.y * up);\n    vec3 col = render(ro, rd, lp);\n    col = clamp(col, 0., 1.);\n\n    if (isinf(col.x) || isinf(col.y) || isinf(col.z) || isnan(col.x) ||\n        isnan(col.y) || isnan(col.z)) {\n        col = vec3(0.0);\n    } else\n        data += vec4(col, 1.);\n\n    if (iMouse.z > 0.) {\n        data *= 0.0;\n    }\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"W33SD8","date":"0","viewed":0,"name":"erererer","description":"rerere","likes":0,"published":"Private","usePreview":0,"tags":["rerr"]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100       // 最大步进次数\n#define MAX_DIST 100.0      // 最大追踪距离\n#define HIT_PRECISION 0.001 // 命中精度\n\n#define ROOM_SIZE 4.0 // 房间的半边长 (从原点到墙壁的距离)\n\n// 乐高小人颜色\n#define COLOR_HEAD   vec3(0.9, 0.8, 0.2) // 黄色\n#define COLOR_TORSO  vec3(0.8, 0.1, 0.1) // 红色\n#define COLOR_LEGS   vec3(0.1, 0.2, 0.8) // 蓝色\n#define COLOR_FLOOR1 vec3(0.8)\n#define COLOR_FLOOR2 vec3(0.2)\n\n// --- SDF 基础几何体 (SDF Primitives) ---\n// 来自 Inigo Quilez 的网站 (iq.com/articles/distfunctions)\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// --- SDF 运算符 (SDF Operators) ---\nfloat opU(float d1, float d2) { return min(d1, d2); }\n\n\n// --- 乐高小人 SDF (LEGO Minifigure SDF) ---\n// 返回一个 vec2: .x 是距离, .y 是材质ID (1=头, 2=身体, 3=腿)\nvec2 sdfLego(vec3 p) {\n    // 整体居中向上移动\n    p.y -= 0.95;\n\n    // 1. 腿 (Legs) - ID 3.0\n    vec3 legSize = vec3(0.2, 0.4, 0.25);\n    vec3 legP = p;\n    legP.x = abs(legP.x) - 0.22; // 两条腿分开\n    float legs = sdBox(legP - vec3(0, 0.4, 0), legSize);\n    vec2 res = vec2(legs, 3.0);\n\n    // 2. 身体/躯干 (Torso) - ID 2.0\n    vec3 torsoSize = vec3(0.45, 0.55, 0.25);\n    float torso = sdBox(p - vec3(0, 1.05, 0), torsoSize);\n    if (torso < res.x) res = vec2(torso, 2.0);\n\n    // 3. 头部 (Head) - ID 1.0\n    float head = sdCylinder(p - vec3(0.0, 1.8, 0.0), 0.35, 0.3);\n    // 头顶的凸起\n    float headStud = sdCylinder(p - vec3(0.0, 2.2, 0.0), 0.05, 0.15);\n    head = opU(head, headStud);\n    if (head < res.x) res = vec2(head, 1.0);\n\n    return res;\n}\n\n\n// --- 整体场景 SDF (Main Scene SDF) ---\n// 返回一个 vec2: .x 是距离, .y 是材质ID (0=地面, 1,2,3=乐高)\nvec2 map(vec3 p) {\n    // 1. 无限镜面效果 (核心)\n    // 通过 \"空间折叠\" 将无限空间映射回中心房间\n    // 这样，光线在逻辑上穿过了墙壁，但几何体却被镜像地重复出现\n    vec3 q = p;\n    q.xz = abs(mod(p.xz + ROOM_SIZE, 2.0 * ROOM_SIZE) - ROOM_SIZE);\n    \n    // 2. 获取折叠空间中的乐高小人距离\n    vec2 lego = sdfLego(q);\n    \n    // 3. 地面 (y=0)\n    // 地面永远是 y=0 的平面，所以距离就是 p.y\n    vec2 floor = vec2(p.y, 0.0);\n    \n    // 4. 返回场景中最近的物体\n    return (lego.x < floor.x) ? lego : floor;\n}\n\n\n// --- 法线计算 (Calculate Normal) ---\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(HIT_PRECISION, 0.0);\n    return normalize(vec3(\n        map(p + e.xyy).x - map(p - e.xyy).x,\n        map(p + e.yxy).x - map(p - e.yxy).x,\n        map(p + e.yyx).x - map(p - e.yyx).x\n    ));\n}\n\n// --- 主渲染函数 ---\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 1. 标准化屏幕坐标\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    // 2. 相机设置 (Camera Setup)\n    // 使用鼠标控制相机旋转\n    float angX = 3.14 * (iMouse.x / iResolution.x - 0.5);\n    float angY = 1.57 * (iMouse.y / iResolution.y - 0.5);\n    \n    vec3 ro; // Ray Origin (光线起点)\n    if(iMouse.z > 0.0){\n        // 按住鼠标时，使用旋转视角\n        ro = vec3(cos(angY) * sin(angX), sin(angY), cos(angY) * cos(angX)) * 3.0;\n    } else {\n        // 默认视角\n        ro = vec3(0.0, 1.5, -3.0);\n    }\n    ro.y = max(ro.y, 0.5) + 1.0; // 确保相机不低于地面，并抬高\n    \n    vec3 lookAt = vec3(0.0, 1.0, 0.0); // 视线焦点 (乐高小人中心)\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f, r);\n    vec3 rd = normalize(f + uv.x * r + uv.y * u); // Ray Direction (光线方向)\n\n    // 3. Raymarching 循环\n    float t = 0.0; // 总行进距离\n    vec2 res;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + t * rd;\n        res = map(p);\n        if (res.x < HIT_PRECISION || t > MAX_DIST) break;\n        t += res.x;\n    }\n\n    // 4. 着色 (Shading)\n    vec3 col = vec3(0.0); // 最终颜色\n    if (t < MAX_DIST) {\n        vec3 p = ro + t * rd;\n        vec3 normal = getNormal(p);\n        \n        // --- 获取物体基础色 (Get Base Color) ---\n        vec3 baseColor;\n        if (res.y == 0.0) { // 地面\n            // 棋盘格地面\n            float checker = mod(floor(p.x) + floor(p.z), 2.0);\n            baseColor = mix(COLOR_FLOOR1, COLOR_FLOOR2, checker);\n        } else if (res.y == 1.0) { // 头\n            baseColor = COLOR_HEAD;\n        } else if (res.y == 2.0) { // 身体\n            baseColor = COLOR_TORSO;\n        } else { // 腿\n            baseColor = COLOR_LEGS;\n        }\n        \n        // --- 光照计算 (Lighting) ---\n        vec3 lightPos = vec3(0.0, 5.0, -3.0); // 一个点光源\n        vec3 lightDir = normalize(lightPos - p);\n        \n        // 漫反射 (Diffuse)\n        float diff = max(0.0, dot(normal, lightDir));\n        \n        // 简单的环境光遮蔽 (Ambient Occlusion)\n        float ao = 0.0;\n        float step = 0.05;\n        for(int j=1; j<5; j++){\n            ao += (float(j)*step - map(p + normal * float(j)*step).x);\n        }\n        ao = 1.0 - clamp(ao, 0.0, 1.0);\n\n        // 组合光照\n        vec3 lighting = vec3(0.2) + diff * vec3(1.0); // 环境光 + 漫反射\n        col = baseColor * lighting * ao;\n        \n        // 添加雾效，增强深度感\n        col *= exp(-0.01 * t * t);\n    }\n\n    // 5. 输出颜色\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]},{"ver":"0.1","info":{"id":"WXcXzX","date":"1754819202","viewed":133,"name":"Indra's pearls, Fig 9.1","description":"Grandma's recipe, the 1/15 cusp group in which a^{15}B is parabolic","likes":4,"published":"Public API","usePreview":0,"tags":["2d","fractal","mobius","circlepacking"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nFig 9.1 and Fig 9.15(ii) in Indra's pearls,\nthe 1/15 and 1/9 double cusp groups.\nUsing Ford domain method.\n\nTranslated from knighty's evaldraw script.\n**ALL the difficult parts were done by knighty**.\nI'm lucky and grateful to have his selfless help.\n\nKeyboadr control:\n\n+ Press 1/2/3 to switch mode (limit set, circle packing, tiling)\n+ Press w/s to zoom in/out\n+ Press a/b/c to see the action of a, b and successive action of a^i\n*/\n#define AA 3\n#define CURVE_THICKNESS 0.007\n\n// uncomment to show the 1/9 cusp group\n//#define cusp_1_9\n\nconst int MAX_ITER = 100;\n\nconst vec2 tb = vec2(2, 0);\n\n#ifdef cusp_1_9\n    const int N = 13;\n    const vec2 ta = vec2(1.8964073,-0.0487530);\n    const float rr = 0.3217;\n    vec2 pts[] = vec2[] (\n            vec2(-1, 0), vec2(1, 0), vec2(0, -1),\n            vec2(0,1)\n        );\n#else\n    const int N = 17;\n    const vec2 ta = vec2(1.95859103, -0.01127856);\n    const float rr = 0.3287582641552815;\n    vec2 pts[] = vec2[] (\n            vec2(-1, 0), vec2(1, 0), vec2(0, -1),\n            vec2(0,1), vec2(0.405415, -0.19312647)\n        );\n#endif\n\nconst vec3 trap1 = vec3(0, 0, 1);\nconst vec3 trap2 = vec3(1. - rr, 0, rr * rr);\nconst vec3 trap3 = vec3(rr - 1., 0, rr * rr);\n\nfloat zoom;\nint mode;\n\nvec2 cmul(vec2 z, vec2 w) { return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x); }\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float d2 = dot(w, w); if (d2 < 1e-15) return vec2(1e7);\n    return cmul(z, vec2(w.x, -w.y)) / d2;\n}\n\nvec2 csqrt(vec2 z) {\n    float r = length(z); float angle = atan(z.y, z.x);\n    return sqrt(r) * vec2(cos(0.5*angle), sin(0.5*angle));\n}\n\nvec2 solveQuadratic(vec2 b, vec2 c) {\n    vec2 delta = cmul(b, b) - 4. * c;\n    vec2 sqrt_delta = csqrt(delta);\n    return (-b - sqrt_delta) / 2.;\n}\n\nstruct Mobius { vec2 a, b, c, d; };\n\nvec2 applyMobius(Mobius m, vec2 z) {\n    vec2 num = cmul(m.a, z) + m.b;\n    vec2 den = cmul(m.c, z) + m.d;\n    return cdiv(num, den);\n}\n\nMobius mulMobius(Mobius m1, Mobius m2) {\n    return Mobius(cmul(m1.a, m2.a)+cmul(m1.b, m2.c), cmul(m1.a, m2.b)+cmul(m1.b, m2.d),\n                  cmul(m1.c, m2.a)+cmul(m1.d, m2.c), cmul(m1.c, m2.b)+cmul(m1.d, m2.d));\n}\n\nMobius invMobius(Mobius m) { return Mobius(m.d, -m.b, -m.c, m.a); }\n\nMobius interpolateMobius(Mobius m1, Mobius m2, float t) {\n    return Mobius(\n        mix(m1.a, m2.a, t),\n        mix(m1.b, m2.b, t),\n        mix(m1.c, m2.c, t),\n        mix(m1.d, m2.d, t)\n    );\n}\n\nconst Mobius identity = Mobius(vec2(1,0), vec2(0), vec2(0), vec2(1,0));\nMobius a, b, A, B;\nMobius transforms[N];\n\n//-----------------------------------------------------\n\nvoid getGenerators(inout Mobius a, inout Mobius b) {\n    // compute tab\n    vec2 ta2 = cmul(ta, ta);\n    vec2 tb2 = cmul(tb, tb);\n    vec2 tab = solveQuadratic(-cmul(ta, tb), ta2 + tb2);\n    \n    // compute z0\n    vec2 num = cmul(tab - vec2(2, 0), tb);\n    vec2 den = cmul(tb, tab) - 2. * ta + cmul(vec2(0, 2), tab);\n    vec2 z0 = cdiv(num, den);\n    \n    // compute b\n    b.a = tb / 2. - vec2(0, 1);\n    b.d = tb / 2. + vec2(0, 1);\n    b.c = b.b = tb / 2.;\n    \n    // compute ab\n    Mobius ab = Mobius(\n        tab / 2.,\n        cdiv(tab / 2. - vec2(1, 0), z0),\n        cmul(tab / 2. + vec2(1, 0), z0),\n        tab / 2.\n    );\n    \n    // a = (ab)B\n    a = mulMobius(ab, invMobius(b));\n}\n\nbool Equal(vec2 z, vec2 a, float deriv) {\n    float k = 2. + length(z);\n    return k * length(z - a) * deriv / zoom < CURVE_THICKNESS;\n}\n\nvoid setupTransforms() {\n    getGenerators(a, b);\n    A = invMobius(a);\n    B = invMobius(b);\n\n    transforms[0] = a;\n\n#ifdef cusp_1_9\n    for (int i = 1; i < 9; i++)\n        transforms[i] = mulMobius(transforms[i-1], a);\n    transforms[9] = b;\n    transforms[10] = mulMobius(a, mulMobius(b, A));\n    transforms[11] = mulMobius(transforms[8], B);\n    transforms[12] = mulMobius(invMobius(transforms[7]), transforms[10]);\n#else\n   \n    for (int i = 1; i < 15; i++)\n        transforms[i] = mulMobius(transforms[i-1], a);\n\n    transforms[15] = b;\n    transforms[16] = mulMobius(mulMobius(a, b), A);\n#endif\n}\n\n\nfloat sdTrapped(vec2 p) {\n    float d1 = 1. - dot(p, p);\n    float d2 = dot(p - trap2.xy, p - trap2.xy) - trap2.z;\n    float d3 = dot(p - trap3.xy, p - trap3.xy) - trap3.z;\n    return min(d1, min(d2, d3));\n}\n\nstruct BestTransformChoice {\n    vec2  z_new;\n    float nsd;\n    bool  found;\n};\n\nvoid fold(inout vec2 z, inout float count, inout float deriv) {\n    for (int i = 0; i < MAX_ITER; i++) {\n        \n        float min_nsd = 1.0;\n        BestTransformChoice best_choice;\n        best_choice.found = false;\n        for (int j = 0; j < N; j++) {\n            Mobius g = transforms[j];\n            vec2 den_g = cmul(g.c, z) + g.d;\n            float nsd_g = dot(den_g, den_g);\n\n            if (nsd_g < min_nsd) {\n                min_nsd = nsd_g;\n                best_choice.z_new = applyMobius(g, z);\n                best_choice.nsd = nsd_g;\n                best_choice.found = true;\n            }\n            Mobius g_inv = invMobius(g);\n            vec2 den_g_inv = cmul(g_inv.c, z) + g_inv.d;\n            float nsd_g_inv = dot(den_g_inv, den_g_inv);\n\n            if (nsd_g_inv < min_nsd) {\n                min_nsd = nsd_g_inv;\n                best_choice.z_new = applyMobius(g_inv, z);\n                best_choice.nsd = nsd_g_inv;\n                best_choice.found = true;\n            }\n        }\n        if (best_choice.found) {\n            z = best_choice.z_new;    \n            deriv *= best_choice.nsd;\n            count += 1.0;\n        }\n        else {\n            break;\n        }\n    }\n}\nvec3 hsv2rgb(vec3 c){\n    vec3 rgb = clamp(abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 getColor(vec2 z, vec2 uv, in float deriv) {\n    \n    float count = 0.0;\n    fold(z, count, deriv);\n    float id;\n    if (dot(z, z) > 1.)\n        { id = 0.; }\n    else if (dot(z - trap2.xy, z - trap2.xy) < trap2.z)\n        { id = 1.; }\n    else if (dot(z - trap3.xy, z - trap3.xy) < trap3.z)\n        { id = 2.; }\n    else\n        id = 3.;\n        \n    float d = abs(sdTrapped(z) * deriv) / zoom;\n    if (mode == 1) {\n        vec3 col = vec3(1);\n        for (int i = 0; i < pts.length(); i++) {\n            if (Equal(z, pts[i], deriv)) {\n                col = vec3(0);\n                break;\n            }\n        }\n        return col;\n    }\n    else if (mode == 0) {\n        if (count > float(MAX_ITER))\n            return vec3(0);\n        float pi = 3.1415926;\n        float t = pi * count / 14.;\n    \n        vec3 col = 0.5 + 0.5 *cos(\n            t + vec3(3., 4.2, 4.9) * 0.95);\n        col = pow(col, vec3(2.2));\n        return col;\n    }\n    else {\n        vec3 col=vec3(1);\n        if (id == 1. || id == 2.)\n            col = 0.5 + 0.45 * cos((id - 1.)*14.+vec3(0,1,2));\n        \n        if (length(z) > 1.) {\n            float id2 = mod(count, 2.);\n            if (id2 == 1.)\n                col = vec3(0.85, 0.85, 0.95);\n        }\n        \n        for (int i = 0; i < pts.length(); i++) {\n            if (Equal(z, pts[i], deriv)) {\n                col = vec3(0);\n                break;\n            }\n        }\n        return col;\n    }\n}\n\nMobius getTransformForK(int k, const in Mobius B) {\n    const Mobius identity = Mobius(vec2(1,0), vec2(0), vec2(0), vec2(1,0));\n    if (k == 0) {\n        return identity;\n    }\n    Mobius a_k = transforms[k - 1];\n    return invMobius(a_k);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    setupTransforms();\n    vec4 pan_vals = textureLod(iChannel0, vec2(0.5, 0.5) / iResolution.xy, 0.0);\n    zoom = textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n    float ab_anim_t = textureLod(iChannel0, vec2(1.5, 0.5) / iResolution.xy, 0.0).x;\n    vec4 c_state = textureLod(iChannel0, vec2(2.5, 0.5) / iResolution.xy, 0.0);\n    \n    mode = int(textureLod(iChannel0, vec2(3.5, 0.5) / iResolution.xy, 0.0).x);\n    \n    int k_from = int(c_state.x);\n    int k_to = int(c_state.y);\n    float anim_timer = c_state.z;\n\n    const Mobius identity = Mobius(vec2(1,0), vec2(0), vec2(0), vec2(1,0)); // Moved identity here for use in getTransformForK\n    Mobius final_transform = identity;\n    if (abs(ab_anim_t) > 0.01) {\n        if (ab_anim_t > 0.0) {\n            final_transform = interpolateMobius(identity, A, ab_anim_t);\n        } else {\n            final_transform = interpolateMobius(identity, B, abs(ab_anim_t));\n        }\n    }\n    else if (k_to > 0 || anim_timer < 1.0) {\n        Mobius T_from = getTransformForK(k_from, B);\n        Mobius T_to = getTransformForK(k_to, B);\n        float t = smoothstep(0.0, 1.0, anim_timer);\n        \n        final_transform = interpolateMobius(T_from, T_to, t);\n    } \n    vec3 col = vec3(0);\n    for (int ii = 0; ii < AA; ii++) {\n        for (int jj = 0; jj < AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * (fragCoord + o) - iResolution.xy -\n                       pan_vals.xy * pow(zoom, -1.0)) /\n                      iResolution.y;\n            uv *= zoom * 1.05; \n            vec2 den_g = cmul(final_transform.c, uv) + final_transform.d;\n            float deriv = dot(den_g, den_g);\n            vec2 z = applyMobius(final_transform, uv);\n            col += getColor(z, uv, deriv);\n        }\n    }\n    col /= (float(AA) * float(AA));\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// https://www.shadertoy.com/view/ldyGzW\nconst int Key_A = 65;\nconst int Key_B = 66;\nconst int Key_C = 67;\nconst int Key_D = 68;\nconst int Key_E = 69;\nconst int Key_F = 70;\nconst int Key_G = 71;\nconst int Key_H = 72;\nconst int Key_I = 73;\nconst int Key_J = 74;\nconst int Key_K = 75;\nconst int Key_L = 76;\nconst int Key_M = 77;\nconst int Key_N = 78;\nconst int Key_O = 79;\nconst int Key_P = 80;\nconst int Key_Q = 81;\nconst int Key_R = 82;\nconst int Key_S = 83;\nconst int Key_T = 84;\nconst int Key_U = 85;\nconst int Key_V = 86;\nconst int Key_W = 87;\nconst int Key_X = 88;\nconst int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48;\nconst int Key_1 = 49;\nconst int Key_2 = 50;\nconst int Key_3 = 51;\nconst int Key_4 = 52;\nconst int Key_5 = 53;\nconst int Key_6 = 54;\nconst int Key_7 = 55;\nconst int Key_8 = 56;\nconst int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal(int key, bool toggle) {\n    return textureLod(iChannel1,\n                      vec2((float(key) + .5) / 256.0, toggle ? .75 : .25), 0.0)\n        .x;\n}\n\nfloat ReadKey(int key) { return ReadKeyInternal(key, false); }\n\nfloat ReadKeyToggle(int key) { return ReadKeyInternal(key, true); }\n\n// Storage Code For Pan and Zoom\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default output for unused pixels\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Pan State at (0,0)\n    if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n        vec4 prev_info = textureLod(iChannel0, vec2(0.0, 0.0), 0.0);\n        float Zoom =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n        float prev_pan_x = prev_info.x;\n        float prev_pan_y = prev_info.y;\n        float legacy_pan_x = prev_info.z;\n        float legacy_pan_y = prev_info.w;\n\n        float pan_x = (iMouse.x - abs(iMouse.z)) * Zoom + legacy_pan_x;\n        float pan_y = (iMouse.y - abs(iMouse.w)) * Zoom + legacy_pan_y;\n\n        if (iMouse.z < 0.0) {\n            legacy_pan_x = prev_pan_x;\n            legacy_pan_y = prev_pan_y;\n            pan_x = legacy_pan_x;\n            pan_y = legacy_pan_y;\n        }\n        fragColor = vec4(pan_x, pan_y, legacy_pan_x, legacy_pan_y);\n    }\n\n    // Zoom State at (10,10)\n    if (ivec2(fragCoord.xy) == ivec2(10, 10)) {\n        float x =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).y;\n        x += ReadKey(Key_W) - ReadKey(Key_S);\n        float Zoom = pow(2.71, -x * 0.05);\n        fragColor = vec4(Zoom, x, 0.0, 0.0);\n    }\n    \n    // Animation State at (1,0)\n    if (ivec2(fragCoord.xy) == ivec2(1, 0)) {\n        // Read previous animation state\n        float prev_anim_t = texelFetch(iChannel0, ivec2(1,0), 0).x;\n\n        float key_a = ReadKey(Key_A);\n        float key_b = ReadKey(Key_B);\n        \n        float target_t = 0.0;\n        if (key_a > 0.0) {\n            target_t = 1.0;\n        } else if (key_b > 0.0) {\n            target_t = -1.0;\n        }\n        \n        float speed = 2.;\n        float anim_t = mix(prev_anim_t, target_t, 1.0 - exp(-iTimeDelta * speed));\n        fragColor = vec4(anim_t, 0.0, 0.0, 1.0);\n    }\n     if (ivec2(fragCoord.xy) == ivec2(2, 0)) {\n         vec4 prev_c_state = texelFetch(iChannel0, ivec2(2,0), 0);\n        float k_from = prev_c_state.x;\n        float k_to = prev_c_state.y;\n        float anim_timer = prev_c_state.z;\n        float prev_key_c_state = prev_c_state.w;\n        \n        float key_c = ReadKey(Key_C);\n        if (anim_timer < 1.0) {\n            float anim_speed = 1.;\n            anim_timer += iTimeDelta * anim_speed;\n        }\n        anim_timer = min(anim_timer, 1.0);\n\n        if (key_c > 0.0 && prev_key_c_state == 0.0 && anim_timer >= 1.0) {\n            k_from = k_to;\n            k_to = mod(k_to + 1.0, 16.0);\n            anim_timer = 0.0;\n        }\n        \n        fragColor = vec4(k_from, k_to, anim_timer, key_c);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(3, 0)) {\n        float current_mode = texelFetch(iChannel0, ivec2(3,0), 0).x;\n        if(iFrame < 2) current_mode = 2.0; \n        if (ReadKey(Key_1) > 0.0) current_mode = 0.0;\n        if (ReadKey(Key_2) > 0.0) current_mode = 1.0;\n        if (ReadKey(Key_3) > 0.0) current_mode = 2.0;\n        fragColor = vec4(current_mode, 0.0, 0.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"WXdSzl","date":"1753810433","viewed":395,"name":"Hyperbolic billiard","description":"Motivated by https://codepen.io/brainjam/pen/GaYJjJ\nclearly, there's still a lot of room for code optimization. But I'm too exhausted now.","likes":30,"published":"Public API","usePreview":0,"tags":["2d","simulation","hyperbolic","poincare","billiard"]},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float seed;\nfloat hash() {\n    float p = fract((seed++) * .1031);\n    p += (p * (p + 19.19)) * 3.;\n    return fract((p + p) * p);\n}\n\nvoid drawParticleShadow(inout vec3 color, vec2 p, vec2 pos, vec2 vel, float r) {\n    const float shadow_offset = .4;\n    const float shadow_darkness = 0.5;\n    const float shadow_softness = 1.;\n\n    float ball_dist = length(p - pos);\n    float glow = pow(1.0 - smoothstep(0.0, r, ball_dist), 6.0);\n\n    vec2 shadow_dir = vec2(0.0);\n    if (length(vel) > 0.001) {\n        shadow_dir = normalize(vel);\n    }\n    vec2 shadow_pos = pos - shadow_dir * r * shadow_offset;\n    float shadow_dist = length(p - shadow_pos);\n    float shadow_mix = 1.0 - smoothstep(r, r * shadow_softness, shadow_dist);\n\n    float final_shadow_mix = shadow_mix * (1.0 - glow); // 阴影不覆盖发光区域\n    color = mix(color, vec3(0.0), final_shadow_mix * shadow_darkness);\n}\n\nvoid drawParticle(inout vec3 color, vec2 p, vec2 pos, vec2 vel, vec3 ball_color,\n                  float r) {\n    const float glow_falloff = 6.; // 发光的衰减指数，值越大，光点越集中\n\n    // --- 高光参数（调整以更明显） ---\n    // 调整光线方向，使其更“靠前”或“侧面”一些，以便高光位置更明显\n    // 这里Z分量增大，使得光线更直接从观察者方向来\n    const vec3 light_direction =\n        normalize(vec3(0.5, 0.5, 1.5)); // 模拟光线方向 (X, Y, Z) Z朝向观察者\n    const float shininess = 64.0; // 材质光泽度，值越大高光越集中和亮\n    const vec3 specular_color = vec3(1.0, 1.0, 1.0); // 高光颜色，通常是白色\n\n    // --- 2. 独立计算球和阴影的“形状”/“透明度” ---\n    // 计算当前片元到球心的距离\n    float ball_dist = length(p - pos);\n\n    // 计算球的辉光强度 (0.0 到 1.0)\n    // 只有在 ball_dist < r 的范围内，glow才>0。在 ball_dist >= r 时，glow 为\n    // 0。\n    float glow = pow(1.0 - smoothstep(0.0, r, ball_dist), glow_falloff);\n\n    // --- 3. 高光计算 ---\n    vec3 specular_intensity = vec3(0.0);\n    // 只有在球体内部才计算高光\n    if (ball_dist < r) {\n        // 计算当前像素点在球体上的“法线”\n        vec2 normal_xy = normalize(p - pos); // 2D平面上的法线分量\n        // 计算Z深度，模拟球体的3D曲面\n        float z_depth_sq = r * r - dot(p - pos, p - pos);\n        float z_depth = sqrt(max(0.0, z_depth_sq));\n\n        // 构造3D法线向量 (xy平面分量和z深度分量)\n        vec3 surface_normal = normalize(\n            vec3(normal_xy, z_depth)); // z_depth无需除以r，normalize会处理\n\n        // 简化视角方向：假设相机在Z轴正方向，看向球心\n        vec3 view_direction =\n            normalize(vec3(0.0, 0.0, 1.0)); // 观察方向，简化为正Z轴\n\n        // 反射光线方向 (R = 2 * (N . L) * N - L)\n        vec3 reflected_light = normalize(\n            2.0 * dot(surface_normal, light_direction) * surface_normal -\n            light_direction);\n\n        // 高光强度：dot(reflected_light, view_direction) 的 shininess 次方\n        float spec_dot = max(0.0, dot(reflected_light, view_direction));\n        specular_intensity = specular_color * pow(spec_dot, shininess);\n\n        // 高光衰减：让高光在球体中心附近更亮，在边缘处逐渐消失\n        // 通过 `smoothstep` 使得高光不会突然出现和消失\n        specular_intensity *= smoothstep(r * 0.5, r * 0., ball_dist);\n    }\n\n    // --- 4. 按正确顺序混合 ---\n\n    // --- 抗锯齿边缘处理 ---\n    float aa_edge = 0.001; // 边缘过渡宽度，值越大边缘越软\n\n    // 球体边缘的混合因子（用于软化边缘）\n    float ball_alpha = 1.0 - smoothstep(r - aa_edge, r + aa_edge, ball_dist);\n\n    // 基础球体颜色 = 球的基色 + 辉光效果\n    vec3 base_particle_color = mix(ball_color, vec3(1.0), glow * 0.5);\n\n    // 最终颜色 = 基础球体颜色 + 高光\n    vec3 final_ball_color = base_particle_color + specular_intensity;\n\n    // 使用球体 alpha 混合颜色，避免锯齿\n    color = mix(color, final_ball_color, ball_alpha);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    seed = float((int(fragCoord.x) * 19349663 ^ int(fragCoord.y) * 83492791) %\n                 38069);\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    uv *= 1.1;\n    vec3 col = vec3(0);\n    vec2 p = uv;\n    int count = 0;\n    if (length(p) > 1.) {\n        p /= dot(p, p);\n    }\n    p = fold_tile(p, count);\n    float c = float(count);\n    vec3 oCol = .55 + .4 * cos(2. * PI * c / 32. + vec3(2, 1, 0));\n    oCol += (vec3(hash(), hash(), hash()) - .5) * .12;\n    float d1 = dot(p, conj(nB));\n    float d2 = dot(p, nB);\n    float d3 = length(p - cen) - r;\n    float dist = min(d1, min(d2, d3));\n    float aa = fwidth(dist) / 2.;\n    float lw = 0.01;\n\n    col = mix(col, oCol, 1. - smoothstep(0., 1., dist - .01));\n    col = mix(col, vec3(0), 1. - smoothstep(lw - aa, lw + aa, dist));\n    vec3 bgColor = col;\n    for (int i = 0; i < NUM_BALLS; i++) {\n        vec4 state = texelFetch(iChannel0, ivec2(i, 0), 0);\n        vec2 ball_pos = state.xy;\n        vec2 ball_vel = state.zw;\n        for (int k = 0; k < 6; k++)\n            drawParticleShadow(bgColor,\n                               getTransformedState(vec4(p, 0, 0), k).xy,\n                               ball_pos, ball_vel, RADIUS);\n    }\n\n    col = bgColor;\n    for (int i = 0; i < NUM_BALLS; i++) {\n        vec4 state = texelFetch(iChannel0, ivec2(i, 0), 0);\n        vec2 ball_pos = state.xy;\n        vec2 ball_vel = state.zw;\n        vec3 ball_color = ball_colors[i];\n        for (int k = 0; k < 6; k++)\n            drawParticle(col, getTransformedState(vec4(p, 0, 0), k).xy,\n                         ball_pos, ball_vel, ball_color, RADIUS);\n    }\n\n    float dcirc = abs(length(uv) - 1.);\n    float sf = 1. / iResolution.y;\n    col = mix(col, vec3(0), 1. - smoothstep(0., 2. * sf, dcirc - 12. * sf));\n    float rnd = smoothstep(.1, 1., sin(iTime * 1.5) * .5 + .5);\n    vec3 blink = vec3(1.0, 0.843, 0.0);\n    blink = mix(blink * 0.7, blink * 3., rnd);\n    col = mix(col, blink, 1. - smoothstep(0., sf, dcirc - 6. * sf));\n    fragColor = vec4(clamp(col, 0., 1.), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Currently support <=6 balls. To use >6 balls.\n// simply add more colors to `ball_colors`\n#define NUM_BALLS 3\n#define MAX_ITER 100\n#define RADIUS 0.03\n#define DT 0.2\n#define PI 3.1415926536\n#define SPEED 0.01\n#define TARGET_ENERGY 3e-4\n\nvec3 ball_colors[] =\n    vec3[](\n    vec3(1.0, 0.3, 0.4),\n    vec3(0.1, 0.8, 0.6),\n    vec3(0.75, 0.75, 0.1),\n    vec3(0.75, 0.1, 0.5),\n    vec3(0.2, 0.2, 1),\n    vec3(0.75, 0.75, 0.75));\n\nconst float P = 8.;\nconst float Q = 3.;\n\nconst float alpha = PI / P;\nconst float beta = PI / Q;\n\nconst float ca = cos(alpha), sa = sin(alpha);\nconst float cb = cos(beta), sb = sin(beta);\nconst vec2 nB = vec2(sa, -ca);\nconst float rho = sqrt(cb * cb - sa * sa);\nconst vec2 cen = vec2(cb / rho, 0.0);\nconst float r = sa / rho;\n\nvec2 conj(vec2 p) { return vec2(p.x, -p.y); }\nvec2 refB(vec2 p) { return reflect(p, nB); }\nvec2 refC(vec2 p) {\n    p -= cen;\n    p *= r * r / dot(p, p);\n    return p + cen;\n}\nvec4 conjState(vec4 p) { return vec4(conj(p.xy), conj(p.zw)); }\n\nvec4 refBState(vec4 p) { return vec4(refB(p.xy), refB(p.zw)); }\n\nvec2 reflectVel(vec2 p, vec2 v) {\n    return vec2(-v.x, v.y);\n    vec2 normal = normalize(p - cen);\n    return reflect(v, normal);\n}\n\nvec4 refCState(vec4 p) { return vec4(refC(p.xy), reflectVel(p.xy, p.zw)); }\n\nvec4 fold(vec4 state) {\n    int count = 0;\n    vec2 p = state.xy;\n    vec2 v = state.zw;\n    for (int i = 0; i < MAX_ITER; i++) {\n        float kA = dot(p, nB);\n        float kB = dot(p, conj(nB));\n        float kC = length(p - cen) - r;\n        if (kA > 0. && kB > 0. && kC > 0.) {\n            if (count % 2 == 1) {\n                p = conj(p);\n                v = conj(v);\n                count += 1;\n            }\n            break;\n        }\n        if (p.y < 0.) {\n            p = conj(p);\n            v = conj(v);\n            count += 1;\n            continue;\n        }\n        if (dot(p, nB) < 0.) {\n            p = refB(p);\n            v = refB(v);\n            count += 1;\n            continue;\n        }\n        if (kC < 0.) {\n            v = reflectVel(p, v);\n            p = refC(p);\n            count += 1;\n            continue;\n        }\n    }\n    return vec4(p, v);\n}\n\nvec2 fold_tile(vec2 p, inout int count) {\n    for (int i = 0; i < MAX_ITER; i++) {\n        float kA = dot(p, nB);\n        float kB = dot(p, conj(nB));\n        float kC = length(p - cen) - r;\n        if (kA > 0. && kB > 0. && kC > 0.) {\n            if (count % 2 == 1) {\n                p = conj(p);\n                count += 1;\n            }\n            return p;\n        }\n        if (kA < 0.) {\n            p = refB(p);\n            count += 1;\n            continue;\n        }\n        if (kB < 0.) {\n            p = reflect(p, conj(nB));\n            count += 1;\n            continue;\n        }\n        if (kC < 0.) {\n            p = refC(p);\n            count += 1;\n            continue;\n        }\n    }\n    return p;\n}\n\nvec4 getTransformedState(vec4 s0, int idx) {\n    if (idx <= 0 || idx > 5)\n        return s0;\n\n    vec4 s1 = refBState(conjState(s0));\n    if (idx == 1)\n        return s1;\n\n    vec4 s2 = refCState(conjState(s1));\n    if (idx == 2)\n        return s2;\n\n    vec4 s3 = conjState(refBState(s0));\n    if (idx == 3)\n        return s3;\n\n    vec4 s4 = refCState(conjState(s3));\n    if (idx == 4)\n        return s4;\n\n    vec4 s5 = refCState(conjState(s0));\n    if (idx == 5)\n        return s5;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 addBall(int idx) {\n    float x = float(idx + 1) / 9.;\n    float ang = float(9 - idx) * PI / 20.;\n    vec2 v = vec2(cos(ang), sin(ang)) * SPEED;\n    return vec4(x, 0, v);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int id = int(fragCoord.x);\n    if (iFrame == 0) {\n        if (id < NUM_BALLS)\n            fragColor = addBall(id);\n        return;\n    }\n    float totalKE = 0.0;\n    for (int i = 0; i < NUM_BALLS; i++) {\n        vec4 s = texelFetch(iChannel0, ivec2(i, 0), 0);\n        totalKE += dot(s.zw, s.zw);\n    }\n\n    float desiredKE = float(NUM_BALLS) * TARGET_ENERGY;\n    float scale = 1.0;\n    if (totalKE > 1e-8) {\n        scale = sqrt(desiredKE / totalKE);\n    }\n    vec4 state = texelFetch(iChannel0, ivec2(id, 0), 0);\n    state.zw *= scale;\n    state.xy += state.zw * DT;\n    fragColor = fold(state);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int id = int(fragCoord.x);\n    if (id >= NUM_BALLS) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    vec4 me = texelFetch(iChannel0, ivec2(id, 0), 0);\n    vec2 total_impulse = vec2(0);\n    vec2 total_pos_adj = vec2(0);\n    bool self_collision = false;\n\n    for (int j = 0; j < NUM_BALLS; ++j) {\n        vec4 other = texelFetch(iChannel0, ivec2(j, 0), 0);\n        for (int k = 0; k < 6; ++k) {\n            if (k == 0 && j == id)\n                continue;\n            vec4 other_transformed = getTransformedState(other, k);\n            vec2 d_pos_vec = me.xy - other_transformed.xy;\n            float dist_sq = dot(d_pos_vec, d_pos_vec);\n            float radii = 2.0 * RADIUS;\n\n            if (dist_sq < radii * radii && dist_sq > 1e-8) {\n                float dist = sqrt(dist_sq);\n                vec2 d_pos_normalized = d_pos_vec * radii / dist;\n                vec2 d_vel_vec = me.zw - other_transformed.zw;\n                if (dot(d_vel_vec, d_pos_vec) >= 0.0)\n                    continue;\n\n                float fact_numerator = 2.0 * dot(d_vel_vec, d_pos_normalized);\n                float fact_denominator =\n                    2.0 * dot(d_pos_normalized, d_pos_normalized);\n                float fact = fact_numerator / fact_denominator;\n\n                vec2 impulse = -fact * d_pos_normalized;\n                total_impulse += impulse;\n\n                float ratio = dist / radii;\n                float overlap = radii - dist;\n                vec2 my_adj = normalize(d_pos_vec) * overlap * 0.5;\n                if (j == id) {\n                    my_adj *= 2.0;\n                }\n                total_pos_adj += my_adj;\n                if (j == id) {\n                    self_collision = true;\n                }\n            }\n        }\n    }\n    if (int(fragCoord.y) == 0) {\n        fragColor = vec4(total_impulse, total_pos_adj);\n    } else if (int(fragCoord.y) == 1) {\n        fragColor = vec4(self_collision ? 1.0 : 0.0, 0.0, 0.0, 0.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 id = ivec2(fragCoord);\n    if (id.x >= NUM_BALLS) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    vec4 state = texelFetch(iChannel0, id, 0);\n    vec4 response_data = texelFetch(iChannel1, ivec2(id.x, 0), 0);\n    vec2 total_impulse = response_data.xy;\n    vec2 total_pos_adj = response_data.zw;\n\n    float self_collision = texelFetch(iChannel1, ivec2(id.x, 1), 0).x;\n    vec2 new_pos = state.xy + total_pos_adj;\n    vec2 new_vel = state.zw + total_impulse;\n\n    if (self_collision > 0.5) {\n        float ke_before = dot(state.zw, state.zw);\n        float ke_after = dot(new_vel, new_vel);\n        if (ke_after > 1e-8) {\n            float ke_correction = sqrt(ke_before / ke_after);\n            new_vel *= ke_correction;\n        }\n    }\n    fragColor = vec4(new_pos, new_vel);\n}","name":"Buffer C","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"WXKXDm","date":"1754669030","viewed":15,"name":"Fork save curve neozhaolia 187","description":"xxxx","likes":0,"published":"Unlisted","usePreview":0,"tags":["2d"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 1\n#define MAX_ITER 400\n#define L2(x) dot(x, x)\n\nfloat zoom;\nint mode;\n\nconst float rr = 0.266617090;\nconst vec3 c5 = vec3(rr - 1., 0, rr);\nconst vec3 c2 = vec3(0.091245189, -0.109073520, 0.142253712);\nconst vec3 c0 = vec3(1. - rr, 0.000000000, rr);\n\nconst vec3 d = vec3(0.000000000, -0.621518731, 0.378481269);\n\nconst vec2 p54 = vec2(-0.466765821, -0.000043118);\nconst vec2 p43 = vec2(-0.221293703, 0.051644396);\nconst vec2 p32 = vec2(-0.000013769, -0.000072971);\nconst vec2 p21 = vec2(0.221419364, -0.051707979);\nconst vec2 p10 = vec2(0.466880530, -0.000026785);\nconst vec2 p56 = vec2(-0.584790766, -0.221370846);\nconst vec2 p67 = vec2(-0.482784599, -0.370137155);\nconst vec2 p7d = vec2(-0.349603921, -0.476936251);\nconst vec2 p2d = vec2(0.066307947, -0.249124423);\nconst vec3 circ_5_4 = vec3(-1, -3297.238281250, 3297.238281250);\nconst vec3 circ_4_53 = vec3(-0.466782153, 0.608771026, 0.608814120);\nconst vec3 circ_3_42 = vec3(-0.145084500, -0.121531114, 0.189202532);\nconst vec3 circ_2_31 = vec3(0.145078152, 0.121525854, 0.189309120);\nconst vec3 circ_1_20 = vec3(0.466941744, -0.609070241, 0.609043479);\nconst vec3 circ_0_1 = vec3(1, -5305.558105469, 5305.558105469);\nconst vec3 circ_5_46 = vec3(-0.466788799, -0.142163649, 0.142120540);\nconst vec3 circ_6_57 = vec3(6.993363857, 4.865468502, 9.127122879);\nconst vec3 circ_7_6d = vec3(-0.233089283, -0.195201054, 0.304877639);\nconst vec3 circ_d_72 = vec3(-0.233396858, -0.195526123, 0.304459751);\nconst vec3 circ_2_d3 = vec3(-0.233803824, -0.195686996, 0.304832131);\nconst vec3 circ_d_7 = vec3(-0.566095769, -1.000000000, 0.566095769);\nconst vec3 circ_5_6 = vec3(-1.000000000, -0.500074327, 0.500074327);\nconst vec3 circ_B = vec3(-1, -1, 1);\nconst vec3 circ_b = vec3(1, -1, 1);\nconst vec3 circ_2_1d = vec3(0.329032749, -0.295904785, 0.266857117);\nconst vec3 circ_d_2 = vec3(4.284636497, -1.000000000, 4.284636497);\n\nstruct Arc {\n    vec3 circle;\n    vec2 p1, p2;\n};\n\nconst Arc blob_a_boundary[6] =\n    Arc[6](Arc(circ_5_4, vec2(-1, 0), p54), Arc(circ_4_53, p54, p43),\n           Arc(circ_3_42, p43, p32), Arc(circ_2_31, p32, p21),\n           Arc(circ_1_20, p21, p10), Arc(circ_0_1, p10, vec2(1, 0)));\n\nconst Arc blob_A_boundary[7] =\n    Arc[7](Arc(vec3(-0.466788799, -0.142163649, 0.142120540), p54, p56),\n           Arc(vec3(6.993363857, 4.865468502, 9.127122879), p56, p67),\n           Arc(vec3(-0.233089283, -0.195201054, 0.304877639), p67, p7d),\n           Arc(vec3(-0.233396858, -0.195526123, 0.304459751), p7d, p2d),\n           Arc(vec3(-0.233803824, -0.195686996, 0.304832131), p2d, p32),\n           Arc(vec3(-0.145084500, -0.121531114, 0.189202532), p32, p43),\n           Arc(vec3(-0.466782153, 0.608771026, 0.608814120), p43, p54));\n\nconst Arc blob_B_boundary[7] =\n    Arc[7](Arc(circ_d_7, vec2(0, -1), p7d), Arc(circ_7_6d, p7d, p67),\n           Arc(circ_6_57, p67, p56), Arc(circ_5_6, p56, vec2(-1, 0)),\n           Arc(circ_B, vec2(-1, 0), vec2(-2, -1)),\n           Arc(circ_B, vec2(-2, -1), vec2(-1, -2)),\n           Arc(circ_B, vec2(-1, -2), vec2(0, -1)));\n\nconst Arc blob_b_boundary[7] = Arc[7](\n    Arc(circ_b, vec2(0, -1), vec2(1, -2)),\n    Arc(circ_b, vec2(1, -2), vec2(2, -1)), Arc(circ_b, vec2(2, -1), vec2(1, 0)),\n    Arc(circ_0_1, vec2(1, 0), p10), Arc(circ_1_20, p10, p21),\n    Arc(circ_2_1d, p21, p2d), Arc(circ_d_2, p2d, vec2(0, -1)));\n\nstruct QueryResult {\n    float dist;\n    vec2 pos;\n    vec2 tangent;\n};\n\nfloat cross2d(vec2 a, vec2 b) { return a.x * b.y - a.y * b.x; }\n\nQueryResult getArcInfo(vec2 p, Arc arc) {\n    vec2 c = arc.circle.xy;\n    float r = arc.circle.z;\n    vec2 p1 = arc.p1;\n    vec2 p2 = arc.p2;\n    vec2 v1 = p1 - c;\n    vec2 v2 = p2 - c;\n    vec2 vp = p - c;\n    float arc_direction = sign(cross2d(v1, v2));\n    if (sign(cross2d(v1, vp)) != -arc_direction &&\n        sign(cross2d(vp, v2)) != -arc_direction) {\n        vec2 q = c + normalize(vp) * r;\n        vec2 tangent_vec = q - c;\n        vec2 tangent =\n            normalize(arc_direction * vec2(-tangent_vec.y, tangent_vec.x));\n        return QueryResult(distance(p, q), q, tangent);\n    } else {\n        float d1 = distance(p, p1);\n        float d2 = distance(p, p2);\n        if (d1 < d2) {\n            vec2 tangent = normalize(arc_direction * vec2(-v1.y, v1.x));\n            return QueryResult(d1, p1, tangent);\n        } else {\n            vec2 tangent = normalize(arc_direction * vec2(-v2.y, v2.x));\n            return QueryResult(d2, p2, tangent);\n        }\n    }\n}\n\nfloat getCurveInfo_a(vec2 p) {\n    QueryResult final_result = QueryResult(1e6, vec2(0.0), vec2(1.0, 0.0));\n    if (p.x < -1.0 || p.x > 1.0) {\n        vec2 q = vec2(p.x, 0.0);\n        final_result = QueryResult(abs(p.y), q, vec2(1.0, 0.0));\n    }\n    for (int i = 0; i < 6; ++i) {\n        QueryResult arc_result = getArcInfo(p, blob_a_boundary[i]);\n        if (arc_result.dist < final_result.dist) {\n            final_result = arc_result;\n        }\n    }\n    vec2 vec_qp = p - final_result.pos;\n    float side = sign(cross2d(final_result.tangent, vec_qp));\n    return -final_result.dist * side;\n}\n\nfloat getCurveInfo(vec2 p, in Arc arcs[7]) {\n    QueryResult final_result = QueryResult(1e6, vec2(0.0), vec2(1.0, 0.0));\n    for (int i = 0; i < 7; ++i) {\n        QueryResult arc_result = getArcInfo(p, arcs[i]);\n        if (arc_result.dist < final_result.dist) {\n            final_result = arc_result;\n        }\n    }\n    vec2 vec_qp = p - final_result.pos;\n    float side = sign(cross2d(final_result.tangent, vec_qp));\n    return -final_result.dist * side;\n}\n\n\nconst Mobius transform_a = Mobius(vec2(0.82106938, -0.38329420499999994),\n                                  vec2(0.38329420499999994, -0.17893062),\n                                  vec2(-0.383294205, -1.82106938),\n                                  vec2(0.82106938, -0.38329420499999994));\nconst Mobius transform_b =\n    Mobius(vec2(1, -1), vec2(1, 0), vec2(1, 0), vec2(1, 1));\n\nconst Mobius transform_A = Mobius(\n    vec2(0.82106938, -0.383294205),\n    vec2(-0.38329420499999994, 0.17893062000000004),\n    vec2(0.3832942050000001, 1.82106938), vec2(0.82106938, -0.383294205));\n\nconst Mobius transform_B =\n    Mobius(vec2(1, 1), vec2(-1, 0), vec2(-1, 0), vec2(1, -1));\n\nconst Mobius identity = Mobius(vec2(1, 0), vec2(0), vec2(0), vec2(1, 0));\n\nMobius interpolateMobius(Mobius m1, Mobius m2, float t) {\n    return Mobius(mix(m1.a, m2.a, t), mix(m1.b, m2.b, t), mix(m1.c, m2.c, t),\n                  mix(m1.d, m2.d, t));\n}\nfloat sdf_d4_unbounded_region(vec2 p) {\n    // 1. SDF for \"outside unit circle\"\n    float sdf_unit_circle_out = length(p) - 1.0;\n    \n    // 2. SDF for \"y < 0\" region (lower half-plane)\n    float sdf_lower_half_plane = p.y;\n    \n    // 3. SDF for \"outside circ_b\"\n    float sdf_circ_b_out = length(p - circ_b.xy) - circ_b.z;\n    \n    // 4. SDF for \"outside circ_B\"\n    float sdf_circ_B_out = length(p - circ_B.xy) - circ_B.z;\n    \n    // 求所有区域的交集 (Intersection = max of all SDFs)\n    float d4 = max(sdf_unit_circle_out, sdf_lower_half_plane);\n    d4 = max(d4, sdf_circ_b_out);\n    d4 = max(d4, sdf_circ_B_out);\n    \n    return d4;\n}\nfloat inside_blob_a(vec2 p) { return getCurveInfo_a(p); }\nfloat inside_blob_b(vec2 p) { return getCurveInfo(p, blob_b_boundary); }\nfloat inside_blob_A(vec2 p) { return getCurveInfo(p, blob_A_boundary); }\nfloat inside_blob_B(vec2 p) { return getCurveInfo(p, blob_B_boundary); }\n\nvoid fold(inout vec2 p, inout float count, inout float deriv) {\n    for (int i = 0; i < MAX_ITER; i++) {\n        // 在循环开始时，就检查是否已经落入基本区域\n        float d1 = length(p - c5.xy) - c5.z;\n        float d2 = length(p - c2.xy) - c2.z;\n        float d3 = length(p - d.xy) - d.z;\n        float d4 = sdf_d4_unbounded_region(p);\n        \n        // 如果点p在任何一个基本区域内部，迭代就应该结束\n        if (d1 < 0. || d2 < 0. || d3 < 0. || d4 < 0.) {\n            break;\n        }\n\n        // 如果还没落入基本区域，才根据 blob 应用变换\n        // 注意：这里的 if 顺序和重叠区域处理可能也需要调整，但我们先解决核心问题\n        if (inside_blob_a(p) < 0.) {\n            deriv *= L2(cmul(transform_A.c, p) + transform_A.d);\n            p = applyMobius(transform_A, p);\n            count += 1.;\n            continue;\n        }\n        if (inside_blob_b(p) < 0.) {\n            deriv *= L2(cmul(transform_B.c, p) + transform_B.d);\n            p = applyMobius(transform_B, p);\n            count += 1.;\n            continue;\n        }\n        if (inside_blob_A(p) < 0.) {\n            deriv *= L2(cmul(transform_a.c, p) + transform_a.d);\n            p = applyMobius(transform_a, p);\n            count += 1.;\n            continue;\n        }\n        if (inside_blob_B(p) < 0.) {\n            deriv *= L2(cmul(transform_b.c, p) + transform_b.d);\n            p = applyMobius(transform_b, p);\n            count += 1.;\n            continue;\n        }\n        \n        // 如果既不在基本区域，也不在任何blob里，说明有问题，提前退出\n        break;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 pan_vals = texelFetch(iChannel0, ivec2(0, 0), 0);\n    zoom = texelFetch(iChannel0, ivec2(10, 10), 0).x;\n    float ab_anim_t = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n    float show_curves = texelFetch(iChannel0, ivec2(2, 0), 0).x;\n\n    Mobius final_transform = identity;\n    if (abs(ab_anim_t) > 0.001) {\n        if (ab_anim_t > 0.0) {\n            final_transform =\n                interpolateMobius(identity, transform_A, ab_anim_t);\n        } else {\n            final_transform =\n                interpolateMobius(identity, transform_B, abs(ab_anim_t));\n        }\n    }\n\n    vec3 finalCol = vec3(0);\n    for (int ii = 0; ii < AA; ii++) {\n        for (int jj = 0; jj < AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA) - 0.5;\n            vec2 uv = (2. * (fragCoord + o) - iResolution.xy -\n                       pan_vals.xy * pow(zoom, -1.0)) /\n                      iResolution.y;\n            uv *= zoom * 1.1;\n\n            float count = 0.;\n            float deriv = 1.;\n            vec2 p = uv;\n            deriv *= L2(cmul(final_transform.c, p) + final_transform.d);\n            p = applyMobius(final_transform, uv);\n            fold(p, count, deriv);\n\n            float id = 0.;\n            float d1 = length(p - c5.xy) - c5.z;\n            float d2 = length(p - c2.xy) - c2.z;\n            float d3 = length(p - d.xy) - d.z;\n            float d4 = sdf_d4_unbounded_region(p);\n            \n            vec3 col;\n            if (mode == 1) {\n             if (d1 <= 0.)\n                    col = vec3(1., 0.7, 0.7);\n                else if (d2 <= 0.)\n                    col = vec3(0.5, 0.1, 0.1);\n                else if (d3 <= 0. || d4 <= 0.) {\n                    float id2 = mod(count, 2.);\n                    if (id2 == 0.)\n                        col = vec3(.3, .3, 0.6);\n                    else\n                        col = vec3(1);\n                }\n            }\n            else {\n                if (d1 < 0. || d2 < 0.)\n                    col = vec3(1., 0.9, 0.3);\n                else if (d3 < 0. || d4 < 0.)\n                    col = vec3(1, 0, 0);\n                else\n                    col = vec3(1, 0.9, 0.3);\n            }\n            float d = min(min(d1, d2), min(d3, d4));\n            d = abs(d) * sqrt(abs(deriv)) / zoom;\n            \n            float lw = 0.03;\n            float aa = fwidth(d) * 2.;\n            col = mix(col, vec3(0), 1. - smoothstep(lw - aa, lw + aa, d));\n\n            if (show_curves > 0.5) {\n                vec2 z = uv;\n                deriv = sqrt(L2(cmul(final_transform.c, z) + final_transform.d));\n                z = applyMobius(final_transform, uv);\n\n                float lw = 0.012;\n                float sd_curve = inside_blob_a(z);\n                sd_curve = abs(sd_curve) * deriv / zoom;\n                aa = fwidth(sd_curve) * 2.;\n                col = mix(col, vec3(1),\n                          1. - smoothstep(lw - aa, lw + aa, sd_curve / zoom));\n\n                sd_curve = inside_blob_A(z);\n                sd_curve = abs(sd_curve) * deriv / zoom;\n                aa = fwidth(sd_curve) * 2.;\n                col = mix(col, vec3(1),\n                          1. - smoothstep(lw - aa, lw + aa, sd_curve / zoom));\n\n                sd_curve = inside_blob_b(z);\n                sd_curve = abs(sd_curve) * deriv / zoom;\n                aa = fwidth(sd_curve) * 2.;\n                col = mix(col, vec3(.2, 1., 0.3),\n                          1. - smoothstep(lw - aa, lw + aa, sd_curve / zoom));\n\n                sd_curve = inside_blob_B(z);\n                sd_curve = abs(sd_curve) * deriv / zoom;\n                aa = fwidth(sd_curve) * 2.;\n                col = mix(col, vec3(.2, 1., 0.3),\n                          1. - smoothstep(lw - aa, lw + aa, sd_curve / zoom));\n            }\n            finalCol += col;\n        }\n    }\n    finalCol /= float(AA * AA);\n    fragColor = vec4(finalCol, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int Key_A = 65;\nconst int Key_B = 66;\nconst int Key_C = 67;\nconst int Key_S = 83;\nconst int Key_W = 87;\n\nfloat ReadKeyInternal(int key, bool toggle) {\n    return textureLod(iChannel1,\n                      vec2((float(key) + .5) / 256.0, toggle ? .75 : .25), 0.0)\n        .x;\n}\n\nfloat ReadKey(int key) { return ReadKeyInternal(key, false); }\nfloat ReadKeyToggle(int key) { return ReadKeyInternal(key, true); }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // 默认情况下，保持上一帧的状态\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // 1. 平移状态存储在像素 (0,0)\n    if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n        vec4 prev_info = texelFetch(iChannel0, ivec2(0,0), 0);\n        float Zoom = texelFetch(iChannel0, ivec2(10,10), 0).x;\n        \n        float prev_pan_x = prev_info.x;\n        float prev_pan_y = prev_info.y;\n        float legacy_pan_x = prev_info.z;\n        float legacy_pan_y = prev_info.w;\n\n        // 当鼠标按下时，根据鼠标位移更新平移量\n        float pan_x = (iMouse.x - abs(iMouse.z)) * Zoom + legacy_pan_x;\n        float pan_y = (iMouse.y - abs(iMouse.w)) * Zoom + legacy_pan_y;\n\n        // 当鼠标松开时，记录当前平移量，为下一次拖动做准备\n        if (iMouse.z < 0.0) {\n            legacy_pan_x = prev_pan_x;\n            legacy_pan_y = prev_pan_y;\n            pan_x = legacy_pan_x;\n            pan_y = legacy_pan_y;\n        }\n        fragColor = vec4(pan_x, pan_y, legacy_pan_x, legacy_pan_y);\n    }\n\n    // 2. 缩放状态存储在像素 (10,10)\n    if (ivec2(fragCoord.xy) == ivec2(10, 10)) {\n        // .y 通道用作累加器\n        float x = texelFetch(iChannel0, ivec2(10,10), 0).y;\n        // 按 W 增加，按 S 减少\n        x += (ReadKey(Key_W) - ReadKey(Key_S)) * 0.5; // 减慢缩放速度\n        // 根据累加值计算缩放系数，.x 通道存储最终的 zoom 值\n        float Zoom = pow(1.1, -x); \n        fragColor = vec4(Zoom, x, 0.0, 0.0);\n    }\n    \n    // 3. 'a'/'b' 变换动画状态存储在像素 (1,0)\n    if (ivec2(fragCoord.xy) == ivec2(1, 0)) {\n        float prev_anim_t = texelFetch(iChannel0, ivec2(1,0), 0).x;\n\n        float key_a = ReadKey(Key_A);\n        float key_b = ReadKey(Key_B);\n        \n        // 目标值：按 a 为 1, 按 b 为 -1, 否则为 0\n        float target_t = 0.0;\n        if (key_a > 0.0) {\n            target_t = 1.0;\n        } else if (key_b > 0.0) {\n            target_t = -1.0;\n        }\n        \n        // 使用 mix 和 exp 实现平滑动画\n        float speed = 4.0;\n        float anim_t = mix(prev_anim_t, target_t, 1.0 - exp(-iTimeDelta * speed));\n        fragColor = vec4(anim_t, 0.0, 0.0, 1.0);\n    }\n    \n    // 4. 'c' 键切换状态存储在像素 (2,0)\n    if (ivec2(fragCoord.xy) == ivec2(2, 0)) {\n        vec4 prev_state = texelFetch(iChannel0, ivec2(2,0), 0);\n        float current_toggle = prev_state.x;\n        float prev_key_c_state = prev_state.y;\n        \n        float key_c = ReadKey(Key_C);\n        \n        // 检测按键的上升沿（按下瞬间）\n        if (key_c > 0.0 && prev_key_c_state == 0.0) {\n            current_toggle = 1.0 - current_toggle; // 翻转状态 (0 -> 1, 1 -> 0)\n        }\n        \n        // .x 存储切换状态，.y 存储上一帧的按键状态用于边缘检测\n        fragColor = vec4(current_toggle, key_c, 0.0, 1.0);\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec2 cmul(vec2 z, vec2 w) { return vec2(z.x * w.x - z.y * w.y, dot(z, w.yx)); }\nvec2 conj(vec2 z) { return vec2(z.x, -z.y); }\nvec2 cdiv(vec2 z, vec2 w) { return cmul(z, conj(w)) / dot(w, w); }\n\nstruct Mobius {\n    vec2 a, b, c, d;\n};\n\nvec2 applyMobius(Mobius m, vec2 z) {\n    return cdiv(cmul(m.a, z) + m.b, cmul(m.c, z) + m.d);\n}\n\nvec3 getCircleFromThreePoints(vec2 p1, vec2 p2, vec2 p3) {\n    // 使用行列式方法求解，参考 https://math.stackexchange.com/a/1460096\n    // 或 https://www.ambrsoft.com/TrigoCalc/Circle3D.htm\n    \n    float p1_sq = dot(p1, p1);\n    float p2_sq = dot(p2, p2);\n    float p3_sq = dot(p3, p3);\n\n    // 计算分母，如果接近0，则三点共线\n    float denominator = 2.0 * (p1.x * (p2.y - p3.y) - p1.y * (p2.x - p3.x) + p2.x * p3.y - p3.x * p2.y);\n    // 计算圆心坐标\n    float center_x = (p1_sq * (p2.y - p3.y) - p2_sq * (p1.y - p3.y) + p3_sq * (p1.y - p2.y)) / denominator;\n    float center_y = (p1_sq * (p3.x - p2.x) - p2_sq * (p3.x - p1.x) + p3_sq * (p2.x - p1.x)) / denominator;\n    \n    vec2 center = vec2(center_x, center_y);\n    float radius = distance(center, p1);\n    \n    return vec3(center, radius);\n}\n\n\nvec3 applyMobiusToCircle(Mobius m, vec3 C) {\n    vec2 center = C.xy;\n    float radius = C.z;\n    \n    // 如果原始圆是一个点 (半径很小)，直接变换该点并返回一个小圆\n    if (radius < 1e-6) {\n        return vec3(applyMobius(m, center), 1e-6);\n    }\n    \n    // 如果原始圆半径很大 (近似于直线)，处理会变得不稳定。\n    // 一个更鲁棒的实现需要单独处理直线的情况。\n    // 但对于普通圆，三点法是最好的。\n\n    // 1. 在原始圆上取三个不同的点\n    // 我们选择 (c+r,0), (c-r,0), (c,r) 这三个点来获得较好的数值稳定性\n    vec2 p1 = center + vec2(radius, 0.0);\n    vec2 p2 = center + vec2(-radius, 0.0);\n    vec2 p3 = center + vec2(0.0, radius);\n    \n    // 2. 将这三个点通过莫比乌斯变换进行映射\n    vec2 q1 = applyMobius(m, p1);\n    vec2 q2 = applyMobius(m, p2);\n    vec2 q3 = applyMobius(m, p3);\n    \n    // 3. 通过这三个新点确定新圆\n    return getCircleFromThreePoints(q1, q2, q3);\n}\n\nvec3 getOrthogonalCircle(vec3 C, vec2 z1, vec2 z2) {\n    vec2 c = C.xy;\n\n    // --- 解线性方程组 Ax=b ---\n    // a11*x + a12*y = b1\n    // a21*x + a22*y = b2\n\n    // 方程1: c' 在 z1, z2 的中垂线上\n    // dot(c', z2-z1) = dot((z1+z2)/2, z2-z1)\n    vec2 v_perp = z2 - z1; // 中垂线的法向量\n    float a11 = v_perp.x;\n    float a12 = v_perp.y;\n    float b1 = dot(0.5 * (z1 + z2), v_perp);\n\n    // 方程2: c' 在 C 于 z1 点的法线上 (这条法线是 C' 在 z1 的切线) 的法线上\n    // dot(c' - z1, z1 - c) = 0  => dot(c', z1-c) = dot(z1, z1-c)\n    vec2 v_tan = z1 - c; // C' 在 z1 的切线方向 (即C的法线方向)\n    float a21 = v_tan.x;\n    float a22 = v_tan.y;\n    float b2 = dot(z1, v_tan);\n\n    // 使用克莱姆法则解方程组\n    float det = a11 * a22 - a12 * a21;\n\n    // 如果 det 接近 0，说明中垂线和法线平行。\n    // 这发生在 z1, z2 是 C 的直径端点时，此时正交“圆”是一条直线。\n    if (abs(det) < 1e-9) {\n        // 返回一条通过 z1, z2 的直线（用大半径圆近似）\n        // 直线的“圆心”可以取中点，但方向垂直于 v_perp\n        vec2 mid_point = 0.5 * (z1 + z2);\n        vec2 dir = vec2(-v_perp.y, v_perp.x);\n        // 把圆心推到很远的地方\n        return vec3(mid_point + dir * 1e5, 1e5); \n    }\n\n    // 解出新圆心 c'\n    vec2 c_prime;\n    c_prime.x = (b1 * a22 - b2 * a12) / det;\n    c_prime.y = (b2 * a11 - b1 * a21) / det;\n\n    // 半径就是新圆心到 z1 (或 z2) 的距离\n    float r_prime = distance(c_prime, z1);\n\n    return vec3(c_prime, r_prime);\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"3XKSDK","date":"0","viewed":0,"name":"Fork Indra's pe neozhaolia 237","description":"Grandma's recipe, the 1/15 cusp group in which a^{15}B is parabolic","likes":0,"published":"Private","usePreview":0,"tags":["2d","fractal","mobius","circlepacking"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nFig 9.1 in Indra's pearls, the 1/15 cusp group.\nUsing Ford domain method.\n\nTranslated from knighty's evaldraw script.\n**ALL the difficult parts were done by knighty**.\nI'm lucky and grateful to have his selfless help.\n\nKeyboadr control:\n\n+ Press 1/2/3 to switch mode (default mode=2)\n+ Press w/s to zoom in/out\n+ Press a/b/c to see the action of a, b and successive action of a^i\n*/\n#define AA 3\n#define L2(x)  dot(x,x) \nconst int MAX_ITER = 150;\nconst vec2 ta = vec2(-1.9,0.1);\nconst vec2 tb = vec2(1.9,0.06);\n\nconst vec3 trap0 = vec3(-3.5, 0.1425, 0.25*(81.+0.285*0.2852));\nconst vec3 trap1 = vec3(-trap0.xy, trap0.z);\nconst vec3 trap2 = vec3(0.615, 0.016, 0.25*(0.77*0.77+0.032*0.032));\nconst vec3 trap3 = vec3(-trap2.xy, trap2.z);\nfloat zoom;\nint mode;\n\nvec2 cmul(vec2 z, vec2 w) { return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x); }\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float d2 = dot(w, w); if (d2 < 1e-15) return vec2(1e7);\n    return cmul(z, vec2(w.x, -w.y)) / d2;\n}\n\nvec2 csqrt(vec2 z) {\n    float r = length(z); float angle = atan(z.y, z.x);\n    return sqrt(r) * vec2(cos(0.5*angle), sin(0.5*angle));\n}\n\nvec2 solveQuadratic(vec2 b, vec2 c) {\n    vec2 delta = cmul(b, b) - 4. * c;\n    vec2 sqrt_delta = csqrt(delta);\n    return (-b + sqrt_delta) / 2.;\n}\n\nstruct Mobius { vec2 a, b, c, d; };\n\nvec2 applyMobius(Mobius m, vec2 z) {\n    vec2 num = cmul(m.a, z) + m.b;\n    vec2 den = cmul(m.c, z) + m.d;\n    return cdiv(num, den);\n}\n\nMobius mulMobius(Mobius m1, Mobius m2) {\n    return Mobius(cmul(m1.a, m2.a)+cmul(m1.b, m2.c), cmul(m1.a, m2.b)+cmul(m1.b, m2.d),\n                  cmul(m1.c, m2.a)+cmul(m1.d, m2.c), cmul(m1.c, m2.b)+cmul(m1.d, m2.d));\n}\n\nMobius invMobius(Mobius m) { return Mobius(m.d, -m.b, -m.c, m.a); }\n\nMobius interpolateMobius(Mobius m1, Mobius m2, float t) {\n    return Mobius(\n        mix(m1.a, m2.a, t),\n        mix(m1.b, m2.b, t),\n        mix(m1.c, m2.c, t),\n        mix(m1.d, m2.d, t)\n    );\n}\n\nconst Mobius identity = Mobius(vec2(1,0), vec2(0), vec2(0), vec2(1,0));\n \n\n//-----------------------------------------------------\n\nconst int N = 13;\nMobius transforms[N];\n\nvoid getGenerators(inout Mobius a, inout Mobius b) {\n    // compute tab\n    vec2 ta2 = cmul(ta, ta);\n    vec2 tb2 = cmul(tb, tb);\n    vec2 tab = solveQuadratic(-cmul(ta, tb), ta2 + tb2);\n    \n    // compute z0\n    vec2 num = cmul(tab - vec2(2, 0), tb);\n    vec2 den = cmul(tb, tab) - 2. * ta + cmul(vec2(0, 2), tab);\n    vec2 z0 = cdiv(num, den);\n    \n    // compute b\n    b.a = tb / 2. - vec2(0, 1);\n    b.d = tb / 2. + vec2(0, 1);\n    b.c = b.b = tb / 2.;\n    \n    // compute ab\n    Mobius ab = Mobius(\n        tab / 2.,\n        cdiv(tab / 2. - vec2(1, 0), z0),\n        cmul(tab / 2. + vec2(1, 0), z0),\n        tab / 2.\n    );\n    \n    // a = (ab)B\n    a = mulMobius(ab, invMobius(b));\n}\n\n\nvoid setupTransforms() {\n    Mobius a, b;\n    getGenerators(a, b);\n    \n    transforms[0] = a;\n    for (int i = 1; i < 8; i++)\n        transforms[i] = mulMobius(transforms[i-1], a);\n\n    transforms[8] = b;\n    Mobius A= invMobius(a);\n    Mobius B = invMobius(b);\n    transforms[9] = mulMobius(mulMobius(a, b), A);\n     transforms[10] = mulMobius(b, A);\n     Mobius tmp = a;\n     for (int i = 0; i < 8; i++)\n         tmp = mulMobius(tmp, b);\n         \n     transforms[11] = tmp; \n     \n        transforms[12] = mulMobius(transforms[11], b);\n}\n\n\nfloat sdTrapped(vec2 z) {\n    float d0 = (L2(z - trap0.xy) - trap0.z);\n     float d1 = (L2(z - trap1.xy) - trap1.z);\n      float d2 = (L2(z - trap2.xy) - trap2.z);\n       float d3 = (L2(z - trap3.xy) - trap3.z);\n    return min(min(-d1,-d0), min(d2, d3));\n}\n\nstruct BestTransformChoice {\n    vec2  z_new;\n    float nsd;\n    bool  found;\n};\n\nvoid fold(inout vec2 z, inout float count, inout float deriv) {\n    for (int i = 0; i < MAX_ITER; i++) {\n        \n        float min_nsd = 1.0;\n        BestTransformChoice best_choice;\n        best_choice.found = false;\n        for (int j = 0; j < N; j++) {\n            Mobius g = transforms[j];\n            vec2 den_g = cmul(g.c, z) + g.d;\n            float nsd_g = dot(den_g, den_g);\n\n            if (nsd_g < min_nsd) {\n                min_nsd = nsd_g;\n                best_choice.z_new = applyMobius(g, z);\n                best_choice.nsd = nsd_g;\n                best_choice.found = true;\n            }\n            Mobius g_inv = invMobius(g);\n            vec2 den_g_inv = cmul(g_inv.c, z) + g_inv.d;\n            float nsd_g_inv = dot(den_g_inv, den_g_inv);\n\n            if (nsd_g_inv < min_nsd) {\n                min_nsd = nsd_g_inv;\n                best_choice.z_new = applyMobius(g_inv, z);\n                best_choice.nsd = nsd_g_inv;\n                best_choice.found = true;\n            }\n        }\n        if (best_choice.found) {\n            z = best_choice.z_new;    \n            deriv *= best_choice.nsd;\n            count += 1.0;\n        }\n        else {\n            break;\n        }\n    }\n}\nvec3 hsv2rgb(vec3 c){\n    vec3 rgb = clamp(abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 getColor(vec2 z, vec2 uv, in float deriv) {\n    \n    float count = 1.0;\n    fold(z, count, deriv);\n    float id;\n    if (L2(z - trap0.xy) > trap0.z)\n        { id = 0.; }\n    else if (L2(z - trap1.xy) > trap1.z)\n        { id = 0.; }\n    else if (L2(z - trap2.xy) < trap2.z)\n        { id = 13.; }\n     else if (L2(z - trap3.xy) < trap3.z)\n        id = 13.;\n    \n    float d = abs(sdTrapped(z)) * abs(deriv) / zoom;\n    float aa = fwidth(d) * 2.;\n    float lw = 0.002;\n    if (mode == 0) {\n        vec3 col = 0.5+0.45 *cos(id + vec3(0,1,2));\n        col = mix(col, vec3(0), 1.-smoothstep(lw-aa, lw+aa, d));\n        return col;\n    }\n    else  {\n        if (count > float(MAX_ITER - 1))\n            return vec3(0);\n        if (count <= 1.)\n            return vec3(0);\n        float pi = 3.1415926;\n        float t = pi * count / 12.;\n        vec3 col = 0.5 + 0.5 * cos(t + .94*vec3(4.4, 3.2, 2.));\n        col = pow(col, vec3(2.2));\n        return col;\n    }\n}\n\nMobius getTransformForK(int k, const in Mobius B) {\n    const Mobius identity = Mobius(vec2(1,0), vec2(0), vec2(0), vec2(1,0));\n    if (k == 0) {\n        return identity;\n    }\n    Mobius a_k = transforms[k - 1];\n    return invMobius(a_k);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    setupTransforms();\n    Mobius a, b, A, B;\n    getGenerators(a, b);\n    A = invMobius(a);\n    B = invMobius(b);\n\n    vec4 pan_vals = textureLod(iChannel0, vec2(0.5, 0.5) / iResolution.xy, 0.0);\n    zoom = textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n    float ab_anim_t = textureLod(iChannel0, vec2(1.5, 0.5) / iResolution.xy, 0.0).x;\n    vec4 c_state = textureLod(iChannel0, vec2(2.5, 0.5) / iResolution.xy, 0.0);\n    \n    mode = int(textureLod(iChannel0, vec2(3.5, 0.5) / iResolution.xy, 0.0).x);\n    \n    int k_from = int(c_state.x);\n    int k_to = int(c_state.y);\n    float anim_timer = c_state.z;\n\n    const Mobius identity = Mobius(vec2(1,0), vec2(0), vec2(0), vec2(1,0)); // Moved identity here for use in getTransformForK\n    Mobius final_transform = identity;\n    if (abs(ab_anim_t) > 0.01) {\n        if (ab_anim_t > 0.0) {\n            final_transform = interpolateMobius(identity, A, ab_anim_t);\n        } else {\n            final_transform = interpolateMobius(identity, B, abs(ab_anim_t));\n        }\n    }\n    else if (k_to > 0 || anim_timer < 1.0) {\n        Mobius T_from = getTransformForK(k_from, B);\n        Mobius T_to = getTransformForK(k_to, B);\n        float t = smoothstep(0.0, 1.0, anim_timer);\n        \n        final_transform = interpolateMobius(T_from, T_to, t);\n    } \n    vec3 col = vec3(0);\n    for (int ii = 0; ii < AA; ii++) {\n        for (int jj = 0; jj < AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * (fragCoord + o) - iResolution.xy -\n                       pan_vals.xy * pow(zoom, -1.0)) /\n                      iResolution.y;\n            uv = uv.yx;\n            uv *= zoom * 1.4; \n            vec2 den_g = cmul(final_transform.c, uv) + final_transform.d;\n            float deriv = dot(den_g, den_g);\n            vec2 z = applyMobius(final_transform, uv);\n            col += getColor(z, uv, deriv);\n        }\n    }\n    col /= (float(AA) * float(AA));\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// https://www.shadertoy.com/view/ldyGzW\nconst int Key_A = 65;\nconst int Key_B = 66;\nconst int Key_C = 67;\nconst int Key_D = 68;\nconst int Key_E = 69;\nconst int Key_F = 70;\nconst int Key_G = 71;\nconst int Key_H = 72;\nconst int Key_I = 73;\nconst int Key_J = 74;\nconst int Key_K = 75;\nconst int Key_L = 76;\nconst int Key_M = 77;\nconst int Key_N = 78;\nconst int Key_O = 79;\nconst int Key_P = 80;\nconst int Key_Q = 81;\nconst int Key_R = 82;\nconst int Key_S = 83;\nconst int Key_T = 84;\nconst int Key_U = 85;\nconst int Key_V = 86;\nconst int Key_W = 87;\nconst int Key_X = 88;\nconst int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48;\nconst int Key_1 = 49;\nconst int Key_2 = 50;\nconst int Key_3 = 51;\nconst int Key_4 = 52;\nconst int Key_5 = 53;\nconst int Key_6 = 54;\nconst int Key_7 = 55;\nconst int Key_8 = 56;\nconst int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal(int key, bool toggle) {\n    return textureLod(iChannel1,\n                      vec2((float(key) + .5) / 256.0, toggle ? .75 : .25), 0.0)\n        .x;\n}\n\nfloat ReadKey(int key) { return ReadKeyInternal(key, false); }\n\nfloat ReadKeyToggle(int key) { return ReadKeyInternal(key, true); }\n\n// Storage Code For Pan and Zoom\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default output for unused pixels\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Pan State at (0,0)\n    if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n        vec4 prev_info = textureLod(iChannel0, vec2(0.0, 0.0), 0.0);\n        float Zoom =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n        float prev_pan_x = prev_info.x;\n        float prev_pan_y = prev_info.y;\n        float legacy_pan_x = prev_info.z;\n        float legacy_pan_y = prev_info.w;\n\n        float pan_x = (iMouse.x - abs(iMouse.z)) * Zoom + legacy_pan_x;\n        float pan_y = (iMouse.y - abs(iMouse.w)) * Zoom + legacy_pan_y;\n\n        if (iMouse.z < 0.0) {\n            legacy_pan_x = prev_pan_x;\n            legacy_pan_y = prev_pan_y;\n            pan_x = legacy_pan_x;\n            pan_y = legacy_pan_y;\n        }\n        fragColor = vec4(pan_x, pan_y, legacy_pan_x, legacy_pan_y);\n    }\n\n    // Zoom State at (10,10)\n    if (ivec2(fragCoord.xy) == ivec2(10, 10)) {\n        float x =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).y;\n        x += ReadKey(Key_W) - ReadKey(Key_S);\n        float Zoom = pow(2.71, -x * 0.05);\n        fragColor = vec4(Zoom, x, 0.0, 0.0);\n    }\n    \n    // Animation State at (1,0)\n    if (ivec2(fragCoord.xy) == ivec2(1, 0)) {\n        // Read previous animation state\n        float prev_anim_t = texelFetch(iChannel0, ivec2(1,0), 0).x;\n\n        float key_a = ReadKey(Key_A);\n        float key_b = ReadKey(Key_B);\n        \n        float target_t = 0.0;\n        if (key_a > 0.0) {\n            target_t = 1.0;\n        } else if (key_b > 0.0) {\n            target_t = -1.0;\n        }\n        \n        float speed = 4.0;\n        float anim_t = mix(prev_anim_t, target_t, 1.0 - exp(-iTimeDelta * speed));\n        fragColor = vec4(anim_t, 0.0, 0.0, 1.0);\n    }\n     if (ivec2(fragCoord.xy) == ivec2(2, 0)) {\n         vec4 prev_c_state = texelFetch(iChannel0, ivec2(2,0), 0);\n        float k_from = prev_c_state.x;\n        float k_to = prev_c_state.y;\n        float anim_timer = prev_c_state.z;\n        float prev_key_c_state = prev_c_state.w;\n        \n        float key_c = ReadKey(Key_C);\n        if (anim_timer < 1.0) {\n            float anim_speed = 2.0;\n            anim_timer += iTimeDelta * anim_speed;\n        }\n        anim_timer = min(anim_timer, 1.0);\n\n        if (key_c > 0.0 && prev_key_c_state == 0.0 && anim_timer >= 1.0) {\n            k_from = k_to;\n            k_to = mod(k_to + 1.0, 16.0);\n            anim_timer = 0.0;\n        }\n        \n        fragColor = vec4(k_from, k_to, anim_timer, key_c);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(3, 0)) {\n        float current_mode = texelFetch(iChannel0, ivec2(3,0), 0).x;\n        if(iFrame < 2) current_mode = 0.0; \n        if (ReadKey(Key_1) > 0.0) current_mode = 0.0;\n        if (ReadKey(Key_2) > 0.0) current_mode = 1.0;\n        if (ReadKey(Key_3) > 0.0) current_mode = 2.0;\n        fragColor = vec4(current_mode, 0.0, 0.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"t3KSDV","date":"0","viewed":0,"name":"thurston","description":"nice","likes":0,"published":"Private","usePreview":0,"tags":["2d"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define N_CORNERS 4\n#define N_TOTAL (N + N_CORNERS)\n\n// --- Coordinate Transformation and Helpers ---\n\n// Get point from Buffer A. It's already in the uv-like coordinate space.\nvec2 getPoint(int i) {\n    return texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n}\n\n// Check for an edge in Buffer B\nbool hasEdge(int i, int j) {\n    // Make sure indices are ordered for the symmetric matrix optimization\n    return texelFetch(iChannel1, ivec2(min(i,j), max(i,j)), 0).r > 0.5;\n}\n\n// SDF for a line segment in our abstract coordinate space\nfloat sdfLine(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n// Check if point p is inside triangle (a, b, c)\nbool inTriangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec3 w; // Barycentric coordinates\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    w.y = (d11 * d20 - d01 * d21) / denom;\n    w.z = (d00 * d21 - d01 * d20) / denom;\n    w.x = 1.0 - w.y - w.z;\n    return all(greaterThanEqual(w, vec3(0.0)));\n}\n\n// --- Main Rendering ---\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Convert current pixel coordinate to our new normalized coordinate system\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.1, 0.1, 0.2); // Background color\n    \n    // --- 1. Draw Faces (Triangles) ---\n    for (int i = 0; i < N_TOTAL; i++) {\n        for (int j = i + 1; j < N_TOTAL; j++) {\n            if (!hasEdge(i, j)) continue;\n            for (int k = j + 1; k < N_TOTAL; k++) {\n                if (hasEdge(j, k) && hasEdge(i, k)) {\n                    vec2 p_i = getPoint(i);\n                    vec2 p_j = getPoint(j);\n                    vec2 p_k = getPoint(k);\n                    \n                    if (inTriangle(uv, p_i, p_j, p_k)) {\n                        vec3 tri_color = 0.5 + 0.5 * cos(vec3(i,j,k) * 0.3 + vec3(0,2,4));\n                        col = mix(col, tri_color, 0.6);\n                    }\n                }\n            }\n        }\n    }\n\n    // --- 2. Draw Edges ---\n    // We define thickness in terms of our normalized coordinate system\n    float line_thickness = 2.0 / iResolution.y; \n    float edge_dist = 1e6;\n    for (int i = 0; i < N_TOTAL; i++) {\n        for (int j = i + 1; j < N_TOTAL; j++) {\n            if (hasEdge(i, j)) {\n                edge_dist = min(edge_dist, sdfLine(uv, getPoint(i), getPoint(j)));\n            }\n        }\n    }\n    col = mix(vec3(0.9), col, smoothstep(line_thickness * 0.5, line_thickness * 1.5, edge_dist));\n    \n    // --- 3. Draw Points ---\n    float point_radius = 6.0 / iResolution.y;\n    float point_dist = 1e6;\n    for (int i = 0; i < N_TOTAL; i++) {\n        // Calculate distance in the normalized space\n        point_dist = min(point_dist, length(uv - getPoint(i)));\n    }\n    col = mix(vec3(1.0, 0.8, 0.0), col, smoothstep(point_radius, point_radius + (1.0/iResolution.y), point_dist));\n\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define N_CORNERS 4\n#define N_TOTAL (N+ N_CORNERS) // Total points: 32\n\n// --- Helper: Pseudo-random number generator ---\nvec2 hash( vec2 p ) {\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123); // Output in [-1, 1] range\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2(fragCoord);\n\n    // We only use the first N_TOTAL pixels in the first row.\n    if (px.y > 0 || px.x >= N_TOTAL) {\n        discard;\n        return;\n    }\n    \n    // --- Feedback loop to preserve data after frame 0 ---\n    // Make sure iChannel0 is set to Buffer A itself!\n    if (iFrame > 0) {\n        fragColor = texelFetch(iChannel0, px, 0);\n        return;\n    }\n\n    // --- On Frame 0: Generate all points ---\n    vec2 point_pos;\n    float aspect = iResolution.x / iResolution.y;\n\n    if (px.x < N_CORNERS) {\n        // --- Generate the 4 corner points ---\n        // We use a bit of math to generate the 4 corners from indices 0, 1, 2, 3\n        // index 0: (-aspect, -1)\n        // index 1: ( aspect, -1)\n        // index 2: (-aspect,  1)\n        // index 3: ( aspect,  1)\n        float x_sign = (px.x % 2 == 0) ? -1.0 : 1.0;\n        float y_sign = (px.x < 2) ? -1.0 : 1.0;\n        point_pos = vec2(x_sign * aspect, y_sign);\n\n    } else {\n        // --- Generate N_RANDOM random points within the region ---\n        // Use the pixel's x-coordinate as a seed.\n        // The hash function gives a point in [-1, 1]x[-1, 1].\n        // We scale it to fit our [-aspect, aspect]x[-1, 1] region.\n        vec2 random_unit = hash(vec2(px.x, 1.0));\n        point_pos = random_unit * vec2(aspect, 1.0);\n    }\n\n    // Store the point's coordinates in rg channels.\n    fragColor = vec4(point_pos, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n#define N_CORNERS 4\n#define N_TOTAL (N + N_CORNERS)\n\n// Fetches the position of the i-th point from Buffer A (iChannel0)\n// The point is already in our desired coordinate system.\nvec2 getPoint(int i) {\n    return texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n}\n\n// ... (The inCircumcircle function remains exactly the same as before) ...\nfloat inCircumcircle(vec2 p_a, vec2 p_b, vec2 p_c, vec2 p_test) {\n    float a_sq = dot(p_a, p_a);\n    float b_sq = dot(p_b, p_b);\n    float c_sq = dot(p_c, p_c);\n    float test_sq = dot(p_test, p_test);\n\n    mat4 m = mat4(\n        p_a.x, p_a.y, a_sq, 1.0,\n        p_b.x, p_b.y, b_sq, 1.0,\n        p_c.x, p_c.y, c_sq, 1.0,\n        p_test.x, p_test.y, test_sq, 1.0\n    );\n    \n    float orientation = (p_b.x - p_a.x) * (p_c.y - p_a.y) - (p_b.y - p_a.y) * (p_c.x - p_a.x);\n    return determinant(m) * sign(orientation);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2(fragCoord);\n    int i = px.x;\n    int j = px.y;\n\n    // We are building an N_TOTAL x N_TOTAL adjacency matrix\n    if (i >= N_TOTAL || j >= N_TOTAL || i == j) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    // Symmetric matrix optimization\n    if (i > j) {\n        fragColor = texelFetch(iChannel1, ivec2(j, i), 0);\n        return;\n    }\n\n    vec2 p_i = getPoint(i);\n    vec2 p_j = getPoint(j);\n    \n    bool is_delaunay_edge = false;\n    \n    // Check all possible triangles using the edge (i, j)\n    for (int k = 0; k < N_TOTAL; k++) {\n        if (k == i || k == j) continue;\n        \n        vec2 p_k = getPoint(k);\n        \n        // Collinearity check\n        vec2 v_ik = p_k - p_i;\n        vec2 v_ij = p_j - p_i;\n        if (abs(v_ik.x * v_ij.y - v_ik.y * v_ij.x) < 0.0001) continue;\n\n        bool is_empty_circle = true;\n        // Check all other points\n        for (int m = 0; m < N_TOTAL; m++) {\n            if (m == i || m == j || m == k) continue;\n            \n            vec2 p_m = getPoint(m);\n            if (inCircumcircle(p_i, p_j, p_k, p_m) > 0.0001) { // Add a small epsilon\n                is_empty_circle = false;\n                break;\n            }\n        }\n        \n        if (is_empty_circle) {\n            is_delaunay_edge = true;\n            break;\n        }\n    }\n    \n    if (is_delaunay_edge) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } else {\n        fragColor = vec4(0.0);\n    }\n    }","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define N 20","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"3XVSWd","date":"1755187131","viewed":184,"name":"Indra's pearls, Fig 7.3","description":"The glowing gasket","likes":20,"published":"Public API","usePreview":0,"tags":["fractal","mobius","apollonian","gasket"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe glowing gasket — Fig. 7.3 of Indra's Pearls\n\nTwo fundamental domains, each one is a one-punctured torus.\n\nKeyboard controls:\n  1/2/3  - Switch mode (limit set, circle packing, tiling)\n  w/s    - Zoom in / out\n  a/b    - Show the action of generators a / b\n  c      - Show the four circles C_a, C_A, C_b, C_B\n*/\n\n#define AA 2\n#define CURVE_THICKNESS 0.015\n\nconst float PI = 3.14159265359;\nconst int MAX_ITER = 100;\n\nfloat zoom;\nint mode;\nint draw_curve;\n\n#define L2(x) dot(x, x)\n\nbool Equal(vec2 z, vec2 a, float deriv) {\n    float k = 4. + 4. * L2(z) ;\n    return k * length(z - a) * deriv / zoom < CURVE_THICKNESS;\n}\n\nvec2 u1, u2;\n\nvec2 get_tangent(vec3 c, vec3 d) {\n    vec2 dir = normalize(c.xy - d.xy);\n    return dir * d.r + d.xy;\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float d2 = dot(w, w);\n    if (d2 < 1e-15)\n        return vec2(1e7);\n    return cmul(z, vec2(w.x, -w.y)) / d2;\n}\n\nstruct Mobius {\n    vec2 a, b, c, d;\n};\n\nvec2 applyMobius(Mobius m, vec2 z) {\n    vec2 num = cmul(m.a, z) + m.b;\n    vec2 den = cmul(m.c, z) + m.d;\n    return cdiv(num, den);\n}\n\nMobius invMobius(Mobius m) { return Mobius(m.d, -m.b, -m.c, m.a); }\n\nMobius interpolateMobius(Mobius m1, Mobius m2, float t) {\n    return Mobius(mix(m1.a, m2.a, t), mix(m1.b, m2.b, t), mix(m1.c, m2.c, t),\n                  mix(m1.d, m2.d, t));\n}\n\nconst Mobius identity = Mobius(vec2(1, 0), vec2(0), vec2(0), vec2(1, 0));\n\nconst Mobius a = Mobius(vec2(1, 0), vec2(0), vec2(0, -2), vec2(1, 0));\n\nconst Mobius b = Mobius(vec2(1, -1), vec2(1, 0), vec2(1, 0), vec2(1, 1));\n\nMobius A, B;\n\nvoid setup() {\n    A = invMobius(a);\n    B = invMobius(b);\n    u1 = get_tangent(vec3(0, -0.25, 0.25), vec3(-1, -1, 1));\n    u2 = get_tangent(vec3(0, -0.25, 0.25), vec3(1, -1, 1));\n}\n\nconst float rr = 0.25;\nconst float ss = 1. / 3.;\nconst vec3 circ_B = vec3(-1, -1, 1);\nconst vec3 circ_b = vec3(1, -1, 1);\nconst vec3 circ_A = vec3(0, -rr, rr);\nconst vec3 trap1 = vec3(-0.5, 0, 0.5);\nconst vec3 trap2 = vec3(0.5, 0, 0.5);\nconst vec3 trap3 = vec3(0., ss - 1., ss);\n\nfloat sdTrapped(vec2 z) {\n    float db = length(z - circ_b.xy) - circ_b.z;\n    float dB = length(z - circ_B.xy) - circ_B.z;\n    float dA = length(z - circ_A.xy) - circ_A.z;\n    float da = -z.y;\n    return min(min(da, dA), min(db, dB));\n}\n\nvoid fold(inout vec2 z, inout float count, inout float deriv) {\n    for (int i = 0; i < MAX_ITER; i++) {\n        bool found = true;\n        if (z.y > 0.) {\n            deriv *= L2(cmul(A.c, z) + A.d);\n            z = applyMobius(A, z);\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (length(z - circ_A.xy) < circ_A.z) {\n            deriv *= L2(cmul(a.c, z) + a.d);\n            z = applyMobius(a, z);\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (length(z - circ_b.xy) < circ_b.z) {\n            deriv *= L2(cmul(B.c, z) + B.d);\n            z = applyMobius(B, z);\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (length(z - circ_B.xy) < circ_B.z) {\n            deriv *= L2(cmul(b.c, z) + b.d);\n            z = applyMobius(b, z);\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (found)\n            break;\n    }\n}\n\nvec3 getColor(vec2 z, in float deriv) {\n    float scale = deriv;\n    vec2 w = z;\n    float count = 0.0;\n    fold(z, count, deriv);\n    float id;\n    vec2 pts[] =\n            vec2[](vec2(-1, 0), vec2(1, 0), vec2(0), vec2(0, -1), vec2(0,1),u1, u2);\n    if (dot(z, z) > 1.) {\n        id = 0.;\n    } else if (length(z - trap1.xy) < trap1.z) {\n        id = 1.;\n    } else if (length(z - trap2.xy) < trap2.z) {\n        id = 1.;\n    } else if (length(z - trap3.xy) < trap3.z) {\n        id = 2.;\n    } else\n        id = 2.;\n\n    vec3 col;\n    if (mode == 0) {\n        if (count >= float(MAX_ITER))\n            col = vec3(0);\n        else if (count == 0.)\n            col = vec3(0);\n        else {\n            col = 0.5 + 0.5 * cos(\n                count * PI / 15. + vec3(4.4, 3.2, 2.)\n            );\n            \n        }\n    } else if (mode == 1) {\n\n        if (id == 1.) {\n            col = vec3(1, 0.5, 0.75);\n        } else {\n            col = vec3(1);\n        }\n        for (int i = 0; i < pts.length(); i++) {\n            if (Equal(z, pts[i], deriv)) {\n                col = vec3(0);\n                break;\n            }\n        }\n    }\n    else {\n        float k = mod(count, 2.);\n        col = 0.5 + 0.45 * cos(k * 9. + vec3(0, 1, 2));\n        if (id != 1.) {\n            if (k == 1.)\n                col = vec3(1);\n            else\n                col = vec3(0.9, 0.9, 0.97);\n        }\n        for (int i = 0; i < pts.length(); i++) {\n            if (Equal(z, pts[i], deriv)) {\n                col = vec3(0);\n                break;\n            }\n        }\n    }\n    if (draw_curve > 0) {\n        float d1 = min(-w.y, length(w - circ_A.xy) - circ_A.z);\n        float d2 = length(w - circ_b.xy) - circ_b.z;\n        d2 = min(d2, length(w - circ_B.xy) - circ_B.z);\n        d1 = abs(d1) * scale / zoom;\n        d2 = abs(d2) * scale / zoom;\n        float lw = 0.0125;\n        float aa1 = fwidth(d1);\n        float aa2 = fwidth(d2);\n        col = mix(col, vec3(0, 0, 1), 1. - smoothstep(lw - aa2, lw + aa2, d2));\n        col = mix(col, vec3(1, 0, 0), 1. - smoothstep(lw - aa1, lw + aa1, d1));\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    setup();\n\n    vec4 pan_vals = textureLod(iChannel0, vec2(0.5, 0.5) / iResolution.xy, 0.0);\n    zoom = textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n    float ab_anim_t =\n        textureLod(iChannel0, vec2(1.5, 0.5) / iResolution.xy, 0.0).x;\n    vec4 c_state = textureLod(iChannel0, vec2(2.5, 0.5) / iResolution.xy, 0.0);\n\n    mode = int(textureLod(iChannel0, vec2(3.5, 0.5) / iResolution.xy, 0.0).x);\n    draw_curve =\n        int(textureLod(iChannel0, vec2(4.5, 0.5) / iResolution.xy, 0.0).x);\n    int k_from = int(c_state.x);\n    int k_to = int(c_state.y);\n    float anim_timer = c_state.z;\n\n    Mobius final_transform = identity;\n    if (abs(ab_anim_t) > 0.01) {\n        if (ab_anim_t > 0.0) {\n            final_transform = interpolateMobius(identity, A, ab_anim_t);\n        } else {\n            final_transform = interpolateMobius(identity, B, abs(ab_anim_t));\n        }\n    }\n    vec3 col = vec3(0);\n    for (int ii = 0; ii < AA; ii++) {\n        for (int jj = 0; jj < AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * (fragCoord + o) - iResolution.xy -\n                       pan_vals.xy * pow(zoom, -1.0)) /\n                      iResolution.y;\n            uv *= zoom * 1.05;\n            vec2 den_g = cmul(final_transform.c, uv) + final_transform.d;\n            float deriv = dot(den_g, den_g);\n            vec2 z = applyMobius(final_transform, uv);\n            col += getColor(z, deriv);\n        }\n    }\n    col /= (float(AA) * float(AA));\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// https://www.shadertoy.com/view/ldyGzW\nconst int Key_A = 65;\nconst int Key_B = 66;\nconst int Key_C = 67;\nconst int Key_D = 68;\nconst int Key_E = 69;\nconst int Key_F = 70;\nconst int Key_G = 71;\nconst int Key_H = 72;\nconst int Key_I = 73;\nconst int Key_J = 74;\nconst int Key_K = 75;\nconst int Key_L = 76;\nconst int Key_M = 77;\nconst int Key_N = 78;\nconst int Key_O = 79;\nconst int Key_P = 80;\nconst int Key_Q = 81;\nconst int Key_R = 82;\nconst int Key_S = 83;\nconst int Key_T = 84;\nconst int Key_U = 85;\nconst int Key_V = 86;\nconst int Key_W = 87;\nconst int Key_X = 88;\nconst int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48;\nconst int Key_1 = 49;\nconst int Key_2 = 50;\nconst int Key_3 = 51;\nconst int Key_4 = 52;\nconst int Key_5 = 53;\nconst int Key_6 = 54;\nconst int Key_7 = 55;\nconst int Key_8 = 56;\nconst int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal(int key, bool toggle) {\n    return textureLod(iChannel1,\n                      vec2((float(key) + .5) / 256.0, toggle ? .75 : .25), 0.0)\n        .x;\n}\n\nfloat ReadKey(int key) { return ReadKeyInternal(key, false); }\n\nfloat ReadKeyToggle(int key) { return ReadKeyInternal(key, true); }\n\n// Storage Code For Pan and Zoom\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default output for unused pixels\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Pan State at (0,0)\n    if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n        vec4 prev_info = textureLod(iChannel0, vec2(0.0, 0.0), 0.0);\n        float Zoom =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n        float prev_pan_x = prev_info.x;\n        float prev_pan_y = prev_info.y;\n        float legacy_pan_x = prev_info.z;\n        float legacy_pan_y = prev_info.w;\n\n        float pan_x = (iMouse.x - abs(iMouse.z)) * Zoom + legacy_pan_x;\n        float pan_y = (iMouse.y - abs(iMouse.w)) * Zoom + legacy_pan_y;\n\n        if (iMouse.z < 0.0) {\n            legacy_pan_x = prev_pan_x;\n            legacy_pan_y = prev_pan_y;\n            pan_x = legacy_pan_x;\n            pan_y = legacy_pan_y;\n        }\n        fragColor = vec4(pan_x, pan_y, legacy_pan_x, legacy_pan_y);\n    }\n\n    // Zoom State at (10,10)\n    if (ivec2(fragCoord.xy) == ivec2(10, 10)) {\n        float x =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).y;\n        x += ReadKey(Key_W) - ReadKey(Key_S);\n        float Zoom = pow(2.71, -x * 0.05);\n        fragColor = vec4(Zoom, x, 0.0, 0.0);\n    }\n\n    // Animation State at (1,0)\n    if (ivec2(fragCoord.xy) == ivec2(1, 0)) {\n        // Read previous animation state\n        float prev_anim_t = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n\n        float key_a = ReadKey(Key_A);\n        float key_b = ReadKey(Key_B);\n\n        float target_t = 0.0;\n        if (key_a > 0.0) {\n            target_t = 1.0;\n        } else if (key_b > 0.0) {\n            target_t = -1.0;\n        }\n        float speed = 3.;\n        float anim_t =\n            mix(prev_anim_t, target_t, 1.0 - exp(-iTimeDelta * speed));\n        fragColor = vec4(anim_t, 0.0, 0.0, 1.0);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(2, 0)) {\n        vec4 prev_c_state = texelFetch(iChannel0, ivec2(2, 0), 0);\n        float k_from = prev_c_state.x;\n        float k_to = prev_c_state.y;\n        float anim_timer = prev_c_state.z;\n        float prev_key_c_state = prev_c_state.w;\n\n        float key_c = ReadKey(Key_C);\n        if (anim_timer < 1.0) {\n            float anim_speed = 1.;\n            anim_timer += iTimeDelta * anim_speed;\n        }\n        anim_timer = min(anim_timer, 1.0);\n\n        if (key_c > 0.0 && prev_key_c_state == 0.0 && anim_timer >= 1.0) {\n            k_from = k_to;\n            k_to = mod(k_to + 1.0, 16.0);\n            anim_timer = 0.0;\n        }\n\n        fragColor = vec4(k_from, k_to, anim_timer, key_c);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(3, 0)) {\n        float current_mode = texelFetch(iChannel0, ivec2(3, 0), 0).x;\n        if (iFrame < 2)\n            current_mode = 0.0;\n        if (ReadKey(Key_1) > 0.0)\n            current_mode = 0.0;\n        if (ReadKey(Key_2) > 0.0)\n            current_mode = 1.0;\n        if (ReadKey(Key_3) > 0.0)\n            current_mode = 2.0;\n\n        fragColor = vec4(current_mode, 0.0, 0.0, 1.0);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(4, 0)) {\n        vec4 prev_state = texelFetch(iChannel0, ivec2(4, 0), 0);\n        float current_toggle = prev_state.x;\n        float prev_key_c_state = prev_state.y;\n\n        float key_c = ReadKey(Key_C);\n        if (key_c > 0.0 && prev_key_c_state == 0.0) {\n            current_toggle = 1.0 - current_toggle;\n        }\n        fragColor = vec4(current_toggle, key_c, 0.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"tfXyRr","date":"0","viewed":0,"name":"Fork Indra's pe neozhaolia 098","description":"The glowing gasket","likes":0,"published":"Private","usePreview":0,"tags":["2d","fractal","mobius","gasket"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe glowing gasket — Fig. 7.3 of Indra's Pearls\n\nTwo fundamental domains, each one is a one-punctured torus.\n\nKeyboard controls:\n  1/2/3  - Switch mode\n  w/s    - Zoom in / out\n  a/b    - Show the action of generators a / b\n  c      - Show the four circles C_a, C_A, C_b, C_B\n*/\n\n#define AA 2\n\nconst float PI = 3.14159265359;\nconst int MAX_ITER = 100;\n\nfloat zoom;\nint mode;\nint draw_curve;\n\n#define L2(x) dot(x, x)\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float d2 = dot(w, w);\n    if (d2 < 1e-15)\n        return vec2(1e7);\n    return cmul(z, vec2(w.x, -w.y)) / d2;\n}\n\nstruct Mobius {\n    vec2 a, b, c, d;\n};\n\nvec2 applyMobius(Mobius m, vec2 z) {\n    vec2 num = cmul(m.a, z) + m.b;\n    vec2 den = cmul(m.c, z) + m.d;\n    return cdiv(num, den);\n}\n\nMobius invMobius(Mobius m) { return Mobius(m.d, -m.b, -m.c, m.a); }\n\nMobius interpolateMobius(Mobius m1, Mobius m2, float t) {\n    return Mobius(mix(m1.a, m2.a, t), mix(m1.b, m2.b, t), mix(m1.c, m2.c, t),\n                  mix(m1.d, m2.d, t));\n}\n\nconst Mobius identity = Mobius(vec2(1, 0), vec2(0), vec2(0), vec2(1, 0));\n\nconst Mobius a = Mobius(vec2(1, 0), vec2(0, 0), vec2(-2, 0), vec2(1, 0));\nconst Mobius A = Mobius(vec2(1, 0), vec2(0, 0), vec2(2, 0), vec2(1, 0));\n\nconst Mobius b = Mobius(vec2(1, 0), vec2(2, 0), vec2(0, 0), vec2(1, 0));\nconst Mobius B = Mobius(vec2(1, 0), vec2(-2, 0), vec2(0, 0), vec2(1, 0));\nconst Mobius U2P = Mobius(\n    vec2(0, -1), vec2(0, -1), vec2(1, 0), vec2(0, -1)\n);\nconst Mobius P2U = Mobius(\n    vec2(0, 1), vec2(0, 1), vec2(-1, 0), vec2(1, 0)\n);\nconst float rr = 0.5;\nconst vec3 circ_a = vec3(-rr, 0, rr);\nconst vec3 circ_A = vec3(rr, 0, rr);\n\n// A simple 1D hash function - takes a float, returns a float\nfloat hash1(float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\n// A hash function that returns a more \"structured\" random number, good for patterns\nfloat hash1b(float n) {\n    // The constants are just large prime numbers for good pseudo-random properties\n    return fract(sin(n*12.9898)*43758.5453);\n}\nfloat sdTrapped(vec2 z) {\n    float da = length(z - circ_a.xy) - circ_a.z;\n    float dA = length(z - circ_A.xy) - circ_A.z;\n    float dB = z.x + 1.;\n    float db = 1. - z.x;\n    return min(min(da, dA), min(db, dB));\n}\n\nvoid fold(inout vec2 z, inout float count, inout float deriv) {\n    for (int i = 0; i < MAX_ITER; i++) {\n        bool found = true;\n        if (length(z - circ_a.xy) < circ_a.z) {\n            deriv *= L2(cmul(A.c, z) + A.d);\n            z = applyMobius(A, z);\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (length(z - circ_A.xy) < circ_A.z) {\n            deriv *= L2(cmul(a.c, z) + a.d);\n            z = applyMobius(a, z);\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (z.x > 1.) {\n            z = applyMobius(B, z);\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (z.x < -1.) {\n            z = applyMobius(b, z);\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (found)\n            break;\n    }\n}\n\nvec3 getColor(vec2 z, in float deriv, vec2 fragCoord) {\n    vec2 w = z; // The coordinate in the Upper-Half-Plane\n    float count = 0.0;\n    float scale = deriv;\n    // We need a separate variable for the coloring decision\n    vec2 z_for_coloring = z;\n    float count_for_coloring = 0.0;\n    float deriv_for_coloring = deriv;\n    fold(z_for_coloring, count_for_coloring, deriv_for_coloring);\n    \n    // Determine the base color and if we are in a hatchable area\n    float id = (z_for_coloring.x < 0.) ? 0. : 1.;\n    bool in_hatch_area = (id == 1.0);\n    vec3 col = in_hatch_area ? vec3(.6, .9, 0.75) : vec3(1.0);\n    \n    // --- START OF BOUNDARY-AWARE HATCHING LOGIC ---\n    \n    // 1. Parameters\n    float line_spacing = 0.09; // The distance between each horizontal line\n    \n    // 2. Check if the current pixel's y-level is designated for a line\n    float lane_id = floor(w.y / line_spacing);\n    float lane_pos = fract(w.y / line_spacing);\n    \n    // We only draw a line if we are on a specific \"lane\"\n    // and if the base color is the one we want to hatch\n    if (abs(lane_pos - 0.5) < 0.05 && in_hatch_area) { // Draw line in the middle of the lane\n        \n        // 3. Find the left and right boundaries of the region at this y-level\n        // We use a simple root-finding (bisection-like) method\n        float step = 0.1; // Initial search step, can be adjusted\n        \n        // Search for the left boundary (-x direction)\n        vec2 left_pos = w;\n        bool left_boundary_found = false;\n        for(int i = 0; i < 15; i++) {\n            vec2 p = left_pos;\n            float c = 0.0, drv = deriv;\n            fold(p, c, drv);\n            if (p.x < 0.0) { // We crossed into the white region\n                left_pos += vec2(step, 0.0);\n                step *= 0.5; // Refine search\n            } else {\n                left_pos -= vec2(step, 0.0);\n                left_boundary_found = true;\n            }\n        }\n        \n        // Search for the right boundary (+x direction)\n        vec2 right_pos = w;\n        step = 0.1; // Reset step\n        bool right_boundary_found = false;\n        for(int i = 0; i < 15; i++) {\n            vec2 p = right_pos;\n            float c = 0.0, drv = deriv;\n            fold(p, c, drv);\n            if (p.x < 0.0) { // We are still in the white region (error case) or started there\n                // This case is complex, for simplicity we assume we start in the green region\n                // If not, we just won't find a boundary\n                break;\n            } else { // We are in the green region\n                right_pos += vec2(step, 0.0);\n                right_boundary_found = true;\n            }\n        }\n        \n        // After finding we are in green, we need to find where it becomes white\n        right_pos = w;\n        step = 0.1;\n        for(int i=0; i<15; i++) {\n             vec2 p = right_pos;\n             float c = 0.0, drv = deriv;\n             fold(p,c,drv);\n             if (p.x > 0.0) { // Still in green\n                 right_pos += vec2(step, 0.0);\n             } else { // Crossed to white\n                 right_pos -= vec2(step, 0.0);\n                 step *= 0.5;\n             }\n        }\n        \n        // 4. If both boundaries are valid, draw the line\n        if (left_boundary_found && right_boundary_found) {\n            vec3 hatch_color = vec3(0.3, 0.5, 0.4);\n\n        // 调用铅笔纹理\n        vec2 qq = w * 8.0 * (iResolution.y / 450.0);\n        vec3 pencil_col = pencil(hatch_color, qq, 4);\n\n        // 混合原色与铅笔纹理\n        col = mix(hatch_color, pencil_col, 0.85);\n        }\n    }\n    \n    // --- END OF HATCHING LOGIC ---\n    \n    // Draw the main black boundary lines on top of everything\n    vec2 p_boundary = w;\n    float c_boundary = 0.0, drv_boundary = deriv;\n    fold(p_boundary, c_boundary, drv_boundary);\n    float d = abs(sdTrapped(p_boundary)) / zoom;\n    float d2 = abs(p_boundary.x) / zoom;\n    float aa2 = fwidth(d2) / 2.;\n    float aa = fwidth(d) / 2.0;\n    float lw = 0.012;\n    col = mix(col, vec3(0), 1. - smoothstep(lw-aa, lw+aa, d));\n     col = mix(col, vec3(0.5), 1. - smoothstep(lw-aa2, lw+aa2, d2));\n    \n    // Draw debug curves (unchanged)\n    if (draw_curve > 0) {\n        float d1 = min(1. - w.x, w.x + 1.);\n        float d2 = length(w - circ_a.xy) - circ_a.z;\n        d2 = min(d2, length(w - circ_A.xy) - circ_A.z);\n        d1 = abs(d1) * scale / zoom;\n        d2 = abs(d2) * scale / zoom;\n        float lw = 0.0125;\n        float aa1 = fwidth(d1);\n        float aa2 = fwidth(d2);\n        col = mix(col, vec3(0, 0, 1), 1. - smoothstep(lw - aa2, lw + aa2, d2));\n        col = mix(col, vec3(1, 0, 0), 1. - smoothstep(lw - aa1, lw + aa1, d1));\n    }\n    return col;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 pan_vals = textureLod(iChannel0, vec2(0.5, 0.5) / iResolution.xy, 0.0);\n    zoom = textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n    float ab_anim_t =\n        textureLod(iChannel0, vec2(1.5, 0.5) / iResolution.xy, 0.0).x;\n    vec4 c_state = textureLod(iChannel0, vec2(2.5, 0.5) / iResolution.xy, 0.0);\n\n    mode = int(textureLod(iChannel0, vec2(3.5, 0.5) / iResolution.xy, 0.0).x);\n    draw_curve =\n        int(textureLod(iChannel0, vec2(4.5, 0.5) / iResolution.xy, 0.0).x);\n    int k_from = int(c_state.x);\n    int k_to = int(c_state.y);\n    float anim_timer = c_state.z;\n\n    const Mobius identity =\n        Mobius(vec2(1, 0), vec2(0), vec2(0),\n               vec2(1, 0)); \n    Mobius final_transform = identity;\n    if (abs(ab_anim_t) > 0.01) {\n        if (ab_anim_t > 0.0) {\n            final_transform = interpolateMobius(identity, A, ab_anim_t);\n        } else {\n            final_transform = interpolateMobius(identity, B, abs(ab_anim_t));\n        }\n    }\n    vec3 col = vec3(0);\n    for (int ii = 0; ii < AA; ii++) {\n        for (int jj = 0; jj < AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            \n            // Screen coordinates setup\n            vec2 uv = (2. * (fragCoord + o) - iResolution.xy) / iResolution.y;\n            uv -= pan_vals.xy * pow(zoom, -1.0) / iResolution.y * 2.0;\n            uv *= zoom;\n            \n            float deriv = 1.0;\n\n            if (mode == 1) {\n                if (length(uv) > 1.0) {\n                    col += vec3(0.0);\n                    continue;\n                }\n                \n                deriv *= L2(cdiv(vec2(1.0), cmul(P2U.c, uv) + P2U.d));\n                uv = applyMobius(P2U, uv);\n            }\n            else {\n                uv *= 1.5;\n                uv.y += 1.5;\n            }\n        \n            vec2 den = cmul(final_transform.c, uv) + final_transform.d;\n            deriv *= L2(den);\n            vec2 z = applyMobius(final_transform, uv);\n\n            // STEP 2: Pass the screen coordinate to getColor\n            col += getColor(z, deriv, fragCoord + o); \n        }\n    }\n    col /= (float(AA) * float(AA));\n    \n    if (mode == 1) {\n        vec2 uv_center = (2. * fragCoord - iResolution.xy) / iResolution.y;\n        uv_center -= pan_vals.xy * pow(zoom, -1.0) / iResolution.y * 2.0;\n        uv_center *= zoom;\n        col = mix(vec3(0.1), col, smoothstep(1.0, 1.0 - 2.0/iResolution.y, length(uv_center)));\n    }\n\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// https://www.shadertoy.com/view/ldyGzW\nconst int Key_A = 65;\nconst int Key_B = 66;\nconst int Key_C = 67;\nconst int Key_D = 68;\nconst int Key_E = 69;\nconst int Key_F = 70;\nconst int Key_G = 71;\nconst int Key_H = 72;\nconst int Key_I = 73;\nconst int Key_J = 74;\nconst int Key_K = 75;\nconst int Key_L = 76;\nconst int Key_M = 77;\nconst int Key_N = 78;\nconst int Key_O = 79;\nconst int Key_P = 80;\nconst int Key_Q = 81;\nconst int Key_R = 82;\nconst int Key_S = 83;\nconst int Key_T = 84;\nconst int Key_U = 85;\nconst int Key_V = 86;\nconst int Key_W = 87;\nconst int Key_X = 88;\nconst int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48;\nconst int Key_1 = 49;\nconst int Key_2 = 50;\nconst int Key_3 = 51;\nconst int Key_4 = 52;\nconst int Key_5 = 53;\nconst int Key_6 = 54;\nconst int Key_7 = 55;\nconst int Key_8 = 56;\nconst int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal(int key, bool toggle) {\n    return textureLod(iChannel1,\n                      vec2((float(key) + .5) / 256.0, toggle ? .75 : .25), 0.0)\n        .x;\n}\n\nfloat ReadKey(int key) { return ReadKeyInternal(key, false); }\n\nfloat ReadKeyToggle(int key) { return ReadKeyInternal(key, true); }\n\n// Storage Code For Pan and Zoom\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default output for unused pixels\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Pan State at (0,0)\n    if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n        vec4 prev_info = textureLod(iChannel0, vec2(0.0, 0.0), 0.0);\n        float Zoom =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n        float prev_pan_x = prev_info.x;\n        float prev_pan_y = prev_info.y;\n        float legacy_pan_x = prev_info.z;\n        float legacy_pan_y = prev_info.w;\n\n        float pan_x = (iMouse.x - abs(iMouse.z)) * Zoom + legacy_pan_x;\n        float pan_y = (iMouse.y - abs(iMouse.w)) * Zoom + legacy_pan_y;\n\n        if (iMouse.z < 0.0) {\n            legacy_pan_x = prev_pan_x;\n            legacy_pan_y = prev_pan_y;\n            pan_x = legacy_pan_x;\n            pan_y = legacy_pan_y;\n        }\n        fragColor = vec4(pan_x, pan_y, legacy_pan_x, legacy_pan_y);\n    }\n\n    // Zoom State at (10,10)\n    if (ivec2(fragCoord.xy) == ivec2(10, 10)) {\n        float x =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).y;\n        x += ReadKey(Key_W) - ReadKey(Key_S);\n        float Zoom = pow(2.71, -x * 0.05);\n        fragColor = vec4(Zoom, x, 0.0, 0.0);\n    }\n\n    // Animation State at (1,0)\n    if (ivec2(fragCoord.xy) == ivec2(1, 0)) {\n        // Read previous animation state\n        float prev_anim_t = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n\n        float key_a = ReadKey(Key_A);\n        float key_b = ReadKey(Key_B);\n\n        float target_t = 0.0;\n        if (key_a > 0.0) {\n            target_t = 1.0;\n        } else if (key_b > 0.0) {\n            target_t = -1.0;\n        }\n        float speed = 3.;\n        float anim_t =\n            mix(prev_anim_t, target_t, 1.0 - exp(-iTimeDelta * speed));\n        fragColor = vec4(anim_t, 0.0, 0.0, 1.0);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(2, 0)) {\n        vec4 prev_c_state = texelFetch(iChannel0, ivec2(2, 0), 0);\n        float k_from = prev_c_state.x;\n        float k_to = prev_c_state.y;\n        float anim_timer = prev_c_state.z;\n        float prev_key_c_state = prev_c_state.w;\n\n        float key_c = ReadKey(Key_C);\n        if (anim_timer < 1.0) {\n            float anim_speed = 1.;\n            anim_timer += iTimeDelta * anim_speed;\n        }\n        anim_timer = min(anim_timer, 1.0);\n\n        if (key_c > 0.0 && prev_key_c_state == 0.0 && anim_timer >= 1.0) {\n            k_from = k_to;\n            k_to = mod(k_to + 1.0, 16.0);\n            anim_timer = 0.0;\n        }\n\n        fragColor = vec4(k_from, k_to, anim_timer, key_c);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(3, 0)) {\n        float current_mode = texelFetch(iChannel0, ivec2(3, 0), 0).x;\n        if (iFrame < 2)\n            current_mode = 0.0;\n        if (ReadKey(Key_1) > 0.0)\n            current_mode = 0.0;\n        if (ReadKey(Key_2) > 0.0)\n            current_mode = 1.0;\n        if (ReadKey(Key_3) > 0.0)\n            current_mode = 2.0;\n\n        fragColor = vec4(current_mode, 0.0, 0.0, 1.0);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(4, 0)) {\n        vec4 prev_state = texelFetch(iChannel0, ivec2(4, 0), 0);\n        float current_toggle = prev_state.x;\n        float prev_key_c_state = prev_state.y;\n\n        float key_c = ReadKey(Key_C);\n        if (key_c > 0.0 && prev_key_c_state == 0.0) {\n            current_toggle = 1.0 - current_toggle;\n        }\n        fragColor = vec4(current_toggle, key_c, 0.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(123.34, 456.21));\n    p += dot(p, p + 45.32);\n    return fract(p.x * p.y);\n}\n\n// 简易 fbm，用于 pencil() 笔触扰动\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = hash21(i);\n    float b = hash21(i + vec2(1,0));\n    float c = hash21(i + vec2(0,1));\n    float d = hash21(i + vec2(1,1));\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;\n}\n\nfloat fbm(vec2 p) {\n    float f = 0.0;\n    f += 0.5  * noise(p); p *= 2.02;\n    f += 0.25 * noise(p); p *= 2.03;\n    f += 0.125* noise(p); p *= 2.01;\n    f += 0.0625*noise(p);\n    return f;\n}\n\n// 铅笔纹理函数\nvec3 pencil(vec3 baseCol, vec2 uv, int darkLines) {\n    // 笔触扰动\n    float pat = fbm(uv*1.5) * 0.8 + fbm(uv*4.0) * 0.2;\n    // 加方向性条纹\n    float lines = sin(uv.x*60.0 + pat*2.0);\n    float mask = smoothstep(-0.2, 0.2, lines);\n    vec3 ink = mix(vec3(1.0), vec3(0.0), mask * 0.6);\n    vec3 finalCol = baseCol * ink;\n    if (darkLines == 1) {\n        finalCol *= 0.85;\n    }\n    return finalCol;\n}","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"Wfsczr","date":"0","viewed":0,"name":"wilson test","description":"xxxx","likes":0,"published":"Private","usePreview":0,"tags":["2d","maze"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CELL_SIZE 7.0\n#define GRID_WIDTH  floor(iResolution.x / CELL_SIZE)\n#define GRID_HEIGHT floor(iResolution.y / CELL_SIZE)\n\n#define STATE_WALL 0.0\n#define STATE_TREE 1.0\n\nvec4 getCell(ivec2 pos) {\n    if (pos.x < 0 || pos.x >= int(GRID_WIDTH) ||\n        pos.y < 0 || pos.y >= int(GRID_HEIGHT)) {\n        return vec4(STATE_WALL);\n    }\n    return texelFetch(iChannel0, pos, 0); // iChannel0 is Buffer A\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 grid_pixel_size = vec2(GRID_WIDTH, GRID_HEIGHT) * CELL_SIZE;\n    vec2 offset = (iResolution.xy - grid_pixel_size) / 2.0;\n    ivec2 p_grid = ivec2(floor((fragCoord - offset) / CELL_SIZE));\n    \n    if (p_grid.x < 0 || p_grid.x >= int(GRID_WIDTH) ||\n        p_grid.y < 0 || p_grid.y >= int(GRID_HEIGHT)) {\n        fragColor = vec4(0.05, 0.0, 0.1, 1.0);\n        return;\n    }\n\n    vec4 cell_main = getCell(p_grid);\n    float state = cell_main.r;\n\n    vec3 finalColor = vec3(0.1, 0.1, 0.15); // Wall\n\n    if (state > STATE_TREE) { \n        finalColor = vec3(1.0, 0.6, 0.0); // Path is bright orange\n    } else if (state == STATE_TREE) {\n        finalColor = vec3(1.0); // Tree is white\n    }\n    \n    // Gap filling logic\n    if (state == STATE_WALL) {\n        vec4 N = getCell(p_grid + ivec2(0, 1)); vec4 S = getCell(p_grid - ivec2(0, 1));\n        vec4 E = getCell(p_grid + ivec2(1, 0)); vec4 W = getCell(p_grid - ivec2(1, 0));\n        if (N.r > STATE_TREE && S.r > STATE_TREE) finalColor = vec3(1.0, 0.6, 0.0);\n        if (E.r > STATE_TREE && W.r > STATE_TREE) finalColor = vec3(1.0, 0.6, 0.0);\n        if (N.r == STATE_TREE && S.r == STATE_TREE) finalColor = vec3(1.0);\n        if (E.r == STATE_TREE && W.r == STATE_TREE) finalColor = vec3(1.0);\n    }\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define CELL_SIZE 7.0\n#define SPEED 1\n\n// --- DERIVED CONSTANTS ---\n#define GRID_WIDTH  floor(iResolution.x / CELL_SIZE)\n#define GRID_HEIGHT floor(iResolution.y / CELL_SIZE)\n\n#define STATE_WALL 0.0\n#define STATE_TREE 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    ivec2 p = ivec2(fragCoord);\n\n    if (float(p.x) >= GRID_WIDTH || float(p.y) >= GRID_HEIGHT) {\n        fragColor = vec4(0.0); return;\n    }\n\n    // --- INITIALIZATION ---\n    if (iFrame < 5 || texelFetch(iChannel1, ivec2(0), 0).x < 0.0) { // Reset on click\n        fragColor = vec4(STATE_WALL);\n        return;\n    }\n\n    vec4 prev_cell = texelFetch(iChannel0, p, 0);\n    // Read PREVIOUS agent state from Buffer B\n    vec4 prev_agent = texelFetch(iChannel1, ivec2(0), 0);\n    fragColor = prev_cell;\n\n    // --- GRID LOGIC ---\n    // The only thing the grid does is mark the agent's previous position.\n    if (p == ivec2(prev_agent.xy)) {\n        fragColor.r = 100.0; // Mark as path with a high value\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define CELL_SIZE 7.0\n#define SPEED 1\n\n// --- DERIVED CONSTANTS ---\n#define GRID_WIDTH  floor(iResolution.x / CELL_SIZE)\n#define GRID_HEIGHT floor(iResolution.y / CELL_SIZE)\n\n// Helper functions\nfloat rand(vec2 co){ return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453); }\n\nivec2 randomNeighbour(ivec2 cell, float seed) {\n    ivec2 neighbours[4];\n    int count = 0;\n    if (cell.x >= 2)   neighbours[count++] = ivec2(cell.x - 2, cell.y);\n    if (cell.y >= 2)   neighbours[count++] = ivec2(cell.x, cell.y - 2);\n    if (cell.x <= int(GRID_WIDTH) - 3)  neighbours[count++] = ivec2(cell.x + 2, cell.y);\n    if (cell.y <= int(GRID_HEIGHT) - 3) neighbours[count++] = ivec2(cell.x, cell.y + 2);\n    if (count == 0) return cell;\n    return neighbours[int(floor(seed * float(count)))];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // This shader only needs to run for the single pixel at (0,0)\n    if (ivec2(fragCoord) != ivec2(0)) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    // --- INITIALIZATION ---\n    if (iFrame < 5 || iMouse.z > 0.0) {\n        // Start walking from a fixed position\n        // We use a negative X value as a \"reset\" signal for Buffer A\n        if (iMouse.z > 0.0) {\n             fragColor = vec4(-1.0, 0.0, 0.0, 0.0);\n        } else {\n             fragColor = vec4(floor(GRID_WIDTH/2.0)*2.0+1.0, floor(GRID_HEIGHT/2.0)*2.0+1.0, 2.0, 1.0);\n        }\n        return;\n    }\n\n    vec4 prev_agent = texelFetch(iChannel0, ivec2(0), 0);\n    vec4 agent = prev_agent;\n\n    for (int k=0; k<SPEED; ++k) {\n        ivec2 current_pos = ivec2(agent.xy);\n        float seed = rand(vec2(iTime, agent.x * 13.7 + agent.y * 3.1 + agent.z));\n        ivec2 next_pos = randomNeighbour(current_pos, seed);\n        agent = vec4(vec2(next_pos), agent.z + 1.0, 1.0);\n    }\n    \n    fragColor = agent;\n}","name":"Buffer B","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"tclczH","date":"0","viewed":0,"name":"Fork Fork Indra neozhaolia 137","description":"The glowing gasket","likes":0,"published":"Private","usePreview":0,"tags":["2d","fractal","mobius","gasket"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\nconst float PI = 3.14159265359;\nconst int MAX_ITER = 100;\n\nfloat zoom;\nint mode;\nint draw_curve;\n\n#define L2(x) dot(x, x)\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float d2 = dot(w, w);\n    if (d2 < 1e-15)\n        return vec2(1e7);\n    return cmul(z, vec2(w.x, -w.y)) / d2;\n}\n\nstruct Mobius {\n    vec2 a, b, c, d;\n};\n\nvec2 applyMobius(Mobius m, vec2 z) {\n    vec2 num = cmul(m.a, z) + m.b;\n    vec2 den = cmul(m.c, z) + m.d;\n    return cdiv(num, den);\n}\n\nMobius invMobius(Mobius m) { return Mobius(m.d, -m.b, -m.c, m.a); }\n\nMobius interpolateMobius(Mobius m1, Mobius m2, float t) {\n    return Mobius(mix(m1.a, m2.a, t), mix(m1.b, m2.b, t), mix(m1.c, m2.c, t),\n                  mix(m1.d, m2.d, t));\n}\n\nconst Mobius I = Mobius(vec2(1, 0), vec2(0), vec2(0), vec2(1, 0));\nMobius a, b, A, B;\n\nfloat sdFundDomainUHP(vec2 z) {\n    float da = length(z - vec2(-0.5, 0)) - 0.5;\n    float dA = length(z - vec2(0.5, 0)) - 0.5;\n    float dB = z.x + 1.;\n    float db = 1. - z.x;\n    return min(min(da, dA), min(db, dB));\n}\n\nvoid foldUHP(inout vec2 z, inout float count, inout float deriv) {\n    for (int i = 0; i < MAX_ITER; i++) {\n        bool found = true;\n        if (length(z - vec2(-0.5, 0)) < 0.5) {\n            deriv *= L2(cmul(A.c, z) + A.d);\n            z = applyMobius(A, z);\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (length(z - vec2(0.5, 0)) < 0.5) {\n            deriv *= L2(cmul(a.c, z) + a.d);\n            z = applyMobius(a, z);\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (z.x > 1.) {\n            z.x -= 2.;\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (z.x < -1.) {\n            z.x += 2.;\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (found)\n            break;\n    }\n}\n\nvoid setup() {\n\n    a = Mobius(vec2(1, 0), vec2(0, 0), vec2(-2, 0), vec2(1, 0));\n    A = Mobius(vec2(1, 0), vec2(0, 0), vec2(2, 0), vec2(1, 0));\n\n    b = Mobius(vec2(1, 0), vec2(2, 0), vec2(0, 0), vec2(1, 0));\n    B = Mobius(vec2(1, 0), vec2(-2, 0), vec2(0, 0), vec2(1, 0));\n}\n\nvec3 getColor(vec2 z, in float deriv, vec2 fragCoord) {\n    vec2 w = z;\n    float count = 0.0;\n    float scale = deriv;\n\n    foldUHP(z, count, deriv);\n\n    float id = (z.x < 0.) ? 0. : 1.;\n    vec3 col = (id == 1.) ? vec3(.6, .9, 0.75) : vec3(1.0);\n\n    float d = abs(sdFundDomainUHP(z)) / zoom;\n    float d2 = abs(z.x) / deriv / zoom;\n    float aa = fwidth(d) / 2.0;\n    float aa2 = fwidth(d2) / 2.;\n    float lw = 0.004;\n    col = mix(col, vec3(0), 1. - smoothstep(0., 0.01, d-aa));\n    //col = mix(col, vec3(0.5), 1. - smoothstep(lw - aa2, lw + aa2, d2));\n\n    if (draw_curve > 0) {\n        float d1 = min(1. - w.x, w.x + 1.);\n        float d2 = length(w - vec2(-0.5, 0)) - 0.5;\n        d2 = min(d2, length(w - vec2(0.5, 0)) - 0.5);\n        d1 = abs(d1) * scale / zoom;\n        d2 = abs(d2) * scale / zoom;\n        float lw = 0.0125;\n        float aa1 = fwidth(d1);\n        float aa2 = fwidth(d2);\n        col = mix(col, vec3(0, 0, 1), 1. - smoothstep(lw - aa2, lw + aa2, d2));\n        col = mix(col, vec3(1, 0, 0), 1. - smoothstep(lw - aa1, lw + aa1, d1));\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    setup();\n    \n    vec4 pan_vals = textureLod(iChannel0, vec2(0.5, 0.5) / iResolution.xy, 0.0);\n    zoom = textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n    float ab_anim_t =\n        textureLod(iChannel0, vec2(1.5, 0.5) / iResolution.xy, 0.0).x;\n    vec4 c_state = textureLod(iChannel0, vec2(2.5, 0.5) / iResolution.xy, 0.0);\n\n    mode = int(textureLod(iChannel0, vec2(3.5, 0.5) / iResolution.xy, 0.0).x);\n    draw_curve =\n        int(textureLod(iChannel0, vec2(4.5, 0.5) / iResolution.xy, 0.0).x);\n    int k_from = int(c_state.x);\n    int k_to = int(c_state.y);\n    float anim_timer = c_state.z;\n\n    Mobius final_transform = I;\n    if (abs(ab_anim_t) > 0.01) {\n        if (ab_anim_t > 0.0) {\n            final_transform = interpolateMobius(I, A, ab_anim_t);\n        } else {\n            final_transform = interpolateMobius(I, B, abs(ab_anim_t));\n        }\n    }\n    vec3 col = vec3(0);\n    for (int ii = 0; ii < AA; ii++) {\n        for (int jj = 0; jj < AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * (fragCoord + o) - iResolution.xy) / iResolution.y;\n            uv -= pan_vals.xy * pow(zoom, -1.0) / iResolution.y * 2.0;\n            uv *= 1.5;\n            uv.y += 1.5;\n            uv *= zoom;\n            \n            float deriv = 1.0;\n            vec2 den = cmul(final_transform.c, uv) + final_transform.d;\n            deriv *= L2(den);\n            vec2 z = applyMobius(final_transform, uv);\n            col += getColor(z, deriv, fragCoord + o);\n        }\n    }\n    col /= (float(AA) * float(AA));\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// https://www.shadertoy.com/view/ldyGzW\nconst int Key_A = 65;\nconst int Key_B = 66;\nconst int Key_C = 67;\nconst int Key_D = 68;\nconst int Key_E = 69;\nconst int Key_F = 70;\nconst int Key_G = 71;\nconst int Key_H = 72;\nconst int Key_I = 73;\nconst int Key_J = 74;\nconst int Key_K = 75;\nconst int Key_L = 76;\nconst int Key_M = 77;\nconst int Key_N = 78;\nconst int Key_O = 79;\nconst int Key_P = 80;\nconst int Key_Q = 81;\nconst int Key_R = 82;\nconst int Key_S = 83;\nconst int Key_T = 84;\nconst int Key_U = 85;\nconst int Key_V = 86;\nconst int Key_W = 87;\nconst int Key_X = 88;\nconst int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48;\nconst int Key_1 = 49;\nconst int Key_2 = 50;\nconst int Key_3 = 51;\nconst int Key_4 = 52;\nconst int Key_5 = 53;\nconst int Key_6 = 54;\nconst int Key_7 = 55;\nconst int Key_8 = 56;\nconst int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal(int key, bool toggle) {\n    return textureLod(iChannel1,\n                      vec2((float(key) + .5) / 256.0, toggle ? .75 : .25), 0.0)\n        .x;\n}\n\nfloat ReadKey(int key) { return ReadKeyInternal(key, false); }\n\nfloat ReadKeyToggle(int key) { return ReadKeyInternal(key, true); }\n\n// Storage Code For Pan and Zoom\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default output for unused pixels\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Pan State at (0,0)\n    if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n        vec4 prev_info = textureLod(iChannel0, vec2(0.0, 0.0), 0.0);\n        float Zoom =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n        float prev_pan_x = prev_info.x;\n        float prev_pan_y = prev_info.y;\n        float legacy_pan_x = prev_info.z;\n        float legacy_pan_y = prev_info.w;\n\n        float pan_x = (iMouse.x - abs(iMouse.z)) * Zoom + legacy_pan_x;\n        float pan_y = (iMouse.y - abs(iMouse.w)) * Zoom + legacy_pan_y;\n\n        if (iMouse.z < 0.0) {\n            legacy_pan_x = prev_pan_x;\n            legacy_pan_y = prev_pan_y;\n            pan_x = legacy_pan_x;\n            pan_y = legacy_pan_y;\n        }\n        fragColor = vec4(pan_x, pan_y, legacy_pan_x, legacy_pan_y);\n    }\n\n    // Zoom State at (10,10)\n    if (ivec2(fragCoord.xy) == ivec2(10, 10)) {\n        float x =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).y;\n        x += ReadKey(Key_W) - ReadKey(Key_S);\n        float Zoom = pow(2.71, -x * 0.05);\n        fragColor = vec4(Zoom, x, 0.0, 0.0);\n    }\n\n    // Animation State at (1,0)\n    if (ivec2(fragCoord.xy) == ivec2(1, 0)) {\n        // Read previous animation state\n        float prev_anim_t = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n\n        float key_a = ReadKey(Key_A);\n        float key_b = ReadKey(Key_B);\n\n        float target_t = 0.0;\n        if (key_a > 0.0) {\n            target_t = 1.0;\n        } else if (key_b > 0.0) {\n            target_t = -1.0;\n        }\n        float speed = 3.;\n        float anim_t =\n            mix(prev_anim_t, target_t, 1.0 - exp(-iTimeDelta * speed));\n        fragColor = vec4(anim_t, 0.0, 0.0, 1.0);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(2, 0)) {\n        vec4 prev_c_state = texelFetch(iChannel0, ivec2(2, 0), 0);\n        float k_from = prev_c_state.x;\n        float k_to = prev_c_state.y;\n        float anim_timer = prev_c_state.z;\n        float prev_key_c_state = prev_c_state.w;\n\n        float key_c = ReadKey(Key_C);\n        if (anim_timer < 1.0) {\n            float anim_speed = 1.;\n            anim_timer += iTimeDelta * anim_speed;\n        }\n        anim_timer = min(anim_timer, 1.0);\n\n        if (key_c > 0.0 && prev_key_c_state == 0.0 && anim_timer >= 1.0) {\n            k_from = k_to;\n            k_to = mod(k_to + 1.0, 16.0);\n            anim_timer = 0.0;\n        }\n\n        fragColor = vec4(k_from, k_to, anim_timer, key_c);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(3, 0)) {\n        float current_mode = texelFetch(iChannel0, ivec2(3, 0), 0).x;\n        if (iFrame < 2)\n            current_mode = 0.0;\n        if (ReadKey(Key_1) > 0.0)\n            current_mode = 0.0;\n        if (ReadKey(Key_2) > 0.0)\n            current_mode = 1.0;\n        if (ReadKey(Key_3) > 0.0)\n            current_mode = 2.0;\n\n        fragColor = vec4(current_mode, 0.0, 0.0, 1.0);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(4, 0)) {\n        vec4 prev_state = texelFetch(iChannel0, ivec2(4, 0), 0);\n        float current_toggle = prev_state.x;\n        float prev_key_c_state = prev_state.y;\n\n        float key_c = ReadKey(Key_C);\n        if (key_c > 0.0 && prev_key_c_state == 0.0) {\n            current_toggle = 1.0 - current_toggle;\n        }\n        fragColor = vec4(current_toggle, key_c, 0.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"3cscRN","date":"0","viewed":0,"name":"测试直接getColor返回颜色","description":"Grandma's recipe, the 1/15 cusp group in which a^{15}B is parabolic","likes":0,"published":"Private","usePreview":0,"tags":["2d","fractal","mobius","circlepacking"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nFig 9.1 and Fig 9.15(ii) in Indra's pearls,\nthe 1/15 and 1/9 double cusp groups.\nUsing Ford domain method.\n\nTranslated from knighty's evaldraw script.\n**ALL the difficult parts were done by knighty**.\nI'm lucky and grateful to have his selfless help.\n\nKeyboadr control:\n\n+ Press 1/2/3 to switch mode (limit set, circle packing, tiling)\n+ Press w/s to zoom in/out\n+ Press a/b/c to see the action of a, b and successive action of a^i\n*/\n#define AA 1\n#define CURVE_THICKNESS 0.008\n\n// uncomment to show the 1/9 cusp group\n//#define cusp_1_9\n\nconst int MAX_ITER = 100;\n\nconst vec2 tb = vec2(2, 0);\n\n#ifdef cusp_1_9\n    const int N = 13;\n    const vec2 ta = vec2(1.8964073,-0.0487530);\n    const float rr = 0.3217;\n    vec2 pts[] = vec2[] (\n            vec2(-1, 0), vec2(1, 0), vec2(0, -1),\n            vec2(0,1)\n        );\n#else\n    const int N = 17;\n    const vec2 ta = vec2(1.95859103, -0.01127856);\n    const float rr = 0.3287582641552815;\n    vec2 pts[] = vec2[] (\n            vec2(-1, 0), vec2(1, 0), vec2(0, -1),\n            vec2(0,1), vec2(0.405415, -0.19312647)\n        );\n#endif\n\nconst vec3 trap1 = vec3(0, 0, 1);\nconst vec3 trap2 = vec3(1. - rr, 0, rr * rr);\nconst vec3 trap3 = vec3(rr - 1., 0, rr * rr);\n\nfloat zoom;\nint mode;\n\nvec2 cmul(vec2 z, vec2 w) { return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x); }\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float d2 = dot(w, w); if (d2 < 1e-15) return vec2(1e7);\n    return cmul(z, vec2(w.x, -w.y)) / d2;\n}\n\nvec2 csqrt(vec2 z) {\n    float r = length(z); float angle = atan(z.y, z.x);\n    return sqrt(r) * vec2(cos(0.5*angle), sin(0.5*angle));\n}\n\nvec2 solveQuadratic(vec2 b, vec2 c) {\n    vec2 delta = cmul(b, b) - 4. * c;\n    vec2 sqrt_delta = csqrt(delta);\n    return (-b - sqrt_delta) / 2.;\n}\n\nstruct Mobius { vec2 a, b, c, d; };\n\nvec2 applyMobius(Mobius m, vec2 z) {\n    vec2 num = cmul(m.a, z) + m.b;\n    vec2 den = cmul(m.c, z) + m.d;\n    return cdiv(num, den);\n}\n\nMobius mulMobius(Mobius m1, Mobius m2) {\n    return Mobius(cmul(m1.a, m2.a)+cmul(m1.b, m2.c), cmul(m1.a, m2.b)+cmul(m1.b, m2.d),\n                  cmul(m1.c, m2.a)+cmul(m1.d, m2.c), cmul(m1.c, m2.b)+cmul(m1.d, m2.d));\n}\n\nMobius invMobius(Mobius m) { return Mobius(m.d, -m.b, -m.c, m.a); }\n\nMobius interpolateMobius(Mobius m1, Mobius m2, float t) {\n    return Mobius(\n        mix(m1.a, m2.a, t),\n        mix(m1.b, m2.b, t),\n        mix(m1.c, m2.c, t),\n        mix(m1.d, m2.d, t)\n    );\n}\n\nconst Mobius identity = Mobius(vec2(1,0), vec2(0), vec2(0), vec2(1,0));\nMobius a, b, A, B;\nMobius transforms[N];\n\n//-----------------------------------------------------\n\nvoid getGenerators(inout Mobius a, inout Mobius b) {\n    // compute tab\n    vec2 ta2 = cmul(ta, ta);\n    vec2 tb2 = cmul(tb, tb);\n    vec2 tab = solveQuadratic(-cmul(ta, tb), ta2 + tb2);\n    \n    // compute z0\n    vec2 num = cmul(tab - vec2(2, 0), tb);\n    vec2 den = cmul(tb, tab) - 2. * ta + cmul(vec2(0, 2), tab);\n    vec2 z0 = cdiv(num, den);\n    \n    // compute b\n    b.a = tb / 2. - vec2(0, 1);\n    b.d = tb / 2. + vec2(0, 1);\n    b.c = b.b = tb / 2.;\n    \n    // compute ab\n    Mobius ab = Mobius(\n        tab / 2.,\n        cdiv(tab / 2. - vec2(1, 0), z0),\n        cmul(tab / 2. + vec2(1, 0), z0),\n        tab / 2.\n    );\n    \n    // a = (ab)B\n    a = mulMobius(ab, invMobius(b));\n}\n\nbool Equal(vec2 z, vec2 a, float deriv) {\n    float k = 2. + length(z);\n    return k * length(z - a) * deriv / zoom < CURVE_THICKNESS;\n}\n\nvoid setupTransforms() {\n    getGenerators(a, b);\n    A = invMobius(a);\n    B = invMobius(b);\n\n    transforms[0] = a;\n\n#ifdef cusp_1_9\n    for (int i = 1; i < 9; i++)\n        transforms[i] = mulMobius(transforms[i-1], a);\n    transforms[9] = b;\n    transforms[10] = mulMobius(a, mulMobius(b, A));\n    transforms[11] = mulMobius(transforms[8], B);\n    transforms[12] = mulMobius(invMobius(transforms[7]), transforms[10]);\n#else\n   \n    for (int i = 1; i < 15; i++)\n        transforms[i] = mulMobius(transforms[i-1], a);\n\n    transforms[15] = b;\n    transforms[16] = mulMobius(mulMobius(a, b), A);\n#endif\n}\n\n\nfloat sdTrapped(vec2 p) {\n    float d1 = 1. - dot(p, p);\n    float d2 = dot(p - trap2.xy, p - trap2.xy) - trap2.z;\n    float d3 = dot(p - trap3.xy, p - trap3.xy) - trap3.z;\n    return min(d1, min(d2, d3));\n}\n\nstruct BestTransformChoice {\n    vec2  z_new;\n    float nsd;\n    bool  found;\n};\n\nvec3 hsv2rgb(vec3 c){\n    vec3 rgb = clamp(abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 getColor(vec2 z, vec2 uv, in float deriv) {\n    \n    float count = 0.0;\n    for (int i = 0; i < MAX_ITER; i++) {\n        if (mode > 0) {\n            for (int j = 0; j < pts.length(); j++) {\n                if (Equal(z, pts[j], deriv)) {\n                    return vec3(0);\n                \n                }\n            }\n        }\n        float min_nsd = 1.0;\n        BestTransformChoice best_choice;\n        best_choice.found = false;\n        for (int j = 0; j < N; j++) {\n            Mobius g = transforms[j];\n            vec2 den_g = cmul(g.c, z) + g.d;\n            float nsd_g = dot(den_g, den_g);\n\n            if (nsd_g < min_nsd) {\n                min_nsd = nsd_g;\n                best_choice.z_new = applyMobius(g, z);\n                best_choice.nsd = nsd_g;\n                best_choice.found = true;\n            }\n            Mobius g_inv = invMobius(g);\n            vec2 den_g_inv = cmul(g_inv.c, z) + g_inv.d;\n            float nsd_g_inv = dot(den_g_inv, den_g_inv);\n\n            if (nsd_g_inv < min_nsd) {\n                min_nsd = nsd_g_inv;\n                best_choice.z_new = applyMobius(g_inv, z);\n                best_choice.nsd = nsd_g_inv;\n                best_choice.found = true;\n            }\n        }\n        if (best_choice.found) {\n            z = best_choice.z_new;    \n            deriv *= best_choice.nsd;\n            count += 1.0;\n        }\n        else {\n            break;\n        }\n    }\n    float id;\n    if (dot(z, z) > 1.)\n        { id = 0.; }\n    else if (dot(z - trap2.xy, z - trap2.xy) < trap2.z)\n        { id = 1.; }\n    else if (dot(z - trap3.xy, z - trap3.xy) < trap3.z)\n        { id = 2.; }\n    else\n        id = 3.;\n        \n    float d = abs(sdTrapped(z) * deriv) / zoom;\n    if (mode == 1) {\n        return vec3(1);\n    }\n    else if (mode == 0) {\n        if (count > float(MAX_ITER))\n            return vec3(0);\n        float pi = 3.1415926;\n        float t = pi * count / 14.;\n    \n        vec3 col = 0.5 + 0.5 *cos(\n            t + vec3(3., 4.2, 4.9) * 0.95);\n        col = pow(col, vec3(2.2));\n        return col;\n    }\n    else {\n        vec3 col = vec3(1);\n        if (id == 1. || id == 2.)\n            col = 0.5 + 0.45 * cos((id - 1.)*14.+vec3(0,1,2));\n        \n        if (length(z) > 1.) {\n            float id2 = mod(count, 2.);\n            if (id2 == 1.)\n                col = vec3(0.85, 0.85, 0.95);\n        }\n        return col;\n    }\n}\n\nMobius getTransformForK(int k, const in Mobius B) {\n    const Mobius identity = Mobius(vec2(1,0), vec2(0), vec2(0), vec2(1,0));\n    if (k == 0) {\n        return identity;\n    }\n    Mobius a_k = transforms[k - 1];\n    return invMobius(a_k);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    setupTransforms();\n    vec4 pan_vals = textureLod(iChannel0, vec2(0.5, 0.5) / iResolution.xy, 0.0);\n    zoom = textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n    float ab_anim_t = textureLod(iChannel0, vec2(1.5, 0.5) / iResolution.xy, 0.0).x;\n    vec4 c_state = textureLod(iChannel0, vec2(2.5, 0.5) / iResolution.xy, 0.0);\n    \n    mode = int(textureLod(iChannel0, vec2(3.5, 0.5) / iResolution.xy, 0.0).x);\n    \n    int k_from = int(c_state.x);\n    int k_to = int(c_state.y);\n    float anim_timer = c_state.z;\n\n    const Mobius identity = Mobius(vec2(1,0), vec2(0), vec2(0), vec2(1,0)); // Moved identity here for use in getTransformForK\n    Mobius final_transform = identity;\n    if (abs(ab_anim_t) > 0.01) {\n        if (ab_anim_t > 0.0) {\n            final_transform = interpolateMobius(identity, A, ab_anim_t);\n        } else {\n            final_transform = interpolateMobius(identity, B, abs(ab_anim_t));\n        }\n    }\n    else if (k_to > 0 || anim_timer < 1.0) {\n        Mobius T_from = getTransformForK(k_from, B);\n        Mobius T_to = getTransformForK(k_to, B);\n        float t = smoothstep(0.0, 1.0, anim_timer);\n        \n        final_transform = interpolateMobius(T_from, T_to, t);\n    } \n    vec3 col = vec3(0);\n    for (int ii = 0; ii < AA; ii++) {\n        for (int jj = 0; jj < AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * (fragCoord + o) - iResolution.xy -\n                       pan_vals.xy * pow(zoom, -1.0)) /\n                      iResolution.y;\n            uv *= zoom * 1.05; \n            vec2 den_g = cmul(final_transform.c, uv) + final_transform.d;\n            float deriv = dot(den_g, den_g);\n            vec2 z = applyMobius(final_transform, uv);\n            col += getColor(z, uv, deriv);\n        }\n    }\n    col /= (float(AA) * float(AA));\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// https://www.shadertoy.com/view/ldyGzW\nconst int Key_A = 65;\nconst int Key_B = 66;\nconst int Key_C = 67;\nconst int Key_D = 68;\nconst int Key_E = 69;\nconst int Key_F = 70;\nconst int Key_G = 71;\nconst int Key_H = 72;\nconst int Key_I = 73;\nconst int Key_J = 74;\nconst int Key_K = 75;\nconst int Key_L = 76;\nconst int Key_M = 77;\nconst int Key_N = 78;\nconst int Key_O = 79;\nconst int Key_P = 80;\nconst int Key_Q = 81;\nconst int Key_R = 82;\nconst int Key_S = 83;\nconst int Key_T = 84;\nconst int Key_U = 85;\nconst int Key_V = 86;\nconst int Key_W = 87;\nconst int Key_X = 88;\nconst int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48;\nconst int Key_1 = 49;\nconst int Key_2 = 50;\nconst int Key_3 = 51;\nconst int Key_4 = 52;\nconst int Key_5 = 53;\nconst int Key_6 = 54;\nconst int Key_7 = 55;\nconst int Key_8 = 56;\nconst int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal(int key, bool toggle) {\n    return textureLod(iChannel1,\n                      vec2((float(key) + .5) / 256.0, toggle ? .75 : .25), 0.0)\n        .x;\n}\n\nfloat ReadKey(int key) { return ReadKeyInternal(key, false); }\n\nfloat ReadKeyToggle(int key) { return ReadKeyInternal(key, true); }\n\n// Storage Code For Pan and Zoom\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default output for unused pixels\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Pan State at (0,0)\n    if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n        vec4 prev_info = textureLod(iChannel0, vec2(0.0, 0.0), 0.0);\n        float Zoom =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n        float prev_pan_x = prev_info.x;\n        float prev_pan_y = prev_info.y;\n        float legacy_pan_x = prev_info.z;\n        float legacy_pan_y = prev_info.w;\n\n        float pan_x = (iMouse.x - abs(iMouse.z)) * Zoom + legacy_pan_x;\n        float pan_y = (iMouse.y - abs(iMouse.w)) * Zoom + legacy_pan_y;\n\n        if (iMouse.z < 0.0) {\n            legacy_pan_x = prev_pan_x;\n            legacy_pan_y = prev_pan_y;\n            pan_x = legacy_pan_x;\n            pan_y = legacy_pan_y;\n        }\n        fragColor = vec4(pan_x, pan_y, legacy_pan_x, legacy_pan_y);\n    }\n\n    // Zoom State at (10,10)\n    if (ivec2(fragCoord.xy) == ivec2(10, 10)) {\n        float x =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).y;\n        x += ReadKey(Key_W) - ReadKey(Key_S);\n        float Zoom = pow(2.71, -x * 0.05);\n        fragColor = vec4(Zoom, x, 0.0, 0.0);\n    }\n    \n    // Animation State at (1,0)\n    if (ivec2(fragCoord.xy) == ivec2(1, 0)) {\n        // Read previous animation state\n        float prev_anim_t = texelFetch(iChannel0, ivec2(1,0), 0).x;\n\n        float key_a = ReadKey(Key_A);\n        float key_b = ReadKey(Key_B);\n        \n        float target_t = 0.0;\n        if (key_a > 0.0) {\n            target_t = 1.0;\n        } else if (key_b > 0.0) {\n            target_t = -1.0;\n        }\n        \n        float speed = 2.;\n        float anim_t = mix(prev_anim_t, target_t, 1.0 - exp(-iTimeDelta * speed));\n        fragColor = vec4(anim_t, 0.0, 0.0, 1.0);\n    }\n     if (ivec2(fragCoord.xy) == ivec2(2, 0)) {\n         vec4 prev_c_state = texelFetch(iChannel0, ivec2(2,0), 0);\n        float k_from = prev_c_state.x;\n        float k_to = prev_c_state.y;\n        float anim_timer = prev_c_state.z;\n        float prev_key_c_state = prev_c_state.w;\n        \n        float key_c = ReadKey(Key_C);\n        if (anim_timer < 1.0) {\n            float anim_speed = 1.;\n            anim_timer += iTimeDelta * anim_speed;\n        }\n        anim_timer = min(anim_timer, 1.0);\n\n        if (key_c > 0.0 && prev_key_c_state == 0.0 && anim_timer >= 1.0) {\n            k_from = k_to;\n            k_to = mod(k_to + 1.0, 16.0);\n            anim_timer = 0.0;\n        }\n        \n        fragColor = vec4(k_from, k_to, anim_timer, key_c);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(3, 0)) {\n        float current_mode = texelFetch(iChannel0, ivec2(3,0), 0).x;\n        if(iFrame < 2) current_mode = 2.0; \n        if (ReadKey(Key_1) > 0.0) current_mode = 0.0;\n        if (ReadKey(Key_2) > 0.0) current_mode = 1.0;\n        if (ReadKey(Key_3) > 0.0) current_mode = 2.0;\n        fragColor = vec4(current_mode, 0.0, 0.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"WcscRN","date":"0","viewed":0,"name":"Fork Indra's pe neozhaolia 297","description":"The glowing gasket","likes":0,"published":"Private","usePreview":0,"tags":["2d","fractal","mobius","gasket"]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThe glowing gasket — Fig. 7.3 of Indra's Pearls\n\nTwo fundamental domains, each one is a one-punctured torus.\n\nKeyboard controls:\n  1/2/3  - Switch mode (limit set, circle packing, tiling)\n  w/s    - Zoom in / out\n  a/b    - Show the action of generators a / b\n  c      - Show the four circles C_a, C_A, C_b, C_B\n*/\n\n#define AA 2\n#define CURVE_THICKNESS 0.007\n\nconst float PI = 3.14159265359;\nconst int MAX_ITER = 100;\n\nfloat zoom;\nint mode;\nint draw_curve;\n\n#define L2(x) dot(x, x)\n\nvec2 u1, u2;\n\nvec2 get_tangent(vec3 c, vec3 d) {\n    vec2 dir = normalize(c.xy - d.xy);\n    return dir * d.r + d.xy;\n}\n\nvec2 cmul(vec2 z, vec2 w) {\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n    float d2 = dot(w, w);\n    if (d2 < 1e-15)\n        return vec2(1e7);\n    return cmul(z, vec2(w.x, -w.y)) / d2;\n}\n\nstruct Mobius {\n    vec2 a, b, c, d;\n};\n\nvec2 applyMobius(Mobius m, vec2 z) {\n    vec2 num = cmul(m.a, z) + m.b;\n    vec2 den = cmul(m.c, z) + m.d;\n    return cdiv(num, den);\n}\n\nMobius invMobius(Mobius m) { return Mobius(m.d, -m.b, -m.c, m.a); }\n\nMobius interpolateMobius(Mobius m1, Mobius m2, float t) {\n    return Mobius(mix(m1.a, m2.a, t), mix(m1.b, m2.b, t), mix(m1.c, m2.c, t),\n                  mix(m1.d, m2.d, t));\n}\n\nbool Equal(vec2 z, vec2 a, float deriv) {\n    float k = 1. + length(z);\n    return k * length(z - a) * deriv / zoom < CURVE_THICKNESS;\n}\n\nconst Mobius identity = Mobius(vec2(1, 0), vec2(0), vec2(0), vec2(1, 0));\n\nconst Mobius a = Mobius(vec2(1, 0), vec2(0), vec2(0, -2), vec2(1, 0));\n\nconst Mobius b = Mobius(vec2(1, -1), vec2(1, 0), vec2(1, 0), vec2(1, 1));\n\nMobius A, B;\n\nvoid setup() {\n    A = invMobius(a);\n    B = invMobius(b);\n    u1 = get_tangent(vec3(0, -0.25, 0.25), vec3(-1, -1, 1));\n    u2 = get_tangent(vec3(0, -0.25, 0.25), vec3(1, -1, 1));\n}\n\nconst float rr = 0.25;\nconst float ss = 1. / 3.;\nconst vec3 circ_B = vec3(-1, -1, 1);\nconst vec3 circ_b = vec3(1, -1, 1);\nconst vec3 circ_A = vec3(0, -rr, rr);\nconst vec3 trap1 = vec3(-0.5, 0, 0.5);\nconst vec3 trap2 = vec3(0.5, 0, 0.5);\nconst vec3 trap3 = vec3(0., ss - 1., ss);\n\nfloat sdTrapped(vec2 z) {\n    float db = length(z - circ_b.xy) - circ_b.z;\n    float dB = length(z - circ_B.xy) - circ_B.z;\n    float dA = length(z - circ_A.xy) - circ_A.z;\n    float da = -z.y;\n    return min(min(da, dA), min(db, dB));\n}\n\nvoid fold(inout vec2 z, inout float count, inout float deriv) {\n    for (int i = 0; i < MAX_ITER; i++) {\n        bool found = true;\n        if (z.y > 0.) {\n            deriv *= L2(cmul(A.c, z) + A.d);\n            z = applyMobius(A, z);\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (length(z - circ_A.xy) < circ_A.z) {\n            deriv *= L2(cmul(a.c, z) + a.d);\n            z = applyMobius(a, z);\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (length(z - circ_b.xy) < circ_b.z) {\n            deriv *= L2(cmul(B.c, z) + B.d);\n            z = applyMobius(B, z);\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (length(z - circ_B.xy) < circ_B.z) {\n            deriv *= L2(cmul(b.c, z) + b.d);\n            z = applyMobius(b, z);\n            count += 1.;\n            found = false;\n            continue;\n        }\n        if (found)\n            break;\n    }\n}\n\nvec3 getColor(vec2 z, in float deriv) {\n    float scale = deriv;\n    vec2 w = z;\n    float count = 0.0;\n    fold(z, count, deriv);\n    float id;\n    vec2 pts[] =\n            vec2[](vec2(-1, 0), vec2(1, 0), vec2(0), vec2(0, -1), u1, u2);\n    if (dot(z, z) > 1.) {\n        id = 0.;\n    } else if (length(z - trap1.xy) < trap1.z) {\n        id = 1.;\n    } else if (length(z - trap2.xy) < trap2.z) {\n        id = 1.;\n    } else if (length(z - trap3.xy) < trap3.z) {\n        id = 2.;\n    } else\n        id = 2.;\n\n    vec3 col;\n    if (mode == 0) {\n        if (count >= float(MAX_ITER))\n            col = vec3(0);\n        else if (count == 0.)\n            col = vec3(0);\n        else {\n            col = 0.5 + 0.5 * cos(\n                count * PI / 15. + vec3(4.4, 3.2, 2.)\n            );\n            \n        }\n    } else if (mode == 1) {\n\n        if (id == 1.) {\n            col = vec3(1, 0.5, 0.75);\n        } else {\n            col = vec3(1);\n        }\n        for (int i = 0; i < pts.length(); i++) {\n            if (Equal(z, pts[i], deriv)) {\n                col = vec3(0);\n                break;\n            }\n        }\n    }\n    else {\n        float k = mod(count, 2.);\n        col = 0.5 + 0.45 * cos(k * 9. + vec3(0, 1, 2));\n        if (id != 1.) {\n            if (k == 1.)\n                col = vec3(1);\n            else\n                col = vec3(0.9, 0.9, 0.97);\n        }\n        for (int i = 0; i < pts.length(); i++) {\n            if (Equal(z, pts[i], deriv)) {\n                col = vec3(0);\n                break;\n            }\n        }\n    }\n    if (draw_curve > 0) {\n        float d1 = min(-w.y, length(w - circ_A.xy) - circ_A.z);\n        float d2 = length(w - circ_b.xy) - circ_b.z;\n        d2 = min(d2, length(w - circ_B.xy) - circ_B.z);\n        d1 = abs(d1) * scale / zoom;\n        d2 = abs(d2) * scale / zoom;\n        float lw = 0.0125;\n        float aa1 = fwidth(d1);\n        float aa2 = fwidth(d2);\n        col = mix(col, vec3(0, 0, 1), 1. - smoothstep(lw - aa2, lw + aa2, d2));\n        col = mix(col, vec3(1, 0, 0), 1. - smoothstep(lw - aa1, lw + aa1, d1));\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    setup();\n\n    vec4 pan_vals = textureLod(iChannel0, vec2(0.5, 0.5) / iResolution.xy, 0.0);\n    zoom = textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n    float ab_anim_t =\n        textureLod(iChannel0, vec2(1.5, 0.5) / iResolution.xy, 0.0).x;\n    vec4 c_state = textureLod(iChannel0, vec2(2.5, 0.5) / iResolution.xy, 0.0);\n\n    mode = int(textureLod(iChannel0, vec2(3.5, 0.5) / iResolution.xy, 0.0).x);\n    draw_curve =\n        int(textureLod(iChannel0, vec2(4.5, 0.5) / iResolution.xy, 0.0).x);\n    int k_from = int(c_state.x);\n    int k_to = int(c_state.y);\n    float anim_timer = c_state.z;\n\n    const Mobius identity =\n        Mobius(vec2(1, 0), vec2(0), vec2(0),\n               vec2(1, 0)); // Moved identity here for use in getTransformForK\n    Mobius final_transform = identity;\n    if (abs(ab_anim_t) > 0.01) {\n        if (ab_anim_t > 0.0) {\n            final_transform = interpolateMobius(identity, A, ab_anim_t);\n        } else {\n            final_transform = interpolateMobius(identity, B, abs(ab_anim_t));\n        }\n    }\n    vec3 col = vec3(0);\n    for (int ii = 0; ii < AA; ii++) {\n        for (int jj = 0; jj < AA; jj++) {\n            vec2 o = vec2(float(ii), float(jj)) / float(AA);\n            vec2 uv = (2. * (fragCoord + o) - iResolution.xy -\n                       pan_vals.xy * pow(zoom, -1.0)) /\n                      iResolution.y;\n            uv *= zoom * 1.05;\n            vec2 den_g = cmul(final_transform.c, uv) + final_transform.d;\n            float deriv = dot(den_g, den_g);\n            vec2 z = applyMobius(final_transform, uv);\n            col += getColor(z, deriv);\n        }\n    }\n    col /= (float(AA) * float(AA));\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// https://www.shadertoy.com/view/ldyGzW\nconst int Key_A = 65;\nconst int Key_B = 66;\nconst int Key_C = 67;\nconst int Key_D = 68;\nconst int Key_E = 69;\nconst int Key_F = 70;\nconst int Key_G = 71;\nconst int Key_H = 72;\nconst int Key_I = 73;\nconst int Key_J = 74;\nconst int Key_K = 75;\nconst int Key_L = 76;\nconst int Key_M = 77;\nconst int Key_N = 78;\nconst int Key_O = 79;\nconst int Key_P = 80;\nconst int Key_Q = 81;\nconst int Key_R = 82;\nconst int Key_S = 83;\nconst int Key_T = 84;\nconst int Key_U = 85;\nconst int Key_V = 86;\nconst int Key_W = 87;\nconst int Key_X = 88;\nconst int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48;\nconst int Key_1 = 49;\nconst int Key_2 = 50;\nconst int Key_3 = 51;\nconst int Key_4 = 52;\nconst int Key_5 = 53;\nconst int Key_6 = 54;\nconst int Key_7 = 55;\nconst int Key_8 = 56;\nconst int Key_9 = 57;\nconst int Key_Space = 32;\n\nfloat ReadKeyInternal(int key, bool toggle) {\n    return textureLod(iChannel1,\n                      vec2((float(key) + .5) / 256.0, toggle ? .75 : .25), 0.0)\n        .x;\n}\n\nfloat ReadKey(int key) { return ReadKeyInternal(key, false); }\n\nfloat ReadKeyToggle(int key) { return ReadKeyInternal(key, true); }\n\n// Storage Code For Pan and Zoom\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Default output for unused pixels\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    // Pan State at (0,0)\n    if (ivec2(fragCoord.xy) == ivec2(0, 0)) {\n        vec4 prev_info = textureLod(iChannel0, vec2(0.0, 0.0), 0.0);\n        float Zoom =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).x;\n        float prev_pan_x = prev_info.x;\n        float prev_pan_y = prev_info.y;\n        float legacy_pan_x = prev_info.z;\n        float legacy_pan_y = prev_info.w;\n\n        float pan_x = (iMouse.x - abs(iMouse.z)) * Zoom + legacy_pan_x;\n        float pan_y = (iMouse.y - abs(iMouse.w)) * Zoom + legacy_pan_y;\n\n        if (iMouse.z < 0.0) {\n            legacy_pan_x = prev_pan_x;\n            legacy_pan_y = prev_pan_y;\n            pan_x = legacy_pan_x;\n            pan_y = legacy_pan_y;\n        }\n        fragColor = vec4(pan_x, pan_y, legacy_pan_x, legacy_pan_y);\n    }\n\n    // Zoom State at (10,10)\n    if (ivec2(fragCoord.xy) == ivec2(10, 10)) {\n        float x =\n            textureLod(iChannel0, vec2(10.5, 10.5) / iResolution.xy, 0.0).y;\n        x += ReadKey(Key_W) - ReadKey(Key_S);\n        float Zoom = pow(2.71, -x * 0.05);\n        fragColor = vec4(Zoom, x, 0.0, 0.0);\n    }\n\n    // Animation State at (1,0)\n    if (ivec2(fragCoord.xy) == ivec2(1, 0)) {\n        // Read previous animation state\n        float prev_anim_t = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n\n        float key_a = ReadKey(Key_A);\n        float key_b = ReadKey(Key_B);\n\n        float target_t = 0.0;\n        if (key_a > 0.0) {\n            target_t = 1.0;\n        } else if (key_b > 0.0) {\n            target_t = -1.0;\n        }\n        float speed = 3.;\n        float anim_t =\n            mix(prev_anim_t, target_t, 1.0 - exp(-iTimeDelta * speed));\n        fragColor = vec4(anim_t, 0.0, 0.0, 1.0);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(2, 0)) {\n        vec4 prev_c_state = texelFetch(iChannel0, ivec2(2, 0), 0);\n        float k_from = prev_c_state.x;\n        float k_to = prev_c_state.y;\n        float anim_timer = prev_c_state.z;\n        float prev_key_c_state = prev_c_state.w;\n\n        float key_c = ReadKey(Key_C);\n        if (anim_timer < 1.0) {\n            float anim_speed = 1.;\n            anim_timer += iTimeDelta * anim_speed;\n        }\n        anim_timer = min(anim_timer, 1.0);\n\n        if (key_c > 0.0 && prev_key_c_state == 0.0 && anim_timer >= 1.0) {\n            k_from = k_to;\n            k_to = mod(k_to + 1.0, 16.0);\n            anim_timer = 0.0;\n        }\n\n        fragColor = vec4(k_from, k_to, anim_timer, key_c);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(3, 0)) {\n        float current_mode = texelFetch(iChannel0, ivec2(3, 0), 0).x;\n        if (iFrame < 2)\n            current_mode = 0.0;\n        if (ReadKey(Key_1) > 0.0)\n            current_mode = 0.0;\n        if (ReadKey(Key_2) > 0.0)\n            current_mode = 1.0;\n        if (ReadKey(Key_3) > 0.0)\n            current_mode = 2.0;\n\n        fragColor = vec4(current_mode, 0.0, 0.0, 1.0);\n    }\n    if (ivec2(fragCoord.xy) == ivec2(4, 0)) {\n        vec4 prev_state = texelFetch(iChannel0, ivec2(4, 0), 0);\n        float current_toggle = prev_state.x;\n        float prev_key_c_state = prev_state.y;\n\n        float key_c = ReadKey(Key_C);\n        if (key_c > 0.0 && prev_key_c_state == 0.0) {\n            current_toggle = 1.0 - current_toggle;\n        }\n        fragColor = vec4(current_toggle, key_c, 0.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]},{"ver":"0.1","info":{"id":"wflcz2","date":"0","viewed":0,"name":"Sturmian neozhaolia 517","description":"xxxx","likes":0,"published":"Private","usePreview":0,"tags":["3e"]},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 3\n\nconst float TUBE_RADIUS = 0.035;\nconst float MAX_DIST = 100.0;\nconst float SURF_DIST = 0.001;\n\nint gcd(int a, int b) {\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return (a == 0) ? 1 : a;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\nfloat sdGeodesicTube(vec3 pos, vec2 tor, float p_t, float q_t) {\n    float d_torus = sdTorus(pos, tor);\n    float u = atan(pos.z, pos.x);\n    float v = atan(pos.y, length(pos.xz) - tor.x + 1e-9);\n    float val = p_t * u - q_t * v;\n    float s = abs(mod(val + PI, 2. * PI) - PI);\n    float n = length(vec2(p_t, q_t));\n    if (n < 0.1)\n        n = 1.;\n    float c = s / n;\n    float d_geodesic = tor.y * c;\n    return length(vec2(d_torus, d_geodesic)) - TUBE_RADIUS;\n}\nvec2 map(vec3 pos, vec2 tor, float p_t, float q_t) {\n    float dt = sdTorus(pos, tor);\n    float dtu = sdGeodesicTube(pos, tor, p_t, q_t);\n    if (dtu < dt)\n        return vec2(dtu, 2.);\n    return vec2(dt, 1.);\n}\nvec3 calcNormal(vec3 pos, vec2 tor, float p_t, float q_t) {\n    vec2 e = vec2(.001, 0.);\n    float d = map(pos, tor, p_t, q_t).x;\n    return normalize(vec3(d - map(pos - e.xyy, tor, p_t, q_t).x,\n                          d - map(pos - e.yxy, tor, p_t, q_t).x,\n                          d - map(pos - e.yyx, tor, p_t, q_t).x));\n}\nvec2 raymarch(vec3 ro, vec3 rd, vec2 tor, float p_t, float q_t) {\n    float t = 0., m = -1.;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + t * rd;\n        vec2 res = map(p, tor, p_t, q_t);\n        float d = res.x;\n        if (!(d > -1000. && d < 1000.))\n            break;\n        m = res.y;\n        if (d < SURF_DIST || t > MAX_DIST)\n            break;\n        t += d;\n    }\n    if (t > MAX_DIST)\n        t = -1.;\n    return vec2(t, m);\n}\n\nmat2 getAnimatedMatrix(out mat2 M_inv, out float show_cross) {\n    vec2 active_ab = texelFetch(iChannel0, REG_ACTIVE_MATRIX_AB, 0).xy;\n    vec2 active_cd = texelFetch(iChannel0, REG_ACTIVE_MATRIX_CD, 0).xy;\n    vec2 old_active_ab = texelFetch(iChannel0, REG_OLD_ACTIVE_MATRIX_AB, 0).xy;\n    vec2 old_active_cd = texelFetch(iChannel0, REG_OLD_ACTIVE_MATRIX_CD, 0).xy;\n\n    vec4 anim_state = texelFetch(iChannel0, REG_ANIM_TIMER, 0);\n    float anim_timer = anim_state.x;\n    show_cross = anim_state.y;\n\n    mat2 M_old = mat2(old_active_ab.x, old_active_cd.x, old_active_ab.y,\n                      old_active_cd.y);\n    mat2 M_new = mat2(active_ab.x, active_cd.x, active_ab.y, active_cd.y);\n    float t = smoothstep(0.0, 1.0, anim_timer);\n    mat2 M_anim = M_old * (1.0 - t) + M_new * t;\n\n\n    float det = determinant(M_anim);\n    if (abs(det) > 0.0001) {\n        M_inv = inverse(M_anim);\n    } else {\n        M_inv = mat2(1.0);\n    }\n\n    return M_anim;\n}\n\nvec3 render_scene(vec2 fragCoord, vec2 resolution, float p, float q,\n                  vec2 camera_rot) {\n    mat2 M_inv;\n    float show_cross_unused;\n    mat2 M_anim = getAnimatedMatrix(M_inv, show_cross_unused);\n\n    ivec2 slope_int = ivec2(round(p), round(q));\n    int common_divisor = gcd(slope_int.x, slope_int.y);\n    vec2 reduced_slope = vec2(slope_int) / float(common_divisor);\n\n    vec2 twisted_slope = M_anim * reduced_slope;\n    float p_twisted = twisted_slope.x;\n    float q_twisted = twisted_slope.y;\n\n    float yaw = camera_rot.x;\n    float pitch = camera_rot.y;\n    if (iMouse.z <= 0.0) {\n        yaw += iTime * 0.3;\n    }\n    float dist = 3.0;\n    vec3 ro;\n    ro.x = dist * cos(pitch) * sin(yaw);\n    ro.y = dist * sin(pitch);\n    ro.z = dist * cos(pitch) * cos(yaw);\n    ro.y += 0.5;\n    vec3 ta = vec3(0.0, -0.1, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec2 p_scene = (-resolution + 2.0 * fragCoord) / resolution.y;\n    vec3 rd = normalize(p_scene.x * uu + p_scene.y * vv + 1.5 * ww);\n    vec2 torus = vec2(1.0, 0.5);\n    vec2 hit = raymarch(ro, rd, torus, p_twisted, q_twisted);\n    float t = hit.x;\n    float materialID = hit.y;\n    vec3 col = vec3(0.08) * (1.0 - 0.3 * length(p_scene)) + 0.02 * rd.y;\n\n    if (t > 0.0) {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos, torus, p_twisted, q_twisted);\n        vec3 lig = normalize(vec3(0.7, 0.6, 0.3));\n        vec3 hal = normalize(-rd + lig);\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float amb = clamp(0.7, 0.0, 1.0) + 0.3 * nor.y;\n        if (materialID > 1.5) {\n            col = UI_ACCENT_COLOR;\n            col = col * (amb * 0.3 + dif * 0.7);\n            float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n            col += vec3(1.0) * spe * 0.5;\n        } else {\n            const float fr = 16.0;\n            vec2 uv =\n                vec2(atan(pos.z, pos.x), atan(pos.y, length(pos.xz) - torus.x));\n            vec2 transformed_uv = M_inv * (uv / (2.0 * PI));\n            vec2 scaled_uv = transformed_uv * fr;\n            vec2 iuv = floor(scaled_uv);\n            float checker_pattern = mod(iuv.x + iuv.y, 2.0);\n            vec3 base_col = (checker_pattern > 0.5) ? vec3(1.0) : vec3(0.6);\n            vec2 fuv = fract(scaled_uv);\n            vec2 dist_to_edge = min(fuv, 1.0 - fuv);\n            float dist_to_line = min(dist_to_edge.x, dist_to_edge.y);\n            float line_width = 0.02;\n            float aa = fwidth(dist_to_line) * 1.5;\n            float line_intensity =\n                1.0 -\n                smoothstep(line_width - aa, line_width + aa, dist_to_line);\n            vec3 line_color = vec3(0.1);\n            col = mix(base_col, line_color, line_intensity);\n            col *=\n                vec3(0.15, 0.25, 0.35) * amb + 1.05 * vec3(1.0, 0.9, 0.7) * dif;\n        }\n    }\n    return sqrt(col);\n}\n\nvec3 render_ui(vec2 fragCoord, float p, float q, float a, float b, float c,\n               float d) {\n    vec3 final_col = UI_BACKGROUND_COLOR;\n    float aa = 1.5 / iResolution.y;\n    float text_dist = 1e5;\n    vec3 button_layer = vec3(0.0);\n    float title_size = iResolution.y * UI_TITLE_TEXT_SIZE_FRAC;\n    float num_size_pq = iResolution.y * UI_PQ_NUM_SIZE_FRAC;\n    float num_size_abcd = iResolution.y * UI_ABCD_NUM_SIZE_FRAC;\n    float btn_radius_pq = iResolution.y * UI_PQ_BTN_RADIUS_FRAC;\n    float btn_radius_abcd = iResolution.y * UI_ABCD_BTN_RADIUS_FRAC;\n    int slope_chars[5] = int[](83, 76, 79, 80, 69);\n    text_dist = min(text_dist, get_string_dist(iChannel1, fragCoord,\n                                               SLOPE_TITLE_POS(iResolution.xy),\n                                               title_size, slope_chars, 5));\n    text_dist = min(text_dist,\n                    get_number_dist(iChannel1, fragCoord,\n                                    P_NUM_POS(iResolution.xy), num_size_pq, p));\n    button_layer += draw_button(\n        fragCoord, iMouse.xy, P_BTN_UP_POS(iResolution.xy), btn_radius_pq, PI);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, P_BTN_DOWN_POS(iResolution.xy),\n                    btn_radius_pq, 0.0);\n    text_dist = min(text_dist,\n                    get_number_dist(iChannel1, fragCoord,\n                                    Q_NUM_POS(iResolution.xy), num_size_pq, q));\n    button_layer += draw_button(\n        fragCoord, iMouse.xy, Q_BTN_UP_POS(iResolution.xy), btn_radius_pq, PI);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, Q_BTN_DOWN_POS(iResolution.xy),\n                    btn_radius_pq, 0.0);\n    int twist_chars[5] = int[](84, 87, 73, 83, 84);\n    text_dist = min(text_dist, get_string_dist(iChannel1, fragCoord,\n                                               TWIST_TITLE_POS(iResolution.xy),\n                                               title_size, twist_chars, 5));\n    text_dist = min(text_dist, get_number_dist(iChannel1, fragCoord,\n                                               A_NUM_POS(iResolution.xy),\n                                               num_size_abcd, a));\n    text_dist = min(text_dist, get_number_dist(iChannel1, fragCoord,\n                                               B_NUM_POS(iResolution.xy),\n                                               num_size_abcd, b));\n    text_dist = min(text_dist, get_number_dist(iChannel1, fragCoord,\n                                               C_NUM_POS(iResolution.xy),\n                                               num_size_abcd, c));\n    text_dist = min(text_dist, get_number_dist(iChannel1, fragCoord,\n                                               D_NUM_POS(iResolution.xy),\n                                               num_size_abcd, d));\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, A_BTN_UP_POS(iResolution.xy),\n                    btn_radius_abcd, PI);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, A_BTN_DOWN_POS(iResolution.xy),\n                    btn_radius_abcd, 0.0);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, B_BTN_UP_POS(iResolution.xy),\n                    btn_radius_abcd, PI);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, B_BTN_DOWN_POS(iResolution.xy),\n                    btn_radius_abcd, 0.0);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, C_BTN_UP_POS(iResolution.xy),\n                    btn_radius_abcd, PI);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, C_BTN_DOWN_POS(iResolution.xy),\n                    btn_radius_abcd, 0.0);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, D_BTN_UP_POS(iResolution.xy),\n                    btn_radius_abcd, PI);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, D_BTN_DOWN_POS(iResolution.xy),\n                    btn_radius_abcd, 0.0);\n    final_col =\n        mix(final_col, UI_TEXT_COLOR, 1.0 - smoothstep(-aa, aa, text_dist));\n    final_col += button_layer;\n    text_dist = 1e5;\n    text_dist =\n        min(text_dist, font_dist(iChannel1,\n                                 fragCoord - vec2(UI_CENTER_X(iResolution.xy),\n                                                  P_NUM_POS(iResolution.xy).y),\n                                 num_size_pq, 47));\n    final_col = mix(final_col, UI_ELEMENT_COLOR,\n                    1.0 - smoothstep(-0.5, 0.5, text_dist));\n    float h_offset = iResolution.y * UI_MATRIX_BRACKET_H_OFFSET_FRAC;\n    float v_offset = iResolution.y * UI_MATRIX_BRACKET_V_OFFSET_FRAC;\n    float line_x_pos_left = A_NUM_POS(iResolution.xy).x - h_offset;\n    float line_x_pos_right = B_NUM_POS(iResolution.xy).x + h_offset;\n    float line_y_start = A_NUM_POS(iResolution.xy).y - v_offset;\n    float line_y_end = C_NUM_POS(iResolution.xy).y + v_offset;\n    float matrix_line =\n        sdSegment(fragCoord, vec2(line_x_pos_left, line_y_start),\n                  vec2(line_x_pos_left, line_y_end));\n    matrix_line = min(matrix_line,\n                      sdSegment(fragCoord, vec2(line_x_pos_right, line_y_start),\n                                vec2(line_x_pos_right, line_y_end)));\n    final_col = mix(final_col, UI_ELEMENT_COLOR,\n                    1.0 - smoothstep(0.8, 1.2, matrix_line));\n\n    mat2 M_inv_unused;\n    float show_cross;\n    mat2 M_anim = getAnimatedMatrix(M_inv_unused, show_cross);\n\n    if (show_cross > 0.5) {\n        vec2 cross_center = vec2(\n            UI_CENTER_X(iResolution.xy),\n            (A_NUM_POS(iResolution.xy).y + C_NUM_POS(iResolution.xy).y) * 0.5);\n        float cross_size = iResolution.y * UI_CROSS_SIZE_FRAC;\n        vec2 p1 = cross_center + vec2(-cross_size, cross_size);\n        vec2 p2 = cross_center + vec2(cross_size, -cross_size);\n        vec2 p3 = cross_center + vec2(cross_size, cross_size);\n        vec2 p4 = cross_center + vec2(-cross_size, -cross_size);\n        float dist_to_cross =\n            min(sdSegment(fragCoord, p1, p2), sdSegment(fragCoord, p3, p4));\n        float cross_thickness = 1.0;\n        float cross_aa = 1.0;\n        vec3 cross_color = vec3(1.0, 0.2, 0.2);\n        float cross_alpha =\n            1.0 - smoothstep(cross_thickness - cross_aa,\n                             cross_thickness + cross_aa, dist_to_cross);\n        final_col = mix(final_col, cross_color, cross_alpha);\n    }\n\n    float ui_width = UI_WIDTH_PIXELS(iResolution.xy);\n    float viz_margin = iResolution.y * UI_VIZBOX_MARGIN_FRAC;\n    float viz_size = min(ui_width - viz_margin, iResolution.y * 0.4);\n    vec4 vizBox = vec4(UI_CENTER_X(iResolution.xy),\n                       viz_size * 0.5 + iResolution.y * UI_VIZBOX_Y_OFFSET_FRAC,\n                       vec2(viz_size) * 0.5);\n    if (insideBox(fragCoord, vizBox)) {\n        vec2 local_uv =\n            (fragCoord - (vizBox.xy - vizBox.zw)) / (2.0 * vizBox.zw);\n        vec3 box_col = UI_BACKGROUND_COLOR;\n        float border_width = 0.015;\n        vec2 border_dist = min(local_uv, 1.0 - local_uv);\n        float border_aa = 1.5 / vizBox.z;\n        float border =\n            smoothstep(border_width - border_aa, border_width + border_aa,\n                       min(border_dist.x, border_dist.y));\n        box_col = mix(vec3(1.0), box_col, border);\n\n        vec2 original_slope = vec2(p, q);\n        vec2 twisted_slope = M_anim * original_slope;\n\n        float billiard_dist =\n            twisted_slope.x * local_uv.x - twisted_slope.y * local_uv.y;\n        \n        float line_value = fract(billiard_dist);\n        float line_width_in_uv_space = fwidth(billiard_dist)*2.0;\n        float dist_to_line = min(line_value, 1.0 - line_value);\n        float billiard_line = smoothstep(0.5 * line_width_in_uv_space, -0.5 * line_width_in_uv_space, dist_to_line);\n\n        box_col = mix(box_col, UI_ACCENT_COLOR, billiard_line);\n        final_col = box_col;\n    }\n    return final_col;\n}\n\nvec3 render(in vec2 fragCoord) {\n    vec3 col;\n    float ui_width = UI_WIDTH_PIXELS(iResolution.xy);\n    if (fragCoord.x < ui_width) {\n        vec2 pq = texelFetch(iChannel0, REG_PQ, 0).xy;\n        vec2 ab = texelFetch(iChannel0, REG_MATRIX_AB, 0).xy;\n        vec2 cd = texelFetch(iChannel0, REG_MATRIX_CD, 0).xy;\n        col = render_ui(fragCoord, pq.x, pq.y, ab.x, ab.y, cd.x, cd.y);\n        float border =\n            smoothstep(0.0, 2.0 / iResolution.x, abs(fragCoord.x - ui_width));\n        col = mix(col, UI_BORDER_COLOR, 1.0 - border);\n    } else {\n        vec2 pq = texelFetch(iChannel0, REG_PQ, 0).xy;\n        vec2 camera_rot = texelFetch(iChannel0, REG_CAMERA, 0).xy;\n        vec2 scene_coord = fragCoord - vec2(ui_width, 0.0);\n        vec2 scene_res = vec2(iResolution.x - ui_width, iResolution.y);\n        col = render_scene(scene_coord, scene_res, pq.x, pq.y, camera_rot);\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 total_col = vec3(0.0);\n#if AA > 1\n    for (int m = 0; m < AA; m++) {\n        for (int n = 0; n < AA; n++) {\n            vec2 offset = (vec2(float(m), float(n)) + 0.5) / float(AA);\n            vec2 sub_pixel_coord = floor(fragCoord) + offset;\n            total_col += render(sub_pixel_coord);\n        }\n    }\n    total_col /= float(AA * AA);\n#else\n    total_col = render(fragCoord);\n#endif\n    total_col +=\n        fract(sin(fragCoord.x * vec3(13, 1, 11) + fragCoord.y * vec3(1, 7, 5)) *\n              158.391832) /\n        255.0;\n    fragColor = vec4(total_col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 fc = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0, fc, 0);\n\n    if (iFrame == 0) {\n        if (fc == REG_PQ) fragColor = vec4(1.0, 1.0, 0.0, 0.0);\n        if (fc == REG_MATRIX_AB) fragColor = vec4(1.0, -1.0, 0.0, 0.0);\n        if (fc == REG_MATRIX_CD) fragColor = vec4(0.0, 1.0, 0.0, 0.0);\n        if (fc == REG_MOUSE) fragColor = vec4(-1.0, -1.0, 0.0, 0.0);\n        if (fc == REG_CAMERA) fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        if (fc == REG_ACTIVE_MATRIX_AB) fragColor = vec4(1.0, -1.0, 0.0, 0.0);\n        if (fc == REG_ACTIVE_MATRIX_CD) fragColor = vec4(0.0, 1.0, 0.0, 0.0);\n        if (fc == REG_OLD_ACTIVE_MATRIX_AB) fragColor = vec4(1.0, -1.0, 0.0, 0.0);\n        if (fc == REG_OLD_ACTIVE_MATRIX_CD) fragColor = vec4(0.0, 1.0, 0.0, 0.0);\n        if (fc == REG_ANIM_TIMER) fragColor = vec4(2.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    vec2 pq = texelFetch(iChannel0, REG_PQ, 0).xy;\n    vec2 display_ab = texelFetch(iChannel0, REG_MATRIX_AB, 0).xy;\n    vec2 display_cd = texelFetch(iChannel0, REG_MATRIX_CD, 0).xy;\n    vec2 active_ab = texelFetch(iChannel0, REG_ACTIVE_MATRIX_AB, 0).xy;\n    vec2 active_cd = texelFetch(iChannel0, REG_ACTIVE_MATRIX_CD, 0).xy;\n    vec2 old_active_ab = texelFetch(iChannel0, REG_OLD_ACTIVE_MATRIX_AB, 0).xy;\n    vec2 old_active_cd = texelFetch(iChannel0, REG_OLD_ACTIVE_MATRIX_CD, 0).xy;\n    \n    vec4 anim_state = texelFetch(iChannel0, REG_ANIM_TIMER, 0);\n    float anim_timer = anim_state.x;\n    float show_cross = anim_state.y;\n    \n    vec4 prev_mouse = texelFetch(iChannel0, REG_MOUSE, 0);\n    vec2 camera_rot = texelFetch(iChannel0, REG_CAMERA, 0).xy;\n    \n    bool mouse_clicked = iMouse.z > 0.0 && prev_mouse.z <= 0.0;\n    \n    if(anim_timer < 1.0) {\n        anim_timer += 0.04;\n    }\n\n    if (iMouse.x < UI_WIDTH_PIXELS(iResolution.xy)) {\n        if (mouse_clicked) {\n            bool matrix_button_clicked = false;\n            vec2 prospective_ab = display_ab;\n            vec2 prospective_cd = display_cd;\n\n            if      (insideBox(iMouse.xy, P_UP_BOX(iResolution.xy)))   { pq.x++; }\n            else if (insideBox(iMouse.xy, P_DOWN_BOX(iResolution.xy))) { pq.x--; }\n            else if (insideBox(iMouse.xy, Q_UP_BOX(iResolution.xy)))   { pq.y++; }\n            else if (insideBox(iMouse.xy, Q_DOWN_BOX(iResolution.xy))) { pq.y--; }\n            \n            else if (insideBox(iMouse.xy, A_UP_BOX(iResolution.xy)))   { prospective_ab.x++; matrix_button_clicked = true; }\n            else if (insideBox(iMouse.xy, A_DOWN_BOX(iResolution.xy))) { prospective_ab.x--; matrix_button_clicked = true; }\n            else if (insideBox(iMouse.xy, B_UP_BOX(iResolution.xy)))   { prospective_ab.y++; matrix_button_clicked = true; }\n            else if (insideBox(iMouse.xy, B_DOWN_BOX(iResolution.xy))) { prospective_ab.y--; matrix_button_clicked = true; }\n            \n            else if (insideBox(iMouse.xy, C_UP_BOX(iResolution.xy)))   { prospective_cd.x++; matrix_button_clicked = true; }\n            else if (insideBox(iMouse.xy, C_DOWN_BOX(iResolution.xy))) { prospective_cd.x--; matrix_button_clicked = true; }\n            else if (insideBox(iMouse.xy, D_UP_BOX(iResolution.xy)))   { prospective_cd.y++; matrix_button_clicked = true; }\n            else if (insideBox(iMouse.xy, D_DOWN_BOX(iResolution.xy))) { prospective_cd.y--; matrix_button_clicked = true; }\n            \n            if (matrix_button_clicked) {\n                display_ab = prospective_ab;\n                display_cd = prospective_cd;\n\n                float det = display_ab.x * display_cd.y - display_ab.y * display_cd.x;\n                if (abs(det - 1.0) < 0.0001) {\n                    old_active_ab = active_ab;\n                    old_active_cd = active_cd;\n                    active_ab = display_ab;\n                    active_cd = display_cd;\n                    anim_timer = 0.0;\n                    show_cross = 0.0;\n                } else {\n                    anim_timer = 2.0;\n                    show_cross = 1.0;\n                }\n            }\n        }\n    } \n    else if (iMouse.z > 0.0) {\n        vec2 delta = iMouse.xy - prev_mouse.xy;\n        camera_rot.x -= delta.x * 0.005;\n        camera_rot.y += delta.y * 0.005;\n        camera_rot.y = clamp(camera_rot.y, -PI / 2.0 + 0.05, PI / 2.0 - 0.05);\n    }\n\n    if (fc == REG_PQ) fragColor = vec4(pq, 0, 0);\n    if (fc == REG_MATRIX_AB) fragColor = vec4(display_ab, 0, 0);\n    if (fc == REG_MATRIX_CD) fragColor = vec4(display_cd, 0, 0);\n    if (fc == REG_MOUSE) fragColor = iMouse;\n    if (fc == REG_CAMERA) fragColor = vec4(camera_rot, 0, 0);\n    if (fc == REG_ACTIVE_MATRIX_AB) fragColor = vec4(active_ab, 0, 0);\n    if (fc == REG_ACTIVE_MATRIX_CD) fragColor = vec4(active_cd, 0, 0);\n    if (fc == REG_OLD_ACTIVE_MATRIX_AB) fragColor = vec4(old_active_ab, 0, 0);\n    if (fc == REG_OLD_ACTIVE_MATRIX_CD) fragColor = vec4(old_active_cd, 0, 0);\n    if (fc == REG_ANIM_TIMER) fragColor = vec4(anim_timer, show_cross, 0.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\n// --- UI Theming Constants ---\n#define UI_WIDTH_FRAC 0.25\n#define UI_BACKGROUND_COLOR vec3(0.1, 0.12, 0.15)\n#define UI_TEXT_COLOR vec3(0.9)\n#define UI_ELEMENT_COLOR vec3(0.9)\n#define UI_BUTTON_COLOR vec3(0.4)\n#define UI_BUTTON_HOVER_COLOR vec3(0.8, 0., 0.8)\n#define UI_ACCENT_COLOR vec3(1.0, 0.7, 0.2)\n#define UI_BORDER_COLOR vec3(0.05)\n\n// --- UI Layout Base Constants (NOW AS PROPORTIONS) ---\n#define DESIGN_RESOLUTION_Y 540.0\n#define UI_SLOPE_TITLE_Y_FRAC (40.0 / DESIGN_RESOLUTION_Y)\n#define UI_SLOPE_NUM_Y_FRAC (100.0 / DESIGN_RESOLUTION_Y)\n#define UI_SLOPE_NUM_X_FRAC 0.2\n#define UI_PQ_BTN_Y_SPACING_FRAC (30.0 / DESIGN_RESOLUTION_Y)\n#define UI_PQ_BTN_RADIUS_FRAC (30.0 / DESIGN_RESOLUTION_Y)\n#define UI_TWIST_TITLE_Y_FRAC (180.0 / DESIGN_RESOLUTION_Y)\n#define UI_TWIST_TOP_ROW_Y_FRAC (240.0 / DESIGN_RESOLUTION_Y)\n#define UI_TWIST_BOTTOM_ROW_Y_FRAC (320.0 / DESIGN_RESOLUTION_Y)\n#define UI_TWIST_NUM_X_FRAC 0.2\n#define UI_ABCD_BTN_Y_SPACING_FRAC (20.0 / DESIGN_RESOLUTION_Y)\n#define UI_ABCD_BTN_RADIUS_FRAC (28.0 / DESIGN_RESOLUTION_Y)\n#define UI_BTN_BBOX_SIZE_FRAC (15.0 / DESIGN_RESOLUTION_Y)\n#define UI_TITLE_TEXT_SIZE_FRAC (20.0 / DESIGN_RESOLUTION_Y)\n#define UI_PQ_NUM_SIZE_FRAC (30.0 / DESIGN_RESOLUTION_Y)\n#define UI_ABCD_NUM_SIZE_FRAC (20.0 / DESIGN_RESOLUTION_Y)\n#define UI_MATRIX_BRACKET_H_OFFSET_FRAC (30.0 / DESIGN_RESOLUTION_Y)\n#define UI_MATRIX_BRACKET_V_OFFSET_FRAC (110.0 / DESIGN_RESOLUTION_Y)\n#define UI_VIZBOX_Y_OFFSET_FRAC (20.0 / DESIGN_RESOLUTION_Y)\n#define UI_VIZBOX_MARGIN_FRAC (100.0 / DESIGN_RESOLUTION_Y)\n#define UI_CROSS_SIZE_FRAC (12.0 / DESIGN_RESOLUTION_Y)\n\n// --- UI Layout Calculation Macros ---\n#define UI_WIDTH_PIXELS(res) ((res).x * UI_WIDTH_FRAC)\n#define UI_CENTER_X(res) (UI_WIDTH_PIXELS(res) * 0.5)\n#define SLOPE_TITLE_POS(res)                                                   \\\n    vec2(UI_CENTER_X(res), (res).y * (1.0 - UI_SLOPE_TITLE_Y_FRAC))\n#define P_NUM_POS(res)                                                         \\\n    vec2(UI_CENTER_X(res) - UI_WIDTH_PIXELS(res) * UI_SLOPE_NUM_X_FRAC,        \\\n         (res).y * (1.0 - UI_SLOPE_NUM_Y_FRAC))\n#define Q_NUM_POS(res)                                                         \\\n    vec2(UI_CENTER_X(res) + UI_WIDTH_PIXELS(res) * UI_SLOPE_NUM_X_FRAC,        \\\n         (res).y * (1.0 - UI_SLOPE_NUM_Y_FRAC))\n#define P_BTN_UP_POS(res)                                                      \\\n    (P_NUM_POS(res) + vec2(0.0, (res).y * UI_PQ_BTN_Y_SPACING_FRAC))\n#define P_BTN_DOWN_POS(res)                                                    \\\n    (P_NUM_POS(res) - vec2(0.0, (res).y * UI_PQ_BTN_Y_SPACING_FRAC))\n#define Q_BTN_UP_POS(res)                                                      \\\n    (Q_NUM_POS(res) + vec2(0.0, (res).y * UI_PQ_BTN_Y_SPACING_FRAC))\n#define Q_BTN_DOWN_POS(res)                                                    \\\n    (Q_NUM_POS(res) - vec2(0.0, (res).y * UI_PQ_BTN_Y_SPACING_FRAC))\n#define TWIST_TITLE_POS(res)                                                   \\\n    vec2(UI_CENTER_X(res), (res).y * (1.0 - UI_TWIST_TITLE_Y_FRAC))\n#define A_NUM_POS(res)                                                         \\\n    (vec2(UI_CENTER_X(res), (res).y * (1.0 - UI_TWIST_TOP_ROW_Y_FRAC)) -       \\\n     vec2(UI_WIDTH_PIXELS(res) * UI_TWIST_NUM_X_FRAC, 0.0))\n#define B_NUM_POS(res)                                                         \\\n    (vec2(UI_CENTER_X(res), (res).y * (1.0 - UI_TWIST_TOP_ROW_Y_FRAC)) +       \\\n     vec2(UI_WIDTH_PIXELS(res) * UI_TWIST_NUM_X_FRAC, 0.0))\n#define C_NUM_POS(res)                                                         \\\n    (vec2(UI_CENTER_X(res), (res).y * (1.0 - UI_TWIST_BOTTOM_ROW_Y_FRAC)) -    \\\n     vec2(UI_WIDTH_PIXELS(res) * UI_TWIST_NUM_X_FRAC, 0.0))\n#define D_NUM_POS(res)                                                         \\\n    (vec2(UI_CENTER_X(res), (res).y * (1.0 - UI_TWIST_BOTTOM_ROW_Y_FRAC)) +    \\\n     vec2(UI_WIDTH_PIXELS(res) * UI_TWIST_NUM_X_FRAC, 0.0))\n#define A_BTN_UP_POS(res)                                                      \\\n    (A_NUM_POS(res) + vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define A_BTN_DOWN_POS(res)                                                    \\\n    (A_NUM_POS(res) - vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define B_BTN_UP_POS(res)                                                      \\\n    (B_NUM_POS(res) + vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define B_BTN_DOWN_POS(res)                                                    \\\n    (B_NUM_POS(res) - vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define C_BTN_UP_POS(res)                                                      \\\n    (C_NUM_POS(res) + vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define C_BTN_DOWN_POS(res)                                                    \\\n    (C_NUM_POS(res) - vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define D_BTN_UP_POS(res)                                                      \\\n    (D_NUM_POS(res) + vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define D_BTN_DOWN_POS(res)                                                    \\\n    (D_NUM_POS(res) - vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define P_UP_BOX(res)                                                          \\\n    vec4(P_BTN_UP_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define P_DOWN_BOX(res)                                                        \\\n    vec4(P_BTN_DOWN_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define Q_UP_BOX(res)                                                          \\\n    vec4(Q_BTN_UP_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define Q_DOWN_BOX(res)                                                        \\\n    vec4(Q_BTN_DOWN_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define A_UP_BOX(res)                                                          \\\n    vec4(A_BTN_UP_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define A_DOWN_BOX(res)                                                        \\\n    vec4(A_BTN_DOWN_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define B_UP_BOX(res)                                                          \\\n    vec4(B_BTN_UP_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define B_DOWN_BOX(res)                                                        \\\n    vec4(B_BTN_DOWN_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define C_UP_BOX(res)                                                          \\\n    vec4(C_BTN_UP_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define C_DOWN_BOX(res)                                                        \\\n    vec4(C_BTN_DOWN_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define D_UP_BOX(res)                                                          \\\n    vec4(D_BTN_UP_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define D_DOWN_BOX(res)                                                        \\\n    vec4(D_BTN_DOWN_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n\n// --- Buffer Register Definitions ---\n#define REG_PQ ivec2(0, 0)\n#define REG_MATRIX_AB ivec2(1, 0) // Stores the DISPLAY matrix values\n#define REG_MATRIX_CD ivec2(2, 0) //\n#define REG_MOUSE ivec2(3, 0)\n#define REG_CAMERA ivec2(4, 0)\n#define REG_ACTIVE_MATRIX_AB                                                   \\\n    ivec2(5, 0) // Stores the last VALID matrix for rendering\n#define REG_ACTIVE_MATRIX_CD ivec2(6, 0) //\n#define REG_OLD_ACTIVE_MATRIX_AB                                               \\\n    ivec2(7, 0) // Stores the previous VALID matrix for animation start\n#define REG_OLD_ACTIVE_MATRIX_CD ivec2(8, 0) //\n#define REG_ANIM_TIMER ivec2(9, 0)           // x: timer, y: show_cross_flag\n\n// --- General Drawing & Math Functions ---\nfloat sdTriangle(vec2 p) {\n    p.y = -p.y;\n    return max(abs(p.x) * 0.866025 + p.y * 0.5, -p.y);\n}\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\nbool insideBox(vec2 p, vec4 b) {\n    vec2 q = abs(p - b.xy);\n    return all(lessThan(q, b.zw));\n}\nfloat font_dist(sampler2D font_texture, vec2 tpos, float size, int char_code) {\n    if (char_code < 32 || char_code > 127)\n        return 1e5;\n    float scl = 0.63 / size;\n    vec2 uv = tpos * scl;\n    ivec2 grid_pos = ivec2(char_code % 16, 15 - (char_code / 16));\n    vec2 font_uv = (uv + vec2(grid_pos) + 0.5) * (1.0 / 16.0);\n    float dist_from_tex = texture(font_texture, font_uv).a - 0.5;\n    vec2 box = abs(uv) - 0.5;\n    return max(dist_from_tex, max(box.x, box.y)) / scl;\n}\nfloat get_string_dist(sampler2D font_texture, vec2 fragCoord, vec2 p,\n                      float size, const int chars[5], int len) {\n    vec2 text_pos = fragCoord - p;\n    float char_spacing = size * 0.8;\n    float x_offset = text_pos.x + float(len - 1) * 0.5 * char_spacing;\n    int char_idx = int(floor(x_offset / char_spacing + 0.5));\n    if (char_idx < 0 || char_idx >= len)\n        return 1e5;\n    vec2 char_center_offset = vec2(float(char_idx) * char_spacing -\n                                       float(len - 1) * 0.5 * char_spacing,\n                                   0.0);\n    return font_dist(font_texture, text_pos - char_center_offset, size,\n                     chars[char_idx]);\n}\nfloat get_number_dist(sampler2D font_texture, vec2 fragCoord, vec2 p,\n                      float size, float num) {\n    vec2 text_pos = fragCoord - p;\n    float char_spacing = size * 0.7;\n    float num_abs = abs(num);\n    bool is_neg = num < 0.0;\n    int whole_part = int(floor(num_abs));\n    int num_digits = (whole_part == 0)\n                         ? 1\n                         : int(floor(log2(float(whole_part)) / log2(10.0))) + 1;\n    float total_width = float(num_digits) * char_spacing;\n    if (is_neg)\n        total_width += char_spacing;\n    float x_offset = text_pos.x + total_width * 0.5;\n    if (is_neg) {\n        if (x_offset < char_spacing) {\n            return font_dist(\n                font_texture,\n                text_pos - vec2(-total_width * 0.5 + char_spacing * 0.5, 0.0),\n                size, 45);\n        }\n        x_offset -= char_spacing;\n    }\n    int digit_idx = int(floor(x_offset / char_spacing));\n    if (digit_idx < 0 || digit_idx >= num_digits)\n        return 1e5;\n    float power_of_10 = pow(10.0, float(num_digits - 1 - digit_idx));\n    int digit = int(mod(floor(float(whole_part) / power_of_10), 10.0));\n    vec2 digit_center_offset =\n        vec2((is_neg ? char_spacing : 0.0) - total_width * 0.5 +\n                 (float(digit_idx) + 0.5) * char_spacing,\n             0.0);\n    return font_dist(font_texture, text_pos - digit_center_offset, size,\n                     digit + 48);\n}\nvec3 draw_button(vec2 fragCoord, vec2 mouseCoord, vec2 center, float size,\n                 float orientation) {\n    vec2 p = fragCoord - center;\n    mat2 rot = mat2(cos(orientation), -sin(orientation), sin(orientation),\n                    cos(orientation));\n    p = rot * p;\n    float d = sdTriangle(p / size);\n    vec3 col = UI_BUTTON_COLOR;\n    if (length(center - mouseCoord) < size * 1.1) {\n        col = UI_BUTTON_HOVER_COLOR;\n    }\n    float aa = fwidth(abs(d));\n    return mix(vec3(0.0), col, 1.0 - smoothstep(0.15 - aa, 0.15 + aa, d));\n}\n","name":"Common","description":"","type":"common"}]},{"ver":"0.1","info":{"id":"3cXyDS","date":"1755960387","viewed":125,"name":"Mapping class group of the torus","description":"Interactive demo showing the mapping class group of the torus is SL(2,Z).","likes":15,"published":"Public API","usePreview":1,"tags":["torus","continuedfraction","sl2z","sturmianwords","geodesicline","dehntwist","mappingclassgroup"]},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nMapping Class Group of the Torus and Sturmian words\n\n\nLeft-hand side of the UI:\n\n**SLOPE**: \n\nA geodesic with slope p/q. This is a periodic orbit in the\nsquare, and a closed geodesic on the torus:\nit winds around the two fundamental circles of the torus, \nq times in one and p times in the other.\n\n**TWIST**: Any matrix in SL(2,Z). It acts on the \ngeodesic, sending slope p/q to the geodesic corresponding\nto M * (p/q,1). On the right-hand 3D view, you can see\nhow this twists the torus and changes the geodesic.\n\n**Sturmian word**: Each time the geodesic crosses a\nvertical edge of the square, we write down A; each time\nit crosses a horizontal edge, we write down B.\nThis produces an infinite sequence of A's and B's,\ncalled a Sturmian word. When the slope is rational,\nthe Sturmian word has a finite repetend. This repetend\nis displayed right below the TWIST matrix.\n\nAt the bottom of the UI, you see the geodesic inside the square.\n*/\n\n\n#define AA 3\n\nconst float TUBE_RADIUS = 0.035;\nconst float MAX_DIST = 100.0;\nconst float SURF_DIST = 0.001;\n\n#define MAX_WORD_LEN 24\n\nint gcd(int a, int b) {\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return (a == 0) ? 1 : a;\n}\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\nfloat sdGeodesicTube(vec3 pos, vec2 tor, float p_t, float q_t) {\n    float d_torus = sdTorus(pos, tor);\n    float u = atan(pos.z, pos.x);\n    float v = atan(pos.y, length(pos.xz) - tor.x + 1e-9);\n    float offset = 1.0 / sqrt(2.0) * PI;\n    float val = p_t * (v / (2. * PI)) - q_t * (u / (2. * PI)) + offset;\n    float d_line = fract(val);\n    d_line = min(d_line, 1.0 - d_line);\n    float n = length(vec2(p_t, q_t));\n    if (n < 0.1)\n        n = 1.;\n    float d_geodesic = tor.y * d_line * 2.0 * PI / n;\n    return length(vec2(d_torus, d_geodesic)) - TUBE_RADIUS;\n}\nvec2 map(vec3 pos, vec2 tor, float p_t, float q_t) {\n    float dt = sdTorus(pos, tor);\n    float dtu = sdGeodesicTube(pos, tor, p_t, q_t);\n    if (dtu < dt)\n        return vec2(dtu, 2.);\n    return vec2(dt, 1.);\n}\nvec3 calcNormal(vec3 pos, vec2 tor, float p_t, float q_t) {\n    vec2 e = vec2(.001, 0.);\n    float d = map(pos, tor, p_t, q_t).x;\n    return normalize(vec3(d - map(pos - e.xyy, tor, p_t, q_t).x,\n                          d - map(pos - e.yxy, tor, p_t, q_t).x,\n                          d - map(pos - e.yyx, tor, p_t, q_t).x));\n}\nvec2 raymarch(vec3 ro, vec3 rd, vec2 tor, float p_t, float q_t) {\n    float t = 0., m = -1.;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = ro + t * rd;\n        vec2 res = map(p, tor, p_t, q_t);\n        float d = res.x;\n        if (!(d > -1000. && d < 1000.))\n            break;\n        m = res.y;\n        if (d < SURF_DIST || t > MAX_DIST)\n            break;\n        t += d;\n    }\n    if (t > MAX_DIST)\n        t = -1.;\n    return vec2(t, m);\n}\n\nmat2 getAnimatedMatrix(out mat2 M_inv, out float show_cross) {\n    vec2 active_ab = texelFetch(iChannel0, REG_ACTIVE_MATRIX_AB, 0).xy;\n    vec2 active_cd = texelFetch(iChannel0, REG_ACTIVE_MATRIX_CD, 0).xy;\n    vec2 old_active_ab = texelFetch(iChannel0, REG_OLD_ACTIVE_MATRIX_AB, 0).xy;\n    vec2 old_active_cd = texelFetch(iChannel0, REG_OLD_ACTIVE_MATRIX_CD, 0).xy;\n    vec4 anim_state = texelFetch(iChannel0, REG_ANIM_TIMER, 0);\n    float anim_timer = anim_state.x;\n    show_cross = anim_state.y;\n    mat2 M_old = mat2(old_active_ab.x, old_active_cd.x, old_active_ab.y,\n                      old_active_cd.y);\n    mat2 M_new = mat2(active_ab.x, active_cd.x, active_ab.y, active_cd.y);\n    float t = smoothstep(0.0, 1.0, anim_timer);\n    mat2 M_anim = M_old * (1.0 - t) + M_new * t;\n    float det = determinant(M_anim);\n    if (abs(det) > 0.0001) {\n        M_inv = inverse(M_anim);\n    } else {\n        M_inv = mat2(1.0);\n    }\n    return M_anim;\n}\n\nint generateSturmianWord(vec2 slope, out int word[MAX_WORD_LEN]) {\n    ivec2 s_int = ivec2(round(abs(slope)));\n    int common_divisor = gcd(s_int.x, s_int.y);\n    s_int /= common_divisor;\n    int p = s_int.x; // p is vertical\n    int q = s_int.y; // q is horizontal\n    if (p < 0 || q < 0)\n        return 0;\n    if (p == 0 && q == 0)\n        return 0;\n    if (q == 0) {\n        word[0] = 65;\n        return 1;\n    }\n    if (p == 0) {\n        word[0] = 66;\n        return 1;\n    }\n    int len = p + q;\n    int loop_len = min(len, MAX_WORD_LEN);\n    float x0 = 1.0 / sqrt(2.0);\n    float y0 = 0.0;\n    int ix = 0;\n    int iy = 0;\n    for (int i = 0; i < loop_len; ++i) {\n        if (float(p) * (float(ix) + 1.0 - x0) <\n            float(q) * (float(iy) + 1.0 - y0)) {\n            word[i] = 65;\n            ix++;\n        } else {\n            word[i] = 66;\n            iy++;\n        }\n    }\n    return loop_len;\n}\n\nvec3 render_scene(vec2 fragCoord, vec2 resolution, float p, float q,\n                  vec2 camera_rot) {\n    mat2 M_inv;\n    float show_cross_unused;\n    mat2 M_anim = getAnimatedMatrix(M_inv, show_cross_unused);\n    ivec2 slope_int = ivec2(round(p), round(q));\n    int common_divisor = gcd(slope_int.x, slope_int.y);\n    vec2 reduced_slope = vec2(slope_int) / float(common_divisor);\n    vec2 twisted_slope = M_anim * reduced_slope;\n    float p_twisted = twisted_slope.x;\n    float q_twisted = twisted_slope.y;\n    float yaw = camera_rot.x;\n    float pitch = camera_rot.y;\n    if (iMouse.z <= 0.0) {\n        yaw += iTime * 0.3;\n    }\n    float dist = 3.0;\n    vec3 ro;\n    ro.x = dist * cos(pitch) * sin(yaw);\n    ro.y = dist * sin(pitch);\n    ro.z = dist * cos(pitch) * cos(yaw);\n    ro.y += 0.5;\n    vec3 ta = vec3(0.0, -0.1, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec2 p_scene = (-resolution + 2.0 * fragCoord) / resolution.y;\n    vec3 rd = normalize(p_scene.x * uu + p_scene.y * vv + 1.5 * ww);\n    vec2 torus = vec2(1.0, 0.5);\n    vec2 hit = raymarch(ro, rd, torus, p_twisted, q_twisted);\n    float t = hit.x;\n    float materialID = hit.y;\n    vec3 col = vec3(0.08) * (1.0 - 0.3 * length(p_scene)) + 0.02 * rd.y;\n    if (t > 0.0) {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos, torus, p_twisted, q_twisted);\n        vec3 lig = normalize(vec3(0.7, 0.6, 0.3));\n        vec3 hal = normalize(-rd + lig);\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float amb = clamp(0.7, 0.0, 1.0) + 0.3 * nor.y;\n        if (materialID > 1.5) {\n            col = UI_ACCENT_COLOR;\n            col = col * (amb * 0.3 + dif * 0.7);\n            float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 32.0);\n            col += vec3(1.0) * spe * 0.5;\n        } else {\n            const float fr = 16.0;\n            vec2 uv =\n                vec2(atan(pos.z, pos.x), atan(pos.y, length(pos.xz) - torus.x));\n            vec2 transformed_uv = M_inv * (uv / (2.0 * PI));\n            vec2 scaled_uv = transformed_uv * fr;\n            vec2 iuv = floor(scaled_uv);\n            float checker_pattern = mod(iuv.x + iuv.y, 2.0);\n            vec3 base_col = (checker_pattern > 0.5) ? vec3(1.0) : vec3(0.6);\n            vec2 fuv = fract(scaled_uv);\n            vec2 dist_to_edge = min(fuv, 1.0 - fuv);\n            float dist_to_line = min(dist_to_edge.x, dist_to_edge.y);\n            float line_width = 0.02;\n            float aa = fwidth(dist_to_line) * 1.5;\n            float line_intensity =\n                1.0 -\n                smoothstep(line_width - aa, line_width + aa, dist_to_line);\n            vec3 line_color = vec3(0.1);\n            col = mix(base_col, line_color, line_intensity);\n            col *=\n                vec3(0.15, 0.25, 0.35) * amb + 1.05 * vec3(1.0, 0.9, 0.7) * dif;\n        }\n    }\n    return sqrt(col);\n}\n\nvec3 render_ui(vec2 fragCoord, float p, float q, float a, float b, float c,\n               float d) {\n    vec3 final_col = UI_BACKGROUND_COLOR;\n    float aa = 1.5 / iResolution.y;\n    float text_dist = 1e5;\n    vec3 button_layer = vec3(0.0);\n    float title_size = iResolution.y * UI_TITLE_TEXT_SIZE_FRAC;\n    float num_size_pq = iResolution.y * UI_PQ_NUM_SIZE_FRAC;\n    float num_size_abcd = iResolution.y * UI_ABCD_NUM_SIZE_FRAC;\n    float sturmian_size = iResolution.y * UI_STURMIAN_WORD_SIZE_FRAC;\n    float btn_radius_pq = iResolution.y * UI_PQ_BTN_RADIUS_FRAC;\n    float btn_radius_abcd = iResolution.y * UI_ABCD_BTN_RADIUS_FRAC;\n\n    float ui_width = UI_WIDTH_PIXELS(iResolution.xy);\n    float max_viz_width = ui_width * (1.0 - 2.0 * UI_VIZBOX_H_PADDING_FRAC);\n    vec2 sturmian_pos = STURMIAN_WORD_POS(iResolution.xy);\n    float viz_top_y_limit = sturmian_pos.y - (sturmian_size * 0.5) - (iResolution.y * UI_VIZBOX_V_PADDING_FRAC);\n    float viz_bottom_y_limit = iResolution.y * UI_VIZBOX_BOTTOM_MARGIN_FRAC;\n\n    float max_viz_height = viz_top_y_limit - viz_bottom_y_limit;\n\n    float viz_size = min(max_viz_width, max_viz_height);\n\n    vec4 vizBox = vec4(\n        UI_CENTER_X(iResolution.xy),\n        viz_bottom_y_limit + viz_size * 0.5,\n        vec2(viz_size) * 0.5\n    );\n    int string_buffer[MAX_UI_STRING_LEN];\n    string_buffer[0] = 83;\n    string_buffer[1] = 76;\n    string_buffer[2] = 79;\n    string_buffer[3] = 80;\n    string_buffer[4] = 69;\n    text_dist = min(text_dist, get_string_dist(iChannel1, fragCoord,\n                                               SLOPE_TITLE_POS(iResolution.xy),\n                                               title_size, string_buffer, 5));\n    text_dist = min(text_dist,\n                    get_number_dist(iChannel1, fragCoord,\n                                    P_NUM_POS(iResolution.xy), num_size_pq, p));\n    button_layer += draw_button(\n        fragCoord, iMouse.xy, P_BTN_UP_POS(iResolution.xy), btn_radius_pq, PI);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, P_BTN_DOWN_POS(iResolution.xy),\n                    btn_radius_pq, 0.0);\n    text_dist = min(text_dist,\n                    get_number_dist(iChannel1, fragCoord,\n                                    Q_NUM_POS(iResolution.xy), num_size_pq, q));\n    button_layer += draw_button(\n        fragCoord, iMouse.xy, Q_BTN_UP_POS(iResolution.xy), btn_radius_pq, PI);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, Q_BTN_DOWN_POS(iResolution.xy),\n                    btn_radius_pq, 0.0);\n    string_buffer[0] = 84;\n    string_buffer[1] = 87;\n    string_buffer[2] = 73;\n    string_buffer[3] = 83;\n    string_buffer[4] = 84;\n    text_dist = min(text_dist, get_string_dist(iChannel1, fragCoord,\n                                               TWIST_TITLE_POS(iResolution.xy),\n                                               title_size, string_buffer, 5));\n    text_dist = min(text_dist, get_number_dist(iChannel1, fragCoord,\n                                               A_NUM_POS(iResolution.xy),\n                                               num_size_abcd, a));\n    text_dist = min(text_dist, get_number_dist(iChannel1, fragCoord,\n                                               B_NUM_POS(iResolution.xy),\n                                               num_size_abcd, b));\n    text_dist = min(text_dist, get_number_dist(iChannel1, fragCoord,\n                                               C_NUM_POS(iResolution.xy),\n                                               num_size_abcd, c));\n    text_dist = min(text_dist, get_number_dist(iChannel1, fragCoord,\n                                               D_NUM_POS(iResolution.xy),\n                                               num_size_abcd, d));\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, A_BTN_UP_POS(iResolution.xy),\n                    btn_radius_abcd, PI);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, A_BTN_DOWN_POS(iResolution.xy),\n                    btn_radius_abcd, 0.0);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, B_BTN_UP_POS(iResolution.xy),\n                    btn_radius_abcd, PI);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, B_BTN_DOWN_POS(iResolution.xy),\n                    btn_radius_abcd, 0.0);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, C_BTN_UP_POS(iResolution.xy),\n                    btn_radius_abcd, PI);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, C_BTN_DOWN_POS(iResolution.xy),\n                    btn_radius_abcd, 0.0);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, D_BTN_UP_POS(iResolution.xy),\n                    btn_radius_abcd, PI);\n    button_layer +=\n        draw_button(fragCoord, iMouse.xy, D_BTN_DOWN_POS(iResolution.xy),\n                    btn_radius_abcd, 0.0);\n\n    mat2 M_inv_unused;\n    float show_cross;\n    mat2 M_anim = getAnimatedMatrix(M_inv_unused, show_cross);\n    vec2 twisted_slope = M_anim * vec2(p, q);\n\n    int word[MAX_WORD_LEN];\n    int word_len = generateSturmianWord(twisted_slope, word);\n\n    if (word_len > 0) {\n        text_dist =\n            min(text_dist, get_string_dist(iChannel1, fragCoord,\n                                           STURMIAN_WORD_POS(iResolution.xy),\n                                           sturmian_size, word, word_len));\n        float char_spacing = sturmian_size * 0.8;\n        float word_pixel_width = float(word_len) * char_spacing;\n        \n        vec2 line_start = sturmian_pos + vec2(-word_pixel_width * 0.5, sturmian_size * 0.8);\n        vec2 line_end = sturmian_pos + vec2(word_pixel_width * 0.5, sturmian_size * 0.8);\n\n        float overline_dist = sdSegment(fragCoord, line_start, line_end);\n        \n        float line_thickness = 3.;\n        final_col = mix(final_col, UI_TEXT_COLOR, 1.0 - smoothstep(0.0, line_thickness, overline_dist));\n    }\n\n    final_col =\n        mix(final_col, UI_TEXT_COLOR, 1.0 - smoothstep(-aa, aa, text_dist));\n    final_col += button_layer;\n    text_dist = 1e5;\n    text_dist =\n        min(text_dist, font_dist(iChannel1,\n                                 fragCoord - vec2(UI_CENTER_X(iResolution.xy),\n                                                  P_NUM_POS(iResolution.xy).y),\n                                 num_size_pq, 47));\n    final_col = mix(final_col, UI_ELEMENT_COLOR,\n                    1.0 - smoothstep(-0.5, 0.5, text_dist));\n    float h_offset = iResolution.y * UI_MATRIX_BRACKET_H_OFFSET_FRAC;\n    float v_offset = iResolution.y * UI_MATRIX_BRACKET_V_OFFSET_FRAC;\n    float line_x_pos_left = A_NUM_POS(iResolution.xy).x - h_offset;\n    float line_x_pos_right = B_NUM_POS(iResolution.xy).x + h_offset;\n    float line_y_start = A_NUM_POS(iResolution.xy).y - v_offset;\n    float line_y_end = C_NUM_POS(iResolution.xy).y + v_offset;\n    float matrix_line =\n        sdSegment(fragCoord, vec2(line_x_pos_left, line_y_start),\n                  vec2(line_x_pos_left, line_y_end));\n    matrix_line = min(matrix_line,\n                      sdSegment(fragCoord, vec2(line_x_pos_right, line_y_start),\n                                vec2(line_x_pos_right, line_y_end)));\n    final_col = mix(final_col, UI_ELEMENT_COLOR,\n                    1.0 - smoothstep(0.8, 1.2, matrix_line));\n\n    if (show_cross > 0.5) {\n        vec2 cross_center = vec2(\n            UI_CENTER_X(iResolution.xy),\n            (A_NUM_POS(iResolution.xy).y + C_NUM_POS(iResolution.xy).y) * 0.5);\n        float cross_size = iResolution.y * UI_CROSS_SIZE_FRAC;\n        vec2 p1 = cross_center + vec2(-cross_size, cross_size);\n        vec2 p2 = cross_center + vec2(cross_size, -cross_size);\n        vec2 p3 = cross_center + vec2(cross_size, cross_size);\n        vec2 p4 = cross_center + vec2(-cross_size, -cross_size);\n        float dist_to_cross =\n            min(sdSegment(fragCoord, p1, p2), sdSegment(fragCoord, p3, p4));\n        float cross_thickness = 1.0;\n        float cross_aa = 1.0;\n        vec3 cross_color = vec3(1.0, 0.2, 0.2);\n        float cross_alpha =\n            1.0 - smoothstep(cross_thickness - cross_aa,\n                             cross_thickness + cross_aa, dist_to_cross);\n        final_col = mix(final_col, cross_color, cross_alpha);\n    }\n\n    if (insideBox(fragCoord, vizBox)) {\n        vec2 local_uv =\n            (fragCoord - (vizBox.xy - vizBox.zw)) / (2.0 * vizBox.zw);\n        vec3 box_col = UI_BACKGROUND_COLOR;\n        float border_width = 0.015;\n        vec2 border_dist = min(local_uv, 1.0 - local_uv);\n        float border_aa = 1.5 / vizBox.z;\n        float border =\n            smoothstep(border_width - border_aa, border_width + border_aa,\n                       min(border_dist.x, border_dist.y));\n        box_col = mix(vec3(1.0), box_col, border);\n\n        vec2 original_slope = vec2(p, q);\n        vec2 final_twisted_slope = M_anim * original_slope;\n\n        float p_viz = abs(final_twisted_slope.x);\n        float q_viz = abs(final_twisted_slope.y);\n\n        float min_dist = 1e5;\n        vec2 current_pos = vec2(1.0 / sqrt(2.0), 0.0);\n\n        vec2 dir = normalize(vec2(q_viz, p_viz));\n        for (int i = 0; i < 30; i++) {\n            vec2 inv_dir = 1.0 / (dir + 1e-9);\n            vec2 t_bounds;\n            if (dir.x > 0.0)\n                t_bounds.x = (1.0 - current_pos.x) * inv_dir.x;\n            else\n                t_bounds.x = (0.0 - current_pos.x) * inv_dir.x;\n            if (dir.y > 0.0)\n                t_bounds.y = (1.0 - current_pos.y) * inv_dir.y;\n            else\n                t_bounds.y = (0.0 - current_pos.y) * inv_dir.y;\n\n            float t_step = min(t_bounds.x, t_bounds.y);\n            vec2 end_point = current_pos + t_step * dir;\n            min_dist =\n                min(min_dist, sdSegment(local_uv, current_pos, end_point));\n\n            if (abs(end_point.x - 0.0) < 1e-5) {\n                end_point.x = 1.0;\n            } else if (abs(end_point.x - 1.0) < 1e-5) {\n                end_point.x = 0.0;\n            }\n            if (abs(end_point.y - 0.0) < 1e-5) {\n                end_point.y = 1.0;\n            } else if (abs(end_point.y - 1.0) < 1e-5) {\n                end_point.y = 0.0;\n            }\n\n            current_pos = end_point;\n        }\n        float line_width = 0.008;\n        float line_aa = 2.0 / viz_size;\n        float billiard_line = 1.0 - smoothstep(line_width - line_aa,\n                                               line_width + line_aa, min_dist);\n\n        box_col = mix(box_col, UI_ACCENT_COLOR, billiard_line);\n        final_col = box_col;\n    }\n    return final_col;\n}\n\nvec3 render(in vec2 fragCoord) {\n    vec3 col;\n    float ui_width = UI_WIDTH_PIXELS(iResolution.xy);\n    if (fragCoord.x < ui_width) {\n        vec2 pq = texelFetch(iChannel0, REG_PQ, 0).xy;\n        vec2 ab = texelFetch(iChannel0, REG_MATRIX_AB, 0).xy;\n        vec2 cd = texelFetch(iChannel0, REG_MATRIX_CD, 0).xy;\n        col = render_ui(fragCoord, pq.x, pq.y, ab.x, ab.y, cd.x, cd.y);\n        float border =\n            smoothstep(0.0, 2.0 / iResolution.x, abs(fragCoord.x - ui_width));\n        col = mix(col, UI_BORDER_COLOR, 1.0 - border);\n    } else {\n        vec2 pq = texelFetch(iChannel0, REG_PQ, 0).xy;\n        vec2 camera_rot = texelFetch(iChannel0, REG_CAMERA, 0).xy;\n        vec2 scene_coord = fragCoord - vec2(ui_width, 0.0);\n        vec2 scene_res = vec2(iResolution.x - ui_width, iResolution.y);\n        col = render_scene(scene_coord, scene_res, pq.x, pq.y, camera_rot);\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 total_col = vec3(0.0);\n#if AA > 1\n    for (int m = 0; m < AA; m++) {\n        for (int n = 0; n < AA; n++) {\n            vec2 offset = (vec2(float(m), float(n)) + 0.5) / float(AA);\n            vec2 sub_pixel_coord = floor(fragCoord) + offset;\n            total_col += render(sub_pixel_coord);\n        }\n    }\n    total_col /= float(AA * AA);\n#else\n    total_col = render(fragCoord);\n#endif\n    total_col +=\n        fract(sin(fragCoord.x * vec3(13, 1, 11) + fragCoord.y * vec3(1, 7, 5)) *\n              158.391832) /\n        255.0;\n    fragColor = vec4(total_col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\n// --- UI Theming Constants ---\n#define UI_WIDTH_FRAC 0.25\n#define UI_BACKGROUND_COLOR vec3(0.1, 0.12, 0.15)\n#define UI_TEXT_COLOR vec3(0.9)\n#define UI_ELEMENT_COLOR vec3(0.9)\n#define UI_BUTTON_COLOR vec3(0.4)\n#define UI_BUTTON_HOVER_COLOR vec3(0.8, 0., 0.8)\n#define UI_ACCENT_COLOR vec3(1.0, 0.7, 0.2)\n#define UI_BORDER_COLOR vec3(0.05)\n\n// --- UI Layout Base Constants (RESTORED TO YOUR ORIGINAL VALUES) ---\n#define DESIGN_RESOLUTION_Y 540.0\n#define UI_SLOPE_TITLE_Y_FRAC (20.0 / DESIGN_RESOLUTION_Y)\n#define UI_SLOPE_NUM_Y_FRAC (80.0 / DESIGN_RESOLUTION_Y)\n#define UI_SLOPE_NUM_X_FRAC 0.2\n#define UI_PQ_BTN_Y_SPACING_FRAC (30.0 / DESIGN_RESOLUTION_Y)\n#define UI_PQ_BTN_RADIUS_FRAC (30.0 / DESIGN_RESOLUTION_Y)\n#define UI_TWIST_TITLE_Y_FRAC (150.0 / DESIGN_RESOLUTION_Y)\n#define UI_TWIST_TOP_ROW_Y_FRAC (210.0 / DESIGN_RESOLUTION_Y)\n#define UI_TWIST_BOTTOM_ROW_Y_FRAC (290.0 / DESIGN_RESOLUTION_Y) // Restored\n#define UI_TWIST_NUM_X_FRAC 0.2\n#define UI_ABCD_BTN_Y_SPACING_FRAC (20.0 / DESIGN_RESOLUTION_Y)\n#define UI_ABCD_BTN_RADIUS_FRAC (28.0 / DESIGN_RESOLUTION_Y)\n#define UI_BTN_BBOX_SIZE_FRAC                                                  \\\n    (38.0 / DESIGN_RESOLUTION_Y) // Corrected small size\n#define UI_TITLE_TEXT_SIZE_FRAC (20.0 / DESIGN_RESOLUTION_Y)\n#define UI_PQ_NUM_SIZE_FRAC (30.0 / DESIGN_RESOLUTION_Y)\n#define UI_ABCD_NUM_SIZE_FRAC (20.0 / DESIGN_RESOLUTION_Y)\n#define UI_MATRIX_BRACKET_H_OFFSET_FRAC (30.0 / DESIGN_RESOLUTION_Y)\n#define UI_MATRIX_BRACKET_V_OFFSET_FRAC (110.0 / DESIGN_RESOLUTION_Y)\n#define UI_VIZBOX_Y_OFFSET_FRAC (10.0 / DESIGN_RESOLUTION_Y)\n#define UI_VIZBOX_MARGIN_FRAC (100.0 / DESIGN_RESOLUTION_Y)\n#define UI_CROSS_SIZE_FRAC (12.0 / DESIGN_RESOLUTION_Y)\n\n#define UI_STURMIAN_WORD_Y_FRAC (365.0 / DESIGN_RESOLUTION_Y)\n#define UI_STURMIAN_WORD_SIZE_FRAC (22.0 / DESIGN_RESOLUTION_Y)\n#define UI_VIZBOX_H_PADDING_FRAC 0.15\n#define UI_VIZBOX_V_PADDING_FRAC (20.0 / DESIGN_RESOLUTION_Y)\n#define UI_VIZBOX_BOTTOM_MARGIN_FRAC (20.0 / DESIGN_RESOLUTION_Y)\n// --- UI Layout Calculation Macros ---\n#define UI_WIDTH_PIXELS(res) ((res).x * UI_WIDTH_FRAC)\n#define UI_CENTER_X(res) (UI_WIDTH_PIXELS(res) * 0.5)\n#define SLOPE_TITLE_POS(res)                                                   \\\n    vec2(UI_CENTER_X(res), (res).y * (1.0 - UI_SLOPE_TITLE_Y_FRAC))\n#define P_NUM_POS(res)                                                         \\\n    vec2(UI_CENTER_X(res) - UI_WIDTH_PIXELS(res) * UI_SLOPE_NUM_X_FRAC,        \\\n         (res).y * (1.0 - UI_SLOPE_NUM_Y_FRAC))\n#define Q_NUM_POS(res)                                                         \\\n    vec2(UI_CENTER_X(res) + UI_WIDTH_PIXELS(res) * UI_SLOPE_NUM_X_FRAC,        \\\n         (res).y * (1.0 - UI_SLOPE_NUM_Y_FRAC))\n#define P_BTN_UP_POS(res)                                                      \\\n    (P_NUM_POS(res) + vec2(0.0, (res).y * UI_PQ_BTN_Y_SPACING_FRAC))\n#define P_BTN_DOWN_POS(res)                                                    \\\n    (P_NUM_POS(res) - vec2(0.0, (res).y * UI_PQ_BTN_Y_SPACING_FRAC))\n#define Q_BTN_UP_POS(res)                                                      \\\n    (Q_NUM_POS(res) + vec2(0.0, (res).y * UI_PQ_BTN_Y_SPACING_FRAC))\n#define Q_BTN_DOWN_POS(res)                                                    \\\n    (Q_NUM_POS(res) - vec2(0.0, (res).y * UI_PQ_BTN_Y_SPACING_FRAC))\n#define TWIST_TITLE_POS(res)                                                   \\\n    vec2(UI_CENTER_X(res), (res).y * (1.0 - UI_TWIST_TITLE_Y_FRAC))\n#define A_NUM_POS(res)                                                         \\\n    (vec2(UI_CENTER_X(res), (res).y * (1.0 - UI_TWIST_TOP_ROW_Y_FRAC)) -       \\\n     vec2(UI_WIDTH_PIXELS(res) * UI_TWIST_NUM_X_FRAC, 0.0))\n#define B_NUM_POS(res)                                                         \\\n    (vec2(UI_CENTER_X(res), (res).y * (1.0 - UI_TWIST_TOP_ROW_Y_FRAC)) +       \\\n     vec2(UI_WIDTH_PIXELS(res) * UI_TWIST_NUM_X_FRAC, 0.0))\n#define C_NUM_POS(res)                                                         \\\n    (vec2(UI_CENTER_X(res), (res).y * (1.0 - UI_TWIST_BOTTOM_ROW_Y_FRAC)) -    \\\n     vec2(UI_WIDTH_PIXELS(res) * UI_TWIST_NUM_X_FRAC, 0.0))\n#define D_NUM_POS(res)                                                         \\\n    (vec2(UI_CENTER_X(res), (res).y * (1.0 - UI_TWIST_BOTTOM_ROW_Y_FRAC)) +    \\\n     vec2(UI_WIDTH_PIXELS(res) * UI_TWIST_NUM_X_FRAC, 0.0))\n#define A_BTN_UP_POS(res)                                                      \\\n    (A_NUM_POS(res) + vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define A_BTN_DOWN_POS(res)                                                    \\\n    (A_NUM_POS(res) - vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define B_BTN_UP_POS(res)                                                      \\\n    (B_NUM_POS(res) + vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define B_BTN_DOWN_POS(res)                                                    \\\n    (B_NUM_POS(res) - vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define C_BTN_UP_POS(res)                                                      \\\n    (C_NUM_POS(res) + vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define C_BTN_DOWN_POS(res)                                                    \\\n    (C_NUM_POS(res) - vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define D_BTN_UP_POS(res)                                                      \\\n    (D_NUM_POS(res) + vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define D_BTN_DOWN_POS(res)                                                    \\\n    (D_NUM_POS(res) - vec2(0.0, (res).y * UI_ABCD_BTN_Y_SPACING_FRAC))\n#define P_UP_BOX(res)                                                          \\\n    vec4(P_BTN_UP_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define P_DOWN_BOX(res)                                                        \\\n    vec4(P_BTN_DOWN_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define Q_UP_BOX(res)                                                          \\\n    vec4(Q_BTN_UP_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define Q_DOWN_BOX(res)                                                        \\\n    vec4(Q_BTN_DOWN_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define A_UP_BOX(res)                                                          \\\n    vec4(A_BTN_UP_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define A_DOWN_BOX(res)                                                        \\\n    vec4(A_BTN_DOWN_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define B_UP_BOX(res)                                                          \\\n    vec4(B_BTN_UP_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define B_DOWN_BOX(res)                                                        \\\n    vec4(B_BTN_DOWN_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define C_UP_BOX(res)                                                          \\\n    vec4(C_BTN_UP_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define C_DOWN_BOX(res)                                                        \\\n    vec4(C_BTN_DOWN_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define D_UP_BOX(res)                                                          \\\n    vec4(D_BTN_UP_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define D_DOWN_BOX(res)                                                        \\\n    vec4(D_BTN_DOWN_POS(res), vec2((res).y *UI_BTN_BBOX_SIZE_FRAC) * 0.5)\n#define STURMIAN_WORD_POS(res)                                                 \\\n    vec2(UI_CENTER_X(res), (res).y * (1.0 - UI_STURMIAN_WORD_Y_FRAC))\n\n// --- Buffer Register Definitions ---\n#define REG_PQ ivec2(0, 0)\n#define REG_MATRIX_AB ivec2(1, 0)\n#define REG_MATRIX_CD ivec2(2, 0)\n#define REG_MOUSE ivec2(3, 0)\n#define REG_CAMERA ivec2(4, 0)\n#define REG_ACTIVE_MATRIX_AB ivec2(5, 0)\n#define REG_ACTIVE_MATRIX_CD ivec2(6, 0)\n#define REG_OLD_ACTIVE_MATRIX_AB ivec2(7, 0)\n#define REG_OLD_ACTIVE_MATRIX_CD ivec2(8, 0)\n#define REG_ANIM_TIMER ivec2(9, 0)\n\n// --- General Drawing & Math Functions ---\nfloat sdTriangle(vec2 p) {\n    p.y = -p.y;\n    return max(abs(p.x) * 0.866025 + p.y * 0.5, -p.y);\n}\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\nbool insideBox(vec2 p, vec4 b) {\n    vec2 q = abs(p - b.xy);\n    return all(lessThan(q, b.zw));\n}\nfloat font_dist(sampler2D font_texture, vec2 tpos, float size, int char_code) {\n    if (char_code < 32 || char_code > 127)\n        return 1e5;\n    float scl = 0.63 / size;\n    vec2 uv = tpos * scl;\n    ivec2 grid_pos = ivec2(char_code % 16, 15 - (char_code / 16));\n    vec2 font_uv = (uv + vec2(grid_pos) + 0.5) * (1.0 / 16.0);\n    float dist_from_tex = texture(font_texture, font_uv).a - 0.5;\n    vec2 box = abs(uv) - 0.5;\n    return max(dist_from_tex, max(box.x, box.y)) / scl;\n}\n\n#define MAX_UI_STRING_LEN 24\nfloat get_string_dist(sampler2D font_texture, vec2 fragCoord, vec2 p,\n                      float size, in int chars[MAX_UI_STRING_LEN], int len) {\n    vec2 text_pos = fragCoord - p;\n    float char_spacing = size * 0.8;\n    float x_offset = text_pos.x + float(len - 1) * 0.5 * char_spacing;\n    int char_idx = int(floor(x_offset / char_spacing + 0.5));\n    if (char_idx < 0 || char_idx >= len)\n        return 1e5;\n    vec2 char_center_offset = vec2(float(char_idx) * char_spacing -\n                                       float(len - 1) * 0.5 * char_spacing,\n                                   0.0);\n    return font_dist(font_texture, text_pos - char_center_offset, size,\n                     chars[char_idx]);\n}\n\nfloat get_number_dist(sampler2D font_texture, vec2 fragCoord, vec2 p,\n                      float size, float num) {\n    vec2 text_pos = fragCoord - p;\n    float char_spacing = size * 0.7;\n    float num_abs = abs(num);\n    bool is_neg = num < 0.0;\n    int whole_part = int(floor(num_abs));\n    int num_digits = (whole_part == 0)\n                         ? 1\n                         : int(floor(log2(float(whole_part)) / log2(10.0))) + 1;\n    float total_width = float(num_digits) * char_spacing;\n    if (is_neg)\n        total_width += char_spacing;\n    float x_offset = text_pos.x + total_width * 0.5;\n    if (is_neg) {\n        if (x_offset < char_spacing) {\n            return font_dist(\n                font_texture,\n                text_pos - vec2(-total_width * 0.5 + char_spacing * 0.5, 0.0),\n                size, 45);\n        }\n        x_offset -= char_spacing;\n    }\n    int digit_idx = int(floor(x_offset / char_spacing));\n    if (digit_idx < 0 || digit_idx >= num_digits)\n        return 1e5;\n    float power_of_10 = pow(10.0, float(num_digits - 1 - digit_idx));\n    int digit = int(mod(floor(float(whole_part) / power_of_10), 10.0));\n    vec2 digit_center_offset =\n        vec2((is_neg ? char_spacing : 0.0) - total_width * 0.5 +\n                 (float(digit_idx) + 0.5) * char_spacing,\n             0.0);\n    return font_dist(font_texture, text_pos - digit_center_offset, size,\n                     digit + 48);\n}\nvec3 draw_button(vec2 fragCoord, vec2 mouseCoord, vec2 center, float size,\n                 float orientation) {\n    vec2 p = fragCoord - center;\n    mat2 rot = mat2(cos(orientation), -sin(orientation), sin(orientation),\n                    cos(orientation));\n    p = rot * p;\n    float d = sdTriangle(p / size);\n    vec3 col = UI_BUTTON_COLOR;\n    if (length(center - mouseCoord) < size * 1.1) {\n        col = UI_BUTTON_HOVER_COLOR;\n    }\n    float aa = fwidth(abs(d));\n    return mix(vec3(0.0), col, 1.0 - smoothstep(0.15 - aa, 0.15 + aa, d));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 fc = ivec2(fragCoord);\n    fragColor = texelFetch(iChannel0, fc, 0);\n\n    if (iFrame == 0) {\n        if (fc == REG_PQ) fragColor = vec4(2.0, 5.0, 0.0, 0.0);\n        if (fc == REG_MATRIX_AB) fragColor = vec4(1.0, 0.0, 0.0, 0.0);\n        if (fc == REG_MATRIX_CD) fragColor = vec4(0.0, 1.0, 0.0, 0.0);\n        if (fc == REG_MOUSE) fragColor = vec4(-1.0, -1.0, 0.0, 0.0);\n        if (fc == REG_CAMERA) fragColor = vec4(0.0, 0.6, 0.0, 0.0);\n        if (fc == REG_ACTIVE_MATRIX_AB) fragColor = vec4(1.0, 0.0, 0.0, 0.0);\n        if (fc == REG_ACTIVE_MATRIX_CD) fragColor = vec4(0.0, 1.0, 0.0, 0.0);\n        if (fc == REG_OLD_ACTIVE_MATRIX_AB) fragColor = vec4(1.0, 0.0, 0.0, 0.0);\n        if (fc == REG_OLD_ACTIVE_MATRIX_CD) fragColor = vec4(0.0, 1.0, 0.0, 0.0);\n        if (fc == REG_ANIM_TIMER) fragColor = vec4(2.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    vec2 pq = texelFetch(iChannel0, REG_PQ, 0).xy;\n    vec2 display_ab = texelFetch(iChannel0, REG_MATRIX_AB, 0).xy;\n    vec2 display_cd = texelFetch(iChannel0, REG_MATRIX_CD, 0).xy;\n    vec2 active_ab = texelFetch(iChannel0, REG_ACTIVE_MATRIX_AB, 0).xy;\n    vec2 active_cd = texelFetch(iChannel0, REG_ACTIVE_MATRIX_CD, 0).xy;\n    vec2 old_active_ab = texelFetch(iChannel0, REG_OLD_ACTIVE_MATRIX_AB, 0).xy;\n    vec2 old_active_cd = texelFetch(iChannel0, REG_OLD_ACTIVE_MATRIX_CD, 0).xy;\n    \n    vec4 anim_state = texelFetch(iChannel0, REG_ANIM_TIMER, 0);\n    float anim_timer = anim_state.x;\n    float show_cross = anim_state.y;\n    \n    vec4 prev_mouse = texelFetch(iChannel0, REG_MOUSE, 0);\n    vec2 camera_rot = texelFetch(iChannel0, REG_CAMERA, 0).xy;\n    \n    bool mouse_clicked = iMouse.z > 0.0 && prev_mouse.z <= 0.0;\n    \n    if(anim_timer < 1.0) {\n        anim_timer += 0.04;\n    }\n\n    if (iMouse.x < UI_WIDTH_PIXELS(iResolution.xy)) {\n        if (mouse_clicked) {\n            bool matrix_button_clicked = false;\n            vec2 prospective_ab = display_ab;\n            vec2 prospective_cd = display_cd;\n\n            if      (insideBox(iMouse.xy, P_UP_BOX(iResolution.xy)))   { pq.x++; }\n            else if (insideBox(iMouse.xy, P_DOWN_BOX(iResolution.xy))) { pq.x--; }\n            else if (insideBox(iMouse.xy, Q_UP_BOX(iResolution.xy)))   { pq.y++; }\n            else if (insideBox(iMouse.xy, Q_DOWN_BOX(iResolution.xy))) { pq.y--; }\n            \n            else if (insideBox(iMouse.xy, A_UP_BOX(iResolution.xy)))   { prospective_ab.x++; matrix_button_clicked = true; }\n            else if (insideBox(iMouse.xy, A_DOWN_BOX(iResolution.xy))) { prospective_ab.x--; matrix_button_clicked = true; }\n            else if (insideBox(iMouse.xy, B_UP_BOX(iResolution.xy)))   { prospective_ab.y++; matrix_button_clicked = true; }\n            else if (insideBox(iMouse.xy, B_DOWN_BOX(iResolution.xy))) { prospective_ab.y--; matrix_button_clicked = true; }\n            \n            else if (insideBox(iMouse.xy, C_UP_BOX(iResolution.xy)))   { prospective_cd.x++; matrix_button_clicked = true; }\n            else if (insideBox(iMouse.xy, C_DOWN_BOX(iResolution.xy))) { prospective_cd.x--; matrix_button_clicked = true; }\n            else if (insideBox(iMouse.xy, D_UP_BOX(iResolution.xy)))   { prospective_cd.y++; matrix_button_clicked = true; }\n            else if (insideBox(iMouse.xy, D_DOWN_BOX(iResolution.xy))) { prospective_cd.y--; matrix_button_clicked = true; }\n            \n            if (matrix_button_clicked) {\n                display_ab = prospective_ab;\n                display_cd = prospective_cd;\n\n                float det = display_ab.x * display_cd.y - display_ab.y * display_cd.x;\n                if (abs(det - 1.0) < 0.0001) {\n                    old_active_ab = active_ab;\n                    old_active_cd = active_cd;\n                    active_ab = display_ab;\n                    active_cd = display_cd;\n                    anim_timer = 0.0;\n                    show_cross = 0.0;\n                } else {\n                    anim_timer = 2.0;\n                    show_cross = 1.0;\n                }\n            }\n        }\n    } \n    else if (iMouse.z > 0.0) {\n        vec2 delta = iMouse.xy - prev_mouse.xy;\n        camera_rot.x -= delta.x * 0.005;\n        camera_rot.y += delta.y * 0.005;\n        camera_rot.y = clamp(camera_rot.y, -PI / 2.0 + 0.05, PI / 2.0 - 0.05);\n    }\n\n    if (fc == REG_PQ) fragColor = vec4(pq, 0, 0);\n    if (fc == REG_MATRIX_AB) fragColor = vec4(display_ab, 0, 0);\n    if (fc == REG_MATRIX_CD) fragColor = vec4(display_cd, 0, 0);\n    if (fc == REG_MOUSE) fragColor = iMouse;\n    if (fc == REG_CAMERA) fragColor = vec4(camera_rot, 0, 0);\n    if (fc == REG_ACTIVE_MATRIX_AB) fragColor = vec4(active_ab, 0, 0);\n    if (fc == REG_ACTIVE_MATRIX_CD) fragColor = vec4(active_cd, 0, 0);\n    if (fc == REG_OLD_ACTIVE_MATRIX_AB) fragColor = vec4(old_active_ab, 0, 0);\n    if (fc == REG_OLD_ACTIVE_MATRIX_CD) fragColor = vec4(old_active_cd, 0, 0);\n    if (fc == REG_ANIM_TIMER) fragColor = vec4(anim_timer, show_cross, 0.0, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}]}